
/**
 * Client
**/

import * as runtime from './runtime/library';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Category
 * 
 */
export type Category = {
  id: number
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Menu
 * 
 */
export type Menu = {
  id: number
  name: string
  image: string
  price: number
  categoryId: number | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Order
 * 
 */
export type Order = {
  id: number
  status: string
  tableId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model OrderItem
 * 
 */
export type OrderItem = {
  id: number
  menuId: number
  orderId: number | null
  quantity: number
  totalPrice: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model QuizCategory
 * 
 */
export type QuizCategory = {
  id: number
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Choice
 * 
 */
export type Choice = {
  id: number
  answerText: string
  quizId: number | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Quiz
 * 
 */
export type Quiz = {
  id: number
  questionText: string
  quizCategoryId: number
  correctChoiceId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Round
 * 
 */
export type Round = {
  id: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model FacebookUser
 * 
 */
export type FacebookUser = {
  id: number
  name: string
  imageUrl: string
  bio: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model FacebookUserRelation
 * 
 */
export type FacebookUserRelation = {
  id: number
  followingUserId: number
  followedUserId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Post
 * 
 */
export type Post = {
  id: number
  postText: string
  userId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Comment
 * 
 */
export type Comment = {
  id: number
  commentText: string
  userId: number
  postId: number
  parentCommentId: number | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model FacebookHashTag
 * 
 */
export type FacebookHashTag = {
  id: number
  hashTagText: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model MessengerMessage
 * 
 */
export type MessengerMessage = {
  id: number
  messengerText: string
  fromUserId: number
  toUserId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model TodoList
 * 
 */
export type TodoList = {
  id: number
  task: string
  status: string
  bgColor: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model User
 * 
 */
export type User = {
  id: number
  name: string
  imageUrl: string
  bio: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model UserRelation
 * 
 */
export type UserRelation = {
  id: number
  followingUserId: number
  followedUserId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Tweet
 * 
 */
export type Tweet = {
  id: number
  tweetText: string
  parentTweetId: number | null
  userId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model HashTag
 * 
 */
export type HashTag = {
  id: number
  hashTagText: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model DirectMessage
 * 
 */
export type DirectMessage = {
  id: number
  dmText: string
  fromUserId: number
  toUserId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model YouTubeUser
 * 
 */
export type YouTubeUser = {
  id: number
  name: string
  profileImageUrl: string | null
  bio: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Channel
 * 
 */
export type Channel = {
  id: number
  name: string
  profileImageUrl: string | null
  description: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model UserToChannelwithRole
 * 
 */
export type UserToChannelwithRole = {
  id: number
  youTubeUserId: number
  channelId: number
  role: RoleEnum
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Video
 * 
 */
export type Video = {
  id: number
  title: string
  videoUrl: string
  thumbnailImageUrl: string | null
  description: string | null
  channelId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model UserToVideoWithReaction
 * 
 */
export type UserToVideoWithReaction = {
  id: number
  youTubeUserId: number
  videoId: number
  reaction: ReactionEnum
  createdAt: Date
  updatedAt: Date
}

/**
 * Model VideoComment
 * 
 */
export type VideoComment = {
  id: number
  commentText: string
  youTubeUserId: number
  videoId: number
  parentVideoCommentId: number | null
  createdAt: Date
  updatedAt: Date
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const ReactionEnum: {
  LIKE: 'LIKE',
  DISLIKE: 'DISLIKE'
};

export type ReactionEnum = (typeof ReactionEnum)[keyof typeof ReactionEnum]


export const RoleEnum: {
  MANAGER: 'MANAGER',
  EDITOR: 'EDITOR',
  VIEWER: 'VIEWER'
};

export type RoleEnum = (typeof RoleEnum)[keyof typeof RoleEnum]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Categories
 * const categories = await prisma.category.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Categories
   * const categories = await prisma.category.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<GlobalReject>;

  /**
   * `prisma.menu`: Exposes CRUD operations for the **Menu** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Menus
    * const menus = await prisma.menu.findMany()
    * ```
    */
  get menu(): Prisma.MenuDelegate<GlobalReject>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<GlobalReject>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<GlobalReject>;

  /**
   * `prisma.quizCategory`: Exposes CRUD operations for the **QuizCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizCategories
    * const quizCategories = await prisma.quizCategory.findMany()
    * ```
    */
  get quizCategory(): Prisma.QuizCategoryDelegate<GlobalReject>;

  /**
   * `prisma.choice`: Exposes CRUD operations for the **Choice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Choices
    * const choices = await prisma.choice.findMany()
    * ```
    */
  get choice(): Prisma.ChoiceDelegate<GlobalReject>;

  /**
   * `prisma.quiz`: Exposes CRUD operations for the **Quiz** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quizzes
    * const quizzes = await prisma.quiz.findMany()
    * ```
    */
  get quiz(): Prisma.QuizDelegate<GlobalReject>;

  /**
   * `prisma.round`: Exposes CRUD operations for the **Round** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rounds
    * const rounds = await prisma.round.findMany()
    * ```
    */
  get round(): Prisma.RoundDelegate<GlobalReject>;

  /**
   * `prisma.facebookUser`: Exposes CRUD operations for the **FacebookUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FacebookUsers
    * const facebookUsers = await prisma.facebookUser.findMany()
    * ```
    */
  get facebookUser(): Prisma.FacebookUserDelegate<GlobalReject>;

  /**
   * `prisma.facebookUserRelation`: Exposes CRUD operations for the **FacebookUserRelation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FacebookUserRelations
    * const facebookUserRelations = await prisma.facebookUserRelation.findMany()
    * ```
    */
  get facebookUserRelation(): Prisma.FacebookUserRelationDelegate<GlobalReject>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<GlobalReject>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<GlobalReject>;

  /**
   * `prisma.facebookHashTag`: Exposes CRUD operations for the **FacebookHashTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FacebookHashTags
    * const facebookHashTags = await prisma.facebookHashTag.findMany()
    * ```
    */
  get facebookHashTag(): Prisma.FacebookHashTagDelegate<GlobalReject>;

  /**
   * `prisma.messengerMessage`: Exposes CRUD operations for the **MessengerMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessengerMessages
    * const messengerMessages = await prisma.messengerMessage.findMany()
    * ```
    */
  get messengerMessage(): Prisma.MessengerMessageDelegate<GlobalReject>;

  /**
   * `prisma.todoList`: Exposes CRUD operations for the **TodoList** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TodoLists
    * const todoLists = await prisma.todoList.findMany()
    * ```
    */
  get todoList(): Prisma.TodoListDelegate<GlobalReject>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.userRelation`: Exposes CRUD operations for the **UserRelation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRelations
    * const userRelations = await prisma.userRelation.findMany()
    * ```
    */
  get userRelation(): Prisma.UserRelationDelegate<GlobalReject>;

  /**
   * `prisma.tweet`: Exposes CRUD operations for the **Tweet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tweets
    * const tweets = await prisma.tweet.findMany()
    * ```
    */
  get tweet(): Prisma.TweetDelegate<GlobalReject>;

  /**
   * `prisma.hashTag`: Exposes CRUD operations for the **HashTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HashTags
    * const hashTags = await prisma.hashTag.findMany()
    * ```
    */
  get hashTag(): Prisma.HashTagDelegate<GlobalReject>;

  /**
   * `prisma.directMessage`: Exposes CRUD operations for the **DirectMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DirectMessages
    * const directMessages = await prisma.directMessage.findMany()
    * ```
    */
  get directMessage(): Prisma.DirectMessageDelegate<GlobalReject>;

  /**
   * `prisma.youTubeUser`: Exposes CRUD operations for the **YouTubeUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YouTubeUsers
    * const youTubeUsers = await prisma.youTubeUser.findMany()
    * ```
    */
  get youTubeUser(): Prisma.YouTubeUserDelegate<GlobalReject>;

  /**
   * `prisma.channel`: Exposes CRUD operations for the **Channel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Channels
    * const channels = await prisma.channel.findMany()
    * ```
    */
  get channel(): Prisma.ChannelDelegate<GlobalReject>;

  /**
   * `prisma.userToChannelwithRole`: Exposes CRUD operations for the **UserToChannelwithRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserToChannelwithRoles
    * const userToChannelwithRoles = await prisma.userToChannelwithRole.findMany()
    * ```
    */
  get userToChannelwithRole(): Prisma.UserToChannelwithRoleDelegate<GlobalReject>;

  /**
   * `prisma.video`: Exposes CRUD operations for the **Video** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Videos
    * const videos = await prisma.video.findMany()
    * ```
    */
  get video(): Prisma.VideoDelegate<GlobalReject>;

  /**
   * `prisma.userToVideoWithReaction`: Exposes CRUD operations for the **UserToVideoWithReaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserToVideoWithReactions
    * const userToVideoWithReactions = await prisma.userToVideoWithReaction.findMany()
    * ```
    */
  get userToVideoWithReaction(): Prisma.UserToVideoWithReactionDelegate<GlobalReject>;

  /**
   * `prisma.videoComment`: Exposes CRUD operations for the **VideoComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VideoComments
    * const videoComments = await prisma.videoComment.findMany()
    * ```
    */
  get videoComment(): Prisma.VideoCommentDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.10.1
   * Query Engine version: aead147aa326ccb985dcfed5b065b4fdabd44b19
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Category: 'Category',
    Menu: 'Menu',
    Order: 'Order',
    OrderItem: 'OrderItem',
    QuizCategory: 'QuizCategory',
    Choice: 'Choice',
    Quiz: 'Quiz',
    Round: 'Round',
    FacebookUser: 'FacebookUser',
    FacebookUserRelation: 'FacebookUserRelation',
    Post: 'Post',
    Comment: 'Comment',
    FacebookHashTag: 'FacebookHashTag',
    MessengerMessage: 'MessengerMessage',
    TodoList: 'TodoList',
    User: 'User',
    UserRelation: 'UserRelation',
    Tweet: 'Tweet',
    HashTag: 'HashTag',
    DirectMessage: 'DirectMessage',
    YouTubeUser: 'YouTubeUser',
    Channel: 'Channel',
    UserToChannelwithRole: 'UserToChannelwithRole',
    Video: 'Video',
    UserToVideoWithReaction: 'UserToVideoWithReaction',
    VideoComment: 'VideoComment'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CategoryCountOutputType
   */


  export type CategoryCountOutputType = {
    Menu: number
  }

  export type CategoryCountOutputTypeSelect = {
    Menu?: boolean
  }

  export type CategoryCountOutputTypeGetPayload<S extends boolean | null | undefined | CategoryCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CategoryCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CategoryCountOutputTypeArgs)
    ? CategoryCountOutputType 
    : S extends { select: any } & (CategoryCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CategoryCountOutputType ? CategoryCountOutputType[P] : never
  } 
      : CategoryCountOutputType




  // Custom InputTypes

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect | null
  }



  /**
   * Count Type MenuCountOutputType
   */


  export type MenuCountOutputType = {
    orderItems: number
  }

  export type MenuCountOutputTypeSelect = {
    orderItems?: boolean
  }

  export type MenuCountOutputTypeGetPayload<S extends boolean | null | undefined | MenuCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MenuCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (MenuCountOutputTypeArgs)
    ? MenuCountOutputType 
    : S extends { select: any } & (MenuCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof MenuCountOutputType ? MenuCountOutputType[P] : never
  } 
      : MenuCountOutputType




  // Custom InputTypes

  /**
   * MenuCountOutputType without action
   */
  export type MenuCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MenuCountOutputType
     */
    select?: MenuCountOutputTypeSelect | null
  }



  /**
   * Count Type OrderCountOutputType
   */


  export type OrderCountOutputType = {
    items: number
  }

  export type OrderCountOutputTypeSelect = {
    items?: boolean
  }

  export type OrderCountOutputTypeGetPayload<S extends boolean | null | undefined | OrderCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? OrderCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (OrderCountOutputTypeArgs)
    ? OrderCountOutputType 
    : S extends { select: any } & (OrderCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof OrderCountOutputType ? OrderCountOutputType[P] : never
  } 
      : OrderCountOutputType




  // Custom InputTypes

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect | null
  }



  /**
   * Count Type QuizCategoryCountOutputType
   */


  export type QuizCategoryCountOutputType = {
    quizzes: number
  }

  export type QuizCategoryCountOutputTypeSelect = {
    quizzes?: boolean
  }

  export type QuizCategoryCountOutputTypeGetPayload<S extends boolean | null | undefined | QuizCategoryCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? QuizCategoryCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (QuizCategoryCountOutputTypeArgs)
    ? QuizCategoryCountOutputType 
    : S extends { select: any } & (QuizCategoryCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof QuizCategoryCountOutputType ? QuizCategoryCountOutputType[P] : never
  } 
      : QuizCategoryCountOutputType




  // Custom InputTypes

  /**
   * QuizCategoryCountOutputType without action
   */
  export type QuizCategoryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the QuizCategoryCountOutputType
     */
    select?: QuizCategoryCountOutputTypeSelect | null
  }



  /**
   * Count Type ChoiceCountOutputType
   */


  export type ChoiceCountOutputType = {
    correctQuizzes: number
    rounds: number
  }

  export type ChoiceCountOutputTypeSelect = {
    correctQuizzes?: boolean
    rounds?: boolean
  }

  export type ChoiceCountOutputTypeGetPayload<S extends boolean | null | undefined | ChoiceCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ChoiceCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ChoiceCountOutputTypeArgs)
    ? ChoiceCountOutputType 
    : S extends { select: any } & (ChoiceCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ChoiceCountOutputType ? ChoiceCountOutputType[P] : never
  } 
      : ChoiceCountOutputType




  // Custom InputTypes

  /**
   * ChoiceCountOutputType without action
   */
  export type ChoiceCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ChoiceCountOutputType
     */
    select?: ChoiceCountOutputTypeSelect | null
  }



  /**
   * Count Type QuizCountOutputType
   */


  export type QuizCountOutputType = {
    choices: number
    rounds: number
  }

  export type QuizCountOutputTypeSelect = {
    choices?: boolean
    rounds?: boolean
  }

  export type QuizCountOutputTypeGetPayload<S extends boolean | null | undefined | QuizCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? QuizCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (QuizCountOutputTypeArgs)
    ? QuizCountOutputType 
    : S extends { select: any } & (QuizCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof QuizCountOutputType ? QuizCountOutputType[P] : never
  } 
      : QuizCountOutputType




  // Custom InputTypes

  /**
   * QuizCountOutputType without action
   */
  export type QuizCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the QuizCountOutputType
     */
    select?: QuizCountOutputTypeSelect | null
  }



  /**
   * Count Type RoundCountOutputType
   */


  export type RoundCountOutputType = {
    quizzes: number
    selectedChoices: number
  }

  export type RoundCountOutputTypeSelect = {
    quizzes?: boolean
    selectedChoices?: boolean
  }

  export type RoundCountOutputTypeGetPayload<S extends boolean | null | undefined | RoundCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RoundCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (RoundCountOutputTypeArgs)
    ? RoundCountOutputType 
    : S extends { select: any } & (RoundCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof RoundCountOutputType ? RoundCountOutputType[P] : never
  } 
      : RoundCountOutputType




  // Custom InputTypes

  /**
   * RoundCountOutputType without action
   */
  export type RoundCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RoundCountOutputType
     */
    select?: RoundCountOutputTypeSelect | null
  }



  /**
   * Count Type FacebookUserCountOutputType
   */


  export type FacebookUserCountOutputType = {
    followingUserRelations: number
    followedUserRelations: number
    posts: number
    comments: number
    messengerMessagesFrom: number
    messengerMessagesTo: number
  }

  export type FacebookUserCountOutputTypeSelect = {
    followingUserRelations?: boolean
    followedUserRelations?: boolean
    posts?: boolean
    comments?: boolean
    messengerMessagesFrom?: boolean
    messengerMessagesTo?: boolean
  }

  export type FacebookUserCountOutputTypeGetPayload<S extends boolean | null | undefined | FacebookUserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FacebookUserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (FacebookUserCountOutputTypeArgs)
    ? FacebookUserCountOutputType 
    : S extends { select: any } & (FacebookUserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof FacebookUserCountOutputType ? FacebookUserCountOutputType[P] : never
  } 
      : FacebookUserCountOutputType




  // Custom InputTypes

  /**
   * FacebookUserCountOutputType without action
   */
  export type FacebookUserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the FacebookUserCountOutputType
     */
    select?: FacebookUserCountOutputTypeSelect | null
  }



  /**
   * Count Type PostCountOutputType
   */


  export type PostCountOutputType = {
    comments: number
    hashTags: number
  }

  export type PostCountOutputTypeSelect = {
    comments?: boolean
    hashTags?: boolean
  }

  export type PostCountOutputTypeGetPayload<S extends boolean | null | undefined | PostCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PostCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (PostCountOutputTypeArgs)
    ? PostCountOutputType 
    : S extends { select: any } & (PostCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof PostCountOutputType ? PostCountOutputType[P] : never
  } 
      : PostCountOutputType




  // Custom InputTypes

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PostCountOutputType
     */
    select?: PostCountOutputTypeSelect | null
  }



  /**
   * Count Type CommentCountOutputType
   */


  export type CommentCountOutputType = {
    childComments: number
  }

  export type CommentCountOutputTypeSelect = {
    childComments?: boolean
  }

  export type CommentCountOutputTypeGetPayload<S extends boolean | null | undefined | CommentCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CommentCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CommentCountOutputTypeArgs)
    ? CommentCountOutputType 
    : S extends { select: any } & (CommentCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CommentCountOutputType ? CommentCountOutputType[P] : never
  } 
      : CommentCountOutputType




  // Custom InputTypes

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect | null
  }



  /**
   * Count Type FacebookHashTagCountOutputType
   */


  export type FacebookHashTagCountOutputType = {
    isInPosts: number
  }

  export type FacebookHashTagCountOutputTypeSelect = {
    isInPosts?: boolean
  }

  export type FacebookHashTagCountOutputTypeGetPayload<S extends boolean | null | undefined | FacebookHashTagCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FacebookHashTagCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (FacebookHashTagCountOutputTypeArgs)
    ? FacebookHashTagCountOutputType 
    : S extends { select: any } & (FacebookHashTagCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof FacebookHashTagCountOutputType ? FacebookHashTagCountOutputType[P] : never
  } 
      : FacebookHashTagCountOutputType




  // Custom InputTypes

  /**
   * FacebookHashTagCountOutputType without action
   */
  export type FacebookHashTagCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the FacebookHashTagCountOutputType
     */
    select?: FacebookHashTagCountOutputTypeSelect | null
  }



  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    followingUserRelations: number
    followedUserRelations: number
    tweets: number
    directMessagesFrom: number
    directMessagesTo: number
  }

  export type UserCountOutputTypeSelect = {
    followingUserRelations?: boolean
    followedUserRelations?: boolean
    tweets?: boolean
    directMessagesFrom?: boolean
    directMessagesTo?: boolean
  }

  export type UserCountOutputTypeGetPayload<S extends boolean | null | undefined | UserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (UserCountOutputTypeArgs)
    ? UserCountOutputType 
    : S extends { select: any } & (UserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
      : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type TweetCountOutputType
   */


  export type TweetCountOutputType = {
    childTweets: number
    hashTags: number
  }

  export type TweetCountOutputTypeSelect = {
    childTweets?: boolean
    hashTags?: boolean
  }

  export type TweetCountOutputTypeGetPayload<S extends boolean | null | undefined | TweetCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TweetCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TweetCountOutputTypeArgs)
    ? TweetCountOutputType 
    : S extends { select: any } & (TweetCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TweetCountOutputType ? TweetCountOutputType[P] : never
  } 
      : TweetCountOutputType




  // Custom InputTypes

  /**
   * TweetCountOutputType without action
   */
  export type TweetCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TweetCountOutputType
     */
    select?: TweetCountOutputTypeSelect | null
  }



  /**
   * Count Type HashTagCountOutputType
   */


  export type HashTagCountOutputType = {
    isInTweets: number
  }

  export type HashTagCountOutputTypeSelect = {
    isInTweets?: boolean
  }

  export type HashTagCountOutputTypeGetPayload<S extends boolean | null | undefined | HashTagCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? HashTagCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (HashTagCountOutputTypeArgs)
    ? HashTagCountOutputType 
    : S extends { select: any } & (HashTagCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof HashTagCountOutputType ? HashTagCountOutputType[P] : never
  } 
      : HashTagCountOutputType




  // Custom InputTypes

  /**
   * HashTagCountOutputType without action
   */
  export type HashTagCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the HashTagCountOutputType
     */
    select?: HashTagCountOutputTypeSelect | null
  }



  /**
   * Count Type YouTubeUserCountOutputType
   */


  export type YouTubeUserCountOutputType = {
    adminOfChannels: number
    usersToChannelswithRoles: number
    subscribingToChannels: number
    reactedVideos: number
    usersToVideosWithReactions: number
    videoComments: number
  }

  export type YouTubeUserCountOutputTypeSelect = {
    adminOfChannels?: boolean
    usersToChannelswithRoles?: boolean
    subscribingToChannels?: boolean
    reactedVideos?: boolean
    usersToVideosWithReactions?: boolean
    videoComments?: boolean
  }

  export type YouTubeUserCountOutputTypeGetPayload<S extends boolean | null | undefined | YouTubeUserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YouTubeUserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (YouTubeUserCountOutputTypeArgs)
    ? YouTubeUserCountOutputType 
    : S extends { select: any } & (YouTubeUserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof YouTubeUserCountOutputType ? YouTubeUserCountOutputType[P] : never
  } 
      : YouTubeUserCountOutputType




  // Custom InputTypes

  /**
   * YouTubeUserCountOutputType without action
   */
  export type YouTubeUserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the YouTubeUserCountOutputType
     */
    select?: YouTubeUserCountOutputTypeSelect | null
  }



  /**
   * Count Type ChannelCountOutputType
   */


  export type ChannelCountOutputType = {
    adminUsers: number
    subscribedUsers: number
    usersToChannelswithRoles: number
    owningVideos: number
  }

  export type ChannelCountOutputTypeSelect = {
    adminUsers?: boolean
    subscribedUsers?: boolean
    usersToChannelswithRoles?: boolean
    owningVideos?: boolean
  }

  export type ChannelCountOutputTypeGetPayload<S extends boolean | null | undefined | ChannelCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ChannelCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ChannelCountOutputTypeArgs)
    ? ChannelCountOutputType 
    : S extends { select: any } & (ChannelCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ChannelCountOutputType ? ChannelCountOutputType[P] : never
  } 
      : ChannelCountOutputType




  // Custom InputTypes

  /**
   * ChannelCountOutputType without action
   */
  export type ChannelCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ChannelCountOutputType
     */
    select?: ChannelCountOutputTypeSelect | null
  }



  /**
   * Count Type VideoCountOutputType
   */


  export type VideoCountOutputType = {
    reactedByYouTubeUsers: number
    usersToVideosWithReactions: number
    videoComments: number
  }

  export type VideoCountOutputTypeSelect = {
    reactedByYouTubeUsers?: boolean
    usersToVideosWithReactions?: boolean
    videoComments?: boolean
  }

  export type VideoCountOutputTypeGetPayload<S extends boolean | null | undefined | VideoCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? VideoCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (VideoCountOutputTypeArgs)
    ? VideoCountOutputType 
    : S extends { select: any } & (VideoCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof VideoCountOutputType ? VideoCountOutputType[P] : never
  } 
      : VideoCountOutputType




  // Custom InputTypes

  /**
   * VideoCountOutputType without action
   */
  export type VideoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the VideoCountOutputType
     */
    select?: VideoCountOutputTypeSelect | null
  }



  /**
   * Count Type VideoCommentCountOutputType
   */


  export type VideoCommentCountOutputType = {
    childVideoComments: number
  }

  export type VideoCommentCountOutputTypeSelect = {
    childVideoComments?: boolean
  }

  export type VideoCommentCountOutputTypeGetPayload<S extends boolean | null | undefined | VideoCommentCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? VideoCommentCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (VideoCommentCountOutputTypeArgs)
    ? VideoCommentCountOutputType 
    : S extends { select: any } & (VideoCommentCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof VideoCommentCountOutputType ? VideoCommentCountOutputType[P] : never
  } 
      : VideoCommentCountOutputType




  // Custom InputTypes

  /**
   * VideoCommentCountOutputType without action
   */
  export type VideoCommentCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the VideoCommentCountOutputType
     */
    select?: VideoCommentCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model Category
   */


  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type CategorySumAggregateOutputType = {
    id: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    id?: true
  }

  export type CategorySumAggregateInputType = {
    id?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: Enumerable<CategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs = {
    where?: CategoryWhereInput
    orderBy?: Enumerable<CategoryOrderByWithAggregationInput>
    by: CategoryScalarFieldEnum[]
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }


  export type CategoryGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Menu?: boolean | Category$MenuArgs
    _count?: boolean | CategoryCountOutputTypeArgs
  }


  export type CategoryInclude = {
    Menu?: boolean | Category$MenuArgs
    _count?: boolean | CategoryCountOutputTypeArgs
  }

  export type CategoryGetPayload<S extends boolean | null | undefined | CategoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Category :
    S extends undefined ? never :
    S extends { include: any } & (CategoryArgs | CategoryFindManyArgs)
    ? Category  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Menu' ? Array < MenuGetPayload<S['include'][P]>>  :
        P extends '_count' ? CategoryCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CategoryArgs | CategoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Menu' ? Array < MenuGetPayload<S['select'][P]>>  :
        P extends '_count' ? CategoryCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Category ? Category[P] : never
  } 
      : Category


  type CategoryCountArgs = 
    Omit<CategoryFindManyArgs, 'select' | 'include'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CategoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CategoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Category'> extends True ? Prisma__CategoryClient<CategoryGetPayload<T>> : Prisma__CategoryClient<CategoryGetPayload<T> | null, null>

    /**
     * Find one Category that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CategoryFindUniqueOrThrowArgs>
    ): Prisma__CategoryClient<CategoryGetPayload<T>>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CategoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CategoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Category'> extends True ? Prisma__CategoryClient<CategoryGetPayload<T>> : Prisma__CategoryClient<CategoryGetPayload<T> | null, null>

    /**
     * Find the first Category that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CategoryFindFirstOrThrowArgs>
    ): Prisma__CategoryClient<CategoryGetPayload<T>>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CategoryFindManyArgs>(
      args?: SelectSubset<T, CategoryFindManyArgs>
    ): Prisma.PrismaPromise<Array<CategoryGetPayload<T>>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
    **/
    create<T extends CategoryCreateArgs>(
      args: SelectSubset<T, CategoryCreateArgs>
    ): Prisma__CategoryClient<CategoryGetPayload<T>>

    /**
     * Create many Categories.
     *     @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     *     @example
     *     // Create many Categories
     *     const category = await prisma.category.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CategoryCreateManyArgs>(
      args?: SelectSubset<T, CategoryCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
    **/
    delete<T extends CategoryDeleteArgs>(
      args: SelectSubset<T, CategoryDeleteArgs>
    ): Prisma__CategoryClient<CategoryGetPayload<T>>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CategoryUpdateArgs>(
      args: SelectSubset<T, CategoryUpdateArgs>
    ): Prisma__CategoryClient<CategoryGetPayload<T>>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CategoryDeleteManyArgs>(
      args?: SelectSubset<T, CategoryDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CategoryUpdateManyArgs>(
      args: SelectSubset<T, CategoryUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
    **/
    upsert<T extends CategoryUpsertArgs>(
      args: SelectSubset<T, CategoryUpsertArgs>
    ): Prisma__CategoryClient<CategoryGetPayload<T>>

    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CategoryClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Menu<T extends Category$MenuArgs= {}>(args?: Subset<T, Category$MenuArgs>): Prisma.PrismaPromise<Array<MenuGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Category base type for findUnique actions
   */
  export type CategoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUnique
   */
  export interface CategoryFindUniqueArgs extends CategoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }


  /**
   * Category base type for findFirst actions
   */
  export type CategoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: Enumerable<CategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }

  /**
   * Category findFirst
   */
  export interface CategoryFindFirstArgs extends CategoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: Enumerable<CategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }


  /**
   * Category findMany
   */
  export type CategoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: Enumerable<CategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }


  /**
   * Category create
   */
  export type CategoryCreateArgs = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }


  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs = {
    /**
     * The data used to create many Categories.
     */
    data: Enumerable<CategoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Category update
   */
  export type CategoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }


  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
  }


  /**
   * Category upsert
   */
  export type CategoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }


  /**
   * Category delete
   */
  export type CategoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }


  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
  }


  /**
   * Category.Menu
   */
  export type Category$MenuArgs = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MenuInclude | null
    where?: MenuWhereInput
    orderBy?: Enumerable<MenuOrderByWithRelationInput>
    cursor?: MenuWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MenuScalarFieldEnum>
  }


  /**
   * Category without action
   */
  export type CategoryArgs = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude | null
  }



  /**
   * Model Menu
   */


  export type AggregateMenu = {
    _count: MenuCountAggregateOutputType | null
    _avg: MenuAvgAggregateOutputType | null
    _sum: MenuSumAggregateOutputType | null
    _min: MenuMinAggregateOutputType | null
    _max: MenuMaxAggregateOutputType | null
  }

  export type MenuAvgAggregateOutputType = {
    id: number | null
    price: number | null
    categoryId: number | null
  }

  export type MenuSumAggregateOutputType = {
    id: number | null
    price: number | null
    categoryId: number | null
  }

  export type MenuMinAggregateOutputType = {
    id: number | null
    name: string | null
    image: string | null
    price: number | null
    categoryId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MenuMaxAggregateOutputType = {
    id: number | null
    name: string | null
    image: string | null
    price: number | null
    categoryId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MenuCountAggregateOutputType = {
    id: number
    name: number
    image: number
    price: number
    categoryId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MenuAvgAggregateInputType = {
    id?: true
    price?: true
    categoryId?: true
  }

  export type MenuSumAggregateInputType = {
    id?: true
    price?: true
    categoryId?: true
  }

  export type MenuMinAggregateInputType = {
    id?: true
    name?: true
    image?: true
    price?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MenuMaxAggregateInputType = {
    id?: true
    name?: true
    image?: true
    price?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MenuCountAggregateInputType = {
    id?: true
    name?: true
    image?: true
    price?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MenuAggregateArgs = {
    /**
     * Filter which Menu to aggregate.
     */
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Menus to fetch.
     */
    orderBy?: Enumerable<MenuOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Menus
    **/
    _count?: true | MenuCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MenuAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MenuSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MenuMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MenuMaxAggregateInputType
  }

  export type GetMenuAggregateType<T extends MenuAggregateArgs> = {
        [P in keyof T & keyof AggregateMenu]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenu[P]>
      : GetScalarType<T[P], AggregateMenu[P]>
  }




  export type MenuGroupByArgs = {
    where?: MenuWhereInput
    orderBy?: Enumerable<MenuOrderByWithAggregationInput>
    by: MenuScalarFieldEnum[]
    having?: MenuScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MenuCountAggregateInputType | true
    _avg?: MenuAvgAggregateInputType
    _sum?: MenuSumAggregateInputType
    _min?: MenuMinAggregateInputType
    _max?: MenuMaxAggregateInputType
  }


  export type MenuGroupByOutputType = {
    id: number
    name: string
    image: string
    price: number
    categoryId: number | null
    createdAt: Date
    updatedAt: Date
    _count: MenuCountAggregateOutputType | null
    _avg: MenuAvgAggregateOutputType | null
    _sum: MenuSumAggregateOutputType | null
    _min: MenuMinAggregateOutputType | null
    _max: MenuMaxAggregateOutputType | null
  }

  type GetMenuGroupByPayload<T extends MenuGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MenuGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MenuGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MenuGroupByOutputType[P]>
            : GetScalarType<T[P], MenuGroupByOutputType[P]>
        }
      >
    >


  export type MenuSelect = {
    id?: boolean
    name?: boolean
    image?: boolean
    price?: boolean
    category?: boolean | CategoryArgs
    categoryId?: boolean
    orderItems?: boolean | Menu$orderItemsArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | MenuCountOutputTypeArgs
  }


  export type MenuInclude = {
    category?: boolean | CategoryArgs
    orderItems?: boolean | Menu$orderItemsArgs
    _count?: boolean | MenuCountOutputTypeArgs
  }

  export type MenuGetPayload<S extends boolean | null | undefined | MenuArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Menu :
    S extends undefined ? never :
    S extends { include: any } & (MenuArgs | MenuFindManyArgs)
    ? Menu  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'category' ? CategoryGetPayload<S['include'][P]> | null :
        P extends 'orderItems' ? Array < OrderItemGetPayload<S['include'][P]>>  :
        P extends '_count' ? MenuCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (MenuArgs | MenuFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'category' ? CategoryGetPayload<S['select'][P]> | null :
        P extends 'orderItems' ? Array < OrderItemGetPayload<S['select'][P]>>  :
        P extends '_count' ? MenuCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Menu ? Menu[P] : never
  } 
      : Menu


  type MenuCountArgs = 
    Omit<MenuFindManyArgs, 'select' | 'include'> & {
      select?: MenuCountAggregateInputType | true
    }

  export interface MenuDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Menu that matches the filter.
     * @param {MenuFindUniqueArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MenuFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MenuFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Menu'> extends True ? Prisma__MenuClient<MenuGetPayload<T>> : Prisma__MenuClient<MenuGetPayload<T> | null, null>

    /**
     * Find one Menu that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MenuFindUniqueOrThrowArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MenuFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MenuFindUniqueOrThrowArgs>
    ): Prisma__MenuClient<MenuGetPayload<T>>

    /**
     * Find the first Menu that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuFindFirstArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MenuFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MenuFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Menu'> extends True ? Prisma__MenuClient<MenuGetPayload<T>> : Prisma__MenuClient<MenuGetPayload<T> | null, null>

    /**
     * Find the first Menu that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuFindFirstOrThrowArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MenuFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MenuFindFirstOrThrowArgs>
    ): Prisma__MenuClient<MenuGetPayload<T>>

    /**
     * Find zero or more Menus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Menus
     * const menus = await prisma.menu.findMany()
     * 
     * // Get first 10 Menus
     * const menus = await prisma.menu.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const menuWithIdOnly = await prisma.menu.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MenuFindManyArgs>(
      args?: SelectSubset<T, MenuFindManyArgs>
    ): Prisma.PrismaPromise<Array<MenuGetPayload<T>>>

    /**
     * Create a Menu.
     * @param {MenuCreateArgs} args - Arguments to create a Menu.
     * @example
     * // Create one Menu
     * const Menu = await prisma.menu.create({
     *   data: {
     *     // ... data to create a Menu
     *   }
     * })
     * 
    **/
    create<T extends MenuCreateArgs>(
      args: SelectSubset<T, MenuCreateArgs>
    ): Prisma__MenuClient<MenuGetPayload<T>>

    /**
     * Create many Menus.
     *     @param {MenuCreateManyArgs} args - Arguments to create many Menus.
     *     @example
     *     // Create many Menus
     *     const menu = await prisma.menu.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MenuCreateManyArgs>(
      args?: SelectSubset<T, MenuCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Menu.
     * @param {MenuDeleteArgs} args - Arguments to delete one Menu.
     * @example
     * // Delete one Menu
     * const Menu = await prisma.menu.delete({
     *   where: {
     *     // ... filter to delete one Menu
     *   }
     * })
     * 
    **/
    delete<T extends MenuDeleteArgs>(
      args: SelectSubset<T, MenuDeleteArgs>
    ): Prisma__MenuClient<MenuGetPayload<T>>

    /**
     * Update one Menu.
     * @param {MenuUpdateArgs} args - Arguments to update one Menu.
     * @example
     * // Update one Menu
     * const menu = await prisma.menu.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MenuUpdateArgs>(
      args: SelectSubset<T, MenuUpdateArgs>
    ): Prisma__MenuClient<MenuGetPayload<T>>

    /**
     * Delete zero or more Menus.
     * @param {MenuDeleteManyArgs} args - Arguments to filter Menus to delete.
     * @example
     * // Delete a few Menus
     * const { count } = await prisma.menu.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MenuDeleteManyArgs>(
      args?: SelectSubset<T, MenuDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Menus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Menus
     * const menu = await prisma.menu.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MenuUpdateManyArgs>(
      args: SelectSubset<T, MenuUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Menu.
     * @param {MenuUpsertArgs} args - Arguments to update or create a Menu.
     * @example
     * // Update or create a Menu
     * const menu = await prisma.menu.upsert({
     *   create: {
     *     // ... data to create a Menu
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Menu we want to update
     *   }
     * })
    **/
    upsert<T extends MenuUpsertArgs>(
      args: SelectSubset<T, MenuUpsertArgs>
    ): Prisma__MenuClient<MenuGetPayload<T>>

    /**
     * Count the number of Menus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuCountArgs} args - Arguments to filter Menus to count.
     * @example
     * // Count the number of Menus
     * const count = await prisma.menu.count({
     *   where: {
     *     // ... the filter for the Menus we want to count
     *   }
     * })
    **/
    count<T extends MenuCountArgs>(
      args?: Subset<T, MenuCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenuCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Menu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MenuAggregateArgs>(args: Subset<T, MenuAggregateArgs>): Prisma.PrismaPromise<GetMenuAggregateType<T>>

    /**
     * Group by Menu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MenuGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MenuGroupByArgs['orderBy'] }
        : { orderBy?: MenuGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MenuGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenuGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Menu.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MenuClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    category<T extends CategoryArgs= {}>(args?: Subset<T, CategoryArgs>): Prisma__CategoryClient<CategoryGetPayload<T> | Null>;

    orderItems<T extends Menu$orderItemsArgs= {}>(args?: Subset<T, Menu$orderItemsArgs>): Prisma.PrismaPromise<Array<OrderItemGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Menu base type for findUnique actions
   */
  export type MenuFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MenuInclude | null
    /**
     * Filter, which Menu to fetch.
     */
    where: MenuWhereUniqueInput
  }

  /**
   * Menu findUnique
   */
  export interface MenuFindUniqueArgs extends MenuFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Menu findUniqueOrThrow
   */
  export type MenuFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MenuInclude | null
    /**
     * Filter, which Menu to fetch.
     */
    where: MenuWhereUniqueInput
  }


  /**
   * Menu base type for findFirst actions
   */
  export type MenuFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MenuInclude | null
    /**
     * Filter, which Menu to fetch.
     */
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Menus to fetch.
     */
    orderBy?: Enumerable<MenuOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Menus.
     */
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Menus.
     */
    distinct?: Enumerable<MenuScalarFieldEnum>
  }

  /**
   * Menu findFirst
   */
  export interface MenuFindFirstArgs extends MenuFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Menu findFirstOrThrow
   */
  export type MenuFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MenuInclude | null
    /**
     * Filter, which Menu to fetch.
     */
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Menus to fetch.
     */
    orderBy?: Enumerable<MenuOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Menus.
     */
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Menus.
     */
    distinct?: Enumerable<MenuScalarFieldEnum>
  }


  /**
   * Menu findMany
   */
  export type MenuFindManyArgs = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MenuInclude | null
    /**
     * Filter, which Menus to fetch.
     */
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Menus to fetch.
     */
    orderBy?: Enumerable<MenuOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Menus.
     */
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Menus.
     */
    skip?: number
    distinct?: Enumerable<MenuScalarFieldEnum>
  }


  /**
   * Menu create
   */
  export type MenuCreateArgs = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MenuInclude | null
    /**
     * The data needed to create a Menu.
     */
    data: XOR<MenuCreateInput, MenuUncheckedCreateInput>
  }


  /**
   * Menu createMany
   */
  export type MenuCreateManyArgs = {
    /**
     * The data used to create many Menus.
     */
    data: Enumerable<MenuCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Menu update
   */
  export type MenuUpdateArgs = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MenuInclude | null
    /**
     * The data needed to update a Menu.
     */
    data: XOR<MenuUpdateInput, MenuUncheckedUpdateInput>
    /**
     * Choose, which Menu to update.
     */
    where: MenuWhereUniqueInput
  }


  /**
   * Menu updateMany
   */
  export type MenuUpdateManyArgs = {
    /**
     * The data used to update Menus.
     */
    data: XOR<MenuUpdateManyMutationInput, MenuUncheckedUpdateManyInput>
    /**
     * Filter which Menus to update
     */
    where?: MenuWhereInput
  }


  /**
   * Menu upsert
   */
  export type MenuUpsertArgs = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MenuInclude | null
    /**
     * The filter to search for the Menu to update in case it exists.
     */
    where: MenuWhereUniqueInput
    /**
     * In case the Menu found by the `where` argument doesn't exist, create a new Menu with this data.
     */
    create: XOR<MenuCreateInput, MenuUncheckedCreateInput>
    /**
     * In case the Menu was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MenuUpdateInput, MenuUncheckedUpdateInput>
  }


  /**
   * Menu delete
   */
  export type MenuDeleteArgs = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MenuInclude | null
    /**
     * Filter which Menu to delete.
     */
    where: MenuWhereUniqueInput
  }


  /**
   * Menu deleteMany
   */
  export type MenuDeleteManyArgs = {
    /**
     * Filter which Menus to delete
     */
    where?: MenuWhereInput
  }


  /**
   * Menu.orderItems
   */
  export type Menu$orderItemsArgs = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemInclude | null
    where?: OrderItemWhereInput
    orderBy?: Enumerable<OrderItemOrderByWithRelationInput>
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OrderItemScalarFieldEnum>
  }


  /**
   * Menu without action
   */
  export type MenuArgs = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MenuInclude | null
  }



  /**
   * Model Order
   */


  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    id: number | null
    tableId: number | null
  }

  export type OrderSumAggregateOutputType = {
    id: number | null
    tableId: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: number | null
    status: string | null
    tableId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: number | null
    status: string | null
    tableId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    status: number
    tableId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    id?: true
    tableId?: true
  }

  export type OrderSumAggregateInputType = {
    id?: true
    tableId?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    status?: true
    tableId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    status?: true
    tableId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    status?: true
    tableId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderAggregateArgs = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: Enumerable<OrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs = {
    where?: OrderWhereInput
    orderBy?: Enumerable<OrderOrderByWithAggregationInput>
    by: OrderScalarFieldEnum[]
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }


  export type OrderGroupByOutputType = {
    id: number
    status: string
    tableId: number
    createdAt: Date
    updatedAt: Date
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect = {
    id?: boolean
    status?: boolean
    tableId?: boolean
    items?: boolean | Order$itemsArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | OrderCountOutputTypeArgs
  }


  export type OrderInclude = {
    items?: boolean | Order$itemsArgs
    _count?: boolean | OrderCountOutputTypeArgs
  }

  export type OrderGetPayload<S extends boolean | null | undefined | OrderArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Order :
    S extends undefined ? never :
    S extends { include: any } & (OrderArgs | OrderFindManyArgs)
    ? Order  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'items' ? Array < OrderItemGetPayload<S['include'][P]>>  :
        P extends '_count' ? OrderCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (OrderArgs | OrderFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'items' ? Array < OrderItemGetPayload<S['select'][P]>>  :
        P extends '_count' ? OrderCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Order ? Order[P] : never
  } 
      : Order


  type OrderCountArgs = 
    Omit<OrderFindManyArgs, 'select' | 'include'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrderFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OrderFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Order'> extends True ? Prisma__OrderClient<OrderGetPayload<T>> : Prisma__OrderClient<OrderGetPayload<T> | null, null>

    /**
     * Find one Order that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OrderFindUniqueOrThrowArgs>
    ): Prisma__OrderClient<OrderGetPayload<T>>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrderFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OrderFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Order'> extends True ? Prisma__OrderClient<OrderGetPayload<T>> : Prisma__OrderClient<OrderGetPayload<T> | null, null>

    /**
     * Find the first Order that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OrderFindFirstOrThrowArgs>
    ): Prisma__OrderClient<OrderGetPayload<T>>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrderFindManyArgs>(
      args?: SelectSubset<T, OrderFindManyArgs>
    ): Prisma.PrismaPromise<Array<OrderGetPayload<T>>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
    **/
    create<T extends OrderCreateArgs>(
      args: SelectSubset<T, OrderCreateArgs>
    ): Prisma__OrderClient<OrderGetPayload<T>>

    /**
     * Create many Orders.
     *     @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     *     @example
     *     // Create many Orders
     *     const order = await prisma.order.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrderCreateManyArgs>(
      args?: SelectSubset<T, OrderCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
    **/
    delete<T extends OrderDeleteArgs>(
      args: SelectSubset<T, OrderDeleteArgs>
    ): Prisma__OrderClient<OrderGetPayload<T>>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrderUpdateArgs>(
      args: SelectSubset<T, OrderUpdateArgs>
    ): Prisma__OrderClient<OrderGetPayload<T>>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrderDeleteManyArgs>(
      args?: SelectSubset<T, OrderDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrderUpdateManyArgs>(
      args: SelectSubset<T, OrderUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
    **/
    upsert<T extends OrderUpsertArgs>(
      args: SelectSubset<T, OrderUpsertArgs>
    ): Prisma__OrderClient<OrderGetPayload<T>>

    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OrderClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    items<T extends Order$itemsArgs= {}>(args?: Subset<T, Order$itemsArgs>): Prisma.PrismaPromise<Array<OrderItemGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Order base type for findUnique actions
   */
  export type OrderFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUnique
   */
  export interface OrderFindUniqueArgs extends OrderFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }


  /**
   * Order base type for findFirst actions
   */
  export type OrderFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: Enumerable<OrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: Enumerable<OrderScalarFieldEnum>
  }

  /**
   * Order findFirst
   */
  export interface OrderFindFirstArgs extends OrderFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: Enumerable<OrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: Enumerable<OrderScalarFieldEnum>
  }


  /**
   * Order findMany
   */
  export type OrderFindManyArgs = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: Enumerable<OrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: Enumerable<OrderScalarFieldEnum>
  }


  /**
   * Order create
   */
  export type OrderCreateArgs = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }


  /**
   * Order createMany
   */
  export type OrderCreateManyArgs = {
    /**
     * The data used to create many Orders.
     */
    data: Enumerable<OrderCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Order update
   */
  export type OrderUpdateArgs = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }


  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
  }


  /**
   * Order upsert
   */
  export type OrderUpsertArgs = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }


  /**
   * Order delete
   */
  export type OrderDeleteArgs = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }


  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
  }


  /**
   * Order.items
   */
  export type Order$itemsArgs = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemInclude | null
    where?: OrderItemWhereInput
    orderBy?: Enumerable<OrderItemOrderByWithRelationInput>
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OrderItemScalarFieldEnum>
  }


  /**
   * Order without action
   */
  export type OrderArgs = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude | null
  }



  /**
   * Model OrderItem
   */


  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    id: number | null
    menuId: number | null
    orderId: number | null
    quantity: number | null
    totalPrice: number | null
  }

  export type OrderItemSumAggregateOutputType = {
    id: number | null
    menuId: number | null
    orderId: number | null
    quantity: number | null
    totalPrice: number | null
  }

  export type OrderItemMinAggregateOutputType = {
    id: number | null
    menuId: number | null
    orderId: number | null
    quantity: number | null
    totalPrice: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderItemMaxAggregateOutputType = {
    id: number | null
    menuId: number | null
    orderId: number | null
    quantity: number | null
    totalPrice: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderItemCountAggregateOutputType = {
    id: number
    menuId: number
    orderId: number
    quantity: number
    totalPrice: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    id?: true
    menuId?: true
    orderId?: true
    quantity?: true
    totalPrice?: true
  }

  export type OrderItemSumAggregateInputType = {
    id?: true
    menuId?: true
    orderId?: true
    quantity?: true
    totalPrice?: true
  }

  export type OrderItemMinAggregateInputType = {
    id?: true
    menuId?: true
    orderId?: true
    quantity?: true
    totalPrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderItemMaxAggregateInputType = {
    id?: true
    menuId?: true
    orderId?: true
    quantity?: true
    totalPrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderItemCountAggregateInputType = {
    id?: true
    menuId?: true
    orderId?: true
    quantity?: true
    totalPrice?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderItemAggregateArgs = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: Enumerable<OrderItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }




  export type OrderItemGroupByArgs = {
    where?: OrderItemWhereInput
    orderBy?: Enumerable<OrderItemOrderByWithAggregationInput>
    by: OrderItemScalarFieldEnum[]
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }


  export type OrderItemGroupByOutputType = {
    id: number
    menuId: number
    orderId: number | null
    quantity: number
    totalPrice: number
    createdAt: Date
    updatedAt: Date
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<OrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemSelect = {
    id?: boolean
    menu?: boolean | MenuArgs
    menuId?: boolean
    order?: boolean | OrderArgs
    orderId?: boolean
    quantity?: boolean
    totalPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type OrderItemInclude = {
    menu?: boolean | MenuArgs
    order?: boolean | OrderArgs
  }

  export type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? OrderItem :
    S extends undefined ? never :
    S extends { include: any } & (OrderItemArgs | OrderItemFindManyArgs)
    ? OrderItem  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'menu' ? MenuGetPayload<S['include'][P]> :
        P extends 'order' ? OrderGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (OrderItemArgs | OrderItemFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'menu' ? MenuGetPayload<S['select'][P]> :
        P extends 'order' ? OrderGetPayload<S['select'][P]> | null :  P extends keyof OrderItem ? OrderItem[P] : never
  } 
      : OrderItem


  type OrderItemCountArgs = 
    Omit<OrderItemFindManyArgs, 'select' | 'include'> & {
      select?: OrderItemCountAggregateInputType | true
    }

  export interface OrderItemDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrderItemFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OrderItemFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OrderItem'> extends True ? Prisma__OrderItemClient<OrderItemGetPayload<T>> : Prisma__OrderItemClient<OrderItemGetPayload<T> | null, null>

    /**
     * Find one OrderItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OrderItemFindUniqueOrThrowArgs>
    ): Prisma__OrderItemClient<OrderItemGetPayload<T>>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrderItemFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OrderItemFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OrderItem'> extends True ? Prisma__OrderItemClient<OrderItemGetPayload<T>> : Prisma__OrderItemClient<OrderItemGetPayload<T> | null, null>

    /**
     * Find the first OrderItem that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs>
    ): Prisma__OrderItemClient<OrderItemGetPayload<T>>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrderItemFindManyArgs>(
      args?: SelectSubset<T, OrderItemFindManyArgs>
    ): Prisma.PrismaPromise<Array<OrderItemGetPayload<T>>>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
    **/
    create<T extends OrderItemCreateArgs>(
      args: SelectSubset<T, OrderItemCreateArgs>
    ): Prisma__OrderItemClient<OrderItemGetPayload<T>>

    /**
     * Create many OrderItems.
     *     @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     *     @example
     *     // Create many OrderItems
     *     const orderItem = await prisma.orderItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrderItemCreateManyArgs>(
      args?: SelectSubset<T, OrderItemCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
    **/
    delete<T extends OrderItemDeleteArgs>(
      args: SelectSubset<T, OrderItemDeleteArgs>
    ): Prisma__OrderItemClient<OrderItemGetPayload<T>>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrderItemUpdateArgs>(
      args: SelectSubset<T, OrderItemUpdateArgs>
    ): Prisma__OrderItemClient<OrderItemGetPayload<T>>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrderItemDeleteManyArgs>(
      args?: SelectSubset<T, OrderItemDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrderItemUpdateManyArgs>(
      args: SelectSubset<T, OrderItemUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
    **/
    upsert<T extends OrderItemUpsertArgs>(
      args: SelectSubset<T, OrderItemUpsertArgs>
    ): Prisma__OrderItemClient<OrderItemGetPayload<T>>

    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OrderItemClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    menu<T extends MenuArgs= {}>(args?: Subset<T, MenuArgs>): Prisma__MenuClient<MenuGetPayload<T> | Null>;

    order<T extends OrderArgs= {}>(args?: Subset<T, OrderArgs>): Prisma__OrderClient<OrderGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * OrderItem base type for findUnique actions
   */
  export type OrderItemFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemInclude | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findUnique
   */
  export interface OrderItemFindUniqueArgs extends OrderItemFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemInclude | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }


  /**
   * OrderItem base type for findFirst actions
   */
  export type OrderItemFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemInclude | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: Enumerable<OrderItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: Enumerable<OrderItemScalarFieldEnum>
  }

  /**
   * OrderItem findFirst
   */
  export interface OrderItemFindFirstArgs extends OrderItemFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemInclude | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: Enumerable<OrderItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: Enumerable<OrderItemScalarFieldEnum>
  }


  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemInclude | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: Enumerable<OrderItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: Enumerable<OrderItemScalarFieldEnum>
  }


  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemInclude | null
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }


  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs = {
    /**
     * The data used to create many OrderItems.
     */
    data: Enumerable<OrderItemCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemInclude | null
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput
  }


  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
  }


  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemInclude | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }


  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemInclude | null
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput
  }


  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput
  }


  /**
   * OrderItem without action
   */
  export type OrderItemArgs = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemInclude | null
  }



  /**
   * Model QuizCategory
   */


  export type AggregateQuizCategory = {
    _count: QuizCategoryCountAggregateOutputType | null
    _avg: QuizCategoryAvgAggregateOutputType | null
    _sum: QuizCategorySumAggregateOutputType | null
    _min: QuizCategoryMinAggregateOutputType | null
    _max: QuizCategoryMaxAggregateOutputType | null
  }

  export type QuizCategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type QuizCategorySumAggregateOutputType = {
    id: number | null
  }

  export type QuizCategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizCategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizCategoryCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuizCategoryAvgAggregateInputType = {
    id?: true
  }

  export type QuizCategorySumAggregateInputType = {
    id?: true
  }

  export type QuizCategoryMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizCategoryCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuizCategoryAggregateArgs = {
    /**
     * Filter which QuizCategory to aggregate.
     */
    where?: QuizCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizCategories to fetch.
     */
    orderBy?: Enumerable<QuizCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizCategories
    **/
    _count?: true | QuizCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizCategoryMaxAggregateInputType
  }

  export type GetQuizCategoryAggregateType<T extends QuizCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizCategory[P]>
      : GetScalarType<T[P], AggregateQuizCategory[P]>
  }




  export type QuizCategoryGroupByArgs = {
    where?: QuizCategoryWhereInput
    orderBy?: Enumerable<QuizCategoryOrderByWithAggregationInput>
    by: QuizCategoryScalarFieldEnum[]
    having?: QuizCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizCategoryCountAggregateInputType | true
    _avg?: QuizCategoryAvgAggregateInputType
    _sum?: QuizCategorySumAggregateInputType
    _min?: QuizCategoryMinAggregateInputType
    _max?: QuizCategoryMaxAggregateInputType
  }


  export type QuizCategoryGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: QuizCategoryCountAggregateOutputType | null
    _avg: QuizCategoryAvgAggregateOutputType | null
    _sum: QuizCategorySumAggregateOutputType | null
    _min: QuizCategoryMinAggregateOutputType | null
    _max: QuizCategoryMaxAggregateOutputType | null
  }

  type GetQuizCategoryGroupByPayload<T extends QuizCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<QuizCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], QuizCategoryGroupByOutputType[P]>
        }
      >
    >


  export type QuizCategorySelect = {
    id?: boolean
    name?: boolean
    quizzes?: boolean | QuizCategory$quizzesArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | QuizCategoryCountOutputTypeArgs
  }


  export type QuizCategoryInclude = {
    quizzes?: boolean | QuizCategory$quizzesArgs
    _count?: boolean | QuizCategoryCountOutputTypeArgs
  }

  export type QuizCategoryGetPayload<S extends boolean | null | undefined | QuizCategoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? QuizCategory :
    S extends undefined ? never :
    S extends { include: any } & (QuizCategoryArgs | QuizCategoryFindManyArgs)
    ? QuizCategory  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'quizzes' ? Array < QuizGetPayload<S['include'][P]>>  :
        P extends '_count' ? QuizCategoryCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (QuizCategoryArgs | QuizCategoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'quizzes' ? Array < QuizGetPayload<S['select'][P]>>  :
        P extends '_count' ? QuizCategoryCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof QuizCategory ? QuizCategory[P] : never
  } 
      : QuizCategory


  type QuizCategoryCountArgs = 
    Omit<QuizCategoryFindManyArgs, 'select' | 'include'> & {
      select?: QuizCategoryCountAggregateInputType | true
    }

  export interface QuizCategoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one QuizCategory that matches the filter.
     * @param {QuizCategoryFindUniqueArgs} args - Arguments to find a QuizCategory
     * @example
     * // Get one QuizCategory
     * const quizCategory = await prisma.quizCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuizCategoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, QuizCategoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'QuizCategory'> extends True ? Prisma__QuizCategoryClient<QuizCategoryGetPayload<T>> : Prisma__QuizCategoryClient<QuizCategoryGetPayload<T> | null, null>

    /**
     * Find one QuizCategory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {QuizCategoryFindUniqueOrThrowArgs} args - Arguments to find a QuizCategory
     * @example
     * // Get one QuizCategory
     * const quizCategory = await prisma.quizCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QuizCategoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, QuizCategoryFindUniqueOrThrowArgs>
    ): Prisma__QuizCategoryClient<QuizCategoryGetPayload<T>>

    /**
     * Find the first QuizCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizCategoryFindFirstArgs} args - Arguments to find a QuizCategory
     * @example
     * // Get one QuizCategory
     * const quizCategory = await prisma.quizCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuizCategoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, QuizCategoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'QuizCategory'> extends True ? Prisma__QuizCategoryClient<QuizCategoryGetPayload<T>> : Prisma__QuizCategoryClient<QuizCategoryGetPayload<T> | null, null>

    /**
     * Find the first QuizCategory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizCategoryFindFirstOrThrowArgs} args - Arguments to find a QuizCategory
     * @example
     * // Get one QuizCategory
     * const quizCategory = await prisma.quizCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QuizCategoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, QuizCategoryFindFirstOrThrowArgs>
    ): Prisma__QuizCategoryClient<QuizCategoryGetPayload<T>>

    /**
     * Find zero or more QuizCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizCategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizCategories
     * const quizCategories = await prisma.quizCategory.findMany()
     * 
     * // Get first 10 QuizCategories
     * const quizCategories = await prisma.quizCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizCategoryWithIdOnly = await prisma.quizCategory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends QuizCategoryFindManyArgs>(
      args?: SelectSubset<T, QuizCategoryFindManyArgs>
    ): Prisma.PrismaPromise<Array<QuizCategoryGetPayload<T>>>

    /**
     * Create a QuizCategory.
     * @param {QuizCategoryCreateArgs} args - Arguments to create a QuizCategory.
     * @example
     * // Create one QuizCategory
     * const QuizCategory = await prisma.quizCategory.create({
     *   data: {
     *     // ... data to create a QuizCategory
     *   }
     * })
     * 
    **/
    create<T extends QuizCategoryCreateArgs>(
      args: SelectSubset<T, QuizCategoryCreateArgs>
    ): Prisma__QuizCategoryClient<QuizCategoryGetPayload<T>>

    /**
     * Create many QuizCategories.
     *     @param {QuizCategoryCreateManyArgs} args - Arguments to create many QuizCategories.
     *     @example
     *     // Create many QuizCategories
     *     const quizCategory = await prisma.quizCategory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QuizCategoryCreateManyArgs>(
      args?: SelectSubset<T, QuizCategoryCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QuizCategory.
     * @param {QuizCategoryDeleteArgs} args - Arguments to delete one QuizCategory.
     * @example
     * // Delete one QuizCategory
     * const QuizCategory = await prisma.quizCategory.delete({
     *   where: {
     *     // ... filter to delete one QuizCategory
     *   }
     * })
     * 
    **/
    delete<T extends QuizCategoryDeleteArgs>(
      args: SelectSubset<T, QuizCategoryDeleteArgs>
    ): Prisma__QuizCategoryClient<QuizCategoryGetPayload<T>>

    /**
     * Update one QuizCategory.
     * @param {QuizCategoryUpdateArgs} args - Arguments to update one QuizCategory.
     * @example
     * // Update one QuizCategory
     * const quizCategory = await prisma.quizCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuizCategoryUpdateArgs>(
      args: SelectSubset<T, QuizCategoryUpdateArgs>
    ): Prisma__QuizCategoryClient<QuizCategoryGetPayload<T>>

    /**
     * Delete zero or more QuizCategories.
     * @param {QuizCategoryDeleteManyArgs} args - Arguments to filter QuizCategories to delete.
     * @example
     * // Delete a few QuizCategories
     * const { count } = await prisma.quizCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuizCategoryDeleteManyArgs>(
      args?: SelectSubset<T, QuizCategoryDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizCategories
     * const quizCategory = await prisma.quizCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuizCategoryUpdateManyArgs>(
      args: SelectSubset<T, QuizCategoryUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuizCategory.
     * @param {QuizCategoryUpsertArgs} args - Arguments to update or create a QuizCategory.
     * @example
     * // Update or create a QuizCategory
     * const quizCategory = await prisma.quizCategory.upsert({
     *   create: {
     *     // ... data to create a QuizCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizCategory we want to update
     *   }
     * })
    **/
    upsert<T extends QuizCategoryUpsertArgs>(
      args: SelectSubset<T, QuizCategoryUpsertArgs>
    ): Prisma__QuizCategoryClient<QuizCategoryGetPayload<T>>

    /**
     * Count the number of QuizCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizCategoryCountArgs} args - Arguments to filter QuizCategories to count.
     * @example
     * // Count the number of QuizCategories
     * const count = await prisma.quizCategory.count({
     *   where: {
     *     // ... the filter for the QuizCategories we want to count
     *   }
     * })
    **/
    count<T extends QuizCategoryCountArgs>(
      args?: Subset<T, QuizCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizCategoryAggregateArgs>(args: Subset<T, QuizCategoryAggregateArgs>): Prisma.PrismaPromise<GetQuizCategoryAggregateType<T>>

    /**
     * Group by QuizCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizCategoryGroupByArgs['orderBy'] }
        : { orderBy?: QuizCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__QuizCategoryClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    quizzes<T extends QuizCategory$quizzesArgs= {}>(args?: Subset<T, QuizCategory$quizzesArgs>): Prisma.PrismaPromise<Array<QuizGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * QuizCategory base type for findUnique actions
   */
  export type QuizCategoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the QuizCategory
     */
    select?: QuizCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizCategoryInclude | null
    /**
     * Filter, which QuizCategory to fetch.
     */
    where: QuizCategoryWhereUniqueInput
  }

  /**
   * QuizCategory findUnique
   */
  export interface QuizCategoryFindUniqueArgs extends QuizCategoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuizCategory findUniqueOrThrow
   */
  export type QuizCategoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the QuizCategory
     */
    select?: QuizCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizCategoryInclude | null
    /**
     * Filter, which QuizCategory to fetch.
     */
    where: QuizCategoryWhereUniqueInput
  }


  /**
   * QuizCategory base type for findFirst actions
   */
  export type QuizCategoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the QuizCategory
     */
    select?: QuizCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizCategoryInclude | null
    /**
     * Filter, which QuizCategory to fetch.
     */
    where?: QuizCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizCategories to fetch.
     */
    orderBy?: Enumerable<QuizCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizCategories.
     */
    cursor?: QuizCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizCategories.
     */
    distinct?: Enumerable<QuizCategoryScalarFieldEnum>
  }

  /**
   * QuizCategory findFirst
   */
  export interface QuizCategoryFindFirstArgs extends QuizCategoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuizCategory findFirstOrThrow
   */
  export type QuizCategoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the QuizCategory
     */
    select?: QuizCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizCategoryInclude | null
    /**
     * Filter, which QuizCategory to fetch.
     */
    where?: QuizCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizCategories to fetch.
     */
    orderBy?: Enumerable<QuizCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizCategories.
     */
    cursor?: QuizCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizCategories.
     */
    distinct?: Enumerable<QuizCategoryScalarFieldEnum>
  }


  /**
   * QuizCategory findMany
   */
  export type QuizCategoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the QuizCategory
     */
    select?: QuizCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizCategoryInclude | null
    /**
     * Filter, which QuizCategories to fetch.
     */
    where?: QuizCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizCategories to fetch.
     */
    orderBy?: Enumerable<QuizCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizCategories.
     */
    cursor?: QuizCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizCategories.
     */
    skip?: number
    distinct?: Enumerable<QuizCategoryScalarFieldEnum>
  }


  /**
   * QuizCategory create
   */
  export type QuizCategoryCreateArgs = {
    /**
     * Select specific fields to fetch from the QuizCategory
     */
    select?: QuizCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizCategoryInclude | null
    /**
     * The data needed to create a QuizCategory.
     */
    data: XOR<QuizCategoryCreateInput, QuizCategoryUncheckedCreateInput>
  }


  /**
   * QuizCategory createMany
   */
  export type QuizCategoryCreateManyArgs = {
    /**
     * The data used to create many QuizCategories.
     */
    data: Enumerable<QuizCategoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * QuizCategory update
   */
  export type QuizCategoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the QuizCategory
     */
    select?: QuizCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizCategoryInclude | null
    /**
     * The data needed to update a QuizCategory.
     */
    data: XOR<QuizCategoryUpdateInput, QuizCategoryUncheckedUpdateInput>
    /**
     * Choose, which QuizCategory to update.
     */
    where: QuizCategoryWhereUniqueInput
  }


  /**
   * QuizCategory updateMany
   */
  export type QuizCategoryUpdateManyArgs = {
    /**
     * The data used to update QuizCategories.
     */
    data: XOR<QuizCategoryUpdateManyMutationInput, QuizCategoryUncheckedUpdateManyInput>
    /**
     * Filter which QuizCategories to update
     */
    where?: QuizCategoryWhereInput
  }


  /**
   * QuizCategory upsert
   */
  export type QuizCategoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the QuizCategory
     */
    select?: QuizCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizCategoryInclude | null
    /**
     * The filter to search for the QuizCategory to update in case it exists.
     */
    where: QuizCategoryWhereUniqueInput
    /**
     * In case the QuizCategory found by the `where` argument doesn't exist, create a new QuizCategory with this data.
     */
    create: XOR<QuizCategoryCreateInput, QuizCategoryUncheckedCreateInput>
    /**
     * In case the QuizCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizCategoryUpdateInput, QuizCategoryUncheckedUpdateInput>
  }


  /**
   * QuizCategory delete
   */
  export type QuizCategoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the QuizCategory
     */
    select?: QuizCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizCategoryInclude | null
    /**
     * Filter which QuizCategory to delete.
     */
    where: QuizCategoryWhereUniqueInput
  }


  /**
   * QuizCategory deleteMany
   */
  export type QuizCategoryDeleteManyArgs = {
    /**
     * Filter which QuizCategories to delete
     */
    where?: QuizCategoryWhereInput
  }


  /**
   * QuizCategory.quizzes
   */
  export type QuizCategory$quizzesArgs = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizInclude | null
    where?: QuizWhereInput
    orderBy?: Enumerable<QuizOrderByWithRelationInput>
    cursor?: QuizWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<QuizScalarFieldEnum>
  }


  /**
   * QuizCategory without action
   */
  export type QuizCategoryArgs = {
    /**
     * Select specific fields to fetch from the QuizCategory
     */
    select?: QuizCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizCategoryInclude | null
  }



  /**
   * Model Choice
   */


  export type AggregateChoice = {
    _count: ChoiceCountAggregateOutputType | null
    _avg: ChoiceAvgAggregateOutputType | null
    _sum: ChoiceSumAggregateOutputType | null
    _min: ChoiceMinAggregateOutputType | null
    _max: ChoiceMaxAggregateOutputType | null
  }

  export type ChoiceAvgAggregateOutputType = {
    id: number | null
    quizId: number | null
  }

  export type ChoiceSumAggregateOutputType = {
    id: number | null
    quizId: number | null
  }

  export type ChoiceMinAggregateOutputType = {
    id: number | null
    answerText: string | null
    quizId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChoiceMaxAggregateOutputType = {
    id: number | null
    answerText: string | null
    quizId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChoiceCountAggregateOutputType = {
    id: number
    answerText: number
    quizId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChoiceAvgAggregateInputType = {
    id?: true
    quizId?: true
  }

  export type ChoiceSumAggregateInputType = {
    id?: true
    quizId?: true
  }

  export type ChoiceMinAggregateInputType = {
    id?: true
    answerText?: true
    quizId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChoiceMaxAggregateInputType = {
    id?: true
    answerText?: true
    quizId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChoiceCountAggregateInputType = {
    id?: true
    answerText?: true
    quizId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChoiceAggregateArgs = {
    /**
     * Filter which Choice to aggregate.
     */
    where?: ChoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Choices to fetch.
     */
    orderBy?: Enumerable<ChoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Choices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Choices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Choices
    **/
    _count?: true | ChoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChoiceMaxAggregateInputType
  }

  export type GetChoiceAggregateType<T extends ChoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateChoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChoice[P]>
      : GetScalarType<T[P], AggregateChoice[P]>
  }




  export type ChoiceGroupByArgs = {
    where?: ChoiceWhereInput
    orderBy?: Enumerable<ChoiceOrderByWithAggregationInput>
    by: ChoiceScalarFieldEnum[]
    having?: ChoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChoiceCountAggregateInputType | true
    _avg?: ChoiceAvgAggregateInputType
    _sum?: ChoiceSumAggregateInputType
    _min?: ChoiceMinAggregateInputType
    _max?: ChoiceMaxAggregateInputType
  }


  export type ChoiceGroupByOutputType = {
    id: number
    answerText: string
    quizId: number | null
    createdAt: Date
    updatedAt: Date
    _count: ChoiceCountAggregateOutputType | null
    _avg: ChoiceAvgAggregateOutputType | null
    _sum: ChoiceSumAggregateOutputType | null
    _min: ChoiceMinAggregateOutputType | null
    _max: ChoiceMaxAggregateOutputType | null
  }

  type GetChoiceGroupByPayload<T extends ChoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ChoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChoiceGroupByOutputType[P]>
            : GetScalarType<T[P], ChoiceGroupByOutputType[P]>
        }
      >
    >


  export type ChoiceSelect = {
    id?: boolean
    answerText?: boolean
    quiz?: boolean | QuizArgs
    quizId?: boolean
    correctQuizzes?: boolean | Choice$correctQuizzesArgs
    rounds?: boolean | Choice$roundsArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | ChoiceCountOutputTypeArgs
  }


  export type ChoiceInclude = {
    quiz?: boolean | QuizArgs
    correctQuizzes?: boolean | Choice$correctQuizzesArgs
    rounds?: boolean | Choice$roundsArgs
    _count?: boolean | ChoiceCountOutputTypeArgs
  }

  export type ChoiceGetPayload<S extends boolean | null | undefined | ChoiceArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Choice :
    S extends undefined ? never :
    S extends { include: any } & (ChoiceArgs | ChoiceFindManyArgs)
    ? Choice  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'quiz' ? QuizGetPayload<S['include'][P]> | null :
        P extends 'correctQuizzes' ? Array < QuizGetPayload<S['include'][P]>>  :
        P extends 'rounds' ? Array < RoundGetPayload<S['include'][P]>>  :
        P extends '_count' ? ChoiceCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ChoiceArgs | ChoiceFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'quiz' ? QuizGetPayload<S['select'][P]> | null :
        P extends 'correctQuizzes' ? Array < QuizGetPayload<S['select'][P]>>  :
        P extends 'rounds' ? Array < RoundGetPayload<S['select'][P]>>  :
        P extends '_count' ? ChoiceCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Choice ? Choice[P] : never
  } 
      : Choice


  type ChoiceCountArgs = 
    Omit<ChoiceFindManyArgs, 'select' | 'include'> & {
      select?: ChoiceCountAggregateInputType | true
    }

  export interface ChoiceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Choice that matches the filter.
     * @param {ChoiceFindUniqueArgs} args - Arguments to find a Choice
     * @example
     * // Get one Choice
     * const choice = await prisma.choice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ChoiceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ChoiceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Choice'> extends True ? Prisma__ChoiceClient<ChoiceGetPayload<T>> : Prisma__ChoiceClient<ChoiceGetPayload<T> | null, null>

    /**
     * Find one Choice that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ChoiceFindUniqueOrThrowArgs} args - Arguments to find a Choice
     * @example
     * // Get one Choice
     * const choice = await prisma.choice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ChoiceFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ChoiceFindUniqueOrThrowArgs>
    ): Prisma__ChoiceClient<ChoiceGetPayload<T>>

    /**
     * Find the first Choice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceFindFirstArgs} args - Arguments to find a Choice
     * @example
     * // Get one Choice
     * const choice = await prisma.choice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ChoiceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ChoiceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Choice'> extends True ? Prisma__ChoiceClient<ChoiceGetPayload<T>> : Prisma__ChoiceClient<ChoiceGetPayload<T> | null, null>

    /**
     * Find the first Choice that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceFindFirstOrThrowArgs} args - Arguments to find a Choice
     * @example
     * // Get one Choice
     * const choice = await prisma.choice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ChoiceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ChoiceFindFirstOrThrowArgs>
    ): Prisma__ChoiceClient<ChoiceGetPayload<T>>

    /**
     * Find zero or more Choices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Choices
     * const choices = await prisma.choice.findMany()
     * 
     * // Get first 10 Choices
     * const choices = await prisma.choice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const choiceWithIdOnly = await prisma.choice.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ChoiceFindManyArgs>(
      args?: SelectSubset<T, ChoiceFindManyArgs>
    ): Prisma.PrismaPromise<Array<ChoiceGetPayload<T>>>

    /**
     * Create a Choice.
     * @param {ChoiceCreateArgs} args - Arguments to create a Choice.
     * @example
     * // Create one Choice
     * const Choice = await prisma.choice.create({
     *   data: {
     *     // ... data to create a Choice
     *   }
     * })
     * 
    **/
    create<T extends ChoiceCreateArgs>(
      args: SelectSubset<T, ChoiceCreateArgs>
    ): Prisma__ChoiceClient<ChoiceGetPayload<T>>

    /**
     * Create many Choices.
     *     @param {ChoiceCreateManyArgs} args - Arguments to create many Choices.
     *     @example
     *     // Create many Choices
     *     const choice = await prisma.choice.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ChoiceCreateManyArgs>(
      args?: SelectSubset<T, ChoiceCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Choice.
     * @param {ChoiceDeleteArgs} args - Arguments to delete one Choice.
     * @example
     * // Delete one Choice
     * const Choice = await prisma.choice.delete({
     *   where: {
     *     // ... filter to delete one Choice
     *   }
     * })
     * 
    **/
    delete<T extends ChoiceDeleteArgs>(
      args: SelectSubset<T, ChoiceDeleteArgs>
    ): Prisma__ChoiceClient<ChoiceGetPayload<T>>

    /**
     * Update one Choice.
     * @param {ChoiceUpdateArgs} args - Arguments to update one Choice.
     * @example
     * // Update one Choice
     * const choice = await prisma.choice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ChoiceUpdateArgs>(
      args: SelectSubset<T, ChoiceUpdateArgs>
    ): Prisma__ChoiceClient<ChoiceGetPayload<T>>

    /**
     * Delete zero or more Choices.
     * @param {ChoiceDeleteManyArgs} args - Arguments to filter Choices to delete.
     * @example
     * // Delete a few Choices
     * const { count } = await prisma.choice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ChoiceDeleteManyArgs>(
      args?: SelectSubset<T, ChoiceDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Choices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Choices
     * const choice = await prisma.choice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ChoiceUpdateManyArgs>(
      args: SelectSubset<T, ChoiceUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Choice.
     * @param {ChoiceUpsertArgs} args - Arguments to update or create a Choice.
     * @example
     * // Update or create a Choice
     * const choice = await prisma.choice.upsert({
     *   create: {
     *     // ... data to create a Choice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Choice we want to update
     *   }
     * })
    **/
    upsert<T extends ChoiceUpsertArgs>(
      args: SelectSubset<T, ChoiceUpsertArgs>
    ): Prisma__ChoiceClient<ChoiceGetPayload<T>>

    /**
     * Count the number of Choices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceCountArgs} args - Arguments to filter Choices to count.
     * @example
     * // Count the number of Choices
     * const count = await prisma.choice.count({
     *   where: {
     *     // ... the filter for the Choices we want to count
     *   }
     * })
    **/
    count<T extends ChoiceCountArgs>(
      args?: Subset<T, ChoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Choice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChoiceAggregateArgs>(args: Subset<T, ChoiceAggregateArgs>): Prisma.PrismaPromise<GetChoiceAggregateType<T>>

    /**
     * Group by Choice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChoiceGroupByArgs['orderBy'] }
        : { orderBy?: ChoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Choice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ChoiceClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    quiz<T extends QuizArgs= {}>(args?: Subset<T, QuizArgs>): Prisma__QuizClient<QuizGetPayload<T> | Null>;

    correctQuizzes<T extends Choice$correctQuizzesArgs= {}>(args?: Subset<T, Choice$correctQuizzesArgs>): Prisma.PrismaPromise<Array<QuizGetPayload<T>>| Null>;

    rounds<T extends Choice$roundsArgs= {}>(args?: Subset<T, Choice$roundsArgs>): Prisma.PrismaPromise<Array<RoundGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Choice base type for findUnique actions
   */
  export type ChoiceFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceInclude | null
    /**
     * Filter, which Choice to fetch.
     */
    where: ChoiceWhereUniqueInput
  }

  /**
   * Choice findUnique
   */
  export interface ChoiceFindUniqueArgs extends ChoiceFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Choice findUniqueOrThrow
   */
  export type ChoiceFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceInclude | null
    /**
     * Filter, which Choice to fetch.
     */
    where: ChoiceWhereUniqueInput
  }


  /**
   * Choice base type for findFirst actions
   */
  export type ChoiceFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceInclude | null
    /**
     * Filter, which Choice to fetch.
     */
    where?: ChoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Choices to fetch.
     */
    orderBy?: Enumerable<ChoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Choices.
     */
    cursor?: ChoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Choices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Choices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Choices.
     */
    distinct?: Enumerable<ChoiceScalarFieldEnum>
  }

  /**
   * Choice findFirst
   */
  export interface ChoiceFindFirstArgs extends ChoiceFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Choice findFirstOrThrow
   */
  export type ChoiceFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceInclude | null
    /**
     * Filter, which Choice to fetch.
     */
    where?: ChoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Choices to fetch.
     */
    orderBy?: Enumerable<ChoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Choices.
     */
    cursor?: ChoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Choices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Choices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Choices.
     */
    distinct?: Enumerable<ChoiceScalarFieldEnum>
  }


  /**
   * Choice findMany
   */
  export type ChoiceFindManyArgs = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceInclude | null
    /**
     * Filter, which Choices to fetch.
     */
    where?: ChoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Choices to fetch.
     */
    orderBy?: Enumerable<ChoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Choices.
     */
    cursor?: ChoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Choices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Choices.
     */
    skip?: number
    distinct?: Enumerable<ChoiceScalarFieldEnum>
  }


  /**
   * Choice create
   */
  export type ChoiceCreateArgs = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceInclude | null
    /**
     * The data needed to create a Choice.
     */
    data: XOR<ChoiceCreateInput, ChoiceUncheckedCreateInput>
  }


  /**
   * Choice createMany
   */
  export type ChoiceCreateManyArgs = {
    /**
     * The data used to create many Choices.
     */
    data: Enumerable<ChoiceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Choice update
   */
  export type ChoiceUpdateArgs = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceInclude | null
    /**
     * The data needed to update a Choice.
     */
    data: XOR<ChoiceUpdateInput, ChoiceUncheckedUpdateInput>
    /**
     * Choose, which Choice to update.
     */
    where: ChoiceWhereUniqueInput
  }


  /**
   * Choice updateMany
   */
  export type ChoiceUpdateManyArgs = {
    /**
     * The data used to update Choices.
     */
    data: XOR<ChoiceUpdateManyMutationInput, ChoiceUncheckedUpdateManyInput>
    /**
     * Filter which Choices to update
     */
    where?: ChoiceWhereInput
  }


  /**
   * Choice upsert
   */
  export type ChoiceUpsertArgs = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceInclude | null
    /**
     * The filter to search for the Choice to update in case it exists.
     */
    where: ChoiceWhereUniqueInput
    /**
     * In case the Choice found by the `where` argument doesn't exist, create a new Choice with this data.
     */
    create: XOR<ChoiceCreateInput, ChoiceUncheckedCreateInput>
    /**
     * In case the Choice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChoiceUpdateInput, ChoiceUncheckedUpdateInput>
  }


  /**
   * Choice delete
   */
  export type ChoiceDeleteArgs = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceInclude | null
    /**
     * Filter which Choice to delete.
     */
    where: ChoiceWhereUniqueInput
  }


  /**
   * Choice deleteMany
   */
  export type ChoiceDeleteManyArgs = {
    /**
     * Filter which Choices to delete
     */
    where?: ChoiceWhereInput
  }


  /**
   * Choice.correctQuizzes
   */
  export type Choice$correctQuizzesArgs = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizInclude | null
    where?: QuizWhereInput
    orderBy?: Enumerable<QuizOrderByWithRelationInput>
    cursor?: QuizWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<QuizScalarFieldEnum>
  }


  /**
   * Choice.rounds
   */
  export type Choice$roundsArgs = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoundInclude | null
    where?: RoundWhereInput
    orderBy?: Enumerable<RoundOrderByWithRelationInput>
    cursor?: RoundWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RoundScalarFieldEnum>
  }


  /**
   * Choice without action
   */
  export type ChoiceArgs = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceInclude | null
  }



  /**
   * Model Quiz
   */


  export type AggregateQuiz = {
    _count: QuizCountAggregateOutputType | null
    _avg: QuizAvgAggregateOutputType | null
    _sum: QuizSumAggregateOutputType | null
    _min: QuizMinAggregateOutputType | null
    _max: QuizMaxAggregateOutputType | null
  }

  export type QuizAvgAggregateOutputType = {
    id: number | null
    quizCategoryId: number | null
    correctChoiceId: number | null
  }

  export type QuizSumAggregateOutputType = {
    id: number | null
    quizCategoryId: number | null
    correctChoiceId: number | null
  }

  export type QuizMinAggregateOutputType = {
    id: number | null
    questionText: string | null
    quizCategoryId: number | null
    correctChoiceId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizMaxAggregateOutputType = {
    id: number | null
    questionText: string | null
    quizCategoryId: number | null
    correctChoiceId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizCountAggregateOutputType = {
    id: number
    questionText: number
    quizCategoryId: number
    correctChoiceId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuizAvgAggregateInputType = {
    id?: true
    quizCategoryId?: true
    correctChoiceId?: true
  }

  export type QuizSumAggregateInputType = {
    id?: true
    quizCategoryId?: true
    correctChoiceId?: true
  }

  export type QuizMinAggregateInputType = {
    id?: true
    questionText?: true
    quizCategoryId?: true
    correctChoiceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizMaxAggregateInputType = {
    id?: true
    questionText?: true
    quizCategoryId?: true
    correctChoiceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizCountAggregateInputType = {
    id?: true
    questionText?: true
    quizCategoryId?: true
    correctChoiceId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuizAggregateArgs = {
    /**
     * Filter which Quiz to aggregate.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: Enumerable<QuizOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Quizzes
    **/
    _count?: true | QuizCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizMaxAggregateInputType
  }

  export type GetQuizAggregateType<T extends QuizAggregateArgs> = {
        [P in keyof T & keyof AggregateQuiz]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuiz[P]>
      : GetScalarType<T[P], AggregateQuiz[P]>
  }




  export type QuizGroupByArgs = {
    where?: QuizWhereInput
    orderBy?: Enumerable<QuizOrderByWithAggregationInput>
    by: QuizScalarFieldEnum[]
    having?: QuizScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizCountAggregateInputType | true
    _avg?: QuizAvgAggregateInputType
    _sum?: QuizSumAggregateInputType
    _min?: QuizMinAggregateInputType
    _max?: QuizMaxAggregateInputType
  }


  export type QuizGroupByOutputType = {
    id: number
    questionText: string
    quizCategoryId: number
    correctChoiceId: number
    createdAt: Date
    updatedAt: Date
    _count: QuizCountAggregateOutputType | null
    _avg: QuizAvgAggregateOutputType | null
    _sum: QuizSumAggregateOutputType | null
    _min: QuizMinAggregateOutputType | null
    _max: QuizMaxAggregateOutputType | null
  }

  type GetQuizGroupByPayload<T extends QuizGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<QuizGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizGroupByOutputType[P]>
            : GetScalarType<T[P], QuizGroupByOutputType[P]>
        }
      >
    >


  export type QuizSelect = {
    id?: boolean
    questionText?: boolean
    category?: boolean | QuizCategoryArgs
    quizCategoryId?: boolean
    choices?: boolean | Quiz$choicesArgs
    correctChoice?: boolean | ChoiceArgs
    correctChoiceId?: boolean
    rounds?: boolean | Quiz$roundsArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | QuizCountOutputTypeArgs
  }


  export type QuizInclude = {
    category?: boolean | QuizCategoryArgs
    choices?: boolean | Quiz$choicesArgs
    correctChoice?: boolean | ChoiceArgs
    rounds?: boolean | Quiz$roundsArgs
    _count?: boolean | QuizCountOutputTypeArgs
  }

  export type QuizGetPayload<S extends boolean | null | undefined | QuizArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Quiz :
    S extends undefined ? never :
    S extends { include: any } & (QuizArgs | QuizFindManyArgs)
    ? Quiz  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'category' ? QuizCategoryGetPayload<S['include'][P]> :
        P extends 'choices' ? Array < ChoiceGetPayload<S['include'][P]>>  :
        P extends 'correctChoice' ? ChoiceGetPayload<S['include'][P]> :
        P extends 'rounds' ? Array < RoundGetPayload<S['include'][P]>>  :
        P extends '_count' ? QuizCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (QuizArgs | QuizFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'category' ? QuizCategoryGetPayload<S['select'][P]> :
        P extends 'choices' ? Array < ChoiceGetPayload<S['select'][P]>>  :
        P extends 'correctChoice' ? ChoiceGetPayload<S['select'][P]> :
        P extends 'rounds' ? Array < RoundGetPayload<S['select'][P]>>  :
        P extends '_count' ? QuizCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Quiz ? Quiz[P] : never
  } 
      : Quiz


  type QuizCountArgs = 
    Omit<QuizFindManyArgs, 'select' | 'include'> & {
      select?: QuizCountAggregateInputType | true
    }

  export interface QuizDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Quiz that matches the filter.
     * @param {QuizFindUniqueArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuizFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, QuizFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Quiz'> extends True ? Prisma__QuizClient<QuizGetPayload<T>> : Prisma__QuizClient<QuizGetPayload<T> | null, null>

    /**
     * Find one Quiz that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {QuizFindUniqueOrThrowArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QuizFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, QuizFindUniqueOrThrowArgs>
    ): Prisma__QuizClient<QuizGetPayload<T>>

    /**
     * Find the first Quiz that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizFindFirstArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuizFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, QuizFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Quiz'> extends True ? Prisma__QuizClient<QuizGetPayload<T>> : Prisma__QuizClient<QuizGetPayload<T> | null, null>

    /**
     * Find the first Quiz that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizFindFirstOrThrowArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QuizFindFirstOrThrowArgs>(
      args?: SelectSubset<T, QuizFindFirstOrThrowArgs>
    ): Prisma__QuizClient<QuizGetPayload<T>>

    /**
     * Find zero or more Quizzes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quizzes
     * const quizzes = await prisma.quiz.findMany()
     * 
     * // Get first 10 Quizzes
     * const quizzes = await prisma.quiz.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizWithIdOnly = await prisma.quiz.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends QuizFindManyArgs>(
      args?: SelectSubset<T, QuizFindManyArgs>
    ): Prisma.PrismaPromise<Array<QuizGetPayload<T>>>

    /**
     * Create a Quiz.
     * @param {QuizCreateArgs} args - Arguments to create a Quiz.
     * @example
     * // Create one Quiz
     * const Quiz = await prisma.quiz.create({
     *   data: {
     *     // ... data to create a Quiz
     *   }
     * })
     * 
    **/
    create<T extends QuizCreateArgs>(
      args: SelectSubset<T, QuizCreateArgs>
    ): Prisma__QuizClient<QuizGetPayload<T>>

    /**
     * Create many Quizzes.
     *     @param {QuizCreateManyArgs} args - Arguments to create many Quizzes.
     *     @example
     *     // Create many Quizzes
     *     const quiz = await prisma.quiz.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QuizCreateManyArgs>(
      args?: SelectSubset<T, QuizCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Quiz.
     * @param {QuizDeleteArgs} args - Arguments to delete one Quiz.
     * @example
     * // Delete one Quiz
     * const Quiz = await prisma.quiz.delete({
     *   where: {
     *     // ... filter to delete one Quiz
     *   }
     * })
     * 
    **/
    delete<T extends QuizDeleteArgs>(
      args: SelectSubset<T, QuizDeleteArgs>
    ): Prisma__QuizClient<QuizGetPayload<T>>

    /**
     * Update one Quiz.
     * @param {QuizUpdateArgs} args - Arguments to update one Quiz.
     * @example
     * // Update one Quiz
     * const quiz = await prisma.quiz.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuizUpdateArgs>(
      args: SelectSubset<T, QuizUpdateArgs>
    ): Prisma__QuizClient<QuizGetPayload<T>>

    /**
     * Delete zero or more Quizzes.
     * @param {QuizDeleteManyArgs} args - Arguments to filter Quizzes to delete.
     * @example
     * // Delete a few Quizzes
     * const { count } = await prisma.quiz.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuizDeleteManyArgs>(
      args?: SelectSubset<T, QuizDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quizzes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quizzes
     * const quiz = await prisma.quiz.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuizUpdateManyArgs>(
      args: SelectSubset<T, QuizUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Quiz.
     * @param {QuizUpsertArgs} args - Arguments to update or create a Quiz.
     * @example
     * // Update or create a Quiz
     * const quiz = await prisma.quiz.upsert({
     *   create: {
     *     // ... data to create a Quiz
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quiz we want to update
     *   }
     * })
    **/
    upsert<T extends QuizUpsertArgs>(
      args: SelectSubset<T, QuizUpsertArgs>
    ): Prisma__QuizClient<QuizGetPayload<T>>

    /**
     * Count the number of Quizzes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizCountArgs} args - Arguments to filter Quizzes to count.
     * @example
     * // Count the number of Quizzes
     * const count = await prisma.quiz.count({
     *   where: {
     *     // ... the filter for the Quizzes we want to count
     *   }
     * })
    **/
    count<T extends QuizCountArgs>(
      args?: Subset<T, QuizCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quiz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizAggregateArgs>(args: Subset<T, QuizAggregateArgs>): Prisma.PrismaPromise<GetQuizAggregateType<T>>

    /**
     * Group by Quiz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizGroupByArgs['orderBy'] }
        : { orderBy?: QuizGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Quiz.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__QuizClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    category<T extends QuizCategoryArgs= {}>(args?: Subset<T, QuizCategoryArgs>): Prisma__QuizCategoryClient<QuizCategoryGetPayload<T> | Null>;

    choices<T extends Quiz$choicesArgs= {}>(args?: Subset<T, Quiz$choicesArgs>): Prisma.PrismaPromise<Array<ChoiceGetPayload<T>>| Null>;

    correctChoice<T extends ChoiceArgs= {}>(args?: Subset<T, ChoiceArgs>): Prisma__ChoiceClient<ChoiceGetPayload<T> | Null>;

    rounds<T extends Quiz$roundsArgs= {}>(args?: Subset<T, Quiz$roundsArgs>): Prisma.PrismaPromise<Array<RoundGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Quiz base type for findUnique actions
   */
  export type QuizFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizInclude | null
    /**
     * Filter, which Quiz to fetch.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz findUnique
   */
  export interface QuizFindUniqueArgs extends QuizFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Quiz findUniqueOrThrow
   */
  export type QuizFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizInclude | null
    /**
     * Filter, which Quiz to fetch.
     */
    where: QuizWhereUniqueInput
  }


  /**
   * Quiz base type for findFirst actions
   */
  export type QuizFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizInclude | null
    /**
     * Filter, which Quiz to fetch.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: Enumerable<QuizOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quizzes.
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quizzes.
     */
    distinct?: Enumerable<QuizScalarFieldEnum>
  }

  /**
   * Quiz findFirst
   */
  export interface QuizFindFirstArgs extends QuizFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Quiz findFirstOrThrow
   */
  export type QuizFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizInclude | null
    /**
     * Filter, which Quiz to fetch.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: Enumerable<QuizOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quizzes.
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quizzes.
     */
    distinct?: Enumerable<QuizScalarFieldEnum>
  }


  /**
   * Quiz findMany
   */
  export type QuizFindManyArgs = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizInclude | null
    /**
     * Filter, which Quizzes to fetch.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: Enumerable<QuizOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Quizzes.
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    distinct?: Enumerable<QuizScalarFieldEnum>
  }


  /**
   * Quiz create
   */
  export type QuizCreateArgs = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizInclude | null
    /**
     * The data needed to create a Quiz.
     */
    data: XOR<QuizCreateInput, QuizUncheckedCreateInput>
  }


  /**
   * Quiz createMany
   */
  export type QuizCreateManyArgs = {
    /**
     * The data used to create many Quizzes.
     */
    data: Enumerable<QuizCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Quiz update
   */
  export type QuizUpdateArgs = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizInclude | null
    /**
     * The data needed to update a Quiz.
     */
    data: XOR<QuizUpdateInput, QuizUncheckedUpdateInput>
    /**
     * Choose, which Quiz to update.
     */
    where: QuizWhereUniqueInput
  }


  /**
   * Quiz updateMany
   */
  export type QuizUpdateManyArgs = {
    /**
     * The data used to update Quizzes.
     */
    data: XOR<QuizUpdateManyMutationInput, QuizUncheckedUpdateManyInput>
    /**
     * Filter which Quizzes to update
     */
    where?: QuizWhereInput
  }


  /**
   * Quiz upsert
   */
  export type QuizUpsertArgs = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizInclude | null
    /**
     * The filter to search for the Quiz to update in case it exists.
     */
    where: QuizWhereUniqueInput
    /**
     * In case the Quiz found by the `where` argument doesn't exist, create a new Quiz with this data.
     */
    create: XOR<QuizCreateInput, QuizUncheckedCreateInput>
    /**
     * In case the Quiz was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizUpdateInput, QuizUncheckedUpdateInput>
  }


  /**
   * Quiz delete
   */
  export type QuizDeleteArgs = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizInclude | null
    /**
     * Filter which Quiz to delete.
     */
    where: QuizWhereUniqueInput
  }


  /**
   * Quiz deleteMany
   */
  export type QuizDeleteManyArgs = {
    /**
     * Filter which Quizzes to delete
     */
    where?: QuizWhereInput
  }


  /**
   * Quiz.choices
   */
  export type Quiz$choicesArgs = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceInclude | null
    where?: ChoiceWhereInput
    orderBy?: Enumerable<ChoiceOrderByWithRelationInput>
    cursor?: ChoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ChoiceScalarFieldEnum>
  }


  /**
   * Quiz.rounds
   */
  export type Quiz$roundsArgs = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoundInclude | null
    where?: RoundWhereInput
    orderBy?: Enumerable<RoundOrderByWithRelationInput>
    cursor?: RoundWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RoundScalarFieldEnum>
  }


  /**
   * Quiz without action
   */
  export type QuizArgs = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizInclude | null
  }



  /**
   * Model Round
   */


  export type AggregateRound = {
    _count: RoundCountAggregateOutputType | null
    _avg: RoundAvgAggregateOutputType | null
    _sum: RoundSumAggregateOutputType | null
    _min: RoundMinAggregateOutputType | null
    _max: RoundMaxAggregateOutputType | null
  }

  export type RoundAvgAggregateOutputType = {
    id: number | null
  }

  export type RoundSumAggregateOutputType = {
    id: number | null
  }

  export type RoundMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoundMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoundCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoundAvgAggregateInputType = {
    id?: true
  }

  export type RoundSumAggregateInputType = {
    id?: true
  }

  export type RoundMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoundMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoundCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoundAggregateArgs = {
    /**
     * Filter which Round to aggregate.
     */
    where?: RoundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rounds to fetch.
     */
    orderBy?: Enumerable<RoundOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rounds
    **/
    _count?: true | RoundCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoundAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoundSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoundMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoundMaxAggregateInputType
  }

  export type GetRoundAggregateType<T extends RoundAggregateArgs> = {
        [P in keyof T & keyof AggregateRound]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRound[P]>
      : GetScalarType<T[P], AggregateRound[P]>
  }




  export type RoundGroupByArgs = {
    where?: RoundWhereInput
    orderBy?: Enumerable<RoundOrderByWithAggregationInput>
    by: RoundScalarFieldEnum[]
    having?: RoundScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoundCountAggregateInputType | true
    _avg?: RoundAvgAggregateInputType
    _sum?: RoundSumAggregateInputType
    _min?: RoundMinAggregateInputType
    _max?: RoundMaxAggregateInputType
  }


  export type RoundGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    _count: RoundCountAggregateOutputType | null
    _avg: RoundAvgAggregateOutputType | null
    _sum: RoundSumAggregateOutputType | null
    _min: RoundMinAggregateOutputType | null
    _max: RoundMaxAggregateOutputType | null
  }

  type GetRoundGroupByPayload<T extends RoundGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RoundGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoundGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoundGroupByOutputType[P]>
            : GetScalarType<T[P], RoundGroupByOutputType[P]>
        }
      >
    >


  export type RoundSelect = {
    id?: boolean
    quizzes?: boolean | Round$quizzesArgs
    selectedChoices?: boolean | Round$selectedChoicesArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | RoundCountOutputTypeArgs
  }


  export type RoundInclude = {
    quizzes?: boolean | Round$quizzesArgs
    selectedChoices?: boolean | Round$selectedChoicesArgs
    _count?: boolean | RoundCountOutputTypeArgs
  }

  export type RoundGetPayload<S extends boolean | null | undefined | RoundArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Round :
    S extends undefined ? never :
    S extends { include: any } & (RoundArgs | RoundFindManyArgs)
    ? Round  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'quizzes' ? Array < QuizGetPayload<S['include'][P]>>  :
        P extends 'selectedChoices' ? Array < ChoiceGetPayload<S['include'][P]>>  :
        P extends '_count' ? RoundCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (RoundArgs | RoundFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'quizzes' ? Array < QuizGetPayload<S['select'][P]>>  :
        P extends 'selectedChoices' ? Array < ChoiceGetPayload<S['select'][P]>>  :
        P extends '_count' ? RoundCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Round ? Round[P] : never
  } 
      : Round


  type RoundCountArgs = 
    Omit<RoundFindManyArgs, 'select' | 'include'> & {
      select?: RoundCountAggregateInputType | true
    }

  export interface RoundDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Round that matches the filter.
     * @param {RoundFindUniqueArgs} args - Arguments to find a Round
     * @example
     * // Get one Round
     * const round = await prisma.round.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RoundFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RoundFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Round'> extends True ? Prisma__RoundClient<RoundGetPayload<T>> : Prisma__RoundClient<RoundGetPayload<T> | null, null>

    /**
     * Find one Round that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RoundFindUniqueOrThrowArgs} args - Arguments to find a Round
     * @example
     * // Get one Round
     * const round = await prisma.round.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RoundFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RoundFindUniqueOrThrowArgs>
    ): Prisma__RoundClient<RoundGetPayload<T>>

    /**
     * Find the first Round that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundFindFirstArgs} args - Arguments to find a Round
     * @example
     * // Get one Round
     * const round = await prisma.round.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RoundFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RoundFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Round'> extends True ? Prisma__RoundClient<RoundGetPayload<T>> : Prisma__RoundClient<RoundGetPayload<T> | null, null>

    /**
     * Find the first Round that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundFindFirstOrThrowArgs} args - Arguments to find a Round
     * @example
     * // Get one Round
     * const round = await prisma.round.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RoundFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RoundFindFirstOrThrowArgs>
    ): Prisma__RoundClient<RoundGetPayload<T>>

    /**
     * Find zero or more Rounds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rounds
     * const rounds = await prisma.round.findMany()
     * 
     * // Get first 10 Rounds
     * const rounds = await prisma.round.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roundWithIdOnly = await prisma.round.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RoundFindManyArgs>(
      args?: SelectSubset<T, RoundFindManyArgs>
    ): Prisma.PrismaPromise<Array<RoundGetPayload<T>>>

    /**
     * Create a Round.
     * @param {RoundCreateArgs} args - Arguments to create a Round.
     * @example
     * // Create one Round
     * const Round = await prisma.round.create({
     *   data: {
     *     // ... data to create a Round
     *   }
     * })
     * 
    **/
    create<T extends RoundCreateArgs>(
      args: SelectSubset<T, RoundCreateArgs>
    ): Prisma__RoundClient<RoundGetPayload<T>>

    /**
     * Create many Rounds.
     *     @param {RoundCreateManyArgs} args - Arguments to create many Rounds.
     *     @example
     *     // Create many Rounds
     *     const round = await prisma.round.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RoundCreateManyArgs>(
      args?: SelectSubset<T, RoundCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Round.
     * @param {RoundDeleteArgs} args - Arguments to delete one Round.
     * @example
     * // Delete one Round
     * const Round = await prisma.round.delete({
     *   where: {
     *     // ... filter to delete one Round
     *   }
     * })
     * 
    **/
    delete<T extends RoundDeleteArgs>(
      args: SelectSubset<T, RoundDeleteArgs>
    ): Prisma__RoundClient<RoundGetPayload<T>>

    /**
     * Update one Round.
     * @param {RoundUpdateArgs} args - Arguments to update one Round.
     * @example
     * // Update one Round
     * const round = await prisma.round.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RoundUpdateArgs>(
      args: SelectSubset<T, RoundUpdateArgs>
    ): Prisma__RoundClient<RoundGetPayload<T>>

    /**
     * Delete zero or more Rounds.
     * @param {RoundDeleteManyArgs} args - Arguments to filter Rounds to delete.
     * @example
     * // Delete a few Rounds
     * const { count } = await prisma.round.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RoundDeleteManyArgs>(
      args?: SelectSubset<T, RoundDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rounds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rounds
     * const round = await prisma.round.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RoundUpdateManyArgs>(
      args: SelectSubset<T, RoundUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Round.
     * @param {RoundUpsertArgs} args - Arguments to update or create a Round.
     * @example
     * // Update or create a Round
     * const round = await prisma.round.upsert({
     *   create: {
     *     // ... data to create a Round
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Round we want to update
     *   }
     * })
    **/
    upsert<T extends RoundUpsertArgs>(
      args: SelectSubset<T, RoundUpsertArgs>
    ): Prisma__RoundClient<RoundGetPayload<T>>

    /**
     * Count the number of Rounds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundCountArgs} args - Arguments to filter Rounds to count.
     * @example
     * // Count the number of Rounds
     * const count = await prisma.round.count({
     *   where: {
     *     // ... the filter for the Rounds we want to count
     *   }
     * })
    **/
    count<T extends RoundCountArgs>(
      args?: Subset<T, RoundCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoundCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Round.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoundAggregateArgs>(args: Subset<T, RoundAggregateArgs>): Prisma.PrismaPromise<GetRoundAggregateType<T>>

    /**
     * Group by Round.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoundGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoundGroupByArgs['orderBy'] }
        : { orderBy?: RoundGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoundGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoundGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Round.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RoundClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    quizzes<T extends Round$quizzesArgs= {}>(args?: Subset<T, Round$quizzesArgs>): Prisma.PrismaPromise<Array<QuizGetPayload<T>>| Null>;

    selectedChoices<T extends Round$selectedChoicesArgs= {}>(args?: Subset<T, Round$selectedChoicesArgs>): Prisma.PrismaPromise<Array<ChoiceGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Round base type for findUnique actions
   */
  export type RoundFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoundInclude | null
    /**
     * Filter, which Round to fetch.
     */
    where: RoundWhereUniqueInput
  }

  /**
   * Round findUnique
   */
  export interface RoundFindUniqueArgs extends RoundFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Round findUniqueOrThrow
   */
  export type RoundFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoundInclude | null
    /**
     * Filter, which Round to fetch.
     */
    where: RoundWhereUniqueInput
  }


  /**
   * Round base type for findFirst actions
   */
  export type RoundFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoundInclude | null
    /**
     * Filter, which Round to fetch.
     */
    where?: RoundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rounds to fetch.
     */
    orderBy?: Enumerable<RoundOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rounds.
     */
    cursor?: RoundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rounds.
     */
    distinct?: Enumerable<RoundScalarFieldEnum>
  }

  /**
   * Round findFirst
   */
  export interface RoundFindFirstArgs extends RoundFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Round findFirstOrThrow
   */
  export type RoundFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoundInclude | null
    /**
     * Filter, which Round to fetch.
     */
    where?: RoundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rounds to fetch.
     */
    orderBy?: Enumerable<RoundOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rounds.
     */
    cursor?: RoundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rounds.
     */
    distinct?: Enumerable<RoundScalarFieldEnum>
  }


  /**
   * Round findMany
   */
  export type RoundFindManyArgs = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoundInclude | null
    /**
     * Filter, which Rounds to fetch.
     */
    where?: RoundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rounds to fetch.
     */
    orderBy?: Enumerable<RoundOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rounds.
     */
    cursor?: RoundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rounds.
     */
    skip?: number
    distinct?: Enumerable<RoundScalarFieldEnum>
  }


  /**
   * Round create
   */
  export type RoundCreateArgs = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoundInclude | null
    /**
     * The data needed to create a Round.
     */
    data: XOR<RoundCreateInput, RoundUncheckedCreateInput>
  }


  /**
   * Round createMany
   */
  export type RoundCreateManyArgs = {
    /**
     * The data used to create many Rounds.
     */
    data: Enumerable<RoundCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Round update
   */
  export type RoundUpdateArgs = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoundInclude | null
    /**
     * The data needed to update a Round.
     */
    data: XOR<RoundUpdateInput, RoundUncheckedUpdateInput>
    /**
     * Choose, which Round to update.
     */
    where: RoundWhereUniqueInput
  }


  /**
   * Round updateMany
   */
  export type RoundUpdateManyArgs = {
    /**
     * The data used to update Rounds.
     */
    data: XOR<RoundUpdateManyMutationInput, RoundUncheckedUpdateManyInput>
    /**
     * Filter which Rounds to update
     */
    where?: RoundWhereInput
  }


  /**
   * Round upsert
   */
  export type RoundUpsertArgs = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoundInclude | null
    /**
     * The filter to search for the Round to update in case it exists.
     */
    where: RoundWhereUniqueInput
    /**
     * In case the Round found by the `where` argument doesn't exist, create a new Round with this data.
     */
    create: XOR<RoundCreateInput, RoundUncheckedCreateInput>
    /**
     * In case the Round was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoundUpdateInput, RoundUncheckedUpdateInput>
  }


  /**
   * Round delete
   */
  export type RoundDeleteArgs = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoundInclude | null
    /**
     * Filter which Round to delete.
     */
    where: RoundWhereUniqueInput
  }


  /**
   * Round deleteMany
   */
  export type RoundDeleteManyArgs = {
    /**
     * Filter which Rounds to delete
     */
    where?: RoundWhereInput
  }


  /**
   * Round.quizzes
   */
  export type Round$quizzesArgs = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizInclude | null
    where?: QuizWhereInput
    orderBy?: Enumerable<QuizOrderByWithRelationInput>
    cursor?: QuizWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<QuizScalarFieldEnum>
  }


  /**
   * Round.selectedChoices
   */
  export type Round$selectedChoicesArgs = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceInclude | null
    where?: ChoiceWhereInput
    orderBy?: Enumerable<ChoiceOrderByWithRelationInput>
    cursor?: ChoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ChoiceScalarFieldEnum>
  }


  /**
   * Round without action
   */
  export type RoundArgs = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoundInclude | null
  }



  /**
   * Model FacebookUser
   */


  export type AggregateFacebookUser = {
    _count: FacebookUserCountAggregateOutputType | null
    _avg: FacebookUserAvgAggregateOutputType | null
    _sum: FacebookUserSumAggregateOutputType | null
    _min: FacebookUserMinAggregateOutputType | null
    _max: FacebookUserMaxAggregateOutputType | null
  }

  export type FacebookUserAvgAggregateOutputType = {
    id: number | null
  }

  export type FacebookUserSumAggregateOutputType = {
    id: number | null
  }

  export type FacebookUserMinAggregateOutputType = {
    id: number | null
    name: string | null
    imageUrl: string | null
    bio: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacebookUserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    imageUrl: string | null
    bio: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacebookUserCountAggregateOutputType = {
    id: number
    name: number
    imageUrl: number
    bio: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FacebookUserAvgAggregateInputType = {
    id?: true
  }

  export type FacebookUserSumAggregateInputType = {
    id?: true
  }

  export type FacebookUserMinAggregateInputType = {
    id?: true
    name?: true
    imageUrl?: true
    bio?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacebookUserMaxAggregateInputType = {
    id?: true
    name?: true
    imageUrl?: true
    bio?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacebookUserCountAggregateInputType = {
    id?: true
    name?: true
    imageUrl?: true
    bio?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FacebookUserAggregateArgs = {
    /**
     * Filter which FacebookUser to aggregate.
     */
    where?: FacebookUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookUsers to fetch.
     */
    orderBy?: Enumerable<FacebookUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacebookUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FacebookUsers
    **/
    _count?: true | FacebookUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FacebookUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FacebookUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacebookUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacebookUserMaxAggregateInputType
  }

  export type GetFacebookUserAggregateType<T extends FacebookUserAggregateArgs> = {
        [P in keyof T & keyof AggregateFacebookUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacebookUser[P]>
      : GetScalarType<T[P], AggregateFacebookUser[P]>
  }




  export type FacebookUserGroupByArgs = {
    where?: FacebookUserWhereInput
    orderBy?: Enumerable<FacebookUserOrderByWithAggregationInput>
    by: FacebookUserScalarFieldEnum[]
    having?: FacebookUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacebookUserCountAggregateInputType | true
    _avg?: FacebookUserAvgAggregateInputType
    _sum?: FacebookUserSumAggregateInputType
    _min?: FacebookUserMinAggregateInputType
    _max?: FacebookUserMaxAggregateInputType
  }


  export type FacebookUserGroupByOutputType = {
    id: number
    name: string
    imageUrl: string
    bio: string
    createdAt: Date
    updatedAt: Date
    _count: FacebookUserCountAggregateOutputType | null
    _avg: FacebookUserAvgAggregateOutputType | null
    _sum: FacebookUserSumAggregateOutputType | null
    _min: FacebookUserMinAggregateOutputType | null
    _max: FacebookUserMaxAggregateOutputType | null
  }

  type GetFacebookUserGroupByPayload<T extends FacebookUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FacebookUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacebookUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacebookUserGroupByOutputType[P]>
            : GetScalarType<T[P], FacebookUserGroupByOutputType[P]>
        }
      >
    >


  export type FacebookUserSelect = {
    id?: boolean
    name?: boolean
    imageUrl?: boolean
    bio?: boolean
    followingUserRelations?: boolean | FacebookUser$followingUserRelationsArgs
    followedUserRelations?: boolean | FacebookUser$followedUserRelationsArgs
    posts?: boolean | FacebookUser$postsArgs
    comments?: boolean | FacebookUser$commentsArgs
    messengerMessagesFrom?: boolean | FacebookUser$messengerMessagesFromArgs
    messengerMessagesTo?: boolean | FacebookUser$messengerMessagesToArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | FacebookUserCountOutputTypeArgs
  }


  export type FacebookUserInclude = {
    followingUserRelations?: boolean | FacebookUser$followingUserRelationsArgs
    followedUserRelations?: boolean | FacebookUser$followedUserRelationsArgs
    posts?: boolean | FacebookUser$postsArgs
    comments?: boolean | FacebookUser$commentsArgs
    messengerMessagesFrom?: boolean | FacebookUser$messengerMessagesFromArgs
    messengerMessagesTo?: boolean | FacebookUser$messengerMessagesToArgs
    _count?: boolean | FacebookUserCountOutputTypeArgs
  }

  export type FacebookUserGetPayload<S extends boolean | null | undefined | FacebookUserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FacebookUser :
    S extends undefined ? never :
    S extends { include: any } & (FacebookUserArgs | FacebookUserFindManyArgs)
    ? FacebookUser  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'followingUserRelations' ? Array < FacebookUserRelationGetPayload<S['include'][P]>>  :
        P extends 'followedUserRelations' ? Array < FacebookUserRelationGetPayload<S['include'][P]>>  :
        P extends 'posts' ? Array < PostGetPayload<S['include'][P]>>  :
        P extends 'comments' ? Array < CommentGetPayload<S['include'][P]>>  :
        P extends 'messengerMessagesFrom' ? Array < MessengerMessageGetPayload<S['include'][P]>>  :
        P extends 'messengerMessagesTo' ? Array < MessengerMessageGetPayload<S['include'][P]>>  :
        P extends '_count' ? FacebookUserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FacebookUserArgs | FacebookUserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'followingUserRelations' ? Array < FacebookUserRelationGetPayload<S['select'][P]>>  :
        P extends 'followedUserRelations' ? Array < FacebookUserRelationGetPayload<S['select'][P]>>  :
        P extends 'posts' ? Array < PostGetPayload<S['select'][P]>>  :
        P extends 'comments' ? Array < CommentGetPayload<S['select'][P]>>  :
        P extends 'messengerMessagesFrom' ? Array < MessengerMessageGetPayload<S['select'][P]>>  :
        P extends 'messengerMessagesTo' ? Array < MessengerMessageGetPayload<S['select'][P]>>  :
        P extends '_count' ? FacebookUserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof FacebookUser ? FacebookUser[P] : never
  } 
      : FacebookUser


  type FacebookUserCountArgs = 
    Omit<FacebookUserFindManyArgs, 'select' | 'include'> & {
      select?: FacebookUserCountAggregateInputType | true
    }

  export interface FacebookUserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one FacebookUser that matches the filter.
     * @param {FacebookUserFindUniqueArgs} args - Arguments to find a FacebookUser
     * @example
     * // Get one FacebookUser
     * const facebookUser = await prisma.facebookUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FacebookUserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FacebookUserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FacebookUser'> extends True ? Prisma__FacebookUserClient<FacebookUserGetPayload<T>> : Prisma__FacebookUserClient<FacebookUserGetPayload<T> | null, null>

    /**
     * Find one FacebookUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FacebookUserFindUniqueOrThrowArgs} args - Arguments to find a FacebookUser
     * @example
     * // Get one FacebookUser
     * const facebookUser = await prisma.facebookUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FacebookUserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FacebookUserFindUniqueOrThrowArgs>
    ): Prisma__FacebookUserClient<FacebookUserGetPayload<T>>

    /**
     * Find the first FacebookUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserFindFirstArgs} args - Arguments to find a FacebookUser
     * @example
     * // Get one FacebookUser
     * const facebookUser = await prisma.facebookUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FacebookUserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FacebookUserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FacebookUser'> extends True ? Prisma__FacebookUserClient<FacebookUserGetPayload<T>> : Prisma__FacebookUserClient<FacebookUserGetPayload<T> | null, null>

    /**
     * Find the first FacebookUser that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserFindFirstOrThrowArgs} args - Arguments to find a FacebookUser
     * @example
     * // Get one FacebookUser
     * const facebookUser = await prisma.facebookUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FacebookUserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FacebookUserFindFirstOrThrowArgs>
    ): Prisma__FacebookUserClient<FacebookUserGetPayload<T>>

    /**
     * Find zero or more FacebookUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FacebookUsers
     * const facebookUsers = await prisma.facebookUser.findMany()
     * 
     * // Get first 10 FacebookUsers
     * const facebookUsers = await prisma.facebookUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facebookUserWithIdOnly = await prisma.facebookUser.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FacebookUserFindManyArgs>(
      args?: SelectSubset<T, FacebookUserFindManyArgs>
    ): Prisma.PrismaPromise<Array<FacebookUserGetPayload<T>>>

    /**
     * Create a FacebookUser.
     * @param {FacebookUserCreateArgs} args - Arguments to create a FacebookUser.
     * @example
     * // Create one FacebookUser
     * const FacebookUser = await prisma.facebookUser.create({
     *   data: {
     *     // ... data to create a FacebookUser
     *   }
     * })
     * 
    **/
    create<T extends FacebookUserCreateArgs>(
      args: SelectSubset<T, FacebookUserCreateArgs>
    ): Prisma__FacebookUserClient<FacebookUserGetPayload<T>>

    /**
     * Create many FacebookUsers.
     *     @param {FacebookUserCreateManyArgs} args - Arguments to create many FacebookUsers.
     *     @example
     *     // Create many FacebookUsers
     *     const facebookUser = await prisma.facebookUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FacebookUserCreateManyArgs>(
      args?: SelectSubset<T, FacebookUserCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FacebookUser.
     * @param {FacebookUserDeleteArgs} args - Arguments to delete one FacebookUser.
     * @example
     * // Delete one FacebookUser
     * const FacebookUser = await prisma.facebookUser.delete({
     *   where: {
     *     // ... filter to delete one FacebookUser
     *   }
     * })
     * 
    **/
    delete<T extends FacebookUserDeleteArgs>(
      args: SelectSubset<T, FacebookUserDeleteArgs>
    ): Prisma__FacebookUserClient<FacebookUserGetPayload<T>>

    /**
     * Update one FacebookUser.
     * @param {FacebookUserUpdateArgs} args - Arguments to update one FacebookUser.
     * @example
     * // Update one FacebookUser
     * const facebookUser = await prisma.facebookUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FacebookUserUpdateArgs>(
      args: SelectSubset<T, FacebookUserUpdateArgs>
    ): Prisma__FacebookUserClient<FacebookUserGetPayload<T>>

    /**
     * Delete zero or more FacebookUsers.
     * @param {FacebookUserDeleteManyArgs} args - Arguments to filter FacebookUsers to delete.
     * @example
     * // Delete a few FacebookUsers
     * const { count } = await prisma.facebookUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FacebookUserDeleteManyArgs>(
      args?: SelectSubset<T, FacebookUserDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacebookUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FacebookUsers
     * const facebookUser = await prisma.facebookUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FacebookUserUpdateManyArgs>(
      args: SelectSubset<T, FacebookUserUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FacebookUser.
     * @param {FacebookUserUpsertArgs} args - Arguments to update or create a FacebookUser.
     * @example
     * // Update or create a FacebookUser
     * const facebookUser = await prisma.facebookUser.upsert({
     *   create: {
     *     // ... data to create a FacebookUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FacebookUser we want to update
     *   }
     * })
    **/
    upsert<T extends FacebookUserUpsertArgs>(
      args: SelectSubset<T, FacebookUserUpsertArgs>
    ): Prisma__FacebookUserClient<FacebookUserGetPayload<T>>

    /**
     * Count the number of FacebookUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserCountArgs} args - Arguments to filter FacebookUsers to count.
     * @example
     * // Count the number of FacebookUsers
     * const count = await prisma.facebookUser.count({
     *   where: {
     *     // ... the filter for the FacebookUsers we want to count
     *   }
     * })
    **/
    count<T extends FacebookUserCountArgs>(
      args?: Subset<T, FacebookUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacebookUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FacebookUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacebookUserAggregateArgs>(args: Subset<T, FacebookUserAggregateArgs>): Prisma.PrismaPromise<GetFacebookUserAggregateType<T>>

    /**
     * Group by FacebookUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacebookUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacebookUserGroupByArgs['orderBy'] }
        : { orderBy?: FacebookUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacebookUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacebookUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FacebookUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FacebookUserClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    followingUserRelations<T extends FacebookUser$followingUserRelationsArgs= {}>(args?: Subset<T, FacebookUser$followingUserRelationsArgs>): Prisma.PrismaPromise<Array<FacebookUserRelationGetPayload<T>>| Null>;

    followedUserRelations<T extends FacebookUser$followedUserRelationsArgs= {}>(args?: Subset<T, FacebookUser$followedUserRelationsArgs>): Prisma.PrismaPromise<Array<FacebookUserRelationGetPayload<T>>| Null>;

    posts<T extends FacebookUser$postsArgs= {}>(args?: Subset<T, FacebookUser$postsArgs>): Prisma.PrismaPromise<Array<PostGetPayload<T>>| Null>;

    comments<T extends FacebookUser$commentsArgs= {}>(args?: Subset<T, FacebookUser$commentsArgs>): Prisma.PrismaPromise<Array<CommentGetPayload<T>>| Null>;

    messengerMessagesFrom<T extends FacebookUser$messengerMessagesFromArgs= {}>(args?: Subset<T, FacebookUser$messengerMessagesFromArgs>): Prisma.PrismaPromise<Array<MessengerMessageGetPayload<T>>| Null>;

    messengerMessagesTo<T extends FacebookUser$messengerMessagesToArgs= {}>(args?: Subset<T, FacebookUser$messengerMessagesToArgs>): Prisma.PrismaPromise<Array<MessengerMessageGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FacebookUser base type for findUnique actions
   */
  export type FacebookUserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FacebookUser
     */
    select?: FacebookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserInclude | null
    /**
     * Filter, which FacebookUser to fetch.
     */
    where: FacebookUserWhereUniqueInput
  }

  /**
   * FacebookUser findUnique
   */
  export interface FacebookUserFindUniqueArgs extends FacebookUserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FacebookUser findUniqueOrThrow
   */
  export type FacebookUserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FacebookUser
     */
    select?: FacebookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserInclude | null
    /**
     * Filter, which FacebookUser to fetch.
     */
    where: FacebookUserWhereUniqueInput
  }


  /**
   * FacebookUser base type for findFirst actions
   */
  export type FacebookUserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FacebookUser
     */
    select?: FacebookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserInclude | null
    /**
     * Filter, which FacebookUser to fetch.
     */
    where?: FacebookUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookUsers to fetch.
     */
    orderBy?: Enumerable<FacebookUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacebookUsers.
     */
    cursor?: FacebookUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacebookUsers.
     */
    distinct?: Enumerable<FacebookUserScalarFieldEnum>
  }

  /**
   * FacebookUser findFirst
   */
  export interface FacebookUserFindFirstArgs extends FacebookUserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FacebookUser findFirstOrThrow
   */
  export type FacebookUserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FacebookUser
     */
    select?: FacebookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserInclude | null
    /**
     * Filter, which FacebookUser to fetch.
     */
    where?: FacebookUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookUsers to fetch.
     */
    orderBy?: Enumerable<FacebookUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacebookUsers.
     */
    cursor?: FacebookUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacebookUsers.
     */
    distinct?: Enumerable<FacebookUserScalarFieldEnum>
  }


  /**
   * FacebookUser findMany
   */
  export type FacebookUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the FacebookUser
     */
    select?: FacebookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserInclude | null
    /**
     * Filter, which FacebookUsers to fetch.
     */
    where?: FacebookUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookUsers to fetch.
     */
    orderBy?: Enumerable<FacebookUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FacebookUsers.
     */
    cursor?: FacebookUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookUsers.
     */
    skip?: number
    distinct?: Enumerable<FacebookUserScalarFieldEnum>
  }


  /**
   * FacebookUser create
   */
  export type FacebookUserCreateArgs = {
    /**
     * Select specific fields to fetch from the FacebookUser
     */
    select?: FacebookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserInclude | null
    /**
     * The data needed to create a FacebookUser.
     */
    data: XOR<FacebookUserCreateInput, FacebookUserUncheckedCreateInput>
  }


  /**
   * FacebookUser createMany
   */
  export type FacebookUserCreateManyArgs = {
    /**
     * The data used to create many FacebookUsers.
     */
    data: Enumerable<FacebookUserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FacebookUser update
   */
  export type FacebookUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the FacebookUser
     */
    select?: FacebookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserInclude | null
    /**
     * The data needed to update a FacebookUser.
     */
    data: XOR<FacebookUserUpdateInput, FacebookUserUncheckedUpdateInput>
    /**
     * Choose, which FacebookUser to update.
     */
    where: FacebookUserWhereUniqueInput
  }


  /**
   * FacebookUser updateMany
   */
  export type FacebookUserUpdateManyArgs = {
    /**
     * The data used to update FacebookUsers.
     */
    data: XOR<FacebookUserUpdateManyMutationInput, FacebookUserUncheckedUpdateManyInput>
    /**
     * Filter which FacebookUsers to update
     */
    where?: FacebookUserWhereInput
  }


  /**
   * FacebookUser upsert
   */
  export type FacebookUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the FacebookUser
     */
    select?: FacebookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserInclude | null
    /**
     * The filter to search for the FacebookUser to update in case it exists.
     */
    where: FacebookUserWhereUniqueInput
    /**
     * In case the FacebookUser found by the `where` argument doesn't exist, create a new FacebookUser with this data.
     */
    create: XOR<FacebookUserCreateInput, FacebookUserUncheckedCreateInput>
    /**
     * In case the FacebookUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacebookUserUpdateInput, FacebookUserUncheckedUpdateInput>
  }


  /**
   * FacebookUser delete
   */
  export type FacebookUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the FacebookUser
     */
    select?: FacebookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserInclude | null
    /**
     * Filter which FacebookUser to delete.
     */
    where: FacebookUserWhereUniqueInput
  }


  /**
   * FacebookUser deleteMany
   */
  export type FacebookUserDeleteManyArgs = {
    /**
     * Filter which FacebookUsers to delete
     */
    where?: FacebookUserWhereInput
  }


  /**
   * FacebookUser.followingUserRelations
   */
  export type FacebookUser$followingUserRelationsArgs = {
    /**
     * Select specific fields to fetch from the FacebookUserRelation
     */
    select?: FacebookUserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserRelationInclude | null
    where?: FacebookUserRelationWhereInput
    orderBy?: Enumerable<FacebookUserRelationOrderByWithRelationInput>
    cursor?: FacebookUserRelationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FacebookUserRelationScalarFieldEnum>
  }


  /**
   * FacebookUser.followedUserRelations
   */
  export type FacebookUser$followedUserRelationsArgs = {
    /**
     * Select specific fields to fetch from the FacebookUserRelation
     */
    select?: FacebookUserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserRelationInclude | null
    where?: FacebookUserRelationWhereInput
    orderBy?: Enumerable<FacebookUserRelationOrderByWithRelationInput>
    cursor?: FacebookUserRelationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FacebookUserRelationScalarFieldEnum>
  }


  /**
   * FacebookUser.posts
   */
  export type FacebookUser$postsArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    where?: PostWhereInput
    orderBy?: Enumerable<PostOrderByWithRelationInput>
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PostScalarFieldEnum>
  }


  /**
   * FacebookUser.comments
   */
  export type FacebookUser$commentsArgs = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
    where?: CommentWhereInput
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CommentScalarFieldEnum>
  }


  /**
   * FacebookUser.messengerMessagesFrom
   */
  export type FacebookUser$messengerMessagesFromArgs = {
    /**
     * Select specific fields to fetch from the MessengerMessage
     */
    select?: MessengerMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessengerMessageInclude | null
    where?: MessengerMessageWhereInput
    orderBy?: Enumerable<MessengerMessageOrderByWithRelationInput>
    cursor?: MessengerMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MessengerMessageScalarFieldEnum>
  }


  /**
   * FacebookUser.messengerMessagesTo
   */
  export type FacebookUser$messengerMessagesToArgs = {
    /**
     * Select specific fields to fetch from the MessengerMessage
     */
    select?: MessengerMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessengerMessageInclude | null
    where?: MessengerMessageWhereInput
    orderBy?: Enumerable<MessengerMessageOrderByWithRelationInput>
    cursor?: MessengerMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MessengerMessageScalarFieldEnum>
  }


  /**
   * FacebookUser without action
   */
  export type FacebookUserArgs = {
    /**
     * Select specific fields to fetch from the FacebookUser
     */
    select?: FacebookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserInclude | null
  }



  /**
   * Model FacebookUserRelation
   */


  export type AggregateFacebookUserRelation = {
    _count: FacebookUserRelationCountAggregateOutputType | null
    _avg: FacebookUserRelationAvgAggregateOutputType | null
    _sum: FacebookUserRelationSumAggregateOutputType | null
    _min: FacebookUserRelationMinAggregateOutputType | null
    _max: FacebookUserRelationMaxAggregateOutputType | null
  }

  export type FacebookUserRelationAvgAggregateOutputType = {
    id: number | null
    followingUserId: number | null
    followedUserId: number | null
  }

  export type FacebookUserRelationSumAggregateOutputType = {
    id: number | null
    followingUserId: number | null
    followedUserId: number | null
  }

  export type FacebookUserRelationMinAggregateOutputType = {
    id: number | null
    followingUserId: number | null
    followedUserId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacebookUserRelationMaxAggregateOutputType = {
    id: number | null
    followingUserId: number | null
    followedUserId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacebookUserRelationCountAggregateOutputType = {
    id: number
    followingUserId: number
    followedUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FacebookUserRelationAvgAggregateInputType = {
    id?: true
    followingUserId?: true
    followedUserId?: true
  }

  export type FacebookUserRelationSumAggregateInputType = {
    id?: true
    followingUserId?: true
    followedUserId?: true
  }

  export type FacebookUserRelationMinAggregateInputType = {
    id?: true
    followingUserId?: true
    followedUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacebookUserRelationMaxAggregateInputType = {
    id?: true
    followingUserId?: true
    followedUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacebookUserRelationCountAggregateInputType = {
    id?: true
    followingUserId?: true
    followedUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FacebookUserRelationAggregateArgs = {
    /**
     * Filter which FacebookUserRelation to aggregate.
     */
    where?: FacebookUserRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookUserRelations to fetch.
     */
    orderBy?: Enumerable<FacebookUserRelationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacebookUserRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookUserRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookUserRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FacebookUserRelations
    **/
    _count?: true | FacebookUserRelationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FacebookUserRelationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FacebookUserRelationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacebookUserRelationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacebookUserRelationMaxAggregateInputType
  }

  export type GetFacebookUserRelationAggregateType<T extends FacebookUserRelationAggregateArgs> = {
        [P in keyof T & keyof AggregateFacebookUserRelation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacebookUserRelation[P]>
      : GetScalarType<T[P], AggregateFacebookUserRelation[P]>
  }




  export type FacebookUserRelationGroupByArgs = {
    where?: FacebookUserRelationWhereInput
    orderBy?: Enumerable<FacebookUserRelationOrderByWithAggregationInput>
    by: FacebookUserRelationScalarFieldEnum[]
    having?: FacebookUserRelationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacebookUserRelationCountAggregateInputType | true
    _avg?: FacebookUserRelationAvgAggregateInputType
    _sum?: FacebookUserRelationSumAggregateInputType
    _min?: FacebookUserRelationMinAggregateInputType
    _max?: FacebookUserRelationMaxAggregateInputType
  }


  export type FacebookUserRelationGroupByOutputType = {
    id: number
    followingUserId: number
    followedUserId: number
    createdAt: Date
    updatedAt: Date
    _count: FacebookUserRelationCountAggregateOutputType | null
    _avg: FacebookUserRelationAvgAggregateOutputType | null
    _sum: FacebookUserRelationSumAggregateOutputType | null
    _min: FacebookUserRelationMinAggregateOutputType | null
    _max: FacebookUserRelationMaxAggregateOutputType | null
  }

  type GetFacebookUserRelationGroupByPayload<T extends FacebookUserRelationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FacebookUserRelationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacebookUserRelationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacebookUserRelationGroupByOutputType[P]>
            : GetScalarType<T[P], FacebookUserRelationGroupByOutputType[P]>
        }
      >
    >


  export type FacebookUserRelationSelect = {
    id?: boolean
    followingUser?: boolean | FacebookUserArgs
    followingUserId?: boolean
    followedUser?: boolean | FacebookUserArgs
    followedUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type FacebookUserRelationInclude = {
    followingUser?: boolean | FacebookUserArgs
    followedUser?: boolean | FacebookUserArgs
  }

  export type FacebookUserRelationGetPayload<S extends boolean | null | undefined | FacebookUserRelationArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FacebookUserRelation :
    S extends undefined ? never :
    S extends { include: any } & (FacebookUserRelationArgs | FacebookUserRelationFindManyArgs)
    ? FacebookUserRelation  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'followingUser' ? FacebookUserGetPayload<S['include'][P]> :
        P extends 'followedUser' ? FacebookUserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FacebookUserRelationArgs | FacebookUserRelationFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'followingUser' ? FacebookUserGetPayload<S['select'][P]> :
        P extends 'followedUser' ? FacebookUserGetPayload<S['select'][P]> :  P extends keyof FacebookUserRelation ? FacebookUserRelation[P] : never
  } 
      : FacebookUserRelation


  type FacebookUserRelationCountArgs = 
    Omit<FacebookUserRelationFindManyArgs, 'select' | 'include'> & {
      select?: FacebookUserRelationCountAggregateInputType | true
    }

  export interface FacebookUserRelationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one FacebookUserRelation that matches the filter.
     * @param {FacebookUserRelationFindUniqueArgs} args - Arguments to find a FacebookUserRelation
     * @example
     * // Get one FacebookUserRelation
     * const facebookUserRelation = await prisma.facebookUserRelation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FacebookUserRelationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FacebookUserRelationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FacebookUserRelation'> extends True ? Prisma__FacebookUserRelationClient<FacebookUserRelationGetPayload<T>> : Prisma__FacebookUserRelationClient<FacebookUserRelationGetPayload<T> | null, null>

    /**
     * Find one FacebookUserRelation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FacebookUserRelationFindUniqueOrThrowArgs} args - Arguments to find a FacebookUserRelation
     * @example
     * // Get one FacebookUserRelation
     * const facebookUserRelation = await prisma.facebookUserRelation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FacebookUserRelationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FacebookUserRelationFindUniqueOrThrowArgs>
    ): Prisma__FacebookUserRelationClient<FacebookUserRelationGetPayload<T>>

    /**
     * Find the first FacebookUserRelation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserRelationFindFirstArgs} args - Arguments to find a FacebookUserRelation
     * @example
     * // Get one FacebookUserRelation
     * const facebookUserRelation = await prisma.facebookUserRelation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FacebookUserRelationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FacebookUserRelationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FacebookUserRelation'> extends True ? Prisma__FacebookUserRelationClient<FacebookUserRelationGetPayload<T>> : Prisma__FacebookUserRelationClient<FacebookUserRelationGetPayload<T> | null, null>

    /**
     * Find the first FacebookUserRelation that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserRelationFindFirstOrThrowArgs} args - Arguments to find a FacebookUserRelation
     * @example
     * // Get one FacebookUserRelation
     * const facebookUserRelation = await prisma.facebookUserRelation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FacebookUserRelationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FacebookUserRelationFindFirstOrThrowArgs>
    ): Prisma__FacebookUserRelationClient<FacebookUserRelationGetPayload<T>>

    /**
     * Find zero or more FacebookUserRelations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserRelationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FacebookUserRelations
     * const facebookUserRelations = await prisma.facebookUserRelation.findMany()
     * 
     * // Get first 10 FacebookUserRelations
     * const facebookUserRelations = await prisma.facebookUserRelation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facebookUserRelationWithIdOnly = await prisma.facebookUserRelation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FacebookUserRelationFindManyArgs>(
      args?: SelectSubset<T, FacebookUserRelationFindManyArgs>
    ): Prisma.PrismaPromise<Array<FacebookUserRelationGetPayload<T>>>

    /**
     * Create a FacebookUserRelation.
     * @param {FacebookUserRelationCreateArgs} args - Arguments to create a FacebookUserRelation.
     * @example
     * // Create one FacebookUserRelation
     * const FacebookUserRelation = await prisma.facebookUserRelation.create({
     *   data: {
     *     // ... data to create a FacebookUserRelation
     *   }
     * })
     * 
    **/
    create<T extends FacebookUserRelationCreateArgs>(
      args: SelectSubset<T, FacebookUserRelationCreateArgs>
    ): Prisma__FacebookUserRelationClient<FacebookUserRelationGetPayload<T>>

    /**
     * Create many FacebookUserRelations.
     *     @param {FacebookUserRelationCreateManyArgs} args - Arguments to create many FacebookUserRelations.
     *     @example
     *     // Create many FacebookUserRelations
     *     const facebookUserRelation = await prisma.facebookUserRelation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FacebookUserRelationCreateManyArgs>(
      args?: SelectSubset<T, FacebookUserRelationCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FacebookUserRelation.
     * @param {FacebookUserRelationDeleteArgs} args - Arguments to delete one FacebookUserRelation.
     * @example
     * // Delete one FacebookUserRelation
     * const FacebookUserRelation = await prisma.facebookUserRelation.delete({
     *   where: {
     *     // ... filter to delete one FacebookUserRelation
     *   }
     * })
     * 
    **/
    delete<T extends FacebookUserRelationDeleteArgs>(
      args: SelectSubset<T, FacebookUserRelationDeleteArgs>
    ): Prisma__FacebookUserRelationClient<FacebookUserRelationGetPayload<T>>

    /**
     * Update one FacebookUserRelation.
     * @param {FacebookUserRelationUpdateArgs} args - Arguments to update one FacebookUserRelation.
     * @example
     * // Update one FacebookUserRelation
     * const facebookUserRelation = await prisma.facebookUserRelation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FacebookUserRelationUpdateArgs>(
      args: SelectSubset<T, FacebookUserRelationUpdateArgs>
    ): Prisma__FacebookUserRelationClient<FacebookUserRelationGetPayload<T>>

    /**
     * Delete zero or more FacebookUserRelations.
     * @param {FacebookUserRelationDeleteManyArgs} args - Arguments to filter FacebookUserRelations to delete.
     * @example
     * // Delete a few FacebookUserRelations
     * const { count } = await prisma.facebookUserRelation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FacebookUserRelationDeleteManyArgs>(
      args?: SelectSubset<T, FacebookUserRelationDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacebookUserRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserRelationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FacebookUserRelations
     * const facebookUserRelation = await prisma.facebookUserRelation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FacebookUserRelationUpdateManyArgs>(
      args: SelectSubset<T, FacebookUserRelationUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FacebookUserRelation.
     * @param {FacebookUserRelationUpsertArgs} args - Arguments to update or create a FacebookUserRelation.
     * @example
     * // Update or create a FacebookUserRelation
     * const facebookUserRelation = await prisma.facebookUserRelation.upsert({
     *   create: {
     *     // ... data to create a FacebookUserRelation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FacebookUserRelation we want to update
     *   }
     * })
    **/
    upsert<T extends FacebookUserRelationUpsertArgs>(
      args: SelectSubset<T, FacebookUserRelationUpsertArgs>
    ): Prisma__FacebookUserRelationClient<FacebookUserRelationGetPayload<T>>

    /**
     * Count the number of FacebookUserRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserRelationCountArgs} args - Arguments to filter FacebookUserRelations to count.
     * @example
     * // Count the number of FacebookUserRelations
     * const count = await prisma.facebookUserRelation.count({
     *   where: {
     *     // ... the filter for the FacebookUserRelations we want to count
     *   }
     * })
    **/
    count<T extends FacebookUserRelationCountArgs>(
      args?: Subset<T, FacebookUserRelationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacebookUserRelationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FacebookUserRelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserRelationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacebookUserRelationAggregateArgs>(args: Subset<T, FacebookUserRelationAggregateArgs>): Prisma.PrismaPromise<GetFacebookUserRelationAggregateType<T>>

    /**
     * Group by FacebookUserRelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserRelationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacebookUserRelationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacebookUserRelationGroupByArgs['orderBy'] }
        : { orderBy?: FacebookUserRelationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacebookUserRelationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacebookUserRelationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FacebookUserRelation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FacebookUserRelationClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    followingUser<T extends FacebookUserArgs= {}>(args?: Subset<T, FacebookUserArgs>): Prisma__FacebookUserClient<FacebookUserGetPayload<T> | Null>;

    followedUser<T extends FacebookUserArgs= {}>(args?: Subset<T, FacebookUserArgs>): Prisma__FacebookUserClient<FacebookUserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FacebookUserRelation base type for findUnique actions
   */
  export type FacebookUserRelationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FacebookUserRelation
     */
    select?: FacebookUserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserRelationInclude | null
    /**
     * Filter, which FacebookUserRelation to fetch.
     */
    where: FacebookUserRelationWhereUniqueInput
  }

  /**
   * FacebookUserRelation findUnique
   */
  export interface FacebookUserRelationFindUniqueArgs extends FacebookUserRelationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FacebookUserRelation findUniqueOrThrow
   */
  export type FacebookUserRelationFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FacebookUserRelation
     */
    select?: FacebookUserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserRelationInclude | null
    /**
     * Filter, which FacebookUserRelation to fetch.
     */
    where: FacebookUserRelationWhereUniqueInput
  }


  /**
   * FacebookUserRelation base type for findFirst actions
   */
  export type FacebookUserRelationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FacebookUserRelation
     */
    select?: FacebookUserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserRelationInclude | null
    /**
     * Filter, which FacebookUserRelation to fetch.
     */
    where?: FacebookUserRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookUserRelations to fetch.
     */
    orderBy?: Enumerable<FacebookUserRelationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacebookUserRelations.
     */
    cursor?: FacebookUserRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookUserRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookUserRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacebookUserRelations.
     */
    distinct?: Enumerable<FacebookUserRelationScalarFieldEnum>
  }

  /**
   * FacebookUserRelation findFirst
   */
  export interface FacebookUserRelationFindFirstArgs extends FacebookUserRelationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FacebookUserRelation findFirstOrThrow
   */
  export type FacebookUserRelationFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FacebookUserRelation
     */
    select?: FacebookUserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserRelationInclude | null
    /**
     * Filter, which FacebookUserRelation to fetch.
     */
    where?: FacebookUserRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookUserRelations to fetch.
     */
    orderBy?: Enumerable<FacebookUserRelationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacebookUserRelations.
     */
    cursor?: FacebookUserRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookUserRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookUserRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacebookUserRelations.
     */
    distinct?: Enumerable<FacebookUserRelationScalarFieldEnum>
  }


  /**
   * FacebookUserRelation findMany
   */
  export type FacebookUserRelationFindManyArgs = {
    /**
     * Select specific fields to fetch from the FacebookUserRelation
     */
    select?: FacebookUserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserRelationInclude | null
    /**
     * Filter, which FacebookUserRelations to fetch.
     */
    where?: FacebookUserRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookUserRelations to fetch.
     */
    orderBy?: Enumerable<FacebookUserRelationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FacebookUserRelations.
     */
    cursor?: FacebookUserRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookUserRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookUserRelations.
     */
    skip?: number
    distinct?: Enumerable<FacebookUserRelationScalarFieldEnum>
  }


  /**
   * FacebookUserRelation create
   */
  export type FacebookUserRelationCreateArgs = {
    /**
     * Select specific fields to fetch from the FacebookUserRelation
     */
    select?: FacebookUserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserRelationInclude | null
    /**
     * The data needed to create a FacebookUserRelation.
     */
    data: XOR<FacebookUserRelationCreateInput, FacebookUserRelationUncheckedCreateInput>
  }


  /**
   * FacebookUserRelation createMany
   */
  export type FacebookUserRelationCreateManyArgs = {
    /**
     * The data used to create many FacebookUserRelations.
     */
    data: Enumerable<FacebookUserRelationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FacebookUserRelation update
   */
  export type FacebookUserRelationUpdateArgs = {
    /**
     * Select specific fields to fetch from the FacebookUserRelation
     */
    select?: FacebookUserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserRelationInclude | null
    /**
     * The data needed to update a FacebookUserRelation.
     */
    data: XOR<FacebookUserRelationUpdateInput, FacebookUserRelationUncheckedUpdateInput>
    /**
     * Choose, which FacebookUserRelation to update.
     */
    where: FacebookUserRelationWhereUniqueInput
  }


  /**
   * FacebookUserRelation updateMany
   */
  export type FacebookUserRelationUpdateManyArgs = {
    /**
     * The data used to update FacebookUserRelations.
     */
    data: XOR<FacebookUserRelationUpdateManyMutationInput, FacebookUserRelationUncheckedUpdateManyInput>
    /**
     * Filter which FacebookUserRelations to update
     */
    where?: FacebookUserRelationWhereInput
  }


  /**
   * FacebookUserRelation upsert
   */
  export type FacebookUserRelationUpsertArgs = {
    /**
     * Select specific fields to fetch from the FacebookUserRelation
     */
    select?: FacebookUserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserRelationInclude | null
    /**
     * The filter to search for the FacebookUserRelation to update in case it exists.
     */
    where: FacebookUserRelationWhereUniqueInput
    /**
     * In case the FacebookUserRelation found by the `where` argument doesn't exist, create a new FacebookUserRelation with this data.
     */
    create: XOR<FacebookUserRelationCreateInput, FacebookUserRelationUncheckedCreateInput>
    /**
     * In case the FacebookUserRelation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacebookUserRelationUpdateInput, FacebookUserRelationUncheckedUpdateInput>
  }


  /**
   * FacebookUserRelation delete
   */
  export type FacebookUserRelationDeleteArgs = {
    /**
     * Select specific fields to fetch from the FacebookUserRelation
     */
    select?: FacebookUserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserRelationInclude | null
    /**
     * Filter which FacebookUserRelation to delete.
     */
    where: FacebookUserRelationWhereUniqueInput
  }


  /**
   * FacebookUserRelation deleteMany
   */
  export type FacebookUserRelationDeleteManyArgs = {
    /**
     * Filter which FacebookUserRelations to delete
     */
    where?: FacebookUserRelationWhereInput
  }


  /**
   * FacebookUserRelation without action
   */
  export type FacebookUserRelationArgs = {
    /**
     * Select specific fields to fetch from the FacebookUserRelation
     */
    select?: FacebookUserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserRelationInclude | null
  }



  /**
   * Model Post
   */


  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type PostSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type PostMinAggregateOutputType = {
    id: number | null
    postText: string | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostMaxAggregateOutputType = {
    id: number | null
    postText: string | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    postText: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PostAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type PostSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type PostMinAggregateInputType = {
    id?: true
    postText?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    postText?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    postText?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PostAggregateArgs = {
    /**
     * Filter which Post to aggregate.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: Enumerable<PostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs = {
    where?: PostWhereInput
    orderBy?: Enumerable<PostOrderByWithAggregationInput>
    by: PostScalarFieldEnum[]
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _avg?: PostAvgAggregateInputType
    _sum?: PostSumAggregateInputType
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }


  export type PostGroupByOutputType = {
    id: number
    postText: string
    userId: number
    createdAt: Date
    updatedAt: Date
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect = {
    id?: boolean
    postText?: boolean
    postingUser?: boolean | FacebookUserArgs
    userId?: boolean
    comments?: boolean | Post$commentsArgs
    hashTags?: boolean | Post$hashTagsArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | PostCountOutputTypeArgs
  }


  export type PostInclude = {
    postingUser?: boolean | FacebookUserArgs
    comments?: boolean | Post$commentsArgs
    hashTags?: boolean | Post$hashTagsArgs
    _count?: boolean | PostCountOutputTypeArgs
  }

  export type PostGetPayload<S extends boolean | null | undefined | PostArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Post :
    S extends undefined ? never :
    S extends { include: any } & (PostArgs | PostFindManyArgs)
    ? Post  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'postingUser' ? FacebookUserGetPayload<S['include'][P]> :
        P extends 'comments' ? Array < CommentGetPayload<S['include'][P]>>  :
        P extends 'hashTags' ? Array < FacebookHashTagGetPayload<S['include'][P]>>  :
        P extends '_count' ? PostCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PostArgs | PostFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'postingUser' ? FacebookUserGetPayload<S['select'][P]> :
        P extends 'comments' ? Array < CommentGetPayload<S['select'][P]>>  :
        P extends 'hashTags' ? Array < FacebookHashTagGetPayload<S['select'][P]>>  :
        P extends '_count' ? PostCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Post ? Post[P] : never
  } 
      : Post


  type PostCountArgs = 
    Omit<PostFindManyArgs, 'select' | 'include'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface PostDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PostFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PostFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Post'> extends True ? Prisma__PostClient<PostGetPayload<T>> : Prisma__PostClient<PostGetPayload<T> | null, null>

    /**
     * Find one Post that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PostFindUniqueOrThrowArgs>
    ): Prisma__PostClient<PostGetPayload<T>>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PostFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PostFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Post'> extends True ? Prisma__PostClient<PostGetPayload<T>> : Prisma__PostClient<PostGetPayload<T> | null, null>

    /**
     * Find the first Post that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PostFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PostFindFirstOrThrowArgs>
    ): Prisma__PostClient<PostGetPayload<T>>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PostFindManyArgs>(
      args?: SelectSubset<T, PostFindManyArgs>
    ): Prisma.PrismaPromise<Array<PostGetPayload<T>>>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
    **/
    create<T extends PostCreateArgs>(
      args: SelectSubset<T, PostCreateArgs>
    ): Prisma__PostClient<PostGetPayload<T>>

    /**
     * Create many Posts.
     *     @param {PostCreateManyArgs} args - Arguments to create many Posts.
     *     @example
     *     // Create many Posts
     *     const post = await prisma.post.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PostCreateManyArgs>(
      args?: SelectSubset<T, PostCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
    **/
    delete<T extends PostDeleteArgs>(
      args: SelectSubset<T, PostDeleteArgs>
    ): Prisma__PostClient<PostGetPayload<T>>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PostUpdateArgs>(
      args: SelectSubset<T, PostUpdateArgs>
    ): Prisma__PostClient<PostGetPayload<T>>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PostDeleteManyArgs>(
      args?: SelectSubset<T, PostDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PostUpdateManyArgs>(
      args: SelectSubset<T, PostUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
    **/
    upsert<T extends PostUpsertArgs>(
      args: SelectSubset<T, PostUpsertArgs>
    ): Prisma__PostClient<PostGetPayload<T>>

    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PostClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    postingUser<T extends FacebookUserArgs= {}>(args?: Subset<T, FacebookUserArgs>): Prisma__FacebookUserClient<FacebookUserGetPayload<T> | Null>;

    comments<T extends Post$commentsArgs= {}>(args?: Subset<T, Post$commentsArgs>): Prisma.PrismaPromise<Array<CommentGetPayload<T>>| Null>;

    hashTags<T extends Post$hashTagsArgs= {}>(args?: Subset<T, Post$hashTagsArgs>): Prisma.PrismaPromise<Array<FacebookHashTagGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Post base type for findUnique actions
   */
  export type PostFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findUnique
   */
  export interface PostFindUniqueArgs extends PostFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Post findUniqueOrThrow
   */
  export type PostFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }


  /**
   * Post base type for findFirst actions
   */
  export type PostFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: Enumerable<PostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: Enumerable<PostScalarFieldEnum>
  }

  /**
   * Post findFirst
   */
  export interface PostFindFirstArgs extends PostFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Post findFirstOrThrow
   */
  export type PostFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: Enumerable<PostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: Enumerable<PostScalarFieldEnum>
  }


  /**
   * Post findMany
   */
  export type PostFindManyArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: Enumerable<PostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: Enumerable<PostScalarFieldEnum>
  }


  /**
   * Post create
   */
  export type PostCreateArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    /**
     * The data needed to create a Post.
     */
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
  }


  /**
   * Post createMany
   */
  export type PostCreateManyArgs = {
    /**
     * The data used to create many Posts.
     */
    data: Enumerable<PostCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Post update
   */
  export type PostUpdateArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    /**
     * The data needed to update a Post.
     */
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     */
    where: PostWhereUniqueInput
  }


  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
  }


  /**
   * Post upsert
   */
  export type PostUpsertArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    /**
     * The filter to search for the Post to update in case it exists.
     */
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
     */
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }


  /**
   * Post delete
   */
  export type PostDeleteArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    /**
     * Filter which Post to delete.
     */
    where: PostWhereUniqueInput
  }


  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs = {
    /**
     * Filter which Posts to delete
     */
    where?: PostWhereInput
  }


  /**
   * Post.comments
   */
  export type Post$commentsArgs = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
    where?: CommentWhereInput
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CommentScalarFieldEnum>
  }


  /**
   * Post.hashTags
   */
  export type Post$hashTagsArgs = {
    /**
     * Select specific fields to fetch from the FacebookHashTag
     */
    select?: FacebookHashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookHashTagInclude | null
    where?: FacebookHashTagWhereInput
    orderBy?: Enumerable<FacebookHashTagOrderByWithRelationInput>
    cursor?: FacebookHashTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FacebookHashTagScalarFieldEnum>
  }


  /**
   * Post without action
   */
  export type PostArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
  }



  /**
   * Model Comment
   */


  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    postId: number | null
    parentCommentId: number | null
  }

  export type CommentSumAggregateOutputType = {
    id: number | null
    userId: number | null
    postId: number | null
    parentCommentId: number | null
  }

  export type CommentMinAggregateOutputType = {
    id: number | null
    commentText: string | null
    userId: number | null
    postId: number | null
    parentCommentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: number | null
    commentText: string | null
    userId: number | null
    postId: number | null
    parentCommentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    commentText: number
    userId: number
    postId: number
    parentCommentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommentAvgAggregateInputType = {
    id?: true
    userId?: true
    postId?: true
    parentCommentId?: true
  }

  export type CommentSumAggregateInputType = {
    id?: true
    userId?: true
    postId?: true
    parentCommentId?: true
  }

  export type CommentMinAggregateInputType = {
    id?: true
    commentText?: true
    userId?: true
    postId?: true
    parentCommentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    commentText?: true
    userId?: true
    postId?: true
    parentCommentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    commentText?: true
    userId?: true
    postId?: true
    parentCommentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommentAggregateArgs = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs = {
    where?: CommentWhereInput
    orderBy?: Enumerable<CommentOrderByWithAggregationInput>
    by: CommentScalarFieldEnum[]
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _avg?: CommentAvgAggregateInputType
    _sum?: CommentSumAggregateInputType
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }


  export type CommentGroupByOutputType = {
    id: number
    commentText: string
    userId: number
    postId: number
    parentCommentId: number | null
    createdAt: Date
    updatedAt: Date
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect = {
    id?: boolean
    commentText?: boolean
    commentingUser?: boolean | FacebookUserArgs
    userId?: boolean
    parentPost?: boolean | PostArgs
    postId?: boolean
    parentComment?: boolean | CommentArgs
    parentCommentId?: boolean
    childComments?: boolean | Comment$childCommentsArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | CommentCountOutputTypeArgs
  }


  export type CommentInclude = {
    commentingUser?: boolean | FacebookUserArgs
    parentPost?: boolean | PostArgs
    parentComment?: boolean | CommentArgs
    childComments?: boolean | Comment$childCommentsArgs
    _count?: boolean | CommentCountOutputTypeArgs
  }

  export type CommentGetPayload<S extends boolean | null | undefined | CommentArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Comment :
    S extends undefined ? never :
    S extends { include: any } & (CommentArgs | CommentFindManyArgs)
    ? Comment  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'commentingUser' ? FacebookUserGetPayload<S['include'][P]> :
        P extends 'parentPost' ? PostGetPayload<S['include'][P]> :
        P extends 'parentComment' ? CommentGetPayload<S['include'][P]> | null :
        P extends 'childComments' ? Array < CommentGetPayload<S['include'][P]>>  :
        P extends '_count' ? CommentCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CommentArgs | CommentFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'commentingUser' ? FacebookUserGetPayload<S['select'][P]> :
        P extends 'parentPost' ? PostGetPayload<S['select'][P]> :
        P extends 'parentComment' ? CommentGetPayload<S['select'][P]> | null :
        P extends 'childComments' ? Array < CommentGetPayload<S['select'][P]>>  :
        P extends '_count' ? CommentCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Comment ? Comment[P] : never
  } 
      : Comment


  type CommentCountArgs = 
    Omit<CommentFindManyArgs, 'select' | 'include'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CommentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Comment'> extends True ? Prisma__CommentClient<CommentGetPayload<T>> : Prisma__CommentClient<CommentGetPayload<T> | null, null>

    /**
     * Find one Comment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CommentFindUniqueOrThrowArgs>
    ): Prisma__CommentClient<CommentGetPayload<T>>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CommentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Comment'> extends True ? Prisma__CommentClient<CommentGetPayload<T>> : Prisma__CommentClient<CommentGetPayload<T> | null, null>

    /**
     * Find the first Comment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CommentFindFirstOrThrowArgs>
    ): Prisma__CommentClient<CommentGetPayload<T>>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommentFindManyArgs>(
      args?: SelectSubset<T, CommentFindManyArgs>
    ): Prisma.PrismaPromise<Array<CommentGetPayload<T>>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
    **/
    create<T extends CommentCreateArgs>(
      args: SelectSubset<T, CommentCreateArgs>
    ): Prisma__CommentClient<CommentGetPayload<T>>

    /**
     * Create many Comments.
     *     @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     *     @example
     *     // Create many Comments
     *     const comment = await prisma.comment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommentCreateManyArgs>(
      args?: SelectSubset<T, CommentCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
    **/
    delete<T extends CommentDeleteArgs>(
      args: SelectSubset<T, CommentDeleteArgs>
    ): Prisma__CommentClient<CommentGetPayload<T>>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommentUpdateArgs>(
      args: SelectSubset<T, CommentUpdateArgs>
    ): Prisma__CommentClient<CommentGetPayload<T>>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommentDeleteManyArgs>(
      args?: SelectSubset<T, CommentDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommentUpdateManyArgs>(
      args: SelectSubset<T, CommentUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
    **/
    upsert<T extends CommentUpsertArgs>(
      args: SelectSubset<T, CommentUpsertArgs>
    ): Prisma__CommentClient<CommentGetPayload<T>>

    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CommentClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    commentingUser<T extends FacebookUserArgs= {}>(args?: Subset<T, FacebookUserArgs>): Prisma__FacebookUserClient<FacebookUserGetPayload<T> | Null>;

    parentPost<T extends PostArgs= {}>(args?: Subset<T, PostArgs>): Prisma__PostClient<PostGetPayload<T> | Null>;

    parentComment<T extends CommentArgs= {}>(args?: Subset<T, CommentArgs>): Prisma__CommentClient<CommentGetPayload<T> | Null>;

    childComments<T extends Comment$childCommentsArgs= {}>(args?: Subset<T, Comment$childCommentsArgs>): Prisma.PrismaPromise<Array<CommentGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Comment base type for findUnique actions
   */
  export type CommentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUnique
   */
  export interface CommentFindUniqueArgs extends CommentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment base type for findFirst actions
   */
  export type CommentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: Enumerable<CommentScalarFieldEnum>
  }

  /**
   * Comment findFirst
   */
  export interface CommentFindFirstArgs extends CommentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: Enumerable<CommentScalarFieldEnum>
  }


  /**
   * Comment findMany
   */
  export type CommentFindManyArgs = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: Enumerable<CommentScalarFieldEnum>
  }


  /**
   * Comment create
   */
  export type CommentCreateArgs = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }


  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs = {
    /**
     * The data used to create many Comments.
     */
    data: Enumerable<CommentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Comment update
   */
  export type CommentUpdateArgs = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
  }


  /**
   * Comment upsert
   */
  export type CommentUpsertArgs = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }


  /**
   * Comment delete
   */
  export type CommentDeleteArgs = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
  }


  /**
   * Comment.childComments
   */
  export type Comment$childCommentsArgs = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
    where?: CommentWhereInput
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CommentScalarFieldEnum>
  }


  /**
   * Comment without action
   */
  export type CommentArgs = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
  }



  /**
   * Model FacebookHashTag
   */


  export type AggregateFacebookHashTag = {
    _count: FacebookHashTagCountAggregateOutputType | null
    _avg: FacebookHashTagAvgAggregateOutputType | null
    _sum: FacebookHashTagSumAggregateOutputType | null
    _min: FacebookHashTagMinAggregateOutputType | null
    _max: FacebookHashTagMaxAggregateOutputType | null
  }

  export type FacebookHashTagAvgAggregateOutputType = {
    id: number | null
  }

  export type FacebookHashTagSumAggregateOutputType = {
    id: number | null
  }

  export type FacebookHashTagMinAggregateOutputType = {
    id: number | null
    hashTagText: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacebookHashTagMaxAggregateOutputType = {
    id: number | null
    hashTagText: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacebookHashTagCountAggregateOutputType = {
    id: number
    hashTagText: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FacebookHashTagAvgAggregateInputType = {
    id?: true
  }

  export type FacebookHashTagSumAggregateInputType = {
    id?: true
  }

  export type FacebookHashTagMinAggregateInputType = {
    id?: true
    hashTagText?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacebookHashTagMaxAggregateInputType = {
    id?: true
    hashTagText?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacebookHashTagCountAggregateInputType = {
    id?: true
    hashTagText?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FacebookHashTagAggregateArgs = {
    /**
     * Filter which FacebookHashTag to aggregate.
     */
    where?: FacebookHashTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookHashTags to fetch.
     */
    orderBy?: Enumerable<FacebookHashTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacebookHashTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookHashTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookHashTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FacebookHashTags
    **/
    _count?: true | FacebookHashTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FacebookHashTagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FacebookHashTagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacebookHashTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacebookHashTagMaxAggregateInputType
  }

  export type GetFacebookHashTagAggregateType<T extends FacebookHashTagAggregateArgs> = {
        [P in keyof T & keyof AggregateFacebookHashTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacebookHashTag[P]>
      : GetScalarType<T[P], AggregateFacebookHashTag[P]>
  }




  export type FacebookHashTagGroupByArgs = {
    where?: FacebookHashTagWhereInput
    orderBy?: Enumerable<FacebookHashTagOrderByWithAggregationInput>
    by: FacebookHashTagScalarFieldEnum[]
    having?: FacebookHashTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacebookHashTagCountAggregateInputType | true
    _avg?: FacebookHashTagAvgAggregateInputType
    _sum?: FacebookHashTagSumAggregateInputType
    _min?: FacebookHashTagMinAggregateInputType
    _max?: FacebookHashTagMaxAggregateInputType
  }


  export type FacebookHashTagGroupByOutputType = {
    id: number
    hashTagText: string
    createdAt: Date
    updatedAt: Date
    _count: FacebookHashTagCountAggregateOutputType | null
    _avg: FacebookHashTagAvgAggregateOutputType | null
    _sum: FacebookHashTagSumAggregateOutputType | null
    _min: FacebookHashTagMinAggregateOutputType | null
    _max: FacebookHashTagMaxAggregateOutputType | null
  }

  type GetFacebookHashTagGroupByPayload<T extends FacebookHashTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FacebookHashTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacebookHashTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacebookHashTagGroupByOutputType[P]>
            : GetScalarType<T[P], FacebookHashTagGroupByOutputType[P]>
        }
      >
    >


  export type FacebookHashTagSelect = {
    id?: boolean
    hashTagText?: boolean
    isInPosts?: boolean | FacebookHashTag$isInPostsArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | FacebookHashTagCountOutputTypeArgs
  }


  export type FacebookHashTagInclude = {
    isInPosts?: boolean | FacebookHashTag$isInPostsArgs
    _count?: boolean | FacebookHashTagCountOutputTypeArgs
  }

  export type FacebookHashTagGetPayload<S extends boolean | null | undefined | FacebookHashTagArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FacebookHashTag :
    S extends undefined ? never :
    S extends { include: any } & (FacebookHashTagArgs | FacebookHashTagFindManyArgs)
    ? FacebookHashTag  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'isInPosts' ? Array < PostGetPayload<S['include'][P]>>  :
        P extends '_count' ? FacebookHashTagCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FacebookHashTagArgs | FacebookHashTagFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'isInPosts' ? Array < PostGetPayload<S['select'][P]>>  :
        P extends '_count' ? FacebookHashTagCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof FacebookHashTag ? FacebookHashTag[P] : never
  } 
      : FacebookHashTag


  type FacebookHashTagCountArgs = 
    Omit<FacebookHashTagFindManyArgs, 'select' | 'include'> & {
      select?: FacebookHashTagCountAggregateInputType | true
    }

  export interface FacebookHashTagDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one FacebookHashTag that matches the filter.
     * @param {FacebookHashTagFindUniqueArgs} args - Arguments to find a FacebookHashTag
     * @example
     * // Get one FacebookHashTag
     * const facebookHashTag = await prisma.facebookHashTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FacebookHashTagFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FacebookHashTagFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FacebookHashTag'> extends True ? Prisma__FacebookHashTagClient<FacebookHashTagGetPayload<T>> : Prisma__FacebookHashTagClient<FacebookHashTagGetPayload<T> | null, null>

    /**
     * Find one FacebookHashTag that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FacebookHashTagFindUniqueOrThrowArgs} args - Arguments to find a FacebookHashTag
     * @example
     * // Get one FacebookHashTag
     * const facebookHashTag = await prisma.facebookHashTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FacebookHashTagFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FacebookHashTagFindUniqueOrThrowArgs>
    ): Prisma__FacebookHashTagClient<FacebookHashTagGetPayload<T>>

    /**
     * Find the first FacebookHashTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookHashTagFindFirstArgs} args - Arguments to find a FacebookHashTag
     * @example
     * // Get one FacebookHashTag
     * const facebookHashTag = await prisma.facebookHashTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FacebookHashTagFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FacebookHashTagFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FacebookHashTag'> extends True ? Prisma__FacebookHashTagClient<FacebookHashTagGetPayload<T>> : Prisma__FacebookHashTagClient<FacebookHashTagGetPayload<T> | null, null>

    /**
     * Find the first FacebookHashTag that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookHashTagFindFirstOrThrowArgs} args - Arguments to find a FacebookHashTag
     * @example
     * // Get one FacebookHashTag
     * const facebookHashTag = await prisma.facebookHashTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FacebookHashTagFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FacebookHashTagFindFirstOrThrowArgs>
    ): Prisma__FacebookHashTagClient<FacebookHashTagGetPayload<T>>

    /**
     * Find zero or more FacebookHashTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookHashTagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FacebookHashTags
     * const facebookHashTags = await prisma.facebookHashTag.findMany()
     * 
     * // Get first 10 FacebookHashTags
     * const facebookHashTags = await prisma.facebookHashTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facebookHashTagWithIdOnly = await prisma.facebookHashTag.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FacebookHashTagFindManyArgs>(
      args?: SelectSubset<T, FacebookHashTagFindManyArgs>
    ): Prisma.PrismaPromise<Array<FacebookHashTagGetPayload<T>>>

    /**
     * Create a FacebookHashTag.
     * @param {FacebookHashTagCreateArgs} args - Arguments to create a FacebookHashTag.
     * @example
     * // Create one FacebookHashTag
     * const FacebookHashTag = await prisma.facebookHashTag.create({
     *   data: {
     *     // ... data to create a FacebookHashTag
     *   }
     * })
     * 
    **/
    create<T extends FacebookHashTagCreateArgs>(
      args: SelectSubset<T, FacebookHashTagCreateArgs>
    ): Prisma__FacebookHashTagClient<FacebookHashTagGetPayload<T>>

    /**
     * Create many FacebookHashTags.
     *     @param {FacebookHashTagCreateManyArgs} args - Arguments to create many FacebookHashTags.
     *     @example
     *     // Create many FacebookHashTags
     *     const facebookHashTag = await prisma.facebookHashTag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FacebookHashTagCreateManyArgs>(
      args?: SelectSubset<T, FacebookHashTagCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FacebookHashTag.
     * @param {FacebookHashTagDeleteArgs} args - Arguments to delete one FacebookHashTag.
     * @example
     * // Delete one FacebookHashTag
     * const FacebookHashTag = await prisma.facebookHashTag.delete({
     *   where: {
     *     // ... filter to delete one FacebookHashTag
     *   }
     * })
     * 
    **/
    delete<T extends FacebookHashTagDeleteArgs>(
      args: SelectSubset<T, FacebookHashTagDeleteArgs>
    ): Prisma__FacebookHashTagClient<FacebookHashTagGetPayload<T>>

    /**
     * Update one FacebookHashTag.
     * @param {FacebookHashTagUpdateArgs} args - Arguments to update one FacebookHashTag.
     * @example
     * // Update one FacebookHashTag
     * const facebookHashTag = await prisma.facebookHashTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FacebookHashTagUpdateArgs>(
      args: SelectSubset<T, FacebookHashTagUpdateArgs>
    ): Prisma__FacebookHashTagClient<FacebookHashTagGetPayload<T>>

    /**
     * Delete zero or more FacebookHashTags.
     * @param {FacebookHashTagDeleteManyArgs} args - Arguments to filter FacebookHashTags to delete.
     * @example
     * // Delete a few FacebookHashTags
     * const { count } = await prisma.facebookHashTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FacebookHashTagDeleteManyArgs>(
      args?: SelectSubset<T, FacebookHashTagDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacebookHashTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookHashTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FacebookHashTags
     * const facebookHashTag = await prisma.facebookHashTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FacebookHashTagUpdateManyArgs>(
      args: SelectSubset<T, FacebookHashTagUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FacebookHashTag.
     * @param {FacebookHashTagUpsertArgs} args - Arguments to update or create a FacebookHashTag.
     * @example
     * // Update or create a FacebookHashTag
     * const facebookHashTag = await prisma.facebookHashTag.upsert({
     *   create: {
     *     // ... data to create a FacebookHashTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FacebookHashTag we want to update
     *   }
     * })
    **/
    upsert<T extends FacebookHashTagUpsertArgs>(
      args: SelectSubset<T, FacebookHashTagUpsertArgs>
    ): Prisma__FacebookHashTagClient<FacebookHashTagGetPayload<T>>

    /**
     * Count the number of FacebookHashTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookHashTagCountArgs} args - Arguments to filter FacebookHashTags to count.
     * @example
     * // Count the number of FacebookHashTags
     * const count = await prisma.facebookHashTag.count({
     *   where: {
     *     // ... the filter for the FacebookHashTags we want to count
     *   }
     * })
    **/
    count<T extends FacebookHashTagCountArgs>(
      args?: Subset<T, FacebookHashTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacebookHashTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FacebookHashTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookHashTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacebookHashTagAggregateArgs>(args: Subset<T, FacebookHashTagAggregateArgs>): Prisma.PrismaPromise<GetFacebookHashTagAggregateType<T>>

    /**
     * Group by FacebookHashTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookHashTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacebookHashTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacebookHashTagGroupByArgs['orderBy'] }
        : { orderBy?: FacebookHashTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacebookHashTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacebookHashTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FacebookHashTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FacebookHashTagClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    isInPosts<T extends FacebookHashTag$isInPostsArgs= {}>(args?: Subset<T, FacebookHashTag$isInPostsArgs>): Prisma.PrismaPromise<Array<PostGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FacebookHashTag base type for findUnique actions
   */
  export type FacebookHashTagFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FacebookHashTag
     */
    select?: FacebookHashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookHashTagInclude | null
    /**
     * Filter, which FacebookHashTag to fetch.
     */
    where: FacebookHashTagWhereUniqueInput
  }

  /**
   * FacebookHashTag findUnique
   */
  export interface FacebookHashTagFindUniqueArgs extends FacebookHashTagFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FacebookHashTag findUniqueOrThrow
   */
  export type FacebookHashTagFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FacebookHashTag
     */
    select?: FacebookHashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookHashTagInclude | null
    /**
     * Filter, which FacebookHashTag to fetch.
     */
    where: FacebookHashTagWhereUniqueInput
  }


  /**
   * FacebookHashTag base type for findFirst actions
   */
  export type FacebookHashTagFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FacebookHashTag
     */
    select?: FacebookHashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookHashTagInclude | null
    /**
     * Filter, which FacebookHashTag to fetch.
     */
    where?: FacebookHashTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookHashTags to fetch.
     */
    orderBy?: Enumerable<FacebookHashTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacebookHashTags.
     */
    cursor?: FacebookHashTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookHashTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookHashTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacebookHashTags.
     */
    distinct?: Enumerable<FacebookHashTagScalarFieldEnum>
  }

  /**
   * FacebookHashTag findFirst
   */
  export interface FacebookHashTagFindFirstArgs extends FacebookHashTagFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FacebookHashTag findFirstOrThrow
   */
  export type FacebookHashTagFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FacebookHashTag
     */
    select?: FacebookHashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookHashTagInclude | null
    /**
     * Filter, which FacebookHashTag to fetch.
     */
    where?: FacebookHashTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookHashTags to fetch.
     */
    orderBy?: Enumerable<FacebookHashTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacebookHashTags.
     */
    cursor?: FacebookHashTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookHashTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookHashTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacebookHashTags.
     */
    distinct?: Enumerable<FacebookHashTagScalarFieldEnum>
  }


  /**
   * FacebookHashTag findMany
   */
  export type FacebookHashTagFindManyArgs = {
    /**
     * Select specific fields to fetch from the FacebookHashTag
     */
    select?: FacebookHashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookHashTagInclude | null
    /**
     * Filter, which FacebookHashTags to fetch.
     */
    where?: FacebookHashTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookHashTags to fetch.
     */
    orderBy?: Enumerable<FacebookHashTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FacebookHashTags.
     */
    cursor?: FacebookHashTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookHashTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookHashTags.
     */
    skip?: number
    distinct?: Enumerable<FacebookHashTagScalarFieldEnum>
  }


  /**
   * FacebookHashTag create
   */
  export type FacebookHashTagCreateArgs = {
    /**
     * Select specific fields to fetch from the FacebookHashTag
     */
    select?: FacebookHashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookHashTagInclude | null
    /**
     * The data needed to create a FacebookHashTag.
     */
    data: XOR<FacebookHashTagCreateInput, FacebookHashTagUncheckedCreateInput>
  }


  /**
   * FacebookHashTag createMany
   */
  export type FacebookHashTagCreateManyArgs = {
    /**
     * The data used to create many FacebookHashTags.
     */
    data: Enumerable<FacebookHashTagCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FacebookHashTag update
   */
  export type FacebookHashTagUpdateArgs = {
    /**
     * Select specific fields to fetch from the FacebookHashTag
     */
    select?: FacebookHashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookHashTagInclude | null
    /**
     * The data needed to update a FacebookHashTag.
     */
    data: XOR<FacebookHashTagUpdateInput, FacebookHashTagUncheckedUpdateInput>
    /**
     * Choose, which FacebookHashTag to update.
     */
    where: FacebookHashTagWhereUniqueInput
  }


  /**
   * FacebookHashTag updateMany
   */
  export type FacebookHashTagUpdateManyArgs = {
    /**
     * The data used to update FacebookHashTags.
     */
    data: XOR<FacebookHashTagUpdateManyMutationInput, FacebookHashTagUncheckedUpdateManyInput>
    /**
     * Filter which FacebookHashTags to update
     */
    where?: FacebookHashTagWhereInput
  }


  /**
   * FacebookHashTag upsert
   */
  export type FacebookHashTagUpsertArgs = {
    /**
     * Select specific fields to fetch from the FacebookHashTag
     */
    select?: FacebookHashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookHashTagInclude | null
    /**
     * The filter to search for the FacebookHashTag to update in case it exists.
     */
    where: FacebookHashTagWhereUniqueInput
    /**
     * In case the FacebookHashTag found by the `where` argument doesn't exist, create a new FacebookHashTag with this data.
     */
    create: XOR<FacebookHashTagCreateInput, FacebookHashTagUncheckedCreateInput>
    /**
     * In case the FacebookHashTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacebookHashTagUpdateInput, FacebookHashTagUncheckedUpdateInput>
  }


  /**
   * FacebookHashTag delete
   */
  export type FacebookHashTagDeleteArgs = {
    /**
     * Select specific fields to fetch from the FacebookHashTag
     */
    select?: FacebookHashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookHashTagInclude | null
    /**
     * Filter which FacebookHashTag to delete.
     */
    where: FacebookHashTagWhereUniqueInput
  }


  /**
   * FacebookHashTag deleteMany
   */
  export type FacebookHashTagDeleteManyArgs = {
    /**
     * Filter which FacebookHashTags to delete
     */
    where?: FacebookHashTagWhereInput
  }


  /**
   * FacebookHashTag.isInPosts
   */
  export type FacebookHashTag$isInPostsArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    where?: PostWhereInput
    orderBy?: Enumerable<PostOrderByWithRelationInput>
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PostScalarFieldEnum>
  }


  /**
   * FacebookHashTag without action
   */
  export type FacebookHashTagArgs = {
    /**
     * Select specific fields to fetch from the FacebookHashTag
     */
    select?: FacebookHashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookHashTagInclude | null
  }



  /**
   * Model MessengerMessage
   */


  export type AggregateMessengerMessage = {
    _count: MessengerMessageCountAggregateOutputType | null
    _avg: MessengerMessageAvgAggregateOutputType | null
    _sum: MessengerMessageSumAggregateOutputType | null
    _min: MessengerMessageMinAggregateOutputType | null
    _max: MessengerMessageMaxAggregateOutputType | null
  }

  export type MessengerMessageAvgAggregateOutputType = {
    id: number | null
    fromUserId: number | null
    toUserId: number | null
  }

  export type MessengerMessageSumAggregateOutputType = {
    id: number | null
    fromUserId: number | null
    toUserId: number | null
  }

  export type MessengerMessageMinAggregateOutputType = {
    id: number | null
    messengerText: string | null
    fromUserId: number | null
    toUserId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessengerMessageMaxAggregateOutputType = {
    id: number | null
    messengerText: string | null
    fromUserId: number | null
    toUserId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessengerMessageCountAggregateOutputType = {
    id: number
    messengerText: number
    fromUserId: number
    toUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MessengerMessageAvgAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
  }

  export type MessengerMessageSumAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
  }

  export type MessengerMessageMinAggregateInputType = {
    id?: true
    messengerText?: true
    fromUserId?: true
    toUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessengerMessageMaxAggregateInputType = {
    id?: true
    messengerText?: true
    fromUserId?: true
    toUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessengerMessageCountAggregateInputType = {
    id?: true
    messengerText?: true
    fromUserId?: true
    toUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MessengerMessageAggregateArgs = {
    /**
     * Filter which MessengerMessage to aggregate.
     */
    where?: MessengerMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessengerMessages to fetch.
     */
    orderBy?: Enumerable<MessengerMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessengerMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessengerMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessengerMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessengerMessages
    **/
    _count?: true | MessengerMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessengerMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessengerMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessengerMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessengerMessageMaxAggregateInputType
  }

  export type GetMessengerMessageAggregateType<T extends MessengerMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessengerMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessengerMessage[P]>
      : GetScalarType<T[P], AggregateMessengerMessage[P]>
  }




  export type MessengerMessageGroupByArgs = {
    where?: MessengerMessageWhereInput
    orderBy?: Enumerable<MessengerMessageOrderByWithAggregationInput>
    by: MessengerMessageScalarFieldEnum[]
    having?: MessengerMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessengerMessageCountAggregateInputType | true
    _avg?: MessengerMessageAvgAggregateInputType
    _sum?: MessengerMessageSumAggregateInputType
    _min?: MessengerMessageMinAggregateInputType
    _max?: MessengerMessageMaxAggregateInputType
  }


  export type MessengerMessageGroupByOutputType = {
    id: number
    messengerText: string
    fromUserId: number
    toUserId: number
    createdAt: Date
    updatedAt: Date
    _count: MessengerMessageCountAggregateOutputType | null
    _avg: MessengerMessageAvgAggregateOutputType | null
    _sum: MessengerMessageSumAggregateOutputType | null
    _min: MessengerMessageMinAggregateOutputType | null
    _max: MessengerMessageMaxAggregateOutputType | null
  }

  type GetMessengerMessageGroupByPayload<T extends MessengerMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MessengerMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessengerMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessengerMessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessengerMessageGroupByOutputType[P]>
        }
      >
    >


  export type MessengerMessageSelect = {
    id?: boolean
    messengerText?: boolean
    fromUser?: boolean | FacebookUserArgs
    toUser?: boolean | FacebookUserArgs
    fromUserId?: boolean
    toUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type MessengerMessageInclude = {
    fromUser?: boolean | FacebookUserArgs
    toUser?: boolean | FacebookUserArgs
  }

  export type MessengerMessageGetPayload<S extends boolean | null | undefined | MessengerMessageArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MessengerMessage :
    S extends undefined ? never :
    S extends { include: any } & (MessengerMessageArgs | MessengerMessageFindManyArgs)
    ? MessengerMessage  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'fromUser' ? FacebookUserGetPayload<S['include'][P]> :
        P extends 'toUser' ? FacebookUserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (MessengerMessageArgs | MessengerMessageFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'fromUser' ? FacebookUserGetPayload<S['select'][P]> :
        P extends 'toUser' ? FacebookUserGetPayload<S['select'][P]> :  P extends keyof MessengerMessage ? MessengerMessage[P] : never
  } 
      : MessengerMessage


  type MessengerMessageCountArgs = 
    Omit<MessengerMessageFindManyArgs, 'select' | 'include'> & {
      select?: MessengerMessageCountAggregateInputType | true
    }

  export interface MessengerMessageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one MessengerMessage that matches the filter.
     * @param {MessengerMessageFindUniqueArgs} args - Arguments to find a MessengerMessage
     * @example
     * // Get one MessengerMessage
     * const messengerMessage = await prisma.messengerMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MessengerMessageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MessengerMessageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MessengerMessage'> extends True ? Prisma__MessengerMessageClient<MessengerMessageGetPayload<T>> : Prisma__MessengerMessageClient<MessengerMessageGetPayload<T> | null, null>

    /**
     * Find one MessengerMessage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MessengerMessageFindUniqueOrThrowArgs} args - Arguments to find a MessengerMessage
     * @example
     * // Get one MessengerMessage
     * const messengerMessage = await prisma.messengerMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MessengerMessageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MessengerMessageFindUniqueOrThrowArgs>
    ): Prisma__MessengerMessageClient<MessengerMessageGetPayload<T>>

    /**
     * Find the first MessengerMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessengerMessageFindFirstArgs} args - Arguments to find a MessengerMessage
     * @example
     * // Get one MessengerMessage
     * const messengerMessage = await prisma.messengerMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MessengerMessageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MessengerMessageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MessengerMessage'> extends True ? Prisma__MessengerMessageClient<MessengerMessageGetPayload<T>> : Prisma__MessengerMessageClient<MessengerMessageGetPayload<T> | null, null>

    /**
     * Find the first MessengerMessage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessengerMessageFindFirstOrThrowArgs} args - Arguments to find a MessengerMessage
     * @example
     * // Get one MessengerMessage
     * const messengerMessage = await prisma.messengerMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MessengerMessageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MessengerMessageFindFirstOrThrowArgs>
    ): Prisma__MessengerMessageClient<MessengerMessageGetPayload<T>>

    /**
     * Find zero or more MessengerMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessengerMessageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessengerMessages
     * const messengerMessages = await prisma.messengerMessage.findMany()
     * 
     * // Get first 10 MessengerMessages
     * const messengerMessages = await prisma.messengerMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messengerMessageWithIdOnly = await prisma.messengerMessage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MessengerMessageFindManyArgs>(
      args?: SelectSubset<T, MessengerMessageFindManyArgs>
    ): Prisma.PrismaPromise<Array<MessengerMessageGetPayload<T>>>

    /**
     * Create a MessengerMessage.
     * @param {MessengerMessageCreateArgs} args - Arguments to create a MessengerMessage.
     * @example
     * // Create one MessengerMessage
     * const MessengerMessage = await prisma.messengerMessage.create({
     *   data: {
     *     // ... data to create a MessengerMessage
     *   }
     * })
     * 
    **/
    create<T extends MessengerMessageCreateArgs>(
      args: SelectSubset<T, MessengerMessageCreateArgs>
    ): Prisma__MessengerMessageClient<MessengerMessageGetPayload<T>>

    /**
     * Create many MessengerMessages.
     *     @param {MessengerMessageCreateManyArgs} args - Arguments to create many MessengerMessages.
     *     @example
     *     // Create many MessengerMessages
     *     const messengerMessage = await prisma.messengerMessage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MessengerMessageCreateManyArgs>(
      args?: SelectSubset<T, MessengerMessageCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MessengerMessage.
     * @param {MessengerMessageDeleteArgs} args - Arguments to delete one MessengerMessage.
     * @example
     * // Delete one MessengerMessage
     * const MessengerMessage = await prisma.messengerMessage.delete({
     *   where: {
     *     // ... filter to delete one MessengerMessage
     *   }
     * })
     * 
    **/
    delete<T extends MessengerMessageDeleteArgs>(
      args: SelectSubset<T, MessengerMessageDeleteArgs>
    ): Prisma__MessengerMessageClient<MessengerMessageGetPayload<T>>

    /**
     * Update one MessengerMessage.
     * @param {MessengerMessageUpdateArgs} args - Arguments to update one MessengerMessage.
     * @example
     * // Update one MessengerMessage
     * const messengerMessage = await prisma.messengerMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MessengerMessageUpdateArgs>(
      args: SelectSubset<T, MessengerMessageUpdateArgs>
    ): Prisma__MessengerMessageClient<MessengerMessageGetPayload<T>>

    /**
     * Delete zero or more MessengerMessages.
     * @param {MessengerMessageDeleteManyArgs} args - Arguments to filter MessengerMessages to delete.
     * @example
     * // Delete a few MessengerMessages
     * const { count } = await prisma.messengerMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MessengerMessageDeleteManyArgs>(
      args?: SelectSubset<T, MessengerMessageDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessengerMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessengerMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessengerMessages
     * const messengerMessage = await prisma.messengerMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MessengerMessageUpdateManyArgs>(
      args: SelectSubset<T, MessengerMessageUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MessengerMessage.
     * @param {MessengerMessageUpsertArgs} args - Arguments to update or create a MessengerMessage.
     * @example
     * // Update or create a MessengerMessage
     * const messengerMessage = await prisma.messengerMessage.upsert({
     *   create: {
     *     // ... data to create a MessengerMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessengerMessage we want to update
     *   }
     * })
    **/
    upsert<T extends MessengerMessageUpsertArgs>(
      args: SelectSubset<T, MessengerMessageUpsertArgs>
    ): Prisma__MessengerMessageClient<MessengerMessageGetPayload<T>>

    /**
     * Count the number of MessengerMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessengerMessageCountArgs} args - Arguments to filter MessengerMessages to count.
     * @example
     * // Count the number of MessengerMessages
     * const count = await prisma.messengerMessage.count({
     *   where: {
     *     // ... the filter for the MessengerMessages we want to count
     *   }
     * })
    **/
    count<T extends MessengerMessageCountArgs>(
      args?: Subset<T, MessengerMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessengerMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessengerMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessengerMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessengerMessageAggregateArgs>(args: Subset<T, MessengerMessageAggregateArgs>): Prisma.PrismaPromise<GetMessengerMessageAggregateType<T>>

    /**
     * Group by MessengerMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessengerMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessengerMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessengerMessageGroupByArgs['orderBy'] }
        : { orderBy?: MessengerMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessengerMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessengerMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for MessengerMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MessengerMessageClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    fromUser<T extends FacebookUserArgs= {}>(args?: Subset<T, FacebookUserArgs>): Prisma__FacebookUserClient<FacebookUserGetPayload<T> | Null>;

    toUser<T extends FacebookUserArgs= {}>(args?: Subset<T, FacebookUserArgs>): Prisma__FacebookUserClient<FacebookUserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * MessengerMessage base type for findUnique actions
   */
  export type MessengerMessageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the MessengerMessage
     */
    select?: MessengerMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessengerMessageInclude | null
    /**
     * Filter, which MessengerMessage to fetch.
     */
    where: MessengerMessageWhereUniqueInput
  }

  /**
   * MessengerMessage findUnique
   */
  export interface MessengerMessageFindUniqueArgs extends MessengerMessageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MessengerMessage findUniqueOrThrow
   */
  export type MessengerMessageFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MessengerMessage
     */
    select?: MessengerMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessengerMessageInclude | null
    /**
     * Filter, which MessengerMessage to fetch.
     */
    where: MessengerMessageWhereUniqueInput
  }


  /**
   * MessengerMessage base type for findFirst actions
   */
  export type MessengerMessageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the MessengerMessage
     */
    select?: MessengerMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessengerMessageInclude | null
    /**
     * Filter, which MessengerMessage to fetch.
     */
    where?: MessengerMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessengerMessages to fetch.
     */
    orderBy?: Enumerable<MessengerMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessengerMessages.
     */
    cursor?: MessengerMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessengerMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessengerMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessengerMessages.
     */
    distinct?: Enumerable<MessengerMessageScalarFieldEnum>
  }

  /**
   * MessengerMessage findFirst
   */
  export interface MessengerMessageFindFirstArgs extends MessengerMessageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MessengerMessage findFirstOrThrow
   */
  export type MessengerMessageFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MessengerMessage
     */
    select?: MessengerMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessengerMessageInclude | null
    /**
     * Filter, which MessengerMessage to fetch.
     */
    where?: MessengerMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessengerMessages to fetch.
     */
    orderBy?: Enumerable<MessengerMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessengerMessages.
     */
    cursor?: MessengerMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessengerMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessengerMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessengerMessages.
     */
    distinct?: Enumerable<MessengerMessageScalarFieldEnum>
  }


  /**
   * MessengerMessage findMany
   */
  export type MessengerMessageFindManyArgs = {
    /**
     * Select specific fields to fetch from the MessengerMessage
     */
    select?: MessengerMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessengerMessageInclude | null
    /**
     * Filter, which MessengerMessages to fetch.
     */
    where?: MessengerMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessengerMessages to fetch.
     */
    orderBy?: Enumerable<MessengerMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessengerMessages.
     */
    cursor?: MessengerMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessengerMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessengerMessages.
     */
    skip?: number
    distinct?: Enumerable<MessengerMessageScalarFieldEnum>
  }


  /**
   * MessengerMessage create
   */
  export type MessengerMessageCreateArgs = {
    /**
     * Select specific fields to fetch from the MessengerMessage
     */
    select?: MessengerMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessengerMessageInclude | null
    /**
     * The data needed to create a MessengerMessage.
     */
    data: XOR<MessengerMessageCreateInput, MessengerMessageUncheckedCreateInput>
  }


  /**
   * MessengerMessage createMany
   */
  export type MessengerMessageCreateManyArgs = {
    /**
     * The data used to create many MessengerMessages.
     */
    data: Enumerable<MessengerMessageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * MessengerMessage update
   */
  export type MessengerMessageUpdateArgs = {
    /**
     * Select specific fields to fetch from the MessengerMessage
     */
    select?: MessengerMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessengerMessageInclude | null
    /**
     * The data needed to update a MessengerMessage.
     */
    data: XOR<MessengerMessageUpdateInput, MessengerMessageUncheckedUpdateInput>
    /**
     * Choose, which MessengerMessage to update.
     */
    where: MessengerMessageWhereUniqueInput
  }


  /**
   * MessengerMessage updateMany
   */
  export type MessengerMessageUpdateManyArgs = {
    /**
     * The data used to update MessengerMessages.
     */
    data: XOR<MessengerMessageUpdateManyMutationInput, MessengerMessageUncheckedUpdateManyInput>
    /**
     * Filter which MessengerMessages to update
     */
    where?: MessengerMessageWhereInput
  }


  /**
   * MessengerMessage upsert
   */
  export type MessengerMessageUpsertArgs = {
    /**
     * Select specific fields to fetch from the MessengerMessage
     */
    select?: MessengerMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessengerMessageInclude | null
    /**
     * The filter to search for the MessengerMessage to update in case it exists.
     */
    where: MessengerMessageWhereUniqueInput
    /**
     * In case the MessengerMessage found by the `where` argument doesn't exist, create a new MessengerMessage with this data.
     */
    create: XOR<MessengerMessageCreateInput, MessengerMessageUncheckedCreateInput>
    /**
     * In case the MessengerMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessengerMessageUpdateInput, MessengerMessageUncheckedUpdateInput>
  }


  /**
   * MessengerMessage delete
   */
  export type MessengerMessageDeleteArgs = {
    /**
     * Select specific fields to fetch from the MessengerMessage
     */
    select?: MessengerMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessengerMessageInclude | null
    /**
     * Filter which MessengerMessage to delete.
     */
    where: MessengerMessageWhereUniqueInput
  }


  /**
   * MessengerMessage deleteMany
   */
  export type MessengerMessageDeleteManyArgs = {
    /**
     * Filter which MessengerMessages to delete
     */
    where?: MessengerMessageWhereInput
  }


  /**
   * MessengerMessage without action
   */
  export type MessengerMessageArgs = {
    /**
     * Select specific fields to fetch from the MessengerMessage
     */
    select?: MessengerMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessengerMessageInclude | null
  }



  /**
   * Model TodoList
   */


  export type AggregateTodoList = {
    _count: TodoListCountAggregateOutputType | null
    _avg: TodoListAvgAggregateOutputType | null
    _sum: TodoListSumAggregateOutputType | null
    _min: TodoListMinAggregateOutputType | null
    _max: TodoListMaxAggregateOutputType | null
  }

  export type TodoListAvgAggregateOutputType = {
    id: number | null
  }

  export type TodoListSumAggregateOutputType = {
    id: number | null
  }

  export type TodoListMinAggregateOutputType = {
    id: number | null
    task: string | null
    status: string | null
    bgColor: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TodoListMaxAggregateOutputType = {
    id: number | null
    task: string | null
    status: string | null
    bgColor: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TodoListCountAggregateOutputType = {
    id: number
    task: number
    status: number
    bgColor: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TodoListAvgAggregateInputType = {
    id?: true
  }

  export type TodoListSumAggregateInputType = {
    id?: true
  }

  export type TodoListMinAggregateInputType = {
    id?: true
    task?: true
    status?: true
    bgColor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TodoListMaxAggregateInputType = {
    id?: true
    task?: true
    status?: true
    bgColor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TodoListCountAggregateInputType = {
    id?: true
    task?: true
    status?: true
    bgColor?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TodoListAggregateArgs = {
    /**
     * Filter which TodoList to aggregate.
     */
    where?: TodoListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TodoLists to fetch.
     */
    orderBy?: Enumerable<TodoListOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TodoListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TodoLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TodoLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TodoLists
    **/
    _count?: true | TodoListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TodoListAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TodoListSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TodoListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TodoListMaxAggregateInputType
  }

  export type GetTodoListAggregateType<T extends TodoListAggregateArgs> = {
        [P in keyof T & keyof AggregateTodoList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTodoList[P]>
      : GetScalarType<T[P], AggregateTodoList[P]>
  }




  export type TodoListGroupByArgs = {
    where?: TodoListWhereInput
    orderBy?: Enumerable<TodoListOrderByWithAggregationInput>
    by: TodoListScalarFieldEnum[]
    having?: TodoListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TodoListCountAggregateInputType | true
    _avg?: TodoListAvgAggregateInputType
    _sum?: TodoListSumAggregateInputType
    _min?: TodoListMinAggregateInputType
    _max?: TodoListMaxAggregateInputType
  }


  export type TodoListGroupByOutputType = {
    id: number
    task: string
    status: string
    bgColor: string
    createdAt: Date
    updatedAt: Date
    _count: TodoListCountAggregateOutputType | null
    _avg: TodoListAvgAggregateOutputType | null
    _sum: TodoListSumAggregateOutputType | null
    _min: TodoListMinAggregateOutputType | null
    _max: TodoListMaxAggregateOutputType | null
  }

  type GetTodoListGroupByPayload<T extends TodoListGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TodoListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TodoListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TodoListGroupByOutputType[P]>
            : GetScalarType<T[P], TodoListGroupByOutputType[P]>
        }
      >
    >


  export type TodoListSelect = {
    id?: boolean
    task?: boolean
    status?: boolean
    bgColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type TodoListGetPayload<S extends boolean | null | undefined | TodoListArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TodoList :
    S extends undefined ? never :
    S extends { include: any } & (TodoListArgs | TodoListFindManyArgs)
    ? TodoList 
    : S extends { select: any } & (TodoListArgs | TodoListFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TodoList ? TodoList[P] : never
  } 
      : TodoList


  type TodoListCountArgs = 
    Omit<TodoListFindManyArgs, 'select' | 'include'> & {
      select?: TodoListCountAggregateInputType | true
    }

  export interface TodoListDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TodoList that matches the filter.
     * @param {TodoListFindUniqueArgs} args - Arguments to find a TodoList
     * @example
     * // Get one TodoList
     * const todoList = await prisma.todoList.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TodoListFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TodoListFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TodoList'> extends True ? Prisma__TodoListClient<TodoListGetPayload<T>> : Prisma__TodoListClient<TodoListGetPayload<T> | null, null>

    /**
     * Find one TodoList that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TodoListFindUniqueOrThrowArgs} args - Arguments to find a TodoList
     * @example
     * // Get one TodoList
     * const todoList = await prisma.todoList.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TodoListFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TodoListFindUniqueOrThrowArgs>
    ): Prisma__TodoListClient<TodoListGetPayload<T>>

    /**
     * Find the first TodoList that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoListFindFirstArgs} args - Arguments to find a TodoList
     * @example
     * // Get one TodoList
     * const todoList = await prisma.todoList.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TodoListFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TodoListFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TodoList'> extends True ? Prisma__TodoListClient<TodoListGetPayload<T>> : Prisma__TodoListClient<TodoListGetPayload<T> | null, null>

    /**
     * Find the first TodoList that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoListFindFirstOrThrowArgs} args - Arguments to find a TodoList
     * @example
     * // Get one TodoList
     * const todoList = await prisma.todoList.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TodoListFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TodoListFindFirstOrThrowArgs>
    ): Prisma__TodoListClient<TodoListGetPayload<T>>

    /**
     * Find zero or more TodoLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoListFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TodoLists
     * const todoLists = await prisma.todoList.findMany()
     * 
     * // Get first 10 TodoLists
     * const todoLists = await prisma.todoList.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const todoListWithIdOnly = await prisma.todoList.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TodoListFindManyArgs>(
      args?: SelectSubset<T, TodoListFindManyArgs>
    ): Prisma.PrismaPromise<Array<TodoListGetPayload<T>>>

    /**
     * Create a TodoList.
     * @param {TodoListCreateArgs} args - Arguments to create a TodoList.
     * @example
     * // Create one TodoList
     * const TodoList = await prisma.todoList.create({
     *   data: {
     *     // ... data to create a TodoList
     *   }
     * })
     * 
    **/
    create<T extends TodoListCreateArgs>(
      args: SelectSubset<T, TodoListCreateArgs>
    ): Prisma__TodoListClient<TodoListGetPayload<T>>

    /**
     * Create many TodoLists.
     *     @param {TodoListCreateManyArgs} args - Arguments to create many TodoLists.
     *     @example
     *     // Create many TodoLists
     *     const todoList = await prisma.todoList.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TodoListCreateManyArgs>(
      args?: SelectSubset<T, TodoListCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TodoList.
     * @param {TodoListDeleteArgs} args - Arguments to delete one TodoList.
     * @example
     * // Delete one TodoList
     * const TodoList = await prisma.todoList.delete({
     *   where: {
     *     // ... filter to delete one TodoList
     *   }
     * })
     * 
    **/
    delete<T extends TodoListDeleteArgs>(
      args: SelectSubset<T, TodoListDeleteArgs>
    ): Prisma__TodoListClient<TodoListGetPayload<T>>

    /**
     * Update one TodoList.
     * @param {TodoListUpdateArgs} args - Arguments to update one TodoList.
     * @example
     * // Update one TodoList
     * const todoList = await prisma.todoList.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TodoListUpdateArgs>(
      args: SelectSubset<T, TodoListUpdateArgs>
    ): Prisma__TodoListClient<TodoListGetPayload<T>>

    /**
     * Delete zero or more TodoLists.
     * @param {TodoListDeleteManyArgs} args - Arguments to filter TodoLists to delete.
     * @example
     * // Delete a few TodoLists
     * const { count } = await prisma.todoList.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TodoListDeleteManyArgs>(
      args?: SelectSubset<T, TodoListDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TodoLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TodoLists
     * const todoList = await prisma.todoList.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TodoListUpdateManyArgs>(
      args: SelectSubset<T, TodoListUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TodoList.
     * @param {TodoListUpsertArgs} args - Arguments to update or create a TodoList.
     * @example
     * // Update or create a TodoList
     * const todoList = await prisma.todoList.upsert({
     *   create: {
     *     // ... data to create a TodoList
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TodoList we want to update
     *   }
     * })
    **/
    upsert<T extends TodoListUpsertArgs>(
      args: SelectSubset<T, TodoListUpsertArgs>
    ): Prisma__TodoListClient<TodoListGetPayload<T>>

    /**
     * Count the number of TodoLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoListCountArgs} args - Arguments to filter TodoLists to count.
     * @example
     * // Count the number of TodoLists
     * const count = await prisma.todoList.count({
     *   where: {
     *     // ... the filter for the TodoLists we want to count
     *   }
     * })
    **/
    count<T extends TodoListCountArgs>(
      args?: Subset<T, TodoListCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TodoListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TodoList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TodoListAggregateArgs>(args: Subset<T, TodoListAggregateArgs>): Prisma.PrismaPromise<GetTodoListAggregateType<T>>

    /**
     * Group by TodoList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TodoListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TodoListGroupByArgs['orderBy'] }
        : { orderBy?: TodoListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TodoListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTodoListGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TodoList.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TodoListClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TodoList base type for findUnique actions
   */
  export type TodoListFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
    /**
     * Filter, which TodoList to fetch.
     */
    where: TodoListWhereUniqueInput
  }

  /**
   * TodoList findUnique
   */
  export interface TodoListFindUniqueArgs extends TodoListFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TodoList findUniqueOrThrow
   */
  export type TodoListFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
    /**
     * Filter, which TodoList to fetch.
     */
    where: TodoListWhereUniqueInput
  }


  /**
   * TodoList base type for findFirst actions
   */
  export type TodoListFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
    /**
     * Filter, which TodoList to fetch.
     */
    where?: TodoListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TodoLists to fetch.
     */
    orderBy?: Enumerable<TodoListOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TodoLists.
     */
    cursor?: TodoListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TodoLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TodoLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TodoLists.
     */
    distinct?: Enumerable<TodoListScalarFieldEnum>
  }

  /**
   * TodoList findFirst
   */
  export interface TodoListFindFirstArgs extends TodoListFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TodoList findFirstOrThrow
   */
  export type TodoListFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
    /**
     * Filter, which TodoList to fetch.
     */
    where?: TodoListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TodoLists to fetch.
     */
    orderBy?: Enumerable<TodoListOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TodoLists.
     */
    cursor?: TodoListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TodoLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TodoLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TodoLists.
     */
    distinct?: Enumerable<TodoListScalarFieldEnum>
  }


  /**
   * TodoList findMany
   */
  export type TodoListFindManyArgs = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
    /**
     * Filter, which TodoLists to fetch.
     */
    where?: TodoListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TodoLists to fetch.
     */
    orderBy?: Enumerable<TodoListOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TodoLists.
     */
    cursor?: TodoListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TodoLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TodoLists.
     */
    skip?: number
    distinct?: Enumerable<TodoListScalarFieldEnum>
  }


  /**
   * TodoList create
   */
  export type TodoListCreateArgs = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
    /**
     * The data needed to create a TodoList.
     */
    data: XOR<TodoListCreateInput, TodoListUncheckedCreateInput>
  }


  /**
   * TodoList createMany
   */
  export type TodoListCreateManyArgs = {
    /**
     * The data used to create many TodoLists.
     */
    data: Enumerable<TodoListCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TodoList update
   */
  export type TodoListUpdateArgs = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
    /**
     * The data needed to update a TodoList.
     */
    data: XOR<TodoListUpdateInput, TodoListUncheckedUpdateInput>
    /**
     * Choose, which TodoList to update.
     */
    where: TodoListWhereUniqueInput
  }


  /**
   * TodoList updateMany
   */
  export type TodoListUpdateManyArgs = {
    /**
     * The data used to update TodoLists.
     */
    data: XOR<TodoListUpdateManyMutationInput, TodoListUncheckedUpdateManyInput>
    /**
     * Filter which TodoLists to update
     */
    where?: TodoListWhereInput
  }


  /**
   * TodoList upsert
   */
  export type TodoListUpsertArgs = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
    /**
     * The filter to search for the TodoList to update in case it exists.
     */
    where: TodoListWhereUniqueInput
    /**
     * In case the TodoList found by the `where` argument doesn't exist, create a new TodoList with this data.
     */
    create: XOR<TodoListCreateInput, TodoListUncheckedCreateInput>
    /**
     * In case the TodoList was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TodoListUpdateInput, TodoListUncheckedUpdateInput>
  }


  /**
   * TodoList delete
   */
  export type TodoListDeleteArgs = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
    /**
     * Filter which TodoList to delete.
     */
    where: TodoListWhereUniqueInput
  }


  /**
   * TodoList deleteMany
   */
  export type TodoListDeleteManyArgs = {
    /**
     * Filter which TodoLists to delete
     */
    where?: TodoListWhereInput
  }


  /**
   * TodoList without action
   */
  export type TodoListArgs = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    name: string | null
    imageUrl: string | null
    bio: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    imageUrl: string | null
    bio: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    imageUrl: number
    bio: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    imageUrl?: true
    bio?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    imageUrl?: true
    bio?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    imageUrl?: true
    bio?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: UserScalarFieldEnum[]
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: number
    name: string
    imageUrl: string
    bio: string
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    name?: boolean
    imageUrl?: boolean
    bio?: boolean
    followingUserRelations?: boolean | User$followingUserRelationsArgs
    followedUserRelations?: boolean | User$followedUserRelationsArgs
    tweets?: boolean | User$tweetsArgs
    directMessagesFrom?: boolean | User$directMessagesFromArgs
    directMessagesTo?: boolean | User$directMessagesToArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | UserCountOutputTypeArgs
  }


  export type UserInclude = {
    followingUserRelations?: boolean | User$followingUserRelationsArgs
    followedUserRelations?: boolean | User$followedUserRelationsArgs
    tweets?: boolean | User$tweetsArgs
    directMessagesFrom?: boolean | User$directMessagesFromArgs
    directMessagesTo?: boolean | User$directMessagesToArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<S extends boolean | null | undefined | UserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? User :
    S extends undefined ? never :
    S extends { include: any } & (UserArgs | UserFindManyArgs)
    ? User  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'followingUserRelations' ? Array < UserRelationGetPayload<S['include'][P]>>  :
        P extends 'followedUserRelations' ? Array < UserRelationGetPayload<S['include'][P]>>  :
        P extends 'tweets' ? Array < TweetGetPayload<S['include'][P]>>  :
        P extends 'directMessagesFrom' ? Array < DirectMessageGetPayload<S['include'][P]>>  :
        P extends 'directMessagesTo' ? Array < DirectMessageGetPayload<S['include'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserArgs | UserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'followingUserRelations' ? Array < UserRelationGetPayload<S['select'][P]>>  :
        P extends 'followedUserRelations' ? Array < UserRelationGetPayload<S['select'][P]>>  :
        P extends 'tweets' ? Array < TweetGetPayload<S['select'][P]>>  :
        P extends 'directMessagesFrom' ? Array < DirectMessageGetPayload<S['select'][P]>>  :
        P extends 'directMessagesTo' ? Array < DirectMessageGetPayload<S['select'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof User ? User[P] : never
  } 
      : User


  type UserCountArgs = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserGetPayload<T>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    followingUserRelations<T extends User$followingUserRelationsArgs= {}>(args?: Subset<T, User$followingUserRelationsArgs>): Prisma.PrismaPromise<Array<UserRelationGetPayload<T>>| Null>;

    followedUserRelations<T extends User$followedUserRelationsArgs= {}>(args?: Subset<T, User$followedUserRelationsArgs>): Prisma.PrismaPromise<Array<UserRelationGetPayload<T>>| Null>;

    tweets<T extends User$tweetsArgs= {}>(args?: Subset<T, User$tweetsArgs>): Prisma.PrismaPromise<Array<TweetGetPayload<T>>| Null>;

    directMessagesFrom<T extends User$directMessagesFromArgs= {}>(args?: Subset<T, User$directMessagesFromArgs>): Prisma.PrismaPromise<Array<DirectMessageGetPayload<T>>| Null>;

    directMessagesTo<T extends User$directMessagesToArgs= {}>(args?: Subset<T, User$directMessagesToArgs>): Prisma.PrismaPromise<Array<DirectMessageGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUnique
   */
  export interface UserFindUniqueArgs extends UserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User findFirst
   */
  export interface UserFindFirstArgs extends UserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     */
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.followingUserRelations
   */
  export type User$followingUserRelationsArgs = {
    /**
     * Select specific fields to fetch from the UserRelation
     */
    select?: UserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRelationInclude | null
    where?: UserRelationWhereInput
    orderBy?: Enumerable<UserRelationOrderByWithRelationInput>
    cursor?: UserRelationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserRelationScalarFieldEnum>
  }


  /**
   * User.followedUserRelations
   */
  export type User$followedUserRelationsArgs = {
    /**
     * Select specific fields to fetch from the UserRelation
     */
    select?: UserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRelationInclude | null
    where?: UserRelationWhereInput
    orderBy?: Enumerable<UserRelationOrderByWithRelationInput>
    cursor?: UserRelationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserRelationScalarFieldEnum>
  }


  /**
   * User.tweets
   */
  export type User$tweetsArgs = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TweetInclude | null
    where?: TweetWhereInput
    orderBy?: Enumerable<TweetOrderByWithRelationInput>
    cursor?: TweetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TweetScalarFieldEnum>
  }


  /**
   * User.directMessagesFrom
   */
  export type User$directMessagesFromArgs = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
    where?: DirectMessageWhereInput
    orderBy?: Enumerable<DirectMessageOrderByWithRelationInput>
    cursor?: DirectMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DirectMessageScalarFieldEnum>
  }


  /**
   * User.directMessagesTo
   */
  export type User$directMessagesToArgs = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
    where?: DirectMessageWhereInput
    orderBy?: Enumerable<DirectMessageOrderByWithRelationInput>
    cursor?: DirectMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DirectMessageScalarFieldEnum>
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
  }



  /**
   * Model UserRelation
   */


  export type AggregateUserRelation = {
    _count: UserRelationCountAggregateOutputType | null
    _avg: UserRelationAvgAggregateOutputType | null
    _sum: UserRelationSumAggregateOutputType | null
    _min: UserRelationMinAggregateOutputType | null
    _max: UserRelationMaxAggregateOutputType | null
  }

  export type UserRelationAvgAggregateOutputType = {
    id: number | null
    followingUserId: number | null
    followedUserId: number | null
  }

  export type UserRelationSumAggregateOutputType = {
    id: number | null
    followingUserId: number | null
    followedUserId: number | null
  }

  export type UserRelationMinAggregateOutputType = {
    id: number | null
    followingUserId: number | null
    followedUserId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserRelationMaxAggregateOutputType = {
    id: number | null
    followingUserId: number | null
    followedUserId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserRelationCountAggregateOutputType = {
    id: number
    followingUserId: number
    followedUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserRelationAvgAggregateInputType = {
    id?: true
    followingUserId?: true
    followedUserId?: true
  }

  export type UserRelationSumAggregateInputType = {
    id?: true
    followingUserId?: true
    followedUserId?: true
  }

  export type UserRelationMinAggregateInputType = {
    id?: true
    followingUserId?: true
    followedUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserRelationMaxAggregateInputType = {
    id?: true
    followingUserId?: true
    followedUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserRelationCountAggregateInputType = {
    id?: true
    followingUserId?: true
    followedUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserRelationAggregateArgs = {
    /**
     * Filter which UserRelation to aggregate.
     */
    where?: UserRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRelations to fetch.
     */
    orderBy?: Enumerable<UserRelationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRelations
    **/
    _count?: true | UserRelationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserRelationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserRelationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRelationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRelationMaxAggregateInputType
  }

  export type GetUserRelationAggregateType<T extends UserRelationAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRelation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRelation[P]>
      : GetScalarType<T[P], AggregateUserRelation[P]>
  }




  export type UserRelationGroupByArgs = {
    where?: UserRelationWhereInput
    orderBy?: Enumerable<UserRelationOrderByWithAggregationInput>
    by: UserRelationScalarFieldEnum[]
    having?: UserRelationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRelationCountAggregateInputType | true
    _avg?: UserRelationAvgAggregateInputType
    _sum?: UserRelationSumAggregateInputType
    _min?: UserRelationMinAggregateInputType
    _max?: UserRelationMaxAggregateInputType
  }


  export type UserRelationGroupByOutputType = {
    id: number
    followingUserId: number
    followedUserId: number
    createdAt: Date
    updatedAt: Date
    _count: UserRelationCountAggregateOutputType | null
    _avg: UserRelationAvgAggregateOutputType | null
    _sum: UserRelationSumAggregateOutputType | null
    _min: UserRelationMinAggregateOutputType | null
    _max: UserRelationMaxAggregateOutputType | null
  }

  type GetUserRelationGroupByPayload<T extends UserRelationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserRelationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRelationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRelationGroupByOutputType[P]>
            : GetScalarType<T[P], UserRelationGroupByOutputType[P]>
        }
      >
    >


  export type UserRelationSelect = {
    id?: boolean
    followingUser?: boolean | UserArgs
    followingUserId?: boolean
    followedUser?: boolean | UserArgs
    followedUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type UserRelationInclude = {
    followingUser?: boolean | UserArgs
    followedUser?: boolean | UserArgs
  }

  export type UserRelationGetPayload<S extends boolean | null | undefined | UserRelationArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserRelation :
    S extends undefined ? never :
    S extends { include: any } & (UserRelationArgs | UserRelationFindManyArgs)
    ? UserRelation  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'followingUser' ? UserGetPayload<S['include'][P]> :
        P extends 'followedUser' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserRelationArgs | UserRelationFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'followingUser' ? UserGetPayload<S['select'][P]> :
        P extends 'followedUser' ? UserGetPayload<S['select'][P]> :  P extends keyof UserRelation ? UserRelation[P] : never
  } 
      : UserRelation


  type UserRelationCountArgs = 
    Omit<UserRelationFindManyArgs, 'select' | 'include'> & {
      select?: UserRelationCountAggregateInputType | true
    }

  export interface UserRelationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one UserRelation that matches the filter.
     * @param {UserRelationFindUniqueArgs} args - Arguments to find a UserRelation
     * @example
     * // Get one UserRelation
     * const userRelation = await prisma.userRelation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserRelationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserRelationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserRelation'> extends True ? Prisma__UserRelationClient<UserRelationGetPayload<T>> : Prisma__UserRelationClient<UserRelationGetPayload<T> | null, null>

    /**
     * Find one UserRelation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserRelationFindUniqueOrThrowArgs} args - Arguments to find a UserRelation
     * @example
     * // Get one UserRelation
     * const userRelation = await prisma.userRelation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserRelationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserRelationFindUniqueOrThrowArgs>
    ): Prisma__UserRelationClient<UserRelationGetPayload<T>>

    /**
     * Find the first UserRelation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRelationFindFirstArgs} args - Arguments to find a UserRelation
     * @example
     * // Get one UserRelation
     * const userRelation = await prisma.userRelation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserRelationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserRelationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserRelation'> extends True ? Prisma__UserRelationClient<UserRelationGetPayload<T>> : Prisma__UserRelationClient<UserRelationGetPayload<T> | null, null>

    /**
     * Find the first UserRelation that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRelationFindFirstOrThrowArgs} args - Arguments to find a UserRelation
     * @example
     * // Get one UserRelation
     * const userRelation = await prisma.userRelation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserRelationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserRelationFindFirstOrThrowArgs>
    ): Prisma__UserRelationClient<UserRelationGetPayload<T>>

    /**
     * Find zero or more UserRelations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRelationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRelations
     * const userRelations = await prisma.userRelation.findMany()
     * 
     * // Get first 10 UserRelations
     * const userRelations = await prisma.userRelation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userRelationWithIdOnly = await prisma.userRelation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserRelationFindManyArgs>(
      args?: SelectSubset<T, UserRelationFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserRelationGetPayload<T>>>

    /**
     * Create a UserRelation.
     * @param {UserRelationCreateArgs} args - Arguments to create a UserRelation.
     * @example
     * // Create one UserRelation
     * const UserRelation = await prisma.userRelation.create({
     *   data: {
     *     // ... data to create a UserRelation
     *   }
     * })
     * 
    **/
    create<T extends UserRelationCreateArgs>(
      args: SelectSubset<T, UserRelationCreateArgs>
    ): Prisma__UserRelationClient<UserRelationGetPayload<T>>

    /**
     * Create many UserRelations.
     *     @param {UserRelationCreateManyArgs} args - Arguments to create many UserRelations.
     *     @example
     *     // Create many UserRelations
     *     const userRelation = await prisma.userRelation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserRelationCreateManyArgs>(
      args?: SelectSubset<T, UserRelationCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserRelation.
     * @param {UserRelationDeleteArgs} args - Arguments to delete one UserRelation.
     * @example
     * // Delete one UserRelation
     * const UserRelation = await prisma.userRelation.delete({
     *   where: {
     *     // ... filter to delete one UserRelation
     *   }
     * })
     * 
    **/
    delete<T extends UserRelationDeleteArgs>(
      args: SelectSubset<T, UserRelationDeleteArgs>
    ): Prisma__UserRelationClient<UserRelationGetPayload<T>>

    /**
     * Update one UserRelation.
     * @param {UserRelationUpdateArgs} args - Arguments to update one UserRelation.
     * @example
     * // Update one UserRelation
     * const userRelation = await prisma.userRelation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserRelationUpdateArgs>(
      args: SelectSubset<T, UserRelationUpdateArgs>
    ): Prisma__UserRelationClient<UserRelationGetPayload<T>>

    /**
     * Delete zero or more UserRelations.
     * @param {UserRelationDeleteManyArgs} args - Arguments to filter UserRelations to delete.
     * @example
     * // Delete a few UserRelations
     * const { count } = await prisma.userRelation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserRelationDeleteManyArgs>(
      args?: SelectSubset<T, UserRelationDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRelationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRelations
     * const userRelation = await prisma.userRelation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserRelationUpdateManyArgs>(
      args: SelectSubset<T, UserRelationUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserRelation.
     * @param {UserRelationUpsertArgs} args - Arguments to update or create a UserRelation.
     * @example
     * // Update or create a UserRelation
     * const userRelation = await prisma.userRelation.upsert({
     *   create: {
     *     // ... data to create a UserRelation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRelation we want to update
     *   }
     * })
    **/
    upsert<T extends UserRelationUpsertArgs>(
      args: SelectSubset<T, UserRelationUpsertArgs>
    ): Prisma__UserRelationClient<UserRelationGetPayload<T>>

    /**
     * Count the number of UserRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRelationCountArgs} args - Arguments to filter UserRelations to count.
     * @example
     * // Count the number of UserRelations
     * const count = await prisma.userRelation.count({
     *   where: {
     *     // ... the filter for the UserRelations we want to count
     *   }
     * })
    **/
    count<T extends UserRelationCountArgs>(
      args?: Subset<T, UserRelationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRelationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRelationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRelationAggregateArgs>(args: Subset<T, UserRelationAggregateArgs>): Prisma.PrismaPromise<GetUserRelationAggregateType<T>>

    /**
     * Group by UserRelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRelationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRelationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRelationGroupByArgs['orderBy'] }
        : { orderBy?: UserRelationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRelationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRelationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRelation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserRelationClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    followingUser<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    followedUser<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserRelation base type for findUnique actions
   */
  export type UserRelationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the UserRelation
     */
    select?: UserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRelationInclude | null
    /**
     * Filter, which UserRelation to fetch.
     */
    where: UserRelationWhereUniqueInput
  }

  /**
   * UserRelation findUnique
   */
  export interface UserRelationFindUniqueArgs extends UserRelationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserRelation findUniqueOrThrow
   */
  export type UserRelationFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserRelation
     */
    select?: UserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRelationInclude | null
    /**
     * Filter, which UserRelation to fetch.
     */
    where: UserRelationWhereUniqueInput
  }


  /**
   * UserRelation base type for findFirst actions
   */
  export type UserRelationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the UserRelation
     */
    select?: UserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRelationInclude | null
    /**
     * Filter, which UserRelation to fetch.
     */
    where?: UserRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRelations to fetch.
     */
    orderBy?: Enumerable<UserRelationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRelations.
     */
    cursor?: UserRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRelations.
     */
    distinct?: Enumerable<UserRelationScalarFieldEnum>
  }

  /**
   * UserRelation findFirst
   */
  export interface UserRelationFindFirstArgs extends UserRelationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserRelation findFirstOrThrow
   */
  export type UserRelationFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserRelation
     */
    select?: UserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRelationInclude | null
    /**
     * Filter, which UserRelation to fetch.
     */
    where?: UserRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRelations to fetch.
     */
    orderBy?: Enumerable<UserRelationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRelations.
     */
    cursor?: UserRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRelations.
     */
    distinct?: Enumerable<UserRelationScalarFieldEnum>
  }


  /**
   * UserRelation findMany
   */
  export type UserRelationFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserRelation
     */
    select?: UserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRelationInclude | null
    /**
     * Filter, which UserRelations to fetch.
     */
    where?: UserRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRelations to fetch.
     */
    orderBy?: Enumerable<UserRelationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRelations.
     */
    cursor?: UserRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRelations.
     */
    skip?: number
    distinct?: Enumerable<UserRelationScalarFieldEnum>
  }


  /**
   * UserRelation create
   */
  export type UserRelationCreateArgs = {
    /**
     * Select specific fields to fetch from the UserRelation
     */
    select?: UserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRelationInclude | null
    /**
     * The data needed to create a UserRelation.
     */
    data: XOR<UserRelationCreateInput, UserRelationUncheckedCreateInput>
  }


  /**
   * UserRelation createMany
   */
  export type UserRelationCreateManyArgs = {
    /**
     * The data used to create many UserRelations.
     */
    data: Enumerable<UserRelationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserRelation update
   */
  export type UserRelationUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserRelation
     */
    select?: UserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRelationInclude | null
    /**
     * The data needed to update a UserRelation.
     */
    data: XOR<UserRelationUpdateInput, UserRelationUncheckedUpdateInput>
    /**
     * Choose, which UserRelation to update.
     */
    where: UserRelationWhereUniqueInput
  }


  /**
   * UserRelation updateMany
   */
  export type UserRelationUpdateManyArgs = {
    /**
     * The data used to update UserRelations.
     */
    data: XOR<UserRelationUpdateManyMutationInput, UserRelationUncheckedUpdateManyInput>
    /**
     * Filter which UserRelations to update
     */
    where?: UserRelationWhereInput
  }


  /**
   * UserRelation upsert
   */
  export type UserRelationUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserRelation
     */
    select?: UserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRelationInclude | null
    /**
     * The filter to search for the UserRelation to update in case it exists.
     */
    where: UserRelationWhereUniqueInput
    /**
     * In case the UserRelation found by the `where` argument doesn't exist, create a new UserRelation with this data.
     */
    create: XOR<UserRelationCreateInput, UserRelationUncheckedCreateInput>
    /**
     * In case the UserRelation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRelationUpdateInput, UserRelationUncheckedUpdateInput>
  }


  /**
   * UserRelation delete
   */
  export type UserRelationDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserRelation
     */
    select?: UserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRelationInclude | null
    /**
     * Filter which UserRelation to delete.
     */
    where: UserRelationWhereUniqueInput
  }


  /**
   * UserRelation deleteMany
   */
  export type UserRelationDeleteManyArgs = {
    /**
     * Filter which UserRelations to delete
     */
    where?: UserRelationWhereInput
  }


  /**
   * UserRelation without action
   */
  export type UserRelationArgs = {
    /**
     * Select specific fields to fetch from the UserRelation
     */
    select?: UserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRelationInclude | null
  }



  /**
   * Model Tweet
   */


  export type AggregateTweet = {
    _count: TweetCountAggregateOutputType | null
    _avg: TweetAvgAggregateOutputType | null
    _sum: TweetSumAggregateOutputType | null
    _min: TweetMinAggregateOutputType | null
    _max: TweetMaxAggregateOutputType | null
  }

  export type TweetAvgAggregateOutputType = {
    id: number | null
    parentTweetId: number | null
    userId: number | null
  }

  export type TweetSumAggregateOutputType = {
    id: number | null
    parentTweetId: number | null
    userId: number | null
  }

  export type TweetMinAggregateOutputType = {
    id: number | null
    tweetText: string | null
    parentTweetId: number | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TweetMaxAggregateOutputType = {
    id: number | null
    tweetText: string | null
    parentTweetId: number | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TweetCountAggregateOutputType = {
    id: number
    tweetText: number
    parentTweetId: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TweetAvgAggregateInputType = {
    id?: true
    parentTweetId?: true
    userId?: true
  }

  export type TweetSumAggregateInputType = {
    id?: true
    parentTweetId?: true
    userId?: true
  }

  export type TweetMinAggregateInputType = {
    id?: true
    tweetText?: true
    parentTweetId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TweetMaxAggregateInputType = {
    id?: true
    tweetText?: true
    parentTweetId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TweetCountAggregateInputType = {
    id?: true
    tweetText?: true
    parentTweetId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TweetAggregateArgs = {
    /**
     * Filter which Tweet to aggregate.
     */
    where?: TweetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tweets to fetch.
     */
    orderBy?: Enumerable<TweetOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TweetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tweets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tweets
    **/
    _count?: true | TweetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TweetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TweetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TweetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TweetMaxAggregateInputType
  }

  export type GetTweetAggregateType<T extends TweetAggregateArgs> = {
        [P in keyof T & keyof AggregateTweet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTweet[P]>
      : GetScalarType<T[P], AggregateTweet[P]>
  }




  export type TweetGroupByArgs = {
    where?: TweetWhereInput
    orderBy?: Enumerable<TweetOrderByWithAggregationInput>
    by: TweetScalarFieldEnum[]
    having?: TweetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TweetCountAggregateInputType | true
    _avg?: TweetAvgAggregateInputType
    _sum?: TweetSumAggregateInputType
    _min?: TweetMinAggregateInputType
    _max?: TweetMaxAggregateInputType
  }


  export type TweetGroupByOutputType = {
    id: number
    tweetText: string
    parentTweetId: number | null
    userId: number
    createdAt: Date
    updatedAt: Date
    _count: TweetCountAggregateOutputType | null
    _avg: TweetAvgAggregateOutputType | null
    _sum: TweetSumAggregateOutputType | null
    _min: TweetMinAggregateOutputType | null
    _max: TweetMaxAggregateOutputType | null
  }

  type GetTweetGroupByPayload<T extends TweetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TweetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TweetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TweetGroupByOutputType[P]>
            : GetScalarType<T[P], TweetGroupByOutputType[P]>
        }
      >
    >


  export type TweetSelect = {
    id?: boolean
    tweetText?: boolean
    tweetingUser?: boolean | UserArgs
    parentTweet?: boolean | TweetArgs
    parentTweetId?: boolean
    childTweets?: boolean | Tweet$childTweetsArgs
    userId?: boolean
    hashTags?: boolean | Tweet$hashTagsArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | TweetCountOutputTypeArgs
  }


  export type TweetInclude = {
    tweetingUser?: boolean | UserArgs
    parentTweet?: boolean | TweetArgs
    childTweets?: boolean | Tweet$childTweetsArgs
    hashTags?: boolean | Tweet$hashTagsArgs
    _count?: boolean | TweetCountOutputTypeArgs
  }

  export type TweetGetPayload<S extends boolean | null | undefined | TweetArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Tweet :
    S extends undefined ? never :
    S extends { include: any } & (TweetArgs | TweetFindManyArgs)
    ? Tweet  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'tweetingUser' ? UserGetPayload<S['include'][P]> :
        P extends 'parentTweet' ? TweetGetPayload<S['include'][P]> | null :
        P extends 'childTweets' ? Array < TweetGetPayload<S['include'][P]>>  :
        P extends 'hashTags' ? Array < HashTagGetPayload<S['include'][P]>>  :
        P extends '_count' ? TweetCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TweetArgs | TweetFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'tweetingUser' ? UserGetPayload<S['select'][P]> :
        P extends 'parentTweet' ? TweetGetPayload<S['select'][P]> | null :
        P extends 'childTweets' ? Array < TweetGetPayload<S['select'][P]>>  :
        P extends 'hashTags' ? Array < HashTagGetPayload<S['select'][P]>>  :
        P extends '_count' ? TweetCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Tweet ? Tweet[P] : never
  } 
      : Tweet


  type TweetCountArgs = 
    Omit<TweetFindManyArgs, 'select' | 'include'> & {
      select?: TweetCountAggregateInputType | true
    }

  export interface TweetDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Tweet that matches the filter.
     * @param {TweetFindUniqueArgs} args - Arguments to find a Tweet
     * @example
     * // Get one Tweet
     * const tweet = await prisma.tweet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TweetFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TweetFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Tweet'> extends True ? Prisma__TweetClient<TweetGetPayload<T>> : Prisma__TweetClient<TweetGetPayload<T> | null, null>

    /**
     * Find one Tweet that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TweetFindUniqueOrThrowArgs} args - Arguments to find a Tweet
     * @example
     * // Get one Tweet
     * const tweet = await prisma.tweet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TweetFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TweetFindUniqueOrThrowArgs>
    ): Prisma__TweetClient<TweetGetPayload<T>>

    /**
     * Find the first Tweet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetFindFirstArgs} args - Arguments to find a Tweet
     * @example
     * // Get one Tweet
     * const tweet = await prisma.tweet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TweetFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TweetFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Tweet'> extends True ? Prisma__TweetClient<TweetGetPayload<T>> : Prisma__TweetClient<TweetGetPayload<T> | null, null>

    /**
     * Find the first Tweet that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetFindFirstOrThrowArgs} args - Arguments to find a Tweet
     * @example
     * // Get one Tweet
     * const tweet = await prisma.tweet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TweetFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TweetFindFirstOrThrowArgs>
    ): Prisma__TweetClient<TweetGetPayload<T>>

    /**
     * Find zero or more Tweets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tweets
     * const tweets = await prisma.tweet.findMany()
     * 
     * // Get first 10 Tweets
     * const tweets = await prisma.tweet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tweetWithIdOnly = await prisma.tweet.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TweetFindManyArgs>(
      args?: SelectSubset<T, TweetFindManyArgs>
    ): Prisma.PrismaPromise<Array<TweetGetPayload<T>>>

    /**
     * Create a Tweet.
     * @param {TweetCreateArgs} args - Arguments to create a Tweet.
     * @example
     * // Create one Tweet
     * const Tweet = await prisma.tweet.create({
     *   data: {
     *     // ... data to create a Tweet
     *   }
     * })
     * 
    **/
    create<T extends TweetCreateArgs>(
      args: SelectSubset<T, TweetCreateArgs>
    ): Prisma__TweetClient<TweetGetPayload<T>>

    /**
     * Create many Tweets.
     *     @param {TweetCreateManyArgs} args - Arguments to create many Tweets.
     *     @example
     *     // Create many Tweets
     *     const tweet = await prisma.tweet.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TweetCreateManyArgs>(
      args?: SelectSubset<T, TweetCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tweet.
     * @param {TweetDeleteArgs} args - Arguments to delete one Tweet.
     * @example
     * // Delete one Tweet
     * const Tweet = await prisma.tweet.delete({
     *   where: {
     *     // ... filter to delete one Tweet
     *   }
     * })
     * 
    **/
    delete<T extends TweetDeleteArgs>(
      args: SelectSubset<T, TweetDeleteArgs>
    ): Prisma__TweetClient<TweetGetPayload<T>>

    /**
     * Update one Tweet.
     * @param {TweetUpdateArgs} args - Arguments to update one Tweet.
     * @example
     * // Update one Tweet
     * const tweet = await prisma.tweet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TweetUpdateArgs>(
      args: SelectSubset<T, TweetUpdateArgs>
    ): Prisma__TweetClient<TweetGetPayload<T>>

    /**
     * Delete zero or more Tweets.
     * @param {TweetDeleteManyArgs} args - Arguments to filter Tweets to delete.
     * @example
     * // Delete a few Tweets
     * const { count } = await prisma.tweet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TweetDeleteManyArgs>(
      args?: SelectSubset<T, TweetDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tweets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tweets
     * const tweet = await prisma.tweet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TweetUpdateManyArgs>(
      args: SelectSubset<T, TweetUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tweet.
     * @param {TweetUpsertArgs} args - Arguments to update or create a Tweet.
     * @example
     * // Update or create a Tweet
     * const tweet = await prisma.tweet.upsert({
     *   create: {
     *     // ... data to create a Tweet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tweet we want to update
     *   }
     * })
    **/
    upsert<T extends TweetUpsertArgs>(
      args: SelectSubset<T, TweetUpsertArgs>
    ): Prisma__TweetClient<TweetGetPayload<T>>

    /**
     * Count the number of Tweets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetCountArgs} args - Arguments to filter Tweets to count.
     * @example
     * // Count the number of Tweets
     * const count = await prisma.tweet.count({
     *   where: {
     *     // ... the filter for the Tweets we want to count
     *   }
     * })
    **/
    count<T extends TweetCountArgs>(
      args?: Subset<T, TweetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TweetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tweet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TweetAggregateArgs>(args: Subset<T, TweetAggregateArgs>): Prisma.PrismaPromise<GetTweetAggregateType<T>>

    /**
     * Group by Tweet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TweetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TweetGroupByArgs['orderBy'] }
        : { orderBy?: TweetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TweetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTweetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Tweet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TweetClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    tweetingUser<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    parentTweet<T extends TweetArgs= {}>(args?: Subset<T, TweetArgs>): Prisma__TweetClient<TweetGetPayload<T> | Null>;

    childTweets<T extends Tweet$childTweetsArgs= {}>(args?: Subset<T, Tweet$childTweetsArgs>): Prisma.PrismaPromise<Array<TweetGetPayload<T>>| Null>;

    hashTags<T extends Tweet$hashTagsArgs= {}>(args?: Subset<T, Tweet$hashTagsArgs>): Prisma.PrismaPromise<Array<HashTagGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Tweet base type for findUnique actions
   */
  export type TweetFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TweetInclude | null
    /**
     * Filter, which Tweet to fetch.
     */
    where: TweetWhereUniqueInput
  }

  /**
   * Tweet findUnique
   */
  export interface TweetFindUniqueArgs extends TweetFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Tweet findUniqueOrThrow
   */
  export type TweetFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TweetInclude | null
    /**
     * Filter, which Tweet to fetch.
     */
    where: TweetWhereUniqueInput
  }


  /**
   * Tweet base type for findFirst actions
   */
  export type TweetFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TweetInclude | null
    /**
     * Filter, which Tweet to fetch.
     */
    where?: TweetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tweets to fetch.
     */
    orderBy?: Enumerable<TweetOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tweets.
     */
    cursor?: TweetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tweets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tweets.
     */
    distinct?: Enumerable<TweetScalarFieldEnum>
  }

  /**
   * Tweet findFirst
   */
  export interface TweetFindFirstArgs extends TweetFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Tweet findFirstOrThrow
   */
  export type TweetFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TweetInclude | null
    /**
     * Filter, which Tweet to fetch.
     */
    where?: TweetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tweets to fetch.
     */
    orderBy?: Enumerable<TweetOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tweets.
     */
    cursor?: TweetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tweets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tweets.
     */
    distinct?: Enumerable<TweetScalarFieldEnum>
  }


  /**
   * Tweet findMany
   */
  export type TweetFindManyArgs = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TweetInclude | null
    /**
     * Filter, which Tweets to fetch.
     */
    where?: TweetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tweets to fetch.
     */
    orderBy?: Enumerable<TweetOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tweets.
     */
    cursor?: TweetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tweets.
     */
    skip?: number
    distinct?: Enumerable<TweetScalarFieldEnum>
  }


  /**
   * Tweet create
   */
  export type TweetCreateArgs = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TweetInclude | null
    /**
     * The data needed to create a Tweet.
     */
    data: XOR<TweetCreateInput, TweetUncheckedCreateInput>
  }


  /**
   * Tweet createMany
   */
  export type TweetCreateManyArgs = {
    /**
     * The data used to create many Tweets.
     */
    data: Enumerable<TweetCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Tweet update
   */
  export type TweetUpdateArgs = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TweetInclude | null
    /**
     * The data needed to update a Tweet.
     */
    data: XOR<TweetUpdateInput, TweetUncheckedUpdateInput>
    /**
     * Choose, which Tweet to update.
     */
    where: TweetWhereUniqueInput
  }


  /**
   * Tweet updateMany
   */
  export type TweetUpdateManyArgs = {
    /**
     * The data used to update Tweets.
     */
    data: XOR<TweetUpdateManyMutationInput, TweetUncheckedUpdateManyInput>
    /**
     * Filter which Tweets to update
     */
    where?: TweetWhereInput
  }


  /**
   * Tweet upsert
   */
  export type TweetUpsertArgs = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TweetInclude | null
    /**
     * The filter to search for the Tweet to update in case it exists.
     */
    where: TweetWhereUniqueInput
    /**
     * In case the Tweet found by the `where` argument doesn't exist, create a new Tweet with this data.
     */
    create: XOR<TweetCreateInput, TweetUncheckedCreateInput>
    /**
     * In case the Tweet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TweetUpdateInput, TweetUncheckedUpdateInput>
  }


  /**
   * Tweet delete
   */
  export type TweetDeleteArgs = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TweetInclude | null
    /**
     * Filter which Tweet to delete.
     */
    where: TweetWhereUniqueInput
  }


  /**
   * Tweet deleteMany
   */
  export type TweetDeleteManyArgs = {
    /**
     * Filter which Tweets to delete
     */
    where?: TweetWhereInput
  }


  /**
   * Tweet.childTweets
   */
  export type Tweet$childTweetsArgs = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TweetInclude | null
    where?: TweetWhereInput
    orderBy?: Enumerable<TweetOrderByWithRelationInput>
    cursor?: TweetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TweetScalarFieldEnum>
  }


  /**
   * Tweet.hashTags
   */
  export type Tweet$hashTagsArgs = {
    /**
     * Select specific fields to fetch from the HashTag
     */
    select?: HashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HashTagInclude | null
    where?: HashTagWhereInput
    orderBy?: Enumerable<HashTagOrderByWithRelationInput>
    cursor?: HashTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<HashTagScalarFieldEnum>
  }


  /**
   * Tweet without action
   */
  export type TweetArgs = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TweetInclude | null
  }



  /**
   * Model HashTag
   */


  export type AggregateHashTag = {
    _count: HashTagCountAggregateOutputType | null
    _avg: HashTagAvgAggregateOutputType | null
    _sum: HashTagSumAggregateOutputType | null
    _min: HashTagMinAggregateOutputType | null
    _max: HashTagMaxAggregateOutputType | null
  }

  export type HashTagAvgAggregateOutputType = {
    id: number | null
  }

  export type HashTagSumAggregateOutputType = {
    id: number | null
  }

  export type HashTagMinAggregateOutputType = {
    id: number | null
    hashTagText: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HashTagMaxAggregateOutputType = {
    id: number | null
    hashTagText: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HashTagCountAggregateOutputType = {
    id: number
    hashTagText: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HashTagAvgAggregateInputType = {
    id?: true
  }

  export type HashTagSumAggregateInputType = {
    id?: true
  }

  export type HashTagMinAggregateInputType = {
    id?: true
    hashTagText?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HashTagMaxAggregateInputType = {
    id?: true
    hashTagText?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HashTagCountAggregateInputType = {
    id?: true
    hashTagText?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HashTagAggregateArgs = {
    /**
     * Filter which HashTag to aggregate.
     */
    where?: HashTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HashTags to fetch.
     */
    orderBy?: Enumerable<HashTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HashTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HashTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HashTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HashTags
    **/
    _count?: true | HashTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HashTagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HashTagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HashTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HashTagMaxAggregateInputType
  }

  export type GetHashTagAggregateType<T extends HashTagAggregateArgs> = {
        [P in keyof T & keyof AggregateHashTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHashTag[P]>
      : GetScalarType<T[P], AggregateHashTag[P]>
  }




  export type HashTagGroupByArgs = {
    where?: HashTagWhereInput
    orderBy?: Enumerable<HashTagOrderByWithAggregationInput>
    by: HashTagScalarFieldEnum[]
    having?: HashTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HashTagCountAggregateInputType | true
    _avg?: HashTagAvgAggregateInputType
    _sum?: HashTagSumAggregateInputType
    _min?: HashTagMinAggregateInputType
    _max?: HashTagMaxAggregateInputType
  }


  export type HashTagGroupByOutputType = {
    id: number
    hashTagText: string
    createdAt: Date
    updatedAt: Date
    _count: HashTagCountAggregateOutputType | null
    _avg: HashTagAvgAggregateOutputType | null
    _sum: HashTagSumAggregateOutputType | null
    _min: HashTagMinAggregateOutputType | null
    _max: HashTagMaxAggregateOutputType | null
  }

  type GetHashTagGroupByPayload<T extends HashTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<HashTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HashTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HashTagGroupByOutputType[P]>
            : GetScalarType<T[P], HashTagGroupByOutputType[P]>
        }
      >
    >


  export type HashTagSelect = {
    id?: boolean
    hashTagText?: boolean
    isInTweets?: boolean | HashTag$isInTweetsArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | HashTagCountOutputTypeArgs
  }


  export type HashTagInclude = {
    isInTweets?: boolean | HashTag$isInTweetsArgs
    _count?: boolean | HashTagCountOutputTypeArgs
  }

  export type HashTagGetPayload<S extends boolean | null | undefined | HashTagArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? HashTag :
    S extends undefined ? never :
    S extends { include: any } & (HashTagArgs | HashTagFindManyArgs)
    ? HashTag  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'isInTweets' ? Array < TweetGetPayload<S['include'][P]>>  :
        P extends '_count' ? HashTagCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (HashTagArgs | HashTagFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'isInTweets' ? Array < TweetGetPayload<S['select'][P]>>  :
        P extends '_count' ? HashTagCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof HashTag ? HashTag[P] : never
  } 
      : HashTag


  type HashTagCountArgs = 
    Omit<HashTagFindManyArgs, 'select' | 'include'> & {
      select?: HashTagCountAggregateInputType | true
    }

  export interface HashTagDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one HashTag that matches the filter.
     * @param {HashTagFindUniqueArgs} args - Arguments to find a HashTag
     * @example
     * // Get one HashTag
     * const hashTag = await prisma.hashTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends HashTagFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, HashTagFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'HashTag'> extends True ? Prisma__HashTagClient<HashTagGetPayload<T>> : Prisma__HashTagClient<HashTagGetPayload<T> | null, null>

    /**
     * Find one HashTag that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {HashTagFindUniqueOrThrowArgs} args - Arguments to find a HashTag
     * @example
     * // Get one HashTag
     * const hashTag = await prisma.hashTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends HashTagFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, HashTagFindUniqueOrThrowArgs>
    ): Prisma__HashTagClient<HashTagGetPayload<T>>

    /**
     * Find the first HashTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HashTagFindFirstArgs} args - Arguments to find a HashTag
     * @example
     * // Get one HashTag
     * const hashTag = await prisma.hashTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends HashTagFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, HashTagFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'HashTag'> extends True ? Prisma__HashTagClient<HashTagGetPayload<T>> : Prisma__HashTagClient<HashTagGetPayload<T> | null, null>

    /**
     * Find the first HashTag that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HashTagFindFirstOrThrowArgs} args - Arguments to find a HashTag
     * @example
     * // Get one HashTag
     * const hashTag = await prisma.hashTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends HashTagFindFirstOrThrowArgs>(
      args?: SelectSubset<T, HashTagFindFirstOrThrowArgs>
    ): Prisma__HashTagClient<HashTagGetPayload<T>>

    /**
     * Find zero or more HashTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HashTagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HashTags
     * const hashTags = await prisma.hashTag.findMany()
     * 
     * // Get first 10 HashTags
     * const hashTags = await prisma.hashTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hashTagWithIdOnly = await prisma.hashTag.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends HashTagFindManyArgs>(
      args?: SelectSubset<T, HashTagFindManyArgs>
    ): Prisma.PrismaPromise<Array<HashTagGetPayload<T>>>

    /**
     * Create a HashTag.
     * @param {HashTagCreateArgs} args - Arguments to create a HashTag.
     * @example
     * // Create one HashTag
     * const HashTag = await prisma.hashTag.create({
     *   data: {
     *     // ... data to create a HashTag
     *   }
     * })
     * 
    **/
    create<T extends HashTagCreateArgs>(
      args: SelectSubset<T, HashTagCreateArgs>
    ): Prisma__HashTagClient<HashTagGetPayload<T>>

    /**
     * Create many HashTags.
     *     @param {HashTagCreateManyArgs} args - Arguments to create many HashTags.
     *     @example
     *     // Create many HashTags
     *     const hashTag = await prisma.hashTag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends HashTagCreateManyArgs>(
      args?: SelectSubset<T, HashTagCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HashTag.
     * @param {HashTagDeleteArgs} args - Arguments to delete one HashTag.
     * @example
     * // Delete one HashTag
     * const HashTag = await prisma.hashTag.delete({
     *   where: {
     *     // ... filter to delete one HashTag
     *   }
     * })
     * 
    **/
    delete<T extends HashTagDeleteArgs>(
      args: SelectSubset<T, HashTagDeleteArgs>
    ): Prisma__HashTagClient<HashTagGetPayload<T>>

    /**
     * Update one HashTag.
     * @param {HashTagUpdateArgs} args - Arguments to update one HashTag.
     * @example
     * // Update one HashTag
     * const hashTag = await prisma.hashTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends HashTagUpdateArgs>(
      args: SelectSubset<T, HashTagUpdateArgs>
    ): Prisma__HashTagClient<HashTagGetPayload<T>>

    /**
     * Delete zero or more HashTags.
     * @param {HashTagDeleteManyArgs} args - Arguments to filter HashTags to delete.
     * @example
     * // Delete a few HashTags
     * const { count } = await prisma.hashTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends HashTagDeleteManyArgs>(
      args?: SelectSubset<T, HashTagDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HashTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HashTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HashTags
     * const hashTag = await prisma.hashTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends HashTagUpdateManyArgs>(
      args: SelectSubset<T, HashTagUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HashTag.
     * @param {HashTagUpsertArgs} args - Arguments to update or create a HashTag.
     * @example
     * // Update or create a HashTag
     * const hashTag = await prisma.hashTag.upsert({
     *   create: {
     *     // ... data to create a HashTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HashTag we want to update
     *   }
     * })
    **/
    upsert<T extends HashTagUpsertArgs>(
      args: SelectSubset<T, HashTagUpsertArgs>
    ): Prisma__HashTagClient<HashTagGetPayload<T>>

    /**
     * Count the number of HashTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HashTagCountArgs} args - Arguments to filter HashTags to count.
     * @example
     * // Count the number of HashTags
     * const count = await prisma.hashTag.count({
     *   where: {
     *     // ... the filter for the HashTags we want to count
     *   }
     * })
    **/
    count<T extends HashTagCountArgs>(
      args?: Subset<T, HashTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HashTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HashTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HashTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HashTagAggregateArgs>(args: Subset<T, HashTagAggregateArgs>): Prisma.PrismaPromise<GetHashTagAggregateType<T>>

    /**
     * Group by HashTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HashTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HashTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HashTagGroupByArgs['orderBy'] }
        : { orderBy?: HashTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HashTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHashTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for HashTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__HashTagClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    isInTweets<T extends HashTag$isInTweetsArgs= {}>(args?: Subset<T, HashTag$isInTweetsArgs>): Prisma.PrismaPromise<Array<TweetGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * HashTag base type for findUnique actions
   */
  export type HashTagFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the HashTag
     */
    select?: HashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HashTagInclude | null
    /**
     * Filter, which HashTag to fetch.
     */
    where: HashTagWhereUniqueInput
  }

  /**
   * HashTag findUnique
   */
  export interface HashTagFindUniqueArgs extends HashTagFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * HashTag findUniqueOrThrow
   */
  export type HashTagFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the HashTag
     */
    select?: HashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HashTagInclude | null
    /**
     * Filter, which HashTag to fetch.
     */
    where: HashTagWhereUniqueInput
  }


  /**
   * HashTag base type for findFirst actions
   */
  export type HashTagFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the HashTag
     */
    select?: HashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HashTagInclude | null
    /**
     * Filter, which HashTag to fetch.
     */
    where?: HashTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HashTags to fetch.
     */
    orderBy?: Enumerable<HashTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HashTags.
     */
    cursor?: HashTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HashTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HashTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HashTags.
     */
    distinct?: Enumerable<HashTagScalarFieldEnum>
  }

  /**
   * HashTag findFirst
   */
  export interface HashTagFindFirstArgs extends HashTagFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * HashTag findFirstOrThrow
   */
  export type HashTagFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the HashTag
     */
    select?: HashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HashTagInclude | null
    /**
     * Filter, which HashTag to fetch.
     */
    where?: HashTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HashTags to fetch.
     */
    orderBy?: Enumerable<HashTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HashTags.
     */
    cursor?: HashTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HashTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HashTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HashTags.
     */
    distinct?: Enumerable<HashTagScalarFieldEnum>
  }


  /**
   * HashTag findMany
   */
  export type HashTagFindManyArgs = {
    /**
     * Select specific fields to fetch from the HashTag
     */
    select?: HashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HashTagInclude | null
    /**
     * Filter, which HashTags to fetch.
     */
    where?: HashTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HashTags to fetch.
     */
    orderBy?: Enumerable<HashTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HashTags.
     */
    cursor?: HashTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HashTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HashTags.
     */
    skip?: number
    distinct?: Enumerable<HashTagScalarFieldEnum>
  }


  /**
   * HashTag create
   */
  export type HashTagCreateArgs = {
    /**
     * Select specific fields to fetch from the HashTag
     */
    select?: HashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HashTagInclude | null
    /**
     * The data needed to create a HashTag.
     */
    data: XOR<HashTagCreateInput, HashTagUncheckedCreateInput>
  }


  /**
   * HashTag createMany
   */
  export type HashTagCreateManyArgs = {
    /**
     * The data used to create many HashTags.
     */
    data: Enumerable<HashTagCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * HashTag update
   */
  export type HashTagUpdateArgs = {
    /**
     * Select specific fields to fetch from the HashTag
     */
    select?: HashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HashTagInclude | null
    /**
     * The data needed to update a HashTag.
     */
    data: XOR<HashTagUpdateInput, HashTagUncheckedUpdateInput>
    /**
     * Choose, which HashTag to update.
     */
    where: HashTagWhereUniqueInput
  }


  /**
   * HashTag updateMany
   */
  export type HashTagUpdateManyArgs = {
    /**
     * The data used to update HashTags.
     */
    data: XOR<HashTagUpdateManyMutationInput, HashTagUncheckedUpdateManyInput>
    /**
     * Filter which HashTags to update
     */
    where?: HashTagWhereInput
  }


  /**
   * HashTag upsert
   */
  export type HashTagUpsertArgs = {
    /**
     * Select specific fields to fetch from the HashTag
     */
    select?: HashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HashTagInclude | null
    /**
     * The filter to search for the HashTag to update in case it exists.
     */
    where: HashTagWhereUniqueInput
    /**
     * In case the HashTag found by the `where` argument doesn't exist, create a new HashTag with this data.
     */
    create: XOR<HashTagCreateInput, HashTagUncheckedCreateInput>
    /**
     * In case the HashTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HashTagUpdateInput, HashTagUncheckedUpdateInput>
  }


  /**
   * HashTag delete
   */
  export type HashTagDeleteArgs = {
    /**
     * Select specific fields to fetch from the HashTag
     */
    select?: HashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HashTagInclude | null
    /**
     * Filter which HashTag to delete.
     */
    where: HashTagWhereUniqueInput
  }


  /**
   * HashTag deleteMany
   */
  export type HashTagDeleteManyArgs = {
    /**
     * Filter which HashTags to delete
     */
    where?: HashTagWhereInput
  }


  /**
   * HashTag.isInTweets
   */
  export type HashTag$isInTweetsArgs = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TweetInclude | null
    where?: TweetWhereInput
    orderBy?: Enumerable<TweetOrderByWithRelationInput>
    cursor?: TweetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TweetScalarFieldEnum>
  }


  /**
   * HashTag without action
   */
  export type HashTagArgs = {
    /**
     * Select specific fields to fetch from the HashTag
     */
    select?: HashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HashTagInclude | null
  }



  /**
   * Model DirectMessage
   */


  export type AggregateDirectMessage = {
    _count: DirectMessageCountAggregateOutputType | null
    _avg: DirectMessageAvgAggregateOutputType | null
    _sum: DirectMessageSumAggregateOutputType | null
    _min: DirectMessageMinAggregateOutputType | null
    _max: DirectMessageMaxAggregateOutputType | null
  }

  export type DirectMessageAvgAggregateOutputType = {
    id: number | null
    fromUserId: number | null
    toUserId: number | null
  }

  export type DirectMessageSumAggregateOutputType = {
    id: number | null
    fromUserId: number | null
    toUserId: number | null
  }

  export type DirectMessageMinAggregateOutputType = {
    id: number | null
    dmText: string | null
    fromUserId: number | null
    toUserId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DirectMessageMaxAggregateOutputType = {
    id: number | null
    dmText: string | null
    fromUserId: number | null
    toUserId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DirectMessageCountAggregateOutputType = {
    id: number
    dmText: number
    fromUserId: number
    toUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DirectMessageAvgAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
  }

  export type DirectMessageSumAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
  }

  export type DirectMessageMinAggregateInputType = {
    id?: true
    dmText?: true
    fromUserId?: true
    toUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DirectMessageMaxAggregateInputType = {
    id?: true
    dmText?: true
    fromUserId?: true
    toUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DirectMessageCountAggregateInputType = {
    id?: true
    dmText?: true
    fromUserId?: true
    toUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DirectMessageAggregateArgs = {
    /**
     * Filter which DirectMessage to aggregate.
     */
    where?: DirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DirectMessages to fetch.
     */
    orderBy?: Enumerable<DirectMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DirectMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DirectMessages
    **/
    _count?: true | DirectMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DirectMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DirectMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DirectMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DirectMessageMaxAggregateInputType
  }

  export type GetDirectMessageAggregateType<T extends DirectMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateDirectMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDirectMessage[P]>
      : GetScalarType<T[P], AggregateDirectMessage[P]>
  }




  export type DirectMessageGroupByArgs = {
    where?: DirectMessageWhereInput
    orderBy?: Enumerable<DirectMessageOrderByWithAggregationInput>
    by: DirectMessageScalarFieldEnum[]
    having?: DirectMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DirectMessageCountAggregateInputType | true
    _avg?: DirectMessageAvgAggregateInputType
    _sum?: DirectMessageSumAggregateInputType
    _min?: DirectMessageMinAggregateInputType
    _max?: DirectMessageMaxAggregateInputType
  }


  export type DirectMessageGroupByOutputType = {
    id: number
    dmText: string
    fromUserId: number
    toUserId: number
    createdAt: Date
    updatedAt: Date
    _count: DirectMessageCountAggregateOutputType | null
    _avg: DirectMessageAvgAggregateOutputType | null
    _sum: DirectMessageSumAggregateOutputType | null
    _min: DirectMessageMinAggregateOutputType | null
    _max: DirectMessageMaxAggregateOutputType | null
  }

  type GetDirectMessageGroupByPayload<T extends DirectMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DirectMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DirectMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DirectMessageGroupByOutputType[P]>
            : GetScalarType<T[P], DirectMessageGroupByOutputType[P]>
        }
      >
    >


  export type DirectMessageSelect = {
    id?: boolean
    dmText?: boolean
    fromUser?: boolean | UserArgs
    toUser?: boolean | UserArgs
    fromUserId?: boolean
    toUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type DirectMessageInclude = {
    fromUser?: boolean | UserArgs
    toUser?: boolean | UserArgs
  }

  export type DirectMessageGetPayload<S extends boolean | null | undefined | DirectMessageArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? DirectMessage :
    S extends undefined ? never :
    S extends { include: any } & (DirectMessageArgs | DirectMessageFindManyArgs)
    ? DirectMessage  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'fromUser' ? UserGetPayload<S['include'][P]> :
        P extends 'toUser' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (DirectMessageArgs | DirectMessageFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'fromUser' ? UserGetPayload<S['select'][P]> :
        P extends 'toUser' ? UserGetPayload<S['select'][P]> :  P extends keyof DirectMessage ? DirectMessage[P] : never
  } 
      : DirectMessage


  type DirectMessageCountArgs = 
    Omit<DirectMessageFindManyArgs, 'select' | 'include'> & {
      select?: DirectMessageCountAggregateInputType | true
    }

  export interface DirectMessageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one DirectMessage that matches the filter.
     * @param {DirectMessageFindUniqueArgs} args - Arguments to find a DirectMessage
     * @example
     * // Get one DirectMessage
     * const directMessage = await prisma.directMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DirectMessageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DirectMessageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DirectMessage'> extends True ? Prisma__DirectMessageClient<DirectMessageGetPayload<T>> : Prisma__DirectMessageClient<DirectMessageGetPayload<T> | null, null>

    /**
     * Find one DirectMessage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DirectMessageFindUniqueOrThrowArgs} args - Arguments to find a DirectMessage
     * @example
     * // Get one DirectMessage
     * const directMessage = await prisma.directMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DirectMessageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DirectMessageFindUniqueOrThrowArgs>
    ): Prisma__DirectMessageClient<DirectMessageGetPayload<T>>

    /**
     * Find the first DirectMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageFindFirstArgs} args - Arguments to find a DirectMessage
     * @example
     * // Get one DirectMessage
     * const directMessage = await prisma.directMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DirectMessageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DirectMessageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DirectMessage'> extends True ? Prisma__DirectMessageClient<DirectMessageGetPayload<T>> : Prisma__DirectMessageClient<DirectMessageGetPayload<T> | null, null>

    /**
     * Find the first DirectMessage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageFindFirstOrThrowArgs} args - Arguments to find a DirectMessage
     * @example
     * // Get one DirectMessage
     * const directMessage = await prisma.directMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DirectMessageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DirectMessageFindFirstOrThrowArgs>
    ): Prisma__DirectMessageClient<DirectMessageGetPayload<T>>

    /**
     * Find zero or more DirectMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DirectMessages
     * const directMessages = await prisma.directMessage.findMany()
     * 
     * // Get first 10 DirectMessages
     * const directMessages = await prisma.directMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const directMessageWithIdOnly = await prisma.directMessage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DirectMessageFindManyArgs>(
      args?: SelectSubset<T, DirectMessageFindManyArgs>
    ): Prisma.PrismaPromise<Array<DirectMessageGetPayload<T>>>

    /**
     * Create a DirectMessage.
     * @param {DirectMessageCreateArgs} args - Arguments to create a DirectMessage.
     * @example
     * // Create one DirectMessage
     * const DirectMessage = await prisma.directMessage.create({
     *   data: {
     *     // ... data to create a DirectMessage
     *   }
     * })
     * 
    **/
    create<T extends DirectMessageCreateArgs>(
      args: SelectSubset<T, DirectMessageCreateArgs>
    ): Prisma__DirectMessageClient<DirectMessageGetPayload<T>>

    /**
     * Create many DirectMessages.
     *     @param {DirectMessageCreateManyArgs} args - Arguments to create many DirectMessages.
     *     @example
     *     // Create many DirectMessages
     *     const directMessage = await prisma.directMessage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DirectMessageCreateManyArgs>(
      args?: SelectSubset<T, DirectMessageCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DirectMessage.
     * @param {DirectMessageDeleteArgs} args - Arguments to delete one DirectMessage.
     * @example
     * // Delete one DirectMessage
     * const DirectMessage = await prisma.directMessage.delete({
     *   where: {
     *     // ... filter to delete one DirectMessage
     *   }
     * })
     * 
    **/
    delete<T extends DirectMessageDeleteArgs>(
      args: SelectSubset<T, DirectMessageDeleteArgs>
    ): Prisma__DirectMessageClient<DirectMessageGetPayload<T>>

    /**
     * Update one DirectMessage.
     * @param {DirectMessageUpdateArgs} args - Arguments to update one DirectMessage.
     * @example
     * // Update one DirectMessage
     * const directMessage = await prisma.directMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DirectMessageUpdateArgs>(
      args: SelectSubset<T, DirectMessageUpdateArgs>
    ): Prisma__DirectMessageClient<DirectMessageGetPayload<T>>

    /**
     * Delete zero or more DirectMessages.
     * @param {DirectMessageDeleteManyArgs} args - Arguments to filter DirectMessages to delete.
     * @example
     * // Delete a few DirectMessages
     * const { count } = await prisma.directMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DirectMessageDeleteManyArgs>(
      args?: SelectSubset<T, DirectMessageDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DirectMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DirectMessages
     * const directMessage = await prisma.directMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DirectMessageUpdateManyArgs>(
      args: SelectSubset<T, DirectMessageUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DirectMessage.
     * @param {DirectMessageUpsertArgs} args - Arguments to update or create a DirectMessage.
     * @example
     * // Update or create a DirectMessage
     * const directMessage = await prisma.directMessage.upsert({
     *   create: {
     *     // ... data to create a DirectMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DirectMessage we want to update
     *   }
     * })
    **/
    upsert<T extends DirectMessageUpsertArgs>(
      args: SelectSubset<T, DirectMessageUpsertArgs>
    ): Prisma__DirectMessageClient<DirectMessageGetPayload<T>>

    /**
     * Count the number of DirectMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageCountArgs} args - Arguments to filter DirectMessages to count.
     * @example
     * // Count the number of DirectMessages
     * const count = await prisma.directMessage.count({
     *   where: {
     *     // ... the filter for the DirectMessages we want to count
     *   }
     * })
    **/
    count<T extends DirectMessageCountArgs>(
      args?: Subset<T, DirectMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DirectMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DirectMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DirectMessageAggregateArgs>(args: Subset<T, DirectMessageAggregateArgs>): Prisma.PrismaPromise<GetDirectMessageAggregateType<T>>

    /**
     * Group by DirectMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DirectMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DirectMessageGroupByArgs['orderBy'] }
        : { orderBy?: DirectMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DirectMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDirectMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for DirectMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DirectMessageClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    fromUser<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    toUser<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * DirectMessage base type for findUnique actions
   */
  export type DirectMessageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
    /**
     * Filter, which DirectMessage to fetch.
     */
    where: DirectMessageWhereUniqueInput
  }

  /**
   * DirectMessage findUnique
   */
  export interface DirectMessageFindUniqueArgs extends DirectMessageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DirectMessage findUniqueOrThrow
   */
  export type DirectMessageFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
    /**
     * Filter, which DirectMessage to fetch.
     */
    where: DirectMessageWhereUniqueInput
  }


  /**
   * DirectMessage base type for findFirst actions
   */
  export type DirectMessageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
    /**
     * Filter, which DirectMessage to fetch.
     */
    where?: DirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DirectMessages to fetch.
     */
    orderBy?: Enumerable<DirectMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DirectMessages.
     */
    cursor?: DirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DirectMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DirectMessages.
     */
    distinct?: Enumerable<DirectMessageScalarFieldEnum>
  }

  /**
   * DirectMessage findFirst
   */
  export interface DirectMessageFindFirstArgs extends DirectMessageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DirectMessage findFirstOrThrow
   */
  export type DirectMessageFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
    /**
     * Filter, which DirectMessage to fetch.
     */
    where?: DirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DirectMessages to fetch.
     */
    orderBy?: Enumerable<DirectMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DirectMessages.
     */
    cursor?: DirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DirectMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DirectMessages.
     */
    distinct?: Enumerable<DirectMessageScalarFieldEnum>
  }


  /**
   * DirectMessage findMany
   */
  export type DirectMessageFindManyArgs = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
    /**
     * Filter, which DirectMessages to fetch.
     */
    where?: DirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DirectMessages to fetch.
     */
    orderBy?: Enumerable<DirectMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DirectMessages.
     */
    cursor?: DirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DirectMessages.
     */
    skip?: number
    distinct?: Enumerable<DirectMessageScalarFieldEnum>
  }


  /**
   * DirectMessage create
   */
  export type DirectMessageCreateArgs = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
    /**
     * The data needed to create a DirectMessage.
     */
    data: XOR<DirectMessageCreateInput, DirectMessageUncheckedCreateInput>
  }


  /**
   * DirectMessage createMany
   */
  export type DirectMessageCreateManyArgs = {
    /**
     * The data used to create many DirectMessages.
     */
    data: Enumerable<DirectMessageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DirectMessage update
   */
  export type DirectMessageUpdateArgs = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
    /**
     * The data needed to update a DirectMessage.
     */
    data: XOR<DirectMessageUpdateInput, DirectMessageUncheckedUpdateInput>
    /**
     * Choose, which DirectMessage to update.
     */
    where: DirectMessageWhereUniqueInput
  }


  /**
   * DirectMessage updateMany
   */
  export type DirectMessageUpdateManyArgs = {
    /**
     * The data used to update DirectMessages.
     */
    data: XOR<DirectMessageUpdateManyMutationInput, DirectMessageUncheckedUpdateManyInput>
    /**
     * Filter which DirectMessages to update
     */
    where?: DirectMessageWhereInput
  }


  /**
   * DirectMessage upsert
   */
  export type DirectMessageUpsertArgs = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
    /**
     * The filter to search for the DirectMessage to update in case it exists.
     */
    where: DirectMessageWhereUniqueInput
    /**
     * In case the DirectMessage found by the `where` argument doesn't exist, create a new DirectMessage with this data.
     */
    create: XOR<DirectMessageCreateInput, DirectMessageUncheckedCreateInput>
    /**
     * In case the DirectMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DirectMessageUpdateInput, DirectMessageUncheckedUpdateInput>
  }


  /**
   * DirectMessage delete
   */
  export type DirectMessageDeleteArgs = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
    /**
     * Filter which DirectMessage to delete.
     */
    where: DirectMessageWhereUniqueInput
  }


  /**
   * DirectMessage deleteMany
   */
  export type DirectMessageDeleteManyArgs = {
    /**
     * Filter which DirectMessages to delete
     */
    where?: DirectMessageWhereInput
  }


  /**
   * DirectMessage without action
   */
  export type DirectMessageArgs = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
  }



  /**
   * Model YouTubeUser
   */


  export type AggregateYouTubeUser = {
    _count: YouTubeUserCountAggregateOutputType | null
    _avg: YouTubeUserAvgAggregateOutputType | null
    _sum: YouTubeUserSumAggregateOutputType | null
    _min: YouTubeUserMinAggregateOutputType | null
    _max: YouTubeUserMaxAggregateOutputType | null
  }

  export type YouTubeUserAvgAggregateOutputType = {
    id: number | null
  }

  export type YouTubeUserSumAggregateOutputType = {
    id: number | null
  }

  export type YouTubeUserMinAggregateOutputType = {
    id: number | null
    name: string | null
    profileImageUrl: string | null
    bio: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type YouTubeUserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    profileImageUrl: string | null
    bio: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type YouTubeUserCountAggregateOutputType = {
    id: number
    name: number
    profileImageUrl: number
    bio: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type YouTubeUserAvgAggregateInputType = {
    id?: true
  }

  export type YouTubeUserSumAggregateInputType = {
    id?: true
  }

  export type YouTubeUserMinAggregateInputType = {
    id?: true
    name?: true
    profileImageUrl?: true
    bio?: true
    createdAt?: true
    updatedAt?: true
  }

  export type YouTubeUserMaxAggregateInputType = {
    id?: true
    name?: true
    profileImageUrl?: true
    bio?: true
    createdAt?: true
    updatedAt?: true
  }

  export type YouTubeUserCountAggregateInputType = {
    id?: true
    name?: true
    profileImageUrl?: true
    bio?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type YouTubeUserAggregateArgs = {
    /**
     * Filter which YouTubeUser to aggregate.
     */
    where?: YouTubeUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YouTubeUsers to fetch.
     */
    orderBy?: Enumerable<YouTubeUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YouTubeUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YouTubeUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YouTubeUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YouTubeUsers
    **/
    _count?: true | YouTubeUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YouTubeUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YouTubeUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YouTubeUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YouTubeUserMaxAggregateInputType
  }

  export type GetYouTubeUserAggregateType<T extends YouTubeUserAggregateArgs> = {
        [P in keyof T & keyof AggregateYouTubeUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYouTubeUser[P]>
      : GetScalarType<T[P], AggregateYouTubeUser[P]>
  }




  export type YouTubeUserGroupByArgs = {
    where?: YouTubeUserWhereInput
    orderBy?: Enumerable<YouTubeUserOrderByWithAggregationInput>
    by: YouTubeUserScalarFieldEnum[]
    having?: YouTubeUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YouTubeUserCountAggregateInputType | true
    _avg?: YouTubeUserAvgAggregateInputType
    _sum?: YouTubeUserSumAggregateInputType
    _min?: YouTubeUserMinAggregateInputType
    _max?: YouTubeUserMaxAggregateInputType
  }


  export type YouTubeUserGroupByOutputType = {
    id: number
    name: string
    profileImageUrl: string | null
    bio: string | null
    createdAt: Date
    updatedAt: Date
    _count: YouTubeUserCountAggregateOutputType | null
    _avg: YouTubeUserAvgAggregateOutputType | null
    _sum: YouTubeUserSumAggregateOutputType | null
    _min: YouTubeUserMinAggregateOutputType | null
    _max: YouTubeUserMaxAggregateOutputType | null
  }

  type GetYouTubeUserGroupByPayload<T extends YouTubeUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<YouTubeUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YouTubeUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YouTubeUserGroupByOutputType[P]>
            : GetScalarType<T[P], YouTubeUserGroupByOutputType[P]>
        }
      >
    >


  export type YouTubeUserSelect = {
    id?: boolean
    name?: boolean
    profileImageUrl?: boolean
    bio?: boolean
    adminOfChannels?: boolean | YouTubeUser$adminOfChannelsArgs
    usersToChannelswithRoles?: boolean | YouTubeUser$usersToChannelswithRolesArgs
    subscribingToChannels?: boolean | YouTubeUser$subscribingToChannelsArgs
    reactedVideos?: boolean | YouTubeUser$reactedVideosArgs
    usersToVideosWithReactions?: boolean | YouTubeUser$usersToVideosWithReactionsArgs
    videoComments?: boolean | YouTubeUser$videoCommentsArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | YouTubeUserCountOutputTypeArgs
  }


  export type YouTubeUserInclude = {
    adminOfChannels?: boolean | YouTubeUser$adminOfChannelsArgs
    usersToChannelswithRoles?: boolean | YouTubeUser$usersToChannelswithRolesArgs
    subscribingToChannels?: boolean | YouTubeUser$subscribingToChannelsArgs
    reactedVideos?: boolean | YouTubeUser$reactedVideosArgs
    usersToVideosWithReactions?: boolean | YouTubeUser$usersToVideosWithReactionsArgs
    videoComments?: boolean | YouTubeUser$videoCommentsArgs
    _count?: boolean | YouTubeUserCountOutputTypeArgs
  }

  export type YouTubeUserGetPayload<S extends boolean | null | undefined | YouTubeUserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YouTubeUser :
    S extends undefined ? never :
    S extends { include: any } & (YouTubeUserArgs | YouTubeUserFindManyArgs)
    ? YouTubeUser  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'adminOfChannels' ? Array < ChannelGetPayload<S['include'][P]>>  :
        P extends 'usersToChannelswithRoles' ? Array < UserToChannelwithRoleGetPayload<S['include'][P]>>  :
        P extends 'subscribingToChannels' ? Array < ChannelGetPayload<S['include'][P]>>  :
        P extends 'reactedVideos' ? Array < VideoGetPayload<S['include'][P]>>  :
        P extends 'usersToVideosWithReactions' ? Array < UserToVideoWithReactionGetPayload<S['include'][P]>>  :
        P extends 'videoComments' ? Array < VideoCommentGetPayload<S['include'][P]>>  :
        P extends '_count' ? YouTubeUserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (YouTubeUserArgs | YouTubeUserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'adminOfChannels' ? Array < ChannelGetPayload<S['select'][P]>>  :
        P extends 'usersToChannelswithRoles' ? Array < UserToChannelwithRoleGetPayload<S['select'][P]>>  :
        P extends 'subscribingToChannels' ? Array < ChannelGetPayload<S['select'][P]>>  :
        P extends 'reactedVideos' ? Array < VideoGetPayload<S['select'][P]>>  :
        P extends 'usersToVideosWithReactions' ? Array < UserToVideoWithReactionGetPayload<S['select'][P]>>  :
        P extends 'videoComments' ? Array < VideoCommentGetPayload<S['select'][P]>>  :
        P extends '_count' ? YouTubeUserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof YouTubeUser ? YouTubeUser[P] : never
  } 
      : YouTubeUser


  type YouTubeUserCountArgs = 
    Omit<YouTubeUserFindManyArgs, 'select' | 'include'> & {
      select?: YouTubeUserCountAggregateInputType | true
    }

  export interface YouTubeUserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one YouTubeUser that matches the filter.
     * @param {YouTubeUserFindUniqueArgs} args - Arguments to find a YouTubeUser
     * @example
     * // Get one YouTubeUser
     * const youTubeUser = await prisma.youTubeUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends YouTubeUserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, YouTubeUserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'YouTubeUser'> extends True ? Prisma__YouTubeUserClient<YouTubeUserGetPayload<T>> : Prisma__YouTubeUserClient<YouTubeUserGetPayload<T> | null, null>

    /**
     * Find one YouTubeUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {YouTubeUserFindUniqueOrThrowArgs} args - Arguments to find a YouTubeUser
     * @example
     * // Get one YouTubeUser
     * const youTubeUser = await prisma.youTubeUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends YouTubeUserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, YouTubeUserFindUniqueOrThrowArgs>
    ): Prisma__YouTubeUserClient<YouTubeUserGetPayload<T>>

    /**
     * Find the first YouTubeUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YouTubeUserFindFirstArgs} args - Arguments to find a YouTubeUser
     * @example
     * // Get one YouTubeUser
     * const youTubeUser = await prisma.youTubeUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends YouTubeUserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, YouTubeUserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'YouTubeUser'> extends True ? Prisma__YouTubeUserClient<YouTubeUserGetPayload<T>> : Prisma__YouTubeUserClient<YouTubeUserGetPayload<T> | null, null>

    /**
     * Find the first YouTubeUser that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YouTubeUserFindFirstOrThrowArgs} args - Arguments to find a YouTubeUser
     * @example
     * // Get one YouTubeUser
     * const youTubeUser = await prisma.youTubeUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends YouTubeUserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, YouTubeUserFindFirstOrThrowArgs>
    ): Prisma__YouTubeUserClient<YouTubeUserGetPayload<T>>

    /**
     * Find zero or more YouTubeUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YouTubeUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YouTubeUsers
     * const youTubeUsers = await prisma.youTubeUser.findMany()
     * 
     * // Get first 10 YouTubeUsers
     * const youTubeUsers = await prisma.youTubeUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const youTubeUserWithIdOnly = await prisma.youTubeUser.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends YouTubeUserFindManyArgs>(
      args?: SelectSubset<T, YouTubeUserFindManyArgs>
    ): Prisma.PrismaPromise<Array<YouTubeUserGetPayload<T>>>

    /**
     * Create a YouTubeUser.
     * @param {YouTubeUserCreateArgs} args - Arguments to create a YouTubeUser.
     * @example
     * // Create one YouTubeUser
     * const YouTubeUser = await prisma.youTubeUser.create({
     *   data: {
     *     // ... data to create a YouTubeUser
     *   }
     * })
     * 
    **/
    create<T extends YouTubeUserCreateArgs>(
      args: SelectSubset<T, YouTubeUserCreateArgs>
    ): Prisma__YouTubeUserClient<YouTubeUserGetPayload<T>>

    /**
     * Create many YouTubeUsers.
     *     @param {YouTubeUserCreateManyArgs} args - Arguments to create many YouTubeUsers.
     *     @example
     *     // Create many YouTubeUsers
     *     const youTubeUser = await prisma.youTubeUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends YouTubeUserCreateManyArgs>(
      args?: SelectSubset<T, YouTubeUserCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a YouTubeUser.
     * @param {YouTubeUserDeleteArgs} args - Arguments to delete one YouTubeUser.
     * @example
     * // Delete one YouTubeUser
     * const YouTubeUser = await prisma.youTubeUser.delete({
     *   where: {
     *     // ... filter to delete one YouTubeUser
     *   }
     * })
     * 
    **/
    delete<T extends YouTubeUserDeleteArgs>(
      args: SelectSubset<T, YouTubeUserDeleteArgs>
    ): Prisma__YouTubeUserClient<YouTubeUserGetPayload<T>>

    /**
     * Update one YouTubeUser.
     * @param {YouTubeUserUpdateArgs} args - Arguments to update one YouTubeUser.
     * @example
     * // Update one YouTubeUser
     * const youTubeUser = await prisma.youTubeUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends YouTubeUserUpdateArgs>(
      args: SelectSubset<T, YouTubeUserUpdateArgs>
    ): Prisma__YouTubeUserClient<YouTubeUserGetPayload<T>>

    /**
     * Delete zero or more YouTubeUsers.
     * @param {YouTubeUserDeleteManyArgs} args - Arguments to filter YouTubeUsers to delete.
     * @example
     * // Delete a few YouTubeUsers
     * const { count } = await prisma.youTubeUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends YouTubeUserDeleteManyArgs>(
      args?: SelectSubset<T, YouTubeUserDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YouTubeUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YouTubeUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YouTubeUsers
     * const youTubeUser = await prisma.youTubeUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends YouTubeUserUpdateManyArgs>(
      args: SelectSubset<T, YouTubeUserUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one YouTubeUser.
     * @param {YouTubeUserUpsertArgs} args - Arguments to update or create a YouTubeUser.
     * @example
     * // Update or create a YouTubeUser
     * const youTubeUser = await prisma.youTubeUser.upsert({
     *   create: {
     *     // ... data to create a YouTubeUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YouTubeUser we want to update
     *   }
     * })
    **/
    upsert<T extends YouTubeUserUpsertArgs>(
      args: SelectSubset<T, YouTubeUserUpsertArgs>
    ): Prisma__YouTubeUserClient<YouTubeUserGetPayload<T>>

    /**
     * Count the number of YouTubeUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YouTubeUserCountArgs} args - Arguments to filter YouTubeUsers to count.
     * @example
     * // Count the number of YouTubeUsers
     * const count = await prisma.youTubeUser.count({
     *   where: {
     *     // ... the filter for the YouTubeUsers we want to count
     *   }
     * })
    **/
    count<T extends YouTubeUserCountArgs>(
      args?: Subset<T, YouTubeUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YouTubeUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YouTubeUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YouTubeUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YouTubeUserAggregateArgs>(args: Subset<T, YouTubeUserAggregateArgs>): Prisma.PrismaPromise<GetYouTubeUserAggregateType<T>>

    /**
     * Group by YouTubeUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YouTubeUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YouTubeUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YouTubeUserGroupByArgs['orderBy'] }
        : { orderBy?: YouTubeUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YouTubeUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYouTubeUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for YouTubeUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__YouTubeUserClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    adminOfChannels<T extends YouTubeUser$adminOfChannelsArgs= {}>(args?: Subset<T, YouTubeUser$adminOfChannelsArgs>): Prisma.PrismaPromise<Array<ChannelGetPayload<T>>| Null>;

    usersToChannelswithRoles<T extends YouTubeUser$usersToChannelswithRolesArgs= {}>(args?: Subset<T, YouTubeUser$usersToChannelswithRolesArgs>): Prisma.PrismaPromise<Array<UserToChannelwithRoleGetPayload<T>>| Null>;

    subscribingToChannels<T extends YouTubeUser$subscribingToChannelsArgs= {}>(args?: Subset<T, YouTubeUser$subscribingToChannelsArgs>): Prisma.PrismaPromise<Array<ChannelGetPayload<T>>| Null>;

    reactedVideos<T extends YouTubeUser$reactedVideosArgs= {}>(args?: Subset<T, YouTubeUser$reactedVideosArgs>): Prisma.PrismaPromise<Array<VideoGetPayload<T>>| Null>;

    usersToVideosWithReactions<T extends YouTubeUser$usersToVideosWithReactionsArgs= {}>(args?: Subset<T, YouTubeUser$usersToVideosWithReactionsArgs>): Prisma.PrismaPromise<Array<UserToVideoWithReactionGetPayload<T>>| Null>;

    videoComments<T extends YouTubeUser$videoCommentsArgs= {}>(args?: Subset<T, YouTubeUser$videoCommentsArgs>): Prisma.PrismaPromise<Array<VideoCommentGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * YouTubeUser base type for findUnique actions
   */
  export type YouTubeUserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the YouTubeUser
     */
    select?: YouTubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YouTubeUserInclude | null
    /**
     * Filter, which YouTubeUser to fetch.
     */
    where: YouTubeUserWhereUniqueInput
  }

  /**
   * YouTubeUser findUnique
   */
  export interface YouTubeUserFindUniqueArgs extends YouTubeUserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YouTubeUser findUniqueOrThrow
   */
  export type YouTubeUserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YouTubeUser
     */
    select?: YouTubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YouTubeUserInclude | null
    /**
     * Filter, which YouTubeUser to fetch.
     */
    where: YouTubeUserWhereUniqueInput
  }


  /**
   * YouTubeUser base type for findFirst actions
   */
  export type YouTubeUserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the YouTubeUser
     */
    select?: YouTubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YouTubeUserInclude | null
    /**
     * Filter, which YouTubeUser to fetch.
     */
    where?: YouTubeUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YouTubeUsers to fetch.
     */
    orderBy?: Enumerable<YouTubeUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YouTubeUsers.
     */
    cursor?: YouTubeUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YouTubeUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YouTubeUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YouTubeUsers.
     */
    distinct?: Enumerable<YouTubeUserScalarFieldEnum>
  }

  /**
   * YouTubeUser findFirst
   */
  export interface YouTubeUserFindFirstArgs extends YouTubeUserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YouTubeUser findFirstOrThrow
   */
  export type YouTubeUserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YouTubeUser
     */
    select?: YouTubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YouTubeUserInclude | null
    /**
     * Filter, which YouTubeUser to fetch.
     */
    where?: YouTubeUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YouTubeUsers to fetch.
     */
    orderBy?: Enumerable<YouTubeUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YouTubeUsers.
     */
    cursor?: YouTubeUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YouTubeUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YouTubeUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YouTubeUsers.
     */
    distinct?: Enumerable<YouTubeUserScalarFieldEnum>
  }


  /**
   * YouTubeUser findMany
   */
  export type YouTubeUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the YouTubeUser
     */
    select?: YouTubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YouTubeUserInclude | null
    /**
     * Filter, which YouTubeUsers to fetch.
     */
    where?: YouTubeUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YouTubeUsers to fetch.
     */
    orderBy?: Enumerable<YouTubeUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YouTubeUsers.
     */
    cursor?: YouTubeUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YouTubeUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YouTubeUsers.
     */
    skip?: number
    distinct?: Enumerable<YouTubeUserScalarFieldEnum>
  }


  /**
   * YouTubeUser create
   */
  export type YouTubeUserCreateArgs = {
    /**
     * Select specific fields to fetch from the YouTubeUser
     */
    select?: YouTubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YouTubeUserInclude | null
    /**
     * The data needed to create a YouTubeUser.
     */
    data: XOR<YouTubeUserCreateInput, YouTubeUserUncheckedCreateInput>
  }


  /**
   * YouTubeUser createMany
   */
  export type YouTubeUserCreateManyArgs = {
    /**
     * The data used to create many YouTubeUsers.
     */
    data: Enumerable<YouTubeUserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * YouTubeUser update
   */
  export type YouTubeUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the YouTubeUser
     */
    select?: YouTubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YouTubeUserInclude | null
    /**
     * The data needed to update a YouTubeUser.
     */
    data: XOR<YouTubeUserUpdateInput, YouTubeUserUncheckedUpdateInput>
    /**
     * Choose, which YouTubeUser to update.
     */
    where: YouTubeUserWhereUniqueInput
  }


  /**
   * YouTubeUser updateMany
   */
  export type YouTubeUserUpdateManyArgs = {
    /**
     * The data used to update YouTubeUsers.
     */
    data: XOR<YouTubeUserUpdateManyMutationInput, YouTubeUserUncheckedUpdateManyInput>
    /**
     * Filter which YouTubeUsers to update
     */
    where?: YouTubeUserWhereInput
  }


  /**
   * YouTubeUser upsert
   */
  export type YouTubeUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the YouTubeUser
     */
    select?: YouTubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YouTubeUserInclude | null
    /**
     * The filter to search for the YouTubeUser to update in case it exists.
     */
    where: YouTubeUserWhereUniqueInput
    /**
     * In case the YouTubeUser found by the `where` argument doesn't exist, create a new YouTubeUser with this data.
     */
    create: XOR<YouTubeUserCreateInput, YouTubeUserUncheckedCreateInput>
    /**
     * In case the YouTubeUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YouTubeUserUpdateInput, YouTubeUserUncheckedUpdateInput>
  }


  /**
   * YouTubeUser delete
   */
  export type YouTubeUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the YouTubeUser
     */
    select?: YouTubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YouTubeUserInclude | null
    /**
     * Filter which YouTubeUser to delete.
     */
    where: YouTubeUserWhereUniqueInput
  }


  /**
   * YouTubeUser deleteMany
   */
  export type YouTubeUserDeleteManyArgs = {
    /**
     * Filter which YouTubeUsers to delete
     */
    where?: YouTubeUserWhereInput
  }


  /**
   * YouTubeUser.adminOfChannels
   */
  export type YouTubeUser$adminOfChannelsArgs = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChannelInclude | null
    where?: ChannelWhereInput
    orderBy?: Enumerable<ChannelOrderByWithRelationInput>
    cursor?: ChannelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ChannelScalarFieldEnum>
  }


  /**
   * YouTubeUser.usersToChannelswithRoles
   */
  export type YouTubeUser$usersToChannelswithRolesArgs = {
    /**
     * Select specific fields to fetch from the UserToChannelwithRole
     */
    select?: UserToChannelwithRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToChannelwithRoleInclude | null
    where?: UserToChannelwithRoleWhereInput
    orderBy?: Enumerable<UserToChannelwithRoleOrderByWithRelationInput>
    cursor?: UserToChannelwithRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserToChannelwithRoleScalarFieldEnum>
  }


  /**
   * YouTubeUser.subscribingToChannels
   */
  export type YouTubeUser$subscribingToChannelsArgs = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChannelInclude | null
    where?: ChannelWhereInput
    orderBy?: Enumerable<ChannelOrderByWithRelationInput>
    cursor?: ChannelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ChannelScalarFieldEnum>
  }


  /**
   * YouTubeUser.reactedVideos
   */
  export type YouTubeUser$reactedVideosArgs = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude | null
    where?: VideoWhereInput
    orderBy?: Enumerable<VideoOrderByWithRelationInput>
    cursor?: VideoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<VideoScalarFieldEnum>
  }


  /**
   * YouTubeUser.usersToVideosWithReactions
   */
  export type YouTubeUser$usersToVideosWithReactionsArgs = {
    /**
     * Select specific fields to fetch from the UserToVideoWithReaction
     */
    select?: UserToVideoWithReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToVideoWithReactionInclude | null
    where?: UserToVideoWithReactionWhereInput
    orderBy?: Enumerable<UserToVideoWithReactionOrderByWithRelationInput>
    cursor?: UserToVideoWithReactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserToVideoWithReactionScalarFieldEnum>
  }


  /**
   * YouTubeUser.videoComments
   */
  export type YouTubeUser$videoCommentsArgs = {
    /**
     * Select specific fields to fetch from the VideoComment
     */
    select?: VideoCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoCommentInclude | null
    where?: VideoCommentWhereInput
    orderBy?: Enumerable<VideoCommentOrderByWithRelationInput>
    cursor?: VideoCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<VideoCommentScalarFieldEnum>
  }


  /**
   * YouTubeUser without action
   */
  export type YouTubeUserArgs = {
    /**
     * Select specific fields to fetch from the YouTubeUser
     */
    select?: YouTubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YouTubeUserInclude | null
  }



  /**
   * Model Channel
   */


  export type AggregateChannel = {
    _count: ChannelCountAggregateOutputType | null
    _avg: ChannelAvgAggregateOutputType | null
    _sum: ChannelSumAggregateOutputType | null
    _min: ChannelMinAggregateOutputType | null
    _max: ChannelMaxAggregateOutputType | null
  }

  export type ChannelAvgAggregateOutputType = {
    id: number | null
  }

  export type ChannelSumAggregateOutputType = {
    id: number | null
  }

  export type ChannelMinAggregateOutputType = {
    id: number | null
    name: string | null
    profileImageUrl: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChannelMaxAggregateOutputType = {
    id: number | null
    name: string | null
    profileImageUrl: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChannelCountAggregateOutputType = {
    id: number
    name: number
    profileImageUrl: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChannelAvgAggregateInputType = {
    id?: true
  }

  export type ChannelSumAggregateInputType = {
    id?: true
  }

  export type ChannelMinAggregateInputType = {
    id?: true
    name?: true
    profileImageUrl?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChannelMaxAggregateInputType = {
    id?: true
    name?: true
    profileImageUrl?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChannelCountAggregateInputType = {
    id?: true
    name?: true
    profileImageUrl?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChannelAggregateArgs = {
    /**
     * Filter which Channel to aggregate.
     */
    where?: ChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Channels to fetch.
     */
    orderBy?: Enumerable<ChannelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Channels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Channels
    **/
    _count?: true | ChannelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChannelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChannelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChannelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChannelMaxAggregateInputType
  }

  export type GetChannelAggregateType<T extends ChannelAggregateArgs> = {
        [P in keyof T & keyof AggregateChannel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChannel[P]>
      : GetScalarType<T[P], AggregateChannel[P]>
  }




  export type ChannelGroupByArgs = {
    where?: ChannelWhereInput
    orderBy?: Enumerable<ChannelOrderByWithAggregationInput>
    by: ChannelScalarFieldEnum[]
    having?: ChannelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChannelCountAggregateInputType | true
    _avg?: ChannelAvgAggregateInputType
    _sum?: ChannelSumAggregateInputType
    _min?: ChannelMinAggregateInputType
    _max?: ChannelMaxAggregateInputType
  }


  export type ChannelGroupByOutputType = {
    id: number
    name: string
    profileImageUrl: string | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: ChannelCountAggregateOutputType | null
    _avg: ChannelAvgAggregateOutputType | null
    _sum: ChannelSumAggregateOutputType | null
    _min: ChannelMinAggregateOutputType | null
    _max: ChannelMaxAggregateOutputType | null
  }

  type GetChannelGroupByPayload<T extends ChannelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ChannelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChannelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChannelGroupByOutputType[P]>
            : GetScalarType<T[P], ChannelGroupByOutputType[P]>
        }
      >
    >


  export type ChannelSelect = {
    id?: boolean
    name?: boolean
    profileImageUrl?: boolean
    description?: boolean
    adminUsers?: boolean | Channel$adminUsersArgs
    subscribedUsers?: boolean | Channel$subscribedUsersArgs
    usersToChannelswithRoles?: boolean | Channel$usersToChannelswithRolesArgs
    owningVideos?: boolean | Channel$owningVideosArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | ChannelCountOutputTypeArgs
  }


  export type ChannelInclude = {
    adminUsers?: boolean | Channel$adminUsersArgs
    subscribedUsers?: boolean | Channel$subscribedUsersArgs
    usersToChannelswithRoles?: boolean | Channel$usersToChannelswithRolesArgs
    owningVideos?: boolean | Channel$owningVideosArgs
    _count?: boolean | ChannelCountOutputTypeArgs
  }

  export type ChannelGetPayload<S extends boolean | null | undefined | ChannelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Channel :
    S extends undefined ? never :
    S extends { include: any } & (ChannelArgs | ChannelFindManyArgs)
    ? Channel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'adminUsers' ? Array < YouTubeUserGetPayload<S['include'][P]>>  :
        P extends 'subscribedUsers' ? Array < YouTubeUserGetPayload<S['include'][P]>>  :
        P extends 'usersToChannelswithRoles' ? Array < UserToChannelwithRoleGetPayload<S['include'][P]>>  :
        P extends 'owningVideos' ? Array < VideoGetPayload<S['include'][P]>>  :
        P extends '_count' ? ChannelCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ChannelArgs | ChannelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'adminUsers' ? Array < YouTubeUserGetPayload<S['select'][P]>>  :
        P extends 'subscribedUsers' ? Array < YouTubeUserGetPayload<S['select'][P]>>  :
        P extends 'usersToChannelswithRoles' ? Array < UserToChannelwithRoleGetPayload<S['select'][P]>>  :
        P extends 'owningVideos' ? Array < VideoGetPayload<S['select'][P]>>  :
        P extends '_count' ? ChannelCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Channel ? Channel[P] : never
  } 
      : Channel


  type ChannelCountArgs = 
    Omit<ChannelFindManyArgs, 'select' | 'include'> & {
      select?: ChannelCountAggregateInputType | true
    }

  export interface ChannelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Channel that matches the filter.
     * @param {ChannelFindUniqueArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ChannelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ChannelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Channel'> extends True ? Prisma__ChannelClient<ChannelGetPayload<T>> : Prisma__ChannelClient<ChannelGetPayload<T> | null, null>

    /**
     * Find one Channel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ChannelFindUniqueOrThrowArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ChannelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ChannelFindUniqueOrThrowArgs>
    ): Prisma__ChannelClient<ChannelGetPayload<T>>

    /**
     * Find the first Channel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelFindFirstArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ChannelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ChannelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Channel'> extends True ? Prisma__ChannelClient<ChannelGetPayload<T>> : Prisma__ChannelClient<ChannelGetPayload<T> | null, null>

    /**
     * Find the first Channel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelFindFirstOrThrowArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ChannelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ChannelFindFirstOrThrowArgs>
    ): Prisma__ChannelClient<ChannelGetPayload<T>>

    /**
     * Find zero or more Channels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Channels
     * const channels = await prisma.channel.findMany()
     * 
     * // Get first 10 Channels
     * const channels = await prisma.channel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const channelWithIdOnly = await prisma.channel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ChannelFindManyArgs>(
      args?: SelectSubset<T, ChannelFindManyArgs>
    ): Prisma.PrismaPromise<Array<ChannelGetPayload<T>>>

    /**
     * Create a Channel.
     * @param {ChannelCreateArgs} args - Arguments to create a Channel.
     * @example
     * // Create one Channel
     * const Channel = await prisma.channel.create({
     *   data: {
     *     // ... data to create a Channel
     *   }
     * })
     * 
    **/
    create<T extends ChannelCreateArgs>(
      args: SelectSubset<T, ChannelCreateArgs>
    ): Prisma__ChannelClient<ChannelGetPayload<T>>

    /**
     * Create many Channels.
     *     @param {ChannelCreateManyArgs} args - Arguments to create many Channels.
     *     @example
     *     // Create many Channels
     *     const channel = await prisma.channel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ChannelCreateManyArgs>(
      args?: SelectSubset<T, ChannelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Channel.
     * @param {ChannelDeleteArgs} args - Arguments to delete one Channel.
     * @example
     * // Delete one Channel
     * const Channel = await prisma.channel.delete({
     *   where: {
     *     // ... filter to delete one Channel
     *   }
     * })
     * 
    **/
    delete<T extends ChannelDeleteArgs>(
      args: SelectSubset<T, ChannelDeleteArgs>
    ): Prisma__ChannelClient<ChannelGetPayload<T>>

    /**
     * Update one Channel.
     * @param {ChannelUpdateArgs} args - Arguments to update one Channel.
     * @example
     * // Update one Channel
     * const channel = await prisma.channel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ChannelUpdateArgs>(
      args: SelectSubset<T, ChannelUpdateArgs>
    ): Prisma__ChannelClient<ChannelGetPayload<T>>

    /**
     * Delete zero or more Channels.
     * @param {ChannelDeleteManyArgs} args - Arguments to filter Channels to delete.
     * @example
     * // Delete a few Channels
     * const { count } = await prisma.channel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ChannelDeleteManyArgs>(
      args?: SelectSubset<T, ChannelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Channels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Channels
     * const channel = await prisma.channel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ChannelUpdateManyArgs>(
      args: SelectSubset<T, ChannelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Channel.
     * @param {ChannelUpsertArgs} args - Arguments to update or create a Channel.
     * @example
     * // Update or create a Channel
     * const channel = await prisma.channel.upsert({
     *   create: {
     *     // ... data to create a Channel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Channel we want to update
     *   }
     * })
    **/
    upsert<T extends ChannelUpsertArgs>(
      args: SelectSubset<T, ChannelUpsertArgs>
    ): Prisma__ChannelClient<ChannelGetPayload<T>>

    /**
     * Count the number of Channels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelCountArgs} args - Arguments to filter Channels to count.
     * @example
     * // Count the number of Channels
     * const count = await prisma.channel.count({
     *   where: {
     *     // ... the filter for the Channels we want to count
     *   }
     * })
    **/
    count<T extends ChannelCountArgs>(
      args?: Subset<T, ChannelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChannelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Channel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChannelAggregateArgs>(args: Subset<T, ChannelAggregateArgs>): Prisma.PrismaPromise<GetChannelAggregateType<T>>

    /**
     * Group by Channel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChannelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChannelGroupByArgs['orderBy'] }
        : { orderBy?: ChannelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChannelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChannelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Channel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ChannelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    adminUsers<T extends Channel$adminUsersArgs= {}>(args?: Subset<T, Channel$adminUsersArgs>): Prisma.PrismaPromise<Array<YouTubeUserGetPayload<T>>| Null>;

    subscribedUsers<T extends Channel$subscribedUsersArgs= {}>(args?: Subset<T, Channel$subscribedUsersArgs>): Prisma.PrismaPromise<Array<YouTubeUserGetPayload<T>>| Null>;

    usersToChannelswithRoles<T extends Channel$usersToChannelswithRolesArgs= {}>(args?: Subset<T, Channel$usersToChannelswithRolesArgs>): Prisma.PrismaPromise<Array<UserToChannelwithRoleGetPayload<T>>| Null>;

    owningVideos<T extends Channel$owningVideosArgs= {}>(args?: Subset<T, Channel$owningVideosArgs>): Prisma.PrismaPromise<Array<VideoGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Channel base type for findUnique actions
   */
  export type ChannelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChannelInclude | null
    /**
     * Filter, which Channel to fetch.
     */
    where: ChannelWhereUniqueInput
  }

  /**
   * Channel findUnique
   */
  export interface ChannelFindUniqueArgs extends ChannelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Channel findUniqueOrThrow
   */
  export type ChannelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChannelInclude | null
    /**
     * Filter, which Channel to fetch.
     */
    where: ChannelWhereUniqueInput
  }


  /**
   * Channel base type for findFirst actions
   */
  export type ChannelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChannelInclude | null
    /**
     * Filter, which Channel to fetch.
     */
    where?: ChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Channels to fetch.
     */
    orderBy?: Enumerable<ChannelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Channels.
     */
    cursor?: ChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Channels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Channels.
     */
    distinct?: Enumerable<ChannelScalarFieldEnum>
  }

  /**
   * Channel findFirst
   */
  export interface ChannelFindFirstArgs extends ChannelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Channel findFirstOrThrow
   */
  export type ChannelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChannelInclude | null
    /**
     * Filter, which Channel to fetch.
     */
    where?: ChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Channels to fetch.
     */
    orderBy?: Enumerable<ChannelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Channels.
     */
    cursor?: ChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Channels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Channels.
     */
    distinct?: Enumerable<ChannelScalarFieldEnum>
  }


  /**
   * Channel findMany
   */
  export type ChannelFindManyArgs = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChannelInclude | null
    /**
     * Filter, which Channels to fetch.
     */
    where?: ChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Channels to fetch.
     */
    orderBy?: Enumerable<ChannelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Channels.
     */
    cursor?: ChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Channels.
     */
    skip?: number
    distinct?: Enumerable<ChannelScalarFieldEnum>
  }


  /**
   * Channel create
   */
  export type ChannelCreateArgs = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChannelInclude | null
    /**
     * The data needed to create a Channel.
     */
    data: XOR<ChannelCreateInput, ChannelUncheckedCreateInput>
  }


  /**
   * Channel createMany
   */
  export type ChannelCreateManyArgs = {
    /**
     * The data used to create many Channels.
     */
    data: Enumerable<ChannelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Channel update
   */
  export type ChannelUpdateArgs = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChannelInclude | null
    /**
     * The data needed to update a Channel.
     */
    data: XOR<ChannelUpdateInput, ChannelUncheckedUpdateInput>
    /**
     * Choose, which Channel to update.
     */
    where: ChannelWhereUniqueInput
  }


  /**
   * Channel updateMany
   */
  export type ChannelUpdateManyArgs = {
    /**
     * The data used to update Channels.
     */
    data: XOR<ChannelUpdateManyMutationInput, ChannelUncheckedUpdateManyInput>
    /**
     * Filter which Channels to update
     */
    where?: ChannelWhereInput
  }


  /**
   * Channel upsert
   */
  export type ChannelUpsertArgs = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChannelInclude | null
    /**
     * The filter to search for the Channel to update in case it exists.
     */
    where: ChannelWhereUniqueInput
    /**
     * In case the Channel found by the `where` argument doesn't exist, create a new Channel with this data.
     */
    create: XOR<ChannelCreateInput, ChannelUncheckedCreateInput>
    /**
     * In case the Channel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChannelUpdateInput, ChannelUncheckedUpdateInput>
  }


  /**
   * Channel delete
   */
  export type ChannelDeleteArgs = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChannelInclude | null
    /**
     * Filter which Channel to delete.
     */
    where: ChannelWhereUniqueInput
  }


  /**
   * Channel deleteMany
   */
  export type ChannelDeleteManyArgs = {
    /**
     * Filter which Channels to delete
     */
    where?: ChannelWhereInput
  }


  /**
   * Channel.adminUsers
   */
  export type Channel$adminUsersArgs = {
    /**
     * Select specific fields to fetch from the YouTubeUser
     */
    select?: YouTubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YouTubeUserInclude | null
    where?: YouTubeUserWhereInput
    orderBy?: Enumerable<YouTubeUserOrderByWithRelationInput>
    cursor?: YouTubeUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YouTubeUserScalarFieldEnum>
  }


  /**
   * Channel.subscribedUsers
   */
  export type Channel$subscribedUsersArgs = {
    /**
     * Select specific fields to fetch from the YouTubeUser
     */
    select?: YouTubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YouTubeUserInclude | null
    where?: YouTubeUserWhereInput
    orderBy?: Enumerable<YouTubeUserOrderByWithRelationInput>
    cursor?: YouTubeUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YouTubeUserScalarFieldEnum>
  }


  /**
   * Channel.usersToChannelswithRoles
   */
  export type Channel$usersToChannelswithRolesArgs = {
    /**
     * Select specific fields to fetch from the UserToChannelwithRole
     */
    select?: UserToChannelwithRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToChannelwithRoleInclude | null
    where?: UserToChannelwithRoleWhereInput
    orderBy?: Enumerable<UserToChannelwithRoleOrderByWithRelationInput>
    cursor?: UserToChannelwithRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserToChannelwithRoleScalarFieldEnum>
  }


  /**
   * Channel.owningVideos
   */
  export type Channel$owningVideosArgs = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude | null
    where?: VideoWhereInput
    orderBy?: Enumerable<VideoOrderByWithRelationInput>
    cursor?: VideoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<VideoScalarFieldEnum>
  }


  /**
   * Channel without action
   */
  export type ChannelArgs = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChannelInclude | null
  }



  /**
   * Model UserToChannelwithRole
   */


  export type AggregateUserToChannelwithRole = {
    _count: UserToChannelwithRoleCountAggregateOutputType | null
    _avg: UserToChannelwithRoleAvgAggregateOutputType | null
    _sum: UserToChannelwithRoleSumAggregateOutputType | null
    _min: UserToChannelwithRoleMinAggregateOutputType | null
    _max: UserToChannelwithRoleMaxAggregateOutputType | null
  }

  export type UserToChannelwithRoleAvgAggregateOutputType = {
    id: number | null
    youTubeUserId: number | null
    channelId: number | null
  }

  export type UserToChannelwithRoleSumAggregateOutputType = {
    id: number | null
    youTubeUserId: number | null
    channelId: number | null
  }

  export type UserToChannelwithRoleMinAggregateOutputType = {
    id: number | null
    youTubeUserId: number | null
    channelId: number | null
    role: RoleEnum | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserToChannelwithRoleMaxAggregateOutputType = {
    id: number | null
    youTubeUserId: number | null
    channelId: number | null
    role: RoleEnum | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserToChannelwithRoleCountAggregateOutputType = {
    id: number
    youTubeUserId: number
    channelId: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserToChannelwithRoleAvgAggregateInputType = {
    id?: true
    youTubeUserId?: true
    channelId?: true
  }

  export type UserToChannelwithRoleSumAggregateInputType = {
    id?: true
    youTubeUserId?: true
    channelId?: true
  }

  export type UserToChannelwithRoleMinAggregateInputType = {
    id?: true
    youTubeUserId?: true
    channelId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserToChannelwithRoleMaxAggregateInputType = {
    id?: true
    youTubeUserId?: true
    channelId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserToChannelwithRoleCountAggregateInputType = {
    id?: true
    youTubeUserId?: true
    channelId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserToChannelwithRoleAggregateArgs = {
    /**
     * Filter which UserToChannelwithRole to aggregate.
     */
    where?: UserToChannelwithRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToChannelwithRoles to fetch.
     */
    orderBy?: Enumerable<UserToChannelwithRoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserToChannelwithRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToChannelwithRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToChannelwithRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserToChannelwithRoles
    **/
    _count?: true | UserToChannelwithRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserToChannelwithRoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserToChannelwithRoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserToChannelwithRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserToChannelwithRoleMaxAggregateInputType
  }

  export type GetUserToChannelwithRoleAggregateType<T extends UserToChannelwithRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserToChannelwithRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserToChannelwithRole[P]>
      : GetScalarType<T[P], AggregateUserToChannelwithRole[P]>
  }




  export type UserToChannelwithRoleGroupByArgs = {
    where?: UserToChannelwithRoleWhereInput
    orderBy?: Enumerable<UserToChannelwithRoleOrderByWithAggregationInput>
    by: UserToChannelwithRoleScalarFieldEnum[]
    having?: UserToChannelwithRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserToChannelwithRoleCountAggregateInputType | true
    _avg?: UserToChannelwithRoleAvgAggregateInputType
    _sum?: UserToChannelwithRoleSumAggregateInputType
    _min?: UserToChannelwithRoleMinAggregateInputType
    _max?: UserToChannelwithRoleMaxAggregateInputType
  }


  export type UserToChannelwithRoleGroupByOutputType = {
    id: number
    youTubeUserId: number
    channelId: number
    role: RoleEnum
    createdAt: Date
    updatedAt: Date
    _count: UserToChannelwithRoleCountAggregateOutputType | null
    _avg: UserToChannelwithRoleAvgAggregateOutputType | null
    _sum: UserToChannelwithRoleSumAggregateOutputType | null
    _min: UserToChannelwithRoleMinAggregateOutputType | null
    _max: UserToChannelwithRoleMaxAggregateOutputType | null
  }

  type GetUserToChannelwithRoleGroupByPayload<T extends UserToChannelwithRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserToChannelwithRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserToChannelwithRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserToChannelwithRoleGroupByOutputType[P]>
            : GetScalarType<T[P], UserToChannelwithRoleGroupByOutputType[P]>
        }
      >
    >


  export type UserToChannelwithRoleSelect = {
    id?: boolean
    user?: boolean | YouTubeUserArgs
    youTubeUserId?: boolean
    channel?: boolean | ChannelArgs
    channelId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type UserToChannelwithRoleInclude = {
    user?: boolean | YouTubeUserArgs
    channel?: boolean | ChannelArgs
  }

  export type UserToChannelwithRoleGetPayload<S extends boolean | null | undefined | UserToChannelwithRoleArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserToChannelwithRole :
    S extends undefined ? never :
    S extends { include: any } & (UserToChannelwithRoleArgs | UserToChannelwithRoleFindManyArgs)
    ? UserToChannelwithRole  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? YouTubeUserGetPayload<S['include'][P]> :
        P extends 'channel' ? ChannelGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserToChannelwithRoleArgs | UserToChannelwithRoleFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? YouTubeUserGetPayload<S['select'][P]> :
        P extends 'channel' ? ChannelGetPayload<S['select'][P]> :  P extends keyof UserToChannelwithRole ? UserToChannelwithRole[P] : never
  } 
      : UserToChannelwithRole


  type UserToChannelwithRoleCountArgs = 
    Omit<UserToChannelwithRoleFindManyArgs, 'select' | 'include'> & {
      select?: UserToChannelwithRoleCountAggregateInputType | true
    }

  export interface UserToChannelwithRoleDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one UserToChannelwithRole that matches the filter.
     * @param {UserToChannelwithRoleFindUniqueArgs} args - Arguments to find a UserToChannelwithRole
     * @example
     * // Get one UserToChannelwithRole
     * const userToChannelwithRole = await prisma.userToChannelwithRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserToChannelwithRoleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserToChannelwithRoleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserToChannelwithRole'> extends True ? Prisma__UserToChannelwithRoleClient<UserToChannelwithRoleGetPayload<T>> : Prisma__UserToChannelwithRoleClient<UserToChannelwithRoleGetPayload<T> | null, null>

    /**
     * Find one UserToChannelwithRole that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserToChannelwithRoleFindUniqueOrThrowArgs} args - Arguments to find a UserToChannelwithRole
     * @example
     * // Get one UserToChannelwithRole
     * const userToChannelwithRole = await prisma.userToChannelwithRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserToChannelwithRoleFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserToChannelwithRoleFindUniqueOrThrowArgs>
    ): Prisma__UserToChannelwithRoleClient<UserToChannelwithRoleGetPayload<T>>

    /**
     * Find the first UserToChannelwithRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToChannelwithRoleFindFirstArgs} args - Arguments to find a UserToChannelwithRole
     * @example
     * // Get one UserToChannelwithRole
     * const userToChannelwithRole = await prisma.userToChannelwithRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserToChannelwithRoleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserToChannelwithRoleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserToChannelwithRole'> extends True ? Prisma__UserToChannelwithRoleClient<UserToChannelwithRoleGetPayload<T>> : Prisma__UserToChannelwithRoleClient<UserToChannelwithRoleGetPayload<T> | null, null>

    /**
     * Find the first UserToChannelwithRole that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToChannelwithRoleFindFirstOrThrowArgs} args - Arguments to find a UserToChannelwithRole
     * @example
     * // Get one UserToChannelwithRole
     * const userToChannelwithRole = await prisma.userToChannelwithRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserToChannelwithRoleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserToChannelwithRoleFindFirstOrThrowArgs>
    ): Prisma__UserToChannelwithRoleClient<UserToChannelwithRoleGetPayload<T>>

    /**
     * Find zero or more UserToChannelwithRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToChannelwithRoleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserToChannelwithRoles
     * const userToChannelwithRoles = await prisma.userToChannelwithRole.findMany()
     * 
     * // Get first 10 UserToChannelwithRoles
     * const userToChannelwithRoles = await prisma.userToChannelwithRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userToChannelwithRoleWithIdOnly = await prisma.userToChannelwithRole.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserToChannelwithRoleFindManyArgs>(
      args?: SelectSubset<T, UserToChannelwithRoleFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserToChannelwithRoleGetPayload<T>>>

    /**
     * Create a UserToChannelwithRole.
     * @param {UserToChannelwithRoleCreateArgs} args - Arguments to create a UserToChannelwithRole.
     * @example
     * // Create one UserToChannelwithRole
     * const UserToChannelwithRole = await prisma.userToChannelwithRole.create({
     *   data: {
     *     // ... data to create a UserToChannelwithRole
     *   }
     * })
     * 
    **/
    create<T extends UserToChannelwithRoleCreateArgs>(
      args: SelectSubset<T, UserToChannelwithRoleCreateArgs>
    ): Prisma__UserToChannelwithRoleClient<UserToChannelwithRoleGetPayload<T>>

    /**
     * Create many UserToChannelwithRoles.
     *     @param {UserToChannelwithRoleCreateManyArgs} args - Arguments to create many UserToChannelwithRoles.
     *     @example
     *     // Create many UserToChannelwithRoles
     *     const userToChannelwithRole = await prisma.userToChannelwithRole.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserToChannelwithRoleCreateManyArgs>(
      args?: SelectSubset<T, UserToChannelwithRoleCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserToChannelwithRole.
     * @param {UserToChannelwithRoleDeleteArgs} args - Arguments to delete one UserToChannelwithRole.
     * @example
     * // Delete one UserToChannelwithRole
     * const UserToChannelwithRole = await prisma.userToChannelwithRole.delete({
     *   where: {
     *     // ... filter to delete one UserToChannelwithRole
     *   }
     * })
     * 
    **/
    delete<T extends UserToChannelwithRoleDeleteArgs>(
      args: SelectSubset<T, UserToChannelwithRoleDeleteArgs>
    ): Prisma__UserToChannelwithRoleClient<UserToChannelwithRoleGetPayload<T>>

    /**
     * Update one UserToChannelwithRole.
     * @param {UserToChannelwithRoleUpdateArgs} args - Arguments to update one UserToChannelwithRole.
     * @example
     * // Update one UserToChannelwithRole
     * const userToChannelwithRole = await prisma.userToChannelwithRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserToChannelwithRoleUpdateArgs>(
      args: SelectSubset<T, UserToChannelwithRoleUpdateArgs>
    ): Prisma__UserToChannelwithRoleClient<UserToChannelwithRoleGetPayload<T>>

    /**
     * Delete zero or more UserToChannelwithRoles.
     * @param {UserToChannelwithRoleDeleteManyArgs} args - Arguments to filter UserToChannelwithRoles to delete.
     * @example
     * // Delete a few UserToChannelwithRoles
     * const { count } = await prisma.userToChannelwithRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserToChannelwithRoleDeleteManyArgs>(
      args?: SelectSubset<T, UserToChannelwithRoleDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserToChannelwithRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToChannelwithRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserToChannelwithRoles
     * const userToChannelwithRole = await prisma.userToChannelwithRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserToChannelwithRoleUpdateManyArgs>(
      args: SelectSubset<T, UserToChannelwithRoleUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserToChannelwithRole.
     * @param {UserToChannelwithRoleUpsertArgs} args - Arguments to update or create a UserToChannelwithRole.
     * @example
     * // Update or create a UserToChannelwithRole
     * const userToChannelwithRole = await prisma.userToChannelwithRole.upsert({
     *   create: {
     *     // ... data to create a UserToChannelwithRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserToChannelwithRole we want to update
     *   }
     * })
    **/
    upsert<T extends UserToChannelwithRoleUpsertArgs>(
      args: SelectSubset<T, UserToChannelwithRoleUpsertArgs>
    ): Prisma__UserToChannelwithRoleClient<UserToChannelwithRoleGetPayload<T>>

    /**
     * Count the number of UserToChannelwithRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToChannelwithRoleCountArgs} args - Arguments to filter UserToChannelwithRoles to count.
     * @example
     * // Count the number of UserToChannelwithRoles
     * const count = await prisma.userToChannelwithRole.count({
     *   where: {
     *     // ... the filter for the UserToChannelwithRoles we want to count
     *   }
     * })
    **/
    count<T extends UserToChannelwithRoleCountArgs>(
      args?: Subset<T, UserToChannelwithRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserToChannelwithRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserToChannelwithRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToChannelwithRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserToChannelwithRoleAggregateArgs>(args: Subset<T, UserToChannelwithRoleAggregateArgs>): Prisma.PrismaPromise<GetUserToChannelwithRoleAggregateType<T>>

    /**
     * Group by UserToChannelwithRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToChannelwithRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserToChannelwithRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserToChannelwithRoleGroupByArgs['orderBy'] }
        : { orderBy?: UserToChannelwithRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserToChannelwithRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserToChannelwithRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserToChannelwithRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserToChannelwithRoleClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends YouTubeUserArgs= {}>(args?: Subset<T, YouTubeUserArgs>): Prisma__YouTubeUserClient<YouTubeUserGetPayload<T> | Null>;

    channel<T extends ChannelArgs= {}>(args?: Subset<T, ChannelArgs>): Prisma__ChannelClient<ChannelGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserToChannelwithRole base type for findUnique actions
   */
  export type UserToChannelwithRoleFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the UserToChannelwithRole
     */
    select?: UserToChannelwithRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToChannelwithRoleInclude | null
    /**
     * Filter, which UserToChannelwithRole to fetch.
     */
    where: UserToChannelwithRoleWhereUniqueInput
  }

  /**
   * UserToChannelwithRole findUnique
   */
  export interface UserToChannelwithRoleFindUniqueArgs extends UserToChannelwithRoleFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserToChannelwithRole findUniqueOrThrow
   */
  export type UserToChannelwithRoleFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserToChannelwithRole
     */
    select?: UserToChannelwithRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToChannelwithRoleInclude | null
    /**
     * Filter, which UserToChannelwithRole to fetch.
     */
    where: UserToChannelwithRoleWhereUniqueInput
  }


  /**
   * UserToChannelwithRole base type for findFirst actions
   */
  export type UserToChannelwithRoleFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the UserToChannelwithRole
     */
    select?: UserToChannelwithRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToChannelwithRoleInclude | null
    /**
     * Filter, which UserToChannelwithRole to fetch.
     */
    where?: UserToChannelwithRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToChannelwithRoles to fetch.
     */
    orderBy?: Enumerable<UserToChannelwithRoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserToChannelwithRoles.
     */
    cursor?: UserToChannelwithRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToChannelwithRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToChannelwithRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserToChannelwithRoles.
     */
    distinct?: Enumerable<UserToChannelwithRoleScalarFieldEnum>
  }

  /**
   * UserToChannelwithRole findFirst
   */
  export interface UserToChannelwithRoleFindFirstArgs extends UserToChannelwithRoleFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserToChannelwithRole findFirstOrThrow
   */
  export type UserToChannelwithRoleFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserToChannelwithRole
     */
    select?: UserToChannelwithRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToChannelwithRoleInclude | null
    /**
     * Filter, which UserToChannelwithRole to fetch.
     */
    where?: UserToChannelwithRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToChannelwithRoles to fetch.
     */
    orderBy?: Enumerable<UserToChannelwithRoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserToChannelwithRoles.
     */
    cursor?: UserToChannelwithRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToChannelwithRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToChannelwithRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserToChannelwithRoles.
     */
    distinct?: Enumerable<UserToChannelwithRoleScalarFieldEnum>
  }


  /**
   * UserToChannelwithRole findMany
   */
  export type UserToChannelwithRoleFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserToChannelwithRole
     */
    select?: UserToChannelwithRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToChannelwithRoleInclude | null
    /**
     * Filter, which UserToChannelwithRoles to fetch.
     */
    where?: UserToChannelwithRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToChannelwithRoles to fetch.
     */
    orderBy?: Enumerable<UserToChannelwithRoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserToChannelwithRoles.
     */
    cursor?: UserToChannelwithRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToChannelwithRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToChannelwithRoles.
     */
    skip?: number
    distinct?: Enumerable<UserToChannelwithRoleScalarFieldEnum>
  }


  /**
   * UserToChannelwithRole create
   */
  export type UserToChannelwithRoleCreateArgs = {
    /**
     * Select specific fields to fetch from the UserToChannelwithRole
     */
    select?: UserToChannelwithRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToChannelwithRoleInclude | null
    /**
     * The data needed to create a UserToChannelwithRole.
     */
    data: XOR<UserToChannelwithRoleCreateInput, UserToChannelwithRoleUncheckedCreateInput>
  }


  /**
   * UserToChannelwithRole createMany
   */
  export type UserToChannelwithRoleCreateManyArgs = {
    /**
     * The data used to create many UserToChannelwithRoles.
     */
    data: Enumerable<UserToChannelwithRoleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserToChannelwithRole update
   */
  export type UserToChannelwithRoleUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserToChannelwithRole
     */
    select?: UserToChannelwithRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToChannelwithRoleInclude | null
    /**
     * The data needed to update a UserToChannelwithRole.
     */
    data: XOR<UserToChannelwithRoleUpdateInput, UserToChannelwithRoleUncheckedUpdateInput>
    /**
     * Choose, which UserToChannelwithRole to update.
     */
    where: UserToChannelwithRoleWhereUniqueInput
  }


  /**
   * UserToChannelwithRole updateMany
   */
  export type UserToChannelwithRoleUpdateManyArgs = {
    /**
     * The data used to update UserToChannelwithRoles.
     */
    data: XOR<UserToChannelwithRoleUpdateManyMutationInput, UserToChannelwithRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserToChannelwithRoles to update
     */
    where?: UserToChannelwithRoleWhereInput
  }


  /**
   * UserToChannelwithRole upsert
   */
  export type UserToChannelwithRoleUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserToChannelwithRole
     */
    select?: UserToChannelwithRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToChannelwithRoleInclude | null
    /**
     * The filter to search for the UserToChannelwithRole to update in case it exists.
     */
    where: UserToChannelwithRoleWhereUniqueInput
    /**
     * In case the UserToChannelwithRole found by the `where` argument doesn't exist, create a new UserToChannelwithRole with this data.
     */
    create: XOR<UserToChannelwithRoleCreateInput, UserToChannelwithRoleUncheckedCreateInput>
    /**
     * In case the UserToChannelwithRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserToChannelwithRoleUpdateInput, UserToChannelwithRoleUncheckedUpdateInput>
  }


  /**
   * UserToChannelwithRole delete
   */
  export type UserToChannelwithRoleDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserToChannelwithRole
     */
    select?: UserToChannelwithRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToChannelwithRoleInclude | null
    /**
     * Filter which UserToChannelwithRole to delete.
     */
    where: UserToChannelwithRoleWhereUniqueInput
  }


  /**
   * UserToChannelwithRole deleteMany
   */
  export type UserToChannelwithRoleDeleteManyArgs = {
    /**
     * Filter which UserToChannelwithRoles to delete
     */
    where?: UserToChannelwithRoleWhereInput
  }


  /**
   * UserToChannelwithRole without action
   */
  export type UserToChannelwithRoleArgs = {
    /**
     * Select specific fields to fetch from the UserToChannelwithRole
     */
    select?: UserToChannelwithRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToChannelwithRoleInclude | null
  }



  /**
   * Model Video
   */


  export type AggregateVideo = {
    _count: VideoCountAggregateOutputType | null
    _avg: VideoAvgAggregateOutputType | null
    _sum: VideoSumAggregateOutputType | null
    _min: VideoMinAggregateOutputType | null
    _max: VideoMaxAggregateOutputType | null
  }

  export type VideoAvgAggregateOutputType = {
    id: number | null
    channelId: number | null
  }

  export type VideoSumAggregateOutputType = {
    id: number | null
    channelId: number | null
  }

  export type VideoMinAggregateOutputType = {
    id: number | null
    title: string | null
    videoUrl: string | null
    thumbnailImageUrl: string | null
    description: string | null
    channelId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VideoMaxAggregateOutputType = {
    id: number | null
    title: string | null
    videoUrl: string | null
    thumbnailImageUrl: string | null
    description: string | null
    channelId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VideoCountAggregateOutputType = {
    id: number
    title: number
    videoUrl: number
    thumbnailImageUrl: number
    description: number
    channelId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VideoAvgAggregateInputType = {
    id?: true
    channelId?: true
  }

  export type VideoSumAggregateInputType = {
    id?: true
    channelId?: true
  }

  export type VideoMinAggregateInputType = {
    id?: true
    title?: true
    videoUrl?: true
    thumbnailImageUrl?: true
    description?: true
    channelId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VideoMaxAggregateInputType = {
    id?: true
    title?: true
    videoUrl?: true
    thumbnailImageUrl?: true
    description?: true
    channelId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VideoCountAggregateInputType = {
    id?: true
    title?: true
    videoUrl?: true
    thumbnailImageUrl?: true
    description?: true
    channelId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VideoAggregateArgs = {
    /**
     * Filter which Video to aggregate.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: Enumerable<VideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Videos
    **/
    _count?: true | VideoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VideoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VideoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideoMaxAggregateInputType
  }

  export type GetVideoAggregateType<T extends VideoAggregateArgs> = {
        [P in keyof T & keyof AggregateVideo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideo[P]>
      : GetScalarType<T[P], AggregateVideo[P]>
  }




  export type VideoGroupByArgs = {
    where?: VideoWhereInput
    orderBy?: Enumerable<VideoOrderByWithAggregationInput>
    by: VideoScalarFieldEnum[]
    having?: VideoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideoCountAggregateInputType | true
    _avg?: VideoAvgAggregateInputType
    _sum?: VideoSumAggregateInputType
    _min?: VideoMinAggregateInputType
    _max?: VideoMaxAggregateInputType
  }


  export type VideoGroupByOutputType = {
    id: number
    title: string
    videoUrl: string
    thumbnailImageUrl: string | null
    description: string | null
    channelId: number
    createdAt: Date
    updatedAt: Date
    _count: VideoCountAggregateOutputType | null
    _avg: VideoAvgAggregateOutputType | null
    _sum: VideoSumAggregateOutputType | null
    _min: VideoMinAggregateOutputType | null
    _max: VideoMaxAggregateOutputType | null
  }

  type GetVideoGroupByPayload<T extends VideoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<VideoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideoGroupByOutputType[P]>
            : GetScalarType<T[P], VideoGroupByOutputType[P]>
        }
      >
    >


  export type VideoSelect = {
    id?: boolean
    title?: boolean
    videoUrl?: boolean
    thumbnailImageUrl?: boolean
    description?: boolean
    belongsToChannel?: boolean | ChannelArgs
    channelId?: boolean
    reactedByYouTubeUsers?: boolean | Video$reactedByYouTubeUsersArgs
    usersToVideosWithReactions?: boolean | Video$usersToVideosWithReactionsArgs
    videoComments?: boolean | Video$videoCommentsArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | VideoCountOutputTypeArgs
  }


  export type VideoInclude = {
    belongsToChannel?: boolean | ChannelArgs
    reactedByYouTubeUsers?: boolean | Video$reactedByYouTubeUsersArgs
    usersToVideosWithReactions?: boolean | Video$usersToVideosWithReactionsArgs
    videoComments?: boolean | Video$videoCommentsArgs
    _count?: boolean | VideoCountOutputTypeArgs
  }

  export type VideoGetPayload<S extends boolean | null | undefined | VideoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Video :
    S extends undefined ? never :
    S extends { include: any } & (VideoArgs | VideoFindManyArgs)
    ? Video  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'belongsToChannel' ? ChannelGetPayload<S['include'][P]> :
        P extends 'reactedByYouTubeUsers' ? Array < YouTubeUserGetPayload<S['include'][P]>>  :
        P extends 'usersToVideosWithReactions' ? Array < UserToVideoWithReactionGetPayload<S['include'][P]>>  :
        P extends 'videoComments' ? Array < VideoCommentGetPayload<S['include'][P]>>  :
        P extends '_count' ? VideoCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (VideoArgs | VideoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'belongsToChannel' ? ChannelGetPayload<S['select'][P]> :
        P extends 'reactedByYouTubeUsers' ? Array < YouTubeUserGetPayload<S['select'][P]>>  :
        P extends 'usersToVideosWithReactions' ? Array < UserToVideoWithReactionGetPayload<S['select'][P]>>  :
        P extends 'videoComments' ? Array < VideoCommentGetPayload<S['select'][P]>>  :
        P extends '_count' ? VideoCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Video ? Video[P] : never
  } 
      : Video


  type VideoCountArgs = 
    Omit<VideoFindManyArgs, 'select' | 'include'> & {
      select?: VideoCountAggregateInputType | true
    }

  export interface VideoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Video that matches the filter.
     * @param {VideoFindUniqueArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VideoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, VideoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Video'> extends True ? Prisma__VideoClient<VideoGetPayload<T>> : Prisma__VideoClient<VideoGetPayload<T> | null, null>

    /**
     * Find one Video that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {VideoFindUniqueOrThrowArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends VideoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, VideoFindUniqueOrThrowArgs>
    ): Prisma__VideoClient<VideoGetPayload<T>>

    /**
     * Find the first Video that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFindFirstArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VideoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, VideoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Video'> extends True ? Prisma__VideoClient<VideoGetPayload<T>> : Prisma__VideoClient<VideoGetPayload<T> | null, null>

    /**
     * Find the first Video that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFindFirstOrThrowArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends VideoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, VideoFindFirstOrThrowArgs>
    ): Prisma__VideoClient<VideoGetPayload<T>>

    /**
     * Find zero or more Videos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Videos
     * const videos = await prisma.video.findMany()
     * 
     * // Get first 10 Videos
     * const videos = await prisma.video.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videoWithIdOnly = await prisma.video.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VideoFindManyArgs>(
      args?: SelectSubset<T, VideoFindManyArgs>
    ): Prisma.PrismaPromise<Array<VideoGetPayload<T>>>

    /**
     * Create a Video.
     * @param {VideoCreateArgs} args - Arguments to create a Video.
     * @example
     * // Create one Video
     * const Video = await prisma.video.create({
     *   data: {
     *     // ... data to create a Video
     *   }
     * })
     * 
    **/
    create<T extends VideoCreateArgs>(
      args: SelectSubset<T, VideoCreateArgs>
    ): Prisma__VideoClient<VideoGetPayload<T>>

    /**
     * Create many Videos.
     *     @param {VideoCreateManyArgs} args - Arguments to create many Videos.
     *     @example
     *     // Create many Videos
     *     const video = await prisma.video.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VideoCreateManyArgs>(
      args?: SelectSubset<T, VideoCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Video.
     * @param {VideoDeleteArgs} args - Arguments to delete one Video.
     * @example
     * // Delete one Video
     * const Video = await prisma.video.delete({
     *   where: {
     *     // ... filter to delete one Video
     *   }
     * })
     * 
    **/
    delete<T extends VideoDeleteArgs>(
      args: SelectSubset<T, VideoDeleteArgs>
    ): Prisma__VideoClient<VideoGetPayload<T>>

    /**
     * Update one Video.
     * @param {VideoUpdateArgs} args - Arguments to update one Video.
     * @example
     * // Update one Video
     * const video = await prisma.video.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VideoUpdateArgs>(
      args: SelectSubset<T, VideoUpdateArgs>
    ): Prisma__VideoClient<VideoGetPayload<T>>

    /**
     * Delete zero or more Videos.
     * @param {VideoDeleteManyArgs} args - Arguments to filter Videos to delete.
     * @example
     * // Delete a few Videos
     * const { count } = await prisma.video.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VideoDeleteManyArgs>(
      args?: SelectSubset<T, VideoDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Videos
     * const video = await prisma.video.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VideoUpdateManyArgs>(
      args: SelectSubset<T, VideoUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Video.
     * @param {VideoUpsertArgs} args - Arguments to update or create a Video.
     * @example
     * // Update or create a Video
     * const video = await prisma.video.upsert({
     *   create: {
     *     // ... data to create a Video
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Video we want to update
     *   }
     * })
    **/
    upsert<T extends VideoUpsertArgs>(
      args: SelectSubset<T, VideoUpsertArgs>
    ): Prisma__VideoClient<VideoGetPayload<T>>

    /**
     * Count the number of Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCountArgs} args - Arguments to filter Videos to count.
     * @example
     * // Count the number of Videos
     * const count = await prisma.video.count({
     *   where: {
     *     // ... the filter for the Videos we want to count
     *   }
     * })
    **/
    count<T extends VideoCountArgs>(
      args?: Subset<T, VideoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Video.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideoAggregateArgs>(args: Subset<T, VideoAggregateArgs>): Prisma.PrismaPromise<GetVideoAggregateType<T>>

    /**
     * Group by Video.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideoGroupByArgs['orderBy'] }
        : { orderBy?: VideoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Video.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VideoClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    belongsToChannel<T extends ChannelArgs= {}>(args?: Subset<T, ChannelArgs>): Prisma__ChannelClient<ChannelGetPayload<T> | Null>;

    reactedByYouTubeUsers<T extends Video$reactedByYouTubeUsersArgs= {}>(args?: Subset<T, Video$reactedByYouTubeUsersArgs>): Prisma.PrismaPromise<Array<YouTubeUserGetPayload<T>>| Null>;

    usersToVideosWithReactions<T extends Video$usersToVideosWithReactionsArgs= {}>(args?: Subset<T, Video$usersToVideosWithReactionsArgs>): Prisma.PrismaPromise<Array<UserToVideoWithReactionGetPayload<T>>| Null>;

    videoComments<T extends Video$videoCommentsArgs= {}>(args?: Subset<T, Video$videoCommentsArgs>): Prisma.PrismaPromise<Array<VideoCommentGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Video base type for findUnique actions
   */
  export type VideoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude | null
    /**
     * Filter, which Video to fetch.
     */
    where: VideoWhereUniqueInput
  }

  /**
   * Video findUnique
   */
  export interface VideoFindUniqueArgs extends VideoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Video findUniqueOrThrow
   */
  export type VideoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude | null
    /**
     * Filter, which Video to fetch.
     */
    where: VideoWhereUniqueInput
  }


  /**
   * Video base type for findFirst actions
   */
  export type VideoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude | null
    /**
     * Filter, which Video to fetch.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: Enumerable<VideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Videos.
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Videos.
     */
    distinct?: Enumerable<VideoScalarFieldEnum>
  }

  /**
   * Video findFirst
   */
  export interface VideoFindFirstArgs extends VideoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Video findFirstOrThrow
   */
  export type VideoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude | null
    /**
     * Filter, which Video to fetch.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: Enumerable<VideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Videos.
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Videos.
     */
    distinct?: Enumerable<VideoScalarFieldEnum>
  }


  /**
   * Video findMany
   */
  export type VideoFindManyArgs = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude | null
    /**
     * Filter, which Videos to fetch.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: Enumerable<VideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Videos.
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    distinct?: Enumerable<VideoScalarFieldEnum>
  }


  /**
   * Video create
   */
  export type VideoCreateArgs = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude | null
    /**
     * The data needed to create a Video.
     */
    data: XOR<VideoCreateInput, VideoUncheckedCreateInput>
  }


  /**
   * Video createMany
   */
  export type VideoCreateManyArgs = {
    /**
     * The data used to create many Videos.
     */
    data: Enumerable<VideoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Video update
   */
  export type VideoUpdateArgs = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude | null
    /**
     * The data needed to update a Video.
     */
    data: XOR<VideoUpdateInput, VideoUncheckedUpdateInput>
    /**
     * Choose, which Video to update.
     */
    where: VideoWhereUniqueInput
  }


  /**
   * Video updateMany
   */
  export type VideoUpdateManyArgs = {
    /**
     * The data used to update Videos.
     */
    data: XOR<VideoUpdateManyMutationInput, VideoUncheckedUpdateManyInput>
    /**
     * Filter which Videos to update
     */
    where?: VideoWhereInput
  }


  /**
   * Video upsert
   */
  export type VideoUpsertArgs = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude | null
    /**
     * The filter to search for the Video to update in case it exists.
     */
    where: VideoWhereUniqueInput
    /**
     * In case the Video found by the `where` argument doesn't exist, create a new Video with this data.
     */
    create: XOR<VideoCreateInput, VideoUncheckedCreateInput>
    /**
     * In case the Video was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VideoUpdateInput, VideoUncheckedUpdateInput>
  }


  /**
   * Video delete
   */
  export type VideoDeleteArgs = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude | null
    /**
     * Filter which Video to delete.
     */
    where: VideoWhereUniqueInput
  }


  /**
   * Video deleteMany
   */
  export type VideoDeleteManyArgs = {
    /**
     * Filter which Videos to delete
     */
    where?: VideoWhereInput
  }


  /**
   * Video.reactedByYouTubeUsers
   */
  export type Video$reactedByYouTubeUsersArgs = {
    /**
     * Select specific fields to fetch from the YouTubeUser
     */
    select?: YouTubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YouTubeUserInclude | null
    where?: YouTubeUserWhereInput
    orderBy?: Enumerable<YouTubeUserOrderByWithRelationInput>
    cursor?: YouTubeUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YouTubeUserScalarFieldEnum>
  }


  /**
   * Video.usersToVideosWithReactions
   */
  export type Video$usersToVideosWithReactionsArgs = {
    /**
     * Select specific fields to fetch from the UserToVideoWithReaction
     */
    select?: UserToVideoWithReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToVideoWithReactionInclude | null
    where?: UserToVideoWithReactionWhereInput
    orderBy?: Enumerable<UserToVideoWithReactionOrderByWithRelationInput>
    cursor?: UserToVideoWithReactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserToVideoWithReactionScalarFieldEnum>
  }


  /**
   * Video.videoComments
   */
  export type Video$videoCommentsArgs = {
    /**
     * Select specific fields to fetch from the VideoComment
     */
    select?: VideoCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoCommentInclude | null
    where?: VideoCommentWhereInput
    orderBy?: Enumerable<VideoCommentOrderByWithRelationInput>
    cursor?: VideoCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<VideoCommentScalarFieldEnum>
  }


  /**
   * Video without action
   */
  export type VideoArgs = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude | null
  }



  /**
   * Model UserToVideoWithReaction
   */


  export type AggregateUserToVideoWithReaction = {
    _count: UserToVideoWithReactionCountAggregateOutputType | null
    _avg: UserToVideoWithReactionAvgAggregateOutputType | null
    _sum: UserToVideoWithReactionSumAggregateOutputType | null
    _min: UserToVideoWithReactionMinAggregateOutputType | null
    _max: UserToVideoWithReactionMaxAggregateOutputType | null
  }

  export type UserToVideoWithReactionAvgAggregateOutputType = {
    id: number | null
    youTubeUserId: number | null
    videoId: number | null
  }

  export type UserToVideoWithReactionSumAggregateOutputType = {
    id: number | null
    youTubeUserId: number | null
    videoId: number | null
  }

  export type UserToVideoWithReactionMinAggregateOutputType = {
    id: number | null
    youTubeUserId: number | null
    videoId: number | null
    reaction: ReactionEnum | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserToVideoWithReactionMaxAggregateOutputType = {
    id: number | null
    youTubeUserId: number | null
    videoId: number | null
    reaction: ReactionEnum | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserToVideoWithReactionCountAggregateOutputType = {
    id: number
    youTubeUserId: number
    videoId: number
    reaction: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserToVideoWithReactionAvgAggregateInputType = {
    id?: true
    youTubeUserId?: true
    videoId?: true
  }

  export type UserToVideoWithReactionSumAggregateInputType = {
    id?: true
    youTubeUserId?: true
    videoId?: true
  }

  export type UserToVideoWithReactionMinAggregateInputType = {
    id?: true
    youTubeUserId?: true
    videoId?: true
    reaction?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserToVideoWithReactionMaxAggregateInputType = {
    id?: true
    youTubeUserId?: true
    videoId?: true
    reaction?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserToVideoWithReactionCountAggregateInputType = {
    id?: true
    youTubeUserId?: true
    videoId?: true
    reaction?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserToVideoWithReactionAggregateArgs = {
    /**
     * Filter which UserToVideoWithReaction to aggregate.
     */
    where?: UserToVideoWithReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToVideoWithReactions to fetch.
     */
    orderBy?: Enumerable<UserToVideoWithReactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserToVideoWithReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToVideoWithReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToVideoWithReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserToVideoWithReactions
    **/
    _count?: true | UserToVideoWithReactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserToVideoWithReactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserToVideoWithReactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserToVideoWithReactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserToVideoWithReactionMaxAggregateInputType
  }

  export type GetUserToVideoWithReactionAggregateType<T extends UserToVideoWithReactionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserToVideoWithReaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserToVideoWithReaction[P]>
      : GetScalarType<T[P], AggregateUserToVideoWithReaction[P]>
  }




  export type UserToVideoWithReactionGroupByArgs = {
    where?: UserToVideoWithReactionWhereInput
    orderBy?: Enumerable<UserToVideoWithReactionOrderByWithAggregationInput>
    by: UserToVideoWithReactionScalarFieldEnum[]
    having?: UserToVideoWithReactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserToVideoWithReactionCountAggregateInputType | true
    _avg?: UserToVideoWithReactionAvgAggregateInputType
    _sum?: UserToVideoWithReactionSumAggregateInputType
    _min?: UserToVideoWithReactionMinAggregateInputType
    _max?: UserToVideoWithReactionMaxAggregateInputType
  }


  export type UserToVideoWithReactionGroupByOutputType = {
    id: number
    youTubeUserId: number
    videoId: number
    reaction: ReactionEnum
    createdAt: Date
    updatedAt: Date
    _count: UserToVideoWithReactionCountAggregateOutputType | null
    _avg: UserToVideoWithReactionAvgAggregateOutputType | null
    _sum: UserToVideoWithReactionSumAggregateOutputType | null
    _min: UserToVideoWithReactionMinAggregateOutputType | null
    _max: UserToVideoWithReactionMaxAggregateOutputType | null
  }

  type GetUserToVideoWithReactionGroupByPayload<T extends UserToVideoWithReactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserToVideoWithReactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserToVideoWithReactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserToVideoWithReactionGroupByOutputType[P]>
            : GetScalarType<T[P], UserToVideoWithReactionGroupByOutputType[P]>
        }
      >
    >


  export type UserToVideoWithReactionSelect = {
    id?: boolean
    user?: boolean | YouTubeUserArgs
    youTubeUserId?: boolean
    video?: boolean | VideoArgs
    videoId?: boolean
    reaction?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type UserToVideoWithReactionInclude = {
    user?: boolean | YouTubeUserArgs
    video?: boolean | VideoArgs
  }

  export type UserToVideoWithReactionGetPayload<S extends boolean | null | undefined | UserToVideoWithReactionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserToVideoWithReaction :
    S extends undefined ? never :
    S extends { include: any } & (UserToVideoWithReactionArgs | UserToVideoWithReactionFindManyArgs)
    ? UserToVideoWithReaction  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? YouTubeUserGetPayload<S['include'][P]> :
        P extends 'video' ? VideoGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserToVideoWithReactionArgs | UserToVideoWithReactionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? YouTubeUserGetPayload<S['select'][P]> :
        P extends 'video' ? VideoGetPayload<S['select'][P]> :  P extends keyof UserToVideoWithReaction ? UserToVideoWithReaction[P] : never
  } 
      : UserToVideoWithReaction


  type UserToVideoWithReactionCountArgs = 
    Omit<UserToVideoWithReactionFindManyArgs, 'select' | 'include'> & {
      select?: UserToVideoWithReactionCountAggregateInputType | true
    }

  export interface UserToVideoWithReactionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one UserToVideoWithReaction that matches the filter.
     * @param {UserToVideoWithReactionFindUniqueArgs} args - Arguments to find a UserToVideoWithReaction
     * @example
     * // Get one UserToVideoWithReaction
     * const userToVideoWithReaction = await prisma.userToVideoWithReaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserToVideoWithReactionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserToVideoWithReactionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserToVideoWithReaction'> extends True ? Prisma__UserToVideoWithReactionClient<UserToVideoWithReactionGetPayload<T>> : Prisma__UserToVideoWithReactionClient<UserToVideoWithReactionGetPayload<T> | null, null>

    /**
     * Find one UserToVideoWithReaction that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserToVideoWithReactionFindUniqueOrThrowArgs} args - Arguments to find a UserToVideoWithReaction
     * @example
     * // Get one UserToVideoWithReaction
     * const userToVideoWithReaction = await prisma.userToVideoWithReaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserToVideoWithReactionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserToVideoWithReactionFindUniqueOrThrowArgs>
    ): Prisma__UserToVideoWithReactionClient<UserToVideoWithReactionGetPayload<T>>

    /**
     * Find the first UserToVideoWithReaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToVideoWithReactionFindFirstArgs} args - Arguments to find a UserToVideoWithReaction
     * @example
     * // Get one UserToVideoWithReaction
     * const userToVideoWithReaction = await prisma.userToVideoWithReaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserToVideoWithReactionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserToVideoWithReactionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserToVideoWithReaction'> extends True ? Prisma__UserToVideoWithReactionClient<UserToVideoWithReactionGetPayload<T>> : Prisma__UserToVideoWithReactionClient<UserToVideoWithReactionGetPayload<T> | null, null>

    /**
     * Find the first UserToVideoWithReaction that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToVideoWithReactionFindFirstOrThrowArgs} args - Arguments to find a UserToVideoWithReaction
     * @example
     * // Get one UserToVideoWithReaction
     * const userToVideoWithReaction = await prisma.userToVideoWithReaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserToVideoWithReactionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserToVideoWithReactionFindFirstOrThrowArgs>
    ): Prisma__UserToVideoWithReactionClient<UserToVideoWithReactionGetPayload<T>>

    /**
     * Find zero or more UserToVideoWithReactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToVideoWithReactionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserToVideoWithReactions
     * const userToVideoWithReactions = await prisma.userToVideoWithReaction.findMany()
     * 
     * // Get first 10 UserToVideoWithReactions
     * const userToVideoWithReactions = await prisma.userToVideoWithReaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userToVideoWithReactionWithIdOnly = await prisma.userToVideoWithReaction.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserToVideoWithReactionFindManyArgs>(
      args?: SelectSubset<T, UserToVideoWithReactionFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserToVideoWithReactionGetPayload<T>>>

    /**
     * Create a UserToVideoWithReaction.
     * @param {UserToVideoWithReactionCreateArgs} args - Arguments to create a UserToVideoWithReaction.
     * @example
     * // Create one UserToVideoWithReaction
     * const UserToVideoWithReaction = await prisma.userToVideoWithReaction.create({
     *   data: {
     *     // ... data to create a UserToVideoWithReaction
     *   }
     * })
     * 
    **/
    create<T extends UserToVideoWithReactionCreateArgs>(
      args: SelectSubset<T, UserToVideoWithReactionCreateArgs>
    ): Prisma__UserToVideoWithReactionClient<UserToVideoWithReactionGetPayload<T>>

    /**
     * Create many UserToVideoWithReactions.
     *     @param {UserToVideoWithReactionCreateManyArgs} args - Arguments to create many UserToVideoWithReactions.
     *     @example
     *     // Create many UserToVideoWithReactions
     *     const userToVideoWithReaction = await prisma.userToVideoWithReaction.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserToVideoWithReactionCreateManyArgs>(
      args?: SelectSubset<T, UserToVideoWithReactionCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserToVideoWithReaction.
     * @param {UserToVideoWithReactionDeleteArgs} args - Arguments to delete one UserToVideoWithReaction.
     * @example
     * // Delete one UserToVideoWithReaction
     * const UserToVideoWithReaction = await prisma.userToVideoWithReaction.delete({
     *   where: {
     *     // ... filter to delete one UserToVideoWithReaction
     *   }
     * })
     * 
    **/
    delete<T extends UserToVideoWithReactionDeleteArgs>(
      args: SelectSubset<T, UserToVideoWithReactionDeleteArgs>
    ): Prisma__UserToVideoWithReactionClient<UserToVideoWithReactionGetPayload<T>>

    /**
     * Update one UserToVideoWithReaction.
     * @param {UserToVideoWithReactionUpdateArgs} args - Arguments to update one UserToVideoWithReaction.
     * @example
     * // Update one UserToVideoWithReaction
     * const userToVideoWithReaction = await prisma.userToVideoWithReaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserToVideoWithReactionUpdateArgs>(
      args: SelectSubset<T, UserToVideoWithReactionUpdateArgs>
    ): Prisma__UserToVideoWithReactionClient<UserToVideoWithReactionGetPayload<T>>

    /**
     * Delete zero or more UserToVideoWithReactions.
     * @param {UserToVideoWithReactionDeleteManyArgs} args - Arguments to filter UserToVideoWithReactions to delete.
     * @example
     * // Delete a few UserToVideoWithReactions
     * const { count } = await prisma.userToVideoWithReaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserToVideoWithReactionDeleteManyArgs>(
      args?: SelectSubset<T, UserToVideoWithReactionDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserToVideoWithReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToVideoWithReactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserToVideoWithReactions
     * const userToVideoWithReaction = await prisma.userToVideoWithReaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserToVideoWithReactionUpdateManyArgs>(
      args: SelectSubset<T, UserToVideoWithReactionUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserToVideoWithReaction.
     * @param {UserToVideoWithReactionUpsertArgs} args - Arguments to update or create a UserToVideoWithReaction.
     * @example
     * // Update or create a UserToVideoWithReaction
     * const userToVideoWithReaction = await prisma.userToVideoWithReaction.upsert({
     *   create: {
     *     // ... data to create a UserToVideoWithReaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserToVideoWithReaction we want to update
     *   }
     * })
    **/
    upsert<T extends UserToVideoWithReactionUpsertArgs>(
      args: SelectSubset<T, UserToVideoWithReactionUpsertArgs>
    ): Prisma__UserToVideoWithReactionClient<UserToVideoWithReactionGetPayload<T>>

    /**
     * Count the number of UserToVideoWithReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToVideoWithReactionCountArgs} args - Arguments to filter UserToVideoWithReactions to count.
     * @example
     * // Count the number of UserToVideoWithReactions
     * const count = await prisma.userToVideoWithReaction.count({
     *   where: {
     *     // ... the filter for the UserToVideoWithReactions we want to count
     *   }
     * })
    **/
    count<T extends UserToVideoWithReactionCountArgs>(
      args?: Subset<T, UserToVideoWithReactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserToVideoWithReactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserToVideoWithReaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToVideoWithReactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserToVideoWithReactionAggregateArgs>(args: Subset<T, UserToVideoWithReactionAggregateArgs>): Prisma.PrismaPromise<GetUserToVideoWithReactionAggregateType<T>>

    /**
     * Group by UserToVideoWithReaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToVideoWithReactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserToVideoWithReactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserToVideoWithReactionGroupByArgs['orderBy'] }
        : { orderBy?: UserToVideoWithReactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserToVideoWithReactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserToVideoWithReactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserToVideoWithReaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserToVideoWithReactionClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends YouTubeUserArgs= {}>(args?: Subset<T, YouTubeUserArgs>): Prisma__YouTubeUserClient<YouTubeUserGetPayload<T> | Null>;

    video<T extends VideoArgs= {}>(args?: Subset<T, VideoArgs>): Prisma__VideoClient<VideoGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserToVideoWithReaction base type for findUnique actions
   */
  export type UserToVideoWithReactionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the UserToVideoWithReaction
     */
    select?: UserToVideoWithReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToVideoWithReactionInclude | null
    /**
     * Filter, which UserToVideoWithReaction to fetch.
     */
    where: UserToVideoWithReactionWhereUniqueInput
  }

  /**
   * UserToVideoWithReaction findUnique
   */
  export interface UserToVideoWithReactionFindUniqueArgs extends UserToVideoWithReactionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserToVideoWithReaction findUniqueOrThrow
   */
  export type UserToVideoWithReactionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserToVideoWithReaction
     */
    select?: UserToVideoWithReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToVideoWithReactionInclude | null
    /**
     * Filter, which UserToVideoWithReaction to fetch.
     */
    where: UserToVideoWithReactionWhereUniqueInput
  }


  /**
   * UserToVideoWithReaction base type for findFirst actions
   */
  export type UserToVideoWithReactionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the UserToVideoWithReaction
     */
    select?: UserToVideoWithReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToVideoWithReactionInclude | null
    /**
     * Filter, which UserToVideoWithReaction to fetch.
     */
    where?: UserToVideoWithReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToVideoWithReactions to fetch.
     */
    orderBy?: Enumerable<UserToVideoWithReactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserToVideoWithReactions.
     */
    cursor?: UserToVideoWithReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToVideoWithReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToVideoWithReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserToVideoWithReactions.
     */
    distinct?: Enumerable<UserToVideoWithReactionScalarFieldEnum>
  }

  /**
   * UserToVideoWithReaction findFirst
   */
  export interface UserToVideoWithReactionFindFirstArgs extends UserToVideoWithReactionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserToVideoWithReaction findFirstOrThrow
   */
  export type UserToVideoWithReactionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserToVideoWithReaction
     */
    select?: UserToVideoWithReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToVideoWithReactionInclude | null
    /**
     * Filter, which UserToVideoWithReaction to fetch.
     */
    where?: UserToVideoWithReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToVideoWithReactions to fetch.
     */
    orderBy?: Enumerable<UserToVideoWithReactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserToVideoWithReactions.
     */
    cursor?: UserToVideoWithReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToVideoWithReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToVideoWithReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserToVideoWithReactions.
     */
    distinct?: Enumerable<UserToVideoWithReactionScalarFieldEnum>
  }


  /**
   * UserToVideoWithReaction findMany
   */
  export type UserToVideoWithReactionFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserToVideoWithReaction
     */
    select?: UserToVideoWithReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToVideoWithReactionInclude | null
    /**
     * Filter, which UserToVideoWithReactions to fetch.
     */
    where?: UserToVideoWithReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToVideoWithReactions to fetch.
     */
    orderBy?: Enumerable<UserToVideoWithReactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserToVideoWithReactions.
     */
    cursor?: UserToVideoWithReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToVideoWithReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToVideoWithReactions.
     */
    skip?: number
    distinct?: Enumerable<UserToVideoWithReactionScalarFieldEnum>
  }


  /**
   * UserToVideoWithReaction create
   */
  export type UserToVideoWithReactionCreateArgs = {
    /**
     * Select specific fields to fetch from the UserToVideoWithReaction
     */
    select?: UserToVideoWithReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToVideoWithReactionInclude | null
    /**
     * The data needed to create a UserToVideoWithReaction.
     */
    data: XOR<UserToVideoWithReactionCreateInput, UserToVideoWithReactionUncheckedCreateInput>
  }


  /**
   * UserToVideoWithReaction createMany
   */
  export type UserToVideoWithReactionCreateManyArgs = {
    /**
     * The data used to create many UserToVideoWithReactions.
     */
    data: Enumerable<UserToVideoWithReactionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserToVideoWithReaction update
   */
  export type UserToVideoWithReactionUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserToVideoWithReaction
     */
    select?: UserToVideoWithReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToVideoWithReactionInclude | null
    /**
     * The data needed to update a UserToVideoWithReaction.
     */
    data: XOR<UserToVideoWithReactionUpdateInput, UserToVideoWithReactionUncheckedUpdateInput>
    /**
     * Choose, which UserToVideoWithReaction to update.
     */
    where: UserToVideoWithReactionWhereUniqueInput
  }


  /**
   * UserToVideoWithReaction updateMany
   */
  export type UserToVideoWithReactionUpdateManyArgs = {
    /**
     * The data used to update UserToVideoWithReactions.
     */
    data: XOR<UserToVideoWithReactionUpdateManyMutationInput, UserToVideoWithReactionUncheckedUpdateManyInput>
    /**
     * Filter which UserToVideoWithReactions to update
     */
    where?: UserToVideoWithReactionWhereInput
  }


  /**
   * UserToVideoWithReaction upsert
   */
  export type UserToVideoWithReactionUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserToVideoWithReaction
     */
    select?: UserToVideoWithReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToVideoWithReactionInclude | null
    /**
     * The filter to search for the UserToVideoWithReaction to update in case it exists.
     */
    where: UserToVideoWithReactionWhereUniqueInput
    /**
     * In case the UserToVideoWithReaction found by the `where` argument doesn't exist, create a new UserToVideoWithReaction with this data.
     */
    create: XOR<UserToVideoWithReactionCreateInput, UserToVideoWithReactionUncheckedCreateInput>
    /**
     * In case the UserToVideoWithReaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserToVideoWithReactionUpdateInput, UserToVideoWithReactionUncheckedUpdateInput>
  }


  /**
   * UserToVideoWithReaction delete
   */
  export type UserToVideoWithReactionDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserToVideoWithReaction
     */
    select?: UserToVideoWithReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToVideoWithReactionInclude | null
    /**
     * Filter which UserToVideoWithReaction to delete.
     */
    where: UserToVideoWithReactionWhereUniqueInput
  }


  /**
   * UserToVideoWithReaction deleteMany
   */
  export type UserToVideoWithReactionDeleteManyArgs = {
    /**
     * Filter which UserToVideoWithReactions to delete
     */
    where?: UserToVideoWithReactionWhereInput
  }


  /**
   * UserToVideoWithReaction without action
   */
  export type UserToVideoWithReactionArgs = {
    /**
     * Select specific fields to fetch from the UserToVideoWithReaction
     */
    select?: UserToVideoWithReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToVideoWithReactionInclude | null
  }



  /**
   * Model VideoComment
   */


  export type AggregateVideoComment = {
    _count: VideoCommentCountAggregateOutputType | null
    _avg: VideoCommentAvgAggregateOutputType | null
    _sum: VideoCommentSumAggregateOutputType | null
    _min: VideoCommentMinAggregateOutputType | null
    _max: VideoCommentMaxAggregateOutputType | null
  }

  export type VideoCommentAvgAggregateOutputType = {
    id: number | null
    youTubeUserId: number | null
    videoId: number | null
    parentVideoCommentId: number | null
  }

  export type VideoCommentSumAggregateOutputType = {
    id: number | null
    youTubeUserId: number | null
    videoId: number | null
    parentVideoCommentId: number | null
  }

  export type VideoCommentMinAggregateOutputType = {
    id: number | null
    commentText: string | null
    youTubeUserId: number | null
    videoId: number | null
    parentVideoCommentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VideoCommentMaxAggregateOutputType = {
    id: number | null
    commentText: string | null
    youTubeUserId: number | null
    videoId: number | null
    parentVideoCommentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VideoCommentCountAggregateOutputType = {
    id: number
    commentText: number
    youTubeUserId: number
    videoId: number
    parentVideoCommentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VideoCommentAvgAggregateInputType = {
    id?: true
    youTubeUserId?: true
    videoId?: true
    parentVideoCommentId?: true
  }

  export type VideoCommentSumAggregateInputType = {
    id?: true
    youTubeUserId?: true
    videoId?: true
    parentVideoCommentId?: true
  }

  export type VideoCommentMinAggregateInputType = {
    id?: true
    commentText?: true
    youTubeUserId?: true
    videoId?: true
    parentVideoCommentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VideoCommentMaxAggregateInputType = {
    id?: true
    commentText?: true
    youTubeUserId?: true
    videoId?: true
    parentVideoCommentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VideoCommentCountAggregateInputType = {
    id?: true
    commentText?: true
    youTubeUserId?: true
    videoId?: true
    parentVideoCommentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VideoCommentAggregateArgs = {
    /**
     * Filter which VideoComment to aggregate.
     */
    where?: VideoCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoComments to fetch.
     */
    orderBy?: Enumerable<VideoCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VideoCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VideoComments
    **/
    _count?: true | VideoCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VideoCommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VideoCommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideoCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideoCommentMaxAggregateInputType
  }

  export type GetVideoCommentAggregateType<T extends VideoCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateVideoComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideoComment[P]>
      : GetScalarType<T[P], AggregateVideoComment[P]>
  }




  export type VideoCommentGroupByArgs = {
    where?: VideoCommentWhereInput
    orderBy?: Enumerable<VideoCommentOrderByWithAggregationInput>
    by: VideoCommentScalarFieldEnum[]
    having?: VideoCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideoCommentCountAggregateInputType | true
    _avg?: VideoCommentAvgAggregateInputType
    _sum?: VideoCommentSumAggregateInputType
    _min?: VideoCommentMinAggregateInputType
    _max?: VideoCommentMaxAggregateInputType
  }


  export type VideoCommentGroupByOutputType = {
    id: number
    commentText: string
    youTubeUserId: number
    videoId: number
    parentVideoCommentId: number | null
    createdAt: Date
    updatedAt: Date
    _count: VideoCommentCountAggregateOutputType | null
    _avg: VideoCommentAvgAggregateOutputType | null
    _sum: VideoCommentSumAggregateOutputType | null
    _min: VideoCommentMinAggregateOutputType | null
    _max: VideoCommentMaxAggregateOutputType | null
  }

  type GetVideoCommentGroupByPayload<T extends VideoCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<VideoCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideoCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideoCommentGroupByOutputType[P]>
            : GetScalarType<T[P], VideoCommentGroupByOutputType[P]>
        }
      >
    >


  export type VideoCommentSelect = {
    id?: boolean
    commentText?: boolean
    commentingUser?: boolean | YouTubeUserArgs
    youTubeUserId?: boolean
    parentVideo?: boolean | VideoArgs
    videoId?: boolean
    parentVideoComment?: boolean | VideoCommentArgs
    parentVideoCommentId?: boolean
    childVideoComments?: boolean | VideoComment$childVideoCommentsArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | VideoCommentCountOutputTypeArgs
  }


  export type VideoCommentInclude = {
    commentingUser?: boolean | YouTubeUserArgs
    parentVideo?: boolean | VideoArgs
    parentVideoComment?: boolean | VideoCommentArgs
    childVideoComments?: boolean | VideoComment$childVideoCommentsArgs
    _count?: boolean | VideoCommentCountOutputTypeArgs
  }

  export type VideoCommentGetPayload<S extends boolean | null | undefined | VideoCommentArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? VideoComment :
    S extends undefined ? never :
    S extends { include: any } & (VideoCommentArgs | VideoCommentFindManyArgs)
    ? VideoComment  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'commentingUser' ? YouTubeUserGetPayload<S['include'][P]> :
        P extends 'parentVideo' ? VideoGetPayload<S['include'][P]> :
        P extends 'parentVideoComment' ? VideoCommentGetPayload<S['include'][P]> | null :
        P extends 'childVideoComments' ? Array < VideoCommentGetPayload<S['include'][P]>>  :
        P extends '_count' ? VideoCommentCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (VideoCommentArgs | VideoCommentFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'commentingUser' ? YouTubeUserGetPayload<S['select'][P]> :
        P extends 'parentVideo' ? VideoGetPayload<S['select'][P]> :
        P extends 'parentVideoComment' ? VideoCommentGetPayload<S['select'][P]> | null :
        P extends 'childVideoComments' ? Array < VideoCommentGetPayload<S['select'][P]>>  :
        P extends '_count' ? VideoCommentCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof VideoComment ? VideoComment[P] : never
  } 
      : VideoComment


  type VideoCommentCountArgs = 
    Omit<VideoCommentFindManyArgs, 'select' | 'include'> & {
      select?: VideoCommentCountAggregateInputType | true
    }

  export interface VideoCommentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one VideoComment that matches the filter.
     * @param {VideoCommentFindUniqueArgs} args - Arguments to find a VideoComment
     * @example
     * // Get one VideoComment
     * const videoComment = await prisma.videoComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VideoCommentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, VideoCommentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'VideoComment'> extends True ? Prisma__VideoCommentClient<VideoCommentGetPayload<T>> : Prisma__VideoCommentClient<VideoCommentGetPayload<T> | null, null>

    /**
     * Find one VideoComment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {VideoCommentFindUniqueOrThrowArgs} args - Arguments to find a VideoComment
     * @example
     * // Get one VideoComment
     * const videoComment = await prisma.videoComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends VideoCommentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, VideoCommentFindUniqueOrThrowArgs>
    ): Prisma__VideoCommentClient<VideoCommentGetPayload<T>>

    /**
     * Find the first VideoComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCommentFindFirstArgs} args - Arguments to find a VideoComment
     * @example
     * // Get one VideoComment
     * const videoComment = await prisma.videoComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VideoCommentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, VideoCommentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'VideoComment'> extends True ? Prisma__VideoCommentClient<VideoCommentGetPayload<T>> : Prisma__VideoCommentClient<VideoCommentGetPayload<T> | null, null>

    /**
     * Find the first VideoComment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCommentFindFirstOrThrowArgs} args - Arguments to find a VideoComment
     * @example
     * // Get one VideoComment
     * const videoComment = await prisma.videoComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends VideoCommentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, VideoCommentFindFirstOrThrowArgs>
    ): Prisma__VideoCommentClient<VideoCommentGetPayload<T>>

    /**
     * Find zero or more VideoComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VideoComments
     * const videoComments = await prisma.videoComment.findMany()
     * 
     * // Get first 10 VideoComments
     * const videoComments = await prisma.videoComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videoCommentWithIdOnly = await prisma.videoComment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VideoCommentFindManyArgs>(
      args?: SelectSubset<T, VideoCommentFindManyArgs>
    ): Prisma.PrismaPromise<Array<VideoCommentGetPayload<T>>>

    /**
     * Create a VideoComment.
     * @param {VideoCommentCreateArgs} args - Arguments to create a VideoComment.
     * @example
     * // Create one VideoComment
     * const VideoComment = await prisma.videoComment.create({
     *   data: {
     *     // ... data to create a VideoComment
     *   }
     * })
     * 
    **/
    create<T extends VideoCommentCreateArgs>(
      args: SelectSubset<T, VideoCommentCreateArgs>
    ): Prisma__VideoCommentClient<VideoCommentGetPayload<T>>

    /**
     * Create many VideoComments.
     *     @param {VideoCommentCreateManyArgs} args - Arguments to create many VideoComments.
     *     @example
     *     // Create many VideoComments
     *     const videoComment = await prisma.videoComment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VideoCommentCreateManyArgs>(
      args?: SelectSubset<T, VideoCommentCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a VideoComment.
     * @param {VideoCommentDeleteArgs} args - Arguments to delete one VideoComment.
     * @example
     * // Delete one VideoComment
     * const VideoComment = await prisma.videoComment.delete({
     *   where: {
     *     // ... filter to delete one VideoComment
     *   }
     * })
     * 
    **/
    delete<T extends VideoCommentDeleteArgs>(
      args: SelectSubset<T, VideoCommentDeleteArgs>
    ): Prisma__VideoCommentClient<VideoCommentGetPayload<T>>

    /**
     * Update one VideoComment.
     * @param {VideoCommentUpdateArgs} args - Arguments to update one VideoComment.
     * @example
     * // Update one VideoComment
     * const videoComment = await prisma.videoComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VideoCommentUpdateArgs>(
      args: SelectSubset<T, VideoCommentUpdateArgs>
    ): Prisma__VideoCommentClient<VideoCommentGetPayload<T>>

    /**
     * Delete zero or more VideoComments.
     * @param {VideoCommentDeleteManyArgs} args - Arguments to filter VideoComments to delete.
     * @example
     * // Delete a few VideoComments
     * const { count } = await prisma.videoComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VideoCommentDeleteManyArgs>(
      args?: SelectSubset<T, VideoCommentDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VideoComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VideoComments
     * const videoComment = await prisma.videoComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VideoCommentUpdateManyArgs>(
      args: SelectSubset<T, VideoCommentUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VideoComment.
     * @param {VideoCommentUpsertArgs} args - Arguments to update or create a VideoComment.
     * @example
     * // Update or create a VideoComment
     * const videoComment = await prisma.videoComment.upsert({
     *   create: {
     *     // ... data to create a VideoComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VideoComment we want to update
     *   }
     * })
    **/
    upsert<T extends VideoCommentUpsertArgs>(
      args: SelectSubset<T, VideoCommentUpsertArgs>
    ): Prisma__VideoCommentClient<VideoCommentGetPayload<T>>

    /**
     * Count the number of VideoComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCommentCountArgs} args - Arguments to filter VideoComments to count.
     * @example
     * // Count the number of VideoComments
     * const count = await prisma.videoComment.count({
     *   where: {
     *     // ... the filter for the VideoComments we want to count
     *   }
     * })
    **/
    count<T extends VideoCommentCountArgs>(
      args?: Subset<T, VideoCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideoCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VideoComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideoCommentAggregateArgs>(args: Subset<T, VideoCommentAggregateArgs>): Prisma.PrismaPromise<GetVideoCommentAggregateType<T>>

    /**
     * Group by VideoComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideoCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideoCommentGroupByArgs['orderBy'] }
        : { orderBy?: VideoCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideoCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for VideoComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VideoCommentClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    commentingUser<T extends YouTubeUserArgs= {}>(args?: Subset<T, YouTubeUserArgs>): Prisma__YouTubeUserClient<YouTubeUserGetPayload<T> | Null>;

    parentVideo<T extends VideoArgs= {}>(args?: Subset<T, VideoArgs>): Prisma__VideoClient<VideoGetPayload<T> | Null>;

    parentVideoComment<T extends VideoCommentArgs= {}>(args?: Subset<T, VideoCommentArgs>): Prisma__VideoCommentClient<VideoCommentGetPayload<T> | Null>;

    childVideoComments<T extends VideoComment$childVideoCommentsArgs= {}>(args?: Subset<T, VideoComment$childVideoCommentsArgs>): Prisma.PrismaPromise<Array<VideoCommentGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * VideoComment base type for findUnique actions
   */
  export type VideoCommentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the VideoComment
     */
    select?: VideoCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoCommentInclude | null
    /**
     * Filter, which VideoComment to fetch.
     */
    where: VideoCommentWhereUniqueInput
  }

  /**
   * VideoComment findUnique
   */
  export interface VideoCommentFindUniqueArgs extends VideoCommentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * VideoComment findUniqueOrThrow
   */
  export type VideoCommentFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the VideoComment
     */
    select?: VideoCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoCommentInclude | null
    /**
     * Filter, which VideoComment to fetch.
     */
    where: VideoCommentWhereUniqueInput
  }


  /**
   * VideoComment base type for findFirst actions
   */
  export type VideoCommentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the VideoComment
     */
    select?: VideoCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoCommentInclude | null
    /**
     * Filter, which VideoComment to fetch.
     */
    where?: VideoCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoComments to fetch.
     */
    orderBy?: Enumerable<VideoCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoComments.
     */
    cursor?: VideoCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoComments.
     */
    distinct?: Enumerable<VideoCommentScalarFieldEnum>
  }

  /**
   * VideoComment findFirst
   */
  export interface VideoCommentFindFirstArgs extends VideoCommentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * VideoComment findFirstOrThrow
   */
  export type VideoCommentFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the VideoComment
     */
    select?: VideoCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoCommentInclude | null
    /**
     * Filter, which VideoComment to fetch.
     */
    where?: VideoCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoComments to fetch.
     */
    orderBy?: Enumerable<VideoCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoComments.
     */
    cursor?: VideoCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoComments.
     */
    distinct?: Enumerable<VideoCommentScalarFieldEnum>
  }


  /**
   * VideoComment findMany
   */
  export type VideoCommentFindManyArgs = {
    /**
     * Select specific fields to fetch from the VideoComment
     */
    select?: VideoCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoCommentInclude | null
    /**
     * Filter, which VideoComments to fetch.
     */
    where?: VideoCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoComments to fetch.
     */
    orderBy?: Enumerable<VideoCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VideoComments.
     */
    cursor?: VideoCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoComments.
     */
    skip?: number
    distinct?: Enumerable<VideoCommentScalarFieldEnum>
  }


  /**
   * VideoComment create
   */
  export type VideoCommentCreateArgs = {
    /**
     * Select specific fields to fetch from the VideoComment
     */
    select?: VideoCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoCommentInclude | null
    /**
     * The data needed to create a VideoComment.
     */
    data: XOR<VideoCommentCreateInput, VideoCommentUncheckedCreateInput>
  }


  /**
   * VideoComment createMany
   */
  export type VideoCommentCreateManyArgs = {
    /**
     * The data used to create many VideoComments.
     */
    data: Enumerable<VideoCommentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * VideoComment update
   */
  export type VideoCommentUpdateArgs = {
    /**
     * Select specific fields to fetch from the VideoComment
     */
    select?: VideoCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoCommentInclude | null
    /**
     * The data needed to update a VideoComment.
     */
    data: XOR<VideoCommentUpdateInput, VideoCommentUncheckedUpdateInput>
    /**
     * Choose, which VideoComment to update.
     */
    where: VideoCommentWhereUniqueInput
  }


  /**
   * VideoComment updateMany
   */
  export type VideoCommentUpdateManyArgs = {
    /**
     * The data used to update VideoComments.
     */
    data: XOR<VideoCommentUpdateManyMutationInput, VideoCommentUncheckedUpdateManyInput>
    /**
     * Filter which VideoComments to update
     */
    where?: VideoCommentWhereInput
  }


  /**
   * VideoComment upsert
   */
  export type VideoCommentUpsertArgs = {
    /**
     * Select specific fields to fetch from the VideoComment
     */
    select?: VideoCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoCommentInclude | null
    /**
     * The filter to search for the VideoComment to update in case it exists.
     */
    where: VideoCommentWhereUniqueInput
    /**
     * In case the VideoComment found by the `where` argument doesn't exist, create a new VideoComment with this data.
     */
    create: XOR<VideoCommentCreateInput, VideoCommentUncheckedCreateInput>
    /**
     * In case the VideoComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VideoCommentUpdateInput, VideoCommentUncheckedUpdateInput>
  }


  /**
   * VideoComment delete
   */
  export type VideoCommentDeleteArgs = {
    /**
     * Select specific fields to fetch from the VideoComment
     */
    select?: VideoCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoCommentInclude | null
    /**
     * Filter which VideoComment to delete.
     */
    where: VideoCommentWhereUniqueInput
  }


  /**
   * VideoComment deleteMany
   */
  export type VideoCommentDeleteManyArgs = {
    /**
     * Filter which VideoComments to delete
     */
    where?: VideoCommentWhereInput
  }


  /**
   * VideoComment.childVideoComments
   */
  export type VideoComment$childVideoCommentsArgs = {
    /**
     * Select specific fields to fetch from the VideoComment
     */
    select?: VideoCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoCommentInclude | null
    where?: VideoCommentWhereInput
    orderBy?: Enumerable<VideoCommentOrderByWithRelationInput>
    cursor?: VideoCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<VideoCommentScalarFieldEnum>
  }


  /**
   * VideoComment without action
   */
  export type VideoCommentArgs = {
    /**
     * Select specific fields to fetch from the VideoComment
     */
    select?: VideoCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoCommentInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const ChannelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    profileImageUrl: 'profileImageUrl',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChannelScalarFieldEnum = (typeof ChannelScalarFieldEnum)[keyof typeof ChannelScalarFieldEnum]


  export const ChoiceScalarFieldEnum: {
    id: 'id',
    answerText: 'answerText',
    quizId: 'quizId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChoiceScalarFieldEnum = (typeof ChoiceScalarFieldEnum)[keyof typeof ChoiceScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    commentText: 'commentText',
    userId: 'userId',
    postId: 'postId',
    parentCommentId: 'parentCommentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const DirectMessageScalarFieldEnum: {
    id: 'id',
    dmText: 'dmText',
    fromUserId: 'fromUserId',
    toUserId: 'toUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DirectMessageScalarFieldEnum = (typeof DirectMessageScalarFieldEnum)[keyof typeof DirectMessageScalarFieldEnum]


  export const FacebookHashTagScalarFieldEnum: {
    id: 'id',
    hashTagText: 'hashTagText',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FacebookHashTagScalarFieldEnum = (typeof FacebookHashTagScalarFieldEnum)[keyof typeof FacebookHashTagScalarFieldEnum]


  export const FacebookUserRelationScalarFieldEnum: {
    id: 'id',
    followingUserId: 'followingUserId',
    followedUserId: 'followedUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FacebookUserRelationScalarFieldEnum = (typeof FacebookUserRelationScalarFieldEnum)[keyof typeof FacebookUserRelationScalarFieldEnum]


  export const FacebookUserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    imageUrl: 'imageUrl',
    bio: 'bio',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FacebookUserScalarFieldEnum = (typeof FacebookUserScalarFieldEnum)[keyof typeof FacebookUserScalarFieldEnum]


  export const HashTagScalarFieldEnum: {
    id: 'id',
    hashTagText: 'hashTagText',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HashTagScalarFieldEnum = (typeof HashTagScalarFieldEnum)[keyof typeof HashTagScalarFieldEnum]


  export const MenuScalarFieldEnum: {
    id: 'id',
    name: 'name',
    image: 'image',
    price: 'price',
    categoryId: 'categoryId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MenuScalarFieldEnum = (typeof MenuScalarFieldEnum)[keyof typeof MenuScalarFieldEnum]


  export const MessengerMessageScalarFieldEnum: {
    id: 'id',
    messengerText: 'messengerText',
    fromUserId: 'fromUserId',
    toUserId: 'toUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MessengerMessageScalarFieldEnum = (typeof MessengerMessageScalarFieldEnum)[keyof typeof MessengerMessageScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    id: 'id',
    menuId: 'menuId',
    orderId: 'orderId',
    quantity: 'quantity',
    totalPrice: 'totalPrice',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    status: 'status',
    tableId: 'tableId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const PostScalarFieldEnum: {
    id: 'id',
    postText: 'postText',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const QuizCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuizCategoryScalarFieldEnum = (typeof QuizCategoryScalarFieldEnum)[keyof typeof QuizCategoryScalarFieldEnum]


  export const QuizScalarFieldEnum: {
    id: 'id',
    questionText: 'questionText',
    quizCategoryId: 'quizCategoryId',
    correctChoiceId: 'correctChoiceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuizScalarFieldEnum = (typeof QuizScalarFieldEnum)[keyof typeof QuizScalarFieldEnum]


  export const RoundScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoundScalarFieldEnum = (typeof RoundScalarFieldEnum)[keyof typeof RoundScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const TodoListScalarFieldEnum: {
    id: 'id',
    task: 'task',
    status: 'status',
    bgColor: 'bgColor',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TodoListScalarFieldEnum = (typeof TodoListScalarFieldEnum)[keyof typeof TodoListScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TweetScalarFieldEnum: {
    id: 'id',
    tweetText: 'tweetText',
    parentTweetId: 'parentTweetId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TweetScalarFieldEnum = (typeof TweetScalarFieldEnum)[keyof typeof TweetScalarFieldEnum]


  export const UserRelationScalarFieldEnum: {
    id: 'id',
    followingUserId: 'followingUserId',
    followedUserId: 'followedUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserRelationScalarFieldEnum = (typeof UserRelationScalarFieldEnum)[keyof typeof UserRelationScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    imageUrl: 'imageUrl',
    bio: 'bio',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserToChannelwithRoleScalarFieldEnum: {
    id: 'id',
    youTubeUserId: 'youTubeUserId',
    channelId: 'channelId',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserToChannelwithRoleScalarFieldEnum = (typeof UserToChannelwithRoleScalarFieldEnum)[keyof typeof UserToChannelwithRoleScalarFieldEnum]


  export const UserToVideoWithReactionScalarFieldEnum: {
    id: 'id',
    youTubeUserId: 'youTubeUserId',
    videoId: 'videoId',
    reaction: 'reaction',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserToVideoWithReactionScalarFieldEnum = (typeof UserToVideoWithReactionScalarFieldEnum)[keyof typeof UserToVideoWithReactionScalarFieldEnum]


  export const VideoCommentScalarFieldEnum: {
    id: 'id',
    commentText: 'commentText',
    youTubeUserId: 'youTubeUserId',
    videoId: 'videoId',
    parentVideoCommentId: 'parentVideoCommentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VideoCommentScalarFieldEnum = (typeof VideoCommentScalarFieldEnum)[keyof typeof VideoCommentScalarFieldEnum]


  export const VideoScalarFieldEnum: {
    id: 'id',
    title: 'title',
    videoUrl: 'videoUrl',
    thumbnailImageUrl: 'thumbnailImageUrl',
    description: 'description',
    channelId: 'channelId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VideoScalarFieldEnum = (typeof VideoScalarFieldEnum)[keyof typeof VideoScalarFieldEnum]


  export const YouTubeUserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    profileImageUrl: 'profileImageUrl',
    bio: 'bio',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type YouTubeUserScalarFieldEnum = (typeof YouTubeUserScalarFieldEnum)[keyof typeof YouTubeUserScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type CategoryWhereInput = {
    AND?: Enumerable<CategoryWhereInput>
    OR?: Enumerable<CategoryWhereInput>
    NOT?: Enumerable<CategoryWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    Menu?: MenuListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Menu?: MenuOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = {
    id?: number
  }

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<CategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CategoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type MenuWhereInput = {
    AND?: Enumerable<MenuWhereInput>
    OR?: Enumerable<MenuWhereInput>
    NOT?: Enumerable<MenuWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    image?: StringFilter | string
    price?: FloatFilter | number
    category?: XOR<CategoryRelationFilter, CategoryWhereInput> | null
    categoryId?: IntNullableFilter | number | null
    orderItems?: OrderItemListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type MenuOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    price?: SortOrder
    category?: CategoryOrderByWithRelationInput
    categoryId?: SortOrder
    orderItems?: OrderItemOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuWhereUniqueInput = {
    id?: number
  }

  export type MenuOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    price?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MenuCountOrderByAggregateInput
    _avg?: MenuAvgOrderByAggregateInput
    _max?: MenuMaxOrderByAggregateInput
    _min?: MenuMinOrderByAggregateInput
    _sum?: MenuSumOrderByAggregateInput
  }

  export type MenuScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MenuScalarWhereWithAggregatesInput>
    OR?: Enumerable<MenuScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MenuScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    image?: StringWithAggregatesFilter | string
    price?: FloatWithAggregatesFilter | number
    categoryId?: IntNullableWithAggregatesFilter | number | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type OrderWhereInput = {
    AND?: Enumerable<OrderWhereInput>
    OR?: Enumerable<OrderWhereInput>
    NOT?: Enumerable<OrderWhereInput>
    id?: IntFilter | number
    status?: StringFilter | string
    tableId?: IntFilter | number
    items?: OrderItemListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    tableId?: SortOrder
    items?: OrderItemOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderWhereUniqueInput = {
    id?: number
  }

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    tableId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OrderScalarWhereWithAggregatesInput>
    OR?: Enumerable<OrderScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OrderScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    status?: StringWithAggregatesFilter | string
    tableId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type OrderItemWhereInput = {
    AND?: Enumerable<OrderItemWhereInput>
    OR?: Enumerable<OrderItemWhereInput>
    NOT?: Enumerable<OrderItemWhereInput>
    id?: IntFilter | number
    menu?: XOR<MenuRelationFilter, MenuWhereInput>
    menuId?: IntFilter | number
    order?: XOR<OrderRelationFilter, OrderWhereInput> | null
    orderId?: IntNullableFilter | number | null
    quantity?: IntFilter | number
    totalPrice?: FloatFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder
    menu?: MenuOrderByWithRelationInput
    menuId?: SortOrder
    order?: OrderOrderByWithRelationInput
    orderId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderItemWhereUniqueInput = {
    id?: number
  }

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    menuId?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderItemCountOrderByAggregateInput
    _avg?: OrderItemAvgOrderByAggregateInput
    _max?: OrderItemMaxOrderByAggregateInput
    _min?: OrderItemMinOrderByAggregateInput
    _sum?: OrderItemSumOrderByAggregateInput
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OrderItemScalarWhereWithAggregatesInput>
    OR?: Enumerable<OrderItemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OrderItemScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    menuId?: IntWithAggregatesFilter | number
    orderId?: IntNullableWithAggregatesFilter | number | null
    quantity?: IntWithAggregatesFilter | number
    totalPrice?: FloatWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type QuizCategoryWhereInput = {
    AND?: Enumerable<QuizCategoryWhereInput>
    OR?: Enumerable<QuizCategoryWhereInput>
    NOT?: Enumerable<QuizCategoryWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    quizzes?: QuizListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type QuizCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    quizzes?: QuizOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizCategoryWhereUniqueInput = {
    id?: number
  }

  export type QuizCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuizCategoryCountOrderByAggregateInput
    _avg?: QuizCategoryAvgOrderByAggregateInput
    _max?: QuizCategoryMaxOrderByAggregateInput
    _min?: QuizCategoryMinOrderByAggregateInput
    _sum?: QuizCategorySumOrderByAggregateInput
  }

  export type QuizCategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<QuizCategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<QuizCategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<QuizCategoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ChoiceWhereInput = {
    AND?: Enumerable<ChoiceWhereInput>
    OR?: Enumerable<ChoiceWhereInput>
    NOT?: Enumerable<ChoiceWhereInput>
    id?: IntFilter | number
    answerText?: StringFilter | string
    quiz?: XOR<QuizRelationFilter, QuizWhereInput> | null
    quizId?: IntNullableFilter | number | null
    correctQuizzes?: QuizListRelationFilter
    rounds?: RoundListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ChoiceOrderByWithRelationInput = {
    id?: SortOrder
    answerText?: SortOrder
    quiz?: QuizOrderByWithRelationInput
    quizId?: SortOrder
    correctQuizzes?: QuizOrderByRelationAggregateInput
    rounds?: RoundOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChoiceWhereUniqueInput = {
    id?: number
  }

  export type ChoiceOrderByWithAggregationInput = {
    id?: SortOrder
    answerText?: SortOrder
    quizId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChoiceCountOrderByAggregateInput
    _avg?: ChoiceAvgOrderByAggregateInput
    _max?: ChoiceMaxOrderByAggregateInput
    _min?: ChoiceMinOrderByAggregateInput
    _sum?: ChoiceSumOrderByAggregateInput
  }

  export type ChoiceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ChoiceScalarWhereWithAggregatesInput>
    OR?: Enumerable<ChoiceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ChoiceScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    answerText?: StringWithAggregatesFilter | string
    quizId?: IntNullableWithAggregatesFilter | number | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type QuizWhereInput = {
    AND?: Enumerable<QuizWhereInput>
    OR?: Enumerable<QuizWhereInput>
    NOT?: Enumerable<QuizWhereInput>
    id?: IntFilter | number
    questionText?: StringFilter | string
    category?: XOR<QuizCategoryRelationFilter, QuizCategoryWhereInput>
    quizCategoryId?: IntFilter | number
    choices?: ChoiceListRelationFilter
    correctChoice?: XOR<ChoiceRelationFilter, ChoiceWhereInput>
    correctChoiceId?: IntFilter | number
    rounds?: RoundListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type QuizOrderByWithRelationInput = {
    id?: SortOrder
    questionText?: SortOrder
    category?: QuizCategoryOrderByWithRelationInput
    quizCategoryId?: SortOrder
    choices?: ChoiceOrderByRelationAggregateInput
    correctChoice?: ChoiceOrderByWithRelationInput
    correctChoiceId?: SortOrder
    rounds?: RoundOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizWhereUniqueInput = {
    id?: number
  }

  export type QuizOrderByWithAggregationInput = {
    id?: SortOrder
    questionText?: SortOrder
    quizCategoryId?: SortOrder
    correctChoiceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuizCountOrderByAggregateInput
    _avg?: QuizAvgOrderByAggregateInput
    _max?: QuizMaxOrderByAggregateInput
    _min?: QuizMinOrderByAggregateInput
    _sum?: QuizSumOrderByAggregateInput
  }

  export type QuizScalarWhereWithAggregatesInput = {
    AND?: Enumerable<QuizScalarWhereWithAggregatesInput>
    OR?: Enumerable<QuizScalarWhereWithAggregatesInput>
    NOT?: Enumerable<QuizScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    questionText?: StringWithAggregatesFilter | string
    quizCategoryId?: IntWithAggregatesFilter | number
    correctChoiceId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type RoundWhereInput = {
    AND?: Enumerable<RoundWhereInput>
    OR?: Enumerable<RoundWhereInput>
    NOT?: Enumerable<RoundWhereInput>
    id?: IntFilter | number
    quizzes?: QuizListRelationFilter
    selectedChoices?: ChoiceListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type RoundOrderByWithRelationInput = {
    id?: SortOrder
    quizzes?: QuizOrderByRelationAggregateInput
    selectedChoices?: ChoiceOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoundWhereUniqueInput = {
    id?: number
  }

  export type RoundOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoundCountOrderByAggregateInput
    _avg?: RoundAvgOrderByAggregateInput
    _max?: RoundMaxOrderByAggregateInput
    _min?: RoundMinOrderByAggregateInput
    _sum?: RoundSumOrderByAggregateInput
  }

  export type RoundScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RoundScalarWhereWithAggregatesInput>
    OR?: Enumerable<RoundScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RoundScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FacebookUserWhereInput = {
    AND?: Enumerable<FacebookUserWhereInput>
    OR?: Enumerable<FacebookUserWhereInput>
    NOT?: Enumerable<FacebookUserWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    imageUrl?: StringFilter | string
    bio?: StringFilter | string
    followingUserRelations?: FacebookUserRelationListRelationFilter
    followedUserRelations?: FacebookUserRelationListRelationFilter
    posts?: PostListRelationFilter
    comments?: CommentListRelationFilter
    messengerMessagesFrom?: MessengerMessageListRelationFilter
    messengerMessagesTo?: MessengerMessageListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type FacebookUserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    bio?: SortOrder
    followingUserRelations?: FacebookUserRelationOrderByRelationAggregateInput
    followedUserRelations?: FacebookUserRelationOrderByRelationAggregateInput
    posts?: PostOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    messengerMessagesFrom?: MessengerMessageOrderByRelationAggregateInput
    messengerMessagesTo?: MessengerMessageOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookUserWhereUniqueInput = {
    id?: number
  }

  export type FacebookUserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FacebookUserCountOrderByAggregateInput
    _avg?: FacebookUserAvgOrderByAggregateInput
    _max?: FacebookUserMaxOrderByAggregateInput
    _min?: FacebookUserMinOrderByAggregateInput
    _sum?: FacebookUserSumOrderByAggregateInput
  }

  export type FacebookUserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FacebookUserScalarWhereWithAggregatesInput>
    OR?: Enumerable<FacebookUserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FacebookUserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    imageUrl?: StringWithAggregatesFilter | string
    bio?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FacebookUserRelationWhereInput = {
    AND?: Enumerable<FacebookUserRelationWhereInput>
    OR?: Enumerable<FacebookUserRelationWhereInput>
    NOT?: Enumerable<FacebookUserRelationWhereInput>
    id?: IntFilter | number
    followingUser?: XOR<FacebookUserRelationFilter, FacebookUserWhereInput>
    followingUserId?: IntFilter | number
    followedUser?: XOR<FacebookUserRelationFilter, FacebookUserWhereInput>
    followedUserId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type FacebookUserRelationOrderByWithRelationInput = {
    id?: SortOrder
    followingUser?: FacebookUserOrderByWithRelationInput
    followingUserId?: SortOrder
    followedUser?: FacebookUserOrderByWithRelationInput
    followedUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookUserRelationWhereUniqueInput = {
    id?: number
  }

  export type FacebookUserRelationOrderByWithAggregationInput = {
    id?: SortOrder
    followingUserId?: SortOrder
    followedUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FacebookUserRelationCountOrderByAggregateInput
    _avg?: FacebookUserRelationAvgOrderByAggregateInput
    _max?: FacebookUserRelationMaxOrderByAggregateInput
    _min?: FacebookUserRelationMinOrderByAggregateInput
    _sum?: FacebookUserRelationSumOrderByAggregateInput
  }

  export type FacebookUserRelationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FacebookUserRelationScalarWhereWithAggregatesInput>
    OR?: Enumerable<FacebookUserRelationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FacebookUserRelationScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    followingUserId?: IntWithAggregatesFilter | number
    followedUserId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type PostWhereInput = {
    AND?: Enumerable<PostWhereInput>
    OR?: Enumerable<PostWhereInput>
    NOT?: Enumerable<PostWhereInput>
    id?: IntFilter | number
    postText?: StringFilter | string
    postingUser?: XOR<FacebookUserRelationFilter, FacebookUserWhereInput>
    userId?: IntFilter | number
    comments?: CommentListRelationFilter
    hashTags?: FacebookHashTagListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type PostOrderByWithRelationInput = {
    id?: SortOrder
    postText?: SortOrder
    postingUser?: FacebookUserOrderByWithRelationInput
    userId?: SortOrder
    comments?: CommentOrderByRelationAggregateInput
    hashTags?: FacebookHashTagOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostWhereUniqueInput = {
    id?: number
  }

  export type PostOrderByWithAggregationInput = {
    id?: SortOrder
    postText?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PostCountOrderByAggregateInput
    _avg?: PostAvgOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
    _sum?: PostSumOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PostScalarWhereWithAggregatesInput>
    OR?: Enumerable<PostScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PostScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    postText?: StringWithAggregatesFilter | string
    userId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CommentWhereInput = {
    AND?: Enumerable<CommentWhereInput>
    OR?: Enumerable<CommentWhereInput>
    NOT?: Enumerable<CommentWhereInput>
    id?: IntFilter | number
    commentText?: StringFilter | string
    commentingUser?: XOR<FacebookUserRelationFilter, FacebookUserWhereInput>
    userId?: IntFilter | number
    parentPost?: XOR<PostRelationFilter, PostWhereInput>
    postId?: IntFilter | number
    parentComment?: XOR<CommentRelationFilter, CommentWhereInput> | null
    parentCommentId?: IntNullableFilter | number | null
    childComments?: CommentListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    commentText?: SortOrder
    commentingUser?: FacebookUserOrderByWithRelationInput
    userId?: SortOrder
    parentPost?: PostOrderByWithRelationInput
    postId?: SortOrder
    parentComment?: CommentOrderByWithRelationInput
    parentCommentId?: SortOrder
    childComments?: CommentOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentWhereUniqueInput = {
    id?: number
  }

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    commentText?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    parentCommentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _avg?: CommentAvgOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
    _sum?: CommentSumOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CommentScalarWhereWithAggregatesInput>
    OR?: Enumerable<CommentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CommentScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    commentText?: StringWithAggregatesFilter | string
    userId?: IntWithAggregatesFilter | number
    postId?: IntWithAggregatesFilter | number
    parentCommentId?: IntNullableWithAggregatesFilter | number | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FacebookHashTagWhereInput = {
    AND?: Enumerable<FacebookHashTagWhereInput>
    OR?: Enumerable<FacebookHashTagWhereInput>
    NOT?: Enumerable<FacebookHashTagWhereInput>
    id?: IntFilter | number
    hashTagText?: StringFilter | string
    isInPosts?: PostListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type FacebookHashTagOrderByWithRelationInput = {
    id?: SortOrder
    hashTagText?: SortOrder
    isInPosts?: PostOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookHashTagWhereUniqueInput = {
    id?: number
  }

  export type FacebookHashTagOrderByWithAggregationInput = {
    id?: SortOrder
    hashTagText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FacebookHashTagCountOrderByAggregateInput
    _avg?: FacebookHashTagAvgOrderByAggregateInput
    _max?: FacebookHashTagMaxOrderByAggregateInput
    _min?: FacebookHashTagMinOrderByAggregateInput
    _sum?: FacebookHashTagSumOrderByAggregateInput
  }

  export type FacebookHashTagScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FacebookHashTagScalarWhereWithAggregatesInput>
    OR?: Enumerable<FacebookHashTagScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FacebookHashTagScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    hashTagText?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type MessengerMessageWhereInput = {
    AND?: Enumerable<MessengerMessageWhereInput>
    OR?: Enumerable<MessengerMessageWhereInput>
    NOT?: Enumerable<MessengerMessageWhereInput>
    id?: IntFilter | number
    messengerText?: StringFilter | string
    fromUser?: XOR<FacebookUserRelationFilter, FacebookUserWhereInput>
    toUser?: XOR<FacebookUserRelationFilter, FacebookUserWhereInput>
    fromUserId?: IntFilter | number
    toUserId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type MessengerMessageOrderByWithRelationInput = {
    id?: SortOrder
    messengerText?: SortOrder
    fromUser?: FacebookUserOrderByWithRelationInput
    toUser?: FacebookUserOrderByWithRelationInput
    fromUserId?: SortOrder
    toUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessengerMessageWhereUniqueInput = {
    id?: number
  }

  export type MessengerMessageOrderByWithAggregationInput = {
    id?: SortOrder
    messengerText?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MessengerMessageCountOrderByAggregateInput
    _avg?: MessengerMessageAvgOrderByAggregateInput
    _max?: MessengerMessageMaxOrderByAggregateInput
    _min?: MessengerMessageMinOrderByAggregateInput
    _sum?: MessengerMessageSumOrderByAggregateInput
  }

  export type MessengerMessageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MessengerMessageScalarWhereWithAggregatesInput>
    OR?: Enumerable<MessengerMessageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MessengerMessageScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    messengerText?: StringWithAggregatesFilter | string
    fromUserId?: IntWithAggregatesFilter | number
    toUserId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TodoListWhereInput = {
    AND?: Enumerable<TodoListWhereInput>
    OR?: Enumerable<TodoListWhereInput>
    NOT?: Enumerable<TodoListWhereInput>
    id?: IntFilter | number
    task?: StringFilter | string
    status?: StringFilter | string
    bgColor?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TodoListOrderByWithRelationInput = {
    id?: SortOrder
    task?: SortOrder
    status?: SortOrder
    bgColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TodoListWhereUniqueInput = {
    id?: number
  }

  export type TodoListOrderByWithAggregationInput = {
    id?: SortOrder
    task?: SortOrder
    status?: SortOrder
    bgColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TodoListCountOrderByAggregateInput
    _avg?: TodoListAvgOrderByAggregateInput
    _max?: TodoListMaxOrderByAggregateInput
    _min?: TodoListMinOrderByAggregateInput
    _sum?: TodoListSumOrderByAggregateInput
  }

  export type TodoListScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TodoListScalarWhereWithAggregatesInput>
    OR?: Enumerable<TodoListScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TodoListScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    task?: StringWithAggregatesFilter | string
    status?: StringWithAggregatesFilter | string
    bgColor?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    imageUrl?: StringFilter | string
    bio?: StringFilter | string
    followingUserRelations?: UserRelationListRelationFilter
    followedUserRelations?: UserRelationListRelationFilter
    tweets?: TweetListRelationFilter
    directMessagesFrom?: DirectMessageListRelationFilter
    directMessagesTo?: DirectMessageListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    bio?: SortOrder
    followingUserRelations?: UserRelationOrderByRelationAggregateInput
    followedUserRelations?: UserRelationOrderByRelationAggregateInput
    tweets?: TweetOrderByRelationAggregateInput
    directMessagesFrom?: DirectMessageOrderByRelationAggregateInput
    directMessagesTo?: DirectMessageOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserWhereUniqueInput = {
    id?: number
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    imageUrl?: StringWithAggregatesFilter | string
    bio?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserRelationWhereInput = {
    AND?: Enumerable<UserRelationWhereInput>
    OR?: Enumerable<UserRelationWhereInput>
    NOT?: Enumerable<UserRelationWhereInput>
    id?: IntFilter | number
    followingUser?: XOR<UserRelationFilter, UserWhereInput>
    followingUserId?: IntFilter | number
    followedUser?: XOR<UserRelationFilter, UserWhereInput>
    followedUserId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type UserRelationOrderByWithRelationInput = {
    id?: SortOrder
    followingUser?: UserOrderByWithRelationInput
    followingUserId?: SortOrder
    followedUser?: UserOrderByWithRelationInput
    followedUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserRelationWhereUniqueInput = {
    id?: number
  }

  export type UserRelationOrderByWithAggregationInput = {
    id?: SortOrder
    followingUserId?: SortOrder
    followedUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserRelationCountOrderByAggregateInput
    _avg?: UserRelationAvgOrderByAggregateInput
    _max?: UserRelationMaxOrderByAggregateInput
    _min?: UserRelationMinOrderByAggregateInput
    _sum?: UserRelationSumOrderByAggregateInput
  }

  export type UserRelationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserRelationScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserRelationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserRelationScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    followingUserId?: IntWithAggregatesFilter | number
    followedUserId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TweetWhereInput = {
    AND?: Enumerable<TweetWhereInput>
    OR?: Enumerable<TweetWhereInput>
    NOT?: Enumerable<TweetWhereInput>
    id?: IntFilter | number
    tweetText?: StringFilter | string
    tweetingUser?: XOR<UserRelationFilter, UserWhereInput>
    parentTweet?: XOR<TweetRelationFilter, TweetWhereInput> | null
    parentTweetId?: IntNullableFilter | number | null
    childTweets?: TweetListRelationFilter
    userId?: IntFilter | number
    hashTags?: HashTagListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TweetOrderByWithRelationInput = {
    id?: SortOrder
    tweetText?: SortOrder
    tweetingUser?: UserOrderByWithRelationInput
    parentTweet?: TweetOrderByWithRelationInput
    parentTweetId?: SortOrder
    childTweets?: TweetOrderByRelationAggregateInput
    userId?: SortOrder
    hashTags?: HashTagOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TweetWhereUniqueInput = {
    id?: number
  }

  export type TweetOrderByWithAggregationInput = {
    id?: SortOrder
    tweetText?: SortOrder
    parentTweetId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TweetCountOrderByAggregateInput
    _avg?: TweetAvgOrderByAggregateInput
    _max?: TweetMaxOrderByAggregateInput
    _min?: TweetMinOrderByAggregateInput
    _sum?: TweetSumOrderByAggregateInput
  }

  export type TweetScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TweetScalarWhereWithAggregatesInput>
    OR?: Enumerable<TweetScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TweetScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    tweetText?: StringWithAggregatesFilter | string
    parentTweetId?: IntNullableWithAggregatesFilter | number | null
    userId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type HashTagWhereInput = {
    AND?: Enumerable<HashTagWhereInput>
    OR?: Enumerable<HashTagWhereInput>
    NOT?: Enumerable<HashTagWhereInput>
    id?: IntFilter | number
    hashTagText?: StringFilter | string
    isInTweets?: TweetListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type HashTagOrderByWithRelationInput = {
    id?: SortOrder
    hashTagText?: SortOrder
    isInTweets?: TweetOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HashTagWhereUniqueInput = {
    id?: number
  }

  export type HashTagOrderByWithAggregationInput = {
    id?: SortOrder
    hashTagText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HashTagCountOrderByAggregateInput
    _avg?: HashTagAvgOrderByAggregateInput
    _max?: HashTagMaxOrderByAggregateInput
    _min?: HashTagMinOrderByAggregateInput
    _sum?: HashTagSumOrderByAggregateInput
  }

  export type HashTagScalarWhereWithAggregatesInput = {
    AND?: Enumerable<HashTagScalarWhereWithAggregatesInput>
    OR?: Enumerable<HashTagScalarWhereWithAggregatesInput>
    NOT?: Enumerable<HashTagScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    hashTagText?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type DirectMessageWhereInput = {
    AND?: Enumerable<DirectMessageWhereInput>
    OR?: Enumerable<DirectMessageWhereInput>
    NOT?: Enumerable<DirectMessageWhereInput>
    id?: IntFilter | number
    dmText?: StringFilter | string
    fromUser?: XOR<UserRelationFilter, UserWhereInput>
    toUser?: XOR<UserRelationFilter, UserWhereInput>
    fromUserId?: IntFilter | number
    toUserId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type DirectMessageOrderByWithRelationInput = {
    id?: SortOrder
    dmText?: SortOrder
    fromUser?: UserOrderByWithRelationInput
    toUser?: UserOrderByWithRelationInput
    fromUserId?: SortOrder
    toUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DirectMessageWhereUniqueInput = {
    id?: number
  }

  export type DirectMessageOrderByWithAggregationInput = {
    id?: SortOrder
    dmText?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DirectMessageCountOrderByAggregateInput
    _avg?: DirectMessageAvgOrderByAggregateInput
    _max?: DirectMessageMaxOrderByAggregateInput
    _min?: DirectMessageMinOrderByAggregateInput
    _sum?: DirectMessageSumOrderByAggregateInput
  }

  export type DirectMessageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DirectMessageScalarWhereWithAggregatesInput>
    OR?: Enumerable<DirectMessageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DirectMessageScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    dmText?: StringWithAggregatesFilter | string
    fromUserId?: IntWithAggregatesFilter | number
    toUserId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type YouTubeUserWhereInput = {
    AND?: Enumerable<YouTubeUserWhereInput>
    OR?: Enumerable<YouTubeUserWhereInput>
    NOT?: Enumerable<YouTubeUserWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    profileImageUrl?: StringNullableFilter | string | null
    bio?: StringNullableFilter | string | null
    adminOfChannels?: ChannelListRelationFilter
    usersToChannelswithRoles?: UserToChannelwithRoleListRelationFilter
    subscribingToChannels?: ChannelListRelationFilter
    reactedVideos?: VideoListRelationFilter
    usersToVideosWithReactions?: UserToVideoWithReactionListRelationFilter
    videoComments?: VideoCommentListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type YouTubeUserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    profileImageUrl?: SortOrder
    bio?: SortOrder
    adminOfChannels?: ChannelOrderByRelationAggregateInput
    usersToChannelswithRoles?: UserToChannelwithRoleOrderByRelationAggregateInput
    subscribingToChannels?: ChannelOrderByRelationAggregateInput
    reactedVideos?: VideoOrderByRelationAggregateInput
    usersToVideosWithReactions?: UserToVideoWithReactionOrderByRelationAggregateInput
    videoComments?: VideoCommentOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YouTubeUserWhereUniqueInput = {
    id?: number
  }

  export type YouTubeUserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    profileImageUrl?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: YouTubeUserCountOrderByAggregateInput
    _avg?: YouTubeUserAvgOrderByAggregateInput
    _max?: YouTubeUserMaxOrderByAggregateInput
    _min?: YouTubeUserMinOrderByAggregateInput
    _sum?: YouTubeUserSumOrderByAggregateInput
  }

  export type YouTubeUserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<YouTubeUserScalarWhereWithAggregatesInput>
    OR?: Enumerable<YouTubeUserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<YouTubeUserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    profileImageUrl?: StringNullableWithAggregatesFilter | string | null
    bio?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ChannelWhereInput = {
    AND?: Enumerable<ChannelWhereInput>
    OR?: Enumerable<ChannelWhereInput>
    NOT?: Enumerable<ChannelWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    profileImageUrl?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    adminUsers?: YouTubeUserListRelationFilter
    subscribedUsers?: YouTubeUserListRelationFilter
    usersToChannelswithRoles?: UserToChannelwithRoleListRelationFilter
    owningVideos?: VideoListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ChannelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    profileImageUrl?: SortOrder
    description?: SortOrder
    adminUsers?: YouTubeUserOrderByRelationAggregateInput
    subscribedUsers?: YouTubeUserOrderByRelationAggregateInput
    usersToChannelswithRoles?: UserToChannelwithRoleOrderByRelationAggregateInput
    owningVideos?: VideoOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChannelWhereUniqueInput = {
    id?: number
  }

  export type ChannelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    profileImageUrl?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChannelCountOrderByAggregateInput
    _avg?: ChannelAvgOrderByAggregateInput
    _max?: ChannelMaxOrderByAggregateInput
    _min?: ChannelMinOrderByAggregateInput
    _sum?: ChannelSumOrderByAggregateInput
  }

  export type ChannelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ChannelScalarWhereWithAggregatesInput>
    OR?: Enumerable<ChannelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ChannelScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    profileImageUrl?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserToChannelwithRoleWhereInput = {
    AND?: Enumerable<UserToChannelwithRoleWhereInput>
    OR?: Enumerable<UserToChannelwithRoleWhereInput>
    NOT?: Enumerable<UserToChannelwithRoleWhereInput>
    id?: IntFilter | number
    user?: XOR<YouTubeUserRelationFilter, YouTubeUserWhereInput>
    youTubeUserId?: IntFilter | number
    channel?: XOR<ChannelRelationFilter, ChannelWhereInput>
    channelId?: IntFilter | number
    role?: EnumRoleEnumFilter | RoleEnum
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type UserToChannelwithRoleOrderByWithRelationInput = {
    id?: SortOrder
    user?: YouTubeUserOrderByWithRelationInput
    youTubeUserId?: SortOrder
    channel?: ChannelOrderByWithRelationInput
    channelId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserToChannelwithRoleWhereUniqueInput = {
    id?: number
  }

  export type UserToChannelwithRoleOrderByWithAggregationInput = {
    id?: SortOrder
    youTubeUserId?: SortOrder
    channelId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserToChannelwithRoleCountOrderByAggregateInput
    _avg?: UserToChannelwithRoleAvgOrderByAggregateInput
    _max?: UserToChannelwithRoleMaxOrderByAggregateInput
    _min?: UserToChannelwithRoleMinOrderByAggregateInput
    _sum?: UserToChannelwithRoleSumOrderByAggregateInput
  }

  export type UserToChannelwithRoleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserToChannelwithRoleScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserToChannelwithRoleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserToChannelwithRoleScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    youTubeUserId?: IntWithAggregatesFilter | number
    channelId?: IntWithAggregatesFilter | number
    role?: EnumRoleEnumWithAggregatesFilter | RoleEnum
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type VideoWhereInput = {
    AND?: Enumerable<VideoWhereInput>
    OR?: Enumerable<VideoWhereInput>
    NOT?: Enumerable<VideoWhereInput>
    id?: IntFilter | number
    title?: StringFilter | string
    videoUrl?: StringFilter | string
    thumbnailImageUrl?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    belongsToChannel?: XOR<ChannelRelationFilter, ChannelWhereInput>
    channelId?: IntFilter | number
    reactedByYouTubeUsers?: YouTubeUserListRelationFilter
    usersToVideosWithReactions?: UserToVideoWithReactionListRelationFilter
    videoComments?: VideoCommentListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type VideoOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    videoUrl?: SortOrder
    thumbnailImageUrl?: SortOrder
    description?: SortOrder
    belongsToChannel?: ChannelOrderByWithRelationInput
    channelId?: SortOrder
    reactedByYouTubeUsers?: YouTubeUserOrderByRelationAggregateInput
    usersToVideosWithReactions?: UserToVideoWithReactionOrderByRelationAggregateInput
    videoComments?: VideoCommentOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoWhereUniqueInput = {
    id?: number
  }

  export type VideoOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    videoUrl?: SortOrder
    thumbnailImageUrl?: SortOrder
    description?: SortOrder
    channelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VideoCountOrderByAggregateInput
    _avg?: VideoAvgOrderByAggregateInput
    _max?: VideoMaxOrderByAggregateInput
    _min?: VideoMinOrderByAggregateInput
    _sum?: VideoSumOrderByAggregateInput
  }

  export type VideoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<VideoScalarWhereWithAggregatesInput>
    OR?: Enumerable<VideoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<VideoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    title?: StringWithAggregatesFilter | string
    videoUrl?: StringWithAggregatesFilter | string
    thumbnailImageUrl?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    channelId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserToVideoWithReactionWhereInput = {
    AND?: Enumerable<UserToVideoWithReactionWhereInput>
    OR?: Enumerable<UserToVideoWithReactionWhereInput>
    NOT?: Enumerable<UserToVideoWithReactionWhereInput>
    id?: IntFilter | number
    user?: XOR<YouTubeUserRelationFilter, YouTubeUserWhereInput>
    youTubeUserId?: IntFilter | number
    video?: XOR<VideoRelationFilter, VideoWhereInput>
    videoId?: IntFilter | number
    reaction?: EnumReactionEnumFilter | ReactionEnum
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type UserToVideoWithReactionOrderByWithRelationInput = {
    id?: SortOrder
    user?: YouTubeUserOrderByWithRelationInput
    youTubeUserId?: SortOrder
    video?: VideoOrderByWithRelationInput
    videoId?: SortOrder
    reaction?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserToVideoWithReactionWhereUniqueInput = {
    id?: number
  }

  export type UserToVideoWithReactionOrderByWithAggregationInput = {
    id?: SortOrder
    youTubeUserId?: SortOrder
    videoId?: SortOrder
    reaction?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserToVideoWithReactionCountOrderByAggregateInput
    _avg?: UserToVideoWithReactionAvgOrderByAggregateInput
    _max?: UserToVideoWithReactionMaxOrderByAggregateInput
    _min?: UserToVideoWithReactionMinOrderByAggregateInput
    _sum?: UserToVideoWithReactionSumOrderByAggregateInput
  }

  export type UserToVideoWithReactionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserToVideoWithReactionScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserToVideoWithReactionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserToVideoWithReactionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    youTubeUserId?: IntWithAggregatesFilter | number
    videoId?: IntWithAggregatesFilter | number
    reaction?: EnumReactionEnumWithAggregatesFilter | ReactionEnum
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type VideoCommentWhereInput = {
    AND?: Enumerable<VideoCommentWhereInput>
    OR?: Enumerable<VideoCommentWhereInput>
    NOT?: Enumerable<VideoCommentWhereInput>
    id?: IntFilter | number
    commentText?: StringFilter | string
    commentingUser?: XOR<YouTubeUserRelationFilter, YouTubeUserWhereInput>
    youTubeUserId?: IntFilter | number
    parentVideo?: XOR<VideoRelationFilter, VideoWhereInput>
    videoId?: IntFilter | number
    parentVideoComment?: XOR<VideoCommentRelationFilter, VideoCommentWhereInput> | null
    parentVideoCommentId?: IntNullableFilter | number | null
    childVideoComments?: VideoCommentListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type VideoCommentOrderByWithRelationInput = {
    id?: SortOrder
    commentText?: SortOrder
    commentingUser?: YouTubeUserOrderByWithRelationInput
    youTubeUserId?: SortOrder
    parentVideo?: VideoOrderByWithRelationInput
    videoId?: SortOrder
    parentVideoComment?: VideoCommentOrderByWithRelationInput
    parentVideoCommentId?: SortOrder
    childVideoComments?: VideoCommentOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoCommentWhereUniqueInput = {
    id?: number
  }

  export type VideoCommentOrderByWithAggregationInput = {
    id?: SortOrder
    commentText?: SortOrder
    youTubeUserId?: SortOrder
    videoId?: SortOrder
    parentVideoCommentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VideoCommentCountOrderByAggregateInput
    _avg?: VideoCommentAvgOrderByAggregateInput
    _max?: VideoCommentMaxOrderByAggregateInput
    _min?: VideoCommentMinOrderByAggregateInput
    _sum?: VideoCommentSumOrderByAggregateInput
  }

  export type VideoCommentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<VideoCommentScalarWhereWithAggregatesInput>
    OR?: Enumerable<VideoCommentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<VideoCommentScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    commentText?: StringWithAggregatesFilter | string
    youTubeUserId?: IntWithAggregatesFilter | number
    videoId?: IntWithAggregatesFilter | number
    parentVideoCommentId?: IntNullableWithAggregatesFilter | number | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CategoryCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Menu?: MenuCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Menu?: MenuUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Menu?: MenuUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Menu?: MenuUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuCreateInput = {
    name: string
    image: string
    price: number
    category?: CategoryCreateNestedOneWithoutMenuInput
    orderItems?: OrderItemCreateNestedManyWithoutMenuInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuUncheckedCreateInput = {
    id?: number
    name: string
    image: string
    price: number
    categoryId?: number | null
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutMenuInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    category?: CategoryUpdateOneWithoutMenuNestedInput
    orderItems?: OrderItemUpdateManyWithoutMenuNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    orderItems?: OrderItemUncheckedUpdateManyWithoutMenuNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuCreateManyInput = {
    id?: number
    name: string
    image: string
    price: number
    categoryId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    status?: string
    tableId: number
    items?: OrderItemCreateNestedManyWithoutOrderInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUncheckedCreateInput = {
    id?: number
    status?: string
    tableId: number
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateInput = {
    status?: StringFieldUpdateOperationsInput | string
    tableId?: IntFieldUpdateOperationsInput | number
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    tableId?: IntFieldUpdateOperationsInput | number
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyInput = {
    id?: number
    status?: string
    tableId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateManyMutationInput = {
    status?: StringFieldUpdateOperationsInput | string
    tableId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    tableId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateInput = {
    menu: MenuCreateNestedOneWithoutOrderItemsInput
    order?: OrderCreateNestedOneWithoutItemsInput
    quantity: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemUncheckedCreateInput = {
    id?: number
    menuId: number
    orderId?: number | null
    quantity: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemUpdateInput = {
    menu?: MenuUpdateOneRequiredWithoutOrderItemsNestedInput
    order?: OrderUpdateOneWithoutItemsNestedInput
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuId?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManyInput = {
    id?: number
    menuId: number
    orderId?: number | null
    quantity: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuId?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizCategoryCreateInput = {
    name: string
    quizzes?: QuizCreateNestedManyWithoutCategoryInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizCategoryUncheckedCreateInput = {
    id?: number
    name: string
    quizzes?: QuizUncheckedCreateNestedManyWithoutCategoryInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizCategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    quizzes?: QuizUpdateManyWithoutCategoryNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    quizzes?: QuizUncheckedUpdateManyWithoutCategoryNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizCategoryCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizCategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoiceCreateInput = {
    answerText: string
    quiz?: QuizCreateNestedOneWithoutChoicesInput
    correctQuizzes?: QuizCreateNestedManyWithoutCorrectChoiceInput
    rounds?: RoundCreateNestedManyWithoutSelectedChoicesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChoiceUncheckedCreateInput = {
    id?: number
    answerText: string
    quizId?: number | null
    correctQuizzes?: QuizUncheckedCreateNestedManyWithoutCorrectChoiceInput
    rounds?: RoundUncheckedCreateNestedManyWithoutSelectedChoicesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChoiceUpdateInput = {
    answerText?: StringFieldUpdateOperationsInput | string
    quiz?: QuizUpdateOneWithoutChoicesNestedInput
    correctQuizzes?: QuizUpdateManyWithoutCorrectChoiceNestedInput
    rounds?: RoundUpdateManyWithoutSelectedChoicesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    answerText?: StringFieldUpdateOperationsInput | string
    quizId?: NullableIntFieldUpdateOperationsInput | number | null
    correctQuizzes?: QuizUncheckedUpdateManyWithoutCorrectChoiceNestedInput
    rounds?: RoundUncheckedUpdateManyWithoutSelectedChoicesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoiceCreateManyInput = {
    id?: number
    answerText: string
    quizId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChoiceUpdateManyMutationInput = {
    answerText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    answerText?: StringFieldUpdateOperationsInput | string
    quizId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizCreateInput = {
    questionText: string
    category: QuizCategoryCreateNestedOneWithoutQuizzesInput
    choices?: ChoiceCreateNestedManyWithoutQuizInput
    correctChoice: ChoiceCreateNestedOneWithoutCorrectQuizzesInput
    rounds?: RoundCreateNestedManyWithoutQuizzesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizUncheckedCreateInput = {
    id?: number
    questionText: string
    quizCategoryId: number
    choices?: ChoiceUncheckedCreateNestedManyWithoutQuizInput
    correctChoiceId: number
    rounds?: RoundUncheckedCreateNestedManyWithoutQuizzesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizUpdateInput = {
    questionText?: StringFieldUpdateOperationsInput | string
    category?: QuizCategoryUpdateOneRequiredWithoutQuizzesNestedInput
    choices?: ChoiceUpdateManyWithoutQuizNestedInput
    correctChoice?: ChoiceUpdateOneRequiredWithoutCorrectQuizzesNestedInput
    rounds?: RoundUpdateManyWithoutQuizzesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionText?: StringFieldUpdateOperationsInput | string
    quizCategoryId?: IntFieldUpdateOperationsInput | number
    choices?: ChoiceUncheckedUpdateManyWithoutQuizNestedInput
    correctChoiceId?: IntFieldUpdateOperationsInput | number
    rounds?: RoundUncheckedUpdateManyWithoutQuizzesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizCreateManyInput = {
    id?: number
    questionText: string
    quizCategoryId: number
    correctChoiceId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizUpdateManyMutationInput = {
    questionText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionText?: StringFieldUpdateOperationsInput | string
    quizCategoryId?: IntFieldUpdateOperationsInput | number
    correctChoiceId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoundCreateInput = {
    quizzes?: QuizCreateNestedManyWithoutRoundsInput
    selectedChoices?: ChoiceCreateNestedManyWithoutRoundsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoundUncheckedCreateInput = {
    id?: number
    quizzes?: QuizUncheckedCreateNestedManyWithoutRoundsInput
    selectedChoices?: ChoiceUncheckedCreateNestedManyWithoutRoundsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoundUpdateInput = {
    quizzes?: QuizUpdateManyWithoutRoundsNestedInput
    selectedChoices?: ChoiceUpdateManyWithoutRoundsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoundUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizzes?: QuizUncheckedUpdateManyWithoutRoundsNestedInput
    selectedChoices?: ChoiceUncheckedUpdateManyWithoutRoundsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoundCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoundUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoundUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserCreateInput = {
    name: string
    imageUrl: string
    bio: string
    followingUserRelations?: FacebookUserRelationCreateNestedManyWithoutFollowingUserInput
    followedUserRelations?: FacebookUserRelationCreateNestedManyWithoutFollowedUserInput
    posts?: PostCreateNestedManyWithoutPostingUserInput
    comments?: CommentCreateNestedManyWithoutCommentingUserInput
    messengerMessagesFrom?: MessengerMessageCreateNestedManyWithoutFromUserInput
    messengerMessagesTo?: MessengerMessageCreateNestedManyWithoutToUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserUncheckedCreateInput = {
    id?: number
    name: string
    imageUrl: string
    bio: string
    followingUserRelations?: FacebookUserRelationUncheckedCreateNestedManyWithoutFollowingUserInput
    followedUserRelations?: FacebookUserRelationUncheckedCreateNestedManyWithoutFollowedUserInput
    posts?: PostUncheckedCreateNestedManyWithoutPostingUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutCommentingUserInput
    messengerMessagesFrom?: MessengerMessageUncheckedCreateNestedManyWithoutFromUserInput
    messengerMessagesTo?: MessengerMessageUncheckedCreateNestedManyWithoutToUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followingUserRelations?: FacebookUserRelationUpdateManyWithoutFollowingUserNestedInput
    followedUserRelations?: FacebookUserRelationUpdateManyWithoutFollowedUserNestedInput
    posts?: PostUpdateManyWithoutPostingUserNestedInput
    comments?: CommentUpdateManyWithoutCommentingUserNestedInput
    messengerMessagesFrom?: MessengerMessageUpdateManyWithoutFromUserNestedInput
    messengerMessagesTo?: MessengerMessageUpdateManyWithoutToUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followingUserRelations?: FacebookUserRelationUncheckedUpdateManyWithoutFollowingUserNestedInput
    followedUserRelations?: FacebookUserRelationUncheckedUpdateManyWithoutFollowedUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutPostingUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCommentingUserNestedInput
    messengerMessagesFrom?: MessengerMessageUncheckedUpdateManyWithoutFromUserNestedInput
    messengerMessagesTo?: MessengerMessageUncheckedUpdateManyWithoutToUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserCreateManyInput = {
    id?: number
    name: string
    imageUrl: string
    bio: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserRelationCreateInput = {
    followingUser: FacebookUserCreateNestedOneWithoutFollowingUserRelationsInput
    followedUser: FacebookUserCreateNestedOneWithoutFollowedUserRelationsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserRelationUncheckedCreateInput = {
    id?: number
    followingUserId: number
    followedUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserRelationUpdateInput = {
    followingUser?: FacebookUserUpdateOneRequiredWithoutFollowingUserRelationsNestedInput
    followedUser?: FacebookUserUpdateOneRequiredWithoutFollowedUserRelationsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserRelationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    followingUserId?: IntFieldUpdateOperationsInput | number
    followedUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserRelationCreateManyInput = {
    id?: number
    followingUserId: number
    followedUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserRelationUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserRelationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    followingUserId?: IntFieldUpdateOperationsInput | number
    followedUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCreateInput = {
    postText: string
    postingUser: FacebookUserCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutParentPostInput
    hashTags?: FacebookHashTagCreateNestedManyWithoutIsInPostsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostUncheckedCreateInput = {
    id?: number
    postText: string
    userId: number
    comments?: CommentUncheckedCreateNestedManyWithoutParentPostInput
    hashTags?: FacebookHashTagUncheckedCreateNestedManyWithoutIsInPostsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostUpdateInput = {
    postText?: StringFieldUpdateOperationsInput | string
    postingUser?: FacebookUserUpdateOneRequiredWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutParentPostNestedInput
    hashTags?: FacebookHashTagUpdateManyWithoutIsInPostsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    postText?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    comments?: CommentUncheckedUpdateManyWithoutParentPostNestedInput
    hashTags?: FacebookHashTagUncheckedUpdateManyWithoutIsInPostsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCreateManyInput = {
    id?: number
    postText: string
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostUpdateManyMutationInput = {
    postText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    postText?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    commentText: string
    commentingUser: FacebookUserCreateNestedOneWithoutCommentsInput
    parentPost: PostCreateNestedOneWithoutCommentsInput
    parentComment?: CommentCreateNestedOneWithoutChildCommentsInput
    childComments?: CommentCreateNestedManyWithoutParentCommentInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUncheckedCreateInput = {
    id?: number
    commentText: string
    userId: number
    postId: number
    parentCommentId?: number | null
    childComments?: CommentUncheckedCreateNestedManyWithoutParentCommentInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateInput = {
    commentText?: StringFieldUpdateOperationsInput | string
    commentingUser?: FacebookUserUpdateOneRequiredWithoutCommentsNestedInput
    parentPost?: PostUpdateOneRequiredWithoutCommentsNestedInput
    parentComment?: CommentUpdateOneWithoutChildCommentsNestedInput
    childComments?: CommentUpdateManyWithoutParentCommentNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentText?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    parentCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    childComments?: CommentUncheckedUpdateManyWithoutParentCommentNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyInput = {
    id?: number
    commentText: string
    userId: number
    postId: number
    parentCommentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    commentText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentText?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    parentCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookHashTagCreateInput = {
    hashTagText: string
    isInPosts?: PostCreateNestedManyWithoutHashTagsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookHashTagUncheckedCreateInput = {
    id?: number
    hashTagText: string
    isInPosts?: PostUncheckedCreateNestedManyWithoutHashTagsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookHashTagUpdateInput = {
    hashTagText?: StringFieldUpdateOperationsInput | string
    isInPosts?: PostUpdateManyWithoutHashTagsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookHashTagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    hashTagText?: StringFieldUpdateOperationsInput | string
    isInPosts?: PostUncheckedUpdateManyWithoutHashTagsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookHashTagCreateManyInput = {
    id?: number
    hashTagText: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookHashTagUpdateManyMutationInput = {
    hashTagText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookHashTagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    hashTagText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessengerMessageCreateInput = {
    messengerText: string
    fromUser: FacebookUserCreateNestedOneWithoutMessengerMessagesFromInput
    toUser: FacebookUserCreateNestedOneWithoutMessengerMessagesToInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessengerMessageUncheckedCreateInput = {
    id?: number
    messengerText: string
    fromUserId: number
    toUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessengerMessageUpdateInput = {
    messengerText?: StringFieldUpdateOperationsInput | string
    fromUser?: FacebookUserUpdateOneRequiredWithoutMessengerMessagesFromNestedInput
    toUser?: FacebookUserUpdateOneRequiredWithoutMessengerMessagesToNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessengerMessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    messengerText?: StringFieldUpdateOperationsInput | string
    fromUserId?: IntFieldUpdateOperationsInput | number
    toUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessengerMessageCreateManyInput = {
    id?: number
    messengerText: string
    fromUserId: number
    toUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessengerMessageUpdateManyMutationInput = {
    messengerText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessengerMessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    messengerText?: StringFieldUpdateOperationsInput | string
    fromUserId?: IntFieldUpdateOperationsInput | number
    toUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TodoListCreateInput = {
    task: string
    status?: string
    bgColor?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TodoListUncheckedCreateInput = {
    id?: number
    task: string
    status?: string
    bgColor?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TodoListUpdateInput = {
    task?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    bgColor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TodoListUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    task?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    bgColor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TodoListCreateManyInput = {
    id?: number
    task: string
    status?: string
    bgColor?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TodoListUpdateManyMutationInput = {
    task?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    bgColor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TodoListUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    task?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    bgColor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    name: string
    imageUrl: string
    bio: string
    followingUserRelations?: UserRelationCreateNestedManyWithoutFollowingUserInput
    followedUserRelations?: UserRelationCreateNestedManyWithoutFollowedUserInput
    tweets?: TweetCreateNestedManyWithoutTweetingUserInput
    directMessagesFrom?: DirectMessageCreateNestedManyWithoutFromUserInput
    directMessagesTo?: DirectMessageCreateNestedManyWithoutToUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateInput = {
    id?: number
    name: string
    imageUrl: string
    bio: string
    followingUserRelations?: UserRelationUncheckedCreateNestedManyWithoutFollowingUserInput
    followedUserRelations?: UserRelationUncheckedCreateNestedManyWithoutFollowedUserInput
    tweets?: TweetUncheckedCreateNestedManyWithoutTweetingUserInput
    directMessagesFrom?: DirectMessageUncheckedCreateNestedManyWithoutFromUserInput
    directMessagesTo?: DirectMessageUncheckedCreateNestedManyWithoutToUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followingUserRelations?: UserRelationUpdateManyWithoutFollowingUserNestedInput
    followedUserRelations?: UserRelationUpdateManyWithoutFollowedUserNestedInput
    tweets?: TweetUpdateManyWithoutTweetingUserNestedInput
    directMessagesFrom?: DirectMessageUpdateManyWithoutFromUserNestedInput
    directMessagesTo?: DirectMessageUpdateManyWithoutToUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followingUserRelations?: UserRelationUncheckedUpdateManyWithoutFollowingUserNestedInput
    followedUserRelations?: UserRelationUncheckedUpdateManyWithoutFollowedUserNestedInput
    tweets?: TweetUncheckedUpdateManyWithoutTweetingUserNestedInput
    directMessagesFrom?: DirectMessageUncheckedUpdateManyWithoutFromUserNestedInput
    directMessagesTo?: DirectMessageUncheckedUpdateManyWithoutToUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyInput = {
    id?: number
    name: string
    imageUrl: string
    bio: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRelationCreateInput = {
    followingUser: UserCreateNestedOneWithoutFollowingUserRelationsInput
    followedUser: UserCreateNestedOneWithoutFollowedUserRelationsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserRelationUncheckedCreateInput = {
    id?: number
    followingUserId: number
    followedUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserRelationUpdateInput = {
    followingUser?: UserUpdateOneRequiredWithoutFollowingUserRelationsNestedInput
    followedUser?: UserUpdateOneRequiredWithoutFollowedUserRelationsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRelationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    followingUserId?: IntFieldUpdateOperationsInput | number
    followedUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRelationCreateManyInput = {
    id?: number
    followingUserId: number
    followedUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserRelationUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRelationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    followingUserId?: IntFieldUpdateOperationsInput | number
    followedUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TweetCreateInput = {
    tweetText: string
    tweetingUser: UserCreateNestedOneWithoutTweetsInput
    parentTweet?: TweetCreateNestedOneWithoutChildTweetsInput
    childTweets?: TweetCreateNestedManyWithoutParentTweetInput
    hashTags?: HashTagCreateNestedManyWithoutIsInTweetsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TweetUncheckedCreateInput = {
    id?: number
    tweetText: string
    parentTweetId?: number | null
    childTweets?: TweetUncheckedCreateNestedManyWithoutParentTweetInput
    userId: number
    hashTags?: HashTagUncheckedCreateNestedManyWithoutIsInTweetsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TweetUpdateInput = {
    tweetText?: StringFieldUpdateOperationsInput | string
    tweetingUser?: UserUpdateOneRequiredWithoutTweetsNestedInput
    parentTweet?: TweetUpdateOneWithoutChildTweetsNestedInput
    childTweets?: TweetUpdateManyWithoutParentTweetNestedInput
    hashTags?: HashTagUpdateManyWithoutIsInTweetsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TweetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tweetText?: StringFieldUpdateOperationsInput | string
    parentTweetId?: NullableIntFieldUpdateOperationsInput | number | null
    childTweets?: TweetUncheckedUpdateManyWithoutParentTweetNestedInput
    userId?: IntFieldUpdateOperationsInput | number
    hashTags?: HashTagUncheckedUpdateManyWithoutIsInTweetsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TweetCreateManyInput = {
    id?: number
    tweetText: string
    parentTweetId?: number | null
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TweetUpdateManyMutationInput = {
    tweetText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TweetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tweetText?: StringFieldUpdateOperationsInput | string
    parentTweetId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HashTagCreateInput = {
    hashTagText: string
    isInTweets?: TweetCreateNestedManyWithoutHashTagsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HashTagUncheckedCreateInput = {
    id?: number
    hashTagText: string
    isInTweets?: TweetUncheckedCreateNestedManyWithoutHashTagsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HashTagUpdateInput = {
    hashTagText?: StringFieldUpdateOperationsInput | string
    isInTweets?: TweetUpdateManyWithoutHashTagsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HashTagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    hashTagText?: StringFieldUpdateOperationsInput | string
    isInTweets?: TweetUncheckedUpdateManyWithoutHashTagsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HashTagCreateManyInput = {
    id?: number
    hashTagText: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HashTagUpdateManyMutationInput = {
    hashTagText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HashTagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    hashTagText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageCreateInput = {
    dmText: string
    fromUser: UserCreateNestedOneWithoutDirectMessagesFromInput
    toUser: UserCreateNestedOneWithoutDirectMessagesToInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DirectMessageUncheckedCreateInput = {
    id?: number
    dmText: string
    fromUserId: number
    toUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DirectMessageUpdateInput = {
    dmText?: StringFieldUpdateOperationsInput | string
    fromUser?: UserUpdateOneRequiredWithoutDirectMessagesFromNestedInput
    toUser?: UserUpdateOneRequiredWithoutDirectMessagesToNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dmText?: StringFieldUpdateOperationsInput | string
    fromUserId?: IntFieldUpdateOperationsInput | number
    toUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageCreateManyInput = {
    id?: number
    dmText: string
    fromUserId: number
    toUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DirectMessageUpdateManyMutationInput = {
    dmText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dmText?: StringFieldUpdateOperationsInput | string
    fromUserId?: IntFieldUpdateOperationsInput | number
    toUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YouTubeUserCreateInput = {
    name: string
    profileImageUrl?: string | null
    bio?: string | null
    adminOfChannels?: ChannelCreateNestedManyWithoutAdminUsersInput
    usersToChannelswithRoles?: UserToChannelwithRoleCreateNestedManyWithoutUserInput
    subscribingToChannels?: ChannelCreateNestedManyWithoutSubscribedUsersInput
    reactedVideos?: VideoCreateNestedManyWithoutReactedByYouTubeUsersInput
    usersToVideosWithReactions?: UserToVideoWithReactionCreateNestedManyWithoutUserInput
    videoComments?: VideoCommentCreateNestedManyWithoutCommentingUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YouTubeUserUncheckedCreateInput = {
    id?: number
    name: string
    profileImageUrl?: string | null
    bio?: string | null
    adminOfChannels?: ChannelUncheckedCreateNestedManyWithoutAdminUsersInput
    usersToChannelswithRoles?: UserToChannelwithRoleUncheckedCreateNestedManyWithoutUserInput
    subscribingToChannels?: ChannelUncheckedCreateNestedManyWithoutSubscribedUsersInput
    reactedVideos?: VideoUncheckedCreateNestedManyWithoutReactedByYouTubeUsersInput
    usersToVideosWithReactions?: UserToVideoWithReactionUncheckedCreateNestedManyWithoutUserInput
    videoComments?: VideoCommentUncheckedCreateNestedManyWithoutCommentingUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YouTubeUserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    adminOfChannels?: ChannelUpdateManyWithoutAdminUsersNestedInput
    usersToChannelswithRoles?: UserToChannelwithRoleUpdateManyWithoutUserNestedInput
    subscribingToChannels?: ChannelUpdateManyWithoutSubscribedUsersNestedInput
    reactedVideos?: VideoUpdateManyWithoutReactedByYouTubeUsersNestedInput
    usersToVideosWithReactions?: UserToVideoWithReactionUpdateManyWithoutUserNestedInput
    videoComments?: VideoCommentUpdateManyWithoutCommentingUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YouTubeUserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    adminOfChannels?: ChannelUncheckedUpdateManyWithoutAdminUsersNestedInput
    usersToChannelswithRoles?: UserToChannelwithRoleUncheckedUpdateManyWithoutUserNestedInput
    subscribingToChannels?: ChannelUncheckedUpdateManyWithoutSubscribedUsersNestedInput
    reactedVideos?: VideoUncheckedUpdateManyWithoutReactedByYouTubeUsersNestedInput
    usersToVideosWithReactions?: UserToVideoWithReactionUncheckedUpdateManyWithoutUserNestedInput
    videoComments?: VideoCommentUncheckedUpdateManyWithoutCommentingUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YouTubeUserCreateManyInput = {
    id?: number
    name: string
    profileImageUrl?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YouTubeUserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YouTubeUserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelCreateInput = {
    name: string
    profileImageUrl?: string | null
    description?: string | null
    adminUsers?: YouTubeUserCreateNestedManyWithoutAdminOfChannelsInput
    subscribedUsers?: YouTubeUserCreateNestedManyWithoutSubscribingToChannelsInput
    usersToChannelswithRoles?: UserToChannelwithRoleCreateNestedManyWithoutChannelInput
    owningVideos?: VideoCreateNestedManyWithoutBelongsToChannelInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChannelUncheckedCreateInput = {
    id?: number
    name: string
    profileImageUrl?: string | null
    description?: string | null
    adminUsers?: YouTubeUserUncheckedCreateNestedManyWithoutAdminOfChannelsInput
    subscribedUsers?: YouTubeUserUncheckedCreateNestedManyWithoutSubscribingToChannelsInput
    usersToChannelswithRoles?: UserToChannelwithRoleUncheckedCreateNestedManyWithoutChannelInput
    owningVideos?: VideoUncheckedCreateNestedManyWithoutBelongsToChannelInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChannelUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adminUsers?: YouTubeUserUpdateManyWithoutAdminOfChannelsNestedInput
    subscribedUsers?: YouTubeUserUpdateManyWithoutSubscribingToChannelsNestedInput
    usersToChannelswithRoles?: UserToChannelwithRoleUpdateManyWithoutChannelNestedInput
    owningVideos?: VideoUpdateManyWithoutBelongsToChannelNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adminUsers?: YouTubeUserUncheckedUpdateManyWithoutAdminOfChannelsNestedInput
    subscribedUsers?: YouTubeUserUncheckedUpdateManyWithoutSubscribingToChannelsNestedInput
    usersToChannelswithRoles?: UserToChannelwithRoleUncheckedUpdateManyWithoutChannelNestedInput
    owningVideos?: VideoUncheckedUpdateManyWithoutBelongsToChannelNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelCreateManyInput = {
    id?: number
    name: string
    profileImageUrl?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChannelUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToChannelwithRoleCreateInput = {
    user: YouTubeUserCreateNestedOneWithoutUsersToChannelswithRolesInput
    channel: ChannelCreateNestedOneWithoutUsersToChannelswithRolesInput
    role: RoleEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToChannelwithRoleUncheckedCreateInput = {
    id?: number
    youTubeUserId: number
    channelId: number
    role: RoleEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToChannelwithRoleUpdateInput = {
    user?: YouTubeUserUpdateOneRequiredWithoutUsersToChannelswithRolesNestedInput
    channel?: ChannelUpdateOneRequiredWithoutUsersToChannelswithRolesNestedInput
    role?: EnumRoleEnumFieldUpdateOperationsInput | RoleEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToChannelwithRoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    youTubeUserId?: IntFieldUpdateOperationsInput | number
    channelId?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleEnumFieldUpdateOperationsInput | RoleEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToChannelwithRoleCreateManyInput = {
    id?: number
    youTubeUserId: number
    channelId: number
    role: RoleEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToChannelwithRoleUpdateManyMutationInput = {
    role?: EnumRoleEnumFieldUpdateOperationsInput | RoleEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToChannelwithRoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    youTubeUserId?: IntFieldUpdateOperationsInput | number
    channelId?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleEnumFieldUpdateOperationsInput | RoleEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCreateInput = {
    title: string
    videoUrl: string
    thumbnailImageUrl?: string | null
    description?: string | null
    belongsToChannel: ChannelCreateNestedOneWithoutOwningVideosInput
    reactedByYouTubeUsers?: YouTubeUserCreateNestedManyWithoutReactedVideosInput
    usersToVideosWithReactions?: UserToVideoWithReactionCreateNestedManyWithoutVideoInput
    videoComments?: VideoCommentCreateNestedManyWithoutParentVideoInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoUncheckedCreateInput = {
    id?: number
    title: string
    videoUrl: string
    thumbnailImageUrl?: string | null
    description?: string | null
    channelId: number
    reactedByYouTubeUsers?: YouTubeUserUncheckedCreateNestedManyWithoutReactedVideosInput
    usersToVideosWithReactions?: UserToVideoWithReactionUncheckedCreateNestedManyWithoutVideoInput
    videoComments?: VideoCommentUncheckedCreateNestedManyWithoutParentVideoInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    belongsToChannel?: ChannelUpdateOneRequiredWithoutOwningVideosNestedInput
    reactedByYouTubeUsers?: YouTubeUserUpdateManyWithoutReactedVideosNestedInput
    usersToVideosWithReactions?: UserToVideoWithReactionUpdateManyWithoutVideoNestedInput
    videoComments?: VideoCommentUpdateManyWithoutParentVideoNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: IntFieldUpdateOperationsInput | number
    reactedByYouTubeUsers?: YouTubeUserUncheckedUpdateManyWithoutReactedVideosNestedInput
    usersToVideosWithReactions?: UserToVideoWithReactionUncheckedUpdateManyWithoutVideoNestedInput
    videoComments?: VideoCommentUncheckedUpdateManyWithoutParentVideoNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCreateManyInput = {
    id?: number
    title: string
    videoUrl: string
    thumbnailImageUrl?: string | null
    description?: string | null
    channelId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToVideoWithReactionCreateInput = {
    user: YouTubeUserCreateNestedOneWithoutUsersToVideosWithReactionsInput
    video: VideoCreateNestedOneWithoutUsersToVideosWithReactionsInput
    reaction: ReactionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToVideoWithReactionUncheckedCreateInput = {
    id?: number
    youTubeUserId: number
    videoId: number
    reaction: ReactionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToVideoWithReactionUpdateInput = {
    user?: YouTubeUserUpdateOneRequiredWithoutUsersToVideosWithReactionsNestedInput
    video?: VideoUpdateOneRequiredWithoutUsersToVideosWithReactionsNestedInput
    reaction?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToVideoWithReactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    youTubeUserId?: IntFieldUpdateOperationsInput | number
    videoId?: IntFieldUpdateOperationsInput | number
    reaction?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToVideoWithReactionCreateManyInput = {
    id?: number
    youTubeUserId: number
    videoId: number
    reaction: ReactionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToVideoWithReactionUpdateManyMutationInput = {
    reaction?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToVideoWithReactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    youTubeUserId?: IntFieldUpdateOperationsInput | number
    videoId?: IntFieldUpdateOperationsInput | number
    reaction?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCommentCreateInput = {
    commentText: string
    commentingUser: YouTubeUserCreateNestedOneWithoutVideoCommentsInput
    parentVideo: VideoCreateNestedOneWithoutVideoCommentsInput
    parentVideoComment?: VideoCommentCreateNestedOneWithoutChildVideoCommentsInput
    childVideoComments?: VideoCommentCreateNestedManyWithoutParentVideoCommentInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCommentUncheckedCreateInput = {
    id?: number
    commentText: string
    youTubeUserId: number
    videoId: number
    parentVideoCommentId?: number | null
    childVideoComments?: VideoCommentUncheckedCreateNestedManyWithoutParentVideoCommentInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCommentUpdateInput = {
    commentText?: StringFieldUpdateOperationsInput | string
    commentingUser?: YouTubeUserUpdateOneRequiredWithoutVideoCommentsNestedInput
    parentVideo?: VideoUpdateOneRequiredWithoutVideoCommentsNestedInput
    parentVideoComment?: VideoCommentUpdateOneWithoutChildVideoCommentsNestedInput
    childVideoComments?: VideoCommentUpdateManyWithoutParentVideoCommentNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentText?: StringFieldUpdateOperationsInput | string
    youTubeUserId?: IntFieldUpdateOperationsInput | number
    videoId?: IntFieldUpdateOperationsInput | number
    parentVideoCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    childVideoComments?: VideoCommentUncheckedUpdateManyWithoutParentVideoCommentNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCommentCreateManyInput = {
    id?: number
    commentText: string
    youTubeUserId: number
    videoId: number
    parentVideoCommentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCommentUpdateManyMutationInput = {
    commentText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentText?: StringFieldUpdateOperationsInput | string
    youTubeUserId?: IntFieldUpdateOperationsInput | number
    videoId?: IntFieldUpdateOperationsInput | number
    parentVideoCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type MenuListRelationFilter = {
    every?: MenuWhereInput
    some?: MenuWhereInput
    none?: MenuWhereInput
  }

  export type MenuOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type CategoryRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MenuCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    price?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    categoryId?: SortOrder
  }

  export type MenuMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    price?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    price?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    categoryId?: SortOrder
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    tableId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    tableId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    tableId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
  }

  export type MenuRelationFilter = {
    is?: MenuWhereInput
    isNot?: MenuWhereInput
  }

  export type OrderRelationFilter = {
    is?: OrderWhereInput | null
    isNot?: OrderWhereInput | null
  }

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderItemAvgOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
  }

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderItemSumOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
  }

  export type QuizListRelationFilter = {
    every?: QuizWhereInput
    some?: QuizWhereInput
    none?: QuizWhereInput
  }

  export type QuizOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type QuizCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizCategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type QuizRelationFilter = {
    is?: QuizWhereInput | null
    isNot?: QuizWhereInput | null
  }

  export type RoundListRelationFilter = {
    every?: RoundWhereInput
    some?: RoundWhereInput
    none?: RoundWhereInput
  }

  export type RoundOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChoiceCountOrderByAggregateInput = {
    id?: SortOrder
    answerText?: SortOrder
    quizId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChoiceAvgOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
  }

  export type ChoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    answerText?: SortOrder
    quizId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChoiceMinOrderByAggregateInput = {
    id?: SortOrder
    answerText?: SortOrder
    quizId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChoiceSumOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
  }

  export type QuizCategoryRelationFilter = {
    is?: QuizCategoryWhereInput
    isNot?: QuizCategoryWhereInput
  }

  export type ChoiceListRelationFilter = {
    every?: ChoiceWhereInput
    some?: ChoiceWhereInput
    none?: ChoiceWhereInput
  }

  export type ChoiceRelationFilter = {
    is?: ChoiceWhereInput
    isNot?: ChoiceWhereInput
  }

  export type ChoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizCountOrderByAggregateInput = {
    id?: SortOrder
    questionText?: SortOrder
    quizCategoryId?: SortOrder
    correctChoiceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizAvgOrderByAggregateInput = {
    id?: SortOrder
    quizCategoryId?: SortOrder
    correctChoiceId?: SortOrder
  }

  export type QuizMaxOrderByAggregateInput = {
    id?: SortOrder
    questionText?: SortOrder
    quizCategoryId?: SortOrder
    correctChoiceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizMinOrderByAggregateInput = {
    id?: SortOrder
    questionText?: SortOrder
    quizCategoryId?: SortOrder
    correctChoiceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizSumOrderByAggregateInput = {
    id?: SortOrder
    quizCategoryId?: SortOrder
    correctChoiceId?: SortOrder
  }

  export type RoundCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoundAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoundMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoundMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoundSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FacebookUserRelationListRelationFilter = {
    every?: FacebookUserRelationWhereInput
    some?: FacebookUserRelationWhereInput
    none?: FacebookUserRelationWhereInput
  }

  export type PostListRelationFilter = {
    every?: PostWhereInput
    some?: PostWhereInput
    none?: PostWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type MessengerMessageListRelationFilter = {
    every?: MessengerMessageWhereInput
    some?: MessengerMessageWhereInput
    none?: MessengerMessageWhereInput
  }

  export type FacebookUserRelationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessengerMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FacebookUserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookUserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FacebookUserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookUserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookUserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FacebookUserRelationFilter = {
    is?: FacebookUserWhereInput
    isNot?: FacebookUserWhereInput
  }

  export type FacebookUserRelationCountOrderByAggregateInput = {
    id?: SortOrder
    followingUserId?: SortOrder
    followedUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookUserRelationAvgOrderByAggregateInput = {
    id?: SortOrder
    followingUserId?: SortOrder
    followedUserId?: SortOrder
  }

  export type FacebookUserRelationMaxOrderByAggregateInput = {
    id?: SortOrder
    followingUserId?: SortOrder
    followedUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookUserRelationMinOrderByAggregateInput = {
    id?: SortOrder
    followingUserId?: SortOrder
    followedUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookUserRelationSumOrderByAggregateInput = {
    id?: SortOrder
    followingUserId?: SortOrder
    followedUserId?: SortOrder
  }

  export type FacebookHashTagListRelationFilter = {
    every?: FacebookHashTagWhereInput
    some?: FacebookHashTagWhereInput
    none?: FacebookHashTagWhereInput
  }

  export type FacebookHashTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostCountOrderByAggregateInput = {
    id?: SortOrder
    postText?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    id?: SortOrder
    postText?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    id?: SortOrder
    postText?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type PostRelationFilter = {
    is?: PostWhereInput
    isNot?: PostWhereInput
  }

  export type CommentRelationFilter = {
    is?: CommentWhereInput | null
    isNot?: CommentWhereInput | null
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    commentText?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    parentCommentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    parentCommentId?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    commentText?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    parentCommentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    commentText?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    parentCommentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    parentCommentId?: SortOrder
  }

  export type FacebookHashTagCountOrderByAggregateInput = {
    id?: SortOrder
    hashTagText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookHashTagAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FacebookHashTagMaxOrderByAggregateInput = {
    id?: SortOrder
    hashTagText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookHashTagMinOrderByAggregateInput = {
    id?: SortOrder
    hashTagText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookHashTagSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MessengerMessageCountOrderByAggregateInput = {
    id?: SortOrder
    messengerText?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessengerMessageAvgOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
  }

  export type MessengerMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    messengerText?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessengerMessageMinOrderByAggregateInput = {
    id?: SortOrder
    messengerText?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessengerMessageSumOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
  }

  export type TodoListCountOrderByAggregateInput = {
    id?: SortOrder
    task?: SortOrder
    status?: SortOrder
    bgColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TodoListAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TodoListMaxOrderByAggregateInput = {
    id?: SortOrder
    task?: SortOrder
    status?: SortOrder
    bgColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TodoListMinOrderByAggregateInput = {
    id?: SortOrder
    task?: SortOrder
    status?: SortOrder
    bgColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TodoListSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserRelationListRelationFilter = {
    every?: UserRelationWhereInput
    some?: UserRelationWhereInput
    none?: UserRelationWhereInput
  }

  export type TweetListRelationFilter = {
    every?: TweetWhereInput
    some?: TweetWhereInput
    none?: TweetWhereInput
  }

  export type DirectMessageListRelationFilter = {
    every?: DirectMessageWhereInput
    some?: DirectMessageWhereInput
    none?: DirectMessageWhereInput
  }

  export type UserRelationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TweetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DirectMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserRelationCountOrderByAggregateInput = {
    id?: SortOrder
    followingUserId?: SortOrder
    followedUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserRelationAvgOrderByAggregateInput = {
    id?: SortOrder
    followingUserId?: SortOrder
    followedUserId?: SortOrder
  }

  export type UserRelationMaxOrderByAggregateInput = {
    id?: SortOrder
    followingUserId?: SortOrder
    followedUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserRelationMinOrderByAggregateInput = {
    id?: SortOrder
    followingUserId?: SortOrder
    followedUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserRelationSumOrderByAggregateInput = {
    id?: SortOrder
    followingUserId?: SortOrder
    followedUserId?: SortOrder
  }

  export type TweetRelationFilter = {
    is?: TweetWhereInput | null
    isNot?: TweetWhereInput | null
  }

  export type HashTagListRelationFilter = {
    every?: HashTagWhereInput
    some?: HashTagWhereInput
    none?: HashTagWhereInput
  }

  export type HashTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TweetCountOrderByAggregateInput = {
    id?: SortOrder
    tweetText?: SortOrder
    parentTweetId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TweetAvgOrderByAggregateInput = {
    id?: SortOrder
    parentTweetId?: SortOrder
    userId?: SortOrder
  }

  export type TweetMaxOrderByAggregateInput = {
    id?: SortOrder
    tweetText?: SortOrder
    parentTweetId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TweetMinOrderByAggregateInput = {
    id?: SortOrder
    tweetText?: SortOrder
    parentTweetId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TweetSumOrderByAggregateInput = {
    id?: SortOrder
    parentTweetId?: SortOrder
    userId?: SortOrder
  }

  export type HashTagCountOrderByAggregateInput = {
    id?: SortOrder
    hashTagText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HashTagAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type HashTagMaxOrderByAggregateInput = {
    id?: SortOrder
    hashTagText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HashTagMinOrderByAggregateInput = {
    id?: SortOrder
    hashTagText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HashTagSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DirectMessageCountOrderByAggregateInput = {
    id?: SortOrder
    dmText?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DirectMessageAvgOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
  }

  export type DirectMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    dmText?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DirectMessageMinOrderByAggregateInput = {
    id?: SortOrder
    dmText?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DirectMessageSumOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type ChannelListRelationFilter = {
    every?: ChannelWhereInput
    some?: ChannelWhereInput
    none?: ChannelWhereInput
  }

  export type UserToChannelwithRoleListRelationFilter = {
    every?: UserToChannelwithRoleWhereInput
    some?: UserToChannelwithRoleWhereInput
    none?: UserToChannelwithRoleWhereInput
  }

  export type VideoListRelationFilter = {
    every?: VideoWhereInput
    some?: VideoWhereInput
    none?: VideoWhereInput
  }

  export type UserToVideoWithReactionListRelationFilter = {
    every?: UserToVideoWithReactionWhereInput
    some?: UserToVideoWithReactionWhereInput
    none?: UserToVideoWithReactionWhereInput
  }

  export type VideoCommentListRelationFilter = {
    every?: VideoCommentWhereInput
    some?: VideoCommentWhereInput
    none?: VideoCommentWhereInput
  }

  export type ChannelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserToChannelwithRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VideoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserToVideoWithReactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VideoCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type YouTubeUserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    profileImageUrl?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YouTubeUserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type YouTubeUserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    profileImageUrl?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YouTubeUserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    profileImageUrl?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YouTubeUserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type YouTubeUserListRelationFilter = {
    every?: YouTubeUserWhereInput
    some?: YouTubeUserWhereInput
    none?: YouTubeUserWhereInput
  }

  export type YouTubeUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChannelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    profileImageUrl?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChannelAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ChannelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    profileImageUrl?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChannelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    profileImageUrl?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChannelSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type YouTubeUserRelationFilter = {
    is?: YouTubeUserWhereInput
    isNot?: YouTubeUserWhereInput
  }

  export type ChannelRelationFilter = {
    is?: ChannelWhereInput
    isNot?: ChannelWhereInput
  }

  export type EnumRoleEnumFilter = {
    equals?: RoleEnum
    in?: Enumerable<RoleEnum>
    notIn?: Enumerable<RoleEnum>
    not?: NestedEnumRoleEnumFilter | RoleEnum
  }

  export type UserToChannelwithRoleCountOrderByAggregateInput = {
    id?: SortOrder
    youTubeUserId?: SortOrder
    channelId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserToChannelwithRoleAvgOrderByAggregateInput = {
    id?: SortOrder
    youTubeUserId?: SortOrder
    channelId?: SortOrder
  }

  export type UserToChannelwithRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    youTubeUserId?: SortOrder
    channelId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserToChannelwithRoleMinOrderByAggregateInput = {
    id?: SortOrder
    youTubeUserId?: SortOrder
    channelId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserToChannelwithRoleSumOrderByAggregateInput = {
    id?: SortOrder
    youTubeUserId?: SortOrder
    channelId?: SortOrder
  }

  export type EnumRoleEnumWithAggregatesFilter = {
    equals?: RoleEnum
    in?: Enumerable<RoleEnum>
    notIn?: Enumerable<RoleEnum>
    not?: NestedEnumRoleEnumWithAggregatesFilter | RoleEnum
    _count?: NestedIntFilter
    _min?: NestedEnumRoleEnumFilter
    _max?: NestedEnumRoleEnumFilter
  }

  export type VideoCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    videoUrl?: SortOrder
    thumbnailImageUrl?: SortOrder
    description?: SortOrder
    channelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoAvgOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
  }

  export type VideoMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    videoUrl?: SortOrder
    thumbnailImageUrl?: SortOrder
    description?: SortOrder
    channelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    videoUrl?: SortOrder
    thumbnailImageUrl?: SortOrder
    description?: SortOrder
    channelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoSumOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
  }

  export type VideoRelationFilter = {
    is?: VideoWhereInput
    isNot?: VideoWhereInput
  }

  export type EnumReactionEnumFilter = {
    equals?: ReactionEnum
    in?: Enumerable<ReactionEnum>
    notIn?: Enumerable<ReactionEnum>
    not?: NestedEnumReactionEnumFilter | ReactionEnum
  }

  export type UserToVideoWithReactionCountOrderByAggregateInput = {
    id?: SortOrder
    youTubeUserId?: SortOrder
    videoId?: SortOrder
    reaction?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserToVideoWithReactionAvgOrderByAggregateInput = {
    id?: SortOrder
    youTubeUserId?: SortOrder
    videoId?: SortOrder
  }

  export type UserToVideoWithReactionMaxOrderByAggregateInput = {
    id?: SortOrder
    youTubeUserId?: SortOrder
    videoId?: SortOrder
    reaction?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserToVideoWithReactionMinOrderByAggregateInput = {
    id?: SortOrder
    youTubeUserId?: SortOrder
    videoId?: SortOrder
    reaction?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserToVideoWithReactionSumOrderByAggregateInput = {
    id?: SortOrder
    youTubeUserId?: SortOrder
    videoId?: SortOrder
  }

  export type EnumReactionEnumWithAggregatesFilter = {
    equals?: ReactionEnum
    in?: Enumerable<ReactionEnum>
    notIn?: Enumerable<ReactionEnum>
    not?: NestedEnumReactionEnumWithAggregatesFilter | ReactionEnum
    _count?: NestedIntFilter
    _min?: NestedEnumReactionEnumFilter
    _max?: NestedEnumReactionEnumFilter
  }

  export type VideoCommentRelationFilter = {
    is?: VideoCommentWhereInput | null
    isNot?: VideoCommentWhereInput | null
  }

  export type VideoCommentCountOrderByAggregateInput = {
    id?: SortOrder
    commentText?: SortOrder
    youTubeUserId?: SortOrder
    videoId?: SortOrder
    parentVideoCommentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoCommentAvgOrderByAggregateInput = {
    id?: SortOrder
    youTubeUserId?: SortOrder
    videoId?: SortOrder
    parentVideoCommentId?: SortOrder
  }

  export type VideoCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    commentText?: SortOrder
    youTubeUserId?: SortOrder
    videoId?: SortOrder
    parentVideoCommentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoCommentMinOrderByAggregateInput = {
    id?: SortOrder
    commentText?: SortOrder
    youTubeUserId?: SortOrder
    videoId?: SortOrder
    parentVideoCommentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoCommentSumOrderByAggregateInput = {
    id?: SortOrder
    youTubeUserId?: SortOrder
    videoId?: SortOrder
    parentVideoCommentId?: SortOrder
  }

  export type MenuCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<MenuCreateWithoutCategoryInput>, Enumerable<MenuUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<MenuCreateOrConnectWithoutCategoryInput>
    createMany?: MenuCreateManyCategoryInputEnvelope
    connect?: Enumerable<MenuWhereUniqueInput>
  }

  export type MenuUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<MenuCreateWithoutCategoryInput>, Enumerable<MenuUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<MenuCreateOrConnectWithoutCategoryInput>
    createMany?: MenuCreateManyCategoryInputEnvelope
    connect?: Enumerable<MenuWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type MenuUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<MenuCreateWithoutCategoryInput>, Enumerable<MenuUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<MenuCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<MenuUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: MenuCreateManyCategoryInputEnvelope
    set?: Enumerable<MenuWhereUniqueInput>
    disconnect?: Enumerable<MenuWhereUniqueInput>
    delete?: Enumerable<MenuWhereUniqueInput>
    connect?: Enumerable<MenuWhereUniqueInput>
    update?: Enumerable<MenuUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<MenuUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<MenuScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MenuUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<MenuCreateWithoutCategoryInput>, Enumerable<MenuUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<MenuCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<MenuUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: MenuCreateManyCategoryInputEnvelope
    set?: Enumerable<MenuWhereUniqueInput>
    disconnect?: Enumerable<MenuWhereUniqueInput>
    delete?: Enumerable<MenuWhereUniqueInput>
    connect?: Enumerable<MenuWhereUniqueInput>
    update?: Enumerable<MenuUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<MenuUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<MenuScalarWhereInput>
  }

  export type CategoryCreateNestedOneWithoutMenuInput = {
    create?: XOR<CategoryCreateWithoutMenuInput, CategoryUncheckedCreateWithoutMenuInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutMenuInput
    connect?: CategoryWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutMenuInput = {
    create?: XOR<Enumerable<OrderItemCreateWithoutMenuInput>, Enumerable<OrderItemUncheckedCreateWithoutMenuInput>>
    connectOrCreate?: Enumerable<OrderItemCreateOrConnectWithoutMenuInput>
    createMany?: OrderItemCreateManyMenuInputEnvelope
    connect?: Enumerable<OrderItemWhereUniqueInput>
  }

  export type OrderItemUncheckedCreateNestedManyWithoutMenuInput = {
    create?: XOR<Enumerable<OrderItemCreateWithoutMenuInput>, Enumerable<OrderItemUncheckedCreateWithoutMenuInput>>
    connectOrCreate?: Enumerable<OrderItemCreateOrConnectWithoutMenuInput>
    createMany?: OrderItemCreateManyMenuInputEnvelope
    connect?: Enumerable<OrderItemWhereUniqueInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CategoryUpdateOneWithoutMenuNestedInput = {
    create?: XOR<CategoryCreateWithoutMenuInput, CategoryUncheckedCreateWithoutMenuInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutMenuInput
    upsert?: CategoryUpsertWithoutMenuInput
    disconnect?: boolean
    delete?: boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<CategoryUpdateWithoutMenuInput, CategoryUncheckedUpdateWithoutMenuInput>
  }

  export type OrderItemUpdateManyWithoutMenuNestedInput = {
    create?: XOR<Enumerable<OrderItemCreateWithoutMenuInput>, Enumerable<OrderItemUncheckedCreateWithoutMenuInput>>
    connectOrCreate?: Enumerable<OrderItemCreateOrConnectWithoutMenuInput>
    upsert?: Enumerable<OrderItemUpsertWithWhereUniqueWithoutMenuInput>
    createMany?: OrderItemCreateManyMenuInputEnvelope
    set?: Enumerable<OrderItemWhereUniqueInput>
    disconnect?: Enumerable<OrderItemWhereUniqueInput>
    delete?: Enumerable<OrderItemWhereUniqueInput>
    connect?: Enumerable<OrderItemWhereUniqueInput>
    update?: Enumerable<OrderItemUpdateWithWhereUniqueWithoutMenuInput>
    updateMany?: Enumerable<OrderItemUpdateManyWithWhereWithoutMenuInput>
    deleteMany?: Enumerable<OrderItemScalarWhereInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OrderItemUncheckedUpdateManyWithoutMenuNestedInput = {
    create?: XOR<Enumerable<OrderItemCreateWithoutMenuInput>, Enumerable<OrderItemUncheckedCreateWithoutMenuInput>>
    connectOrCreate?: Enumerable<OrderItemCreateOrConnectWithoutMenuInput>
    upsert?: Enumerable<OrderItemUpsertWithWhereUniqueWithoutMenuInput>
    createMany?: OrderItemCreateManyMenuInputEnvelope
    set?: Enumerable<OrderItemWhereUniqueInput>
    disconnect?: Enumerable<OrderItemWhereUniqueInput>
    delete?: Enumerable<OrderItemWhereUniqueInput>
    connect?: Enumerable<OrderItemWhereUniqueInput>
    update?: Enumerable<OrderItemUpdateWithWhereUniqueWithoutMenuInput>
    updateMany?: Enumerable<OrderItemUpdateManyWithWhereWithoutMenuInput>
    deleteMany?: Enumerable<OrderItemScalarWhereInput>
  }

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<Enumerable<OrderItemCreateWithoutOrderInput>, Enumerable<OrderItemUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<OrderItemCreateOrConnectWithoutOrderInput>
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: Enumerable<OrderItemWhereUniqueInput>
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<Enumerable<OrderItemCreateWithoutOrderInput>, Enumerable<OrderItemUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<OrderItemCreateOrConnectWithoutOrderInput>
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: Enumerable<OrderItemWhereUniqueInput>
  }

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<Enumerable<OrderItemCreateWithoutOrderInput>, Enumerable<OrderItemUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<OrderItemCreateOrConnectWithoutOrderInput>
    upsert?: Enumerable<OrderItemUpsertWithWhereUniqueWithoutOrderInput>
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: Enumerable<OrderItemWhereUniqueInput>
    disconnect?: Enumerable<OrderItemWhereUniqueInput>
    delete?: Enumerable<OrderItemWhereUniqueInput>
    connect?: Enumerable<OrderItemWhereUniqueInput>
    update?: Enumerable<OrderItemUpdateWithWhereUniqueWithoutOrderInput>
    updateMany?: Enumerable<OrderItemUpdateManyWithWhereWithoutOrderInput>
    deleteMany?: Enumerable<OrderItemScalarWhereInput>
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<Enumerable<OrderItemCreateWithoutOrderInput>, Enumerable<OrderItemUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<OrderItemCreateOrConnectWithoutOrderInput>
    upsert?: Enumerable<OrderItemUpsertWithWhereUniqueWithoutOrderInput>
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: Enumerable<OrderItemWhereUniqueInput>
    disconnect?: Enumerable<OrderItemWhereUniqueInput>
    delete?: Enumerable<OrderItemWhereUniqueInput>
    connect?: Enumerable<OrderItemWhereUniqueInput>
    update?: Enumerable<OrderItemUpdateWithWhereUniqueWithoutOrderInput>
    updateMany?: Enumerable<OrderItemUpdateManyWithWhereWithoutOrderInput>
    deleteMany?: Enumerable<OrderItemScalarWhereInput>
  }

  export type MenuCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<MenuCreateWithoutOrderItemsInput, MenuUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: MenuCreateOrConnectWithoutOrderItemsInput
    connect?: MenuWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    connect?: OrderWhereUniqueInput
  }

  export type MenuUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<MenuCreateWithoutOrderItemsInput, MenuUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: MenuCreateOrConnectWithoutOrderItemsInput
    upsert?: MenuUpsertWithoutOrderItemsInput
    connect?: MenuWhereUniqueInput
    update?: XOR<MenuUpdateWithoutOrderItemsInput, MenuUncheckedUpdateWithoutOrderItemsInput>
  }

  export type OrderUpdateOneWithoutItemsNestedInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    upsert?: OrderUpsertWithoutItemsInput
    disconnect?: boolean
    delete?: boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type QuizCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<QuizCreateWithoutCategoryInput>, Enumerable<QuizUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<QuizCreateOrConnectWithoutCategoryInput>
    createMany?: QuizCreateManyCategoryInputEnvelope
    connect?: Enumerable<QuizWhereUniqueInput>
  }

  export type QuizUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<QuizCreateWithoutCategoryInput>, Enumerable<QuizUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<QuizCreateOrConnectWithoutCategoryInput>
    createMany?: QuizCreateManyCategoryInputEnvelope
    connect?: Enumerable<QuizWhereUniqueInput>
  }

  export type QuizUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<QuizCreateWithoutCategoryInput>, Enumerable<QuizUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<QuizCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<QuizUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: QuizCreateManyCategoryInputEnvelope
    set?: Enumerable<QuizWhereUniqueInput>
    disconnect?: Enumerable<QuizWhereUniqueInput>
    delete?: Enumerable<QuizWhereUniqueInput>
    connect?: Enumerable<QuizWhereUniqueInput>
    update?: Enumerable<QuizUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<QuizUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<QuizScalarWhereInput>
  }

  export type QuizUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<QuizCreateWithoutCategoryInput>, Enumerable<QuizUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<QuizCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<QuizUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: QuizCreateManyCategoryInputEnvelope
    set?: Enumerable<QuizWhereUniqueInput>
    disconnect?: Enumerable<QuizWhereUniqueInput>
    delete?: Enumerable<QuizWhereUniqueInput>
    connect?: Enumerable<QuizWhereUniqueInput>
    update?: Enumerable<QuizUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<QuizUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<QuizScalarWhereInput>
  }

  export type QuizCreateNestedOneWithoutChoicesInput = {
    create?: XOR<QuizCreateWithoutChoicesInput, QuizUncheckedCreateWithoutChoicesInput>
    connectOrCreate?: QuizCreateOrConnectWithoutChoicesInput
    connect?: QuizWhereUniqueInput
  }

  export type QuizCreateNestedManyWithoutCorrectChoiceInput = {
    create?: XOR<Enumerable<QuizCreateWithoutCorrectChoiceInput>, Enumerable<QuizUncheckedCreateWithoutCorrectChoiceInput>>
    connectOrCreate?: Enumerable<QuizCreateOrConnectWithoutCorrectChoiceInput>
    createMany?: QuizCreateManyCorrectChoiceInputEnvelope
    connect?: Enumerable<QuizWhereUniqueInput>
  }

  export type RoundCreateNestedManyWithoutSelectedChoicesInput = {
    create?: XOR<Enumerable<RoundCreateWithoutSelectedChoicesInput>, Enumerable<RoundUncheckedCreateWithoutSelectedChoicesInput>>
    connectOrCreate?: Enumerable<RoundCreateOrConnectWithoutSelectedChoicesInput>
    connect?: Enumerable<RoundWhereUniqueInput>
  }

  export type QuizUncheckedCreateNestedManyWithoutCorrectChoiceInput = {
    create?: XOR<Enumerable<QuizCreateWithoutCorrectChoiceInput>, Enumerable<QuizUncheckedCreateWithoutCorrectChoiceInput>>
    connectOrCreate?: Enumerable<QuizCreateOrConnectWithoutCorrectChoiceInput>
    createMany?: QuizCreateManyCorrectChoiceInputEnvelope
    connect?: Enumerable<QuizWhereUniqueInput>
  }

  export type RoundUncheckedCreateNestedManyWithoutSelectedChoicesInput = {
    create?: XOR<Enumerable<RoundCreateWithoutSelectedChoicesInput>, Enumerable<RoundUncheckedCreateWithoutSelectedChoicesInput>>
    connectOrCreate?: Enumerable<RoundCreateOrConnectWithoutSelectedChoicesInput>
    connect?: Enumerable<RoundWhereUniqueInput>
  }

  export type QuizUpdateOneWithoutChoicesNestedInput = {
    create?: XOR<QuizCreateWithoutChoicesInput, QuizUncheckedCreateWithoutChoicesInput>
    connectOrCreate?: QuizCreateOrConnectWithoutChoicesInput
    upsert?: QuizUpsertWithoutChoicesInput
    disconnect?: boolean
    delete?: boolean
    connect?: QuizWhereUniqueInput
    update?: XOR<QuizUpdateWithoutChoicesInput, QuizUncheckedUpdateWithoutChoicesInput>
  }

  export type QuizUpdateManyWithoutCorrectChoiceNestedInput = {
    create?: XOR<Enumerable<QuizCreateWithoutCorrectChoiceInput>, Enumerable<QuizUncheckedCreateWithoutCorrectChoiceInput>>
    connectOrCreate?: Enumerable<QuizCreateOrConnectWithoutCorrectChoiceInput>
    upsert?: Enumerable<QuizUpsertWithWhereUniqueWithoutCorrectChoiceInput>
    createMany?: QuizCreateManyCorrectChoiceInputEnvelope
    set?: Enumerable<QuizWhereUniqueInput>
    disconnect?: Enumerable<QuizWhereUniqueInput>
    delete?: Enumerable<QuizWhereUniqueInput>
    connect?: Enumerable<QuizWhereUniqueInput>
    update?: Enumerable<QuizUpdateWithWhereUniqueWithoutCorrectChoiceInput>
    updateMany?: Enumerable<QuizUpdateManyWithWhereWithoutCorrectChoiceInput>
    deleteMany?: Enumerable<QuizScalarWhereInput>
  }

  export type RoundUpdateManyWithoutSelectedChoicesNestedInput = {
    create?: XOR<Enumerable<RoundCreateWithoutSelectedChoicesInput>, Enumerable<RoundUncheckedCreateWithoutSelectedChoicesInput>>
    connectOrCreate?: Enumerable<RoundCreateOrConnectWithoutSelectedChoicesInput>
    upsert?: Enumerable<RoundUpsertWithWhereUniqueWithoutSelectedChoicesInput>
    set?: Enumerable<RoundWhereUniqueInput>
    disconnect?: Enumerable<RoundWhereUniqueInput>
    delete?: Enumerable<RoundWhereUniqueInput>
    connect?: Enumerable<RoundWhereUniqueInput>
    update?: Enumerable<RoundUpdateWithWhereUniqueWithoutSelectedChoicesInput>
    updateMany?: Enumerable<RoundUpdateManyWithWhereWithoutSelectedChoicesInput>
    deleteMany?: Enumerable<RoundScalarWhereInput>
  }

  export type QuizUncheckedUpdateManyWithoutCorrectChoiceNestedInput = {
    create?: XOR<Enumerable<QuizCreateWithoutCorrectChoiceInput>, Enumerable<QuizUncheckedCreateWithoutCorrectChoiceInput>>
    connectOrCreate?: Enumerable<QuizCreateOrConnectWithoutCorrectChoiceInput>
    upsert?: Enumerable<QuizUpsertWithWhereUniqueWithoutCorrectChoiceInput>
    createMany?: QuizCreateManyCorrectChoiceInputEnvelope
    set?: Enumerable<QuizWhereUniqueInput>
    disconnect?: Enumerable<QuizWhereUniqueInput>
    delete?: Enumerable<QuizWhereUniqueInput>
    connect?: Enumerable<QuizWhereUniqueInput>
    update?: Enumerable<QuizUpdateWithWhereUniqueWithoutCorrectChoiceInput>
    updateMany?: Enumerable<QuizUpdateManyWithWhereWithoutCorrectChoiceInput>
    deleteMany?: Enumerable<QuizScalarWhereInput>
  }

  export type RoundUncheckedUpdateManyWithoutSelectedChoicesNestedInput = {
    create?: XOR<Enumerable<RoundCreateWithoutSelectedChoicesInput>, Enumerable<RoundUncheckedCreateWithoutSelectedChoicesInput>>
    connectOrCreate?: Enumerable<RoundCreateOrConnectWithoutSelectedChoicesInput>
    upsert?: Enumerable<RoundUpsertWithWhereUniqueWithoutSelectedChoicesInput>
    set?: Enumerable<RoundWhereUniqueInput>
    disconnect?: Enumerable<RoundWhereUniqueInput>
    delete?: Enumerable<RoundWhereUniqueInput>
    connect?: Enumerable<RoundWhereUniqueInput>
    update?: Enumerable<RoundUpdateWithWhereUniqueWithoutSelectedChoicesInput>
    updateMany?: Enumerable<RoundUpdateManyWithWhereWithoutSelectedChoicesInput>
    deleteMany?: Enumerable<RoundScalarWhereInput>
  }

  export type QuizCategoryCreateNestedOneWithoutQuizzesInput = {
    create?: XOR<QuizCategoryCreateWithoutQuizzesInput, QuizCategoryUncheckedCreateWithoutQuizzesInput>
    connectOrCreate?: QuizCategoryCreateOrConnectWithoutQuizzesInput
    connect?: QuizCategoryWhereUniqueInput
  }

  export type ChoiceCreateNestedManyWithoutQuizInput = {
    create?: XOR<Enumerable<ChoiceCreateWithoutQuizInput>, Enumerable<ChoiceUncheckedCreateWithoutQuizInput>>
    connectOrCreate?: Enumerable<ChoiceCreateOrConnectWithoutQuizInput>
    createMany?: ChoiceCreateManyQuizInputEnvelope
    connect?: Enumerable<ChoiceWhereUniqueInput>
  }

  export type ChoiceCreateNestedOneWithoutCorrectQuizzesInput = {
    create?: XOR<ChoiceCreateWithoutCorrectQuizzesInput, ChoiceUncheckedCreateWithoutCorrectQuizzesInput>
    connectOrCreate?: ChoiceCreateOrConnectWithoutCorrectQuizzesInput
    connect?: ChoiceWhereUniqueInput
  }

  export type RoundCreateNestedManyWithoutQuizzesInput = {
    create?: XOR<Enumerable<RoundCreateWithoutQuizzesInput>, Enumerable<RoundUncheckedCreateWithoutQuizzesInput>>
    connectOrCreate?: Enumerable<RoundCreateOrConnectWithoutQuizzesInput>
    connect?: Enumerable<RoundWhereUniqueInput>
  }

  export type ChoiceUncheckedCreateNestedManyWithoutQuizInput = {
    create?: XOR<Enumerable<ChoiceCreateWithoutQuizInput>, Enumerable<ChoiceUncheckedCreateWithoutQuizInput>>
    connectOrCreate?: Enumerable<ChoiceCreateOrConnectWithoutQuizInput>
    createMany?: ChoiceCreateManyQuizInputEnvelope
    connect?: Enumerable<ChoiceWhereUniqueInput>
  }

  export type RoundUncheckedCreateNestedManyWithoutQuizzesInput = {
    create?: XOR<Enumerable<RoundCreateWithoutQuizzesInput>, Enumerable<RoundUncheckedCreateWithoutQuizzesInput>>
    connectOrCreate?: Enumerable<RoundCreateOrConnectWithoutQuizzesInput>
    connect?: Enumerable<RoundWhereUniqueInput>
  }

  export type QuizCategoryUpdateOneRequiredWithoutQuizzesNestedInput = {
    create?: XOR<QuizCategoryCreateWithoutQuizzesInput, QuizCategoryUncheckedCreateWithoutQuizzesInput>
    connectOrCreate?: QuizCategoryCreateOrConnectWithoutQuizzesInput
    upsert?: QuizCategoryUpsertWithoutQuizzesInput
    connect?: QuizCategoryWhereUniqueInput
    update?: XOR<QuizCategoryUpdateWithoutQuizzesInput, QuizCategoryUncheckedUpdateWithoutQuizzesInput>
  }

  export type ChoiceUpdateManyWithoutQuizNestedInput = {
    create?: XOR<Enumerable<ChoiceCreateWithoutQuizInput>, Enumerable<ChoiceUncheckedCreateWithoutQuizInput>>
    connectOrCreate?: Enumerable<ChoiceCreateOrConnectWithoutQuizInput>
    upsert?: Enumerable<ChoiceUpsertWithWhereUniqueWithoutQuizInput>
    createMany?: ChoiceCreateManyQuizInputEnvelope
    set?: Enumerable<ChoiceWhereUniqueInput>
    disconnect?: Enumerable<ChoiceWhereUniqueInput>
    delete?: Enumerable<ChoiceWhereUniqueInput>
    connect?: Enumerable<ChoiceWhereUniqueInput>
    update?: Enumerable<ChoiceUpdateWithWhereUniqueWithoutQuizInput>
    updateMany?: Enumerable<ChoiceUpdateManyWithWhereWithoutQuizInput>
    deleteMany?: Enumerable<ChoiceScalarWhereInput>
  }

  export type ChoiceUpdateOneRequiredWithoutCorrectQuizzesNestedInput = {
    create?: XOR<ChoiceCreateWithoutCorrectQuizzesInput, ChoiceUncheckedCreateWithoutCorrectQuizzesInput>
    connectOrCreate?: ChoiceCreateOrConnectWithoutCorrectQuizzesInput
    upsert?: ChoiceUpsertWithoutCorrectQuizzesInput
    connect?: ChoiceWhereUniqueInput
    update?: XOR<ChoiceUpdateWithoutCorrectQuizzesInput, ChoiceUncheckedUpdateWithoutCorrectQuizzesInput>
  }

  export type RoundUpdateManyWithoutQuizzesNestedInput = {
    create?: XOR<Enumerable<RoundCreateWithoutQuizzesInput>, Enumerable<RoundUncheckedCreateWithoutQuizzesInput>>
    connectOrCreate?: Enumerable<RoundCreateOrConnectWithoutQuizzesInput>
    upsert?: Enumerable<RoundUpsertWithWhereUniqueWithoutQuizzesInput>
    set?: Enumerable<RoundWhereUniqueInput>
    disconnect?: Enumerable<RoundWhereUniqueInput>
    delete?: Enumerable<RoundWhereUniqueInput>
    connect?: Enumerable<RoundWhereUniqueInput>
    update?: Enumerable<RoundUpdateWithWhereUniqueWithoutQuizzesInput>
    updateMany?: Enumerable<RoundUpdateManyWithWhereWithoutQuizzesInput>
    deleteMany?: Enumerable<RoundScalarWhereInput>
  }

  export type ChoiceUncheckedUpdateManyWithoutQuizNestedInput = {
    create?: XOR<Enumerable<ChoiceCreateWithoutQuizInput>, Enumerable<ChoiceUncheckedCreateWithoutQuizInput>>
    connectOrCreate?: Enumerable<ChoiceCreateOrConnectWithoutQuizInput>
    upsert?: Enumerable<ChoiceUpsertWithWhereUniqueWithoutQuizInput>
    createMany?: ChoiceCreateManyQuizInputEnvelope
    set?: Enumerable<ChoiceWhereUniqueInput>
    disconnect?: Enumerable<ChoiceWhereUniqueInput>
    delete?: Enumerable<ChoiceWhereUniqueInput>
    connect?: Enumerable<ChoiceWhereUniqueInput>
    update?: Enumerable<ChoiceUpdateWithWhereUniqueWithoutQuizInput>
    updateMany?: Enumerable<ChoiceUpdateManyWithWhereWithoutQuizInput>
    deleteMany?: Enumerable<ChoiceScalarWhereInput>
  }

  export type RoundUncheckedUpdateManyWithoutQuizzesNestedInput = {
    create?: XOR<Enumerable<RoundCreateWithoutQuizzesInput>, Enumerable<RoundUncheckedCreateWithoutQuizzesInput>>
    connectOrCreate?: Enumerable<RoundCreateOrConnectWithoutQuizzesInput>
    upsert?: Enumerable<RoundUpsertWithWhereUniqueWithoutQuizzesInput>
    set?: Enumerable<RoundWhereUniqueInput>
    disconnect?: Enumerable<RoundWhereUniqueInput>
    delete?: Enumerable<RoundWhereUniqueInput>
    connect?: Enumerable<RoundWhereUniqueInput>
    update?: Enumerable<RoundUpdateWithWhereUniqueWithoutQuizzesInput>
    updateMany?: Enumerable<RoundUpdateManyWithWhereWithoutQuizzesInput>
    deleteMany?: Enumerable<RoundScalarWhereInput>
  }

  export type QuizCreateNestedManyWithoutRoundsInput = {
    create?: XOR<Enumerable<QuizCreateWithoutRoundsInput>, Enumerable<QuizUncheckedCreateWithoutRoundsInput>>
    connectOrCreate?: Enumerable<QuizCreateOrConnectWithoutRoundsInput>
    connect?: Enumerable<QuizWhereUniqueInput>
  }

  export type ChoiceCreateNestedManyWithoutRoundsInput = {
    create?: XOR<Enumerable<ChoiceCreateWithoutRoundsInput>, Enumerable<ChoiceUncheckedCreateWithoutRoundsInput>>
    connectOrCreate?: Enumerable<ChoiceCreateOrConnectWithoutRoundsInput>
    connect?: Enumerable<ChoiceWhereUniqueInput>
  }

  export type QuizUncheckedCreateNestedManyWithoutRoundsInput = {
    create?: XOR<Enumerable<QuizCreateWithoutRoundsInput>, Enumerable<QuizUncheckedCreateWithoutRoundsInput>>
    connectOrCreate?: Enumerable<QuizCreateOrConnectWithoutRoundsInput>
    connect?: Enumerable<QuizWhereUniqueInput>
  }

  export type ChoiceUncheckedCreateNestedManyWithoutRoundsInput = {
    create?: XOR<Enumerable<ChoiceCreateWithoutRoundsInput>, Enumerable<ChoiceUncheckedCreateWithoutRoundsInput>>
    connectOrCreate?: Enumerable<ChoiceCreateOrConnectWithoutRoundsInput>
    connect?: Enumerable<ChoiceWhereUniqueInput>
  }

  export type QuizUpdateManyWithoutRoundsNestedInput = {
    create?: XOR<Enumerable<QuizCreateWithoutRoundsInput>, Enumerable<QuizUncheckedCreateWithoutRoundsInput>>
    connectOrCreate?: Enumerable<QuizCreateOrConnectWithoutRoundsInput>
    upsert?: Enumerable<QuizUpsertWithWhereUniqueWithoutRoundsInput>
    set?: Enumerable<QuizWhereUniqueInput>
    disconnect?: Enumerable<QuizWhereUniqueInput>
    delete?: Enumerable<QuizWhereUniqueInput>
    connect?: Enumerable<QuizWhereUniqueInput>
    update?: Enumerable<QuizUpdateWithWhereUniqueWithoutRoundsInput>
    updateMany?: Enumerable<QuizUpdateManyWithWhereWithoutRoundsInput>
    deleteMany?: Enumerable<QuizScalarWhereInput>
  }

  export type ChoiceUpdateManyWithoutRoundsNestedInput = {
    create?: XOR<Enumerable<ChoiceCreateWithoutRoundsInput>, Enumerable<ChoiceUncheckedCreateWithoutRoundsInput>>
    connectOrCreate?: Enumerable<ChoiceCreateOrConnectWithoutRoundsInput>
    upsert?: Enumerable<ChoiceUpsertWithWhereUniqueWithoutRoundsInput>
    set?: Enumerable<ChoiceWhereUniqueInput>
    disconnect?: Enumerable<ChoiceWhereUniqueInput>
    delete?: Enumerable<ChoiceWhereUniqueInput>
    connect?: Enumerable<ChoiceWhereUniqueInput>
    update?: Enumerable<ChoiceUpdateWithWhereUniqueWithoutRoundsInput>
    updateMany?: Enumerable<ChoiceUpdateManyWithWhereWithoutRoundsInput>
    deleteMany?: Enumerable<ChoiceScalarWhereInput>
  }

  export type QuizUncheckedUpdateManyWithoutRoundsNestedInput = {
    create?: XOR<Enumerable<QuizCreateWithoutRoundsInput>, Enumerable<QuizUncheckedCreateWithoutRoundsInput>>
    connectOrCreate?: Enumerable<QuizCreateOrConnectWithoutRoundsInput>
    upsert?: Enumerable<QuizUpsertWithWhereUniqueWithoutRoundsInput>
    set?: Enumerable<QuizWhereUniqueInput>
    disconnect?: Enumerable<QuizWhereUniqueInput>
    delete?: Enumerable<QuizWhereUniqueInput>
    connect?: Enumerable<QuizWhereUniqueInput>
    update?: Enumerable<QuizUpdateWithWhereUniqueWithoutRoundsInput>
    updateMany?: Enumerable<QuizUpdateManyWithWhereWithoutRoundsInput>
    deleteMany?: Enumerable<QuizScalarWhereInput>
  }

  export type ChoiceUncheckedUpdateManyWithoutRoundsNestedInput = {
    create?: XOR<Enumerable<ChoiceCreateWithoutRoundsInput>, Enumerable<ChoiceUncheckedCreateWithoutRoundsInput>>
    connectOrCreate?: Enumerable<ChoiceCreateOrConnectWithoutRoundsInput>
    upsert?: Enumerable<ChoiceUpsertWithWhereUniqueWithoutRoundsInput>
    set?: Enumerable<ChoiceWhereUniqueInput>
    disconnect?: Enumerable<ChoiceWhereUniqueInput>
    delete?: Enumerable<ChoiceWhereUniqueInput>
    connect?: Enumerable<ChoiceWhereUniqueInput>
    update?: Enumerable<ChoiceUpdateWithWhereUniqueWithoutRoundsInput>
    updateMany?: Enumerable<ChoiceUpdateManyWithWhereWithoutRoundsInput>
    deleteMany?: Enumerable<ChoiceScalarWhereInput>
  }

  export type FacebookUserRelationCreateNestedManyWithoutFollowingUserInput = {
    create?: XOR<Enumerable<FacebookUserRelationCreateWithoutFollowingUserInput>, Enumerable<FacebookUserRelationUncheckedCreateWithoutFollowingUserInput>>
    connectOrCreate?: Enumerable<FacebookUserRelationCreateOrConnectWithoutFollowingUserInput>
    createMany?: FacebookUserRelationCreateManyFollowingUserInputEnvelope
    connect?: Enumerable<FacebookUserRelationWhereUniqueInput>
  }

  export type FacebookUserRelationCreateNestedManyWithoutFollowedUserInput = {
    create?: XOR<Enumerable<FacebookUserRelationCreateWithoutFollowedUserInput>, Enumerable<FacebookUserRelationUncheckedCreateWithoutFollowedUserInput>>
    connectOrCreate?: Enumerable<FacebookUserRelationCreateOrConnectWithoutFollowedUserInput>
    createMany?: FacebookUserRelationCreateManyFollowedUserInputEnvelope
    connect?: Enumerable<FacebookUserRelationWhereUniqueInput>
  }

  export type PostCreateNestedManyWithoutPostingUserInput = {
    create?: XOR<Enumerable<PostCreateWithoutPostingUserInput>, Enumerable<PostUncheckedCreateWithoutPostingUserInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutPostingUserInput>
    createMany?: PostCreateManyPostingUserInputEnvelope
    connect?: Enumerable<PostWhereUniqueInput>
  }

  export type CommentCreateNestedManyWithoutCommentingUserInput = {
    create?: XOR<Enumerable<CommentCreateWithoutCommentingUserInput>, Enumerable<CommentUncheckedCreateWithoutCommentingUserInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutCommentingUserInput>
    createMany?: CommentCreateManyCommentingUserInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type MessengerMessageCreateNestedManyWithoutFromUserInput = {
    create?: XOR<Enumerable<MessengerMessageCreateWithoutFromUserInput>, Enumerable<MessengerMessageUncheckedCreateWithoutFromUserInput>>
    connectOrCreate?: Enumerable<MessengerMessageCreateOrConnectWithoutFromUserInput>
    createMany?: MessengerMessageCreateManyFromUserInputEnvelope
    connect?: Enumerable<MessengerMessageWhereUniqueInput>
  }

  export type MessengerMessageCreateNestedManyWithoutToUserInput = {
    create?: XOR<Enumerable<MessengerMessageCreateWithoutToUserInput>, Enumerable<MessengerMessageUncheckedCreateWithoutToUserInput>>
    connectOrCreate?: Enumerable<MessengerMessageCreateOrConnectWithoutToUserInput>
    createMany?: MessengerMessageCreateManyToUserInputEnvelope
    connect?: Enumerable<MessengerMessageWhereUniqueInput>
  }

  export type FacebookUserRelationUncheckedCreateNestedManyWithoutFollowingUserInput = {
    create?: XOR<Enumerable<FacebookUserRelationCreateWithoutFollowingUserInput>, Enumerable<FacebookUserRelationUncheckedCreateWithoutFollowingUserInput>>
    connectOrCreate?: Enumerable<FacebookUserRelationCreateOrConnectWithoutFollowingUserInput>
    createMany?: FacebookUserRelationCreateManyFollowingUserInputEnvelope
    connect?: Enumerable<FacebookUserRelationWhereUniqueInput>
  }

  export type FacebookUserRelationUncheckedCreateNestedManyWithoutFollowedUserInput = {
    create?: XOR<Enumerable<FacebookUserRelationCreateWithoutFollowedUserInput>, Enumerable<FacebookUserRelationUncheckedCreateWithoutFollowedUserInput>>
    connectOrCreate?: Enumerable<FacebookUserRelationCreateOrConnectWithoutFollowedUserInput>
    createMany?: FacebookUserRelationCreateManyFollowedUserInputEnvelope
    connect?: Enumerable<FacebookUserRelationWhereUniqueInput>
  }

  export type PostUncheckedCreateNestedManyWithoutPostingUserInput = {
    create?: XOR<Enumerable<PostCreateWithoutPostingUserInput>, Enumerable<PostUncheckedCreateWithoutPostingUserInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutPostingUserInput>
    createMany?: PostCreateManyPostingUserInputEnvelope
    connect?: Enumerable<PostWhereUniqueInput>
  }

  export type CommentUncheckedCreateNestedManyWithoutCommentingUserInput = {
    create?: XOR<Enumerable<CommentCreateWithoutCommentingUserInput>, Enumerable<CommentUncheckedCreateWithoutCommentingUserInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutCommentingUserInput>
    createMany?: CommentCreateManyCommentingUserInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type MessengerMessageUncheckedCreateNestedManyWithoutFromUserInput = {
    create?: XOR<Enumerable<MessengerMessageCreateWithoutFromUserInput>, Enumerable<MessengerMessageUncheckedCreateWithoutFromUserInput>>
    connectOrCreate?: Enumerable<MessengerMessageCreateOrConnectWithoutFromUserInput>
    createMany?: MessengerMessageCreateManyFromUserInputEnvelope
    connect?: Enumerable<MessengerMessageWhereUniqueInput>
  }

  export type MessengerMessageUncheckedCreateNestedManyWithoutToUserInput = {
    create?: XOR<Enumerable<MessengerMessageCreateWithoutToUserInput>, Enumerable<MessengerMessageUncheckedCreateWithoutToUserInput>>
    connectOrCreate?: Enumerable<MessengerMessageCreateOrConnectWithoutToUserInput>
    createMany?: MessengerMessageCreateManyToUserInputEnvelope
    connect?: Enumerable<MessengerMessageWhereUniqueInput>
  }

  export type FacebookUserRelationUpdateManyWithoutFollowingUserNestedInput = {
    create?: XOR<Enumerable<FacebookUserRelationCreateWithoutFollowingUserInput>, Enumerable<FacebookUserRelationUncheckedCreateWithoutFollowingUserInput>>
    connectOrCreate?: Enumerable<FacebookUserRelationCreateOrConnectWithoutFollowingUserInput>
    upsert?: Enumerable<FacebookUserRelationUpsertWithWhereUniqueWithoutFollowingUserInput>
    createMany?: FacebookUserRelationCreateManyFollowingUserInputEnvelope
    set?: Enumerable<FacebookUserRelationWhereUniqueInput>
    disconnect?: Enumerable<FacebookUserRelationWhereUniqueInput>
    delete?: Enumerable<FacebookUserRelationWhereUniqueInput>
    connect?: Enumerable<FacebookUserRelationWhereUniqueInput>
    update?: Enumerable<FacebookUserRelationUpdateWithWhereUniqueWithoutFollowingUserInput>
    updateMany?: Enumerable<FacebookUserRelationUpdateManyWithWhereWithoutFollowingUserInput>
    deleteMany?: Enumerable<FacebookUserRelationScalarWhereInput>
  }

  export type FacebookUserRelationUpdateManyWithoutFollowedUserNestedInput = {
    create?: XOR<Enumerable<FacebookUserRelationCreateWithoutFollowedUserInput>, Enumerable<FacebookUserRelationUncheckedCreateWithoutFollowedUserInput>>
    connectOrCreate?: Enumerable<FacebookUserRelationCreateOrConnectWithoutFollowedUserInput>
    upsert?: Enumerable<FacebookUserRelationUpsertWithWhereUniqueWithoutFollowedUserInput>
    createMany?: FacebookUserRelationCreateManyFollowedUserInputEnvelope
    set?: Enumerable<FacebookUserRelationWhereUniqueInput>
    disconnect?: Enumerable<FacebookUserRelationWhereUniqueInput>
    delete?: Enumerable<FacebookUserRelationWhereUniqueInput>
    connect?: Enumerable<FacebookUserRelationWhereUniqueInput>
    update?: Enumerable<FacebookUserRelationUpdateWithWhereUniqueWithoutFollowedUserInput>
    updateMany?: Enumerable<FacebookUserRelationUpdateManyWithWhereWithoutFollowedUserInput>
    deleteMany?: Enumerable<FacebookUserRelationScalarWhereInput>
  }

  export type PostUpdateManyWithoutPostingUserNestedInput = {
    create?: XOR<Enumerable<PostCreateWithoutPostingUserInput>, Enumerable<PostUncheckedCreateWithoutPostingUserInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutPostingUserInput>
    upsert?: Enumerable<PostUpsertWithWhereUniqueWithoutPostingUserInput>
    createMany?: PostCreateManyPostingUserInputEnvelope
    set?: Enumerable<PostWhereUniqueInput>
    disconnect?: Enumerable<PostWhereUniqueInput>
    delete?: Enumerable<PostWhereUniqueInput>
    connect?: Enumerable<PostWhereUniqueInput>
    update?: Enumerable<PostUpdateWithWhereUniqueWithoutPostingUserInput>
    updateMany?: Enumerable<PostUpdateManyWithWhereWithoutPostingUserInput>
    deleteMany?: Enumerable<PostScalarWhereInput>
  }

  export type CommentUpdateManyWithoutCommentingUserNestedInput = {
    create?: XOR<Enumerable<CommentCreateWithoutCommentingUserInput>, Enumerable<CommentUncheckedCreateWithoutCommentingUserInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutCommentingUserInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutCommentingUserInput>
    createMany?: CommentCreateManyCommentingUserInputEnvelope
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    connect?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutCommentingUserInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutCommentingUserInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type MessengerMessageUpdateManyWithoutFromUserNestedInput = {
    create?: XOR<Enumerable<MessengerMessageCreateWithoutFromUserInput>, Enumerable<MessengerMessageUncheckedCreateWithoutFromUserInput>>
    connectOrCreate?: Enumerable<MessengerMessageCreateOrConnectWithoutFromUserInput>
    upsert?: Enumerable<MessengerMessageUpsertWithWhereUniqueWithoutFromUserInput>
    createMany?: MessengerMessageCreateManyFromUserInputEnvelope
    set?: Enumerable<MessengerMessageWhereUniqueInput>
    disconnect?: Enumerable<MessengerMessageWhereUniqueInput>
    delete?: Enumerable<MessengerMessageWhereUniqueInput>
    connect?: Enumerable<MessengerMessageWhereUniqueInput>
    update?: Enumerable<MessengerMessageUpdateWithWhereUniqueWithoutFromUserInput>
    updateMany?: Enumerable<MessengerMessageUpdateManyWithWhereWithoutFromUserInput>
    deleteMany?: Enumerable<MessengerMessageScalarWhereInput>
  }

  export type MessengerMessageUpdateManyWithoutToUserNestedInput = {
    create?: XOR<Enumerable<MessengerMessageCreateWithoutToUserInput>, Enumerable<MessengerMessageUncheckedCreateWithoutToUserInput>>
    connectOrCreate?: Enumerable<MessengerMessageCreateOrConnectWithoutToUserInput>
    upsert?: Enumerable<MessengerMessageUpsertWithWhereUniqueWithoutToUserInput>
    createMany?: MessengerMessageCreateManyToUserInputEnvelope
    set?: Enumerable<MessengerMessageWhereUniqueInput>
    disconnect?: Enumerable<MessengerMessageWhereUniqueInput>
    delete?: Enumerable<MessengerMessageWhereUniqueInput>
    connect?: Enumerable<MessengerMessageWhereUniqueInput>
    update?: Enumerable<MessengerMessageUpdateWithWhereUniqueWithoutToUserInput>
    updateMany?: Enumerable<MessengerMessageUpdateManyWithWhereWithoutToUserInput>
    deleteMany?: Enumerable<MessengerMessageScalarWhereInput>
  }

  export type FacebookUserRelationUncheckedUpdateManyWithoutFollowingUserNestedInput = {
    create?: XOR<Enumerable<FacebookUserRelationCreateWithoutFollowingUserInput>, Enumerable<FacebookUserRelationUncheckedCreateWithoutFollowingUserInput>>
    connectOrCreate?: Enumerable<FacebookUserRelationCreateOrConnectWithoutFollowingUserInput>
    upsert?: Enumerable<FacebookUserRelationUpsertWithWhereUniqueWithoutFollowingUserInput>
    createMany?: FacebookUserRelationCreateManyFollowingUserInputEnvelope
    set?: Enumerable<FacebookUserRelationWhereUniqueInput>
    disconnect?: Enumerable<FacebookUserRelationWhereUniqueInput>
    delete?: Enumerable<FacebookUserRelationWhereUniqueInput>
    connect?: Enumerable<FacebookUserRelationWhereUniqueInput>
    update?: Enumerable<FacebookUserRelationUpdateWithWhereUniqueWithoutFollowingUserInput>
    updateMany?: Enumerable<FacebookUserRelationUpdateManyWithWhereWithoutFollowingUserInput>
    deleteMany?: Enumerable<FacebookUserRelationScalarWhereInput>
  }

  export type FacebookUserRelationUncheckedUpdateManyWithoutFollowedUserNestedInput = {
    create?: XOR<Enumerable<FacebookUserRelationCreateWithoutFollowedUserInput>, Enumerable<FacebookUserRelationUncheckedCreateWithoutFollowedUserInput>>
    connectOrCreate?: Enumerable<FacebookUserRelationCreateOrConnectWithoutFollowedUserInput>
    upsert?: Enumerable<FacebookUserRelationUpsertWithWhereUniqueWithoutFollowedUserInput>
    createMany?: FacebookUserRelationCreateManyFollowedUserInputEnvelope
    set?: Enumerable<FacebookUserRelationWhereUniqueInput>
    disconnect?: Enumerable<FacebookUserRelationWhereUniqueInput>
    delete?: Enumerable<FacebookUserRelationWhereUniqueInput>
    connect?: Enumerable<FacebookUserRelationWhereUniqueInput>
    update?: Enumerable<FacebookUserRelationUpdateWithWhereUniqueWithoutFollowedUserInput>
    updateMany?: Enumerable<FacebookUserRelationUpdateManyWithWhereWithoutFollowedUserInput>
    deleteMany?: Enumerable<FacebookUserRelationScalarWhereInput>
  }

  export type PostUncheckedUpdateManyWithoutPostingUserNestedInput = {
    create?: XOR<Enumerable<PostCreateWithoutPostingUserInput>, Enumerable<PostUncheckedCreateWithoutPostingUserInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutPostingUserInput>
    upsert?: Enumerable<PostUpsertWithWhereUniqueWithoutPostingUserInput>
    createMany?: PostCreateManyPostingUserInputEnvelope
    set?: Enumerable<PostWhereUniqueInput>
    disconnect?: Enumerable<PostWhereUniqueInput>
    delete?: Enumerable<PostWhereUniqueInput>
    connect?: Enumerable<PostWhereUniqueInput>
    update?: Enumerable<PostUpdateWithWhereUniqueWithoutPostingUserInput>
    updateMany?: Enumerable<PostUpdateManyWithWhereWithoutPostingUserInput>
    deleteMany?: Enumerable<PostScalarWhereInput>
  }

  export type CommentUncheckedUpdateManyWithoutCommentingUserNestedInput = {
    create?: XOR<Enumerable<CommentCreateWithoutCommentingUserInput>, Enumerable<CommentUncheckedCreateWithoutCommentingUserInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutCommentingUserInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutCommentingUserInput>
    createMany?: CommentCreateManyCommentingUserInputEnvelope
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    connect?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutCommentingUserInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutCommentingUserInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type MessengerMessageUncheckedUpdateManyWithoutFromUserNestedInput = {
    create?: XOR<Enumerable<MessengerMessageCreateWithoutFromUserInput>, Enumerable<MessengerMessageUncheckedCreateWithoutFromUserInput>>
    connectOrCreate?: Enumerable<MessengerMessageCreateOrConnectWithoutFromUserInput>
    upsert?: Enumerable<MessengerMessageUpsertWithWhereUniqueWithoutFromUserInput>
    createMany?: MessengerMessageCreateManyFromUserInputEnvelope
    set?: Enumerable<MessengerMessageWhereUniqueInput>
    disconnect?: Enumerable<MessengerMessageWhereUniqueInput>
    delete?: Enumerable<MessengerMessageWhereUniqueInput>
    connect?: Enumerable<MessengerMessageWhereUniqueInput>
    update?: Enumerable<MessengerMessageUpdateWithWhereUniqueWithoutFromUserInput>
    updateMany?: Enumerable<MessengerMessageUpdateManyWithWhereWithoutFromUserInput>
    deleteMany?: Enumerable<MessengerMessageScalarWhereInput>
  }

  export type MessengerMessageUncheckedUpdateManyWithoutToUserNestedInput = {
    create?: XOR<Enumerable<MessengerMessageCreateWithoutToUserInput>, Enumerable<MessengerMessageUncheckedCreateWithoutToUserInput>>
    connectOrCreate?: Enumerable<MessengerMessageCreateOrConnectWithoutToUserInput>
    upsert?: Enumerable<MessengerMessageUpsertWithWhereUniqueWithoutToUserInput>
    createMany?: MessengerMessageCreateManyToUserInputEnvelope
    set?: Enumerable<MessengerMessageWhereUniqueInput>
    disconnect?: Enumerable<MessengerMessageWhereUniqueInput>
    delete?: Enumerable<MessengerMessageWhereUniqueInput>
    connect?: Enumerable<MessengerMessageWhereUniqueInput>
    update?: Enumerable<MessengerMessageUpdateWithWhereUniqueWithoutToUserInput>
    updateMany?: Enumerable<MessengerMessageUpdateManyWithWhereWithoutToUserInput>
    deleteMany?: Enumerable<MessengerMessageScalarWhereInput>
  }

  export type FacebookUserCreateNestedOneWithoutFollowingUserRelationsInput = {
    create?: XOR<FacebookUserCreateWithoutFollowingUserRelationsInput, FacebookUserUncheckedCreateWithoutFollowingUserRelationsInput>
    connectOrCreate?: FacebookUserCreateOrConnectWithoutFollowingUserRelationsInput
    connect?: FacebookUserWhereUniqueInput
  }

  export type FacebookUserCreateNestedOneWithoutFollowedUserRelationsInput = {
    create?: XOR<FacebookUserCreateWithoutFollowedUserRelationsInput, FacebookUserUncheckedCreateWithoutFollowedUserRelationsInput>
    connectOrCreate?: FacebookUserCreateOrConnectWithoutFollowedUserRelationsInput
    connect?: FacebookUserWhereUniqueInput
  }

  export type FacebookUserUpdateOneRequiredWithoutFollowingUserRelationsNestedInput = {
    create?: XOR<FacebookUserCreateWithoutFollowingUserRelationsInput, FacebookUserUncheckedCreateWithoutFollowingUserRelationsInput>
    connectOrCreate?: FacebookUserCreateOrConnectWithoutFollowingUserRelationsInput
    upsert?: FacebookUserUpsertWithoutFollowingUserRelationsInput
    connect?: FacebookUserWhereUniqueInput
    update?: XOR<FacebookUserUpdateWithoutFollowingUserRelationsInput, FacebookUserUncheckedUpdateWithoutFollowingUserRelationsInput>
  }

  export type FacebookUserUpdateOneRequiredWithoutFollowedUserRelationsNestedInput = {
    create?: XOR<FacebookUserCreateWithoutFollowedUserRelationsInput, FacebookUserUncheckedCreateWithoutFollowedUserRelationsInput>
    connectOrCreate?: FacebookUserCreateOrConnectWithoutFollowedUserRelationsInput
    upsert?: FacebookUserUpsertWithoutFollowedUserRelationsInput
    connect?: FacebookUserWhereUniqueInput
    update?: XOR<FacebookUserUpdateWithoutFollowedUserRelationsInput, FacebookUserUncheckedUpdateWithoutFollowedUserRelationsInput>
  }

  export type FacebookUserCreateNestedOneWithoutPostsInput = {
    create?: XOR<FacebookUserCreateWithoutPostsInput, FacebookUserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: FacebookUserCreateOrConnectWithoutPostsInput
    connect?: FacebookUserWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutParentPostInput = {
    create?: XOR<Enumerable<CommentCreateWithoutParentPostInput>, Enumerable<CommentUncheckedCreateWithoutParentPostInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutParentPostInput>
    createMany?: CommentCreateManyParentPostInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type FacebookHashTagCreateNestedManyWithoutIsInPostsInput = {
    create?: XOR<Enumerable<FacebookHashTagCreateWithoutIsInPostsInput>, Enumerable<FacebookHashTagUncheckedCreateWithoutIsInPostsInput>>
    connectOrCreate?: Enumerable<FacebookHashTagCreateOrConnectWithoutIsInPostsInput>
    connect?: Enumerable<FacebookHashTagWhereUniqueInput>
  }

  export type CommentUncheckedCreateNestedManyWithoutParentPostInput = {
    create?: XOR<Enumerable<CommentCreateWithoutParentPostInput>, Enumerable<CommentUncheckedCreateWithoutParentPostInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutParentPostInput>
    createMany?: CommentCreateManyParentPostInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type FacebookHashTagUncheckedCreateNestedManyWithoutIsInPostsInput = {
    create?: XOR<Enumerable<FacebookHashTagCreateWithoutIsInPostsInput>, Enumerable<FacebookHashTagUncheckedCreateWithoutIsInPostsInput>>
    connectOrCreate?: Enumerable<FacebookHashTagCreateOrConnectWithoutIsInPostsInput>
    connect?: Enumerable<FacebookHashTagWhereUniqueInput>
  }

  export type FacebookUserUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<FacebookUserCreateWithoutPostsInput, FacebookUserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: FacebookUserCreateOrConnectWithoutPostsInput
    upsert?: FacebookUserUpsertWithoutPostsInput
    connect?: FacebookUserWhereUniqueInput
    update?: XOR<FacebookUserUpdateWithoutPostsInput, FacebookUserUncheckedUpdateWithoutPostsInput>
  }

  export type CommentUpdateManyWithoutParentPostNestedInput = {
    create?: XOR<Enumerable<CommentCreateWithoutParentPostInput>, Enumerable<CommentUncheckedCreateWithoutParentPostInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutParentPostInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutParentPostInput>
    createMany?: CommentCreateManyParentPostInputEnvelope
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    connect?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutParentPostInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutParentPostInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type FacebookHashTagUpdateManyWithoutIsInPostsNestedInput = {
    create?: XOR<Enumerable<FacebookHashTagCreateWithoutIsInPostsInput>, Enumerable<FacebookHashTagUncheckedCreateWithoutIsInPostsInput>>
    connectOrCreate?: Enumerable<FacebookHashTagCreateOrConnectWithoutIsInPostsInput>
    upsert?: Enumerable<FacebookHashTagUpsertWithWhereUniqueWithoutIsInPostsInput>
    set?: Enumerable<FacebookHashTagWhereUniqueInput>
    disconnect?: Enumerable<FacebookHashTagWhereUniqueInput>
    delete?: Enumerable<FacebookHashTagWhereUniqueInput>
    connect?: Enumerable<FacebookHashTagWhereUniqueInput>
    update?: Enumerable<FacebookHashTagUpdateWithWhereUniqueWithoutIsInPostsInput>
    updateMany?: Enumerable<FacebookHashTagUpdateManyWithWhereWithoutIsInPostsInput>
    deleteMany?: Enumerable<FacebookHashTagScalarWhereInput>
  }

  export type CommentUncheckedUpdateManyWithoutParentPostNestedInput = {
    create?: XOR<Enumerable<CommentCreateWithoutParentPostInput>, Enumerable<CommentUncheckedCreateWithoutParentPostInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutParentPostInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutParentPostInput>
    createMany?: CommentCreateManyParentPostInputEnvelope
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    connect?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutParentPostInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutParentPostInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type FacebookHashTagUncheckedUpdateManyWithoutIsInPostsNestedInput = {
    create?: XOR<Enumerable<FacebookHashTagCreateWithoutIsInPostsInput>, Enumerable<FacebookHashTagUncheckedCreateWithoutIsInPostsInput>>
    connectOrCreate?: Enumerable<FacebookHashTagCreateOrConnectWithoutIsInPostsInput>
    upsert?: Enumerable<FacebookHashTagUpsertWithWhereUniqueWithoutIsInPostsInput>
    set?: Enumerable<FacebookHashTagWhereUniqueInput>
    disconnect?: Enumerable<FacebookHashTagWhereUniqueInput>
    delete?: Enumerable<FacebookHashTagWhereUniqueInput>
    connect?: Enumerable<FacebookHashTagWhereUniqueInput>
    update?: Enumerable<FacebookHashTagUpdateWithWhereUniqueWithoutIsInPostsInput>
    updateMany?: Enumerable<FacebookHashTagUpdateManyWithWhereWithoutIsInPostsInput>
    deleteMany?: Enumerable<FacebookHashTagScalarWhereInput>
  }

  export type FacebookUserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<FacebookUserCreateWithoutCommentsInput, FacebookUserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: FacebookUserCreateOrConnectWithoutCommentsInput
    connect?: FacebookUserWhereUniqueInput
  }

  export type PostCreateNestedOneWithoutCommentsInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    connect?: PostWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutChildCommentsInput = {
    create?: XOR<CommentCreateWithoutChildCommentsInput, CommentUncheckedCreateWithoutChildCommentsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutChildCommentsInput
    connect?: CommentWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutParentCommentInput = {
    create?: XOR<Enumerable<CommentCreateWithoutParentCommentInput>, Enumerable<CommentUncheckedCreateWithoutParentCommentInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutParentCommentInput>
    createMany?: CommentCreateManyParentCommentInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type CommentUncheckedCreateNestedManyWithoutParentCommentInput = {
    create?: XOR<Enumerable<CommentCreateWithoutParentCommentInput>, Enumerable<CommentUncheckedCreateWithoutParentCommentInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutParentCommentInput>
    createMany?: CommentCreateManyParentCommentInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type FacebookUserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<FacebookUserCreateWithoutCommentsInput, FacebookUserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: FacebookUserCreateOrConnectWithoutCommentsInput
    upsert?: FacebookUserUpsertWithoutCommentsInput
    connect?: FacebookUserWhereUniqueInput
    update?: XOR<FacebookUserUpdateWithoutCommentsInput, FacebookUserUncheckedUpdateWithoutCommentsInput>
  }

  export type PostUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    upsert?: PostUpsertWithoutCommentsInput
    connect?: PostWhereUniqueInput
    update?: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
  }

  export type CommentUpdateOneWithoutChildCommentsNestedInput = {
    create?: XOR<CommentCreateWithoutChildCommentsInput, CommentUncheckedCreateWithoutChildCommentsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutChildCommentsInput
    upsert?: CommentUpsertWithoutChildCommentsInput
    disconnect?: boolean
    delete?: boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<CommentUpdateWithoutChildCommentsInput, CommentUncheckedUpdateWithoutChildCommentsInput>
  }

  export type CommentUpdateManyWithoutParentCommentNestedInput = {
    create?: XOR<Enumerable<CommentCreateWithoutParentCommentInput>, Enumerable<CommentUncheckedCreateWithoutParentCommentInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutParentCommentInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutParentCommentInput>
    createMany?: CommentCreateManyParentCommentInputEnvelope
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    connect?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutParentCommentInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutParentCommentInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type CommentUncheckedUpdateManyWithoutParentCommentNestedInput = {
    create?: XOR<Enumerable<CommentCreateWithoutParentCommentInput>, Enumerable<CommentUncheckedCreateWithoutParentCommentInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutParentCommentInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutParentCommentInput>
    createMany?: CommentCreateManyParentCommentInputEnvelope
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    connect?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutParentCommentInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutParentCommentInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type PostCreateNestedManyWithoutHashTagsInput = {
    create?: XOR<Enumerable<PostCreateWithoutHashTagsInput>, Enumerable<PostUncheckedCreateWithoutHashTagsInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutHashTagsInput>
    connect?: Enumerable<PostWhereUniqueInput>
  }

  export type PostUncheckedCreateNestedManyWithoutHashTagsInput = {
    create?: XOR<Enumerable<PostCreateWithoutHashTagsInput>, Enumerable<PostUncheckedCreateWithoutHashTagsInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutHashTagsInput>
    connect?: Enumerable<PostWhereUniqueInput>
  }

  export type PostUpdateManyWithoutHashTagsNestedInput = {
    create?: XOR<Enumerable<PostCreateWithoutHashTagsInput>, Enumerable<PostUncheckedCreateWithoutHashTagsInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutHashTagsInput>
    upsert?: Enumerable<PostUpsertWithWhereUniqueWithoutHashTagsInput>
    set?: Enumerable<PostWhereUniqueInput>
    disconnect?: Enumerable<PostWhereUniqueInput>
    delete?: Enumerable<PostWhereUniqueInput>
    connect?: Enumerable<PostWhereUniqueInput>
    update?: Enumerable<PostUpdateWithWhereUniqueWithoutHashTagsInput>
    updateMany?: Enumerable<PostUpdateManyWithWhereWithoutHashTagsInput>
    deleteMany?: Enumerable<PostScalarWhereInput>
  }

  export type PostUncheckedUpdateManyWithoutHashTagsNestedInput = {
    create?: XOR<Enumerable<PostCreateWithoutHashTagsInput>, Enumerable<PostUncheckedCreateWithoutHashTagsInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutHashTagsInput>
    upsert?: Enumerable<PostUpsertWithWhereUniqueWithoutHashTagsInput>
    set?: Enumerable<PostWhereUniqueInput>
    disconnect?: Enumerable<PostWhereUniqueInput>
    delete?: Enumerable<PostWhereUniqueInput>
    connect?: Enumerable<PostWhereUniqueInput>
    update?: Enumerable<PostUpdateWithWhereUniqueWithoutHashTagsInput>
    updateMany?: Enumerable<PostUpdateManyWithWhereWithoutHashTagsInput>
    deleteMany?: Enumerable<PostScalarWhereInput>
  }

  export type FacebookUserCreateNestedOneWithoutMessengerMessagesFromInput = {
    create?: XOR<FacebookUserCreateWithoutMessengerMessagesFromInput, FacebookUserUncheckedCreateWithoutMessengerMessagesFromInput>
    connectOrCreate?: FacebookUserCreateOrConnectWithoutMessengerMessagesFromInput
    connect?: FacebookUserWhereUniqueInput
  }

  export type FacebookUserCreateNestedOneWithoutMessengerMessagesToInput = {
    create?: XOR<FacebookUserCreateWithoutMessengerMessagesToInput, FacebookUserUncheckedCreateWithoutMessengerMessagesToInput>
    connectOrCreate?: FacebookUserCreateOrConnectWithoutMessengerMessagesToInput
    connect?: FacebookUserWhereUniqueInput
  }

  export type FacebookUserUpdateOneRequiredWithoutMessengerMessagesFromNestedInput = {
    create?: XOR<FacebookUserCreateWithoutMessengerMessagesFromInput, FacebookUserUncheckedCreateWithoutMessengerMessagesFromInput>
    connectOrCreate?: FacebookUserCreateOrConnectWithoutMessengerMessagesFromInput
    upsert?: FacebookUserUpsertWithoutMessengerMessagesFromInput
    connect?: FacebookUserWhereUniqueInput
    update?: XOR<FacebookUserUpdateWithoutMessengerMessagesFromInput, FacebookUserUncheckedUpdateWithoutMessengerMessagesFromInput>
  }

  export type FacebookUserUpdateOneRequiredWithoutMessengerMessagesToNestedInput = {
    create?: XOR<FacebookUserCreateWithoutMessengerMessagesToInput, FacebookUserUncheckedCreateWithoutMessengerMessagesToInput>
    connectOrCreate?: FacebookUserCreateOrConnectWithoutMessengerMessagesToInput
    upsert?: FacebookUserUpsertWithoutMessengerMessagesToInput
    connect?: FacebookUserWhereUniqueInput
    update?: XOR<FacebookUserUpdateWithoutMessengerMessagesToInput, FacebookUserUncheckedUpdateWithoutMessengerMessagesToInput>
  }

  export type UserRelationCreateNestedManyWithoutFollowingUserInput = {
    create?: XOR<Enumerable<UserRelationCreateWithoutFollowingUserInput>, Enumerable<UserRelationUncheckedCreateWithoutFollowingUserInput>>
    connectOrCreate?: Enumerable<UserRelationCreateOrConnectWithoutFollowingUserInput>
    createMany?: UserRelationCreateManyFollowingUserInputEnvelope
    connect?: Enumerable<UserRelationWhereUniqueInput>
  }

  export type UserRelationCreateNestedManyWithoutFollowedUserInput = {
    create?: XOR<Enumerable<UserRelationCreateWithoutFollowedUserInput>, Enumerable<UserRelationUncheckedCreateWithoutFollowedUserInput>>
    connectOrCreate?: Enumerable<UserRelationCreateOrConnectWithoutFollowedUserInput>
    createMany?: UserRelationCreateManyFollowedUserInputEnvelope
    connect?: Enumerable<UserRelationWhereUniqueInput>
  }

  export type TweetCreateNestedManyWithoutTweetingUserInput = {
    create?: XOR<Enumerable<TweetCreateWithoutTweetingUserInput>, Enumerable<TweetUncheckedCreateWithoutTweetingUserInput>>
    connectOrCreate?: Enumerable<TweetCreateOrConnectWithoutTweetingUserInput>
    createMany?: TweetCreateManyTweetingUserInputEnvelope
    connect?: Enumerable<TweetWhereUniqueInput>
  }

  export type DirectMessageCreateNestedManyWithoutFromUserInput = {
    create?: XOR<Enumerable<DirectMessageCreateWithoutFromUserInput>, Enumerable<DirectMessageUncheckedCreateWithoutFromUserInput>>
    connectOrCreate?: Enumerable<DirectMessageCreateOrConnectWithoutFromUserInput>
    createMany?: DirectMessageCreateManyFromUserInputEnvelope
    connect?: Enumerable<DirectMessageWhereUniqueInput>
  }

  export type DirectMessageCreateNestedManyWithoutToUserInput = {
    create?: XOR<Enumerable<DirectMessageCreateWithoutToUserInput>, Enumerable<DirectMessageUncheckedCreateWithoutToUserInput>>
    connectOrCreate?: Enumerable<DirectMessageCreateOrConnectWithoutToUserInput>
    createMany?: DirectMessageCreateManyToUserInputEnvelope
    connect?: Enumerable<DirectMessageWhereUniqueInput>
  }

  export type UserRelationUncheckedCreateNestedManyWithoutFollowingUserInput = {
    create?: XOR<Enumerable<UserRelationCreateWithoutFollowingUserInput>, Enumerable<UserRelationUncheckedCreateWithoutFollowingUserInput>>
    connectOrCreate?: Enumerable<UserRelationCreateOrConnectWithoutFollowingUserInput>
    createMany?: UserRelationCreateManyFollowingUserInputEnvelope
    connect?: Enumerable<UserRelationWhereUniqueInput>
  }

  export type UserRelationUncheckedCreateNestedManyWithoutFollowedUserInput = {
    create?: XOR<Enumerable<UserRelationCreateWithoutFollowedUserInput>, Enumerable<UserRelationUncheckedCreateWithoutFollowedUserInput>>
    connectOrCreate?: Enumerable<UserRelationCreateOrConnectWithoutFollowedUserInput>
    createMany?: UserRelationCreateManyFollowedUserInputEnvelope
    connect?: Enumerable<UserRelationWhereUniqueInput>
  }

  export type TweetUncheckedCreateNestedManyWithoutTweetingUserInput = {
    create?: XOR<Enumerable<TweetCreateWithoutTweetingUserInput>, Enumerable<TweetUncheckedCreateWithoutTweetingUserInput>>
    connectOrCreate?: Enumerable<TweetCreateOrConnectWithoutTweetingUserInput>
    createMany?: TweetCreateManyTweetingUserInputEnvelope
    connect?: Enumerable<TweetWhereUniqueInput>
  }

  export type DirectMessageUncheckedCreateNestedManyWithoutFromUserInput = {
    create?: XOR<Enumerable<DirectMessageCreateWithoutFromUserInput>, Enumerable<DirectMessageUncheckedCreateWithoutFromUserInput>>
    connectOrCreate?: Enumerable<DirectMessageCreateOrConnectWithoutFromUserInput>
    createMany?: DirectMessageCreateManyFromUserInputEnvelope
    connect?: Enumerable<DirectMessageWhereUniqueInput>
  }

  export type DirectMessageUncheckedCreateNestedManyWithoutToUserInput = {
    create?: XOR<Enumerable<DirectMessageCreateWithoutToUserInput>, Enumerable<DirectMessageUncheckedCreateWithoutToUserInput>>
    connectOrCreate?: Enumerable<DirectMessageCreateOrConnectWithoutToUserInput>
    createMany?: DirectMessageCreateManyToUserInputEnvelope
    connect?: Enumerable<DirectMessageWhereUniqueInput>
  }

  export type UserRelationUpdateManyWithoutFollowingUserNestedInput = {
    create?: XOR<Enumerable<UserRelationCreateWithoutFollowingUserInput>, Enumerable<UserRelationUncheckedCreateWithoutFollowingUserInput>>
    connectOrCreate?: Enumerable<UserRelationCreateOrConnectWithoutFollowingUserInput>
    upsert?: Enumerable<UserRelationUpsertWithWhereUniqueWithoutFollowingUserInput>
    createMany?: UserRelationCreateManyFollowingUserInputEnvelope
    set?: Enumerable<UserRelationWhereUniqueInput>
    disconnect?: Enumerable<UserRelationWhereUniqueInput>
    delete?: Enumerable<UserRelationWhereUniqueInput>
    connect?: Enumerable<UserRelationWhereUniqueInput>
    update?: Enumerable<UserRelationUpdateWithWhereUniqueWithoutFollowingUserInput>
    updateMany?: Enumerable<UserRelationUpdateManyWithWhereWithoutFollowingUserInput>
    deleteMany?: Enumerable<UserRelationScalarWhereInput>
  }

  export type UserRelationUpdateManyWithoutFollowedUserNestedInput = {
    create?: XOR<Enumerable<UserRelationCreateWithoutFollowedUserInput>, Enumerable<UserRelationUncheckedCreateWithoutFollowedUserInput>>
    connectOrCreate?: Enumerable<UserRelationCreateOrConnectWithoutFollowedUserInput>
    upsert?: Enumerable<UserRelationUpsertWithWhereUniqueWithoutFollowedUserInput>
    createMany?: UserRelationCreateManyFollowedUserInputEnvelope
    set?: Enumerable<UserRelationWhereUniqueInput>
    disconnect?: Enumerable<UserRelationWhereUniqueInput>
    delete?: Enumerable<UserRelationWhereUniqueInput>
    connect?: Enumerable<UserRelationWhereUniqueInput>
    update?: Enumerable<UserRelationUpdateWithWhereUniqueWithoutFollowedUserInput>
    updateMany?: Enumerable<UserRelationUpdateManyWithWhereWithoutFollowedUserInput>
    deleteMany?: Enumerable<UserRelationScalarWhereInput>
  }

  export type TweetUpdateManyWithoutTweetingUserNestedInput = {
    create?: XOR<Enumerable<TweetCreateWithoutTweetingUserInput>, Enumerable<TweetUncheckedCreateWithoutTweetingUserInput>>
    connectOrCreate?: Enumerable<TweetCreateOrConnectWithoutTweetingUserInput>
    upsert?: Enumerable<TweetUpsertWithWhereUniqueWithoutTweetingUserInput>
    createMany?: TweetCreateManyTweetingUserInputEnvelope
    set?: Enumerable<TweetWhereUniqueInput>
    disconnect?: Enumerable<TweetWhereUniqueInput>
    delete?: Enumerable<TweetWhereUniqueInput>
    connect?: Enumerable<TweetWhereUniqueInput>
    update?: Enumerable<TweetUpdateWithWhereUniqueWithoutTweetingUserInput>
    updateMany?: Enumerable<TweetUpdateManyWithWhereWithoutTweetingUserInput>
    deleteMany?: Enumerable<TweetScalarWhereInput>
  }

  export type DirectMessageUpdateManyWithoutFromUserNestedInput = {
    create?: XOR<Enumerable<DirectMessageCreateWithoutFromUserInput>, Enumerable<DirectMessageUncheckedCreateWithoutFromUserInput>>
    connectOrCreate?: Enumerable<DirectMessageCreateOrConnectWithoutFromUserInput>
    upsert?: Enumerable<DirectMessageUpsertWithWhereUniqueWithoutFromUserInput>
    createMany?: DirectMessageCreateManyFromUserInputEnvelope
    set?: Enumerable<DirectMessageWhereUniqueInput>
    disconnect?: Enumerable<DirectMessageWhereUniqueInput>
    delete?: Enumerable<DirectMessageWhereUniqueInput>
    connect?: Enumerable<DirectMessageWhereUniqueInput>
    update?: Enumerable<DirectMessageUpdateWithWhereUniqueWithoutFromUserInput>
    updateMany?: Enumerable<DirectMessageUpdateManyWithWhereWithoutFromUserInput>
    deleteMany?: Enumerable<DirectMessageScalarWhereInput>
  }

  export type DirectMessageUpdateManyWithoutToUserNestedInput = {
    create?: XOR<Enumerable<DirectMessageCreateWithoutToUserInput>, Enumerable<DirectMessageUncheckedCreateWithoutToUserInput>>
    connectOrCreate?: Enumerable<DirectMessageCreateOrConnectWithoutToUserInput>
    upsert?: Enumerable<DirectMessageUpsertWithWhereUniqueWithoutToUserInput>
    createMany?: DirectMessageCreateManyToUserInputEnvelope
    set?: Enumerable<DirectMessageWhereUniqueInput>
    disconnect?: Enumerable<DirectMessageWhereUniqueInput>
    delete?: Enumerable<DirectMessageWhereUniqueInput>
    connect?: Enumerable<DirectMessageWhereUniqueInput>
    update?: Enumerable<DirectMessageUpdateWithWhereUniqueWithoutToUserInput>
    updateMany?: Enumerable<DirectMessageUpdateManyWithWhereWithoutToUserInput>
    deleteMany?: Enumerable<DirectMessageScalarWhereInput>
  }

  export type UserRelationUncheckedUpdateManyWithoutFollowingUserNestedInput = {
    create?: XOR<Enumerable<UserRelationCreateWithoutFollowingUserInput>, Enumerable<UserRelationUncheckedCreateWithoutFollowingUserInput>>
    connectOrCreate?: Enumerable<UserRelationCreateOrConnectWithoutFollowingUserInput>
    upsert?: Enumerable<UserRelationUpsertWithWhereUniqueWithoutFollowingUserInput>
    createMany?: UserRelationCreateManyFollowingUserInputEnvelope
    set?: Enumerable<UserRelationWhereUniqueInput>
    disconnect?: Enumerable<UserRelationWhereUniqueInput>
    delete?: Enumerable<UserRelationWhereUniqueInput>
    connect?: Enumerable<UserRelationWhereUniqueInput>
    update?: Enumerable<UserRelationUpdateWithWhereUniqueWithoutFollowingUserInput>
    updateMany?: Enumerable<UserRelationUpdateManyWithWhereWithoutFollowingUserInput>
    deleteMany?: Enumerable<UserRelationScalarWhereInput>
  }

  export type UserRelationUncheckedUpdateManyWithoutFollowedUserNestedInput = {
    create?: XOR<Enumerable<UserRelationCreateWithoutFollowedUserInput>, Enumerable<UserRelationUncheckedCreateWithoutFollowedUserInput>>
    connectOrCreate?: Enumerable<UserRelationCreateOrConnectWithoutFollowedUserInput>
    upsert?: Enumerable<UserRelationUpsertWithWhereUniqueWithoutFollowedUserInput>
    createMany?: UserRelationCreateManyFollowedUserInputEnvelope
    set?: Enumerable<UserRelationWhereUniqueInput>
    disconnect?: Enumerable<UserRelationWhereUniqueInput>
    delete?: Enumerable<UserRelationWhereUniqueInput>
    connect?: Enumerable<UserRelationWhereUniqueInput>
    update?: Enumerable<UserRelationUpdateWithWhereUniqueWithoutFollowedUserInput>
    updateMany?: Enumerable<UserRelationUpdateManyWithWhereWithoutFollowedUserInput>
    deleteMany?: Enumerable<UserRelationScalarWhereInput>
  }

  export type TweetUncheckedUpdateManyWithoutTweetingUserNestedInput = {
    create?: XOR<Enumerable<TweetCreateWithoutTweetingUserInput>, Enumerable<TweetUncheckedCreateWithoutTweetingUserInput>>
    connectOrCreate?: Enumerable<TweetCreateOrConnectWithoutTweetingUserInput>
    upsert?: Enumerable<TweetUpsertWithWhereUniqueWithoutTweetingUserInput>
    createMany?: TweetCreateManyTweetingUserInputEnvelope
    set?: Enumerable<TweetWhereUniqueInput>
    disconnect?: Enumerable<TweetWhereUniqueInput>
    delete?: Enumerable<TweetWhereUniqueInput>
    connect?: Enumerable<TweetWhereUniqueInput>
    update?: Enumerable<TweetUpdateWithWhereUniqueWithoutTweetingUserInput>
    updateMany?: Enumerable<TweetUpdateManyWithWhereWithoutTweetingUserInput>
    deleteMany?: Enumerable<TweetScalarWhereInput>
  }

  export type DirectMessageUncheckedUpdateManyWithoutFromUserNestedInput = {
    create?: XOR<Enumerable<DirectMessageCreateWithoutFromUserInput>, Enumerable<DirectMessageUncheckedCreateWithoutFromUserInput>>
    connectOrCreate?: Enumerable<DirectMessageCreateOrConnectWithoutFromUserInput>
    upsert?: Enumerable<DirectMessageUpsertWithWhereUniqueWithoutFromUserInput>
    createMany?: DirectMessageCreateManyFromUserInputEnvelope
    set?: Enumerable<DirectMessageWhereUniqueInput>
    disconnect?: Enumerable<DirectMessageWhereUniqueInput>
    delete?: Enumerable<DirectMessageWhereUniqueInput>
    connect?: Enumerable<DirectMessageWhereUniqueInput>
    update?: Enumerable<DirectMessageUpdateWithWhereUniqueWithoutFromUserInput>
    updateMany?: Enumerable<DirectMessageUpdateManyWithWhereWithoutFromUserInput>
    deleteMany?: Enumerable<DirectMessageScalarWhereInput>
  }

  export type DirectMessageUncheckedUpdateManyWithoutToUserNestedInput = {
    create?: XOR<Enumerable<DirectMessageCreateWithoutToUserInput>, Enumerable<DirectMessageUncheckedCreateWithoutToUserInput>>
    connectOrCreate?: Enumerable<DirectMessageCreateOrConnectWithoutToUserInput>
    upsert?: Enumerable<DirectMessageUpsertWithWhereUniqueWithoutToUserInput>
    createMany?: DirectMessageCreateManyToUserInputEnvelope
    set?: Enumerable<DirectMessageWhereUniqueInput>
    disconnect?: Enumerable<DirectMessageWhereUniqueInput>
    delete?: Enumerable<DirectMessageWhereUniqueInput>
    connect?: Enumerable<DirectMessageWhereUniqueInput>
    update?: Enumerable<DirectMessageUpdateWithWhereUniqueWithoutToUserInput>
    updateMany?: Enumerable<DirectMessageUpdateManyWithWhereWithoutToUserInput>
    deleteMany?: Enumerable<DirectMessageScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutFollowingUserRelationsInput = {
    create?: XOR<UserCreateWithoutFollowingUserRelationsInput, UserUncheckedCreateWithoutFollowingUserRelationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowingUserRelationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFollowedUserRelationsInput = {
    create?: XOR<UserCreateWithoutFollowedUserRelationsInput, UserUncheckedCreateWithoutFollowedUserRelationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowedUserRelationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFollowingUserRelationsNestedInput = {
    create?: XOR<UserCreateWithoutFollowingUserRelationsInput, UserUncheckedCreateWithoutFollowingUserRelationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowingUserRelationsInput
    upsert?: UserUpsertWithoutFollowingUserRelationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutFollowingUserRelationsInput, UserUncheckedUpdateWithoutFollowingUserRelationsInput>
  }

  export type UserUpdateOneRequiredWithoutFollowedUserRelationsNestedInput = {
    create?: XOR<UserCreateWithoutFollowedUserRelationsInput, UserUncheckedCreateWithoutFollowedUserRelationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowedUserRelationsInput
    upsert?: UserUpsertWithoutFollowedUserRelationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutFollowedUserRelationsInput, UserUncheckedUpdateWithoutFollowedUserRelationsInput>
  }

  export type UserCreateNestedOneWithoutTweetsInput = {
    create?: XOR<UserCreateWithoutTweetsInput, UserUncheckedCreateWithoutTweetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTweetsInput
    connect?: UserWhereUniqueInput
  }

  export type TweetCreateNestedOneWithoutChildTweetsInput = {
    create?: XOR<TweetCreateWithoutChildTweetsInput, TweetUncheckedCreateWithoutChildTweetsInput>
    connectOrCreate?: TweetCreateOrConnectWithoutChildTweetsInput
    connect?: TweetWhereUniqueInput
  }

  export type TweetCreateNestedManyWithoutParentTweetInput = {
    create?: XOR<Enumerable<TweetCreateWithoutParentTweetInput>, Enumerable<TweetUncheckedCreateWithoutParentTweetInput>>
    connectOrCreate?: Enumerable<TweetCreateOrConnectWithoutParentTweetInput>
    createMany?: TweetCreateManyParentTweetInputEnvelope
    connect?: Enumerable<TweetWhereUniqueInput>
  }

  export type HashTagCreateNestedManyWithoutIsInTweetsInput = {
    create?: XOR<Enumerable<HashTagCreateWithoutIsInTweetsInput>, Enumerable<HashTagUncheckedCreateWithoutIsInTweetsInput>>
    connectOrCreate?: Enumerable<HashTagCreateOrConnectWithoutIsInTweetsInput>
    connect?: Enumerable<HashTagWhereUniqueInput>
  }

  export type TweetUncheckedCreateNestedManyWithoutParentTweetInput = {
    create?: XOR<Enumerable<TweetCreateWithoutParentTweetInput>, Enumerable<TweetUncheckedCreateWithoutParentTweetInput>>
    connectOrCreate?: Enumerable<TweetCreateOrConnectWithoutParentTweetInput>
    createMany?: TweetCreateManyParentTweetInputEnvelope
    connect?: Enumerable<TweetWhereUniqueInput>
  }

  export type HashTagUncheckedCreateNestedManyWithoutIsInTweetsInput = {
    create?: XOR<Enumerable<HashTagCreateWithoutIsInTweetsInput>, Enumerable<HashTagUncheckedCreateWithoutIsInTweetsInput>>
    connectOrCreate?: Enumerable<HashTagCreateOrConnectWithoutIsInTweetsInput>
    connect?: Enumerable<HashTagWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutTweetsNestedInput = {
    create?: XOR<UserCreateWithoutTweetsInput, UserUncheckedCreateWithoutTweetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTweetsInput
    upsert?: UserUpsertWithoutTweetsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutTweetsInput, UserUncheckedUpdateWithoutTweetsInput>
  }

  export type TweetUpdateOneWithoutChildTweetsNestedInput = {
    create?: XOR<TweetCreateWithoutChildTweetsInput, TweetUncheckedCreateWithoutChildTweetsInput>
    connectOrCreate?: TweetCreateOrConnectWithoutChildTweetsInput
    upsert?: TweetUpsertWithoutChildTweetsInput
    disconnect?: boolean
    delete?: boolean
    connect?: TweetWhereUniqueInput
    update?: XOR<TweetUpdateWithoutChildTweetsInput, TweetUncheckedUpdateWithoutChildTweetsInput>
  }

  export type TweetUpdateManyWithoutParentTweetNestedInput = {
    create?: XOR<Enumerable<TweetCreateWithoutParentTweetInput>, Enumerable<TweetUncheckedCreateWithoutParentTweetInput>>
    connectOrCreate?: Enumerable<TweetCreateOrConnectWithoutParentTweetInput>
    upsert?: Enumerable<TweetUpsertWithWhereUniqueWithoutParentTweetInput>
    createMany?: TweetCreateManyParentTweetInputEnvelope
    set?: Enumerable<TweetWhereUniqueInput>
    disconnect?: Enumerable<TweetWhereUniqueInput>
    delete?: Enumerable<TweetWhereUniqueInput>
    connect?: Enumerable<TweetWhereUniqueInput>
    update?: Enumerable<TweetUpdateWithWhereUniqueWithoutParentTweetInput>
    updateMany?: Enumerable<TweetUpdateManyWithWhereWithoutParentTweetInput>
    deleteMany?: Enumerable<TweetScalarWhereInput>
  }

  export type HashTagUpdateManyWithoutIsInTweetsNestedInput = {
    create?: XOR<Enumerable<HashTagCreateWithoutIsInTweetsInput>, Enumerable<HashTagUncheckedCreateWithoutIsInTweetsInput>>
    connectOrCreate?: Enumerable<HashTagCreateOrConnectWithoutIsInTweetsInput>
    upsert?: Enumerable<HashTagUpsertWithWhereUniqueWithoutIsInTweetsInput>
    set?: Enumerable<HashTagWhereUniqueInput>
    disconnect?: Enumerable<HashTagWhereUniqueInput>
    delete?: Enumerable<HashTagWhereUniqueInput>
    connect?: Enumerable<HashTagWhereUniqueInput>
    update?: Enumerable<HashTagUpdateWithWhereUniqueWithoutIsInTweetsInput>
    updateMany?: Enumerable<HashTagUpdateManyWithWhereWithoutIsInTweetsInput>
    deleteMany?: Enumerable<HashTagScalarWhereInput>
  }

  export type TweetUncheckedUpdateManyWithoutParentTweetNestedInput = {
    create?: XOR<Enumerable<TweetCreateWithoutParentTweetInput>, Enumerable<TweetUncheckedCreateWithoutParentTweetInput>>
    connectOrCreate?: Enumerable<TweetCreateOrConnectWithoutParentTweetInput>
    upsert?: Enumerable<TweetUpsertWithWhereUniqueWithoutParentTweetInput>
    createMany?: TweetCreateManyParentTweetInputEnvelope
    set?: Enumerable<TweetWhereUniqueInput>
    disconnect?: Enumerable<TweetWhereUniqueInput>
    delete?: Enumerable<TweetWhereUniqueInput>
    connect?: Enumerable<TweetWhereUniqueInput>
    update?: Enumerable<TweetUpdateWithWhereUniqueWithoutParentTweetInput>
    updateMany?: Enumerable<TweetUpdateManyWithWhereWithoutParentTweetInput>
    deleteMany?: Enumerable<TweetScalarWhereInput>
  }

  export type HashTagUncheckedUpdateManyWithoutIsInTweetsNestedInput = {
    create?: XOR<Enumerable<HashTagCreateWithoutIsInTweetsInput>, Enumerable<HashTagUncheckedCreateWithoutIsInTweetsInput>>
    connectOrCreate?: Enumerable<HashTagCreateOrConnectWithoutIsInTweetsInput>
    upsert?: Enumerable<HashTagUpsertWithWhereUniqueWithoutIsInTweetsInput>
    set?: Enumerable<HashTagWhereUniqueInput>
    disconnect?: Enumerable<HashTagWhereUniqueInput>
    delete?: Enumerable<HashTagWhereUniqueInput>
    connect?: Enumerable<HashTagWhereUniqueInput>
    update?: Enumerable<HashTagUpdateWithWhereUniqueWithoutIsInTweetsInput>
    updateMany?: Enumerable<HashTagUpdateManyWithWhereWithoutIsInTweetsInput>
    deleteMany?: Enumerable<HashTagScalarWhereInput>
  }

  export type TweetCreateNestedManyWithoutHashTagsInput = {
    create?: XOR<Enumerable<TweetCreateWithoutHashTagsInput>, Enumerable<TweetUncheckedCreateWithoutHashTagsInput>>
    connectOrCreate?: Enumerable<TweetCreateOrConnectWithoutHashTagsInput>
    connect?: Enumerable<TweetWhereUniqueInput>
  }

  export type TweetUncheckedCreateNestedManyWithoutHashTagsInput = {
    create?: XOR<Enumerable<TweetCreateWithoutHashTagsInput>, Enumerable<TweetUncheckedCreateWithoutHashTagsInput>>
    connectOrCreate?: Enumerable<TweetCreateOrConnectWithoutHashTagsInput>
    connect?: Enumerable<TweetWhereUniqueInput>
  }

  export type TweetUpdateManyWithoutHashTagsNestedInput = {
    create?: XOR<Enumerable<TweetCreateWithoutHashTagsInput>, Enumerable<TweetUncheckedCreateWithoutHashTagsInput>>
    connectOrCreate?: Enumerable<TweetCreateOrConnectWithoutHashTagsInput>
    upsert?: Enumerable<TweetUpsertWithWhereUniqueWithoutHashTagsInput>
    set?: Enumerable<TweetWhereUniqueInput>
    disconnect?: Enumerable<TweetWhereUniqueInput>
    delete?: Enumerable<TweetWhereUniqueInput>
    connect?: Enumerable<TweetWhereUniqueInput>
    update?: Enumerable<TweetUpdateWithWhereUniqueWithoutHashTagsInput>
    updateMany?: Enumerable<TweetUpdateManyWithWhereWithoutHashTagsInput>
    deleteMany?: Enumerable<TweetScalarWhereInput>
  }

  export type TweetUncheckedUpdateManyWithoutHashTagsNestedInput = {
    create?: XOR<Enumerable<TweetCreateWithoutHashTagsInput>, Enumerable<TweetUncheckedCreateWithoutHashTagsInput>>
    connectOrCreate?: Enumerable<TweetCreateOrConnectWithoutHashTagsInput>
    upsert?: Enumerable<TweetUpsertWithWhereUniqueWithoutHashTagsInput>
    set?: Enumerable<TweetWhereUniqueInput>
    disconnect?: Enumerable<TweetWhereUniqueInput>
    delete?: Enumerable<TweetWhereUniqueInput>
    connect?: Enumerable<TweetWhereUniqueInput>
    update?: Enumerable<TweetUpdateWithWhereUniqueWithoutHashTagsInput>
    updateMany?: Enumerable<TweetUpdateManyWithWhereWithoutHashTagsInput>
    deleteMany?: Enumerable<TweetScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutDirectMessagesFromInput = {
    create?: XOR<UserCreateWithoutDirectMessagesFromInput, UserUncheckedCreateWithoutDirectMessagesFromInput>
    connectOrCreate?: UserCreateOrConnectWithoutDirectMessagesFromInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDirectMessagesToInput = {
    create?: XOR<UserCreateWithoutDirectMessagesToInput, UserUncheckedCreateWithoutDirectMessagesToInput>
    connectOrCreate?: UserCreateOrConnectWithoutDirectMessagesToInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDirectMessagesFromNestedInput = {
    create?: XOR<UserCreateWithoutDirectMessagesFromInput, UserUncheckedCreateWithoutDirectMessagesFromInput>
    connectOrCreate?: UserCreateOrConnectWithoutDirectMessagesFromInput
    upsert?: UserUpsertWithoutDirectMessagesFromInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutDirectMessagesFromInput, UserUncheckedUpdateWithoutDirectMessagesFromInput>
  }

  export type UserUpdateOneRequiredWithoutDirectMessagesToNestedInput = {
    create?: XOR<UserCreateWithoutDirectMessagesToInput, UserUncheckedCreateWithoutDirectMessagesToInput>
    connectOrCreate?: UserCreateOrConnectWithoutDirectMessagesToInput
    upsert?: UserUpsertWithoutDirectMessagesToInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutDirectMessagesToInput, UserUncheckedUpdateWithoutDirectMessagesToInput>
  }

  export type ChannelCreateNestedManyWithoutAdminUsersInput = {
    create?: XOR<Enumerable<ChannelCreateWithoutAdminUsersInput>, Enumerable<ChannelUncheckedCreateWithoutAdminUsersInput>>
    connectOrCreate?: Enumerable<ChannelCreateOrConnectWithoutAdminUsersInput>
    connect?: Enumerable<ChannelWhereUniqueInput>
  }

  export type UserToChannelwithRoleCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserToChannelwithRoleCreateWithoutUserInput>, Enumerable<UserToChannelwithRoleUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserToChannelwithRoleCreateOrConnectWithoutUserInput>
    createMany?: UserToChannelwithRoleCreateManyUserInputEnvelope
    connect?: Enumerable<UserToChannelwithRoleWhereUniqueInput>
  }

  export type ChannelCreateNestedManyWithoutSubscribedUsersInput = {
    create?: XOR<Enumerable<ChannelCreateWithoutSubscribedUsersInput>, Enumerable<ChannelUncheckedCreateWithoutSubscribedUsersInput>>
    connectOrCreate?: Enumerable<ChannelCreateOrConnectWithoutSubscribedUsersInput>
    connect?: Enumerable<ChannelWhereUniqueInput>
  }

  export type VideoCreateNestedManyWithoutReactedByYouTubeUsersInput = {
    create?: XOR<Enumerable<VideoCreateWithoutReactedByYouTubeUsersInput>, Enumerable<VideoUncheckedCreateWithoutReactedByYouTubeUsersInput>>
    connectOrCreate?: Enumerable<VideoCreateOrConnectWithoutReactedByYouTubeUsersInput>
    connect?: Enumerable<VideoWhereUniqueInput>
  }

  export type UserToVideoWithReactionCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserToVideoWithReactionCreateWithoutUserInput>, Enumerable<UserToVideoWithReactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserToVideoWithReactionCreateOrConnectWithoutUserInput>
    createMany?: UserToVideoWithReactionCreateManyUserInputEnvelope
    connect?: Enumerable<UserToVideoWithReactionWhereUniqueInput>
  }

  export type VideoCommentCreateNestedManyWithoutCommentingUserInput = {
    create?: XOR<Enumerable<VideoCommentCreateWithoutCommentingUserInput>, Enumerable<VideoCommentUncheckedCreateWithoutCommentingUserInput>>
    connectOrCreate?: Enumerable<VideoCommentCreateOrConnectWithoutCommentingUserInput>
    createMany?: VideoCommentCreateManyCommentingUserInputEnvelope
    connect?: Enumerable<VideoCommentWhereUniqueInput>
  }

  export type ChannelUncheckedCreateNestedManyWithoutAdminUsersInput = {
    create?: XOR<Enumerable<ChannelCreateWithoutAdminUsersInput>, Enumerable<ChannelUncheckedCreateWithoutAdminUsersInput>>
    connectOrCreate?: Enumerable<ChannelCreateOrConnectWithoutAdminUsersInput>
    connect?: Enumerable<ChannelWhereUniqueInput>
  }

  export type UserToChannelwithRoleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserToChannelwithRoleCreateWithoutUserInput>, Enumerable<UserToChannelwithRoleUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserToChannelwithRoleCreateOrConnectWithoutUserInput>
    createMany?: UserToChannelwithRoleCreateManyUserInputEnvelope
    connect?: Enumerable<UserToChannelwithRoleWhereUniqueInput>
  }

  export type ChannelUncheckedCreateNestedManyWithoutSubscribedUsersInput = {
    create?: XOR<Enumerable<ChannelCreateWithoutSubscribedUsersInput>, Enumerable<ChannelUncheckedCreateWithoutSubscribedUsersInput>>
    connectOrCreate?: Enumerable<ChannelCreateOrConnectWithoutSubscribedUsersInput>
    connect?: Enumerable<ChannelWhereUniqueInput>
  }

  export type VideoUncheckedCreateNestedManyWithoutReactedByYouTubeUsersInput = {
    create?: XOR<Enumerable<VideoCreateWithoutReactedByYouTubeUsersInput>, Enumerable<VideoUncheckedCreateWithoutReactedByYouTubeUsersInput>>
    connectOrCreate?: Enumerable<VideoCreateOrConnectWithoutReactedByYouTubeUsersInput>
    connect?: Enumerable<VideoWhereUniqueInput>
  }

  export type UserToVideoWithReactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserToVideoWithReactionCreateWithoutUserInput>, Enumerable<UserToVideoWithReactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserToVideoWithReactionCreateOrConnectWithoutUserInput>
    createMany?: UserToVideoWithReactionCreateManyUserInputEnvelope
    connect?: Enumerable<UserToVideoWithReactionWhereUniqueInput>
  }

  export type VideoCommentUncheckedCreateNestedManyWithoutCommentingUserInput = {
    create?: XOR<Enumerable<VideoCommentCreateWithoutCommentingUserInput>, Enumerable<VideoCommentUncheckedCreateWithoutCommentingUserInput>>
    connectOrCreate?: Enumerable<VideoCommentCreateOrConnectWithoutCommentingUserInput>
    createMany?: VideoCommentCreateManyCommentingUserInputEnvelope
    connect?: Enumerable<VideoCommentWhereUniqueInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type ChannelUpdateManyWithoutAdminUsersNestedInput = {
    create?: XOR<Enumerable<ChannelCreateWithoutAdminUsersInput>, Enumerable<ChannelUncheckedCreateWithoutAdminUsersInput>>
    connectOrCreate?: Enumerable<ChannelCreateOrConnectWithoutAdminUsersInput>
    upsert?: Enumerable<ChannelUpsertWithWhereUniqueWithoutAdminUsersInput>
    set?: Enumerable<ChannelWhereUniqueInput>
    disconnect?: Enumerable<ChannelWhereUniqueInput>
    delete?: Enumerable<ChannelWhereUniqueInput>
    connect?: Enumerable<ChannelWhereUniqueInput>
    update?: Enumerable<ChannelUpdateWithWhereUniqueWithoutAdminUsersInput>
    updateMany?: Enumerable<ChannelUpdateManyWithWhereWithoutAdminUsersInput>
    deleteMany?: Enumerable<ChannelScalarWhereInput>
  }

  export type UserToChannelwithRoleUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserToChannelwithRoleCreateWithoutUserInput>, Enumerable<UserToChannelwithRoleUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserToChannelwithRoleCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserToChannelwithRoleUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserToChannelwithRoleCreateManyUserInputEnvelope
    set?: Enumerable<UserToChannelwithRoleWhereUniqueInput>
    disconnect?: Enumerable<UserToChannelwithRoleWhereUniqueInput>
    delete?: Enumerable<UserToChannelwithRoleWhereUniqueInput>
    connect?: Enumerable<UserToChannelwithRoleWhereUniqueInput>
    update?: Enumerable<UserToChannelwithRoleUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserToChannelwithRoleUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserToChannelwithRoleScalarWhereInput>
  }

  export type ChannelUpdateManyWithoutSubscribedUsersNestedInput = {
    create?: XOR<Enumerable<ChannelCreateWithoutSubscribedUsersInput>, Enumerable<ChannelUncheckedCreateWithoutSubscribedUsersInput>>
    connectOrCreate?: Enumerable<ChannelCreateOrConnectWithoutSubscribedUsersInput>
    upsert?: Enumerable<ChannelUpsertWithWhereUniqueWithoutSubscribedUsersInput>
    set?: Enumerable<ChannelWhereUniqueInput>
    disconnect?: Enumerable<ChannelWhereUniqueInput>
    delete?: Enumerable<ChannelWhereUniqueInput>
    connect?: Enumerable<ChannelWhereUniqueInput>
    update?: Enumerable<ChannelUpdateWithWhereUniqueWithoutSubscribedUsersInput>
    updateMany?: Enumerable<ChannelUpdateManyWithWhereWithoutSubscribedUsersInput>
    deleteMany?: Enumerable<ChannelScalarWhereInput>
  }

  export type VideoUpdateManyWithoutReactedByYouTubeUsersNestedInput = {
    create?: XOR<Enumerable<VideoCreateWithoutReactedByYouTubeUsersInput>, Enumerable<VideoUncheckedCreateWithoutReactedByYouTubeUsersInput>>
    connectOrCreate?: Enumerable<VideoCreateOrConnectWithoutReactedByYouTubeUsersInput>
    upsert?: Enumerable<VideoUpsertWithWhereUniqueWithoutReactedByYouTubeUsersInput>
    set?: Enumerable<VideoWhereUniqueInput>
    disconnect?: Enumerable<VideoWhereUniqueInput>
    delete?: Enumerable<VideoWhereUniqueInput>
    connect?: Enumerable<VideoWhereUniqueInput>
    update?: Enumerable<VideoUpdateWithWhereUniqueWithoutReactedByYouTubeUsersInput>
    updateMany?: Enumerable<VideoUpdateManyWithWhereWithoutReactedByYouTubeUsersInput>
    deleteMany?: Enumerable<VideoScalarWhereInput>
  }

  export type UserToVideoWithReactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserToVideoWithReactionCreateWithoutUserInput>, Enumerable<UserToVideoWithReactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserToVideoWithReactionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserToVideoWithReactionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserToVideoWithReactionCreateManyUserInputEnvelope
    set?: Enumerable<UserToVideoWithReactionWhereUniqueInput>
    disconnect?: Enumerable<UserToVideoWithReactionWhereUniqueInput>
    delete?: Enumerable<UserToVideoWithReactionWhereUniqueInput>
    connect?: Enumerable<UserToVideoWithReactionWhereUniqueInput>
    update?: Enumerable<UserToVideoWithReactionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserToVideoWithReactionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserToVideoWithReactionScalarWhereInput>
  }

  export type VideoCommentUpdateManyWithoutCommentingUserNestedInput = {
    create?: XOR<Enumerable<VideoCommentCreateWithoutCommentingUserInput>, Enumerable<VideoCommentUncheckedCreateWithoutCommentingUserInput>>
    connectOrCreate?: Enumerable<VideoCommentCreateOrConnectWithoutCommentingUserInput>
    upsert?: Enumerable<VideoCommentUpsertWithWhereUniqueWithoutCommentingUserInput>
    createMany?: VideoCommentCreateManyCommentingUserInputEnvelope
    set?: Enumerable<VideoCommentWhereUniqueInput>
    disconnect?: Enumerable<VideoCommentWhereUniqueInput>
    delete?: Enumerable<VideoCommentWhereUniqueInput>
    connect?: Enumerable<VideoCommentWhereUniqueInput>
    update?: Enumerable<VideoCommentUpdateWithWhereUniqueWithoutCommentingUserInput>
    updateMany?: Enumerable<VideoCommentUpdateManyWithWhereWithoutCommentingUserInput>
    deleteMany?: Enumerable<VideoCommentScalarWhereInput>
  }

  export type ChannelUncheckedUpdateManyWithoutAdminUsersNestedInput = {
    create?: XOR<Enumerable<ChannelCreateWithoutAdminUsersInput>, Enumerable<ChannelUncheckedCreateWithoutAdminUsersInput>>
    connectOrCreate?: Enumerable<ChannelCreateOrConnectWithoutAdminUsersInput>
    upsert?: Enumerable<ChannelUpsertWithWhereUniqueWithoutAdminUsersInput>
    set?: Enumerable<ChannelWhereUniqueInput>
    disconnect?: Enumerable<ChannelWhereUniqueInput>
    delete?: Enumerable<ChannelWhereUniqueInput>
    connect?: Enumerable<ChannelWhereUniqueInput>
    update?: Enumerable<ChannelUpdateWithWhereUniqueWithoutAdminUsersInput>
    updateMany?: Enumerable<ChannelUpdateManyWithWhereWithoutAdminUsersInput>
    deleteMany?: Enumerable<ChannelScalarWhereInput>
  }

  export type UserToChannelwithRoleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserToChannelwithRoleCreateWithoutUserInput>, Enumerable<UserToChannelwithRoleUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserToChannelwithRoleCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserToChannelwithRoleUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserToChannelwithRoleCreateManyUserInputEnvelope
    set?: Enumerable<UserToChannelwithRoleWhereUniqueInput>
    disconnect?: Enumerable<UserToChannelwithRoleWhereUniqueInput>
    delete?: Enumerable<UserToChannelwithRoleWhereUniqueInput>
    connect?: Enumerable<UserToChannelwithRoleWhereUniqueInput>
    update?: Enumerable<UserToChannelwithRoleUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserToChannelwithRoleUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserToChannelwithRoleScalarWhereInput>
  }

  export type ChannelUncheckedUpdateManyWithoutSubscribedUsersNestedInput = {
    create?: XOR<Enumerable<ChannelCreateWithoutSubscribedUsersInput>, Enumerable<ChannelUncheckedCreateWithoutSubscribedUsersInput>>
    connectOrCreate?: Enumerable<ChannelCreateOrConnectWithoutSubscribedUsersInput>
    upsert?: Enumerable<ChannelUpsertWithWhereUniqueWithoutSubscribedUsersInput>
    set?: Enumerable<ChannelWhereUniqueInput>
    disconnect?: Enumerable<ChannelWhereUniqueInput>
    delete?: Enumerable<ChannelWhereUniqueInput>
    connect?: Enumerable<ChannelWhereUniqueInput>
    update?: Enumerable<ChannelUpdateWithWhereUniqueWithoutSubscribedUsersInput>
    updateMany?: Enumerable<ChannelUpdateManyWithWhereWithoutSubscribedUsersInput>
    deleteMany?: Enumerable<ChannelScalarWhereInput>
  }

  export type VideoUncheckedUpdateManyWithoutReactedByYouTubeUsersNestedInput = {
    create?: XOR<Enumerable<VideoCreateWithoutReactedByYouTubeUsersInput>, Enumerable<VideoUncheckedCreateWithoutReactedByYouTubeUsersInput>>
    connectOrCreate?: Enumerable<VideoCreateOrConnectWithoutReactedByYouTubeUsersInput>
    upsert?: Enumerable<VideoUpsertWithWhereUniqueWithoutReactedByYouTubeUsersInput>
    set?: Enumerable<VideoWhereUniqueInput>
    disconnect?: Enumerable<VideoWhereUniqueInput>
    delete?: Enumerable<VideoWhereUniqueInput>
    connect?: Enumerable<VideoWhereUniqueInput>
    update?: Enumerable<VideoUpdateWithWhereUniqueWithoutReactedByYouTubeUsersInput>
    updateMany?: Enumerable<VideoUpdateManyWithWhereWithoutReactedByYouTubeUsersInput>
    deleteMany?: Enumerable<VideoScalarWhereInput>
  }

  export type UserToVideoWithReactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserToVideoWithReactionCreateWithoutUserInput>, Enumerable<UserToVideoWithReactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserToVideoWithReactionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserToVideoWithReactionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserToVideoWithReactionCreateManyUserInputEnvelope
    set?: Enumerable<UserToVideoWithReactionWhereUniqueInput>
    disconnect?: Enumerable<UserToVideoWithReactionWhereUniqueInput>
    delete?: Enumerable<UserToVideoWithReactionWhereUniqueInput>
    connect?: Enumerable<UserToVideoWithReactionWhereUniqueInput>
    update?: Enumerable<UserToVideoWithReactionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserToVideoWithReactionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserToVideoWithReactionScalarWhereInput>
  }

  export type VideoCommentUncheckedUpdateManyWithoutCommentingUserNestedInput = {
    create?: XOR<Enumerable<VideoCommentCreateWithoutCommentingUserInput>, Enumerable<VideoCommentUncheckedCreateWithoutCommentingUserInput>>
    connectOrCreate?: Enumerable<VideoCommentCreateOrConnectWithoutCommentingUserInput>
    upsert?: Enumerable<VideoCommentUpsertWithWhereUniqueWithoutCommentingUserInput>
    createMany?: VideoCommentCreateManyCommentingUserInputEnvelope
    set?: Enumerable<VideoCommentWhereUniqueInput>
    disconnect?: Enumerable<VideoCommentWhereUniqueInput>
    delete?: Enumerable<VideoCommentWhereUniqueInput>
    connect?: Enumerable<VideoCommentWhereUniqueInput>
    update?: Enumerable<VideoCommentUpdateWithWhereUniqueWithoutCommentingUserInput>
    updateMany?: Enumerable<VideoCommentUpdateManyWithWhereWithoutCommentingUserInput>
    deleteMany?: Enumerable<VideoCommentScalarWhereInput>
  }

  export type YouTubeUserCreateNestedManyWithoutAdminOfChannelsInput = {
    create?: XOR<Enumerable<YouTubeUserCreateWithoutAdminOfChannelsInput>, Enumerable<YouTubeUserUncheckedCreateWithoutAdminOfChannelsInput>>
    connectOrCreate?: Enumerable<YouTubeUserCreateOrConnectWithoutAdminOfChannelsInput>
    connect?: Enumerable<YouTubeUserWhereUniqueInput>
  }

  export type YouTubeUserCreateNestedManyWithoutSubscribingToChannelsInput = {
    create?: XOR<Enumerable<YouTubeUserCreateWithoutSubscribingToChannelsInput>, Enumerable<YouTubeUserUncheckedCreateWithoutSubscribingToChannelsInput>>
    connectOrCreate?: Enumerable<YouTubeUserCreateOrConnectWithoutSubscribingToChannelsInput>
    connect?: Enumerable<YouTubeUserWhereUniqueInput>
  }

  export type UserToChannelwithRoleCreateNestedManyWithoutChannelInput = {
    create?: XOR<Enumerable<UserToChannelwithRoleCreateWithoutChannelInput>, Enumerable<UserToChannelwithRoleUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<UserToChannelwithRoleCreateOrConnectWithoutChannelInput>
    createMany?: UserToChannelwithRoleCreateManyChannelInputEnvelope
    connect?: Enumerable<UserToChannelwithRoleWhereUniqueInput>
  }

  export type VideoCreateNestedManyWithoutBelongsToChannelInput = {
    create?: XOR<Enumerable<VideoCreateWithoutBelongsToChannelInput>, Enumerable<VideoUncheckedCreateWithoutBelongsToChannelInput>>
    connectOrCreate?: Enumerable<VideoCreateOrConnectWithoutBelongsToChannelInput>
    createMany?: VideoCreateManyBelongsToChannelInputEnvelope
    connect?: Enumerable<VideoWhereUniqueInput>
  }

  export type YouTubeUserUncheckedCreateNestedManyWithoutAdminOfChannelsInput = {
    create?: XOR<Enumerable<YouTubeUserCreateWithoutAdminOfChannelsInput>, Enumerable<YouTubeUserUncheckedCreateWithoutAdminOfChannelsInput>>
    connectOrCreate?: Enumerable<YouTubeUserCreateOrConnectWithoutAdminOfChannelsInput>
    connect?: Enumerable<YouTubeUserWhereUniqueInput>
  }

  export type YouTubeUserUncheckedCreateNestedManyWithoutSubscribingToChannelsInput = {
    create?: XOR<Enumerable<YouTubeUserCreateWithoutSubscribingToChannelsInput>, Enumerable<YouTubeUserUncheckedCreateWithoutSubscribingToChannelsInput>>
    connectOrCreate?: Enumerable<YouTubeUserCreateOrConnectWithoutSubscribingToChannelsInput>
    connect?: Enumerable<YouTubeUserWhereUniqueInput>
  }

  export type UserToChannelwithRoleUncheckedCreateNestedManyWithoutChannelInput = {
    create?: XOR<Enumerable<UserToChannelwithRoleCreateWithoutChannelInput>, Enumerable<UserToChannelwithRoleUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<UserToChannelwithRoleCreateOrConnectWithoutChannelInput>
    createMany?: UserToChannelwithRoleCreateManyChannelInputEnvelope
    connect?: Enumerable<UserToChannelwithRoleWhereUniqueInput>
  }

  export type VideoUncheckedCreateNestedManyWithoutBelongsToChannelInput = {
    create?: XOR<Enumerable<VideoCreateWithoutBelongsToChannelInput>, Enumerable<VideoUncheckedCreateWithoutBelongsToChannelInput>>
    connectOrCreate?: Enumerable<VideoCreateOrConnectWithoutBelongsToChannelInput>
    createMany?: VideoCreateManyBelongsToChannelInputEnvelope
    connect?: Enumerable<VideoWhereUniqueInput>
  }

  export type YouTubeUserUpdateManyWithoutAdminOfChannelsNestedInput = {
    create?: XOR<Enumerable<YouTubeUserCreateWithoutAdminOfChannelsInput>, Enumerable<YouTubeUserUncheckedCreateWithoutAdminOfChannelsInput>>
    connectOrCreate?: Enumerable<YouTubeUserCreateOrConnectWithoutAdminOfChannelsInput>
    upsert?: Enumerable<YouTubeUserUpsertWithWhereUniqueWithoutAdminOfChannelsInput>
    set?: Enumerable<YouTubeUserWhereUniqueInput>
    disconnect?: Enumerable<YouTubeUserWhereUniqueInput>
    delete?: Enumerable<YouTubeUserWhereUniqueInput>
    connect?: Enumerable<YouTubeUserWhereUniqueInput>
    update?: Enumerable<YouTubeUserUpdateWithWhereUniqueWithoutAdminOfChannelsInput>
    updateMany?: Enumerable<YouTubeUserUpdateManyWithWhereWithoutAdminOfChannelsInput>
    deleteMany?: Enumerable<YouTubeUserScalarWhereInput>
  }

  export type YouTubeUserUpdateManyWithoutSubscribingToChannelsNestedInput = {
    create?: XOR<Enumerable<YouTubeUserCreateWithoutSubscribingToChannelsInput>, Enumerable<YouTubeUserUncheckedCreateWithoutSubscribingToChannelsInput>>
    connectOrCreate?: Enumerable<YouTubeUserCreateOrConnectWithoutSubscribingToChannelsInput>
    upsert?: Enumerable<YouTubeUserUpsertWithWhereUniqueWithoutSubscribingToChannelsInput>
    set?: Enumerable<YouTubeUserWhereUniqueInput>
    disconnect?: Enumerable<YouTubeUserWhereUniqueInput>
    delete?: Enumerable<YouTubeUserWhereUniqueInput>
    connect?: Enumerable<YouTubeUserWhereUniqueInput>
    update?: Enumerable<YouTubeUserUpdateWithWhereUniqueWithoutSubscribingToChannelsInput>
    updateMany?: Enumerable<YouTubeUserUpdateManyWithWhereWithoutSubscribingToChannelsInput>
    deleteMany?: Enumerable<YouTubeUserScalarWhereInput>
  }

  export type UserToChannelwithRoleUpdateManyWithoutChannelNestedInput = {
    create?: XOR<Enumerable<UserToChannelwithRoleCreateWithoutChannelInput>, Enumerable<UserToChannelwithRoleUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<UserToChannelwithRoleCreateOrConnectWithoutChannelInput>
    upsert?: Enumerable<UserToChannelwithRoleUpsertWithWhereUniqueWithoutChannelInput>
    createMany?: UserToChannelwithRoleCreateManyChannelInputEnvelope
    set?: Enumerable<UserToChannelwithRoleWhereUniqueInput>
    disconnect?: Enumerable<UserToChannelwithRoleWhereUniqueInput>
    delete?: Enumerable<UserToChannelwithRoleWhereUniqueInput>
    connect?: Enumerable<UserToChannelwithRoleWhereUniqueInput>
    update?: Enumerable<UserToChannelwithRoleUpdateWithWhereUniqueWithoutChannelInput>
    updateMany?: Enumerable<UserToChannelwithRoleUpdateManyWithWhereWithoutChannelInput>
    deleteMany?: Enumerable<UserToChannelwithRoleScalarWhereInput>
  }

  export type VideoUpdateManyWithoutBelongsToChannelNestedInput = {
    create?: XOR<Enumerable<VideoCreateWithoutBelongsToChannelInput>, Enumerable<VideoUncheckedCreateWithoutBelongsToChannelInput>>
    connectOrCreate?: Enumerable<VideoCreateOrConnectWithoutBelongsToChannelInput>
    upsert?: Enumerable<VideoUpsertWithWhereUniqueWithoutBelongsToChannelInput>
    createMany?: VideoCreateManyBelongsToChannelInputEnvelope
    set?: Enumerable<VideoWhereUniqueInput>
    disconnect?: Enumerable<VideoWhereUniqueInput>
    delete?: Enumerable<VideoWhereUniqueInput>
    connect?: Enumerable<VideoWhereUniqueInput>
    update?: Enumerable<VideoUpdateWithWhereUniqueWithoutBelongsToChannelInput>
    updateMany?: Enumerable<VideoUpdateManyWithWhereWithoutBelongsToChannelInput>
    deleteMany?: Enumerable<VideoScalarWhereInput>
  }

  export type YouTubeUserUncheckedUpdateManyWithoutAdminOfChannelsNestedInput = {
    create?: XOR<Enumerable<YouTubeUserCreateWithoutAdminOfChannelsInput>, Enumerable<YouTubeUserUncheckedCreateWithoutAdminOfChannelsInput>>
    connectOrCreate?: Enumerable<YouTubeUserCreateOrConnectWithoutAdminOfChannelsInput>
    upsert?: Enumerable<YouTubeUserUpsertWithWhereUniqueWithoutAdminOfChannelsInput>
    set?: Enumerable<YouTubeUserWhereUniqueInput>
    disconnect?: Enumerable<YouTubeUserWhereUniqueInput>
    delete?: Enumerable<YouTubeUserWhereUniqueInput>
    connect?: Enumerable<YouTubeUserWhereUniqueInput>
    update?: Enumerable<YouTubeUserUpdateWithWhereUniqueWithoutAdminOfChannelsInput>
    updateMany?: Enumerable<YouTubeUserUpdateManyWithWhereWithoutAdminOfChannelsInput>
    deleteMany?: Enumerable<YouTubeUserScalarWhereInput>
  }

  export type YouTubeUserUncheckedUpdateManyWithoutSubscribingToChannelsNestedInput = {
    create?: XOR<Enumerable<YouTubeUserCreateWithoutSubscribingToChannelsInput>, Enumerable<YouTubeUserUncheckedCreateWithoutSubscribingToChannelsInput>>
    connectOrCreate?: Enumerable<YouTubeUserCreateOrConnectWithoutSubscribingToChannelsInput>
    upsert?: Enumerable<YouTubeUserUpsertWithWhereUniqueWithoutSubscribingToChannelsInput>
    set?: Enumerable<YouTubeUserWhereUniqueInput>
    disconnect?: Enumerable<YouTubeUserWhereUniqueInput>
    delete?: Enumerable<YouTubeUserWhereUniqueInput>
    connect?: Enumerable<YouTubeUserWhereUniqueInput>
    update?: Enumerable<YouTubeUserUpdateWithWhereUniqueWithoutSubscribingToChannelsInput>
    updateMany?: Enumerable<YouTubeUserUpdateManyWithWhereWithoutSubscribingToChannelsInput>
    deleteMany?: Enumerable<YouTubeUserScalarWhereInput>
  }

  export type UserToChannelwithRoleUncheckedUpdateManyWithoutChannelNestedInput = {
    create?: XOR<Enumerable<UserToChannelwithRoleCreateWithoutChannelInput>, Enumerable<UserToChannelwithRoleUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<UserToChannelwithRoleCreateOrConnectWithoutChannelInput>
    upsert?: Enumerable<UserToChannelwithRoleUpsertWithWhereUniqueWithoutChannelInput>
    createMany?: UserToChannelwithRoleCreateManyChannelInputEnvelope
    set?: Enumerable<UserToChannelwithRoleWhereUniqueInput>
    disconnect?: Enumerable<UserToChannelwithRoleWhereUniqueInput>
    delete?: Enumerable<UserToChannelwithRoleWhereUniqueInput>
    connect?: Enumerable<UserToChannelwithRoleWhereUniqueInput>
    update?: Enumerable<UserToChannelwithRoleUpdateWithWhereUniqueWithoutChannelInput>
    updateMany?: Enumerable<UserToChannelwithRoleUpdateManyWithWhereWithoutChannelInput>
    deleteMany?: Enumerable<UserToChannelwithRoleScalarWhereInput>
  }

  export type VideoUncheckedUpdateManyWithoutBelongsToChannelNestedInput = {
    create?: XOR<Enumerable<VideoCreateWithoutBelongsToChannelInput>, Enumerable<VideoUncheckedCreateWithoutBelongsToChannelInput>>
    connectOrCreate?: Enumerable<VideoCreateOrConnectWithoutBelongsToChannelInput>
    upsert?: Enumerable<VideoUpsertWithWhereUniqueWithoutBelongsToChannelInput>
    createMany?: VideoCreateManyBelongsToChannelInputEnvelope
    set?: Enumerable<VideoWhereUniqueInput>
    disconnect?: Enumerable<VideoWhereUniqueInput>
    delete?: Enumerable<VideoWhereUniqueInput>
    connect?: Enumerable<VideoWhereUniqueInput>
    update?: Enumerable<VideoUpdateWithWhereUniqueWithoutBelongsToChannelInput>
    updateMany?: Enumerable<VideoUpdateManyWithWhereWithoutBelongsToChannelInput>
    deleteMany?: Enumerable<VideoScalarWhereInput>
  }

  export type YouTubeUserCreateNestedOneWithoutUsersToChannelswithRolesInput = {
    create?: XOR<YouTubeUserCreateWithoutUsersToChannelswithRolesInput, YouTubeUserUncheckedCreateWithoutUsersToChannelswithRolesInput>
    connectOrCreate?: YouTubeUserCreateOrConnectWithoutUsersToChannelswithRolesInput
    connect?: YouTubeUserWhereUniqueInput
  }

  export type ChannelCreateNestedOneWithoutUsersToChannelswithRolesInput = {
    create?: XOR<ChannelCreateWithoutUsersToChannelswithRolesInput, ChannelUncheckedCreateWithoutUsersToChannelswithRolesInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutUsersToChannelswithRolesInput
    connect?: ChannelWhereUniqueInput
  }

  export type YouTubeUserUpdateOneRequiredWithoutUsersToChannelswithRolesNestedInput = {
    create?: XOR<YouTubeUserCreateWithoutUsersToChannelswithRolesInput, YouTubeUserUncheckedCreateWithoutUsersToChannelswithRolesInput>
    connectOrCreate?: YouTubeUserCreateOrConnectWithoutUsersToChannelswithRolesInput
    upsert?: YouTubeUserUpsertWithoutUsersToChannelswithRolesInput
    connect?: YouTubeUserWhereUniqueInput
    update?: XOR<YouTubeUserUpdateWithoutUsersToChannelswithRolesInput, YouTubeUserUncheckedUpdateWithoutUsersToChannelswithRolesInput>
  }

  export type ChannelUpdateOneRequiredWithoutUsersToChannelswithRolesNestedInput = {
    create?: XOR<ChannelCreateWithoutUsersToChannelswithRolesInput, ChannelUncheckedCreateWithoutUsersToChannelswithRolesInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutUsersToChannelswithRolesInput
    upsert?: ChannelUpsertWithoutUsersToChannelswithRolesInput
    connect?: ChannelWhereUniqueInput
    update?: XOR<ChannelUpdateWithoutUsersToChannelswithRolesInput, ChannelUncheckedUpdateWithoutUsersToChannelswithRolesInput>
  }

  export type EnumRoleEnumFieldUpdateOperationsInput = {
    set?: RoleEnum
  }

  export type ChannelCreateNestedOneWithoutOwningVideosInput = {
    create?: XOR<ChannelCreateWithoutOwningVideosInput, ChannelUncheckedCreateWithoutOwningVideosInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutOwningVideosInput
    connect?: ChannelWhereUniqueInput
  }

  export type YouTubeUserCreateNestedManyWithoutReactedVideosInput = {
    create?: XOR<Enumerable<YouTubeUserCreateWithoutReactedVideosInput>, Enumerable<YouTubeUserUncheckedCreateWithoutReactedVideosInput>>
    connectOrCreate?: Enumerable<YouTubeUserCreateOrConnectWithoutReactedVideosInput>
    connect?: Enumerable<YouTubeUserWhereUniqueInput>
  }

  export type UserToVideoWithReactionCreateNestedManyWithoutVideoInput = {
    create?: XOR<Enumerable<UserToVideoWithReactionCreateWithoutVideoInput>, Enumerable<UserToVideoWithReactionUncheckedCreateWithoutVideoInput>>
    connectOrCreate?: Enumerable<UserToVideoWithReactionCreateOrConnectWithoutVideoInput>
    createMany?: UserToVideoWithReactionCreateManyVideoInputEnvelope
    connect?: Enumerable<UserToVideoWithReactionWhereUniqueInput>
  }

  export type VideoCommentCreateNestedManyWithoutParentVideoInput = {
    create?: XOR<Enumerable<VideoCommentCreateWithoutParentVideoInput>, Enumerable<VideoCommentUncheckedCreateWithoutParentVideoInput>>
    connectOrCreate?: Enumerable<VideoCommentCreateOrConnectWithoutParentVideoInput>
    createMany?: VideoCommentCreateManyParentVideoInputEnvelope
    connect?: Enumerable<VideoCommentWhereUniqueInput>
  }

  export type YouTubeUserUncheckedCreateNestedManyWithoutReactedVideosInput = {
    create?: XOR<Enumerable<YouTubeUserCreateWithoutReactedVideosInput>, Enumerable<YouTubeUserUncheckedCreateWithoutReactedVideosInput>>
    connectOrCreate?: Enumerable<YouTubeUserCreateOrConnectWithoutReactedVideosInput>
    connect?: Enumerable<YouTubeUserWhereUniqueInput>
  }

  export type UserToVideoWithReactionUncheckedCreateNestedManyWithoutVideoInput = {
    create?: XOR<Enumerable<UserToVideoWithReactionCreateWithoutVideoInput>, Enumerable<UserToVideoWithReactionUncheckedCreateWithoutVideoInput>>
    connectOrCreate?: Enumerable<UserToVideoWithReactionCreateOrConnectWithoutVideoInput>
    createMany?: UserToVideoWithReactionCreateManyVideoInputEnvelope
    connect?: Enumerable<UserToVideoWithReactionWhereUniqueInput>
  }

  export type VideoCommentUncheckedCreateNestedManyWithoutParentVideoInput = {
    create?: XOR<Enumerable<VideoCommentCreateWithoutParentVideoInput>, Enumerable<VideoCommentUncheckedCreateWithoutParentVideoInput>>
    connectOrCreate?: Enumerable<VideoCommentCreateOrConnectWithoutParentVideoInput>
    createMany?: VideoCommentCreateManyParentVideoInputEnvelope
    connect?: Enumerable<VideoCommentWhereUniqueInput>
  }

  export type ChannelUpdateOneRequiredWithoutOwningVideosNestedInput = {
    create?: XOR<ChannelCreateWithoutOwningVideosInput, ChannelUncheckedCreateWithoutOwningVideosInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutOwningVideosInput
    upsert?: ChannelUpsertWithoutOwningVideosInput
    connect?: ChannelWhereUniqueInput
    update?: XOR<ChannelUpdateWithoutOwningVideosInput, ChannelUncheckedUpdateWithoutOwningVideosInput>
  }

  export type YouTubeUserUpdateManyWithoutReactedVideosNestedInput = {
    create?: XOR<Enumerable<YouTubeUserCreateWithoutReactedVideosInput>, Enumerable<YouTubeUserUncheckedCreateWithoutReactedVideosInput>>
    connectOrCreate?: Enumerable<YouTubeUserCreateOrConnectWithoutReactedVideosInput>
    upsert?: Enumerable<YouTubeUserUpsertWithWhereUniqueWithoutReactedVideosInput>
    set?: Enumerable<YouTubeUserWhereUniqueInput>
    disconnect?: Enumerable<YouTubeUserWhereUniqueInput>
    delete?: Enumerable<YouTubeUserWhereUniqueInput>
    connect?: Enumerable<YouTubeUserWhereUniqueInput>
    update?: Enumerable<YouTubeUserUpdateWithWhereUniqueWithoutReactedVideosInput>
    updateMany?: Enumerable<YouTubeUserUpdateManyWithWhereWithoutReactedVideosInput>
    deleteMany?: Enumerable<YouTubeUserScalarWhereInput>
  }

  export type UserToVideoWithReactionUpdateManyWithoutVideoNestedInput = {
    create?: XOR<Enumerable<UserToVideoWithReactionCreateWithoutVideoInput>, Enumerable<UserToVideoWithReactionUncheckedCreateWithoutVideoInput>>
    connectOrCreate?: Enumerable<UserToVideoWithReactionCreateOrConnectWithoutVideoInput>
    upsert?: Enumerable<UserToVideoWithReactionUpsertWithWhereUniqueWithoutVideoInput>
    createMany?: UserToVideoWithReactionCreateManyVideoInputEnvelope
    set?: Enumerable<UserToVideoWithReactionWhereUniqueInput>
    disconnect?: Enumerable<UserToVideoWithReactionWhereUniqueInput>
    delete?: Enumerable<UserToVideoWithReactionWhereUniqueInput>
    connect?: Enumerable<UserToVideoWithReactionWhereUniqueInput>
    update?: Enumerable<UserToVideoWithReactionUpdateWithWhereUniqueWithoutVideoInput>
    updateMany?: Enumerable<UserToVideoWithReactionUpdateManyWithWhereWithoutVideoInput>
    deleteMany?: Enumerable<UserToVideoWithReactionScalarWhereInput>
  }

  export type VideoCommentUpdateManyWithoutParentVideoNestedInput = {
    create?: XOR<Enumerable<VideoCommentCreateWithoutParentVideoInput>, Enumerable<VideoCommentUncheckedCreateWithoutParentVideoInput>>
    connectOrCreate?: Enumerable<VideoCommentCreateOrConnectWithoutParentVideoInput>
    upsert?: Enumerable<VideoCommentUpsertWithWhereUniqueWithoutParentVideoInput>
    createMany?: VideoCommentCreateManyParentVideoInputEnvelope
    set?: Enumerable<VideoCommentWhereUniqueInput>
    disconnect?: Enumerable<VideoCommentWhereUniqueInput>
    delete?: Enumerable<VideoCommentWhereUniqueInput>
    connect?: Enumerable<VideoCommentWhereUniqueInput>
    update?: Enumerable<VideoCommentUpdateWithWhereUniqueWithoutParentVideoInput>
    updateMany?: Enumerable<VideoCommentUpdateManyWithWhereWithoutParentVideoInput>
    deleteMany?: Enumerable<VideoCommentScalarWhereInput>
  }

  export type YouTubeUserUncheckedUpdateManyWithoutReactedVideosNestedInput = {
    create?: XOR<Enumerable<YouTubeUserCreateWithoutReactedVideosInput>, Enumerable<YouTubeUserUncheckedCreateWithoutReactedVideosInput>>
    connectOrCreate?: Enumerable<YouTubeUserCreateOrConnectWithoutReactedVideosInput>
    upsert?: Enumerable<YouTubeUserUpsertWithWhereUniqueWithoutReactedVideosInput>
    set?: Enumerable<YouTubeUserWhereUniqueInput>
    disconnect?: Enumerable<YouTubeUserWhereUniqueInput>
    delete?: Enumerable<YouTubeUserWhereUniqueInput>
    connect?: Enumerable<YouTubeUserWhereUniqueInput>
    update?: Enumerable<YouTubeUserUpdateWithWhereUniqueWithoutReactedVideosInput>
    updateMany?: Enumerable<YouTubeUserUpdateManyWithWhereWithoutReactedVideosInput>
    deleteMany?: Enumerable<YouTubeUserScalarWhereInput>
  }

  export type UserToVideoWithReactionUncheckedUpdateManyWithoutVideoNestedInput = {
    create?: XOR<Enumerable<UserToVideoWithReactionCreateWithoutVideoInput>, Enumerable<UserToVideoWithReactionUncheckedCreateWithoutVideoInput>>
    connectOrCreate?: Enumerable<UserToVideoWithReactionCreateOrConnectWithoutVideoInput>
    upsert?: Enumerable<UserToVideoWithReactionUpsertWithWhereUniqueWithoutVideoInput>
    createMany?: UserToVideoWithReactionCreateManyVideoInputEnvelope
    set?: Enumerable<UserToVideoWithReactionWhereUniqueInput>
    disconnect?: Enumerable<UserToVideoWithReactionWhereUniqueInput>
    delete?: Enumerable<UserToVideoWithReactionWhereUniqueInput>
    connect?: Enumerable<UserToVideoWithReactionWhereUniqueInput>
    update?: Enumerable<UserToVideoWithReactionUpdateWithWhereUniqueWithoutVideoInput>
    updateMany?: Enumerable<UserToVideoWithReactionUpdateManyWithWhereWithoutVideoInput>
    deleteMany?: Enumerable<UserToVideoWithReactionScalarWhereInput>
  }

  export type VideoCommentUncheckedUpdateManyWithoutParentVideoNestedInput = {
    create?: XOR<Enumerable<VideoCommentCreateWithoutParentVideoInput>, Enumerable<VideoCommentUncheckedCreateWithoutParentVideoInput>>
    connectOrCreate?: Enumerable<VideoCommentCreateOrConnectWithoutParentVideoInput>
    upsert?: Enumerable<VideoCommentUpsertWithWhereUniqueWithoutParentVideoInput>
    createMany?: VideoCommentCreateManyParentVideoInputEnvelope
    set?: Enumerable<VideoCommentWhereUniqueInput>
    disconnect?: Enumerable<VideoCommentWhereUniqueInput>
    delete?: Enumerable<VideoCommentWhereUniqueInput>
    connect?: Enumerable<VideoCommentWhereUniqueInput>
    update?: Enumerable<VideoCommentUpdateWithWhereUniqueWithoutParentVideoInput>
    updateMany?: Enumerable<VideoCommentUpdateManyWithWhereWithoutParentVideoInput>
    deleteMany?: Enumerable<VideoCommentScalarWhereInput>
  }

  export type YouTubeUserCreateNestedOneWithoutUsersToVideosWithReactionsInput = {
    create?: XOR<YouTubeUserCreateWithoutUsersToVideosWithReactionsInput, YouTubeUserUncheckedCreateWithoutUsersToVideosWithReactionsInput>
    connectOrCreate?: YouTubeUserCreateOrConnectWithoutUsersToVideosWithReactionsInput
    connect?: YouTubeUserWhereUniqueInput
  }

  export type VideoCreateNestedOneWithoutUsersToVideosWithReactionsInput = {
    create?: XOR<VideoCreateWithoutUsersToVideosWithReactionsInput, VideoUncheckedCreateWithoutUsersToVideosWithReactionsInput>
    connectOrCreate?: VideoCreateOrConnectWithoutUsersToVideosWithReactionsInput
    connect?: VideoWhereUniqueInput
  }

  export type YouTubeUserUpdateOneRequiredWithoutUsersToVideosWithReactionsNestedInput = {
    create?: XOR<YouTubeUserCreateWithoutUsersToVideosWithReactionsInput, YouTubeUserUncheckedCreateWithoutUsersToVideosWithReactionsInput>
    connectOrCreate?: YouTubeUserCreateOrConnectWithoutUsersToVideosWithReactionsInput
    upsert?: YouTubeUserUpsertWithoutUsersToVideosWithReactionsInput
    connect?: YouTubeUserWhereUniqueInput
    update?: XOR<YouTubeUserUpdateWithoutUsersToVideosWithReactionsInput, YouTubeUserUncheckedUpdateWithoutUsersToVideosWithReactionsInput>
  }

  export type VideoUpdateOneRequiredWithoutUsersToVideosWithReactionsNestedInput = {
    create?: XOR<VideoCreateWithoutUsersToVideosWithReactionsInput, VideoUncheckedCreateWithoutUsersToVideosWithReactionsInput>
    connectOrCreate?: VideoCreateOrConnectWithoutUsersToVideosWithReactionsInput
    upsert?: VideoUpsertWithoutUsersToVideosWithReactionsInput
    connect?: VideoWhereUniqueInput
    update?: XOR<VideoUpdateWithoutUsersToVideosWithReactionsInput, VideoUncheckedUpdateWithoutUsersToVideosWithReactionsInput>
  }

  export type EnumReactionEnumFieldUpdateOperationsInput = {
    set?: ReactionEnum
  }

  export type YouTubeUserCreateNestedOneWithoutVideoCommentsInput = {
    create?: XOR<YouTubeUserCreateWithoutVideoCommentsInput, YouTubeUserUncheckedCreateWithoutVideoCommentsInput>
    connectOrCreate?: YouTubeUserCreateOrConnectWithoutVideoCommentsInput
    connect?: YouTubeUserWhereUniqueInput
  }

  export type VideoCreateNestedOneWithoutVideoCommentsInput = {
    create?: XOR<VideoCreateWithoutVideoCommentsInput, VideoUncheckedCreateWithoutVideoCommentsInput>
    connectOrCreate?: VideoCreateOrConnectWithoutVideoCommentsInput
    connect?: VideoWhereUniqueInput
  }

  export type VideoCommentCreateNestedOneWithoutChildVideoCommentsInput = {
    create?: XOR<VideoCommentCreateWithoutChildVideoCommentsInput, VideoCommentUncheckedCreateWithoutChildVideoCommentsInput>
    connectOrCreate?: VideoCommentCreateOrConnectWithoutChildVideoCommentsInput
    connect?: VideoCommentWhereUniqueInput
  }

  export type VideoCommentCreateNestedManyWithoutParentVideoCommentInput = {
    create?: XOR<Enumerable<VideoCommentCreateWithoutParentVideoCommentInput>, Enumerable<VideoCommentUncheckedCreateWithoutParentVideoCommentInput>>
    connectOrCreate?: Enumerable<VideoCommentCreateOrConnectWithoutParentVideoCommentInput>
    createMany?: VideoCommentCreateManyParentVideoCommentInputEnvelope
    connect?: Enumerable<VideoCommentWhereUniqueInput>
  }

  export type VideoCommentUncheckedCreateNestedManyWithoutParentVideoCommentInput = {
    create?: XOR<Enumerable<VideoCommentCreateWithoutParentVideoCommentInput>, Enumerable<VideoCommentUncheckedCreateWithoutParentVideoCommentInput>>
    connectOrCreate?: Enumerable<VideoCommentCreateOrConnectWithoutParentVideoCommentInput>
    createMany?: VideoCommentCreateManyParentVideoCommentInputEnvelope
    connect?: Enumerable<VideoCommentWhereUniqueInput>
  }

  export type YouTubeUserUpdateOneRequiredWithoutVideoCommentsNestedInput = {
    create?: XOR<YouTubeUserCreateWithoutVideoCommentsInput, YouTubeUserUncheckedCreateWithoutVideoCommentsInput>
    connectOrCreate?: YouTubeUserCreateOrConnectWithoutVideoCommentsInput
    upsert?: YouTubeUserUpsertWithoutVideoCommentsInput
    connect?: YouTubeUserWhereUniqueInput
    update?: XOR<YouTubeUserUpdateWithoutVideoCommentsInput, YouTubeUserUncheckedUpdateWithoutVideoCommentsInput>
  }

  export type VideoUpdateOneRequiredWithoutVideoCommentsNestedInput = {
    create?: XOR<VideoCreateWithoutVideoCommentsInput, VideoUncheckedCreateWithoutVideoCommentsInput>
    connectOrCreate?: VideoCreateOrConnectWithoutVideoCommentsInput
    upsert?: VideoUpsertWithoutVideoCommentsInput
    connect?: VideoWhereUniqueInput
    update?: XOR<VideoUpdateWithoutVideoCommentsInput, VideoUncheckedUpdateWithoutVideoCommentsInput>
  }

  export type VideoCommentUpdateOneWithoutChildVideoCommentsNestedInput = {
    create?: XOR<VideoCommentCreateWithoutChildVideoCommentsInput, VideoCommentUncheckedCreateWithoutChildVideoCommentsInput>
    connectOrCreate?: VideoCommentCreateOrConnectWithoutChildVideoCommentsInput
    upsert?: VideoCommentUpsertWithoutChildVideoCommentsInput
    disconnect?: boolean
    delete?: boolean
    connect?: VideoCommentWhereUniqueInput
    update?: XOR<VideoCommentUpdateWithoutChildVideoCommentsInput, VideoCommentUncheckedUpdateWithoutChildVideoCommentsInput>
  }

  export type VideoCommentUpdateManyWithoutParentVideoCommentNestedInput = {
    create?: XOR<Enumerable<VideoCommentCreateWithoutParentVideoCommentInput>, Enumerable<VideoCommentUncheckedCreateWithoutParentVideoCommentInput>>
    connectOrCreate?: Enumerable<VideoCommentCreateOrConnectWithoutParentVideoCommentInput>
    upsert?: Enumerable<VideoCommentUpsertWithWhereUniqueWithoutParentVideoCommentInput>
    createMany?: VideoCommentCreateManyParentVideoCommentInputEnvelope
    set?: Enumerable<VideoCommentWhereUniqueInput>
    disconnect?: Enumerable<VideoCommentWhereUniqueInput>
    delete?: Enumerable<VideoCommentWhereUniqueInput>
    connect?: Enumerable<VideoCommentWhereUniqueInput>
    update?: Enumerable<VideoCommentUpdateWithWhereUniqueWithoutParentVideoCommentInput>
    updateMany?: Enumerable<VideoCommentUpdateManyWithWhereWithoutParentVideoCommentInput>
    deleteMany?: Enumerable<VideoCommentScalarWhereInput>
  }

  export type VideoCommentUncheckedUpdateManyWithoutParentVideoCommentNestedInput = {
    create?: XOR<Enumerable<VideoCommentCreateWithoutParentVideoCommentInput>, Enumerable<VideoCommentUncheckedCreateWithoutParentVideoCommentInput>>
    connectOrCreate?: Enumerable<VideoCommentCreateOrConnectWithoutParentVideoCommentInput>
    upsert?: Enumerable<VideoCommentUpsertWithWhereUniqueWithoutParentVideoCommentInput>
    createMany?: VideoCommentCreateManyParentVideoCommentInputEnvelope
    set?: Enumerable<VideoCommentWhereUniqueInput>
    disconnect?: Enumerable<VideoCommentWhereUniqueInput>
    delete?: Enumerable<VideoCommentWhereUniqueInput>
    connect?: Enumerable<VideoCommentWhereUniqueInput>
    update?: Enumerable<VideoCommentUpdateWithWhereUniqueWithoutParentVideoCommentInput>
    updateMany?: Enumerable<VideoCommentUpdateManyWithWhereWithoutParentVideoCommentInput>
    deleteMany?: Enumerable<VideoCommentScalarWhereInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedEnumRoleEnumFilter = {
    equals?: RoleEnum
    in?: Enumerable<RoleEnum>
    notIn?: Enumerable<RoleEnum>
    not?: NestedEnumRoleEnumFilter | RoleEnum
  }

  export type NestedEnumRoleEnumWithAggregatesFilter = {
    equals?: RoleEnum
    in?: Enumerable<RoleEnum>
    notIn?: Enumerable<RoleEnum>
    not?: NestedEnumRoleEnumWithAggregatesFilter | RoleEnum
    _count?: NestedIntFilter
    _min?: NestedEnumRoleEnumFilter
    _max?: NestedEnumRoleEnumFilter
  }

  export type NestedEnumReactionEnumFilter = {
    equals?: ReactionEnum
    in?: Enumerable<ReactionEnum>
    notIn?: Enumerable<ReactionEnum>
    not?: NestedEnumReactionEnumFilter | ReactionEnum
  }

  export type NestedEnumReactionEnumWithAggregatesFilter = {
    equals?: ReactionEnum
    in?: Enumerable<ReactionEnum>
    notIn?: Enumerable<ReactionEnum>
    not?: NestedEnumReactionEnumWithAggregatesFilter | ReactionEnum
    _count?: NestedIntFilter
    _min?: NestedEnumReactionEnumFilter
    _max?: NestedEnumReactionEnumFilter
  }

  export type MenuCreateWithoutCategoryInput = {
    name: string
    image: string
    price: number
    orderItems?: OrderItemCreateNestedManyWithoutMenuInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuUncheckedCreateWithoutCategoryInput = {
    id?: number
    name: string
    image: string
    price: number
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutMenuInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuCreateOrConnectWithoutCategoryInput = {
    where: MenuWhereUniqueInput
    create: XOR<MenuCreateWithoutCategoryInput, MenuUncheckedCreateWithoutCategoryInput>
  }

  export type MenuCreateManyCategoryInputEnvelope = {
    data: Enumerable<MenuCreateManyCategoryInput>
    skipDuplicates?: boolean
  }

  export type MenuUpsertWithWhereUniqueWithoutCategoryInput = {
    where: MenuWhereUniqueInput
    update: XOR<MenuUpdateWithoutCategoryInput, MenuUncheckedUpdateWithoutCategoryInput>
    create: XOR<MenuCreateWithoutCategoryInput, MenuUncheckedCreateWithoutCategoryInput>
  }

  export type MenuUpdateWithWhereUniqueWithoutCategoryInput = {
    where: MenuWhereUniqueInput
    data: XOR<MenuUpdateWithoutCategoryInput, MenuUncheckedUpdateWithoutCategoryInput>
  }

  export type MenuUpdateManyWithWhereWithoutCategoryInput = {
    where: MenuScalarWhereInput
    data: XOR<MenuUpdateManyMutationInput, MenuUncheckedUpdateManyWithoutMenuInput>
  }

  export type MenuScalarWhereInput = {
    AND?: Enumerable<MenuScalarWhereInput>
    OR?: Enumerable<MenuScalarWhereInput>
    NOT?: Enumerable<MenuScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    image?: StringFilter | string
    price?: FloatFilter | number
    categoryId?: IntNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type CategoryCreateWithoutMenuInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUncheckedCreateWithoutMenuInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryCreateOrConnectWithoutMenuInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutMenuInput, CategoryUncheckedCreateWithoutMenuInput>
  }

  export type OrderItemCreateWithoutMenuInput = {
    order?: OrderCreateNestedOneWithoutItemsInput
    quantity: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemUncheckedCreateWithoutMenuInput = {
    id?: number
    orderId?: number | null
    quantity: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemCreateOrConnectWithoutMenuInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutMenuInput, OrderItemUncheckedCreateWithoutMenuInput>
  }

  export type OrderItemCreateManyMenuInputEnvelope = {
    data: Enumerable<OrderItemCreateManyMenuInput>
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithoutMenuInput = {
    update: XOR<CategoryUpdateWithoutMenuInput, CategoryUncheckedUpdateWithoutMenuInput>
    create: XOR<CategoryCreateWithoutMenuInput, CategoryUncheckedCreateWithoutMenuInput>
  }

  export type CategoryUpdateWithoutMenuInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateWithoutMenuInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUpsertWithWhereUniqueWithoutMenuInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutMenuInput, OrderItemUncheckedUpdateWithoutMenuInput>
    create: XOR<OrderItemCreateWithoutMenuInput, OrderItemUncheckedCreateWithoutMenuInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutMenuInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutMenuInput, OrderItemUncheckedUpdateWithoutMenuInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutMenuInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderItemsInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: Enumerable<OrderItemScalarWhereInput>
    OR?: Enumerable<OrderItemScalarWhereInput>
    NOT?: Enumerable<OrderItemScalarWhereInput>
    id?: IntFilter | number
    menuId?: IntFilter | number
    orderId?: IntNullableFilter | number | null
    quantity?: IntFilter | number
    totalPrice?: FloatFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type OrderItemCreateWithoutOrderInput = {
    menu: MenuCreateNestedOneWithoutOrderItemsInput
    quantity: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: number
    menuId: number
    quantity: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: Enumerable<OrderItemCreateManyOrderInput>
    skipDuplicates?: boolean
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutItemsInput>
  }

  export type MenuCreateWithoutOrderItemsInput = {
    name: string
    image: string
    price: number
    category?: CategoryCreateNestedOneWithoutMenuInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuUncheckedCreateWithoutOrderItemsInput = {
    id?: number
    name: string
    image: string
    price: number
    categoryId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuCreateOrConnectWithoutOrderItemsInput = {
    where: MenuWhereUniqueInput
    create: XOR<MenuCreateWithoutOrderItemsInput, MenuUncheckedCreateWithoutOrderItemsInput>
  }

  export type OrderCreateWithoutItemsInput = {
    status?: string
    tableId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUncheckedCreateWithoutItemsInput = {
    id?: number
    status?: string
    tableId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateOrConnectWithoutItemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
  }

  export type MenuUpsertWithoutOrderItemsInput = {
    update: XOR<MenuUpdateWithoutOrderItemsInput, MenuUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<MenuCreateWithoutOrderItemsInput, MenuUncheckedCreateWithoutOrderItemsInput>
  }

  export type MenuUpdateWithoutOrderItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    category?: CategoryUpdateOneWithoutMenuNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuUncheckedUpdateWithoutOrderItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpsertWithoutItemsInput = {
    update: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
  }

  export type OrderUpdateWithoutItemsInput = {
    status?: StringFieldUpdateOperationsInput | string
    tableId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    tableId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizCreateWithoutCategoryInput = {
    questionText: string
    choices?: ChoiceCreateNestedManyWithoutQuizInput
    correctChoice: ChoiceCreateNestedOneWithoutCorrectQuizzesInput
    rounds?: RoundCreateNestedManyWithoutQuizzesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizUncheckedCreateWithoutCategoryInput = {
    id?: number
    questionText: string
    choices?: ChoiceUncheckedCreateNestedManyWithoutQuizInput
    correctChoiceId: number
    rounds?: RoundUncheckedCreateNestedManyWithoutQuizzesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizCreateOrConnectWithoutCategoryInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutCategoryInput, QuizUncheckedCreateWithoutCategoryInput>
  }

  export type QuizCreateManyCategoryInputEnvelope = {
    data: Enumerable<QuizCreateManyCategoryInput>
    skipDuplicates?: boolean
  }

  export type QuizUpsertWithWhereUniqueWithoutCategoryInput = {
    where: QuizWhereUniqueInput
    update: XOR<QuizUpdateWithoutCategoryInput, QuizUncheckedUpdateWithoutCategoryInput>
    create: XOR<QuizCreateWithoutCategoryInput, QuizUncheckedCreateWithoutCategoryInput>
  }

  export type QuizUpdateWithWhereUniqueWithoutCategoryInput = {
    where: QuizWhereUniqueInput
    data: XOR<QuizUpdateWithoutCategoryInput, QuizUncheckedUpdateWithoutCategoryInput>
  }

  export type QuizUpdateManyWithWhereWithoutCategoryInput = {
    where: QuizScalarWhereInput
    data: XOR<QuizUpdateManyMutationInput, QuizUncheckedUpdateManyWithoutQuizzesInput>
  }

  export type QuizScalarWhereInput = {
    AND?: Enumerable<QuizScalarWhereInput>
    OR?: Enumerable<QuizScalarWhereInput>
    NOT?: Enumerable<QuizScalarWhereInput>
    id?: IntFilter | number
    questionText?: StringFilter | string
    quizCategoryId?: IntFilter | number
    correctChoiceId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type QuizCreateWithoutChoicesInput = {
    questionText: string
    category: QuizCategoryCreateNestedOneWithoutQuizzesInput
    correctChoice: ChoiceCreateNestedOneWithoutCorrectQuizzesInput
    rounds?: RoundCreateNestedManyWithoutQuizzesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizUncheckedCreateWithoutChoicesInput = {
    id?: number
    questionText: string
    quizCategoryId: number
    correctChoiceId: number
    rounds?: RoundUncheckedCreateNestedManyWithoutQuizzesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizCreateOrConnectWithoutChoicesInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutChoicesInput, QuizUncheckedCreateWithoutChoicesInput>
  }

  export type QuizCreateWithoutCorrectChoiceInput = {
    questionText: string
    category: QuizCategoryCreateNestedOneWithoutQuizzesInput
    choices?: ChoiceCreateNestedManyWithoutQuizInput
    rounds?: RoundCreateNestedManyWithoutQuizzesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizUncheckedCreateWithoutCorrectChoiceInput = {
    id?: number
    questionText: string
    quizCategoryId: number
    choices?: ChoiceUncheckedCreateNestedManyWithoutQuizInput
    rounds?: RoundUncheckedCreateNestedManyWithoutQuizzesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizCreateOrConnectWithoutCorrectChoiceInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutCorrectChoiceInput, QuizUncheckedCreateWithoutCorrectChoiceInput>
  }

  export type QuizCreateManyCorrectChoiceInputEnvelope = {
    data: Enumerable<QuizCreateManyCorrectChoiceInput>
    skipDuplicates?: boolean
  }

  export type RoundCreateWithoutSelectedChoicesInput = {
    quizzes?: QuizCreateNestedManyWithoutRoundsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoundUncheckedCreateWithoutSelectedChoicesInput = {
    id?: number
    quizzes?: QuizUncheckedCreateNestedManyWithoutRoundsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoundCreateOrConnectWithoutSelectedChoicesInput = {
    where: RoundWhereUniqueInput
    create: XOR<RoundCreateWithoutSelectedChoicesInput, RoundUncheckedCreateWithoutSelectedChoicesInput>
  }

  export type QuizUpsertWithoutChoicesInput = {
    update: XOR<QuizUpdateWithoutChoicesInput, QuizUncheckedUpdateWithoutChoicesInput>
    create: XOR<QuizCreateWithoutChoicesInput, QuizUncheckedCreateWithoutChoicesInput>
  }

  export type QuizUpdateWithoutChoicesInput = {
    questionText?: StringFieldUpdateOperationsInput | string
    category?: QuizCategoryUpdateOneRequiredWithoutQuizzesNestedInput
    correctChoice?: ChoiceUpdateOneRequiredWithoutCorrectQuizzesNestedInput
    rounds?: RoundUpdateManyWithoutQuizzesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizUncheckedUpdateWithoutChoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionText?: StringFieldUpdateOperationsInput | string
    quizCategoryId?: IntFieldUpdateOperationsInput | number
    correctChoiceId?: IntFieldUpdateOperationsInput | number
    rounds?: RoundUncheckedUpdateManyWithoutQuizzesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizUpsertWithWhereUniqueWithoutCorrectChoiceInput = {
    where: QuizWhereUniqueInput
    update: XOR<QuizUpdateWithoutCorrectChoiceInput, QuizUncheckedUpdateWithoutCorrectChoiceInput>
    create: XOR<QuizCreateWithoutCorrectChoiceInput, QuizUncheckedCreateWithoutCorrectChoiceInput>
  }

  export type QuizUpdateWithWhereUniqueWithoutCorrectChoiceInput = {
    where: QuizWhereUniqueInput
    data: XOR<QuizUpdateWithoutCorrectChoiceInput, QuizUncheckedUpdateWithoutCorrectChoiceInput>
  }

  export type QuizUpdateManyWithWhereWithoutCorrectChoiceInput = {
    where: QuizScalarWhereInput
    data: XOR<QuizUpdateManyMutationInput, QuizUncheckedUpdateManyWithoutCorrectQuizzesInput>
  }

  export type RoundUpsertWithWhereUniqueWithoutSelectedChoicesInput = {
    where: RoundWhereUniqueInput
    update: XOR<RoundUpdateWithoutSelectedChoicesInput, RoundUncheckedUpdateWithoutSelectedChoicesInput>
    create: XOR<RoundCreateWithoutSelectedChoicesInput, RoundUncheckedCreateWithoutSelectedChoicesInput>
  }

  export type RoundUpdateWithWhereUniqueWithoutSelectedChoicesInput = {
    where: RoundWhereUniqueInput
    data: XOR<RoundUpdateWithoutSelectedChoicesInput, RoundUncheckedUpdateWithoutSelectedChoicesInput>
  }

  export type RoundUpdateManyWithWhereWithoutSelectedChoicesInput = {
    where: RoundScalarWhereInput
    data: XOR<RoundUpdateManyMutationInput, RoundUncheckedUpdateManyWithoutRoundsInput>
  }

  export type RoundScalarWhereInput = {
    AND?: Enumerable<RoundScalarWhereInput>
    OR?: Enumerable<RoundScalarWhereInput>
    NOT?: Enumerable<RoundScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type QuizCategoryCreateWithoutQuizzesInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizCategoryUncheckedCreateWithoutQuizzesInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizCategoryCreateOrConnectWithoutQuizzesInput = {
    where: QuizCategoryWhereUniqueInput
    create: XOR<QuizCategoryCreateWithoutQuizzesInput, QuizCategoryUncheckedCreateWithoutQuizzesInput>
  }

  export type ChoiceCreateWithoutQuizInput = {
    answerText: string
    correctQuizzes?: QuizCreateNestedManyWithoutCorrectChoiceInput
    rounds?: RoundCreateNestedManyWithoutSelectedChoicesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChoiceUncheckedCreateWithoutQuizInput = {
    id?: number
    answerText: string
    correctQuizzes?: QuizUncheckedCreateNestedManyWithoutCorrectChoiceInput
    rounds?: RoundUncheckedCreateNestedManyWithoutSelectedChoicesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChoiceCreateOrConnectWithoutQuizInput = {
    where: ChoiceWhereUniqueInput
    create: XOR<ChoiceCreateWithoutQuizInput, ChoiceUncheckedCreateWithoutQuizInput>
  }

  export type ChoiceCreateManyQuizInputEnvelope = {
    data: Enumerable<ChoiceCreateManyQuizInput>
    skipDuplicates?: boolean
  }

  export type ChoiceCreateWithoutCorrectQuizzesInput = {
    answerText: string
    quiz?: QuizCreateNestedOneWithoutChoicesInput
    rounds?: RoundCreateNestedManyWithoutSelectedChoicesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChoiceUncheckedCreateWithoutCorrectQuizzesInput = {
    id?: number
    answerText: string
    quizId?: number | null
    rounds?: RoundUncheckedCreateNestedManyWithoutSelectedChoicesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChoiceCreateOrConnectWithoutCorrectQuizzesInput = {
    where: ChoiceWhereUniqueInput
    create: XOR<ChoiceCreateWithoutCorrectQuizzesInput, ChoiceUncheckedCreateWithoutCorrectQuizzesInput>
  }

  export type RoundCreateWithoutQuizzesInput = {
    selectedChoices?: ChoiceCreateNestedManyWithoutRoundsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoundUncheckedCreateWithoutQuizzesInput = {
    id?: number
    selectedChoices?: ChoiceUncheckedCreateNestedManyWithoutRoundsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoundCreateOrConnectWithoutQuizzesInput = {
    where: RoundWhereUniqueInput
    create: XOR<RoundCreateWithoutQuizzesInput, RoundUncheckedCreateWithoutQuizzesInput>
  }

  export type QuizCategoryUpsertWithoutQuizzesInput = {
    update: XOR<QuizCategoryUpdateWithoutQuizzesInput, QuizCategoryUncheckedUpdateWithoutQuizzesInput>
    create: XOR<QuizCategoryCreateWithoutQuizzesInput, QuizCategoryUncheckedCreateWithoutQuizzesInput>
  }

  export type QuizCategoryUpdateWithoutQuizzesInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizCategoryUncheckedUpdateWithoutQuizzesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoiceUpsertWithWhereUniqueWithoutQuizInput = {
    where: ChoiceWhereUniqueInput
    update: XOR<ChoiceUpdateWithoutQuizInput, ChoiceUncheckedUpdateWithoutQuizInput>
    create: XOR<ChoiceCreateWithoutQuizInput, ChoiceUncheckedCreateWithoutQuizInput>
  }

  export type ChoiceUpdateWithWhereUniqueWithoutQuizInput = {
    where: ChoiceWhereUniqueInput
    data: XOR<ChoiceUpdateWithoutQuizInput, ChoiceUncheckedUpdateWithoutQuizInput>
  }

  export type ChoiceUpdateManyWithWhereWithoutQuizInput = {
    where: ChoiceScalarWhereInput
    data: XOR<ChoiceUpdateManyMutationInput, ChoiceUncheckedUpdateManyWithoutChoicesInput>
  }

  export type ChoiceScalarWhereInput = {
    AND?: Enumerable<ChoiceScalarWhereInput>
    OR?: Enumerable<ChoiceScalarWhereInput>
    NOT?: Enumerable<ChoiceScalarWhereInput>
    id?: IntFilter | number
    answerText?: StringFilter | string
    quizId?: IntNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ChoiceUpsertWithoutCorrectQuizzesInput = {
    update: XOR<ChoiceUpdateWithoutCorrectQuizzesInput, ChoiceUncheckedUpdateWithoutCorrectQuizzesInput>
    create: XOR<ChoiceCreateWithoutCorrectQuizzesInput, ChoiceUncheckedCreateWithoutCorrectQuizzesInput>
  }

  export type ChoiceUpdateWithoutCorrectQuizzesInput = {
    answerText?: StringFieldUpdateOperationsInput | string
    quiz?: QuizUpdateOneWithoutChoicesNestedInput
    rounds?: RoundUpdateManyWithoutSelectedChoicesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoiceUncheckedUpdateWithoutCorrectQuizzesInput = {
    id?: IntFieldUpdateOperationsInput | number
    answerText?: StringFieldUpdateOperationsInput | string
    quizId?: NullableIntFieldUpdateOperationsInput | number | null
    rounds?: RoundUncheckedUpdateManyWithoutSelectedChoicesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoundUpsertWithWhereUniqueWithoutQuizzesInput = {
    where: RoundWhereUniqueInput
    update: XOR<RoundUpdateWithoutQuizzesInput, RoundUncheckedUpdateWithoutQuizzesInput>
    create: XOR<RoundCreateWithoutQuizzesInput, RoundUncheckedCreateWithoutQuizzesInput>
  }

  export type RoundUpdateWithWhereUniqueWithoutQuizzesInput = {
    where: RoundWhereUniqueInput
    data: XOR<RoundUpdateWithoutQuizzesInput, RoundUncheckedUpdateWithoutQuizzesInput>
  }

  export type RoundUpdateManyWithWhereWithoutQuizzesInput = {
    where: RoundScalarWhereInput
    data: XOR<RoundUpdateManyMutationInput, RoundUncheckedUpdateManyWithoutRoundsInput>
  }

  export type QuizCreateWithoutRoundsInput = {
    questionText: string
    category: QuizCategoryCreateNestedOneWithoutQuizzesInput
    choices?: ChoiceCreateNestedManyWithoutQuizInput
    correctChoice: ChoiceCreateNestedOneWithoutCorrectQuizzesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizUncheckedCreateWithoutRoundsInput = {
    id?: number
    questionText: string
    quizCategoryId: number
    choices?: ChoiceUncheckedCreateNestedManyWithoutQuizInput
    correctChoiceId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizCreateOrConnectWithoutRoundsInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutRoundsInput, QuizUncheckedCreateWithoutRoundsInput>
  }

  export type ChoiceCreateWithoutRoundsInput = {
    answerText: string
    quiz?: QuizCreateNestedOneWithoutChoicesInput
    correctQuizzes?: QuizCreateNestedManyWithoutCorrectChoiceInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChoiceUncheckedCreateWithoutRoundsInput = {
    id?: number
    answerText: string
    quizId?: number | null
    correctQuizzes?: QuizUncheckedCreateNestedManyWithoutCorrectChoiceInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChoiceCreateOrConnectWithoutRoundsInput = {
    where: ChoiceWhereUniqueInput
    create: XOR<ChoiceCreateWithoutRoundsInput, ChoiceUncheckedCreateWithoutRoundsInput>
  }

  export type QuizUpsertWithWhereUniqueWithoutRoundsInput = {
    where: QuizWhereUniqueInput
    update: XOR<QuizUpdateWithoutRoundsInput, QuizUncheckedUpdateWithoutRoundsInput>
    create: XOR<QuizCreateWithoutRoundsInput, QuizUncheckedCreateWithoutRoundsInput>
  }

  export type QuizUpdateWithWhereUniqueWithoutRoundsInput = {
    where: QuizWhereUniqueInput
    data: XOR<QuizUpdateWithoutRoundsInput, QuizUncheckedUpdateWithoutRoundsInput>
  }

  export type QuizUpdateManyWithWhereWithoutRoundsInput = {
    where: QuizScalarWhereInput
    data: XOR<QuizUpdateManyMutationInput, QuizUncheckedUpdateManyWithoutQuizzesInput>
  }

  export type ChoiceUpsertWithWhereUniqueWithoutRoundsInput = {
    where: ChoiceWhereUniqueInput
    update: XOR<ChoiceUpdateWithoutRoundsInput, ChoiceUncheckedUpdateWithoutRoundsInput>
    create: XOR<ChoiceCreateWithoutRoundsInput, ChoiceUncheckedCreateWithoutRoundsInput>
  }

  export type ChoiceUpdateWithWhereUniqueWithoutRoundsInput = {
    where: ChoiceWhereUniqueInput
    data: XOR<ChoiceUpdateWithoutRoundsInput, ChoiceUncheckedUpdateWithoutRoundsInput>
  }

  export type ChoiceUpdateManyWithWhereWithoutRoundsInput = {
    where: ChoiceScalarWhereInput
    data: XOR<ChoiceUpdateManyMutationInput, ChoiceUncheckedUpdateManyWithoutSelectedChoicesInput>
  }

  export type FacebookUserRelationCreateWithoutFollowingUserInput = {
    followedUser: FacebookUserCreateNestedOneWithoutFollowedUserRelationsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserRelationUncheckedCreateWithoutFollowingUserInput = {
    id?: number
    followedUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserRelationCreateOrConnectWithoutFollowingUserInput = {
    where: FacebookUserRelationWhereUniqueInput
    create: XOR<FacebookUserRelationCreateWithoutFollowingUserInput, FacebookUserRelationUncheckedCreateWithoutFollowingUserInput>
  }

  export type FacebookUserRelationCreateManyFollowingUserInputEnvelope = {
    data: Enumerable<FacebookUserRelationCreateManyFollowingUserInput>
    skipDuplicates?: boolean
  }

  export type FacebookUserRelationCreateWithoutFollowedUserInput = {
    followingUser: FacebookUserCreateNestedOneWithoutFollowingUserRelationsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserRelationUncheckedCreateWithoutFollowedUserInput = {
    id?: number
    followingUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserRelationCreateOrConnectWithoutFollowedUserInput = {
    where: FacebookUserRelationWhereUniqueInput
    create: XOR<FacebookUserRelationCreateWithoutFollowedUserInput, FacebookUserRelationUncheckedCreateWithoutFollowedUserInput>
  }

  export type FacebookUserRelationCreateManyFollowedUserInputEnvelope = {
    data: Enumerable<FacebookUserRelationCreateManyFollowedUserInput>
    skipDuplicates?: boolean
  }

  export type PostCreateWithoutPostingUserInput = {
    postText: string
    comments?: CommentCreateNestedManyWithoutParentPostInput
    hashTags?: FacebookHashTagCreateNestedManyWithoutIsInPostsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostUncheckedCreateWithoutPostingUserInput = {
    id?: number
    postText: string
    comments?: CommentUncheckedCreateNestedManyWithoutParentPostInput
    hashTags?: FacebookHashTagUncheckedCreateNestedManyWithoutIsInPostsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostCreateOrConnectWithoutPostingUserInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutPostingUserInput, PostUncheckedCreateWithoutPostingUserInput>
  }

  export type PostCreateManyPostingUserInputEnvelope = {
    data: Enumerable<PostCreateManyPostingUserInput>
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutCommentingUserInput = {
    commentText: string
    parentPost: PostCreateNestedOneWithoutCommentsInput
    parentComment?: CommentCreateNestedOneWithoutChildCommentsInput
    childComments?: CommentCreateNestedManyWithoutParentCommentInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUncheckedCreateWithoutCommentingUserInput = {
    id?: number
    commentText: string
    postId: number
    parentCommentId?: number | null
    childComments?: CommentUncheckedCreateNestedManyWithoutParentCommentInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutCommentingUserInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutCommentingUserInput, CommentUncheckedCreateWithoutCommentingUserInput>
  }

  export type CommentCreateManyCommentingUserInputEnvelope = {
    data: Enumerable<CommentCreateManyCommentingUserInput>
    skipDuplicates?: boolean
  }

  export type MessengerMessageCreateWithoutFromUserInput = {
    messengerText: string
    toUser: FacebookUserCreateNestedOneWithoutMessengerMessagesToInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessengerMessageUncheckedCreateWithoutFromUserInput = {
    id?: number
    messengerText: string
    toUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessengerMessageCreateOrConnectWithoutFromUserInput = {
    where: MessengerMessageWhereUniqueInput
    create: XOR<MessengerMessageCreateWithoutFromUserInput, MessengerMessageUncheckedCreateWithoutFromUserInput>
  }

  export type MessengerMessageCreateManyFromUserInputEnvelope = {
    data: Enumerable<MessengerMessageCreateManyFromUserInput>
    skipDuplicates?: boolean
  }

  export type MessengerMessageCreateWithoutToUserInput = {
    messengerText: string
    fromUser: FacebookUserCreateNestedOneWithoutMessengerMessagesFromInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessengerMessageUncheckedCreateWithoutToUserInput = {
    id?: number
    messengerText: string
    fromUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessengerMessageCreateOrConnectWithoutToUserInput = {
    where: MessengerMessageWhereUniqueInput
    create: XOR<MessengerMessageCreateWithoutToUserInput, MessengerMessageUncheckedCreateWithoutToUserInput>
  }

  export type MessengerMessageCreateManyToUserInputEnvelope = {
    data: Enumerable<MessengerMessageCreateManyToUserInput>
    skipDuplicates?: boolean
  }

  export type FacebookUserRelationUpsertWithWhereUniqueWithoutFollowingUserInput = {
    where: FacebookUserRelationWhereUniqueInput
    update: XOR<FacebookUserRelationUpdateWithoutFollowingUserInput, FacebookUserRelationUncheckedUpdateWithoutFollowingUserInput>
    create: XOR<FacebookUserRelationCreateWithoutFollowingUserInput, FacebookUserRelationUncheckedCreateWithoutFollowingUserInput>
  }

  export type FacebookUserRelationUpdateWithWhereUniqueWithoutFollowingUserInput = {
    where: FacebookUserRelationWhereUniqueInput
    data: XOR<FacebookUserRelationUpdateWithoutFollowingUserInput, FacebookUserRelationUncheckedUpdateWithoutFollowingUserInput>
  }

  export type FacebookUserRelationUpdateManyWithWhereWithoutFollowingUserInput = {
    where: FacebookUserRelationScalarWhereInput
    data: XOR<FacebookUserRelationUpdateManyMutationInput, FacebookUserRelationUncheckedUpdateManyWithoutFollowingUserRelationsInput>
  }

  export type FacebookUserRelationScalarWhereInput = {
    AND?: Enumerable<FacebookUserRelationScalarWhereInput>
    OR?: Enumerable<FacebookUserRelationScalarWhereInput>
    NOT?: Enumerable<FacebookUserRelationScalarWhereInput>
    id?: IntFilter | number
    followingUserId?: IntFilter | number
    followedUserId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type FacebookUserRelationUpsertWithWhereUniqueWithoutFollowedUserInput = {
    where: FacebookUserRelationWhereUniqueInput
    update: XOR<FacebookUserRelationUpdateWithoutFollowedUserInput, FacebookUserRelationUncheckedUpdateWithoutFollowedUserInput>
    create: XOR<FacebookUserRelationCreateWithoutFollowedUserInput, FacebookUserRelationUncheckedCreateWithoutFollowedUserInput>
  }

  export type FacebookUserRelationUpdateWithWhereUniqueWithoutFollowedUserInput = {
    where: FacebookUserRelationWhereUniqueInput
    data: XOR<FacebookUserRelationUpdateWithoutFollowedUserInput, FacebookUserRelationUncheckedUpdateWithoutFollowedUserInput>
  }

  export type FacebookUserRelationUpdateManyWithWhereWithoutFollowedUserInput = {
    where: FacebookUserRelationScalarWhereInput
    data: XOR<FacebookUserRelationUpdateManyMutationInput, FacebookUserRelationUncheckedUpdateManyWithoutFollowedUserRelationsInput>
  }

  export type PostUpsertWithWhereUniqueWithoutPostingUserInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutPostingUserInput, PostUncheckedUpdateWithoutPostingUserInput>
    create: XOR<PostCreateWithoutPostingUserInput, PostUncheckedCreateWithoutPostingUserInput>
  }

  export type PostUpdateWithWhereUniqueWithoutPostingUserInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutPostingUserInput, PostUncheckedUpdateWithoutPostingUserInput>
  }

  export type PostUpdateManyWithWhereWithoutPostingUserInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutPostsInput>
  }

  export type PostScalarWhereInput = {
    AND?: Enumerable<PostScalarWhereInput>
    OR?: Enumerable<PostScalarWhereInput>
    NOT?: Enumerable<PostScalarWhereInput>
    id?: IntFilter | number
    postText?: StringFilter | string
    userId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutCommentingUserInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutCommentingUserInput, CommentUncheckedUpdateWithoutCommentingUserInput>
    create: XOR<CommentCreateWithoutCommentingUserInput, CommentUncheckedCreateWithoutCommentingUserInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutCommentingUserInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutCommentingUserInput, CommentUncheckedUpdateWithoutCommentingUserInput>
  }

  export type CommentUpdateManyWithWhereWithoutCommentingUserInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutCommentsInput>
  }

  export type CommentScalarWhereInput = {
    AND?: Enumerable<CommentScalarWhereInput>
    OR?: Enumerable<CommentScalarWhereInput>
    NOT?: Enumerable<CommentScalarWhereInput>
    id?: IntFilter | number
    commentText?: StringFilter | string
    userId?: IntFilter | number
    postId?: IntFilter | number
    parentCommentId?: IntNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type MessengerMessageUpsertWithWhereUniqueWithoutFromUserInput = {
    where: MessengerMessageWhereUniqueInput
    update: XOR<MessengerMessageUpdateWithoutFromUserInput, MessengerMessageUncheckedUpdateWithoutFromUserInput>
    create: XOR<MessengerMessageCreateWithoutFromUserInput, MessengerMessageUncheckedCreateWithoutFromUserInput>
  }

  export type MessengerMessageUpdateWithWhereUniqueWithoutFromUserInput = {
    where: MessengerMessageWhereUniqueInput
    data: XOR<MessengerMessageUpdateWithoutFromUserInput, MessengerMessageUncheckedUpdateWithoutFromUserInput>
  }

  export type MessengerMessageUpdateManyWithWhereWithoutFromUserInput = {
    where: MessengerMessageScalarWhereInput
    data: XOR<MessengerMessageUpdateManyMutationInput, MessengerMessageUncheckedUpdateManyWithoutMessengerMessagesFromInput>
  }

  export type MessengerMessageScalarWhereInput = {
    AND?: Enumerable<MessengerMessageScalarWhereInput>
    OR?: Enumerable<MessengerMessageScalarWhereInput>
    NOT?: Enumerable<MessengerMessageScalarWhereInput>
    id?: IntFilter | number
    messengerText?: StringFilter | string
    fromUserId?: IntFilter | number
    toUserId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type MessengerMessageUpsertWithWhereUniqueWithoutToUserInput = {
    where: MessengerMessageWhereUniqueInput
    update: XOR<MessengerMessageUpdateWithoutToUserInput, MessengerMessageUncheckedUpdateWithoutToUserInput>
    create: XOR<MessengerMessageCreateWithoutToUserInput, MessengerMessageUncheckedCreateWithoutToUserInput>
  }

  export type MessengerMessageUpdateWithWhereUniqueWithoutToUserInput = {
    where: MessengerMessageWhereUniqueInput
    data: XOR<MessengerMessageUpdateWithoutToUserInput, MessengerMessageUncheckedUpdateWithoutToUserInput>
  }

  export type MessengerMessageUpdateManyWithWhereWithoutToUserInput = {
    where: MessengerMessageScalarWhereInput
    data: XOR<MessengerMessageUpdateManyMutationInput, MessengerMessageUncheckedUpdateManyWithoutMessengerMessagesToInput>
  }

  export type FacebookUserCreateWithoutFollowingUserRelationsInput = {
    name: string
    imageUrl: string
    bio: string
    followedUserRelations?: FacebookUserRelationCreateNestedManyWithoutFollowedUserInput
    posts?: PostCreateNestedManyWithoutPostingUserInput
    comments?: CommentCreateNestedManyWithoutCommentingUserInput
    messengerMessagesFrom?: MessengerMessageCreateNestedManyWithoutFromUserInput
    messengerMessagesTo?: MessengerMessageCreateNestedManyWithoutToUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserUncheckedCreateWithoutFollowingUserRelationsInput = {
    id?: number
    name: string
    imageUrl: string
    bio: string
    followedUserRelations?: FacebookUserRelationUncheckedCreateNestedManyWithoutFollowedUserInput
    posts?: PostUncheckedCreateNestedManyWithoutPostingUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutCommentingUserInput
    messengerMessagesFrom?: MessengerMessageUncheckedCreateNestedManyWithoutFromUserInput
    messengerMessagesTo?: MessengerMessageUncheckedCreateNestedManyWithoutToUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserCreateOrConnectWithoutFollowingUserRelationsInput = {
    where: FacebookUserWhereUniqueInput
    create: XOR<FacebookUserCreateWithoutFollowingUserRelationsInput, FacebookUserUncheckedCreateWithoutFollowingUserRelationsInput>
  }

  export type FacebookUserCreateWithoutFollowedUserRelationsInput = {
    name: string
    imageUrl: string
    bio: string
    followingUserRelations?: FacebookUserRelationCreateNestedManyWithoutFollowingUserInput
    posts?: PostCreateNestedManyWithoutPostingUserInput
    comments?: CommentCreateNestedManyWithoutCommentingUserInput
    messengerMessagesFrom?: MessengerMessageCreateNestedManyWithoutFromUserInput
    messengerMessagesTo?: MessengerMessageCreateNestedManyWithoutToUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserUncheckedCreateWithoutFollowedUserRelationsInput = {
    id?: number
    name: string
    imageUrl: string
    bio: string
    followingUserRelations?: FacebookUserRelationUncheckedCreateNestedManyWithoutFollowingUserInput
    posts?: PostUncheckedCreateNestedManyWithoutPostingUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutCommentingUserInput
    messengerMessagesFrom?: MessengerMessageUncheckedCreateNestedManyWithoutFromUserInput
    messengerMessagesTo?: MessengerMessageUncheckedCreateNestedManyWithoutToUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserCreateOrConnectWithoutFollowedUserRelationsInput = {
    where: FacebookUserWhereUniqueInput
    create: XOR<FacebookUserCreateWithoutFollowedUserRelationsInput, FacebookUserUncheckedCreateWithoutFollowedUserRelationsInput>
  }

  export type FacebookUserUpsertWithoutFollowingUserRelationsInput = {
    update: XOR<FacebookUserUpdateWithoutFollowingUserRelationsInput, FacebookUserUncheckedUpdateWithoutFollowingUserRelationsInput>
    create: XOR<FacebookUserCreateWithoutFollowingUserRelationsInput, FacebookUserUncheckedCreateWithoutFollowingUserRelationsInput>
  }

  export type FacebookUserUpdateWithoutFollowingUserRelationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followedUserRelations?: FacebookUserRelationUpdateManyWithoutFollowedUserNestedInput
    posts?: PostUpdateManyWithoutPostingUserNestedInput
    comments?: CommentUpdateManyWithoutCommentingUserNestedInput
    messengerMessagesFrom?: MessengerMessageUpdateManyWithoutFromUserNestedInput
    messengerMessagesTo?: MessengerMessageUpdateManyWithoutToUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserUncheckedUpdateWithoutFollowingUserRelationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followedUserRelations?: FacebookUserRelationUncheckedUpdateManyWithoutFollowedUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutPostingUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCommentingUserNestedInput
    messengerMessagesFrom?: MessengerMessageUncheckedUpdateManyWithoutFromUserNestedInput
    messengerMessagesTo?: MessengerMessageUncheckedUpdateManyWithoutToUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserUpsertWithoutFollowedUserRelationsInput = {
    update: XOR<FacebookUserUpdateWithoutFollowedUserRelationsInput, FacebookUserUncheckedUpdateWithoutFollowedUserRelationsInput>
    create: XOR<FacebookUserCreateWithoutFollowedUserRelationsInput, FacebookUserUncheckedCreateWithoutFollowedUserRelationsInput>
  }

  export type FacebookUserUpdateWithoutFollowedUserRelationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followingUserRelations?: FacebookUserRelationUpdateManyWithoutFollowingUserNestedInput
    posts?: PostUpdateManyWithoutPostingUserNestedInput
    comments?: CommentUpdateManyWithoutCommentingUserNestedInput
    messengerMessagesFrom?: MessengerMessageUpdateManyWithoutFromUserNestedInput
    messengerMessagesTo?: MessengerMessageUpdateManyWithoutToUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserUncheckedUpdateWithoutFollowedUserRelationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followingUserRelations?: FacebookUserRelationUncheckedUpdateManyWithoutFollowingUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutPostingUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCommentingUserNestedInput
    messengerMessagesFrom?: MessengerMessageUncheckedUpdateManyWithoutFromUserNestedInput
    messengerMessagesTo?: MessengerMessageUncheckedUpdateManyWithoutToUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserCreateWithoutPostsInput = {
    name: string
    imageUrl: string
    bio: string
    followingUserRelations?: FacebookUserRelationCreateNestedManyWithoutFollowingUserInput
    followedUserRelations?: FacebookUserRelationCreateNestedManyWithoutFollowedUserInput
    comments?: CommentCreateNestedManyWithoutCommentingUserInput
    messengerMessagesFrom?: MessengerMessageCreateNestedManyWithoutFromUserInput
    messengerMessagesTo?: MessengerMessageCreateNestedManyWithoutToUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserUncheckedCreateWithoutPostsInput = {
    id?: number
    name: string
    imageUrl: string
    bio: string
    followingUserRelations?: FacebookUserRelationUncheckedCreateNestedManyWithoutFollowingUserInput
    followedUserRelations?: FacebookUserRelationUncheckedCreateNestedManyWithoutFollowedUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutCommentingUserInput
    messengerMessagesFrom?: MessengerMessageUncheckedCreateNestedManyWithoutFromUserInput
    messengerMessagesTo?: MessengerMessageUncheckedCreateNestedManyWithoutToUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserCreateOrConnectWithoutPostsInput = {
    where: FacebookUserWhereUniqueInput
    create: XOR<FacebookUserCreateWithoutPostsInput, FacebookUserUncheckedCreateWithoutPostsInput>
  }

  export type CommentCreateWithoutParentPostInput = {
    commentText: string
    commentingUser: FacebookUserCreateNestedOneWithoutCommentsInput
    parentComment?: CommentCreateNestedOneWithoutChildCommentsInput
    childComments?: CommentCreateNestedManyWithoutParentCommentInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUncheckedCreateWithoutParentPostInput = {
    id?: number
    commentText: string
    userId: number
    parentCommentId?: number | null
    childComments?: CommentUncheckedCreateNestedManyWithoutParentCommentInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutParentPostInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutParentPostInput, CommentUncheckedCreateWithoutParentPostInput>
  }

  export type CommentCreateManyParentPostInputEnvelope = {
    data: Enumerable<CommentCreateManyParentPostInput>
    skipDuplicates?: boolean
  }

  export type FacebookHashTagCreateWithoutIsInPostsInput = {
    hashTagText: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookHashTagUncheckedCreateWithoutIsInPostsInput = {
    id?: number
    hashTagText: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookHashTagCreateOrConnectWithoutIsInPostsInput = {
    where: FacebookHashTagWhereUniqueInput
    create: XOR<FacebookHashTagCreateWithoutIsInPostsInput, FacebookHashTagUncheckedCreateWithoutIsInPostsInput>
  }

  export type FacebookUserUpsertWithoutPostsInput = {
    update: XOR<FacebookUserUpdateWithoutPostsInput, FacebookUserUncheckedUpdateWithoutPostsInput>
    create: XOR<FacebookUserCreateWithoutPostsInput, FacebookUserUncheckedCreateWithoutPostsInput>
  }

  export type FacebookUserUpdateWithoutPostsInput = {
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followingUserRelations?: FacebookUserRelationUpdateManyWithoutFollowingUserNestedInput
    followedUserRelations?: FacebookUserRelationUpdateManyWithoutFollowedUserNestedInput
    comments?: CommentUpdateManyWithoutCommentingUserNestedInput
    messengerMessagesFrom?: MessengerMessageUpdateManyWithoutFromUserNestedInput
    messengerMessagesTo?: MessengerMessageUpdateManyWithoutToUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserUncheckedUpdateWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followingUserRelations?: FacebookUserRelationUncheckedUpdateManyWithoutFollowingUserNestedInput
    followedUserRelations?: FacebookUserRelationUncheckedUpdateManyWithoutFollowedUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCommentingUserNestedInput
    messengerMessagesFrom?: MessengerMessageUncheckedUpdateManyWithoutFromUserNestedInput
    messengerMessagesTo?: MessengerMessageUncheckedUpdateManyWithoutToUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutParentPostInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutParentPostInput, CommentUncheckedUpdateWithoutParentPostInput>
    create: XOR<CommentCreateWithoutParentPostInput, CommentUncheckedCreateWithoutParentPostInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutParentPostInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutParentPostInput, CommentUncheckedUpdateWithoutParentPostInput>
  }

  export type CommentUpdateManyWithWhereWithoutParentPostInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutCommentsInput>
  }

  export type FacebookHashTagUpsertWithWhereUniqueWithoutIsInPostsInput = {
    where: FacebookHashTagWhereUniqueInput
    update: XOR<FacebookHashTagUpdateWithoutIsInPostsInput, FacebookHashTagUncheckedUpdateWithoutIsInPostsInput>
    create: XOR<FacebookHashTagCreateWithoutIsInPostsInput, FacebookHashTagUncheckedCreateWithoutIsInPostsInput>
  }

  export type FacebookHashTagUpdateWithWhereUniqueWithoutIsInPostsInput = {
    where: FacebookHashTagWhereUniqueInput
    data: XOR<FacebookHashTagUpdateWithoutIsInPostsInput, FacebookHashTagUncheckedUpdateWithoutIsInPostsInput>
  }

  export type FacebookHashTagUpdateManyWithWhereWithoutIsInPostsInput = {
    where: FacebookHashTagScalarWhereInput
    data: XOR<FacebookHashTagUpdateManyMutationInput, FacebookHashTagUncheckedUpdateManyWithoutHashTagsInput>
  }

  export type FacebookHashTagScalarWhereInput = {
    AND?: Enumerable<FacebookHashTagScalarWhereInput>
    OR?: Enumerable<FacebookHashTagScalarWhereInput>
    NOT?: Enumerable<FacebookHashTagScalarWhereInput>
    id?: IntFilter | number
    hashTagText?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type FacebookUserCreateWithoutCommentsInput = {
    name: string
    imageUrl: string
    bio: string
    followingUserRelations?: FacebookUserRelationCreateNestedManyWithoutFollowingUserInput
    followedUserRelations?: FacebookUserRelationCreateNestedManyWithoutFollowedUserInput
    posts?: PostCreateNestedManyWithoutPostingUserInput
    messengerMessagesFrom?: MessengerMessageCreateNestedManyWithoutFromUserInput
    messengerMessagesTo?: MessengerMessageCreateNestedManyWithoutToUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserUncheckedCreateWithoutCommentsInput = {
    id?: number
    name: string
    imageUrl: string
    bio: string
    followingUserRelations?: FacebookUserRelationUncheckedCreateNestedManyWithoutFollowingUserInput
    followedUserRelations?: FacebookUserRelationUncheckedCreateNestedManyWithoutFollowedUserInput
    posts?: PostUncheckedCreateNestedManyWithoutPostingUserInput
    messengerMessagesFrom?: MessengerMessageUncheckedCreateNestedManyWithoutFromUserInput
    messengerMessagesTo?: MessengerMessageUncheckedCreateNestedManyWithoutToUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserCreateOrConnectWithoutCommentsInput = {
    where: FacebookUserWhereUniqueInput
    create: XOR<FacebookUserCreateWithoutCommentsInput, FacebookUserUncheckedCreateWithoutCommentsInput>
  }

  export type PostCreateWithoutCommentsInput = {
    postText: string
    postingUser: FacebookUserCreateNestedOneWithoutPostsInput
    hashTags?: FacebookHashTagCreateNestedManyWithoutIsInPostsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostUncheckedCreateWithoutCommentsInput = {
    id?: number
    postText: string
    userId: number
    hashTags?: FacebookHashTagUncheckedCreateNestedManyWithoutIsInPostsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostCreateOrConnectWithoutCommentsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
  }

  export type CommentCreateWithoutChildCommentsInput = {
    commentText: string
    commentingUser: FacebookUserCreateNestedOneWithoutCommentsInput
    parentPost: PostCreateNestedOneWithoutCommentsInput
    parentComment?: CommentCreateNestedOneWithoutChildCommentsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUncheckedCreateWithoutChildCommentsInput = {
    id?: number
    commentText: string
    userId: number
    postId: number
    parentCommentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutChildCommentsInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutChildCommentsInput, CommentUncheckedCreateWithoutChildCommentsInput>
  }

  export type CommentCreateWithoutParentCommentInput = {
    commentText: string
    commentingUser: FacebookUserCreateNestedOneWithoutCommentsInput
    parentPost: PostCreateNestedOneWithoutCommentsInput
    childComments?: CommentCreateNestedManyWithoutParentCommentInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUncheckedCreateWithoutParentCommentInput = {
    id?: number
    commentText: string
    userId: number
    postId: number
    childComments?: CommentUncheckedCreateNestedManyWithoutParentCommentInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutParentCommentInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutParentCommentInput, CommentUncheckedCreateWithoutParentCommentInput>
  }

  export type CommentCreateManyParentCommentInputEnvelope = {
    data: Enumerable<CommentCreateManyParentCommentInput>
    skipDuplicates?: boolean
  }

  export type FacebookUserUpsertWithoutCommentsInput = {
    update: XOR<FacebookUserUpdateWithoutCommentsInput, FacebookUserUncheckedUpdateWithoutCommentsInput>
    create: XOR<FacebookUserCreateWithoutCommentsInput, FacebookUserUncheckedCreateWithoutCommentsInput>
  }

  export type FacebookUserUpdateWithoutCommentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followingUserRelations?: FacebookUserRelationUpdateManyWithoutFollowingUserNestedInput
    followedUserRelations?: FacebookUserRelationUpdateManyWithoutFollowedUserNestedInput
    posts?: PostUpdateManyWithoutPostingUserNestedInput
    messengerMessagesFrom?: MessengerMessageUpdateManyWithoutFromUserNestedInput
    messengerMessagesTo?: MessengerMessageUpdateManyWithoutToUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followingUserRelations?: FacebookUserRelationUncheckedUpdateManyWithoutFollowingUserNestedInput
    followedUserRelations?: FacebookUserRelationUncheckedUpdateManyWithoutFollowedUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutPostingUserNestedInput
    messengerMessagesFrom?: MessengerMessageUncheckedUpdateManyWithoutFromUserNestedInput
    messengerMessagesTo?: MessengerMessageUncheckedUpdateManyWithoutToUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUpsertWithoutCommentsInput = {
    update: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
  }

  export type PostUpdateWithoutCommentsInput = {
    postText?: StringFieldUpdateOperationsInput | string
    postingUser?: FacebookUserUpdateOneRequiredWithoutPostsNestedInput
    hashTags?: FacebookHashTagUpdateManyWithoutIsInPostsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    postText?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    hashTags?: FacebookHashTagUncheckedUpdateManyWithoutIsInPostsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpsertWithoutChildCommentsInput = {
    update: XOR<CommentUpdateWithoutChildCommentsInput, CommentUncheckedUpdateWithoutChildCommentsInput>
    create: XOR<CommentCreateWithoutChildCommentsInput, CommentUncheckedCreateWithoutChildCommentsInput>
  }

  export type CommentUpdateWithoutChildCommentsInput = {
    commentText?: StringFieldUpdateOperationsInput | string
    commentingUser?: FacebookUserUpdateOneRequiredWithoutCommentsNestedInput
    parentPost?: PostUpdateOneRequiredWithoutCommentsNestedInput
    parentComment?: CommentUpdateOneWithoutChildCommentsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateWithoutChildCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentText?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    parentCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutParentCommentInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutParentCommentInput, CommentUncheckedUpdateWithoutParentCommentInput>
    create: XOR<CommentCreateWithoutParentCommentInput, CommentUncheckedCreateWithoutParentCommentInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutParentCommentInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutParentCommentInput, CommentUncheckedUpdateWithoutParentCommentInput>
  }

  export type CommentUpdateManyWithWhereWithoutParentCommentInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutChildCommentsInput>
  }

  export type PostCreateWithoutHashTagsInput = {
    postText: string
    postingUser: FacebookUserCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutParentPostInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostUncheckedCreateWithoutHashTagsInput = {
    id?: number
    postText: string
    userId: number
    comments?: CommentUncheckedCreateNestedManyWithoutParentPostInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostCreateOrConnectWithoutHashTagsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutHashTagsInput, PostUncheckedCreateWithoutHashTagsInput>
  }

  export type PostUpsertWithWhereUniqueWithoutHashTagsInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutHashTagsInput, PostUncheckedUpdateWithoutHashTagsInput>
    create: XOR<PostCreateWithoutHashTagsInput, PostUncheckedCreateWithoutHashTagsInput>
  }

  export type PostUpdateWithWhereUniqueWithoutHashTagsInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutHashTagsInput, PostUncheckedUpdateWithoutHashTagsInput>
  }

  export type PostUpdateManyWithWhereWithoutHashTagsInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutIsInPostsInput>
  }

  export type FacebookUserCreateWithoutMessengerMessagesFromInput = {
    name: string
    imageUrl: string
    bio: string
    followingUserRelations?: FacebookUserRelationCreateNestedManyWithoutFollowingUserInput
    followedUserRelations?: FacebookUserRelationCreateNestedManyWithoutFollowedUserInput
    posts?: PostCreateNestedManyWithoutPostingUserInput
    comments?: CommentCreateNestedManyWithoutCommentingUserInput
    messengerMessagesTo?: MessengerMessageCreateNestedManyWithoutToUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserUncheckedCreateWithoutMessengerMessagesFromInput = {
    id?: number
    name: string
    imageUrl: string
    bio: string
    followingUserRelations?: FacebookUserRelationUncheckedCreateNestedManyWithoutFollowingUserInput
    followedUserRelations?: FacebookUserRelationUncheckedCreateNestedManyWithoutFollowedUserInput
    posts?: PostUncheckedCreateNestedManyWithoutPostingUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutCommentingUserInput
    messengerMessagesTo?: MessengerMessageUncheckedCreateNestedManyWithoutToUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserCreateOrConnectWithoutMessengerMessagesFromInput = {
    where: FacebookUserWhereUniqueInput
    create: XOR<FacebookUserCreateWithoutMessengerMessagesFromInput, FacebookUserUncheckedCreateWithoutMessengerMessagesFromInput>
  }

  export type FacebookUserCreateWithoutMessengerMessagesToInput = {
    name: string
    imageUrl: string
    bio: string
    followingUserRelations?: FacebookUserRelationCreateNestedManyWithoutFollowingUserInput
    followedUserRelations?: FacebookUserRelationCreateNestedManyWithoutFollowedUserInput
    posts?: PostCreateNestedManyWithoutPostingUserInput
    comments?: CommentCreateNestedManyWithoutCommentingUserInput
    messengerMessagesFrom?: MessengerMessageCreateNestedManyWithoutFromUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserUncheckedCreateWithoutMessengerMessagesToInput = {
    id?: number
    name: string
    imageUrl: string
    bio: string
    followingUserRelations?: FacebookUserRelationUncheckedCreateNestedManyWithoutFollowingUserInput
    followedUserRelations?: FacebookUserRelationUncheckedCreateNestedManyWithoutFollowedUserInput
    posts?: PostUncheckedCreateNestedManyWithoutPostingUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutCommentingUserInput
    messengerMessagesFrom?: MessengerMessageUncheckedCreateNestedManyWithoutFromUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserCreateOrConnectWithoutMessengerMessagesToInput = {
    where: FacebookUserWhereUniqueInput
    create: XOR<FacebookUserCreateWithoutMessengerMessagesToInput, FacebookUserUncheckedCreateWithoutMessengerMessagesToInput>
  }

  export type FacebookUserUpsertWithoutMessengerMessagesFromInput = {
    update: XOR<FacebookUserUpdateWithoutMessengerMessagesFromInput, FacebookUserUncheckedUpdateWithoutMessengerMessagesFromInput>
    create: XOR<FacebookUserCreateWithoutMessengerMessagesFromInput, FacebookUserUncheckedCreateWithoutMessengerMessagesFromInput>
  }

  export type FacebookUserUpdateWithoutMessengerMessagesFromInput = {
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followingUserRelations?: FacebookUserRelationUpdateManyWithoutFollowingUserNestedInput
    followedUserRelations?: FacebookUserRelationUpdateManyWithoutFollowedUserNestedInput
    posts?: PostUpdateManyWithoutPostingUserNestedInput
    comments?: CommentUpdateManyWithoutCommentingUserNestedInput
    messengerMessagesTo?: MessengerMessageUpdateManyWithoutToUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserUncheckedUpdateWithoutMessengerMessagesFromInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followingUserRelations?: FacebookUserRelationUncheckedUpdateManyWithoutFollowingUserNestedInput
    followedUserRelations?: FacebookUserRelationUncheckedUpdateManyWithoutFollowedUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutPostingUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCommentingUserNestedInput
    messengerMessagesTo?: MessengerMessageUncheckedUpdateManyWithoutToUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserUpsertWithoutMessengerMessagesToInput = {
    update: XOR<FacebookUserUpdateWithoutMessengerMessagesToInput, FacebookUserUncheckedUpdateWithoutMessengerMessagesToInput>
    create: XOR<FacebookUserCreateWithoutMessengerMessagesToInput, FacebookUserUncheckedCreateWithoutMessengerMessagesToInput>
  }

  export type FacebookUserUpdateWithoutMessengerMessagesToInput = {
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followingUserRelations?: FacebookUserRelationUpdateManyWithoutFollowingUserNestedInput
    followedUserRelations?: FacebookUserRelationUpdateManyWithoutFollowedUserNestedInput
    posts?: PostUpdateManyWithoutPostingUserNestedInput
    comments?: CommentUpdateManyWithoutCommentingUserNestedInput
    messengerMessagesFrom?: MessengerMessageUpdateManyWithoutFromUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserUncheckedUpdateWithoutMessengerMessagesToInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followingUserRelations?: FacebookUserRelationUncheckedUpdateManyWithoutFollowingUserNestedInput
    followedUserRelations?: FacebookUserRelationUncheckedUpdateManyWithoutFollowedUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutPostingUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCommentingUserNestedInput
    messengerMessagesFrom?: MessengerMessageUncheckedUpdateManyWithoutFromUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRelationCreateWithoutFollowingUserInput = {
    followedUser: UserCreateNestedOneWithoutFollowedUserRelationsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserRelationUncheckedCreateWithoutFollowingUserInput = {
    id?: number
    followedUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserRelationCreateOrConnectWithoutFollowingUserInput = {
    where: UserRelationWhereUniqueInput
    create: XOR<UserRelationCreateWithoutFollowingUserInput, UserRelationUncheckedCreateWithoutFollowingUserInput>
  }

  export type UserRelationCreateManyFollowingUserInputEnvelope = {
    data: Enumerable<UserRelationCreateManyFollowingUserInput>
    skipDuplicates?: boolean
  }

  export type UserRelationCreateWithoutFollowedUserInput = {
    followingUser: UserCreateNestedOneWithoutFollowingUserRelationsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserRelationUncheckedCreateWithoutFollowedUserInput = {
    id?: number
    followingUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserRelationCreateOrConnectWithoutFollowedUserInput = {
    where: UserRelationWhereUniqueInput
    create: XOR<UserRelationCreateWithoutFollowedUserInput, UserRelationUncheckedCreateWithoutFollowedUserInput>
  }

  export type UserRelationCreateManyFollowedUserInputEnvelope = {
    data: Enumerable<UserRelationCreateManyFollowedUserInput>
    skipDuplicates?: boolean
  }

  export type TweetCreateWithoutTweetingUserInput = {
    tweetText: string
    parentTweet?: TweetCreateNestedOneWithoutChildTweetsInput
    childTweets?: TweetCreateNestedManyWithoutParentTweetInput
    hashTags?: HashTagCreateNestedManyWithoutIsInTweetsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TweetUncheckedCreateWithoutTweetingUserInput = {
    id?: number
    tweetText: string
    parentTweetId?: number | null
    childTweets?: TweetUncheckedCreateNestedManyWithoutParentTweetInput
    hashTags?: HashTagUncheckedCreateNestedManyWithoutIsInTweetsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TweetCreateOrConnectWithoutTweetingUserInput = {
    where: TweetWhereUniqueInput
    create: XOR<TweetCreateWithoutTweetingUserInput, TweetUncheckedCreateWithoutTweetingUserInput>
  }

  export type TweetCreateManyTweetingUserInputEnvelope = {
    data: Enumerable<TweetCreateManyTweetingUserInput>
    skipDuplicates?: boolean
  }

  export type DirectMessageCreateWithoutFromUserInput = {
    dmText: string
    toUser: UserCreateNestedOneWithoutDirectMessagesToInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DirectMessageUncheckedCreateWithoutFromUserInput = {
    id?: number
    dmText: string
    toUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DirectMessageCreateOrConnectWithoutFromUserInput = {
    where: DirectMessageWhereUniqueInput
    create: XOR<DirectMessageCreateWithoutFromUserInput, DirectMessageUncheckedCreateWithoutFromUserInput>
  }

  export type DirectMessageCreateManyFromUserInputEnvelope = {
    data: Enumerable<DirectMessageCreateManyFromUserInput>
    skipDuplicates?: boolean
  }

  export type DirectMessageCreateWithoutToUserInput = {
    dmText: string
    fromUser: UserCreateNestedOneWithoutDirectMessagesFromInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DirectMessageUncheckedCreateWithoutToUserInput = {
    id?: number
    dmText: string
    fromUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DirectMessageCreateOrConnectWithoutToUserInput = {
    where: DirectMessageWhereUniqueInput
    create: XOR<DirectMessageCreateWithoutToUserInput, DirectMessageUncheckedCreateWithoutToUserInput>
  }

  export type DirectMessageCreateManyToUserInputEnvelope = {
    data: Enumerable<DirectMessageCreateManyToUserInput>
    skipDuplicates?: boolean
  }

  export type UserRelationUpsertWithWhereUniqueWithoutFollowingUserInput = {
    where: UserRelationWhereUniqueInput
    update: XOR<UserRelationUpdateWithoutFollowingUserInput, UserRelationUncheckedUpdateWithoutFollowingUserInput>
    create: XOR<UserRelationCreateWithoutFollowingUserInput, UserRelationUncheckedCreateWithoutFollowingUserInput>
  }

  export type UserRelationUpdateWithWhereUniqueWithoutFollowingUserInput = {
    where: UserRelationWhereUniqueInput
    data: XOR<UserRelationUpdateWithoutFollowingUserInput, UserRelationUncheckedUpdateWithoutFollowingUserInput>
  }

  export type UserRelationUpdateManyWithWhereWithoutFollowingUserInput = {
    where: UserRelationScalarWhereInput
    data: XOR<UserRelationUpdateManyMutationInput, UserRelationUncheckedUpdateManyWithoutFollowingUserRelationsInput>
  }

  export type UserRelationScalarWhereInput = {
    AND?: Enumerable<UserRelationScalarWhereInput>
    OR?: Enumerable<UserRelationScalarWhereInput>
    NOT?: Enumerable<UserRelationScalarWhereInput>
    id?: IntFilter | number
    followingUserId?: IntFilter | number
    followedUserId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type UserRelationUpsertWithWhereUniqueWithoutFollowedUserInput = {
    where: UserRelationWhereUniqueInput
    update: XOR<UserRelationUpdateWithoutFollowedUserInput, UserRelationUncheckedUpdateWithoutFollowedUserInput>
    create: XOR<UserRelationCreateWithoutFollowedUserInput, UserRelationUncheckedCreateWithoutFollowedUserInput>
  }

  export type UserRelationUpdateWithWhereUniqueWithoutFollowedUserInput = {
    where: UserRelationWhereUniqueInput
    data: XOR<UserRelationUpdateWithoutFollowedUserInput, UserRelationUncheckedUpdateWithoutFollowedUserInput>
  }

  export type UserRelationUpdateManyWithWhereWithoutFollowedUserInput = {
    where: UserRelationScalarWhereInput
    data: XOR<UserRelationUpdateManyMutationInput, UserRelationUncheckedUpdateManyWithoutFollowedUserRelationsInput>
  }

  export type TweetUpsertWithWhereUniqueWithoutTweetingUserInput = {
    where: TweetWhereUniqueInput
    update: XOR<TweetUpdateWithoutTweetingUserInput, TweetUncheckedUpdateWithoutTweetingUserInput>
    create: XOR<TweetCreateWithoutTweetingUserInput, TweetUncheckedCreateWithoutTweetingUserInput>
  }

  export type TweetUpdateWithWhereUniqueWithoutTweetingUserInput = {
    where: TweetWhereUniqueInput
    data: XOR<TweetUpdateWithoutTweetingUserInput, TweetUncheckedUpdateWithoutTweetingUserInput>
  }

  export type TweetUpdateManyWithWhereWithoutTweetingUserInput = {
    where: TweetScalarWhereInput
    data: XOR<TweetUpdateManyMutationInput, TweetUncheckedUpdateManyWithoutTweetsInput>
  }

  export type TweetScalarWhereInput = {
    AND?: Enumerable<TweetScalarWhereInput>
    OR?: Enumerable<TweetScalarWhereInput>
    NOT?: Enumerable<TweetScalarWhereInput>
    id?: IntFilter | number
    tweetText?: StringFilter | string
    parentTweetId?: IntNullableFilter | number | null
    userId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type DirectMessageUpsertWithWhereUniqueWithoutFromUserInput = {
    where: DirectMessageWhereUniqueInput
    update: XOR<DirectMessageUpdateWithoutFromUserInput, DirectMessageUncheckedUpdateWithoutFromUserInput>
    create: XOR<DirectMessageCreateWithoutFromUserInput, DirectMessageUncheckedCreateWithoutFromUserInput>
  }

  export type DirectMessageUpdateWithWhereUniqueWithoutFromUserInput = {
    where: DirectMessageWhereUniqueInput
    data: XOR<DirectMessageUpdateWithoutFromUserInput, DirectMessageUncheckedUpdateWithoutFromUserInput>
  }

  export type DirectMessageUpdateManyWithWhereWithoutFromUserInput = {
    where: DirectMessageScalarWhereInput
    data: XOR<DirectMessageUpdateManyMutationInput, DirectMessageUncheckedUpdateManyWithoutDirectMessagesFromInput>
  }

  export type DirectMessageScalarWhereInput = {
    AND?: Enumerable<DirectMessageScalarWhereInput>
    OR?: Enumerable<DirectMessageScalarWhereInput>
    NOT?: Enumerable<DirectMessageScalarWhereInput>
    id?: IntFilter | number
    dmText?: StringFilter | string
    fromUserId?: IntFilter | number
    toUserId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type DirectMessageUpsertWithWhereUniqueWithoutToUserInput = {
    where: DirectMessageWhereUniqueInput
    update: XOR<DirectMessageUpdateWithoutToUserInput, DirectMessageUncheckedUpdateWithoutToUserInput>
    create: XOR<DirectMessageCreateWithoutToUserInput, DirectMessageUncheckedCreateWithoutToUserInput>
  }

  export type DirectMessageUpdateWithWhereUniqueWithoutToUserInput = {
    where: DirectMessageWhereUniqueInput
    data: XOR<DirectMessageUpdateWithoutToUserInput, DirectMessageUncheckedUpdateWithoutToUserInput>
  }

  export type DirectMessageUpdateManyWithWhereWithoutToUserInput = {
    where: DirectMessageScalarWhereInput
    data: XOR<DirectMessageUpdateManyMutationInput, DirectMessageUncheckedUpdateManyWithoutDirectMessagesToInput>
  }

  export type UserCreateWithoutFollowingUserRelationsInput = {
    name: string
    imageUrl: string
    bio: string
    followedUserRelations?: UserRelationCreateNestedManyWithoutFollowedUserInput
    tweets?: TweetCreateNestedManyWithoutTweetingUserInput
    directMessagesFrom?: DirectMessageCreateNestedManyWithoutFromUserInput
    directMessagesTo?: DirectMessageCreateNestedManyWithoutToUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateWithoutFollowingUserRelationsInput = {
    id?: number
    name: string
    imageUrl: string
    bio: string
    followedUserRelations?: UserRelationUncheckedCreateNestedManyWithoutFollowedUserInput
    tweets?: TweetUncheckedCreateNestedManyWithoutTweetingUserInput
    directMessagesFrom?: DirectMessageUncheckedCreateNestedManyWithoutFromUserInput
    directMessagesTo?: DirectMessageUncheckedCreateNestedManyWithoutToUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateOrConnectWithoutFollowingUserRelationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFollowingUserRelationsInput, UserUncheckedCreateWithoutFollowingUserRelationsInput>
  }

  export type UserCreateWithoutFollowedUserRelationsInput = {
    name: string
    imageUrl: string
    bio: string
    followingUserRelations?: UserRelationCreateNestedManyWithoutFollowingUserInput
    tweets?: TweetCreateNestedManyWithoutTweetingUserInput
    directMessagesFrom?: DirectMessageCreateNestedManyWithoutFromUserInput
    directMessagesTo?: DirectMessageCreateNestedManyWithoutToUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateWithoutFollowedUserRelationsInput = {
    id?: number
    name: string
    imageUrl: string
    bio: string
    followingUserRelations?: UserRelationUncheckedCreateNestedManyWithoutFollowingUserInput
    tweets?: TweetUncheckedCreateNestedManyWithoutTweetingUserInput
    directMessagesFrom?: DirectMessageUncheckedCreateNestedManyWithoutFromUserInput
    directMessagesTo?: DirectMessageUncheckedCreateNestedManyWithoutToUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateOrConnectWithoutFollowedUserRelationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFollowedUserRelationsInput, UserUncheckedCreateWithoutFollowedUserRelationsInput>
  }

  export type UserUpsertWithoutFollowingUserRelationsInput = {
    update: XOR<UserUpdateWithoutFollowingUserRelationsInput, UserUncheckedUpdateWithoutFollowingUserRelationsInput>
    create: XOR<UserCreateWithoutFollowingUserRelationsInput, UserUncheckedCreateWithoutFollowingUserRelationsInput>
  }

  export type UserUpdateWithoutFollowingUserRelationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followedUserRelations?: UserRelationUpdateManyWithoutFollowedUserNestedInput
    tweets?: TweetUpdateManyWithoutTweetingUserNestedInput
    directMessagesFrom?: DirectMessageUpdateManyWithoutFromUserNestedInput
    directMessagesTo?: DirectMessageUpdateManyWithoutToUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutFollowingUserRelationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followedUserRelations?: UserRelationUncheckedUpdateManyWithoutFollowedUserNestedInput
    tweets?: TweetUncheckedUpdateManyWithoutTweetingUserNestedInput
    directMessagesFrom?: DirectMessageUncheckedUpdateManyWithoutFromUserNestedInput
    directMessagesTo?: DirectMessageUncheckedUpdateManyWithoutToUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutFollowedUserRelationsInput = {
    update: XOR<UserUpdateWithoutFollowedUserRelationsInput, UserUncheckedUpdateWithoutFollowedUserRelationsInput>
    create: XOR<UserCreateWithoutFollowedUserRelationsInput, UserUncheckedCreateWithoutFollowedUserRelationsInput>
  }

  export type UserUpdateWithoutFollowedUserRelationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followingUserRelations?: UserRelationUpdateManyWithoutFollowingUserNestedInput
    tweets?: TweetUpdateManyWithoutTweetingUserNestedInput
    directMessagesFrom?: DirectMessageUpdateManyWithoutFromUserNestedInput
    directMessagesTo?: DirectMessageUpdateManyWithoutToUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutFollowedUserRelationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followingUserRelations?: UserRelationUncheckedUpdateManyWithoutFollowingUserNestedInput
    tweets?: TweetUncheckedUpdateManyWithoutTweetingUserNestedInput
    directMessagesFrom?: DirectMessageUncheckedUpdateManyWithoutFromUserNestedInput
    directMessagesTo?: DirectMessageUncheckedUpdateManyWithoutToUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutTweetsInput = {
    name: string
    imageUrl: string
    bio: string
    followingUserRelations?: UserRelationCreateNestedManyWithoutFollowingUserInput
    followedUserRelations?: UserRelationCreateNestedManyWithoutFollowedUserInput
    directMessagesFrom?: DirectMessageCreateNestedManyWithoutFromUserInput
    directMessagesTo?: DirectMessageCreateNestedManyWithoutToUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateWithoutTweetsInput = {
    id?: number
    name: string
    imageUrl: string
    bio: string
    followingUserRelations?: UserRelationUncheckedCreateNestedManyWithoutFollowingUserInput
    followedUserRelations?: UserRelationUncheckedCreateNestedManyWithoutFollowedUserInput
    directMessagesFrom?: DirectMessageUncheckedCreateNestedManyWithoutFromUserInput
    directMessagesTo?: DirectMessageUncheckedCreateNestedManyWithoutToUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateOrConnectWithoutTweetsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTweetsInput, UserUncheckedCreateWithoutTweetsInput>
  }

  export type TweetCreateWithoutChildTweetsInput = {
    tweetText: string
    tweetingUser: UserCreateNestedOneWithoutTweetsInput
    parentTweet?: TweetCreateNestedOneWithoutChildTweetsInput
    hashTags?: HashTagCreateNestedManyWithoutIsInTweetsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TweetUncheckedCreateWithoutChildTweetsInput = {
    id?: number
    tweetText: string
    parentTweetId?: number | null
    userId: number
    hashTags?: HashTagUncheckedCreateNestedManyWithoutIsInTweetsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TweetCreateOrConnectWithoutChildTweetsInput = {
    where: TweetWhereUniqueInput
    create: XOR<TweetCreateWithoutChildTweetsInput, TweetUncheckedCreateWithoutChildTweetsInput>
  }

  export type TweetCreateWithoutParentTweetInput = {
    tweetText: string
    tweetingUser: UserCreateNestedOneWithoutTweetsInput
    childTweets?: TweetCreateNestedManyWithoutParentTweetInput
    hashTags?: HashTagCreateNestedManyWithoutIsInTweetsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TweetUncheckedCreateWithoutParentTweetInput = {
    id?: number
    tweetText: string
    childTweets?: TweetUncheckedCreateNestedManyWithoutParentTweetInput
    userId: number
    hashTags?: HashTagUncheckedCreateNestedManyWithoutIsInTweetsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TweetCreateOrConnectWithoutParentTweetInput = {
    where: TweetWhereUniqueInput
    create: XOR<TweetCreateWithoutParentTweetInput, TweetUncheckedCreateWithoutParentTweetInput>
  }

  export type TweetCreateManyParentTweetInputEnvelope = {
    data: Enumerable<TweetCreateManyParentTweetInput>
    skipDuplicates?: boolean
  }

  export type HashTagCreateWithoutIsInTweetsInput = {
    hashTagText: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HashTagUncheckedCreateWithoutIsInTweetsInput = {
    id?: number
    hashTagText: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HashTagCreateOrConnectWithoutIsInTweetsInput = {
    where: HashTagWhereUniqueInput
    create: XOR<HashTagCreateWithoutIsInTweetsInput, HashTagUncheckedCreateWithoutIsInTweetsInput>
  }

  export type UserUpsertWithoutTweetsInput = {
    update: XOR<UserUpdateWithoutTweetsInput, UserUncheckedUpdateWithoutTweetsInput>
    create: XOR<UserCreateWithoutTweetsInput, UserUncheckedCreateWithoutTweetsInput>
  }

  export type UserUpdateWithoutTweetsInput = {
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followingUserRelations?: UserRelationUpdateManyWithoutFollowingUserNestedInput
    followedUserRelations?: UserRelationUpdateManyWithoutFollowedUserNestedInput
    directMessagesFrom?: DirectMessageUpdateManyWithoutFromUserNestedInput
    directMessagesTo?: DirectMessageUpdateManyWithoutToUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutTweetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followingUserRelations?: UserRelationUncheckedUpdateManyWithoutFollowingUserNestedInput
    followedUserRelations?: UserRelationUncheckedUpdateManyWithoutFollowedUserNestedInput
    directMessagesFrom?: DirectMessageUncheckedUpdateManyWithoutFromUserNestedInput
    directMessagesTo?: DirectMessageUncheckedUpdateManyWithoutToUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TweetUpsertWithoutChildTweetsInput = {
    update: XOR<TweetUpdateWithoutChildTweetsInput, TweetUncheckedUpdateWithoutChildTweetsInput>
    create: XOR<TweetCreateWithoutChildTweetsInput, TweetUncheckedCreateWithoutChildTweetsInput>
  }

  export type TweetUpdateWithoutChildTweetsInput = {
    tweetText?: StringFieldUpdateOperationsInput | string
    tweetingUser?: UserUpdateOneRequiredWithoutTweetsNestedInput
    parentTweet?: TweetUpdateOneWithoutChildTweetsNestedInput
    hashTags?: HashTagUpdateManyWithoutIsInTweetsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TweetUncheckedUpdateWithoutChildTweetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tweetText?: StringFieldUpdateOperationsInput | string
    parentTweetId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    hashTags?: HashTagUncheckedUpdateManyWithoutIsInTweetsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TweetUpsertWithWhereUniqueWithoutParentTweetInput = {
    where: TweetWhereUniqueInput
    update: XOR<TweetUpdateWithoutParentTweetInput, TweetUncheckedUpdateWithoutParentTweetInput>
    create: XOR<TweetCreateWithoutParentTweetInput, TweetUncheckedCreateWithoutParentTweetInput>
  }

  export type TweetUpdateWithWhereUniqueWithoutParentTweetInput = {
    where: TweetWhereUniqueInput
    data: XOR<TweetUpdateWithoutParentTweetInput, TweetUncheckedUpdateWithoutParentTweetInput>
  }

  export type TweetUpdateManyWithWhereWithoutParentTweetInput = {
    where: TweetScalarWhereInput
    data: XOR<TweetUpdateManyMutationInput, TweetUncheckedUpdateManyWithoutChildTweetsInput>
  }

  export type HashTagUpsertWithWhereUniqueWithoutIsInTweetsInput = {
    where: HashTagWhereUniqueInput
    update: XOR<HashTagUpdateWithoutIsInTweetsInput, HashTagUncheckedUpdateWithoutIsInTweetsInput>
    create: XOR<HashTagCreateWithoutIsInTweetsInput, HashTagUncheckedCreateWithoutIsInTweetsInput>
  }

  export type HashTagUpdateWithWhereUniqueWithoutIsInTweetsInput = {
    where: HashTagWhereUniqueInput
    data: XOR<HashTagUpdateWithoutIsInTweetsInput, HashTagUncheckedUpdateWithoutIsInTweetsInput>
  }

  export type HashTagUpdateManyWithWhereWithoutIsInTweetsInput = {
    where: HashTagScalarWhereInput
    data: XOR<HashTagUpdateManyMutationInput, HashTagUncheckedUpdateManyWithoutHashTagsInput>
  }

  export type HashTagScalarWhereInput = {
    AND?: Enumerable<HashTagScalarWhereInput>
    OR?: Enumerable<HashTagScalarWhereInput>
    NOT?: Enumerable<HashTagScalarWhereInput>
    id?: IntFilter | number
    hashTagText?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TweetCreateWithoutHashTagsInput = {
    tweetText: string
    tweetingUser: UserCreateNestedOneWithoutTweetsInput
    parentTweet?: TweetCreateNestedOneWithoutChildTweetsInput
    childTweets?: TweetCreateNestedManyWithoutParentTweetInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TweetUncheckedCreateWithoutHashTagsInput = {
    id?: number
    tweetText: string
    parentTweetId?: number | null
    childTweets?: TweetUncheckedCreateNestedManyWithoutParentTweetInput
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TweetCreateOrConnectWithoutHashTagsInput = {
    where: TweetWhereUniqueInput
    create: XOR<TweetCreateWithoutHashTagsInput, TweetUncheckedCreateWithoutHashTagsInput>
  }

  export type TweetUpsertWithWhereUniqueWithoutHashTagsInput = {
    where: TweetWhereUniqueInput
    update: XOR<TweetUpdateWithoutHashTagsInput, TweetUncheckedUpdateWithoutHashTagsInput>
    create: XOR<TweetCreateWithoutHashTagsInput, TweetUncheckedCreateWithoutHashTagsInput>
  }

  export type TweetUpdateWithWhereUniqueWithoutHashTagsInput = {
    where: TweetWhereUniqueInput
    data: XOR<TweetUpdateWithoutHashTagsInput, TweetUncheckedUpdateWithoutHashTagsInput>
  }

  export type TweetUpdateManyWithWhereWithoutHashTagsInput = {
    where: TweetScalarWhereInput
    data: XOR<TweetUpdateManyMutationInput, TweetUncheckedUpdateManyWithoutIsInTweetsInput>
  }

  export type UserCreateWithoutDirectMessagesFromInput = {
    name: string
    imageUrl: string
    bio: string
    followingUserRelations?: UserRelationCreateNestedManyWithoutFollowingUserInput
    followedUserRelations?: UserRelationCreateNestedManyWithoutFollowedUserInput
    tweets?: TweetCreateNestedManyWithoutTweetingUserInput
    directMessagesTo?: DirectMessageCreateNestedManyWithoutToUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateWithoutDirectMessagesFromInput = {
    id?: number
    name: string
    imageUrl: string
    bio: string
    followingUserRelations?: UserRelationUncheckedCreateNestedManyWithoutFollowingUserInput
    followedUserRelations?: UserRelationUncheckedCreateNestedManyWithoutFollowedUserInput
    tweets?: TweetUncheckedCreateNestedManyWithoutTweetingUserInput
    directMessagesTo?: DirectMessageUncheckedCreateNestedManyWithoutToUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateOrConnectWithoutDirectMessagesFromInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDirectMessagesFromInput, UserUncheckedCreateWithoutDirectMessagesFromInput>
  }

  export type UserCreateWithoutDirectMessagesToInput = {
    name: string
    imageUrl: string
    bio: string
    followingUserRelations?: UserRelationCreateNestedManyWithoutFollowingUserInput
    followedUserRelations?: UserRelationCreateNestedManyWithoutFollowedUserInput
    tweets?: TweetCreateNestedManyWithoutTweetingUserInput
    directMessagesFrom?: DirectMessageCreateNestedManyWithoutFromUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateWithoutDirectMessagesToInput = {
    id?: number
    name: string
    imageUrl: string
    bio: string
    followingUserRelations?: UserRelationUncheckedCreateNestedManyWithoutFollowingUserInput
    followedUserRelations?: UserRelationUncheckedCreateNestedManyWithoutFollowedUserInput
    tweets?: TweetUncheckedCreateNestedManyWithoutTweetingUserInput
    directMessagesFrom?: DirectMessageUncheckedCreateNestedManyWithoutFromUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateOrConnectWithoutDirectMessagesToInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDirectMessagesToInput, UserUncheckedCreateWithoutDirectMessagesToInput>
  }

  export type UserUpsertWithoutDirectMessagesFromInput = {
    update: XOR<UserUpdateWithoutDirectMessagesFromInput, UserUncheckedUpdateWithoutDirectMessagesFromInput>
    create: XOR<UserCreateWithoutDirectMessagesFromInput, UserUncheckedCreateWithoutDirectMessagesFromInput>
  }

  export type UserUpdateWithoutDirectMessagesFromInput = {
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followingUserRelations?: UserRelationUpdateManyWithoutFollowingUserNestedInput
    followedUserRelations?: UserRelationUpdateManyWithoutFollowedUserNestedInput
    tweets?: TweetUpdateManyWithoutTweetingUserNestedInput
    directMessagesTo?: DirectMessageUpdateManyWithoutToUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutDirectMessagesFromInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followingUserRelations?: UserRelationUncheckedUpdateManyWithoutFollowingUserNestedInput
    followedUserRelations?: UserRelationUncheckedUpdateManyWithoutFollowedUserNestedInput
    tweets?: TweetUncheckedUpdateManyWithoutTweetingUserNestedInput
    directMessagesTo?: DirectMessageUncheckedUpdateManyWithoutToUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutDirectMessagesToInput = {
    update: XOR<UserUpdateWithoutDirectMessagesToInput, UserUncheckedUpdateWithoutDirectMessagesToInput>
    create: XOR<UserCreateWithoutDirectMessagesToInput, UserUncheckedCreateWithoutDirectMessagesToInput>
  }

  export type UserUpdateWithoutDirectMessagesToInput = {
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followingUserRelations?: UserRelationUpdateManyWithoutFollowingUserNestedInput
    followedUserRelations?: UserRelationUpdateManyWithoutFollowedUserNestedInput
    tweets?: TweetUpdateManyWithoutTweetingUserNestedInput
    directMessagesFrom?: DirectMessageUpdateManyWithoutFromUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutDirectMessagesToInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followingUserRelations?: UserRelationUncheckedUpdateManyWithoutFollowingUserNestedInput
    followedUserRelations?: UserRelationUncheckedUpdateManyWithoutFollowedUserNestedInput
    tweets?: TweetUncheckedUpdateManyWithoutTweetingUserNestedInput
    directMessagesFrom?: DirectMessageUncheckedUpdateManyWithoutFromUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelCreateWithoutAdminUsersInput = {
    name: string
    profileImageUrl?: string | null
    description?: string | null
    subscribedUsers?: YouTubeUserCreateNestedManyWithoutSubscribingToChannelsInput
    usersToChannelswithRoles?: UserToChannelwithRoleCreateNestedManyWithoutChannelInput
    owningVideos?: VideoCreateNestedManyWithoutBelongsToChannelInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChannelUncheckedCreateWithoutAdminUsersInput = {
    id?: number
    name: string
    profileImageUrl?: string | null
    description?: string | null
    subscribedUsers?: YouTubeUserUncheckedCreateNestedManyWithoutSubscribingToChannelsInput
    usersToChannelswithRoles?: UserToChannelwithRoleUncheckedCreateNestedManyWithoutChannelInput
    owningVideos?: VideoUncheckedCreateNestedManyWithoutBelongsToChannelInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChannelCreateOrConnectWithoutAdminUsersInput = {
    where: ChannelWhereUniqueInput
    create: XOR<ChannelCreateWithoutAdminUsersInput, ChannelUncheckedCreateWithoutAdminUsersInput>
  }

  export type UserToChannelwithRoleCreateWithoutUserInput = {
    channel: ChannelCreateNestedOneWithoutUsersToChannelswithRolesInput
    role: RoleEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToChannelwithRoleUncheckedCreateWithoutUserInput = {
    id?: number
    channelId: number
    role: RoleEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToChannelwithRoleCreateOrConnectWithoutUserInput = {
    where: UserToChannelwithRoleWhereUniqueInput
    create: XOR<UserToChannelwithRoleCreateWithoutUserInput, UserToChannelwithRoleUncheckedCreateWithoutUserInput>
  }

  export type UserToChannelwithRoleCreateManyUserInputEnvelope = {
    data: Enumerable<UserToChannelwithRoleCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ChannelCreateWithoutSubscribedUsersInput = {
    name: string
    profileImageUrl?: string | null
    description?: string | null
    adminUsers?: YouTubeUserCreateNestedManyWithoutAdminOfChannelsInput
    usersToChannelswithRoles?: UserToChannelwithRoleCreateNestedManyWithoutChannelInput
    owningVideos?: VideoCreateNestedManyWithoutBelongsToChannelInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChannelUncheckedCreateWithoutSubscribedUsersInput = {
    id?: number
    name: string
    profileImageUrl?: string | null
    description?: string | null
    adminUsers?: YouTubeUserUncheckedCreateNestedManyWithoutAdminOfChannelsInput
    usersToChannelswithRoles?: UserToChannelwithRoleUncheckedCreateNestedManyWithoutChannelInput
    owningVideos?: VideoUncheckedCreateNestedManyWithoutBelongsToChannelInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChannelCreateOrConnectWithoutSubscribedUsersInput = {
    where: ChannelWhereUniqueInput
    create: XOR<ChannelCreateWithoutSubscribedUsersInput, ChannelUncheckedCreateWithoutSubscribedUsersInput>
  }

  export type VideoCreateWithoutReactedByYouTubeUsersInput = {
    title: string
    videoUrl: string
    thumbnailImageUrl?: string | null
    description?: string | null
    belongsToChannel: ChannelCreateNestedOneWithoutOwningVideosInput
    usersToVideosWithReactions?: UserToVideoWithReactionCreateNestedManyWithoutVideoInput
    videoComments?: VideoCommentCreateNestedManyWithoutParentVideoInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoUncheckedCreateWithoutReactedByYouTubeUsersInput = {
    id?: number
    title: string
    videoUrl: string
    thumbnailImageUrl?: string | null
    description?: string | null
    channelId: number
    usersToVideosWithReactions?: UserToVideoWithReactionUncheckedCreateNestedManyWithoutVideoInput
    videoComments?: VideoCommentUncheckedCreateNestedManyWithoutParentVideoInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCreateOrConnectWithoutReactedByYouTubeUsersInput = {
    where: VideoWhereUniqueInput
    create: XOR<VideoCreateWithoutReactedByYouTubeUsersInput, VideoUncheckedCreateWithoutReactedByYouTubeUsersInput>
  }

  export type UserToVideoWithReactionCreateWithoutUserInput = {
    video: VideoCreateNestedOneWithoutUsersToVideosWithReactionsInput
    reaction: ReactionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToVideoWithReactionUncheckedCreateWithoutUserInput = {
    id?: number
    videoId: number
    reaction: ReactionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToVideoWithReactionCreateOrConnectWithoutUserInput = {
    where: UserToVideoWithReactionWhereUniqueInput
    create: XOR<UserToVideoWithReactionCreateWithoutUserInput, UserToVideoWithReactionUncheckedCreateWithoutUserInput>
  }

  export type UserToVideoWithReactionCreateManyUserInputEnvelope = {
    data: Enumerable<UserToVideoWithReactionCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type VideoCommentCreateWithoutCommentingUserInput = {
    commentText: string
    parentVideo: VideoCreateNestedOneWithoutVideoCommentsInput
    parentVideoComment?: VideoCommentCreateNestedOneWithoutChildVideoCommentsInput
    childVideoComments?: VideoCommentCreateNestedManyWithoutParentVideoCommentInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCommentUncheckedCreateWithoutCommentingUserInput = {
    id?: number
    commentText: string
    videoId: number
    parentVideoCommentId?: number | null
    childVideoComments?: VideoCommentUncheckedCreateNestedManyWithoutParentVideoCommentInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCommentCreateOrConnectWithoutCommentingUserInput = {
    where: VideoCommentWhereUniqueInput
    create: XOR<VideoCommentCreateWithoutCommentingUserInput, VideoCommentUncheckedCreateWithoutCommentingUserInput>
  }

  export type VideoCommentCreateManyCommentingUserInputEnvelope = {
    data: Enumerable<VideoCommentCreateManyCommentingUserInput>
    skipDuplicates?: boolean
  }

  export type ChannelUpsertWithWhereUniqueWithoutAdminUsersInput = {
    where: ChannelWhereUniqueInput
    update: XOR<ChannelUpdateWithoutAdminUsersInput, ChannelUncheckedUpdateWithoutAdminUsersInput>
    create: XOR<ChannelCreateWithoutAdminUsersInput, ChannelUncheckedCreateWithoutAdminUsersInput>
  }

  export type ChannelUpdateWithWhereUniqueWithoutAdminUsersInput = {
    where: ChannelWhereUniqueInput
    data: XOR<ChannelUpdateWithoutAdminUsersInput, ChannelUncheckedUpdateWithoutAdminUsersInput>
  }

  export type ChannelUpdateManyWithWhereWithoutAdminUsersInput = {
    where: ChannelScalarWhereInput
    data: XOR<ChannelUpdateManyMutationInput, ChannelUncheckedUpdateManyWithoutAdminOfChannelsInput>
  }

  export type ChannelScalarWhereInput = {
    AND?: Enumerable<ChannelScalarWhereInput>
    OR?: Enumerable<ChannelScalarWhereInput>
    NOT?: Enumerable<ChannelScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    profileImageUrl?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type UserToChannelwithRoleUpsertWithWhereUniqueWithoutUserInput = {
    where: UserToChannelwithRoleWhereUniqueInput
    update: XOR<UserToChannelwithRoleUpdateWithoutUserInput, UserToChannelwithRoleUncheckedUpdateWithoutUserInput>
    create: XOR<UserToChannelwithRoleCreateWithoutUserInput, UserToChannelwithRoleUncheckedCreateWithoutUserInput>
  }

  export type UserToChannelwithRoleUpdateWithWhereUniqueWithoutUserInput = {
    where: UserToChannelwithRoleWhereUniqueInput
    data: XOR<UserToChannelwithRoleUpdateWithoutUserInput, UserToChannelwithRoleUncheckedUpdateWithoutUserInput>
  }

  export type UserToChannelwithRoleUpdateManyWithWhereWithoutUserInput = {
    where: UserToChannelwithRoleScalarWhereInput
    data: XOR<UserToChannelwithRoleUpdateManyMutationInput, UserToChannelwithRoleUncheckedUpdateManyWithoutUsersToChannelswithRolesInput>
  }

  export type UserToChannelwithRoleScalarWhereInput = {
    AND?: Enumerable<UserToChannelwithRoleScalarWhereInput>
    OR?: Enumerable<UserToChannelwithRoleScalarWhereInput>
    NOT?: Enumerable<UserToChannelwithRoleScalarWhereInput>
    id?: IntFilter | number
    youTubeUserId?: IntFilter | number
    channelId?: IntFilter | number
    role?: EnumRoleEnumFilter | RoleEnum
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ChannelUpsertWithWhereUniqueWithoutSubscribedUsersInput = {
    where: ChannelWhereUniqueInput
    update: XOR<ChannelUpdateWithoutSubscribedUsersInput, ChannelUncheckedUpdateWithoutSubscribedUsersInput>
    create: XOR<ChannelCreateWithoutSubscribedUsersInput, ChannelUncheckedCreateWithoutSubscribedUsersInput>
  }

  export type ChannelUpdateWithWhereUniqueWithoutSubscribedUsersInput = {
    where: ChannelWhereUniqueInput
    data: XOR<ChannelUpdateWithoutSubscribedUsersInput, ChannelUncheckedUpdateWithoutSubscribedUsersInput>
  }

  export type ChannelUpdateManyWithWhereWithoutSubscribedUsersInput = {
    where: ChannelScalarWhereInput
    data: XOR<ChannelUpdateManyMutationInput, ChannelUncheckedUpdateManyWithoutSubscribingToChannelsInput>
  }

  export type VideoUpsertWithWhereUniqueWithoutReactedByYouTubeUsersInput = {
    where: VideoWhereUniqueInput
    update: XOR<VideoUpdateWithoutReactedByYouTubeUsersInput, VideoUncheckedUpdateWithoutReactedByYouTubeUsersInput>
    create: XOR<VideoCreateWithoutReactedByYouTubeUsersInput, VideoUncheckedCreateWithoutReactedByYouTubeUsersInput>
  }

  export type VideoUpdateWithWhereUniqueWithoutReactedByYouTubeUsersInput = {
    where: VideoWhereUniqueInput
    data: XOR<VideoUpdateWithoutReactedByYouTubeUsersInput, VideoUncheckedUpdateWithoutReactedByYouTubeUsersInput>
  }

  export type VideoUpdateManyWithWhereWithoutReactedByYouTubeUsersInput = {
    where: VideoScalarWhereInput
    data: XOR<VideoUpdateManyMutationInput, VideoUncheckedUpdateManyWithoutReactedVideosInput>
  }

  export type VideoScalarWhereInput = {
    AND?: Enumerable<VideoScalarWhereInput>
    OR?: Enumerable<VideoScalarWhereInput>
    NOT?: Enumerable<VideoScalarWhereInput>
    id?: IntFilter | number
    title?: StringFilter | string
    videoUrl?: StringFilter | string
    thumbnailImageUrl?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    channelId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type UserToVideoWithReactionUpsertWithWhereUniqueWithoutUserInput = {
    where: UserToVideoWithReactionWhereUniqueInput
    update: XOR<UserToVideoWithReactionUpdateWithoutUserInput, UserToVideoWithReactionUncheckedUpdateWithoutUserInput>
    create: XOR<UserToVideoWithReactionCreateWithoutUserInput, UserToVideoWithReactionUncheckedCreateWithoutUserInput>
  }

  export type UserToVideoWithReactionUpdateWithWhereUniqueWithoutUserInput = {
    where: UserToVideoWithReactionWhereUniqueInput
    data: XOR<UserToVideoWithReactionUpdateWithoutUserInput, UserToVideoWithReactionUncheckedUpdateWithoutUserInput>
  }

  export type UserToVideoWithReactionUpdateManyWithWhereWithoutUserInput = {
    where: UserToVideoWithReactionScalarWhereInput
    data: XOR<UserToVideoWithReactionUpdateManyMutationInput, UserToVideoWithReactionUncheckedUpdateManyWithoutUsersToVideosWithReactionsInput>
  }

  export type UserToVideoWithReactionScalarWhereInput = {
    AND?: Enumerable<UserToVideoWithReactionScalarWhereInput>
    OR?: Enumerable<UserToVideoWithReactionScalarWhereInput>
    NOT?: Enumerable<UserToVideoWithReactionScalarWhereInput>
    id?: IntFilter | number
    youTubeUserId?: IntFilter | number
    videoId?: IntFilter | number
    reaction?: EnumReactionEnumFilter | ReactionEnum
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type VideoCommentUpsertWithWhereUniqueWithoutCommentingUserInput = {
    where: VideoCommentWhereUniqueInput
    update: XOR<VideoCommentUpdateWithoutCommentingUserInput, VideoCommentUncheckedUpdateWithoutCommentingUserInput>
    create: XOR<VideoCommentCreateWithoutCommentingUserInput, VideoCommentUncheckedCreateWithoutCommentingUserInput>
  }

  export type VideoCommentUpdateWithWhereUniqueWithoutCommentingUserInput = {
    where: VideoCommentWhereUniqueInput
    data: XOR<VideoCommentUpdateWithoutCommentingUserInput, VideoCommentUncheckedUpdateWithoutCommentingUserInput>
  }

  export type VideoCommentUpdateManyWithWhereWithoutCommentingUserInput = {
    where: VideoCommentScalarWhereInput
    data: XOR<VideoCommentUpdateManyMutationInput, VideoCommentUncheckedUpdateManyWithoutVideoCommentsInput>
  }

  export type VideoCommentScalarWhereInput = {
    AND?: Enumerable<VideoCommentScalarWhereInput>
    OR?: Enumerable<VideoCommentScalarWhereInput>
    NOT?: Enumerable<VideoCommentScalarWhereInput>
    id?: IntFilter | number
    commentText?: StringFilter | string
    youTubeUserId?: IntFilter | number
    videoId?: IntFilter | number
    parentVideoCommentId?: IntNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type YouTubeUserCreateWithoutAdminOfChannelsInput = {
    name: string
    profileImageUrl?: string | null
    bio?: string | null
    usersToChannelswithRoles?: UserToChannelwithRoleCreateNestedManyWithoutUserInput
    subscribingToChannels?: ChannelCreateNestedManyWithoutSubscribedUsersInput
    reactedVideos?: VideoCreateNestedManyWithoutReactedByYouTubeUsersInput
    usersToVideosWithReactions?: UserToVideoWithReactionCreateNestedManyWithoutUserInput
    videoComments?: VideoCommentCreateNestedManyWithoutCommentingUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YouTubeUserUncheckedCreateWithoutAdminOfChannelsInput = {
    id?: number
    name: string
    profileImageUrl?: string | null
    bio?: string | null
    usersToChannelswithRoles?: UserToChannelwithRoleUncheckedCreateNestedManyWithoutUserInput
    subscribingToChannels?: ChannelUncheckedCreateNestedManyWithoutSubscribedUsersInput
    reactedVideos?: VideoUncheckedCreateNestedManyWithoutReactedByYouTubeUsersInput
    usersToVideosWithReactions?: UserToVideoWithReactionUncheckedCreateNestedManyWithoutUserInput
    videoComments?: VideoCommentUncheckedCreateNestedManyWithoutCommentingUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YouTubeUserCreateOrConnectWithoutAdminOfChannelsInput = {
    where: YouTubeUserWhereUniqueInput
    create: XOR<YouTubeUserCreateWithoutAdminOfChannelsInput, YouTubeUserUncheckedCreateWithoutAdminOfChannelsInput>
  }

  export type YouTubeUserCreateWithoutSubscribingToChannelsInput = {
    name: string
    profileImageUrl?: string | null
    bio?: string | null
    adminOfChannels?: ChannelCreateNestedManyWithoutAdminUsersInput
    usersToChannelswithRoles?: UserToChannelwithRoleCreateNestedManyWithoutUserInput
    reactedVideos?: VideoCreateNestedManyWithoutReactedByYouTubeUsersInput
    usersToVideosWithReactions?: UserToVideoWithReactionCreateNestedManyWithoutUserInput
    videoComments?: VideoCommentCreateNestedManyWithoutCommentingUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YouTubeUserUncheckedCreateWithoutSubscribingToChannelsInput = {
    id?: number
    name: string
    profileImageUrl?: string | null
    bio?: string | null
    adminOfChannels?: ChannelUncheckedCreateNestedManyWithoutAdminUsersInput
    usersToChannelswithRoles?: UserToChannelwithRoleUncheckedCreateNestedManyWithoutUserInput
    reactedVideos?: VideoUncheckedCreateNestedManyWithoutReactedByYouTubeUsersInput
    usersToVideosWithReactions?: UserToVideoWithReactionUncheckedCreateNestedManyWithoutUserInput
    videoComments?: VideoCommentUncheckedCreateNestedManyWithoutCommentingUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YouTubeUserCreateOrConnectWithoutSubscribingToChannelsInput = {
    where: YouTubeUserWhereUniqueInput
    create: XOR<YouTubeUserCreateWithoutSubscribingToChannelsInput, YouTubeUserUncheckedCreateWithoutSubscribingToChannelsInput>
  }

  export type UserToChannelwithRoleCreateWithoutChannelInput = {
    user: YouTubeUserCreateNestedOneWithoutUsersToChannelswithRolesInput
    role: RoleEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToChannelwithRoleUncheckedCreateWithoutChannelInput = {
    id?: number
    youTubeUserId: number
    role: RoleEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToChannelwithRoleCreateOrConnectWithoutChannelInput = {
    where: UserToChannelwithRoleWhereUniqueInput
    create: XOR<UserToChannelwithRoleCreateWithoutChannelInput, UserToChannelwithRoleUncheckedCreateWithoutChannelInput>
  }

  export type UserToChannelwithRoleCreateManyChannelInputEnvelope = {
    data: Enumerable<UserToChannelwithRoleCreateManyChannelInput>
    skipDuplicates?: boolean
  }

  export type VideoCreateWithoutBelongsToChannelInput = {
    title: string
    videoUrl: string
    thumbnailImageUrl?: string | null
    description?: string | null
    reactedByYouTubeUsers?: YouTubeUserCreateNestedManyWithoutReactedVideosInput
    usersToVideosWithReactions?: UserToVideoWithReactionCreateNestedManyWithoutVideoInput
    videoComments?: VideoCommentCreateNestedManyWithoutParentVideoInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoUncheckedCreateWithoutBelongsToChannelInput = {
    id?: number
    title: string
    videoUrl: string
    thumbnailImageUrl?: string | null
    description?: string | null
    reactedByYouTubeUsers?: YouTubeUserUncheckedCreateNestedManyWithoutReactedVideosInput
    usersToVideosWithReactions?: UserToVideoWithReactionUncheckedCreateNestedManyWithoutVideoInput
    videoComments?: VideoCommentUncheckedCreateNestedManyWithoutParentVideoInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCreateOrConnectWithoutBelongsToChannelInput = {
    where: VideoWhereUniqueInput
    create: XOR<VideoCreateWithoutBelongsToChannelInput, VideoUncheckedCreateWithoutBelongsToChannelInput>
  }

  export type VideoCreateManyBelongsToChannelInputEnvelope = {
    data: Enumerable<VideoCreateManyBelongsToChannelInput>
    skipDuplicates?: boolean
  }

  export type YouTubeUserUpsertWithWhereUniqueWithoutAdminOfChannelsInput = {
    where: YouTubeUserWhereUniqueInput
    update: XOR<YouTubeUserUpdateWithoutAdminOfChannelsInput, YouTubeUserUncheckedUpdateWithoutAdminOfChannelsInput>
    create: XOR<YouTubeUserCreateWithoutAdminOfChannelsInput, YouTubeUserUncheckedCreateWithoutAdminOfChannelsInput>
  }

  export type YouTubeUserUpdateWithWhereUniqueWithoutAdminOfChannelsInput = {
    where: YouTubeUserWhereUniqueInput
    data: XOR<YouTubeUserUpdateWithoutAdminOfChannelsInput, YouTubeUserUncheckedUpdateWithoutAdminOfChannelsInput>
  }

  export type YouTubeUserUpdateManyWithWhereWithoutAdminOfChannelsInput = {
    where: YouTubeUserScalarWhereInput
    data: XOR<YouTubeUserUpdateManyMutationInput, YouTubeUserUncheckedUpdateManyWithoutAdminUsersInput>
  }

  export type YouTubeUserScalarWhereInput = {
    AND?: Enumerable<YouTubeUserScalarWhereInput>
    OR?: Enumerable<YouTubeUserScalarWhereInput>
    NOT?: Enumerable<YouTubeUserScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    profileImageUrl?: StringNullableFilter | string | null
    bio?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type YouTubeUserUpsertWithWhereUniqueWithoutSubscribingToChannelsInput = {
    where: YouTubeUserWhereUniqueInput
    update: XOR<YouTubeUserUpdateWithoutSubscribingToChannelsInput, YouTubeUserUncheckedUpdateWithoutSubscribingToChannelsInput>
    create: XOR<YouTubeUserCreateWithoutSubscribingToChannelsInput, YouTubeUserUncheckedCreateWithoutSubscribingToChannelsInput>
  }

  export type YouTubeUserUpdateWithWhereUniqueWithoutSubscribingToChannelsInput = {
    where: YouTubeUserWhereUniqueInput
    data: XOR<YouTubeUserUpdateWithoutSubscribingToChannelsInput, YouTubeUserUncheckedUpdateWithoutSubscribingToChannelsInput>
  }

  export type YouTubeUserUpdateManyWithWhereWithoutSubscribingToChannelsInput = {
    where: YouTubeUserScalarWhereInput
    data: XOR<YouTubeUserUpdateManyMutationInput, YouTubeUserUncheckedUpdateManyWithoutSubscribedUsersInput>
  }

  export type UserToChannelwithRoleUpsertWithWhereUniqueWithoutChannelInput = {
    where: UserToChannelwithRoleWhereUniqueInput
    update: XOR<UserToChannelwithRoleUpdateWithoutChannelInput, UserToChannelwithRoleUncheckedUpdateWithoutChannelInput>
    create: XOR<UserToChannelwithRoleCreateWithoutChannelInput, UserToChannelwithRoleUncheckedCreateWithoutChannelInput>
  }

  export type UserToChannelwithRoleUpdateWithWhereUniqueWithoutChannelInput = {
    where: UserToChannelwithRoleWhereUniqueInput
    data: XOR<UserToChannelwithRoleUpdateWithoutChannelInput, UserToChannelwithRoleUncheckedUpdateWithoutChannelInput>
  }

  export type UserToChannelwithRoleUpdateManyWithWhereWithoutChannelInput = {
    where: UserToChannelwithRoleScalarWhereInput
    data: XOR<UserToChannelwithRoleUpdateManyMutationInput, UserToChannelwithRoleUncheckedUpdateManyWithoutUsersToChannelswithRolesInput>
  }

  export type VideoUpsertWithWhereUniqueWithoutBelongsToChannelInput = {
    where: VideoWhereUniqueInput
    update: XOR<VideoUpdateWithoutBelongsToChannelInput, VideoUncheckedUpdateWithoutBelongsToChannelInput>
    create: XOR<VideoCreateWithoutBelongsToChannelInput, VideoUncheckedCreateWithoutBelongsToChannelInput>
  }

  export type VideoUpdateWithWhereUniqueWithoutBelongsToChannelInput = {
    where: VideoWhereUniqueInput
    data: XOR<VideoUpdateWithoutBelongsToChannelInput, VideoUncheckedUpdateWithoutBelongsToChannelInput>
  }

  export type VideoUpdateManyWithWhereWithoutBelongsToChannelInput = {
    where: VideoScalarWhereInput
    data: XOR<VideoUpdateManyMutationInput, VideoUncheckedUpdateManyWithoutOwningVideosInput>
  }

  export type YouTubeUserCreateWithoutUsersToChannelswithRolesInput = {
    name: string
    profileImageUrl?: string | null
    bio?: string | null
    adminOfChannels?: ChannelCreateNestedManyWithoutAdminUsersInput
    subscribingToChannels?: ChannelCreateNestedManyWithoutSubscribedUsersInput
    reactedVideos?: VideoCreateNestedManyWithoutReactedByYouTubeUsersInput
    usersToVideosWithReactions?: UserToVideoWithReactionCreateNestedManyWithoutUserInput
    videoComments?: VideoCommentCreateNestedManyWithoutCommentingUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YouTubeUserUncheckedCreateWithoutUsersToChannelswithRolesInput = {
    id?: number
    name: string
    profileImageUrl?: string | null
    bio?: string | null
    adminOfChannels?: ChannelUncheckedCreateNestedManyWithoutAdminUsersInput
    subscribingToChannels?: ChannelUncheckedCreateNestedManyWithoutSubscribedUsersInput
    reactedVideos?: VideoUncheckedCreateNestedManyWithoutReactedByYouTubeUsersInput
    usersToVideosWithReactions?: UserToVideoWithReactionUncheckedCreateNestedManyWithoutUserInput
    videoComments?: VideoCommentUncheckedCreateNestedManyWithoutCommentingUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YouTubeUserCreateOrConnectWithoutUsersToChannelswithRolesInput = {
    where: YouTubeUserWhereUniqueInput
    create: XOR<YouTubeUserCreateWithoutUsersToChannelswithRolesInput, YouTubeUserUncheckedCreateWithoutUsersToChannelswithRolesInput>
  }

  export type ChannelCreateWithoutUsersToChannelswithRolesInput = {
    name: string
    profileImageUrl?: string | null
    description?: string | null
    adminUsers?: YouTubeUserCreateNestedManyWithoutAdminOfChannelsInput
    subscribedUsers?: YouTubeUserCreateNestedManyWithoutSubscribingToChannelsInput
    owningVideos?: VideoCreateNestedManyWithoutBelongsToChannelInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChannelUncheckedCreateWithoutUsersToChannelswithRolesInput = {
    id?: number
    name: string
    profileImageUrl?: string | null
    description?: string | null
    adminUsers?: YouTubeUserUncheckedCreateNestedManyWithoutAdminOfChannelsInput
    subscribedUsers?: YouTubeUserUncheckedCreateNestedManyWithoutSubscribingToChannelsInput
    owningVideos?: VideoUncheckedCreateNestedManyWithoutBelongsToChannelInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChannelCreateOrConnectWithoutUsersToChannelswithRolesInput = {
    where: ChannelWhereUniqueInput
    create: XOR<ChannelCreateWithoutUsersToChannelswithRolesInput, ChannelUncheckedCreateWithoutUsersToChannelswithRolesInput>
  }

  export type YouTubeUserUpsertWithoutUsersToChannelswithRolesInput = {
    update: XOR<YouTubeUserUpdateWithoutUsersToChannelswithRolesInput, YouTubeUserUncheckedUpdateWithoutUsersToChannelswithRolesInput>
    create: XOR<YouTubeUserCreateWithoutUsersToChannelswithRolesInput, YouTubeUserUncheckedCreateWithoutUsersToChannelswithRolesInput>
  }

  export type YouTubeUserUpdateWithoutUsersToChannelswithRolesInput = {
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    adminOfChannels?: ChannelUpdateManyWithoutAdminUsersNestedInput
    subscribingToChannels?: ChannelUpdateManyWithoutSubscribedUsersNestedInput
    reactedVideos?: VideoUpdateManyWithoutReactedByYouTubeUsersNestedInput
    usersToVideosWithReactions?: UserToVideoWithReactionUpdateManyWithoutUserNestedInput
    videoComments?: VideoCommentUpdateManyWithoutCommentingUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YouTubeUserUncheckedUpdateWithoutUsersToChannelswithRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    adminOfChannels?: ChannelUncheckedUpdateManyWithoutAdminUsersNestedInput
    subscribingToChannels?: ChannelUncheckedUpdateManyWithoutSubscribedUsersNestedInput
    reactedVideos?: VideoUncheckedUpdateManyWithoutReactedByYouTubeUsersNestedInput
    usersToVideosWithReactions?: UserToVideoWithReactionUncheckedUpdateManyWithoutUserNestedInput
    videoComments?: VideoCommentUncheckedUpdateManyWithoutCommentingUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelUpsertWithoutUsersToChannelswithRolesInput = {
    update: XOR<ChannelUpdateWithoutUsersToChannelswithRolesInput, ChannelUncheckedUpdateWithoutUsersToChannelswithRolesInput>
    create: XOR<ChannelCreateWithoutUsersToChannelswithRolesInput, ChannelUncheckedCreateWithoutUsersToChannelswithRolesInput>
  }

  export type ChannelUpdateWithoutUsersToChannelswithRolesInput = {
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adminUsers?: YouTubeUserUpdateManyWithoutAdminOfChannelsNestedInput
    subscribedUsers?: YouTubeUserUpdateManyWithoutSubscribingToChannelsNestedInput
    owningVideos?: VideoUpdateManyWithoutBelongsToChannelNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelUncheckedUpdateWithoutUsersToChannelswithRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adminUsers?: YouTubeUserUncheckedUpdateManyWithoutAdminOfChannelsNestedInput
    subscribedUsers?: YouTubeUserUncheckedUpdateManyWithoutSubscribingToChannelsNestedInput
    owningVideos?: VideoUncheckedUpdateManyWithoutBelongsToChannelNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelCreateWithoutOwningVideosInput = {
    name: string
    profileImageUrl?: string | null
    description?: string | null
    adminUsers?: YouTubeUserCreateNestedManyWithoutAdminOfChannelsInput
    subscribedUsers?: YouTubeUserCreateNestedManyWithoutSubscribingToChannelsInput
    usersToChannelswithRoles?: UserToChannelwithRoleCreateNestedManyWithoutChannelInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChannelUncheckedCreateWithoutOwningVideosInput = {
    id?: number
    name: string
    profileImageUrl?: string | null
    description?: string | null
    adminUsers?: YouTubeUserUncheckedCreateNestedManyWithoutAdminOfChannelsInput
    subscribedUsers?: YouTubeUserUncheckedCreateNestedManyWithoutSubscribingToChannelsInput
    usersToChannelswithRoles?: UserToChannelwithRoleUncheckedCreateNestedManyWithoutChannelInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChannelCreateOrConnectWithoutOwningVideosInput = {
    where: ChannelWhereUniqueInput
    create: XOR<ChannelCreateWithoutOwningVideosInput, ChannelUncheckedCreateWithoutOwningVideosInput>
  }

  export type YouTubeUserCreateWithoutReactedVideosInput = {
    name: string
    profileImageUrl?: string | null
    bio?: string | null
    adminOfChannels?: ChannelCreateNestedManyWithoutAdminUsersInput
    usersToChannelswithRoles?: UserToChannelwithRoleCreateNestedManyWithoutUserInput
    subscribingToChannels?: ChannelCreateNestedManyWithoutSubscribedUsersInput
    usersToVideosWithReactions?: UserToVideoWithReactionCreateNestedManyWithoutUserInput
    videoComments?: VideoCommentCreateNestedManyWithoutCommentingUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YouTubeUserUncheckedCreateWithoutReactedVideosInput = {
    id?: number
    name: string
    profileImageUrl?: string | null
    bio?: string | null
    adminOfChannels?: ChannelUncheckedCreateNestedManyWithoutAdminUsersInput
    usersToChannelswithRoles?: UserToChannelwithRoleUncheckedCreateNestedManyWithoutUserInput
    subscribingToChannels?: ChannelUncheckedCreateNestedManyWithoutSubscribedUsersInput
    usersToVideosWithReactions?: UserToVideoWithReactionUncheckedCreateNestedManyWithoutUserInput
    videoComments?: VideoCommentUncheckedCreateNestedManyWithoutCommentingUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YouTubeUserCreateOrConnectWithoutReactedVideosInput = {
    where: YouTubeUserWhereUniqueInput
    create: XOR<YouTubeUserCreateWithoutReactedVideosInput, YouTubeUserUncheckedCreateWithoutReactedVideosInput>
  }

  export type UserToVideoWithReactionCreateWithoutVideoInput = {
    user: YouTubeUserCreateNestedOneWithoutUsersToVideosWithReactionsInput
    reaction: ReactionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToVideoWithReactionUncheckedCreateWithoutVideoInput = {
    id?: number
    youTubeUserId: number
    reaction: ReactionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToVideoWithReactionCreateOrConnectWithoutVideoInput = {
    where: UserToVideoWithReactionWhereUniqueInput
    create: XOR<UserToVideoWithReactionCreateWithoutVideoInput, UserToVideoWithReactionUncheckedCreateWithoutVideoInput>
  }

  export type UserToVideoWithReactionCreateManyVideoInputEnvelope = {
    data: Enumerable<UserToVideoWithReactionCreateManyVideoInput>
    skipDuplicates?: boolean
  }

  export type VideoCommentCreateWithoutParentVideoInput = {
    commentText: string
    commentingUser: YouTubeUserCreateNestedOneWithoutVideoCommentsInput
    parentVideoComment?: VideoCommentCreateNestedOneWithoutChildVideoCommentsInput
    childVideoComments?: VideoCommentCreateNestedManyWithoutParentVideoCommentInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCommentUncheckedCreateWithoutParentVideoInput = {
    id?: number
    commentText: string
    youTubeUserId: number
    parentVideoCommentId?: number | null
    childVideoComments?: VideoCommentUncheckedCreateNestedManyWithoutParentVideoCommentInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCommentCreateOrConnectWithoutParentVideoInput = {
    where: VideoCommentWhereUniqueInput
    create: XOR<VideoCommentCreateWithoutParentVideoInput, VideoCommentUncheckedCreateWithoutParentVideoInput>
  }

  export type VideoCommentCreateManyParentVideoInputEnvelope = {
    data: Enumerable<VideoCommentCreateManyParentVideoInput>
    skipDuplicates?: boolean
  }

  export type ChannelUpsertWithoutOwningVideosInput = {
    update: XOR<ChannelUpdateWithoutOwningVideosInput, ChannelUncheckedUpdateWithoutOwningVideosInput>
    create: XOR<ChannelCreateWithoutOwningVideosInput, ChannelUncheckedCreateWithoutOwningVideosInput>
  }

  export type ChannelUpdateWithoutOwningVideosInput = {
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adminUsers?: YouTubeUserUpdateManyWithoutAdminOfChannelsNestedInput
    subscribedUsers?: YouTubeUserUpdateManyWithoutSubscribingToChannelsNestedInput
    usersToChannelswithRoles?: UserToChannelwithRoleUpdateManyWithoutChannelNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelUncheckedUpdateWithoutOwningVideosInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adminUsers?: YouTubeUserUncheckedUpdateManyWithoutAdminOfChannelsNestedInput
    subscribedUsers?: YouTubeUserUncheckedUpdateManyWithoutSubscribingToChannelsNestedInput
    usersToChannelswithRoles?: UserToChannelwithRoleUncheckedUpdateManyWithoutChannelNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YouTubeUserUpsertWithWhereUniqueWithoutReactedVideosInput = {
    where: YouTubeUserWhereUniqueInput
    update: XOR<YouTubeUserUpdateWithoutReactedVideosInput, YouTubeUserUncheckedUpdateWithoutReactedVideosInput>
    create: XOR<YouTubeUserCreateWithoutReactedVideosInput, YouTubeUserUncheckedCreateWithoutReactedVideosInput>
  }

  export type YouTubeUserUpdateWithWhereUniqueWithoutReactedVideosInput = {
    where: YouTubeUserWhereUniqueInput
    data: XOR<YouTubeUserUpdateWithoutReactedVideosInput, YouTubeUserUncheckedUpdateWithoutReactedVideosInput>
  }

  export type YouTubeUserUpdateManyWithWhereWithoutReactedVideosInput = {
    where: YouTubeUserScalarWhereInput
    data: XOR<YouTubeUserUpdateManyMutationInput, YouTubeUserUncheckedUpdateManyWithoutReactedByYouTubeUsersInput>
  }

  export type UserToVideoWithReactionUpsertWithWhereUniqueWithoutVideoInput = {
    where: UserToVideoWithReactionWhereUniqueInput
    update: XOR<UserToVideoWithReactionUpdateWithoutVideoInput, UserToVideoWithReactionUncheckedUpdateWithoutVideoInput>
    create: XOR<UserToVideoWithReactionCreateWithoutVideoInput, UserToVideoWithReactionUncheckedCreateWithoutVideoInput>
  }

  export type UserToVideoWithReactionUpdateWithWhereUniqueWithoutVideoInput = {
    where: UserToVideoWithReactionWhereUniqueInput
    data: XOR<UserToVideoWithReactionUpdateWithoutVideoInput, UserToVideoWithReactionUncheckedUpdateWithoutVideoInput>
  }

  export type UserToVideoWithReactionUpdateManyWithWhereWithoutVideoInput = {
    where: UserToVideoWithReactionScalarWhereInput
    data: XOR<UserToVideoWithReactionUpdateManyMutationInput, UserToVideoWithReactionUncheckedUpdateManyWithoutUsersToVideosWithReactionsInput>
  }

  export type VideoCommentUpsertWithWhereUniqueWithoutParentVideoInput = {
    where: VideoCommentWhereUniqueInput
    update: XOR<VideoCommentUpdateWithoutParentVideoInput, VideoCommentUncheckedUpdateWithoutParentVideoInput>
    create: XOR<VideoCommentCreateWithoutParentVideoInput, VideoCommentUncheckedCreateWithoutParentVideoInput>
  }

  export type VideoCommentUpdateWithWhereUniqueWithoutParentVideoInput = {
    where: VideoCommentWhereUniqueInput
    data: XOR<VideoCommentUpdateWithoutParentVideoInput, VideoCommentUncheckedUpdateWithoutParentVideoInput>
  }

  export type VideoCommentUpdateManyWithWhereWithoutParentVideoInput = {
    where: VideoCommentScalarWhereInput
    data: XOR<VideoCommentUpdateManyMutationInput, VideoCommentUncheckedUpdateManyWithoutVideoCommentsInput>
  }

  export type YouTubeUserCreateWithoutUsersToVideosWithReactionsInput = {
    name: string
    profileImageUrl?: string | null
    bio?: string | null
    adminOfChannels?: ChannelCreateNestedManyWithoutAdminUsersInput
    usersToChannelswithRoles?: UserToChannelwithRoleCreateNestedManyWithoutUserInput
    subscribingToChannels?: ChannelCreateNestedManyWithoutSubscribedUsersInput
    reactedVideos?: VideoCreateNestedManyWithoutReactedByYouTubeUsersInput
    videoComments?: VideoCommentCreateNestedManyWithoutCommentingUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YouTubeUserUncheckedCreateWithoutUsersToVideosWithReactionsInput = {
    id?: number
    name: string
    profileImageUrl?: string | null
    bio?: string | null
    adminOfChannels?: ChannelUncheckedCreateNestedManyWithoutAdminUsersInput
    usersToChannelswithRoles?: UserToChannelwithRoleUncheckedCreateNestedManyWithoutUserInput
    subscribingToChannels?: ChannelUncheckedCreateNestedManyWithoutSubscribedUsersInput
    reactedVideos?: VideoUncheckedCreateNestedManyWithoutReactedByYouTubeUsersInput
    videoComments?: VideoCommentUncheckedCreateNestedManyWithoutCommentingUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YouTubeUserCreateOrConnectWithoutUsersToVideosWithReactionsInput = {
    where: YouTubeUserWhereUniqueInput
    create: XOR<YouTubeUserCreateWithoutUsersToVideosWithReactionsInput, YouTubeUserUncheckedCreateWithoutUsersToVideosWithReactionsInput>
  }

  export type VideoCreateWithoutUsersToVideosWithReactionsInput = {
    title: string
    videoUrl: string
    thumbnailImageUrl?: string | null
    description?: string | null
    belongsToChannel: ChannelCreateNestedOneWithoutOwningVideosInput
    reactedByYouTubeUsers?: YouTubeUserCreateNestedManyWithoutReactedVideosInput
    videoComments?: VideoCommentCreateNestedManyWithoutParentVideoInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoUncheckedCreateWithoutUsersToVideosWithReactionsInput = {
    id?: number
    title: string
    videoUrl: string
    thumbnailImageUrl?: string | null
    description?: string | null
    channelId: number
    reactedByYouTubeUsers?: YouTubeUserUncheckedCreateNestedManyWithoutReactedVideosInput
    videoComments?: VideoCommentUncheckedCreateNestedManyWithoutParentVideoInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCreateOrConnectWithoutUsersToVideosWithReactionsInput = {
    where: VideoWhereUniqueInput
    create: XOR<VideoCreateWithoutUsersToVideosWithReactionsInput, VideoUncheckedCreateWithoutUsersToVideosWithReactionsInput>
  }

  export type YouTubeUserUpsertWithoutUsersToVideosWithReactionsInput = {
    update: XOR<YouTubeUserUpdateWithoutUsersToVideosWithReactionsInput, YouTubeUserUncheckedUpdateWithoutUsersToVideosWithReactionsInput>
    create: XOR<YouTubeUserCreateWithoutUsersToVideosWithReactionsInput, YouTubeUserUncheckedCreateWithoutUsersToVideosWithReactionsInput>
  }

  export type YouTubeUserUpdateWithoutUsersToVideosWithReactionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    adminOfChannels?: ChannelUpdateManyWithoutAdminUsersNestedInput
    usersToChannelswithRoles?: UserToChannelwithRoleUpdateManyWithoutUserNestedInput
    subscribingToChannels?: ChannelUpdateManyWithoutSubscribedUsersNestedInput
    reactedVideos?: VideoUpdateManyWithoutReactedByYouTubeUsersNestedInput
    videoComments?: VideoCommentUpdateManyWithoutCommentingUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YouTubeUserUncheckedUpdateWithoutUsersToVideosWithReactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    adminOfChannels?: ChannelUncheckedUpdateManyWithoutAdminUsersNestedInput
    usersToChannelswithRoles?: UserToChannelwithRoleUncheckedUpdateManyWithoutUserNestedInput
    subscribingToChannels?: ChannelUncheckedUpdateManyWithoutSubscribedUsersNestedInput
    reactedVideos?: VideoUncheckedUpdateManyWithoutReactedByYouTubeUsersNestedInput
    videoComments?: VideoCommentUncheckedUpdateManyWithoutCommentingUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUpsertWithoutUsersToVideosWithReactionsInput = {
    update: XOR<VideoUpdateWithoutUsersToVideosWithReactionsInput, VideoUncheckedUpdateWithoutUsersToVideosWithReactionsInput>
    create: XOR<VideoCreateWithoutUsersToVideosWithReactionsInput, VideoUncheckedCreateWithoutUsersToVideosWithReactionsInput>
  }

  export type VideoUpdateWithoutUsersToVideosWithReactionsInput = {
    title?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    belongsToChannel?: ChannelUpdateOneRequiredWithoutOwningVideosNestedInput
    reactedByYouTubeUsers?: YouTubeUserUpdateManyWithoutReactedVideosNestedInput
    videoComments?: VideoCommentUpdateManyWithoutParentVideoNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUncheckedUpdateWithoutUsersToVideosWithReactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: IntFieldUpdateOperationsInput | number
    reactedByYouTubeUsers?: YouTubeUserUncheckedUpdateManyWithoutReactedVideosNestedInput
    videoComments?: VideoCommentUncheckedUpdateManyWithoutParentVideoNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YouTubeUserCreateWithoutVideoCommentsInput = {
    name: string
    profileImageUrl?: string | null
    bio?: string | null
    adminOfChannels?: ChannelCreateNestedManyWithoutAdminUsersInput
    usersToChannelswithRoles?: UserToChannelwithRoleCreateNestedManyWithoutUserInput
    subscribingToChannels?: ChannelCreateNestedManyWithoutSubscribedUsersInput
    reactedVideos?: VideoCreateNestedManyWithoutReactedByYouTubeUsersInput
    usersToVideosWithReactions?: UserToVideoWithReactionCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YouTubeUserUncheckedCreateWithoutVideoCommentsInput = {
    id?: number
    name: string
    profileImageUrl?: string | null
    bio?: string | null
    adminOfChannels?: ChannelUncheckedCreateNestedManyWithoutAdminUsersInput
    usersToChannelswithRoles?: UserToChannelwithRoleUncheckedCreateNestedManyWithoutUserInput
    subscribingToChannels?: ChannelUncheckedCreateNestedManyWithoutSubscribedUsersInput
    reactedVideos?: VideoUncheckedCreateNestedManyWithoutReactedByYouTubeUsersInput
    usersToVideosWithReactions?: UserToVideoWithReactionUncheckedCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YouTubeUserCreateOrConnectWithoutVideoCommentsInput = {
    where: YouTubeUserWhereUniqueInput
    create: XOR<YouTubeUserCreateWithoutVideoCommentsInput, YouTubeUserUncheckedCreateWithoutVideoCommentsInput>
  }

  export type VideoCreateWithoutVideoCommentsInput = {
    title: string
    videoUrl: string
    thumbnailImageUrl?: string | null
    description?: string | null
    belongsToChannel: ChannelCreateNestedOneWithoutOwningVideosInput
    reactedByYouTubeUsers?: YouTubeUserCreateNestedManyWithoutReactedVideosInput
    usersToVideosWithReactions?: UserToVideoWithReactionCreateNestedManyWithoutVideoInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoUncheckedCreateWithoutVideoCommentsInput = {
    id?: number
    title: string
    videoUrl: string
    thumbnailImageUrl?: string | null
    description?: string | null
    channelId: number
    reactedByYouTubeUsers?: YouTubeUserUncheckedCreateNestedManyWithoutReactedVideosInput
    usersToVideosWithReactions?: UserToVideoWithReactionUncheckedCreateNestedManyWithoutVideoInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCreateOrConnectWithoutVideoCommentsInput = {
    where: VideoWhereUniqueInput
    create: XOR<VideoCreateWithoutVideoCommentsInput, VideoUncheckedCreateWithoutVideoCommentsInput>
  }

  export type VideoCommentCreateWithoutChildVideoCommentsInput = {
    commentText: string
    commentingUser: YouTubeUserCreateNestedOneWithoutVideoCommentsInput
    parentVideo: VideoCreateNestedOneWithoutVideoCommentsInput
    parentVideoComment?: VideoCommentCreateNestedOneWithoutChildVideoCommentsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCommentUncheckedCreateWithoutChildVideoCommentsInput = {
    id?: number
    commentText: string
    youTubeUserId: number
    videoId: number
    parentVideoCommentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCommentCreateOrConnectWithoutChildVideoCommentsInput = {
    where: VideoCommentWhereUniqueInput
    create: XOR<VideoCommentCreateWithoutChildVideoCommentsInput, VideoCommentUncheckedCreateWithoutChildVideoCommentsInput>
  }

  export type VideoCommentCreateWithoutParentVideoCommentInput = {
    commentText: string
    commentingUser: YouTubeUserCreateNestedOneWithoutVideoCommentsInput
    parentVideo: VideoCreateNestedOneWithoutVideoCommentsInput
    childVideoComments?: VideoCommentCreateNestedManyWithoutParentVideoCommentInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCommentUncheckedCreateWithoutParentVideoCommentInput = {
    id?: number
    commentText: string
    youTubeUserId: number
    videoId: number
    childVideoComments?: VideoCommentUncheckedCreateNestedManyWithoutParentVideoCommentInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCommentCreateOrConnectWithoutParentVideoCommentInput = {
    where: VideoCommentWhereUniqueInput
    create: XOR<VideoCommentCreateWithoutParentVideoCommentInput, VideoCommentUncheckedCreateWithoutParentVideoCommentInput>
  }

  export type VideoCommentCreateManyParentVideoCommentInputEnvelope = {
    data: Enumerable<VideoCommentCreateManyParentVideoCommentInput>
    skipDuplicates?: boolean
  }

  export type YouTubeUserUpsertWithoutVideoCommentsInput = {
    update: XOR<YouTubeUserUpdateWithoutVideoCommentsInput, YouTubeUserUncheckedUpdateWithoutVideoCommentsInput>
    create: XOR<YouTubeUserCreateWithoutVideoCommentsInput, YouTubeUserUncheckedCreateWithoutVideoCommentsInput>
  }

  export type YouTubeUserUpdateWithoutVideoCommentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    adminOfChannels?: ChannelUpdateManyWithoutAdminUsersNestedInput
    usersToChannelswithRoles?: UserToChannelwithRoleUpdateManyWithoutUserNestedInput
    subscribingToChannels?: ChannelUpdateManyWithoutSubscribedUsersNestedInput
    reactedVideos?: VideoUpdateManyWithoutReactedByYouTubeUsersNestedInput
    usersToVideosWithReactions?: UserToVideoWithReactionUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YouTubeUserUncheckedUpdateWithoutVideoCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    adminOfChannels?: ChannelUncheckedUpdateManyWithoutAdminUsersNestedInput
    usersToChannelswithRoles?: UserToChannelwithRoleUncheckedUpdateManyWithoutUserNestedInput
    subscribingToChannels?: ChannelUncheckedUpdateManyWithoutSubscribedUsersNestedInput
    reactedVideos?: VideoUncheckedUpdateManyWithoutReactedByYouTubeUsersNestedInput
    usersToVideosWithReactions?: UserToVideoWithReactionUncheckedUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUpsertWithoutVideoCommentsInput = {
    update: XOR<VideoUpdateWithoutVideoCommentsInput, VideoUncheckedUpdateWithoutVideoCommentsInput>
    create: XOR<VideoCreateWithoutVideoCommentsInput, VideoUncheckedCreateWithoutVideoCommentsInput>
  }

  export type VideoUpdateWithoutVideoCommentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    belongsToChannel?: ChannelUpdateOneRequiredWithoutOwningVideosNestedInput
    reactedByYouTubeUsers?: YouTubeUserUpdateManyWithoutReactedVideosNestedInput
    usersToVideosWithReactions?: UserToVideoWithReactionUpdateManyWithoutVideoNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUncheckedUpdateWithoutVideoCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: IntFieldUpdateOperationsInput | number
    reactedByYouTubeUsers?: YouTubeUserUncheckedUpdateManyWithoutReactedVideosNestedInput
    usersToVideosWithReactions?: UserToVideoWithReactionUncheckedUpdateManyWithoutVideoNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCommentUpsertWithoutChildVideoCommentsInput = {
    update: XOR<VideoCommentUpdateWithoutChildVideoCommentsInput, VideoCommentUncheckedUpdateWithoutChildVideoCommentsInput>
    create: XOR<VideoCommentCreateWithoutChildVideoCommentsInput, VideoCommentUncheckedCreateWithoutChildVideoCommentsInput>
  }

  export type VideoCommentUpdateWithoutChildVideoCommentsInput = {
    commentText?: StringFieldUpdateOperationsInput | string
    commentingUser?: YouTubeUserUpdateOneRequiredWithoutVideoCommentsNestedInput
    parentVideo?: VideoUpdateOneRequiredWithoutVideoCommentsNestedInput
    parentVideoComment?: VideoCommentUpdateOneWithoutChildVideoCommentsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCommentUncheckedUpdateWithoutChildVideoCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentText?: StringFieldUpdateOperationsInput | string
    youTubeUserId?: IntFieldUpdateOperationsInput | number
    videoId?: IntFieldUpdateOperationsInput | number
    parentVideoCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCommentUpsertWithWhereUniqueWithoutParentVideoCommentInput = {
    where: VideoCommentWhereUniqueInput
    update: XOR<VideoCommentUpdateWithoutParentVideoCommentInput, VideoCommentUncheckedUpdateWithoutParentVideoCommentInput>
    create: XOR<VideoCommentCreateWithoutParentVideoCommentInput, VideoCommentUncheckedCreateWithoutParentVideoCommentInput>
  }

  export type VideoCommentUpdateWithWhereUniqueWithoutParentVideoCommentInput = {
    where: VideoCommentWhereUniqueInput
    data: XOR<VideoCommentUpdateWithoutParentVideoCommentInput, VideoCommentUncheckedUpdateWithoutParentVideoCommentInput>
  }

  export type VideoCommentUpdateManyWithWhereWithoutParentVideoCommentInput = {
    where: VideoCommentScalarWhereInput
    data: XOR<VideoCommentUpdateManyMutationInput, VideoCommentUncheckedUpdateManyWithoutChildVideoCommentsInput>
  }

  export type MenuCreateManyCategoryInput = {
    id?: number
    name: string
    image: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    orderItems?: OrderItemUpdateManyWithoutMenuNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    orderItems?: OrderItemUncheckedUpdateManyWithoutMenuNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuUncheckedUpdateManyWithoutMenuInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManyMenuInput = {
    id?: number
    orderId?: number | null
    quantity: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemUpdateWithoutMenuInput = {
    order?: OrderUpdateOneWithoutItemsNestedInput
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateWithoutMenuInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManyOrderInput = {
    id?: number
    menuId: number
    quantity: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemUpdateWithoutOrderInput = {
    menu?: MenuUpdateOneRequiredWithoutOrderItemsNestedInput
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateManyWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizCreateManyCategoryInput = {
    id?: number
    questionText: string
    correctChoiceId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizUpdateWithoutCategoryInput = {
    questionText?: StringFieldUpdateOperationsInput | string
    choices?: ChoiceUpdateManyWithoutQuizNestedInput
    correctChoice?: ChoiceUpdateOneRequiredWithoutCorrectQuizzesNestedInput
    rounds?: RoundUpdateManyWithoutQuizzesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionText?: StringFieldUpdateOperationsInput | string
    choices?: ChoiceUncheckedUpdateManyWithoutQuizNestedInput
    correctChoiceId?: IntFieldUpdateOperationsInput | number
    rounds?: RoundUncheckedUpdateManyWithoutQuizzesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizUncheckedUpdateManyWithoutQuizzesInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionText?: StringFieldUpdateOperationsInput | string
    correctChoiceId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizCreateManyCorrectChoiceInput = {
    id?: number
    questionText: string
    quizCategoryId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizUpdateWithoutCorrectChoiceInput = {
    questionText?: StringFieldUpdateOperationsInput | string
    category?: QuizCategoryUpdateOneRequiredWithoutQuizzesNestedInput
    choices?: ChoiceUpdateManyWithoutQuizNestedInput
    rounds?: RoundUpdateManyWithoutQuizzesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizUncheckedUpdateWithoutCorrectChoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionText?: StringFieldUpdateOperationsInput | string
    quizCategoryId?: IntFieldUpdateOperationsInput | number
    choices?: ChoiceUncheckedUpdateManyWithoutQuizNestedInput
    rounds?: RoundUncheckedUpdateManyWithoutQuizzesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizUncheckedUpdateManyWithoutCorrectQuizzesInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionText?: StringFieldUpdateOperationsInput | string
    quizCategoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoundUpdateWithoutSelectedChoicesInput = {
    quizzes?: QuizUpdateManyWithoutRoundsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoundUncheckedUpdateWithoutSelectedChoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizzes?: QuizUncheckedUpdateManyWithoutRoundsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoundUncheckedUpdateManyWithoutRoundsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoiceCreateManyQuizInput = {
    id?: number
    answerText: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChoiceUpdateWithoutQuizInput = {
    answerText?: StringFieldUpdateOperationsInput | string
    correctQuizzes?: QuizUpdateManyWithoutCorrectChoiceNestedInput
    rounds?: RoundUpdateManyWithoutSelectedChoicesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoiceUncheckedUpdateWithoutQuizInput = {
    id?: IntFieldUpdateOperationsInput | number
    answerText?: StringFieldUpdateOperationsInput | string
    correctQuizzes?: QuizUncheckedUpdateManyWithoutCorrectChoiceNestedInput
    rounds?: RoundUncheckedUpdateManyWithoutSelectedChoicesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoiceUncheckedUpdateManyWithoutChoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    answerText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoundUpdateWithoutQuizzesInput = {
    selectedChoices?: ChoiceUpdateManyWithoutRoundsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoundUncheckedUpdateWithoutQuizzesInput = {
    id?: IntFieldUpdateOperationsInput | number
    selectedChoices?: ChoiceUncheckedUpdateManyWithoutRoundsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizUpdateWithoutRoundsInput = {
    questionText?: StringFieldUpdateOperationsInput | string
    category?: QuizCategoryUpdateOneRequiredWithoutQuizzesNestedInput
    choices?: ChoiceUpdateManyWithoutQuizNestedInput
    correctChoice?: ChoiceUpdateOneRequiredWithoutCorrectQuizzesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizUncheckedUpdateWithoutRoundsInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionText?: StringFieldUpdateOperationsInput | string
    quizCategoryId?: IntFieldUpdateOperationsInput | number
    choices?: ChoiceUncheckedUpdateManyWithoutQuizNestedInput
    correctChoiceId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoiceUpdateWithoutRoundsInput = {
    answerText?: StringFieldUpdateOperationsInput | string
    quiz?: QuizUpdateOneWithoutChoicesNestedInput
    correctQuizzes?: QuizUpdateManyWithoutCorrectChoiceNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoiceUncheckedUpdateWithoutRoundsInput = {
    id?: IntFieldUpdateOperationsInput | number
    answerText?: StringFieldUpdateOperationsInput | string
    quizId?: NullableIntFieldUpdateOperationsInput | number | null
    correctQuizzes?: QuizUncheckedUpdateManyWithoutCorrectChoiceNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoiceUncheckedUpdateManyWithoutSelectedChoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    answerText?: StringFieldUpdateOperationsInput | string
    quizId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserRelationCreateManyFollowingUserInput = {
    id?: number
    followedUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserRelationCreateManyFollowedUserInput = {
    id?: number
    followingUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostCreateManyPostingUserInput = {
    id?: number
    postText: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateManyCommentingUserInput = {
    id?: number
    commentText: string
    postId: number
    parentCommentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessengerMessageCreateManyFromUserInput = {
    id?: number
    messengerText: string
    toUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessengerMessageCreateManyToUserInput = {
    id?: number
    messengerText: string
    fromUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserRelationUpdateWithoutFollowingUserInput = {
    followedUser?: FacebookUserUpdateOneRequiredWithoutFollowedUserRelationsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserRelationUncheckedUpdateWithoutFollowingUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    followedUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserRelationUncheckedUpdateManyWithoutFollowingUserRelationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    followedUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserRelationUpdateWithoutFollowedUserInput = {
    followingUser?: FacebookUserUpdateOneRequiredWithoutFollowingUserRelationsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserRelationUncheckedUpdateWithoutFollowedUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    followingUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserRelationUncheckedUpdateManyWithoutFollowedUserRelationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    followingUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUpdateWithoutPostingUserInput = {
    postText?: StringFieldUpdateOperationsInput | string
    comments?: CommentUpdateManyWithoutParentPostNestedInput
    hashTags?: FacebookHashTagUpdateManyWithoutIsInPostsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateWithoutPostingUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    postText?: StringFieldUpdateOperationsInput | string
    comments?: CommentUncheckedUpdateManyWithoutParentPostNestedInput
    hashTags?: FacebookHashTagUncheckedUpdateManyWithoutIsInPostsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateManyWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    postText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutCommentingUserInput = {
    commentText?: StringFieldUpdateOperationsInput | string
    parentPost?: PostUpdateOneRequiredWithoutCommentsNestedInput
    parentComment?: CommentUpdateOneWithoutChildCommentsNestedInput
    childComments?: CommentUpdateManyWithoutParentCommentNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateWithoutCommentingUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentText?: StringFieldUpdateOperationsInput | string
    postId?: IntFieldUpdateOperationsInput | number
    parentCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    childComments?: CommentUncheckedUpdateManyWithoutParentCommentNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentText?: StringFieldUpdateOperationsInput | string
    postId?: IntFieldUpdateOperationsInput | number
    parentCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessengerMessageUpdateWithoutFromUserInput = {
    messengerText?: StringFieldUpdateOperationsInput | string
    toUser?: FacebookUserUpdateOneRequiredWithoutMessengerMessagesToNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessengerMessageUncheckedUpdateWithoutFromUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    messengerText?: StringFieldUpdateOperationsInput | string
    toUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessengerMessageUncheckedUpdateManyWithoutMessengerMessagesFromInput = {
    id?: IntFieldUpdateOperationsInput | number
    messengerText?: StringFieldUpdateOperationsInput | string
    toUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessengerMessageUpdateWithoutToUserInput = {
    messengerText?: StringFieldUpdateOperationsInput | string
    fromUser?: FacebookUserUpdateOneRequiredWithoutMessengerMessagesFromNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessengerMessageUncheckedUpdateWithoutToUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    messengerText?: StringFieldUpdateOperationsInput | string
    fromUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessengerMessageUncheckedUpdateManyWithoutMessengerMessagesToInput = {
    id?: IntFieldUpdateOperationsInput | number
    messengerText?: StringFieldUpdateOperationsInput | string
    fromUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyParentPostInput = {
    id?: number
    commentText: string
    userId: number
    parentCommentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateWithoutParentPostInput = {
    commentText?: StringFieldUpdateOperationsInput | string
    commentingUser?: FacebookUserUpdateOneRequiredWithoutCommentsNestedInput
    parentComment?: CommentUpdateOneWithoutChildCommentsNestedInput
    childComments?: CommentUpdateManyWithoutParentCommentNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateWithoutParentPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentText?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    parentCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    childComments?: CommentUncheckedUpdateManyWithoutParentCommentNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookHashTagUpdateWithoutIsInPostsInput = {
    hashTagText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookHashTagUncheckedUpdateWithoutIsInPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    hashTagText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookHashTagUncheckedUpdateManyWithoutHashTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    hashTagText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyParentCommentInput = {
    id?: number
    commentText: string
    userId: number
    postId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateWithoutParentCommentInput = {
    commentText?: StringFieldUpdateOperationsInput | string
    commentingUser?: FacebookUserUpdateOneRequiredWithoutCommentsNestedInput
    parentPost?: PostUpdateOneRequiredWithoutCommentsNestedInput
    childComments?: CommentUpdateManyWithoutParentCommentNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateWithoutParentCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentText?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    childComments?: CommentUncheckedUpdateManyWithoutParentCommentNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutChildCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentText?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUpdateWithoutHashTagsInput = {
    postText?: StringFieldUpdateOperationsInput | string
    postingUser?: FacebookUserUpdateOneRequiredWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutParentPostNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateWithoutHashTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    postText?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    comments?: CommentUncheckedUpdateManyWithoutParentPostNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateManyWithoutIsInPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    postText?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRelationCreateManyFollowingUserInput = {
    id?: number
    followedUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserRelationCreateManyFollowedUserInput = {
    id?: number
    followingUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TweetCreateManyTweetingUserInput = {
    id?: number
    tweetText: string
    parentTweetId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DirectMessageCreateManyFromUserInput = {
    id?: number
    dmText: string
    toUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DirectMessageCreateManyToUserInput = {
    id?: number
    dmText: string
    fromUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserRelationUpdateWithoutFollowingUserInput = {
    followedUser?: UserUpdateOneRequiredWithoutFollowedUserRelationsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRelationUncheckedUpdateWithoutFollowingUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    followedUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRelationUncheckedUpdateManyWithoutFollowingUserRelationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    followedUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRelationUpdateWithoutFollowedUserInput = {
    followingUser?: UserUpdateOneRequiredWithoutFollowingUserRelationsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRelationUncheckedUpdateWithoutFollowedUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    followingUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRelationUncheckedUpdateManyWithoutFollowedUserRelationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    followingUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TweetUpdateWithoutTweetingUserInput = {
    tweetText?: StringFieldUpdateOperationsInput | string
    parentTweet?: TweetUpdateOneWithoutChildTweetsNestedInput
    childTweets?: TweetUpdateManyWithoutParentTweetNestedInput
    hashTags?: HashTagUpdateManyWithoutIsInTweetsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TweetUncheckedUpdateWithoutTweetingUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    tweetText?: StringFieldUpdateOperationsInput | string
    parentTweetId?: NullableIntFieldUpdateOperationsInput | number | null
    childTweets?: TweetUncheckedUpdateManyWithoutParentTweetNestedInput
    hashTags?: HashTagUncheckedUpdateManyWithoutIsInTweetsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TweetUncheckedUpdateManyWithoutTweetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tweetText?: StringFieldUpdateOperationsInput | string
    parentTweetId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageUpdateWithoutFromUserInput = {
    dmText?: StringFieldUpdateOperationsInput | string
    toUser?: UserUpdateOneRequiredWithoutDirectMessagesToNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageUncheckedUpdateWithoutFromUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    dmText?: StringFieldUpdateOperationsInput | string
    toUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageUncheckedUpdateManyWithoutDirectMessagesFromInput = {
    id?: IntFieldUpdateOperationsInput | number
    dmText?: StringFieldUpdateOperationsInput | string
    toUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageUpdateWithoutToUserInput = {
    dmText?: StringFieldUpdateOperationsInput | string
    fromUser?: UserUpdateOneRequiredWithoutDirectMessagesFromNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageUncheckedUpdateWithoutToUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    dmText?: StringFieldUpdateOperationsInput | string
    fromUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageUncheckedUpdateManyWithoutDirectMessagesToInput = {
    id?: IntFieldUpdateOperationsInput | number
    dmText?: StringFieldUpdateOperationsInput | string
    fromUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TweetCreateManyParentTweetInput = {
    id?: number
    tweetText: string
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TweetUpdateWithoutParentTweetInput = {
    tweetText?: StringFieldUpdateOperationsInput | string
    tweetingUser?: UserUpdateOneRequiredWithoutTweetsNestedInput
    childTweets?: TweetUpdateManyWithoutParentTweetNestedInput
    hashTags?: HashTagUpdateManyWithoutIsInTweetsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TweetUncheckedUpdateWithoutParentTweetInput = {
    id?: IntFieldUpdateOperationsInput | number
    tweetText?: StringFieldUpdateOperationsInput | string
    childTweets?: TweetUncheckedUpdateManyWithoutParentTweetNestedInput
    userId?: IntFieldUpdateOperationsInput | number
    hashTags?: HashTagUncheckedUpdateManyWithoutIsInTweetsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TweetUncheckedUpdateManyWithoutChildTweetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tweetText?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HashTagUpdateWithoutIsInTweetsInput = {
    hashTagText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HashTagUncheckedUpdateWithoutIsInTweetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    hashTagText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HashTagUncheckedUpdateManyWithoutHashTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    hashTagText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TweetUpdateWithoutHashTagsInput = {
    tweetText?: StringFieldUpdateOperationsInput | string
    tweetingUser?: UserUpdateOneRequiredWithoutTweetsNestedInput
    parentTweet?: TweetUpdateOneWithoutChildTweetsNestedInput
    childTweets?: TweetUpdateManyWithoutParentTweetNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TweetUncheckedUpdateWithoutHashTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tweetText?: StringFieldUpdateOperationsInput | string
    parentTweetId?: NullableIntFieldUpdateOperationsInput | number | null
    childTweets?: TweetUncheckedUpdateManyWithoutParentTweetNestedInput
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TweetUncheckedUpdateManyWithoutIsInTweetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tweetText?: StringFieldUpdateOperationsInput | string
    parentTweetId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToChannelwithRoleCreateManyUserInput = {
    id?: number
    channelId: number
    role: RoleEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToVideoWithReactionCreateManyUserInput = {
    id?: number
    videoId: number
    reaction: ReactionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCommentCreateManyCommentingUserInput = {
    id?: number
    commentText: string
    videoId: number
    parentVideoCommentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChannelUpdateWithoutAdminUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subscribedUsers?: YouTubeUserUpdateManyWithoutSubscribingToChannelsNestedInput
    usersToChannelswithRoles?: UserToChannelwithRoleUpdateManyWithoutChannelNestedInput
    owningVideos?: VideoUpdateManyWithoutBelongsToChannelNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelUncheckedUpdateWithoutAdminUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subscribedUsers?: YouTubeUserUncheckedUpdateManyWithoutSubscribingToChannelsNestedInput
    usersToChannelswithRoles?: UserToChannelwithRoleUncheckedUpdateManyWithoutChannelNestedInput
    owningVideos?: VideoUncheckedUpdateManyWithoutBelongsToChannelNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelUncheckedUpdateManyWithoutAdminOfChannelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToChannelwithRoleUpdateWithoutUserInput = {
    channel?: ChannelUpdateOneRequiredWithoutUsersToChannelswithRolesNestedInput
    role?: EnumRoleEnumFieldUpdateOperationsInput | RoleEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToChannelwithRoleUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    channelId?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleEnumFieldUpdateOperationsInput | RoleEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToChannelwithRoleUncheckedUpdateManyWithoutUsersToChannelswithRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    channelId?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleEnumFieldUpdateOperationsInput | RoleEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelUpdateWithoutSubscribedUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adminUsers?: YouTubeUserUpdateManyWithoutAdminOfChannelsNestedInput
    usersToChannelswithRoles?: UserToChannelwithRoleUpdateManyWithoutChannelNestedInput
    owningVideos?: VideoUpdateManyWithoutBelongsToChannelNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelUncheckedUpdateWithoutSubscribedUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adminUsers?: YouTubeUserUncheckedUpdateManyWithoutAdminOfChannelsNestedInput
    usersToChannelswithRoles?: UserToChannelwithRoleUncheckedUpdateManyWithoutChannelNestedInput
    owningVideos?: VideoUncheckedUpdateManyWithoutBelongsToChannelNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelUncheckedUpdateManyWithoutSubscribingToChannelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUpdateWithoutReactedByYouTubeUsersInput = {
    title?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    belongsToChannel?: ChannelUpdateOneRequiredWithoutOwningVideosNestedInput
    usersToVideosWithReactions?: UserToVideoWithReactionUpdateManyWithoutVideoNestedInput
    videoComments?: VideoCommentUpdateManyWithoutParentVideoNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUncheckedUpdateWithoutReactedByYouTubeUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: IntFieldUpdateOperationsInput | number
    usersToVideosWithReactions?: UserToVideoWithReactionUncheckedUpdateManyWithoutVideoNestedInput
    videoComments?: VideoCommentUncheckedUpdateManyWithoutParentVideoNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUncheckedUpdateManyWithoutReactedVideosInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToVideoWithReactionUpdateWithoutUserInput = {
    video?: VideoUpdateOneRequiredWithoutUsersToVideosWithReactionsNestedInput
    reaction?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToVideoWithReactionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    videoId?: IntFieldUpdateOperationsInput | number
    reaction?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToVideoWithReactionUncheckedUpdateManyWithoutUsersToVideosWithReactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    videoId?: IntFieldUpdateOperationsInput | number
    reaction?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCommentUpdateWithoutCommentingUserInput = {
    commentText?: StringFieldUpdateOperationsInput | string
    parentVideo?: VideoUpdateOneRequiredWithoutVideoCommentsNestedInput
    parentVideoComment?: VideoCommentUpdateOneWithoutChildVideoCommentsNestedInput
    childVideoComments?: VideoCommentUpdateManyWithoutParentVideoCommentNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCommentUncheckedUpdateWithoutCommentingUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentText?: StringFieldUpdateOperationsInput | string
    videoId?: IntFieldUpdateOperationsInput | number
    parentVideoCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    childVideoComments?: VideoCommentUncheckedUpdateManyWithoutParentVideoCommentNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCommentUncheckedUpdateManyWithoutVideoCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentText?: StringFieldUpdateOperationsInput | string
    videoId?: IntFieldUpdateOperationsInput | number
    parentVideoCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToChannelwithRoleCreateManyChannelInput = {
    id?: number
    youTubeUserId: number
    role: RoleEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCreateManyBelongsToChannelInput = {
    id?: number
    title: string
    videoUrl: string
    thumbnailImageUrl?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YouTubeUserUpdateWithoutAdminOfChannelsInput = {
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    usersToChannelswithRoles?: UserToChannelwithRoleUpdateManyWithoutUserNestedInput
    subscribingToChannels?: ChannelUpdateManyWithoutSubscribedUsersNestedInput
    reactedVideos?: VideoUpdateManyWithoutReactedByYouTubeUsersNestedInput
    usersToVideosWithReactions?: UserToVideoWithReactionUpdateManyWithoutUserNestedInput
    videoComments?: VideoCommentUpdateManyWithoutCommentingUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YouTubeUserUncheckedUpdateWithoutAdminOfChannelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    usersToChannelswithRoles?: UserToChannelwithRoleUncheckedUpdateManyWithoutUserNestedInput
    subscribingToChannels?: ChannelUncheckedUpdateManyWithoutSubscribedUsersNestedInput
    reactedVideos?: VideoUncheckedUpdateManyWithoutReactedByYouTubeUsersNestedInput
    usersToVideosWithReactions?: UserToVideoWithReactionUncheckedUpdateManyWithoutUserNestedInput
    videoComments?: VideoCommentUncheckedUpdateManyWithoutCommentingUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YouTubeUserUncheckedUpdateManyWithoutAdminUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YouTubeUserUpdateWithoutSubscribingToChannelsInput = {
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    adminOfChannels?: ChannelUpdateManyWithoutAdminUsersNestedInput
    usersToChannelswithRoles?: UserToChannelwithRoleUpdateManyWithoutUserNestedInput
    reactedVideos?: VideoUpdateManyWithoutReactedByYouTubeUsersNestedInput
    usersToVideosWithReactions?: UserToVideoWithReactionUpdateManyWithoutUserNestedInput
    videoComments?: VideoCommentUpdateManyWithoutCommentingUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YouTubeUserUncheckedUpdateWithoutSubscribingToChannelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    adminOfChannels?: ChannelUncheckedUpdateManyWithoutAdminUsersNestedInput
    usersToChannelswithRoles?: UserToChannelwithRoleUncheckedUpdateManyWithoutUserNestedInput
    reactedVideos?: VideoUncheckedUpdateManyWithoutReactedByYouTubeUsersNestedInput
    usersToVideosWithReactions?: UserToVideoWithReactionUncheckedUpdateManyWithoutUserNestedInput
    videoComments?: VideoCommentUncheckedUpdateManyWithoutCommentingUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YouTubeUserUncheckedUpdateManyWithoutSubscribedUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToChannelwithRoleUpdateWithoutChannelInput = {
    user?: YouTubeUserUpdateOneRequiredWithoutUsersToChannelswithRolesNestedInput
    role?: EnumRoleEnumFieldUpdateOperationsInput | RoleEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToChannelwithRoleUncheckedUpdateWithoutChannelInput = {
    id?: IntFieldUpdateOperationsInput | number
    youTubeUserId?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleEnumFieldUpdateOperationsInput | RoleEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUpdateWithoutBelongsToChannelInput = {
    title?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reactedByYouTubeUsers?: YouTubeUserUpdateManyWithoutReactedVideosNestedInput
    usersToVideosWithReactions?: UserToVideoWithReactionUpdateManyWithoutVideoNestedInput
    videoComments?: VideoCommentUpdateManyWithoutParentVideoNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUncheckedUpdateWithoutBelongsToChannelInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reactedByYouTubeUsers?: YouTubeUserUncheckedUpdateManyWithoutReactedVideosNestedInput
    usersToVideosWithReactions?: UserToVideoWithReactionUncheckedUpdateManyWithoutVideoNestedInput
    videoComments?: VideoCommentUncheckedUpdateManyWithoutParentVideoNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUncheckedUpdateManyWithoutOwningVideosInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToVideoWithReactionCreateManyVideoInput = {
    id?: number
    youTubeUserId: number
    reaction: ReactionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCommentCreateManyParentVideoInput = {
    id?: number
    commentText: string
    youTubeUserId: number
    parentVideoCommentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YouTubeUserUpdateWithoutReactedVideosInput = {
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    adminOfChannels?: ChannelUpdateManyWithoutAdminUsersNestedInput
    usersToChannelswithRoles?: UserToChannelwithRoleUpdateManyWithoutUserNestedInput
    subscribingToChannels?: ChannelUpdateManyWithoutSubscribedUsersNestedInput
    usersToVideosWithReactions?: UserToVideoWithReactionUpdateManyWithoutUserNestedInput
    videoComments?: VideoCommentUpdateManyWithoutCommentingUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YouTubeUserUncheckedUpdateWithoutReactedVideosInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    adminOfChannels?: ChannelUncheckedUpdateManyWithoutAdminUsersNestedInput
    usersToChannelswithRoles?: UserToChannelwithRoleUncheckedUpdateManyWithoutUserNestedInput
    subscribingToChannels?: ChannelUncheckedUpdateManyWithoutSubscribedUsersNestedInput
    usersToVideosWithReactions?: UserToVideoWithReactionUncheckedUpdateManyWithoutUserNestedInput
    videoComments?: VideoCommentUncheckedUpdateManyWithoutCommentingUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YouTubeUserUncheckedUpdateManyWithoutReactedByYouTubeUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToVideoWithReactionUpdateWithoutVideoInput = {
    user?: YouTubeUserUpdateOneRequiredWithoutUsersToVideosWithReactionsNestedInput
    reaction?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToVideoWithReactionUncheckedUpdateWithoutVideoInput = {
    id?: IntFieldUpdateOperationsInput | number
    youTubeUserId?: IntFieldUpdateOperationsInput | number
    reaction?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCommentUpdateWithoutParentVideoInput = {
    commentText?: StringFieldUpdateOperationsInput | string
    commentingUser?: YouTubeUserUpdateOneRequiredWithoutVideoCommentsNestedInput
    parentVideoComment?: VideoCommentUpdateOneWithoutChildVideoCommentsNestedInput
    childVideoComments?: VideoCommentUpdateManyWithoutParentVideoCommentNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCommentUncheckedUpdateWithoutParentVideoInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentText?: StringFieldUpdateOperationsInput | string
    youTubeUserId?: IntFieldUpdateOperationsInput | number
    parentVideoCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    childVideoComments?: VideoCommentUncheckedUpdateManyWithoutParentVideoCommentNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCommentCreateManyParentVideoCommentInput = {
    id?: number
    commentText: string
    youTubeUserId: number
    videoId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCommentUpdateWithoutParentVideoCommentInput = {
    commentText?: StringFieldUpdateOperationsInput | string
    commentingUser?: YouTubeUserUpdateOneRequiredWithoutVideoCommentsNestedInput
    parentVideo?: VideoUpdateOneRequiredWithoutVideoCommentsNestedInput
    childVideoComments?: VideoCommentUpdateManyWithoutParentVideoCommentNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCommentUncheckedUpdateWithoutParentVideoCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentText?: StringFieldUpdateOperationsInput | string
    youTubeUserId?: IntFieldUpdateOperationsInput | number
    videoId?: IntFieldUpdateOperationsInput | number
    childVideoComments?: VideoCommentUncheckedUpdateManyWithoutParentVideoCommentNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCommentUncheckedUpdateManyWithoutChildVideoCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentText?: StringFieldUpdateOperationsInput | string
    youTubeUserId?: IntFieldUpdateOperationsInput | number
    videoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}