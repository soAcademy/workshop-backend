
/**
 * Client
**/

import * as runtime from './runtime/library';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Category
 * 
 */
export type Category = {
  id: number
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Menu
 * 
 */
export type Menu = {
  id: number
  name: string
  image: string
  price: number
  categoryId: number | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Order
 * 
 */
export type Order = {
  id: number
  status: string
  tableId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model OrderItem
 * 
 */
export type OrderItem = {
  id: number
  menuId: number
  orderId: number | null
  quantity: number
  totalPrice: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model QuizCategory
 * 
 */
export type QuizCategory = {
  id: number
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Choice
 * 
 */
export type Choice = {
  id: number
  answerText: string
  quizId: number | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Quiz
 * 
 */
export type Quiz = {
  id: number
  questionText: string
  quizCategoryId: number
  correctChoiceId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Round
 * 
 */
export type Round = {
  id: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model BinWashUser
 * 
 */
export type BinWashUser = {
  id: number
  name: string
  balance: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Branch
 * 
 */
export type Branch = {
  id: number
  name: string
  location: string
  telephoneNo: string
  area: number
  binWashUserId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model WashingMachine
 * 
 */
export type WashingMachine = {
  id: number
  brand: string
  model: string
  type: WMTypeEnum
  capacity: number
  manufacturedYear: Date
  warrantyEndDate: Date
  branchId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model WMProgram
 * 
 */
export type WMProgram = {
  id: number
  name: string
  maxCapacity: number
  duration: number
  price: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model WMMaintenanceRecord
 * 
 */
export type WMMaintenanceRecord = {
  id: number
  washingMachineId: number
  maintenanceDateTime: Date
  level: number
  details: string
  binWashUserId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model UsageRecord
 * 
 */
export type UsageRecord = {
  id: number
  dateTime: Date
  binWashUserId: number
  washingMachineId: number
  wMProgramId: number
  price: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model TopUpRecord
 * 
 */
export type TopUpRecord = {
  id: number
  dateTime: Date
  binWashUserId: number
  price: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model FacebookUser
 * 
 */
export type FacebookUser = {
  id: number
  name: string
  imageUrl: string
  bio: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model FacebookUserRelation
 * 
 */
export type FacebookUserRelation = {
  id: number
  followingUserId: number
  followedUserId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Post
 * 
 */
export type Post = {
  id: number
  postText: string
  userId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Comment
 * 
 */
export type Comment = {
  id: number
  commentText: string
  userId: number
  postId: number
  parentCommentId: number | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model FacebookHashTag
 * 
 */
export type FacebookHashTag = {
  id: number
  hashTagText: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model MessengerMessage
 * 
 */
export type MessengerMessage = {
  id: number
  messengerText: string
  fromUserId: number
  toUserId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Author
 * 
 */
export type Author = {
  id: number
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model BookTitle
 * 
 */
export type BookTitle = {
  id: number
  title: string
  isbn: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model BookCategory
 * 
 */
export type BookCategory = {
  id: number
  category: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Book
 * 
 */
export type Book = {
  id: number
  bookTitleId: number
  libraryId: number
  isAvailable: boolean
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Library
 * 
 */
export type Library = {
  id: number
  name: string
  location: string
  universityId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model University
 * 
 */
export type University = {
  id: number
  name: string
  location: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Student
 * 
 */
export type Student = {
  id: number
  Name: string
  universityId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model BorrowingRecord
 * 
 */
export type BorrowingRecord = {
  id: number
  studentId: number
  bookId: number
  startDate: Date
  endDate: Date | null
  actualEndDate: Date | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model RequestRecord
 * 
 */
export type RequestRecord = {
  id: number
  studentId: number
  bookTitleId: number
  requestingLibraryId: number
  requestedLibraryId: number
  requestDate: Date
  acquiredDate: Date | null
  returnDate: Date | null
  bookId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model TodoList
 * 
 */
export type TodoList = {
  id: number
  task: string
  status: string
  bgColor: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model User
 * 
 */
export type User = {
  id: number
  name: string
  imageUrl: string
  bio: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model UserRelation
 * 
 */
export type UserRelation = {
  id: number
  followingUserId: number
  followedUserId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Tweet
 * 
 */
export type Tweet = {
  id: number
  tweetText: string
  parentTweetId: number | null
  userId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model HashTag
 * 
 */
export type HashTag = {
  id: number
  hashTagText: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model DirectMessage
 * 
 */
export type DirectMessage = {
  id: number
  dmText: string
  fromUserId: number
  toUserId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model YouTubeUser
 * 
 */
export type YouTubeUser = {
  id: number
  name: string
  profileImageUrl: string | null
  bio: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Channel
 * 
 */
export type Channel = {
  id: number
  name: string
  profileImageUrl: string | null
  description: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model UserToChannelwithRole
 * 
 */
export type UserToChannelwithRole = {
  id: number
  youTubeUserId: number
  channelId: number
  role: RoleEnum
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Video
 * 
 */
export type Video = {
  id: number
  title: string
  videoUrl: string
  thumbnailImageUrl: string | null
  description: string | null
  channelId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model UserToVideoWithReaction
 * 
 */
export type UserToVideoWithReaction = {
  id: number
  youTubeUserId: number
  videoId: number
  reaction: ReactionEnum
  createdAt: Date
  updatedAt: Date
}

/**
 * Model VideoComment
 * 
 */
export type VideoComment = {
  id: number
  commentText: string
  youTubeUserId: number
  videoId: number
  parentVideoCommentId: number | null
  createdAt: Date
  updatedAt: Date
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const ReactionEnum: {
  LIKE: 'LIKE',
  DISLIKE: 'DISLIKE'
};

export type ReactionEnum = (typeof ReactionEnum)[keyof typeof ReactionEnum]


export const RoleEnum: {
  MANAGER: 'MANAGER',
  EDITOR: 'EDITOR',
  VIEWER: 'VIEWER'
};

export type RoleEnum = (typeof RoleEnum)[keyof typeof RoleEnum]


export const WMTypeEnum: {
  FRONT_LOAD: 'FRONT_LOAD',
  TOP_LOAD: 'TOP_LOAD'
};

export type WMTypeEnum = (typeof WMTypeEnum)[keyof typeof WMTypeEnum]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Categories
 * const categories = await prisma.category.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Categories
   * const categories = await prisma.category.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<GlobalReject>;

  /**
   * `prisma.menu`: Exposes CRUD operations for the **Menu** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Menus
    * const menus = await prisma.menu.findMany()
    * ```
    */
  get menu(): Prisma.MenuDelegate<GlobalReject>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<GlobalReject>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<GlobalReject>;

  /**
   * `prisma.quizCategory`: Exposes CRUD operations for the **QuizCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizCategories
    * const quizCategories = await prisma.quizCategory.findMany()
    * ```
    */
  get quizCategory(): Prisma.QuizCategoryDelegate<GlobalReject>;

  /**
   * `prisma.choice`: Exposes CRUD operations for the **Choice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Choices
    * const choices = await prisma.choice.findMany()
    * ```
    */
  get choice(): Prisma.ChoiceDelegate<GlobalReject>;

  /**
   * `prisma.quiz`: Exposes CRUD operations for the **Quiz** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quizzes
    * const quizzes = await prisma.quiz.findMany()
    * ```
    */
  get quiz(): Prisma.QuizDelegate<GlobalReject>;

  /**
   * `prisma.round`: Exposes CRUD operations for the **Round** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rounds
    * const rounds = await prisma.round.findMany()
    * ```
    */
  get round(): Prisma.RoundDelegate<GlobalReject>;

  /**
   * `prisma.binWashUser`: Exposes CRUD operations for the **BinWashUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BinWashUsers
    * const binWashUsers = await prisma.binWashUser.findMany()
    * ```
    */
  get binWashUser(): Prisma.BinWashUserDelegate<GlobalReject>;

  /**
   * `prisma.branch`: Exposes CRUD operations for the **Branch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Branches
    * const branches = await prisma.branch.findMany()
    * ```
    */
  get branch(): Prisma.BranchDelegate<GlobalReject>;

  /**
   * `prisma.washingMachine`: Exposes CRUD operations for the **WashingMachine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WashingMachines
    * const washingMachines = await prisma.washingMachine.findMany()
    * ```
    */
  get washingMachine(): Prisma.WashingMachineDelegate<GlobalReject>;

  /**
   * `prisma.wMProgram`: Exposes CRUD operations for the **WMProgram** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WMPrograms
    * const wMPrograms = await prisma.wMProgram.findMany()
    * ```
    */
  get wMProgram(): Prisma.WMProgramDelegate<GlobalReject>;

  /**
   * `prisma.wMMaintenanceRecord`: Exposes CRUD operations for the **WMMaintenanceRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WMMaintenanceRecords
    * const wMMaintenanceRecords = await prisma.wMMaintenanceRecord.findMany()
    * ```
    */
  get wMMaintenanceRecord(): Prisma.WMMaintenanceRecordDelegate<GlobalReject>;

  /**
   * `prisma.usageRecord`: Exposes CRUD operations for the **UsageRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsageRecords
    * const usageRecords = await prisma.usageRecord.findMany()
    * ```
    */
  get usageRecord(): Prisma.UsageRecordDelegate<GlobalReject>;

  /**
   * `prisma.topUpRecord`: Exposes CRUD operations for the **TopUpRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TopUpRecords
    * const topUpRecords = await prisma.topUpRecord.findMany()
    * ```
    */
  get topUpRecord(): Prisma.TopUpRecordDelegate<GlobalReject>;

  /**
   * `prisma.facebookUser`: Exposes CRUD operations for the **FacebookUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FacebookUsers
    * const facebookUsers = await prisma.facebookUser.findMany()
    * ```
    */
  get facebookUser(): Prisma.FacebookUserDelegate<GlobalReject>;

  /**
   * `prisma.facebookUserRelation`: Exposes CRUD operations for the **FacebookUserRelation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FacebookUserRelations
    * const facebookUserRelations = await prisma.facebookUserRelation.findMany()
    * ```
    */
  get facebookUserRelation(): Prisma.FacebookUserRelationDelegate<GlobalReject>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<GlobalReject>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<GlobalReject>;

  /**
   * `prisma.facebookHashTag`: Exposes CRUD operations for the **FacebookHashTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FacebookHashTags
    * const facebookHashTags = await prisma.facebookHashTag.findMany()
    * ```
    */
  get facebookHashTag(): Prisma.FacebookHashTagDelegate<GlobalReject>;

  /**
   * `prisma.messengerMessage`: Exposes CRUD operations for the **MessengerMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessengerMessages
    * const messengerMessages = await prisma.messengerMessage.findMany()
    * ```
    */
  get messengerMessage(): Prisma.MessengerMessageDelegate<GlobalReject>;

  /**
   * `prisma.author`: Exposes CRUD operations for the **Author** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Authors
    * const authors = await prisma.author.findMany()
    * ```
    */
  get author(): Prisma.AuthorDelegate<GlobalReject>;

  /**
   * `prisma.bookTitle`: Exposes CRUD operations for the **BookTitle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookTitles
    * const bookTitles = await prisma.bookTitle.findMany()
    * ```
    */
  get bookTitle(): Prisma.BookTitleDelegate<GlobalReject>;

  /**
   * `prisma.bookCategory`: Exposes CRUD operations for the **BookCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookCategories
    * const bookCategories = await prisma.bookCategory.findMany()
    * ```
    */
  get bookCategory(): Prisma.BookCategoryDelegate<GlobalReject>;

  /**
   * `prisma.book`: Exposes CRUD operations for the **Book** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Books
    * const books = await prisma.book.findMany()
    * ```
    */
  get book(): Prisma.BookDelegate<GlobalReject>;

  /**
   * `prisma.library`: Exposes CRUD operations for the **Library** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Libraries
    * const libraries = await prisma.library.findMany()
    * ```
    */
  get library(): Prisma.LibraryDelegate<GlobalReject>;

  /**
   * `prisma.university`: Exposes CRUD operations for the **University** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Universities
    * const universities = await prisma.university.findMany()
    * ```
    */
  get university(): Prisma.UniversityDelegate<GlobalReject>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **Student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.StudentDelegate<GlobalReject>;

  /**
   * `prisma.borrowingRecord`: Exposes CRUD operations for the **BorrowingRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BorrowingRecords
    * const borrowingRecords = await prisma.borrowingRecord.findMany()
    * ```
    */
  get borrowingRecord(): Prisma.BorrowingRecordDelegate<GlobalReject>;

  /**
   * `prisma.requestRecord`: Exposes CRUD operations for the **RequestRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RequestRecords
    * const requestRecords = await prisma.requestRecord.findMany()
    * ```
    */
  get requestRecord(): Prisma.RequestRecordDelegate<GlobalReject>;

  /**
   * `prisma.todoList`: Exposes CRUD operations for the **TodoList** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TodoLists
    * const todoLists = await prisma.todoList.findMany()
    * ```
    */
  get todoList(): Prisma.TodoListDelegate<GlobalReject>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.userRelation`: Exposes CRUD operations for the **UserRelation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRelations
    * const userRelations = await prisma.userRelation.findMany()
    * ```
    */
  get userRelation(): Prisma.UserRelationDelegate<GlobalReject>;

  /**
   * `prisma.tweet`: Exposes CRUD operations for the **Tweet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tweets
    * const tweets = await prisma.tweet.findMany()
    * ```
    */
  get tweet(): Prisma.TweetDelegate<GlobalReject>;

  /**
   * `prisma.hashTag`: Exposes CRUD operations for the **HashTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HashTags
    * const hashTags = await prisma.hashTag.findMany()
    * ```
    */
  get hashTag(): Prisma.HashTagDelegate<GlobalReject>;

  /**
   * `prisma.directMessage`: Exposes CRUD operations for the **DirectMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DirectMessages
    * const directMessages = await prisma.directMessage.findMany()
    * ```
    */
  get directMessage(): Prisma.DirectMessageDelegate<GlobalReject>;

  /**
   * `prisma.youTubeUser`: Exposes CRUD operations for the **YouTubeUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YouTubeUsers
    * const youTubeUsers = await prisma.youTubeUser.findMany()
    * ```
    */
  get youTubeUser(): Prisma.YouTubeUserDelegate<GlobalReject>;

  /**
   * `prisma.channel`: Exposes CRUD operations for the **Channel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Channels
    * const channels = await prisma.channel.findMany()
    * ```
    */
  get channel(): Prisma.ChannelDelegate<GlobalReject>;

  /**
   * `prisma.userToChannelwithRole`: Exposes CRUD operations for the **UserToChannelwithRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserToChannelwithRoles
    * const userToChannelwithRoles = await prisma.userToChannelwithRole.findMany()
    * ```
    */
  get userToChannelwithRole(): Prisma.UserToChannelwithRoleDelegate<GlobalReject>;

  /**
   * `prisma.video`: Exposes CRUD operations for the **Video** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Videos
    * const videos = await prisma.video.findMany()
    * ```
    */
  get video(): Prisma.VideoDelegate<GlobalReject>;

  /**
   * `prisma.userToVideoWithReaction`: Exposes CRUD operations for the **UserToVideoWithReaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserToVideoWithReactions
    * const userToVideoWithReactions = await prisma.userToVideoWithReaction.findMany()
    * ```
    */
  get userToVideoWithReaction(): Prisma.UserToVideoWithReactionDelegate<GlobalReject>;

  /**
   * `prisma.videoComment`: Exposes CRUD operations for the **VideoComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VideoComments
    * const videoComments = await prisma.videoComment.findMany()
    * ```
    */
  get videoComment(): Prisma.VideoCommentDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.10.1
   * Query Engine version: aead147aa326ccb985dcfed5b065b4fdabd44b19
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Category: 'Category',
    Menu: 'Menu',
    Order: 'Order',
    OrderItem: 'OrderItem',
    QuizCategory: 'QuizCategory',
    Choice: 'Choice',
    Quiz: 'Quiz',
    Round: 'Round',
    BinWashUser: 'BinWashUser',
    Branch: 'Branch',
    WashingMachine: 'WashingMachine',
    WMProgram: 'WMProgram',
    WMMaintenanceRecord: 'WMMaintenanceRecord',
    UsageRecord: 'UsageRecord',
    TopUpRecord: 'TopUpRecord',
    FacebookUser: 'FacebookUser',
    FacebookUserRelation: 'FacebookUserRelation',
    Post: 'Post',
    Comment: 'Comment',
    FacebookHashTag: 'FacebookHashTag',
    MessengerMessage: 'MessengerMessage',
    Author: 'Author',
    BookTitle: 'BookTitle',
    BookCategory: 'BookCategory',
    Book: 'Book',
    Library: 'Library',
    University: 'University',
    Student: 'Student',
    BorrowingRecord: 'BorrowingRecord',
    RequestRecord: 'RequestRecord',
    TodoList: 'TodoList',
    User: 'User',
    UserRelation: 'UserRelation',
    Tweet: 'Tweet',
    HashTag: 'HashTag',
    DirectMessage: 'DirectMessage',
    YouTubeUser: 'YouTubeUser',
    Channel: 'Channel',
    UserToChannelwithRole: 'UserToChannelwithRole',
    Video: 'Video',
    UserToVideoWithReaction: 'UserToVideoWithReaction',
    VideoComment: 'VideoComment'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CategoryCountOutputType
   */


  export type CategoryCountOutputType = {
    Menu: number
  }

  export type CategoryCountOutputTypeSelect = {
    Menu?: boolean
  }

  export type CategoryCountOutputTypeGetPayload<S extends boolean | null | undefined | CategoryCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CategoryCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CategoryCountOutputTypeArgs)
    ? CategoryCountOutputType 
    : S extends { select: any } & (CategoryCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CategoryCountOutputType ? CategoryCountOutputType[P] : never
  } 
      : CategoryCountOutputType




  // Custom InputTypes

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect | null
  }



  /**
   * Count Type MenuCountOutputType
   */


  export type MenuCountOutputType = {
    orderItems: number
  }

  export type MenuCountOutputTypeSelect = {
    orderItems?: boolean
  }

  export type MenuCountOutputTypeGetPayload<S extends boolean | null | undefined | MenuCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MenuCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (MenuCountOutputTypeArgs)
    ? MenuCountOutputType 
    : S extends { select: any } & (MenuCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof MenuCountOutputType ? MenuCountOutputType[P] : never
  } 
      : MenuCountOutputType




  // Custom InputTypes

  /**
   * MenuCountOutputType without action
   */
  export type MenuCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MenuCountOutputType
     */
    select?: MenuCountOutputTypeSelect | null
  }



  /**
   * Count Type OrderCountOutputType
   */


  export type OrderCountOutputType = {
    items: number
  }

  export type OrderCountOutputTypeSelect = {
    items?: boolean
  }

  export type OrderCountOutputTypeGetPayload<S extends boolean | null | undefined | OrderCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? OrderCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (OrderCountOutputTypeArgs)
    ? OrderCountOutputType 
    : S extends { select: any } & (OrderCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof OrderCountOutputType ? OrderCountOutputType[P] : never
  } 
      : OrderCountOutputType




  // Custom InputTypes

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect | null
  }



  /**
   * Count Type QuizCategoryCountOutputType
   */


  export type QuizCategoryCountOutputType = {
    quizzes: number
  }

  export type QuizCategoryCountOutputTypeSelect = {
    quizzes?: boolean
  }

  export type QuizCategoryCountOutputTypeGetPayload<S extends boolean | null | undefined | QuizCategoryCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? QuizCategoryCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (QuizCategoryCountOutputTypeArgs)
    ? QuizCategoryCountOutputType 
    : S extends { select: any } & (QuizCategoryCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof QuizCategoryCountOutputType ? QuizCategoryCountOutputType[P] : never
  } 
      : QuizCategoryCountOutputType




  // Custom InputTypes

  /**
   * QuizCategoryCountOutputType without action
   */
  export type QuizCategoryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the QuizCategoryCountOutputType
     */
    select?: QuizCategoryCountOutputTypeSelect | null
  }



  /**
   * Count Type ChoiceCountOutputType
   */


  export type ChoiceCountOutputType = {
    correctQuizzes: number
    rounds: number
  }

  export type ChoiceCountOutputTypeSelect = {
    correctQuizzes?: boolean
    rounds?: boolean
  }

  export type ChoiceCountOutputTypeGetPayload<S extends boolean | null | undefined | ChoiceCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ChoiceCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ChoiceCountOutputTypeArgs)
    ? ChoiceCountOutputType 
    : S extends { select: any } & (ChoiceCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ChoiceCountOutputType ? ChoiceCountOutputType[P] : never
  } 
      : ChoiceCountOutputType




  // Custom InputTypes

  /**
   * ChoiceCountOutputType without action
   */
  export type ChoiceCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ChoiceCountOutputType
     */
    select?: ChoiceCountOutputTypeSelect | null
  }



  /**
   * Count Type QuizCountOutputType
   */


  export type QuizCountOutputType = {
    choices: number
    rounds: number
  }

  export type QuizCountOutputTypeSelect = {
    choices?: boolean
    rounds?: boolean
  }

  export type QuizCountOutputTypeGetPayload<S extends boolean | null | undefined | QuizCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? QuizCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (QuizCountOutputTypeArgs)
    ? QuizCountOutputType 
    : S extends { select: any } & (QuizCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof QuizCountOutputType ? QuizCountOutputType[P] : never
  } 
      : QuizCountOutputType




  // Custom InputTypes

  /**
   * QuizCountOutputType without action
   */
  export type QuizCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the QuizCountOutputType
     */
    select?: QuizCountOutputTypeSelect | null
  }



  /**
   * Count Type RoundCountOutputType
   */


  export type RoundCountOutputType = {
    quizzes: number
    selectedChoices: number
  }

  export type RoundCountOutputTypeSelect = {
    quizzes?: boolean
    selectedChoices?: boolean
  }

  export type RoundCountOutputTypeGetPayload<S extends boolean | null | undefined | RoundCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RoundCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (RoundCountOutputTypeArgs)
    ? RoundCountOutputType 
    : S extends { select: any } & (RoundCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof RoundCountOutputType ? RoundCountOutputType[P] : never
  } 
      : RoundCountOutputType




  // Custom InputTypes

  /**
   * RoundCountOutputType without action
   */
  export type RoundCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RoundCountOutputType
     */
    select?: RoundCountOutputTypeSelect | null
  }



  /**
   * Count Type BinWashUserCountOutputType
   */


  export type BinWashUserCountOutputType = {
    owningBranches: number
    wMMaintenanceRecords: number
    usageRecords: number
    topUpRecords: number
  }

  export type BinWashUserCountOutputTypeSelect = {
    owningBranches?: boolean
    wMMaintenanceRecords?: boolean
    usageRecords?: boolean
    topUpRecords?: boolean
  }

  export type BinWashUserCountOutputTypeGetPayload<S extends boolean | null | undefined | BinWashUserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BinWashUserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (BinWashUserCountOutputTypeArgs)
    ? BinWashUserCountOutputType 
    : S extends { select: any } & (BinWashUserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof BinWashUserCountOutputType ? BinWashUserCountOutputType[P] : never
  } 
      : BinWashUserCountOutputType




  // Custom InputTypes

  /**
   * BinWashUserCountOutputType without action
   */
  export type BinWashUserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BinWashUserCountOutputType
     */
    select?: BinWashUserCountOutputTypeSelect | null
  }



  /**
   * Count Type BranchCountOutputType
   */


  export type BranchCountOutputType = {
    washingMachines: number
  }

  export type BranchCountOutputTypeSelect = {
    washingMachines?: boolean
  }

  export type BranchCountOutputTypeGetPayload<S extends boolean | null | undefined | BranchCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BranchCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (BranchCountOutputTypeArgs)
    ? BranchCountOutputType 
    : S extends { select: any } & (BranchCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof BranchCountOutputType ? BranchCountOutputType[P] : never
  } 
      : BranchCountOutputType




  // Custom InputTypes

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BranchCountOutputType
     */
    select?: BranchCountOutputTypeSelect | null
  }



  /**
   * Count Type WashingMachineCountOutputType
   */


  export type WashingMachineCountOutputType = {
    equippedPrograms: number
    usageRecords: number
    wMMaintenanceRecords: number
  }

  export type WashingMachineCountOutputTypeSelect = {
    equippedPrograms?: boolean
    usageRecords?: boolean
    wMMaintenanceRecords?: boolean
  }

  export type WashingMachineCountOutputTypeGetPayload<S extends boolean | null | undefined | WashingMachineCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? WashingMachineCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (WashingMachineCountOutputTypeArgs)
    ? WashingMachineCountOutputType 
    : S extends { select: any } & (WashingMachineCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof WashingMachineCountOutputType ? WashingMachineCountOutputType[P] : never
  } 
      : WashingMachineCountOutputType




  // Custom InputTypes

  /**
   * WashingMachineCountOutputType without action
   */
  export type WashingMachineCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the WashingMachineCountOutputType
     */
    select?: WashingMachineCountOutputTypeSelect | null
  }



  /**
   * Count Type WMProgramCountOutputType
   */


  export type WMProgramCountOutputType = {
    equippingWMs: number
    usageRecords: number
  }

  export type WMProgramCountOutputTypeSelect = {
    equippingWMs?: boolean
    usageRecords?: boolean
  }

  export type WMProgramCountOutputTypeGetPayload<S extends boolean | null | undefined | WMProgramCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? WMProgramCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (WMProgramCountOutputTypeArgs)
    ? WMProgramCountOutputType 
    : S extends { select: any } & (WMProgramCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof WMProgramCountOutputType ? WMProgramCountOutputType[P] : never
  } 
      : WMProgramCountOutputType




  // Custom InputTypes

  /**
   * WMProgramCountOutputType without action
   */
  export type WMProgramCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the WMProgramCountOutputType
     */
    select?: WMProgramCountOutputTypeSelect | null
  }



  /**
   * Count Type FacebookUserCountOutputType
   */


  export type FacebookUserCountOutputType = {
    followingUserRelations: number
    followedUserRelations: number
    posts: number
    comments: number
    messengerMessagesFrom: number
    messengerMessagesTo: number
  }

  export type FacebookUserCountOutputTypeSelect = {
    followingUserRelations?: boolean
    followedUserRelations?: boolean
    posts?: boolean
    comments?: boolean
    messengerMessagesFrom?: boolean
    messengerMessagesTo?: boolean
  }

  export type FacebookUserCountOutputTypeGetPayload<S extends boolean | null | undefined | FacebookUserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FacebookUserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (FacebookUserCountOutputTypeArgs)
    ? FacebookUserCountOutputType 
    : S extends { select: any } & (FacebookUserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof FacebookUserCountOutputType ? FacebookUserCountOutputType[P] : never
  } 
      : FacebookUserCountOutputType




  // Custom InputTypes

  /**
   * FacebookUserCountOutputType without action
   */
  export type FacebookUserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the FacebookUserCountOutputType
     */
    select?: FacebookUserCountOutputTypeSelect | null
  }



  /**
   * Count Type PostCountOutputType
   */


  export type PostCountOutputType = {
    comments: number
    hashTags: number
  }

  export type PostCountOutputTypeSelect = {
    comments?: boolean
    hashTags?: boolean
  }

  export type PostCountOutputTypeGetPayload<S extends boolean | null | undefined | PostCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PostCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (PostCountOutputTypeArgs)
    ? PostCountOutputType 
    : S extends { select: any } & (PostCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof PostCountOutputType ? PostCountOutputType[P] : never
  } 
      : PostCountOutputType




  // Custom InputTypes

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PostCountOutputType
     */
    select?: PostCountOutputTypeSelect | null
  }



  /**
   * Count Type CommentCountOutputType
   */


  export type CommentCountOutputType = {
    childComments: number
  }

  export type CommentCountOutputTypeSelect = {
    childComments?: boolean
  }

  export type CommentCountOutputTypeGetPayload<S extends boolean | null | undefined | CommentCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CommentCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CommentCountOutputTypeArgs)
    ? CommentCountOutputType 
    : S extends { select: any } & (CommentCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CommentCountOutputType ? CommentCountOutputType[P] : never
  } 
      : CommentCountOutputType




  // Custom InputTypes

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect | null
  }



  /**
   * Count Type FacebookHashTagCountOutputType
   */


  export type FacebookHashTagCountOutputType = {
    isInPosts: number
  }

  export type FacebookHashTagCountOutputTypeSelect = {
    isInPosts?: boolean
  }

  export type FacebookHashTagCountOutputTypeGetPayload<S extends boolean | null | undefined | FacebookHashTagCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FacebookHashTagCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (FacebookHashTagCountOutputTypeArgs)
    ? FacebookHashTagCountOutputType 
    : S extends { select: any } & (FacebookHashTagCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof FacebookHashTagCountOutputType ? FacebookHashTagCountOutputType[P] : never
  } 
      : FacebookHashTagCountOutputType




  // Custom InputTypes

  /**
   * FacebookHashTagCountOutputType without action
   */
  export type FacebookHashTagCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the FacebookHashTagCountOutputType
     */
    select?: FacebookHashTagCountOutputTypeSelect | null
  }



  /**
   * Count Type AuthorCountOutputType
   */


  export type AuthorCountOutputType = {
    bookTitles: number
  }

  export type AuthorCountOutputTypeSelect = {
    bookTitles?: boolean
  }

  export type AuthorCountOutputTypeGetPayload<S extends boolean | null | undefined | AuthorCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? AuthorCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (AuthorCountOutputTypeArgs)
    ? AuthorCountOutputType 
    : S extends { select: any } & (AuthorCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof AuthorCountOutputType ? AuthorCountOutputType[P] : never
  } 
      : AuthorCountOutputType




  // Custom InputTypes

  /**
   * AuthorCountOutputType without action
   */
  export type AuthorCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the AuthorCountOutputType
     */
    select?: AuthorCountOutputTypeSelect | null
  }



  /**
   * Count Type BookTitleCountOutputType
   */


  export type BookTitleCountOutputType = {
    authors: number
    categories: number
    books: number
    requestRecords: number
  }

  export type BookTitleCountOutputTypeSelect = {
    authors?: boolean
    categories?: boolean
    books?: boolean
    requestRecords?: boolean
  }

  export type BookTitleCountOutputTypeGetPayload<S extends boolean | null | undefined | BookTitleCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BookTitleCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (BookTitleCountOutputTypeArgs)
    ? BookTitleCountOutputType 
    : S extends { select: any } & (BookTitleCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof BookTitleCountOutputType ? BookTitleCountOutputType[P] : never
  } 
      : BookTitleCountOutputType




  // Custom InputTypes

  /**
   * BookTitleCountOutputType without action
   */
  export type BookTitleCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BookTitleCountOutputType
     */
    select?: BookTitleCountOutputTypeSelect | null
  }



  /**
   * Count Type BookCategoryCountOutputType
   */


  export type BookCategoryCountOutputType = {
    bookTitles: number
  }

  export type BookCategoryCountOutputTypeSelect = {
    bookTitles?: boolean
  }

  export type BookCategoryCountOutputTypeGetPayload<S extends boolean | null | undefined | BookCategoryCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BookCategoryCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (BookCategoryCountOutputTypeArgs)
    ? BookCategoryCountOutputType 
    : S extends { select: any } & (BookCategoryCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof BookCategoryCountOutputType ? BookCategoryCountOutputType[P] : never
  } 
      : BookCategoryCountOutputType




  // Custom InputTypes

  /**
   * BookCategoryCountOutputType without action
   */
  export type BookCategoryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BookCategoryCountOutputType
     */
    select?: BookCategoryCountOutputTypeSelect | null
  }



  /**
   * Count Type BookCountOutputType
   */


  export type BookCountOutputType = {
    borrowingRecords: number
    requestRecords: number
  }

  export type BookCountOutputTypeSelect = {
    borrowingRecords?: boolean
    requestRecords?: boolean
  }

  export type BookCountOutputTypeGetPayload<S extends boolean | null | undefined | BookCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BookCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (BookCountOutputTypeArgs)
    ? BookCountOutputType 
    : S extends { select: any } & (BookCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof BookCountOutputType ? BookCountOutputType[P] : never
  } 
      : BookCountOutputType




  // Custom InputTypes

  /**
   * BookCountOutputType without action
   */
  export type BookCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BookCountOutputType
     */
    select?: BookCountOutputTypeSelect | null
  }



  /**
   * Count Type LibraryCountOutputType
   */


  export type LibraryCountOutputType = {
    books: number
    requestingRecords: number
    requestedRecords: number
  }

  export type LibraryCountOutputTypeSelect = {
    books?: boolean
    requestingRecords?: boolean
    requestedRecords?: boolean
  }

  export type LibraryCountOutputTypeGetPayload<S extends boolean | null | undefined | LibraryCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LibraryCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (LibraryCountOutputTypeArgs)
    ? LibraryCountOutputType 
    : S extends { select: any } & (LibraryCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof LibraryCountOutputType ? LibraryCountOutputType[P] : never
  } 
      : LibraryCountOutputType




  // Custom InputTypes

  /**
   * LibraryCountOutputType without action
   */
  export type LibraryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the LibraryCountOutputType
     */
    select?: LibraryCountOutputTypeSelect | null
  }



  /**
   * Count Type UniversityCountOutputType
   */


  export type UniversityCountOutputType = {
    libraries: number
    students: number
  }

  export type UniversityCountOutputTypeSelect = {
    libraries?: boolean
    students?: boolean
  }

  export type UniversityCountOutputTypeGetPayload<S extends boolean | null | undefined | UniversityCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UniversityCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (UniversityCountOutputTypeArgs)
    ? UniversityCountOutputType 
    : S extends { select: any } & (UniversityCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof UniversityCountOutputType ? UniversityCountOutputType[P] : never
  } 
      : UniversityCountOutputType




  // Custom InputTypes

  /**
   * UniversityCountOutputType without action
   */
  export type UniversityCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UniversityCountOutputType
     */
    select?: UniversityCountOutputTypeSelect | null
  }



  /**
   * Count Type StudentCountOutputType
   */


  export type StudentCountOutputType = {
    borrowingRecords: number
    requestRecords: number
  }

  export type StudentCountOutputTypeSelect = {
    borrowingRecords?: boolean
    requestRecords?: boolean
  }

  export type StudentCountOutputTypeGetPayload<S extends boolean | null | undefined | StudentCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? StudentCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (StudentCountOutputTypeArgs)
    ? StudentCountOutputType 
    : S extends { select: any } & (StudentCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof StudentCountOutputType ? StudentCountOutputType[P] : never
  } 
      : StudentCountOutputType




  // Custom InputTypes

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the StudentCountOutputType
     */
    select?: StudentCountOutputTypeSelect | null
  }



  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    followingUserRelations: number
    followedUserRelations: number
    tweets: number
    directMessagesFrom: number
    directMessagesTo: number
  }

  export type UserCountOutputTypeSelect = {
    followingUserRelations?: boolean
    followedUserRelations?: boolean
    tweets?: boolean
    directMessagesFrom?: boolean
    directMessagesTo?: boolean
  }

  export type UserCountOutputTypeGetPayload<S extends boolean | null | undefined | UserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (UserCountOutputTypeArgs)
    ? UserCountOutputType 
    : S extends { select: any } & (UserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
      : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type TweetCountOutputType
   */


  export type TweetCountOutputType = {
    childTweets: number
    hashTags: number
  }

  export type TweetCountOutputTypeSelect = {
    childTweets?: boolean
    hashTags?: boolean
  }

  export type TweetCountOutputTypeGetPayload<S extends boolean | null | undefined | TweetCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TweetCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TweetCountOutputTypeArgs)
    ? TweetCountOutputType 
    : S extends { select: any } & (TweetCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TweetCountOutputType ? TweetCountOutputType[P] : never
  } 
      : TweetCountOutputType




  // Custom InputTypes

  /**
   * TweetCountOutputType without action
   */
  export type TweetCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TweetCountOutputType
     */
    select?: TweetCountOutputTypeSelect | null
  }



  /**
   * Count Type HashTagCountOutputType
   */


  export type HashTagCountOutputType = {
    isInTweets: number
  }

  export type HashTagCountOutputTypeSelect = {
    isInTweets?: boolean
  }

  export type HashTagCountOutputTypeGetPayload<S extends boolean | null | undefined | HashTagCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? HashTagCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (HashTagCountOutputTypeArgs)
    ? HashTagCountOutputType 
    : S extends { select: any } & (HashTagCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof HashTagCountOutputType ? HashTagCountOutputType[P] : never
  } 
      : HashTagCountOutputType




  // Custom InputTypes

  /**
   * HashTagCountOutputType without action
   */
  export type HashTagCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the HashTagCountOutputType
     */
    select?: HashTagCountOutputTypeSelect | null
  }



  /**
   * Count Type YouTubeUserCountOutputType
   */


  export type YouTubeUserCountOutputType = {
    adminOfChannels: number
    usersToChannelswithRoles: number
    subscribingToChannels: number
    reactedVideos: number
    usersToVideosWithReactions: number
    videoComments: number
  }

  export type YouTubeUserCountOutputTypeSelect = {
    adminOfChannels?: boolean
    usersToChannelswithRoles?: boolean
    subscribingToChannels?: boolean
    reactedVideos?: boolean
    usersToVideosWithReactions?: boolean
    videoComments?: boolean
  }

  export type YouTubeUserCountOutputTypeGetPayload<S extends boolean | null | undefined | YouTubeUserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YouTubeUserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (YouTubeUserCountOutputTypeArgs)
    ? YouTubeUserCountOutputType 
    : S extends { select: any } & (YouTubeUserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof YouTubeUserCountOutputType ? YouTubeUserCountOutputType[P] : never
  } 
      : YouTubeUserCountOutputType




  // Custom InputTypes

  /**
   * YouTubeUserCountOutputType without action
   */
  export type YouTubeUserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the YouTubeUserCountOutputType
     */
    select?: YouTubeUserCountOutputTypeSelect | null
  }



  /**
   * Count Type ChannelCountOutputType
   */


  export type ChannelCountOutputType = {
    adminUsers: number
    subscribedUsers: number
    usersToChannelswithRoles: number
    owningVideos: number
  }

  export type ChannelCountOutputTypeSelect = {
    adminUsers?: boolean
    subscribedUsers?: boolean
    usersToChannelswithRoles?: boolean
    owningVideos?: boolean
  }

  export type ChannelCountOutputTypeGetPayload<S extends boolean | null | undefined | ChannelCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ChannelCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ChannelCountOutputTypeArgs)
    ? ChannelCountOutputType 
    : S extends { select: any } & (ChannelCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ChannelCountOutputType ? ChannelCountOutputType[P] : never
  } 
      : ChannelCountOutputType




  // Custom InputTypes

  /**
   * ChannelCountOutputType without action
   */
  export type ChannelCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ChannelCountOutputType
     */
    select?: ChannelCountOutputTypeSelect | null
  }



  /**
   * Count Type VideoCountOutputType
   */


  export type VideoCountOutputType = {
    reactedByYouTubeUsers: number
    usersToVideosWithReactions: number
    videoComments: number
  }

  export type VideoCountOutputTypeSelect = {
    reactedByYouTubeUsers?: boolean
    usersToVideosWithReactions?: boolean
    videoComments?: boolean
  }

  export type VideoCountOutputTypeGetPayload<S extends boolean | null | undefined | VideoCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? VideoCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (VideoCountOutputTypeArgs)
    ? VideoCountOutputType 
    : S extends { select: any } & (VideoCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof VideoCountOutputType ? VideoCountOutputType[P] : never
  } 
      : VideoCountOutputType




  // Custom InputTypes

  /**
   * VideoCountOutputType without action
   */
  export type VideoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the VideoCountOutputType
     */
    select?: VideoCountOutputTypeSelect | null
  }



  /**
   * Count Type VideoCommentCountOutputType
   */


  export type VideoCommentCountOutputType = {
    childVideoComments: number
  }

  export type VideoCommentCountOutputTypeSelect = {
    childVideoComments?: boolean
  }

  export type VideoCommentCountOutputTypeGetPayload<S extends boolean | null | undefined | VideoCommentCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? VideoCommentCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (VideoCommentCountOutputTypeArgs)
    ? VideoCommentCountOutputType 
    : S extends { select: any } & (VideoCommentCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof VideoCommentCountOutputType ? VideoCommentCountOutputType[P] : never
  } 
      : VideoCommentCountOutputType




  // Custom InputTypes

  /**
   * VideoCommentCountOutputType without action
   */
  export type VideoCommentCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the VideoCommentCountOutputType
     */
    select?: VideoCommentCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model Category
   */


  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type CategorySumAggregateOutputType = {
    id: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    id?: true
  }

  export type CategorySumAggregateInputType = {
    id?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: Enumerable<CategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs = {
    where?: CategoryWhereInput
    orderBy?: Enumerable<CategoryOrderByWithAggregationInput>
    by: CategoryScalarFieldEnum[]
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }


  export type CategoryGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Menu?: boolean | Category$MenuArgs
    _count?: boolean | CategoryCountOutputTypeArgs
  }


  export type CategoryInclude = {
    Menu?: boolean | Category$MenuArgs
    _count?: boolean | CategoryCountOutputTypeArgs
  }

  export type CategoryGetPayload<S extends boolean | null | undefined | CategoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Category :
    S extends undefined ? never :
    S extends { include: any } & (CategoryArgs | CategoryFindManyArgs)
    ? Category  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Menu' ? Array < MenuGetPayload<S['include'][P]>>  :
        P extends '_count' ? CategoryCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CategoryArgs | CategoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Menu' ? Array < MenuGetPayload<S['select'][P]>>  :
        P extends '_count' ? CategoryCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Category ? Category[P] : never
  } 
      : Category


  type CategoryCountArgs = 
    Omit<CategoryFindManyArgs, 'select' | 'include'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CategoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CategoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Category'> extends True ? Prisma__CategoryClient<CategoryGetPayload<T>> : Prisma__CategoryClient<CategoryGetPayload<T> | null, null>

    /**
     * Find one Category that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CategoryFindUniqueOrThrowArgs>
    ): Prisma__CategoryClient<CategoryGetPayload<T>>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CategoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CategoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Category'> extends True ? Prisma__CategoryClient<CategoryGetPayload<T>> : Prisma__CategoryClient<CategoryGetPayload<T> | null, null>

    /**
     * Find the first Category that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CategoryFindFirstOrThrowArgs>
    ): Prisma__CategoryClient<CategoryGetPayload<T>>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CategoryFindManyArgs>(
      args?: SelectSubset<T, CategoryFindManyArgs>
    ): Prisma.PrismaPromise<Array<CategoryGetPayload<T>>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
    **/
    create<T extends CategoryCreateArgs>(
      args: SelectSubset<T, CategoryCreateArgs>
    ): Prisma__CategoryClient<CategoryGetPayload<T>>

    /**
     * Create many Categories.
     *     @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     *     @example
     *     // Create many Categories
     *     const category = await prisma.category.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CategoryCreateManyArgs>(
      args?: SelectSubset<T, CategoryCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
    **/
    delete<T extends CategoryDeleteArgs>(
      args: SelectSubset<T, CategoryDeleteArgs>
    ): Prisma__CategoryClient<CategoryGetPayload<T>>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CategoryUpdateArgs>(
      args: SelectSubset<T, CategoryUpdateArgs>
    ): Prisma__CategoryClient<CategoryGetPayload<T>>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CategoryDeleteManyArgs>(
      args?: SelectSubset<T, CategoryDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CategoryUpdateManyArgs>(
      args: SelectSubset<T, CategoryUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
    **/
    upsert<T extends CategoryUpsertArgs>(
      args: SelectSubset<T, CategoryUpsertArgs>
    ): Prisma__CategoryClient<CategoryGetPayload<T>>

    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CategoryClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Menu<T extends Category$MenuArgs= {}>(args?: Subset<T, Category$MenuArgs>): Prisma.PrismaPromise<Array<MenuGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Category base type for findUnique actions
   */
  export type CategoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUnique
   */
  export interface CategoryFindUniqueArgs extends CategoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }


  /**
   * Category base type for findFirst actions
   */
  export type CategoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: Enumerable<CategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }

  /**
   * Category findFirst
   */
  export interface CategoryFindFirstArgs extends CategoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: Enumerable<CategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }


  /**
   * Category findMany
   */
  export type CategoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: Enumerable<CategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }


  /**
   * Category create
   */
  export type CategoryCreateArgs = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }


  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs = {
    /**
     * The data used to create many Categories.
     */
    data: Enumerable<CategoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Category update
   */
  export type CategoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }


  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
  }


  /**
   * Category upsert
   */
  export type CategoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }


  /**
   * Category delete
   */
  export type CategoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }


  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
  }


  /**
   * Category.Menu
   */
  export type Category$MenuArgs = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MenuInclude | null
    where?: MenuWhereInput
    orderBy?: Enumerable<MenuOrderByWithRelationInput>
    cursor?: MenuWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MenuScalarFieldEnum>
  }


  /**
   * Category without action
   */
  export type CategoryArgs = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude | null
  }



  /**
   * Model Menu
   */


  export type AggregateMenu = {
    _count: MenuCountAggregateOutputType | null
    _avg: MenuAvgAggregateOutputType | null
    _sum: MenuSumAggregateOutputType | null
    _min: MenuMinAggregateOutputType | null
    _max: MenuMaxAggregateOutputType | null
  }

  export type MenuAvgAggregateOutputType = {
    id: number | null
    price: number | null
    categoryId: number | null
  }

  export type MenuSumAggregateOutputType = {
    id: number | null
    price: number | null
    categoryId: number | null
  }

  export type MenuMinAggregateOutputType = {
    id: number | null
    name: string | null
    image: string | null
    price: number | null
    categoryId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MenuMaxAggregateOutputType = {
    id: number | null
    name: string | null
    image: string | null
    price: number | null
    categoryId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MenuCountAggregateOutputType = {
    id: number
    name: number
    image: number
    price: number
    categoryId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MenuAvgAggregateInputType = {
    id?: true
    price?: true
    categoryId?: true
  }

  export type MenuSumAggregateInputType = {
    id?: true
    price?: true
    categoryId?: true
  }

  export type MenuMinAggregateInputType = {
    id?: true
    name?: true
    image?: true
    price?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MenuMaxAggregateInputType = {
    id?: true
    name?: true
    image?: true
    price?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MenuCountAggregateInputType = {
    id?: true
    name?: true
    image?: true
    price?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MenuAggregateArgs = {
    /**
     * Filter which Menu to aggregate.
     */
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Menus to fetch.
     */
    orderBy?: Enumerable<MenuOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Menus
    **/
    _count?: true | MenuCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MenuAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MenuSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MenuMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MenuMaxAggregateInputType
  }

  export type GetMenuAggregateType<T extends MenuAggregateArgs> = {
        [P in keyof T & keyof AggregateMenu]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenu[P]>
      : GetScalarType<T[P], AggregateMenu[P]>
  }




  export type MenuGroupByArgs = {
    where?: MenuWhereInput
    orderBy?: Enumerable<MenuOrderByWithAggregationInput>
    by: MenuScalarFieldEnum[]
    having?: MenuScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MenuCountAggregateInputType | true
    _avg?: MenuAvgAggregateInputType
    _sum?: MenuSumAggregateInputType
    _min?: MenuMinAggregateInputType
    _max?: MenuMaxAggregateInputType
  }


  export type MenuGroupByOutputType = {
    id: number
    name: string
    image: string
    price: number
    categoryId: number | null
    createdAt: Date
    updatedAt: Date
    _count: MenuCountAggregateOutputType | null
    _avg: MenuAvgAggregateOutputType | null
    _sum: MenuSumAggregateOutputType | null
    _min: MenuMinAggregateOutputType | null
    _max: MenuMaxAggregateOutputType | null
  }

  type GetMenuGroupByPayload<T extends MenuGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MenuGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MenuGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MenuGroupByOutputType[P]>
            : GetScalarType<T[P], MenuGroupByOutputType[P]>
        }
      >
    >


  export type MenuSelect = {
    id?: boolean
    name?: boolean
    image?: boolean
    price?: boolean
    category?: boolean | CategoryArgs
    categoryId?: boolean
    orderItems?: boolean | Menu$orderItemsArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | MenuCountOutputTypeArgs
  }


  export type MenuInclude = {
    category?: boolean | CategoryArgs
    orderItems?: boolean | Menu$orderItemsArgs
    _count?: boolean | MenuCountOutputTypeArgs
  }

  export type MenuGetPayload<S extends boolean | null | undefined | MenuArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Menu :
    S extends undefined ? never :
    S extends { include: any } & (MenuArgs | MenuFindManyArgs)
    ? Menu  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'category' ? CategoryGetPayload<S['include'][P]> | null :
        P extends 'orderItems' ? Array < OrderItemGetPayload<S['include'][P]>>  :
        P extends '_count' ? MenuCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (MenuArgs | MenuFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'category' ? CategoryGetPayload<S['select'][P]> | null :
        P extends 'orderItems' ? Array < OrderItemGetPayload<S['select'][P]>>  :
        P extends '_count' ? MenuCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Menu ? Menu[P] : never
  } 
      : Menu


  type MenuCountArgs = 
    Omit<MenuFindManyArgs, 'select' | 'include'> & {
      select?: MenuCountAggregateInputType | true
    }

  export interface MenuDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Menu that matches the filter.
     * @param {MenuFindUniqueArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MenuFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MenuFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Menu'> extends True ? Prisma__MenuClient<MenuGetPayload<T>> : Prisma__MenuClient<MenuGetPayload<T> | null, null>

    /**
     * Find one Menu that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MenuFindUniqueOrThrowArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MenuFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MenuFindUniqueOrThrowArgs>
    ): Prisma__MenuClient<MenuGetPayload<T>>

    /**
     * Find the first Menu that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuFindFirstArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MenuFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MenuFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Menu'> extends True ? Prisma__MenuClient<MenuGetPayload<T>> : Prisma__MenuClient<MenuGetPayload<T> | null, null>

    /**
     * Find the first Menu that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuFindFirstOrThrowArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MenuFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MenuFindFirstOrThrowArgs>
    ): Prisma__MenuClient<MenuGetPayload<T>>

    /**
     * Find zero or more Menus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Menus
     * const menus = await prisma.menu.findMany()
     * 
     * // Get first 10 Menus
     * const menus = await prisma.menu.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const menuWithIdOnly = await prisma.menu.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MenuFindManyArgs>(
      args?: SelectSubset<T, MenuFindManyArgs>
    ): Prisma.PrismaPromise<Array<MenuGetPayload<T>>>

    /**
     * Create a Menu.
     * @param {MenuCreateArgs} args - Arguments to create a Menu.
     * @example
     * // Create one Menu
     * const Menu = await prisma.menu.create({
     *   data: {
     *     // ... data to create a Menu
     *   }
     * })
     * 
    **/
    create<T extends MenuCreateArgs>(
      args: SelectSubset<T, MenuCreateArgs>
    ): Prisma__MenuClient<MenuGetPayload<T>>

    /**
     * Create many Menus.
     *     @param {MenuCreateManyArgs} args - Arguments to create many Menus.
     *     @example
     *     // Create many Menus
     *     const menu = await prisma.menu.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MenuCreateManyArgs>(
      args?: SelectSubset<T, MenuCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Menu.
     * @param {MenuDeleteArgs} args - Arguments to delete one Menu.
     * @example
     * // Delete one Menu
     * const Menu = await prisma.menu.delete({
     *   where: {
     *     // ... filter to delete one Menu
     *   }
     * })
     * 
    **/
    delete<T extends MenuDeleteArgs>(
      args: SelectSubset<T, MenuDeleteArgs>
    ): Prisma__MenuClient<MenuGetPayload<T>>

    /**
     * Update one Menu.
     * @param {MenuUpdateArgs} args - Arguments to update one Menu.
     * @example
     * // Update one Menu
     * const menu = await prisma.menu.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MenuUpdateArgs>(
      args: SelectSubset<T, MenuUpdateArgs>
    ): Prisma__MenuClient<MenuGetPayload<T>>

    /**
     * Delete zero or more Menus.
     * @param {MenuDeleteManyArgs} args - Arguments to filter Menus to delete.
     * @example
     * // Delete a few Menus
     * const { count } = await prisma.menu.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MenuDeleteManyArgs>(
      args?: SelectSubset<T, MenuDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Menus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Menus
     * const menu = await prisma.menu.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MenuUpdateManyArgs>(
      args: SelectSubset<T, MenuUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Menu.
     * @param {MenuUpsertArgs} args - Arguments to update or create a Menu.
     * @example
     * // Update or create a Menu
     * const menu = await prisma.menu.upsert({
     *   create: {
     *     // ... data to create a Menu
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Menu we want to update
     *   }
     * })
    **/
    upsert<T extends MenuUpsertArgs>(
      args: SelectSubset<T, MenuUpsertArgs>
    ): Prisma__MenuClient<MenuGetPayload<T>>

    /**
     * Count the number of Menus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuCountArgs} args - Arguments to filter Menus to count.
     * @example
     * // Count the number of Menus
     * const count = await prisma.menu.count({
     *   where: {
     *     // ... the filter for the Menus we want to count
     *   }
     * })
    **/
    count<T extends MenuCountArgs>(
      args?: Subset<T, MenuCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenuCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Menu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MenuAggregateArgs>(args: Subset<T, MenuAggregateArgs>): Prisma.PrismaPromise<GetMenuAggregateType<T>>

    /**
     * Group by Menu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MenuGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MenuGroupByArgs['orderBy'] }
        : { orderBy?: MenuGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MenuGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenuGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Menu.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MenuClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    category<T extends CategoryArgs= {}>(args?: Subset<T, CategoryArgs>): Prisma__CategoryClient<CategoryGetPayload<T> | Null>;

    orderItems<T extends Menu$orderItemsArgs= {}>(args?: Subset<T, Menu$orderItemsArgs>): Prisma.PrismaPromise<Array<OrderItemGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Menu base type for findUnique actions
   */
  export type MenuFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MenuInclude | null
    /**
     * Filter, which Menu to fetch.
     */
    where: MenuWhereUniqueInput
  }

  /**
   * Menu findUnique
   */
  export interface MenuFindUniqueArgs extends MenuFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Menu findUniqueOrThrow
   */
  export type MenuFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MenuInclude | null
    /**
     * Filter, which Menu to fetch.
     */
    where: MenuWhereUniqueInput
  }


  /**
   * Menu base type for findFirst actions
   */
  export type MenuFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MenuInclude | null
    /**
     * Filter, which Menu to fetch.
     */
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Menus to fetch.
     */
    orderBy?: Enumerable<MenuOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Menus.
     */
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Menus.
     */
    distinct?: Enumerable<MenuScalarFieldEnum>
  }

  /**
   * Menu findFirst
   */
  export interface MenuFindFirstArgs extends MenuFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Menu findFirstOrThrow
   */
  export type MenuFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MenuInclude | null
    /**
     * Filter, which Menu to fetch.
     */
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Menus to fetch.
     */
    orderBy?: Enumerable<MenuOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Menus.
     */
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Menus.
     */
    distinct?: Enumerable<MenuScalarFieldEnum>
  }


  /**
   * Menu findMany
   */
  export type MenuFindManyArgs = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MenuInclude | null
    /**
     * Filter, which Menus to fetch.
     */
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Menus to fetch.
     */
    orderBy?: Enumerable<MenuOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Menus.
     */
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Menus.
     */
    skip?: number
    distinct?: Enumerable<MenuScalarFieldEnum>
  }


  /**
   * Menu create
   */
  export type MenuCreateArgs = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MenuInclude | null
    /**
     * The data needed to create a Menu.
     */
    data: XOR<MenuCreateInput, MenuUncheckedCreateInput>
  }


  /**
   * Menu createMany
   */
  export type MenuCreateManyArgs = {
    /**
     * The data used to create many Menus.
     */
    data: Enumerable<MenuCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Menu update
   */
  export type MenuUpdateArgs = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MenuInclude | null
    /**
     * The data needed to update a Menu.
     */
    data: XOR<MenuUpdateInput, MenuUncheckedUpdateInput>
    /**
     * Choose, which Menu to update.
     */
    where: MenuWhereUniqueInput
  }


  /**
   * Menu updateMany
   */
  export type MenuUpdateManyArgs = {
    /**
     * The data used to update Menus.
     */
    data: XOR<MenuUpdateManyMutationInput, MenuUncheckedUpdateManyInput>
    /**
     * Filter which Menus to update
     */
    where?: MenuWhereInput
  }


  /**
   * Menu upsert
   */
  export type MenuUpsertArgs = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MenuInclude | null
    /**
     * The filter to search for the Menu to update in case it exists.
     */
    where: MenuWhereUniqueInput
    /**
     * In case the Menu found by the `where` argument doesn't exist, create a new Menu with this data.
     */
    create: XOR<MenuCreateInput, MenuUncheckedCreateInput>
    /**
     * In case the Menu was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MenuUpdateInput, MenuUncheckedUpdateInput>
  }


  /**
   * Menu delete
   */
  export type MenuDeleteArgs = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MenuInclude | null
    /**
     * Filter which Menu to delete.
     */
    where: MenuWhereUniqueInput
  }


  /**
   * Menu deleteMany
   */
  export type MenuDeleteManyArgs = {
    /**
     * Filter which Menus to delete
     */
    where?: MenuWhereInput
  }


  /**
   * Menu.orderItems
   */
  export type Menu$orderItemsArgs = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemInclude | null
    where?: OrderItemWhereInput
    orderBy?: Enumerable<OrderItemOrderByWithRelationInput>
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OrderItemScalarFieldEnum>
  }


  /**
   * Menu without action
   */
  export type MenuArgs = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MenuInclude | null
  }



  /**
   * Model Order
   */


  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    id: number | null
    tableId: number | null
  }

  export type OrderSumAggregateOutputType = {
    id: number | null
    tableId: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: number | null
    status: string | null
    tableId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: number | null
    status: string | null
    tableId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    status: number
    tableId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    id?: true
    tableId?: true
  }

  export type OrderSumAggregateInputType = {
    id?: true
    tableId?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    status?: true
    tableId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    status?: true
    tableId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    status?: true
    tableId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderAggregateArgs = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: Enumerable<OrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs = {
    where?: OrderWhereInput
    orderBy?: Enumerable<OrderOrderByWithAggregationInput>
    by: OrderScalarFieldEnum[]
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }


  export type OrderGroupByOutputType = {
    id: number
    status: string
    tableId: number
    createdAt: Date
    updatedAt: Date
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect = {
    id?: boolean
    status?: boolean
    tableId?: boolean
    items?: boolean | Order$itemsArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | OrderCountOutputTypeArgs
  }


  export type OrderInclude = {
    items?: boolean | Order$itemsArgs
    _count?: boolean | OrderCountOutputTypeArgs
  }

  export type OrderGetPayload<S extends boolean | null | undefined | OrderArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Order :
    S extends undefined ? never :
    S extends { include: any } & (OrderArgs | OrderFindManyArgs)
    ? Order  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'items' ? Array < OrderItemGetPayload<S['include'][P]>>  :
        P extends '_count' ? OrderCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (OrderArgs | OrderFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'items' ? Array < OrderItemGetPayload<S['select'][P]>>  :
        P extends '_count' ? OrderCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Order ? Order[P] : never
  } 
      : Order


  type OrderCountArgs = 
    Omit<OrderFindManyArgs, 'select' | 'include'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrderFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OrderFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Order'> extends True ? Prisma__OrderClient<OrderGetPayload<T>> : Prisma__OrderClient<OrderGetPayload<T> | null, null>

    /**
     * Find one Order that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OrderFindUniqueOrThrowArgs>
    ): Prisma__OrderClient<OrderGetPayload<T>>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrderFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OrderFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Order'> extends True ? Prisma__OrderClient<OrderGetPayload<T>> : Prisma__OrderClient<OrderGetPayload<T> | null, null>

    /**
     * Find the first Order that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OrderFindFirstOrThrowArgs>
    ): Prisma__OrderClient<OrderGetPayload<T>>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrderFindManyArgs>(
      args?: SelectSubset<T, OrderFindManyArgs>
    ): Prisma.PrismaPromise<Array<OrderGetPayload<T>>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
    **/
    create<T extends OrderCreateArgs>(
      args: SelectSubset<T, OrderCreateArgs>
    ): Prisma__OrderClient<OrderGetPayload<T>>

    /**
     * Create many Orders.
     *     @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     *     @example
     *     // Create many Orders
     *     const order = await prisma.order.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrderCreateManyArgs>(
      args?: SelectSubset<T, OrderCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
    **/
    delete<T extends OrderDeleteArgs>(
      args: SelectSubset<T, OrderDeleteArgs>
    ): Prisma__OrderClient<OrderGetPayload<T>>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrderUpdateArgs>(
      args: SelectSubset<T, OrderUpdateArgs>
    ): Prisma__OrderClient<OrderGetPayload<T>>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrderDeleteManyArgs>(
      args?: SelectSubset<T, OrderDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrderUpdateManyArgs>(
      args: SelectSubset<T, OrderUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
    **/
    upsert<T extends OrderUpsertArgs>(
      args: SelectSubset<T, OrderUpsertArgs>
    ): Prisma__OrderClient<OrderGetPayload<T>>

    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OrderClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    items<T extends Order$itemsArgs= {}>(args?: Subset<T, Order$itemsArgs>): Prisma.PrismaPromise<Array<OrderItemGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Order base type for findUnique actions
   */
  export type OrderFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUnique
   */
  export interface OrderFindUniqueArgs extends OrderFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }


  /**
   * Order base type for findFirst actions
   */
  export type OrderFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: Enumerable<OrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: Enumerable<OrderScalarFieldEnum>
  }

  /**
   * Order findFirst
   */
  export interface OrderFindFirstArgs extends OrderFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: Enumerable<OrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: Enumerable<OrderScalarFieldEnum>
  }


  /**
   * Order findMany
   */
  export type OrderFindManyArgs = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: Enumerable<OrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: Enumerable<OrderScalarFieldEnum>
  }


  /**
   * Order create
   */
  export type OrderCreateArgs = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }


  /**
   * Order createMany
   */
  export type OrderCreateManyArgs = {
    /**
     * The data used to create many Orders.
     */
    data: Enumerable<OrderCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Order update
   */
  export type OrderUpdateArgs = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }


  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
  }


  /**
   * Order upsert
   */
  export type OrderUpsertArgs = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }


  /**
   * Order delete
   */
  export type OrderDeleteArgs = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }


  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
  }


  /**
   * Order.items
   */
  export type Order$itemsArgs = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemInclude | null
    where?: OrderItemWhereInput
    orderBy?: Enumerable<OrderItemOrderByWithRelationInput>
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OrderItemScalarFieldEnum>
  }


  /**
   * Order without action
   */
  export type OrderArgs = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude | null
  }



  /**
   * Model OrderItem
   */


  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    id: number | null
    menuId: number | null
    orderId: number | null
    quantity: number | null
    totalPrice: number | null
  }

  export type OrderItemSumAggregateOutputType = {
    id: number | null
    menuId: number | null
    orderId: number | null
    quantity: number | null
    totalPrice: number | null
  }

  export type OrderItemMinAggregateOutputType = {
    id: number | null
    menuId: number | null
    orderId: number | null
    quantity: number | null
    totalPrice: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderItemMaxAggregateOutputType = {
    id: number | null
    menuId: number | null
    orderId: number | null
    quantity: number | null
    totalPrice: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderItemCountAggregateOutputType = {
    id: number
    menuId: number
    orderId: number
    quantity: number
    totalPrice: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    id?: true
    menuId?: true
    orderId?: true
    quantity?: true
    totalPrice?: true
  }

  export type OrderItemSumAggregateInputType = {
    id?: true
    menuId?: true
    orderId?: true
    quantity?: true
    totalPrice?: true
  }

  export type OrderItemMinAggregateInputType = {
    id?: true
    menuId?: true
    orderId?: true
    quantity?: true
    totalPrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderItemMaxAggregateInputType = {
    id?: true
    menuId?: true
    orderId?: true
    quantity?: true
    totalPrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderItemCountAggregateInputType = {
    id?: true
    menuId?: true
    orderId?: true
    quantity?: true
    totalPrice?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderItemAggregateArgs = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: Enumerable<OrderItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }




  export type OrderItemGroupByArgs = {
    where?: OrderItemWhereInput
    orderBy?: Enumerable<OrderItemOrderByWithAggregationInput>
    by: OrderItemScalarFieldEnum[]
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }


  export type OrderItemGroupByOutputType = {
    id: number
    menuId: number
    orderId: number | null
    quantity: number
    totalPrice: number
    createdAt: Date
    updatedAt: Date
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<OrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemSelect = {
    id?: boolean
    menu?: boolean | MenuArgs
    menuId?: boolean
    order?: boolean | OrderArgs
    orderId?: boolean
    quantity?: boolean
    totalPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type OrderItemInclude = {
    menu?: boolean | MenuArgs
    order?: boolean | OrderArgs
  }

  export type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? OrderItem :
    S extends undefined ? never :
    S extends { include: any } & (OrderItemArgs | OrderItemFindManyArgs)
    ? OrderItem  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'menu' ? MenuGetPayload<S['include'][P]> :
        P extends 'order' ? OrderGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (OrderItemArgs | OrderItemFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'menu' ? MenuGetPayload<S['select'][P]> :
        P extends 'order' ? OrderGetPayload<S['select'][P]> | null :  P extends keyof OrderItem ? OrderItem[P] : never
  } 
      : OrderItem


  type OrderItemCountArgs = 
    Omit<OrderItemFindManyArgs, 'select' | 'include'> & {
      select?: OrderItemCountAggregateInputType | true
    }

  export interface OrderItemDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrderItemFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OrderItemFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OrderItem'> extends True ? Prisma__OrderItemClient<OrderItemGetPayload<T>> : Prisma__OrderItemClient<OrderItemGetPayload<T> | null, null>

    /**
     * Find one OrderItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OrderItemFindUniqueOrThrowArgs>
    ): Prisma__OrderItemClient<OrderItemGetPayload<T>>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrderItemFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OrderItemFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OrderItem'> extends True ? Prisma__OrderItemClient<OrderItemGetPayload<T>> : Prisma__OrderItemClient<OrderItemGetPayload<T> | null, null>

    /**
     * Find the first OrderItem that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs>
    ): Prisma__OrderItemClient<OrderItemGetPayload<T>>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrderItemFindManyArgs>(
      args?: SelectSubset<T, OrderItemFindManyArgs>
    ): Prisma.PrismaPromise<Array<OrderItemGetPayload<T>>>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
    **/
    create<T extends OrderItemCreateArgs>(
      args: SelectSubset<T, OrderItemCreateArgs>
    ): Prisma__OrderItemClient<OrderItemGetPayload<T>>

    /**
     * Create many OrderItems.
     *     @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     *     @example
     *     // Create many OrderItems
     *     const orderItem = await prisma.orderItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrderItemCreateManyArgs>(
      args?: SelectSubset<T, OrderItemCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
    **/
    delete<T extends OrderItemDeleteArgs>(
      args: SelectSubset<T, OrderItemDeleteArgs>
    ): Prisma__OrderItemClient<OrderItemGetPayload<T>>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrderItemUpdateArgs>(
      args: SelectSubset<T, OrderItemUpdateArgs>
    ): Prisma__OrderItemClient<OrderItemGetPayload<T>>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrderItemDeleteManyArgs>(
      args?: SelectSubset<T, OrderItemDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrderItemUpdateManyArgs>(
      args: SelectSubset<T, OrderItemUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
    **/
    upsert<T extends OrderItemUpsertArgs>(
      args: SelectSubset<T, OrderItemUpsertArgs>
    ): Prisma__OrderItemClient<OrderItemGetPayload<T>>

    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OrderItemClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    menu<T extends MenuArgs= {}>(args?: Subset<T, MenuArgs>): Prisma__MenuClient<MenuGetPayload<T> | Null>;

    order<T extends OrderArgs= {}>(args?: Subset<T, OrderArgs>): Prisma__OrderClient<OrderGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * OrderItem base type for findUnique actions
   */
  export type OrderItemFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemInclude | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findUnique
   */
  export interface OrderItemFindUniqueArgs extends OrderItemFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemInclude | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }


  /**
   * OrderItem base type for findFirst actions
   */
  export type OrderItemFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemInclude | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: Enumerable<OrderItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: Enumerable<OrderItemScalarFieldEnum>
  }

  /**
   * OrderItem findFirst
   */
  export interface OrderItemFindFirstArgs extends OrderItemFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemInclude | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: Enumerable<OrderItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: Enumerable<OrderItemScalarFieldEnum>
  }


  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemInclude | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: Enumerable<OrderItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: Enumerable<OrderItemScalarFieldEnum>
  }


  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemInclude | null
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }


  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs = {
    /**
     * The data used to create many OrderItems.
     */
    data: Enumerable<OrderItemCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemInclude | null
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput
  }


  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
  }


  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemInclude | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }


  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemInclude | null
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput
  }


  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput
  }


  /**
   * OrderItem without action
   */
  export type OrderItemArgs = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderItemInclude | null
  }



  /**
   * Model QuizCategory
   */


  export type AggregateQuizCategory = {
    _count: QuizCategoryCountAggregateOutputType | null
    _avg: QuizCategoryAvgAggregateOutputType | null
    _sum: QuizCategorySumAggregateOutputType | null
    _min: QuizCategoryMinAggregateOutputType | null
    _max: QuizCategoryMaxAggregateOutputType | null
  }

  export type QuizCategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type QuizCategorySumAggregateOutputType = {
    id: number | null
  }

  export type QuizCategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizCategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizCategoryCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuizCategoryAvgAggregateInputType = {
    id?: true
  }

  export type QuizCategorySumAggregateInputType = {
    id?: true
  }

  export type QuizCategoryMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizCategoryCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuizCategoryAggregateArgs = {
    /**
     * Filter which QuizCategory to aggregate.
     */
    where?: QuizCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizCategories to fetch.
     */
    orderBy?: Enumerable<QuizCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizCategories
    **/
    _count?: true | QuizCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizCategoryMaxAggregateInputType
  }

  export type GetQuizCategoryAggregateType<T extends QuizCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizCategory[P]>
      : GetScalarType<T[P], AggregateQuizCategory[P]>
  }




  export type QuizCategoryGroupByArgs = {
    where?: QuizCategoryWhereInput
    orderBy?: Enumerable<QuizCategoryOrderByWithAggregationInput>
    by: QuizCategoryScalarFieldEnum[]
    having?: QuizCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizCategoryCountAggregateInputType | true
    _avg?: QuizCategoryAvgAggregateInputType
    _sum?: QuizCategorySumAggregateInputType
    _min?: QuizCategoryMinAggregateInputType
    _max?: QuizCategoryMaxAggregateInputType
  }


  export type QuizCategoryGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: QuizCategoryCountAggregateOutputType | null
    _avg: QuizCategoryAvgAggregateOutputType | null
    _sum: QuizCategorySumAggregateOutputType | null
    _min: QuizCategoryMinAggregateOutputType | null
    _max: QuizCategoryMaxAggregateOutputType | null
  }

  type GetQuizCategoryGroupByPayload<T extends QuizCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<QuizCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], QuizCategoryGroupByOutputType[P]>
        }
      >
    >


  export type QuizCategorySelect = {
    id?: boolean
    name?: boolean
    quizzes?: boolean | QuizCategory$quizzesArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | QuizCategoryCountOutputTypeArgs
  }


  export type QuizCategoryInclude = {
    quizzes?: boolean | QuizCategory$quizzesArgs
    _count?: boolean | QuizCategoryCountOutputTypeArgs
  }

  export type QuizCategoryGetPayload<S extends boolean | null | undefined | QuizCategoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? QuizCategory :
    S extends undefined ? never :
    S extends { include: any } & (QuizCategoryArgs | QuizCategoryFindManyArgs)
    ? QuizCategory  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'quizzes' ? Array < QuizGetPayload<S['include'][P]>>  :
        P extends '_count' ? QuizCategoryCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (QuizCategoryArgs | QuizCategoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'quizzes' ? Array < QuizGetPayload<S['select'][P]>>  :
        P extends '_count' ? QuizCategoryCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof QuizCategory ? QuizCategory[P] : never
  } 
      : QuizCategory


  type QuizCategoryCountArgs = 
    Omit<QuizCategoryFindManyArgs, 'select' | 'include'> & {
      select?: QuizCategoryCountAggregateInputType | true
    }

  export interface QuizCategoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one QuizCategory that matches the filter.
     * @param {QuizCategoryFindUniqueArgs} args - Arguments to find a QuizCategory
     * @example
     * // Get one QuizCategory
     * const quizCategory = await prisma.quizCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuizCategoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, QuizCategoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'QuizCategory'> extends True ? Prisma__QuizCategoryClient<QuizCategoryGetPayload<T>> : Prisma__QuizCategoryClient<QuizCategoryGetPayload<T> | null, null>

    /**
     * Find one QuizCategory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {QuizCategoryFindUniqueOrThrowArgs} args - Arguments to find a QuizCategory
     * @example
     * // Get one QuizCategory
     * const quizCategory = await prisma.quizCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QuizCategoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, QuizCategoryFindUniqueOrThrowArgs>
    ): Prisma__QuizCategoryClient<QuizCategoryGetPayload<T>>

    /**
     * Find the first QuizCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizCategoryFindFirstArgs} args - Arguments to find a QuizCategory
     * @example
     * // Get one QuizCategory
     * const quizCategory = await prisma.quizCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuizCategoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, QuizCategoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'QuizCategory'> extends True ? Prisma__QuizCategoryClient<QuizCategoryGetPayload<T>> : Prisma__QuizCategoryClient<QuizCategoryGetPayload<T> | null, null>

    /**
     * Find the first QuizCategory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizCategoryFindFirstOrThrowArgs} args - Arguments to find a QuizCategory
     * @example
     * // Get one QuizCategory
     * const quizCategory = await prisma.quizCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QuizCategoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, QuizCategoryFindFirstOrThrowArgs>
    ): Prisma__QuizCategoryClient<QuizCategoryGetPayload<T>>

    /**
     * Find zero or more QuizCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizCategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizCategories
     * const quizCategories = await prisma.quizCategory.findMany()
     * 
     * // Get first 10 QuizCategories
     * const quizCategories = await prisma.quizCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizCategoryWithIdOnly = await prisma.quizCategory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends QuizCategoryFindManyArgs>(
      args?: SelectSubset<T, QuizCategoryFindManyArgs>
    ): Prisma.PrismaPromise<Array<QuizCategoryGetPayload<T>>>

    /**
     * Create a QuizCategory.
     * @param {QuizCategoryCreateArgs} args - Arguments to create a QuizCategory.
     * @example
     * // Create one QuizCategory
     * const QuizCategory = await prisma.quizCategory.create({
     *   data: {
     *     // ... data to create a QuizCategory
     *   }
     * })
     * 
    **/
    create<T extends QuizCategoryCreateArgs>(
      args: SelectSubset<T, QuizCategoryCreateArgs>
    ): Prisma__QuizCategoryClient<QuizCategoryGetPayload<T>>

    /**
     * Create many QuizCategories.
     *     @param {QuizCategoryCreateManyArgs} args - Arguments to create many QuizCategories.
     *     @example
     *     // Create many QuizCategories
     *     const quizCategory = await prisma.quizCategory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QuizCategoryCreateManyArgs>(
      args?: SelectSubset<T, QuizCategoryCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QuizCategory.
     * @param {QuizCategoryDeleteArgs} args - Arguments to delete one QuizCategory.
     * @example
     * // Delete one QuizCategory
     * const QuizCategory = await prisma.quizCategory.delete({
     *   where: {
     *     // ... filter to delete one QuizCategory
     *   }
     * })
     * 
    **/
    delete<T extends QuizCategoryDeleteArgs>(
      args: SelectSubset<T, QuizCategoryDeleteArgs>
    ): Prisma__QuizCategoryClient<QuizCategoryGetPayload<T>>

    /**
     * Update one QuizCategory.
     * @param {QuizCategoryUpdateArgs} args - Arguments to update one QuizCategory.
     * @example
     * // Update one QuizCategory
     * const quizCategory = await prisma.quizCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuizCategoryUpdateArgs>(
      args: SelectSubset<T, QuizCategoryUpdateArgs>
    ): Prisma__QuizCategoryClient<QuizCategoryGetPayload<T>>

    /**
     * Delete zero or more QuizCategories.
     * @param {QuizCategoryDeleteManyArgs} args - Arguments to filter QuizCategories to delete.
     * @example
     * // Delete a few QuizCategories
     * const { count } = await prisma.quizCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuizCategoryDeleteManyArgs>(
      args?: SelectSubset<T, QuizCategoryDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizCategories
     * const quizCategory = await prisma.quizCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuizCategoryUpdateManyArgs>(
      args: SelectSubset<T, QuizCategoryUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuizCategory.
     * @param {QuizCategoryUpsertArgs} args - Arguments to update or create a QuizCategory.
     * @example
     * // Update or create a QuizCategory
     * const quizCategory = await prisma.quizCategory.upsert({
     *   create: {
     *     // ... data to create a QuizCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizCategory we want to update
     *   }
     * })
    **/
    upsert<T extends QuizCategoryUpsertArgs>(
      args: SelectSubset<T, QuizCategoryUpsertArgs>
    ): Prisma__QuizCategoryClient<QuizCategoryGetPayload<T>>

    /**
     * Count the number of QuizCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizCategoryCountArgs} args - Arguments to filter QuizCategories to count.
     * @example
     * // Count the number of QuizCategories
     * const count = await prisma.quizCategory.count({
     *   where: {
     *     // ... the filter for the QuizCategories we want to count
     *   }
     * })
    **/
    count<T extends QuizCategoryCountArgs>(
      args?: Subset<T, QuizCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizCategoryAggregateArgs>(args: Subset<T, QuizCategoryAggregateArgs>): Prisma.PrismaPromise<GetQuizCategoryAggregateType<T>>

    /**
     * Group by QuizCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizCategoryGroupByArgs['orderBy'] }
        : { orderBy?: QuizCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__QuizCategoryClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    quizzes<T extends QuizCategory$quizzesArgs= {}>(args?: Subset<T, QuizCategory$quizzesArgs>): Prisma.PrismaPromise<Array<QuizGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * QuizCategory base type for findUnique actions
   */
  export type QuizCategoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the QuizCategory
     */
    select?: QuizCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizCategoryInclude | null
    /**
     * Filter, which QuizCategory to fetch.
     */
    where: QuizCategoryWhereUniqueInput
  }

  /**
   * QuizCategory findUnique
   */
  export interface QuizCategoryFindUniqueArgs extends QuizCategoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuizCategory findUniqueOrThrow
   */
  export type QuizCategoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the QuizCategory
     */
    select?: QuizCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizCategoryInclude | null
    /**
     * Filter, which QuizCategory to fetch.
     */
    where: QuizCategoryWhereUniqueInput
  }


  /**
   * QuizCategory base type for findFirst actions
   */
  export type QuizCategoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the QuizCategory
     */
    select?: QuizCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizCategoryInclude | null
    /**
     * Filter, which QuizCategory to fetch.
     */
    where?: QuizCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizCategories to fetch.
     */
    orderBy?: Enumerable<QuizCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizCategories.
     */
    cursor?: QuizCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizCategories.
     */
    distinct?: Enumerable<QuizCategoryScalarFieldEnum>
  }

  /**
   * QuizCategory findFirst
   */
  export interface QuizCategoryFindFirstArgs extends QuizCategoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuizCategory findFirstOrThrow
   */
  export type QuizCategoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the QuizCategory
     */
    select?: QuizCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizCategoryInclude | null
    /**
     * Filter, which QuizCategory to fetch.
     */
    where?: QuizCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizCategories to fetch.
     */
    orderBy?: Enumerable<QuizCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizCategories.
     */
    cursor?: QuizCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizCategories.
     */
    distinct?: Enumerable<QuizCategoryScalarFieldEnum>
  }


  /**
   * QuizCategory findMany
   */
  export type QuizCategoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the QuizCategory
     */
    select?: QuizCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizCategoryInclude | null
    /**
     * Filter, which QuizCategories to fetch.
     */
    where?: QuizCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizCategories to fetch.
     */
    orderBy?: Enumerable<QuizCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizCategories.
     */
    cursor?: QuizCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizCategories.
     */
    skip?: number
    distinct?: Enumerable<QuizCategoryScalarFieldEnum>
  }


  /**
   * QuizCategory create
   */
  export type QuizCategoryCreateArgs = {
    /**
     * Select specific fields to fetch from the QuizCategory
     */
    select?: QuizCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizCategoryInclude | null
    /**
     * The data needed to create a QuizCategory.
     */
    data: XOR<QuizCategoryCreateInput, QuizCategoryUncheckedCreateInput>
  }


  /**
   * QuizCategory createMany
   */
  export type QuizCategoryCreateManyArgs = {
    /**
     * The data used to create many QuizCategories.
     */
    data: Enumerable<QuizCategoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * QuizCategory update
   */
  export type QuizCategoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the QuizCategory
     */
    select?: QuizCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizCategoryInclude | null
    /**
     * The data needed to update a QuizCategory.
     */
    data: XOR<QuizCategoryUpdateInput, QuizCategoryUncheckedUpdateInput>
    /**
     * Choose, which QuizCategory to update.
     */
    where: QuizCategoryWhereUniqueInput
  }


  /**
   * QuizCategory updateMany
   */
  export type QuizCategoryUpdateManyArgs = {
    /**
     * The data used to update QuizCategories.
     */
    data: XOR<QuizCategoryUpdateManyMutationInput, QuizCategoryUncheckedUpdateManyInput>
    /**
     * Filter which QuizCategories to update
     */
    where?: QuizCategoryWhereInput
  }


  /**
   * QuizCategory upsert
   */
  export type QuizCategoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the QuizCategory
     */
    select?: QuizCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizCategoryInclude | null
    /**
     * The filter to search for the QuizCategory to update in case it exists.
     */
    where: QuizCategoryWhereUniqueInput
    /**
     * In case the QuizCategory found by the `where` argument doesn't exist, create a new QuizCategory with this data.
     */
    create: XOR<QuizCategoryCreateInput, QuizCategoryUncheckedCreateInput>
    /**
     * In case the QuizCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizCategoryUpdateInput, QuizCategoryUncheckedUpdateInput>
  }


  /**
   * QuizCategory delete
   */
  export type QuizCategoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the QuizCategory
     */
    select?: QuizCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizCategoryInclude | null
    /**
     * Filter which QuizCategory to delete.
     */
    where: QuizCategoryWhereUniqueInput
  }


  /**
   * QuizCategory deleteMany
   */
  export type QuizCategoryDeleteManyArgs = {
    /**
     * Filter which QuizCategories to delete
     */
    where?: QuizCategoryWhereInput
  }


  /**
   * QuizCategory.quizzes
   */
  export type QuizCategory$quizzesArgs = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizInclude | null
    where?: QuizWhereInput
    orderBy?: Enumerable<QuizOrderByWithRelationInput>
    cursor?: QuizWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<QuizScalarFieldEnum>
  }


  /**
   * QuizCategory without action
   */
  export type QuizCategoryArgs = {
    /**
     * Select specific fields to fetch from the QuizCategory
     */
    select?: QuizCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizCategoryInclude | null
  }



  /**
   * Model Choice
   */


  export type AggregateChoice = {
    _count: ChoiceCountAggregateOutputType | null
    _avg: ChoiceAvgAggregateOutputType | null
    _sum: ChoiceSumAggregateOutputType | null
    _min: ChoiceMinAggregateOutputType | null
    _max: ChoiceMaxAggregateOutputType | null
  }

  export type ChoiceAvgAggregateOutputType = {
    id: number | null
    quizId: number | null
  }

  export type ChoiceSumAggregateOutputType = {
    id: number | null
    quizId: number | null
  }

  export type ChoiceMinAggregateOutputType = {
    id: number | null
    answerText: string | null
    quizId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChoiceMaxAggregateOutputType = {
    id: number | null
    answerText: string | null
    quizId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChoiceCountAggregateOutputType = {
    id: number
    answerText: number
    quizId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChoiceAvgAggregateInputType = {
    id?: true
    quizId?: true
  }

  export type ChoiceSumAggregateInputType = {
    id?: true
    quizId?: true
  }

  export type ChoiceMinAggregateInputType = {
    id?: true
    answerText?: true
    quizId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChoiceMaxAggregateInputType = {
    id?: true
    answerText?: true
    quizId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChoiceCountAggregateInputType = {
    id?: true
    answerText?: true
    quizId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChoiceAggregateArgs = {
    /**
     * Filter which Choice to aggregate.
     */
    where?: ChoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Choices to fetch.
     */
    orderBy?: Enumerable<ChoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Choices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Choices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Choices
    **/
    _count?: true | ChoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChoiceMaxAggregateInputType
  }

  export type GetChoiceAggregateType<T extends ChoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateChoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChoice[P]>
      : GetScalarType<T[P], AggregateChoice[P]>
  }




  export type ChoiceGroupByArgs = {
    where?: ChoiceWhereInput
    orderBy?: Enumerable<ChoiceOrderByWithAggregationInput>
    by: ChoiceScalarFieldEnum[]
    having?: ChoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChoiceCountAggregateInputType | true
    _avg?: ChoiceAvgAggregateInputType
    _sum?: ChoiceSumAggregateInputType
    _min?: ChoiceMinAggregateInputType
    _max?: ChoiceMaxAggregateInputType
  }


  export type ChoiceGroupByOutputType = {
    id: number
    answerText: string
    quizId: number | null
    createdAt: Date
    updatedAt: Date
    _count: ChoiceCountAggregateOutputType | null
    _avg: ChoiceAvgAggregateOutputType | null
    _sum: ChoiceSumAggregateOutputType | null
    _min: ChoiceMinAggregateOutputType | null
    _max: ChoiceMaxAggregateOutputType | null
  }

  type GetChoiceGroupByPayload<T extends ChoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ChoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChoiceGroupByOutputType[P]>
            : GetScalarType<T[P], ChoiceGroupByOutputType[P]>
        }
      >
    >


  export type ChoiceSelect = {
    id?: boolean
    answerText?: boolean
    quiz?: boolean | QuizArgs
    quizId?: boolean
    correctQuizzes?: boolean | Choice$correctQuizzesArgs
    rounds?: boolean | Choice$roundsArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | ChoiceCountOutputTypeArgs
  }


  export type ChoiceInclude = {
    quiz?: boolean | QuizArgs
    correctQuizzes?: boolean | Choice$correctQuizzesArgs
    rounds?: boolean | Choice$roundsArgs
    _count?: boolean | ChoiceCountOutputTypeArgs
  }

  export type ChoiceGetPayload<S extends boolean | null | undefined | ChoiceArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Choice :
    S extends undefined ? never :
    S extends { include: any } & (ChoiceArgs | ChoiceFindManyArgs)
    ? Choice  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'quiz' ? QuizGetPayload<S['include'][P]> | null :
        P extends 'correctQuizzes' ? Array < QuizGetPayload<S['include'][P]>>  :
        P extends 'rounds' ? Array < RoundGetPayload<S['include'][P]>>  :
        P extends '_count' ? ChoiceCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ChoiceArgs | ChoiceFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'quiz' ? QuizGetPayload<S['select'][P]> | null :
        P extends 'correctQuizzes' ? Array < QuizGetPayload<S['select'][P]>>  :
        P extends 'rounds' ? Array < RoundGetPayload<S['select'][P]>>  :
        P extends '_count' ? ChoiceCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Choice ? Choice[P] : never
  } 
      : Choice


  type ChoiceCountArgs = 
    Omit<ChoiceFindManyArgs, 'select' | 'include'> & {
      select?: ChoiceCountAggregateInputType | true
    }

  export interface ChoiceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Choice that matches the filter.
     * @param {ChoiceFindUniqueArgs} args - Arguments to find a Choice
     * @example
     * // Get one Choice
     * const choice = await prisma.choice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ChoiceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ChoiceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Choice'> extends True ? Prisma__ChoiceClient<ChoiceGetPayload<T>> : Prisma__ChoiceClient<ChoiceGetPayload<T> | null, null>

    /**
     * Find one Choice that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ChoiceFindUniqueOrThrowArgs} args - Arguments to find a Choice
     * @example
     * // Get one Choice
     * const choice = await prisma.choice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ChoiceFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ChoiceFindUniqueOrThrowArgs>
    ): Prisma__ChoiceClient<ChoiceGetPayload<T>>

    /**
     * Find the first Choice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceFindFirstArgs} args - Arguments to find a Choice
     * @example
     * // Get one Choice
     * const choice = await prisma.choice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ChoiceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ChoiceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Choice'> extends True ? Prisma__ChoiceClient<ChoiceGetPayload<T>> : Prisma__ChoiceClient<ChoiceGetPayload<T> | null, null>

    /**
     * Find the first Choice that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceFindFirstOrThrowArgs} args - Arguments to find a Choice
     * @example
     * // Get one Choice
     * const choice = await prisma.choice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ChoiceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ChoiceFindFirstOrThrowArgs>
    ): Prisma__ChoiceClient<ChoiceGetPayload<T>>

    /**
     * Find zero or more Choices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Choices
     * const choices = await prisma.choice.findMany()
     * 
     * // Get first 10 Choices
     * const choices = await prisma.choice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const choiceWithIdOnly = await prisma.choice.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ChoiceFindManyArgs>(
      args?: SelectSubset<T, ChoiceFindManyArgs>
    ): Prisma.PrismaPromise<Array<ChoiceGetPayload<T>>>

    /**
     * Create a Choice.
     * @param {ChoiceCreateArgs} args - Arguments to create a Choice.
     * @example
     * // Create one Choice
     * const Choice = await prisma.choice.create({
     *   data: {
     *     // ... data to create a Choice
     *   }
     * })
     * 
    **/
    create<T extends ChoiceCreateArgs>(
      args: SelectSubset<T, ChoiceCreateArgs>
    ): Prisma__ChoiceClient<ChoiceGetPayload<T>>

    /**
     * Create many Choices.
     *     @param {ChoiceCreateManyArgs} args - Arguments to create many Choices.
     *     @example
     *     // Create many Choices
     *     const choice = await prisma.choice.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ChoiceCreateManyArgs>(
      args?: SelectSubset<T, ChoiceCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Choice.
     * @param {ChoiceDeleteArgs} args - Arguments to delete one Choice.
     * @example
     * // Delete one Choice
     * const Choice = await prisma.choice.delete({
     *   where: {
     *     // ... filter to delete one Choice
     *   }
     * })
     * 
    **/
    delete<T extends ChoiceDeleteArgs>(
      args: SelectSubset<T, ChoiceDeleteArgs>
    ): Prisma__ChoiceClient<ChoiceGetPayload<T>>

    /**
     * Update one Choice.
     * @param {ChoiceUpdateArgs} args - Arguments to update one Choice.
     * @example
     * // Update one Choice
     * const choice = await prisma.choice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ChoiceUpdateArgs>(
      args: SelectSubset<T, ChoiceUpdateArgs>
    ): Prisma__ChoiceClient<ChoiceGetPayload<T>>

    /**
     * Delete zero or more Choices.
     * @param {ChoiceDeleteManyArgs} args - Arguments to filter Choices to delete.
     * @example
     * // Delete a few Choices
     * const { count } = await prisma.choice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ChoiceDeleteManyArgs>(
      args?: SelectSubset<T, ChoiceDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Choices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Choices
     * const choice = await prisma.choice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ChoiceUpdateManyArgs>(
      args: SelectSubset<T, ChoiceUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Choice.
     * @param {ChoiceUpsertArgs} args - Arguments to update or create a Choice.
     * @example
     * // Update or create a Choice
     * const choice = await prisma.choice.upsert({
     *   create: {
     *     // ... data to create a Choice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Choice we want to update
     *   }
     * })
    **/
    upsert<T extends ChoiceUpsertArgs>(
      args: SelectSubset<T, ChoiceUpsertArgs>
    ): Prisma__ChoiceClient<ChoiceGetPayload<T>>

    /**
     * Count the number of Choices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceCountArgs} args - Arguments to filter Choices to count.
     * @example
     * // Count the number of Choices
     * const count = await prisma.choice.count({
     *   where: {
     *     // ... the filter for the Choices we want to count
     *   }
     * })
    **/
    count<T extends ChoiceCountArgs>(
      args?: Subset<T, ChoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Choice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChoiceAggregateArgs>(args: Subset<T, ChoiceAggregateArgs>): Prisma.PrismaPromise<GetChoiceAggregateType<T>>

    /**
     * Group by Choice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChoiceGroupByArgs['orderBy'] }
        : { orderBy?: ChoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Choice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ChoiceClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    quiz<T extends QuizArgs= {}>(args?: Subset<T, QuizArgs>): Prisma__QuizClient<QuizGetPayload<T> | Null>;

    correctQuizzes<T extends Choice$correctQuizzesArgs= {}>(args?: Subset<T, Choice$correctQuizzesArgs>): Prisma.PrismaPromise<Array<QuizGetPayload<T>>| Null>;

    rounds<T extends Choice$roundsArgs= {}>(args?: Subset<T, Choice$roundsArgs>): Prisma.PrismaPromise<Array<RoundGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Choice base type for findUnique actions
   */
  export type ChoiceFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceInclude | null
    /**
     * Filter, which Choice to fetch.
     */
    where: ChoiceWhereUniqueInput
  }

  /**
   * Choice findUnique
   */
  export interface ChoiceFindUniqueArgs extends ChoiceFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Choice findUniqueOrThrow
   */
  export type ChoiceFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceInclude | null
    /**
     * Filter, which Choice to fetch.
     */
    where: ChoiceWhereUniqueInput
  }


  /**
   * Choice base type for findFirst actions
   */
  export type ChoiceFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceInclude | null
    /**
     * Filter, which Choice to fetch.
     */
    where?: ChoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Choices to fetch.
     */
    orderBy?: Enumerable<ChoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Choices.
     */
    cursor?: ChoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Choices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Choices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Choices.
     */
    distinct?: Enumerable<ChoiceScalarFieldEnum>
  }

  /**
   * Choice findFirst
   */
  export interface ChoiceFindFirstArgs extends ChoiceFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Choice findFirstOrThrow
   */
  export type ChoiceFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceInclude | null
    /**
     * Filter, which Choice to fetch.
     */
    where?: ChoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Choices to fetch.
     */
    orderBy?: Enumerable<ChoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Choices.
     */
    cursor?: ChoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Choices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Choices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Choices.
     */
    distinct?: Enumerable<ChoiceScalarFieldEnum>
  }


  /**
   * Choice findMany
   */
  export type ChoiceFindManyArgs = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceInclude | null
    /**
     * Filter, which Choices to fetch.
     */
    where?: ChoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Choices to fetch.
     */
    orderBy?: Enumerable<ChoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Choices.
     */
    cursor?: ChoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Choices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Choices.
     */
    skip?: number
    distinct?: Enumerable<ChoiceScalarFieldEnum>
  }


  /**
   * Choice create
   */
  export type ChoiceCreateArgs = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceInclude | null
    /**
     * The data needed to create a Choice.
     */
    data: XOR<ChoiceCreateInput, ChoiceUncheckedCreateInput>
  }


  /**
   * Choice createMany
   */
  export type ChoiceCreateManyArgs = {
    /**
     * The data used to create many Choices.
     */
    data: Enumerable<ChoiceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Choice update
   */
  export type ChoiceUpdateArgs = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceInclude | null
    /**
     * The data needed to update a Choice.
     */
    data: XOR<ChoiceUpdateInput, ChoiceUncheckedUpdateInput>
    /**
     * Choose, which Choice to update.
     */
    where: ChoiceWhereUniqueInput
  }


  /**
   * Choice updateMany
   */
  export type ChoiceUpdateManyArgs = {
    /**
     * The data used to update Choices.
     */
    data: XOR<ChoiceUpdateManyMutationInput, ChoiceUncheckedUpdateManyInput>
    /**
     * Filter which Choices to update
     */
    where?: ChoiceWhereInput
  }


  /**
   * Choice upsert
   */
  export type ChoiceUpsertArgs = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceInclude | null
    /**
     * The filter to search for the Choice to update in case it exists.
     */
    where: ChoiceWhereUniqueInput
    /**
     * In case the Choice found by the `where` argument doesn't exist, create a new Choice with this data.
     */
    create: XOR<ChoiceCreateInput, ChoiceUncheckedCreateInput>
    /**
     * In case the Choice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChoiceUpdateInput, ChoiceUncheckedUpdateInput>
  }


  /**
   * Choice delete
   */
  export type ChoiceDeleteArgs = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceInclude | null
    /**
     * Filter which Choice to delete.
     */
    where: ChoiceWhereUniqueInput
  }


  /**
   * Choice deleteMany
   */
  export type ChoiceDeleteManyArgs = {
    /**
     * Filter which Choices to delete
     */
    where?: ChoiceWhereInput
  }


  /**
   * Choice.correctQuizzes
   */
  export type Choice$correctQuizzesArgs = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizInclude | null
    where?: QuizWhereInput
    orderBy?: Enumerable<QuizOrderByWithRelationInput>
    cursor?: QuizWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<QuizScalarFieldEnum>
  }


  /**
   * Choice.rounds
   */
  export type Choice$roundsArgs = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoundInclude | null
    where?: RoundWhereInput
    orderBy?: Enumerable<RoundOrderByWithRelationInput>
    cursor?: RoundWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RoundScalarFieldEnum>
  }


  /**
   * Choice without action
   */
  export type ChoiceArgs = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceInclude | null
  }



  /**
   * Model Quiz
   */


  export type AggregateQuiz = {
    _count: QuizCountAggregateOutputType | null
    _avg: QuizAvgAggregateOutputType | null
    _sum: QuizSumAggregateOutputType | null
    _min: QuizMinAggregateOutputType | null
    _max: QuizMaxAggregateOutputType | null
  }

  export type QuizAvgAggregateOutputType = {
    id: number | null
    quizCategoryId: number | null
    correctChoiceId: number | null
  }

  export type QuizSumAggregateOutputType = {
    id: number | null
    quizCategoryId: number | null
    correctChoiceId: number | null
  }

  export type QuizMinAggregateOutputType = {
    id: number | null
    questionText: string | null
    quizCategoryId: number | null
    correctChoiceId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizMaxAggregateOutputType = {
    id: number | null
    questionText: string | null
    quizCategoryId: number | null
    correctChoiceId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizCountAggregateOutputType = {
    id: number
    questionText: number
    quizCategoryId: number
    correctChoiceId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuizAvgAggregateInputType = {
    id?: true
    quizCategoryId?: true
    correctChoiceId?: true
  }

  export type QuizSumAggregateInputType = {
    id?: true
    quizCategoryId?: true
    correctChoiceId?: true
  }

  export type QuizMinAggregateInputType = {
    id?: true
    questionText?: true
    quizCategoryId?: true
    correctChoiceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizMaxAggregateInputType = {
    id?: true
    questionText?: true
    quizCategoryId?: true
    correctChoiceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizCountAggregateInputType = {
    id?: true
    questionText?: true
    quizCategoryId?: true
    correctChoiceId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuizAggregateArgs = {
    /**
     * Filter which Quiz to aggregate.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: Enumerable<QuizOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Quizzes
    **/
    _count?: true | QuizCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizMaxAggregateInputType
  }

  export type GetQuizAggregateType<T extends QuizAggregateArgs> = {
        [P in keyof T & keyof AggregateQuiz]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuiz[P]>
      : GetScalarType<T[P], AggregateQuiz[P]>
  }




  export type QuizGroupByArgs = {
    where?: QuizWhereInput
    orderBy?: Enumerable<QuizOrderByWithAggregationInput>
    by: QuizScalarFieldEnum[]
    having?: QuizScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizCountAggregateInputType | true
    _avg?: QuizAvgAggregateInputType
    _sum?: QuizSumAggregateInputType
    _min?: QuizMinAggregateInputType
    _max?: QuizMaxAggregateInputType
  }


  export type QuizGroupByOutputType = {
    id: number
    questionText: string
    quizCategoryId: number
    correctChoiceId: number
    createdAt: Date
    updatedAt: Date
    _count: QuizCountAggregateOutputType | null
    _avg: QuizAvgAggregateOutputType | null
    _sum: QuizSumAggregateOutputType | null
    _min: QuizMinAggregateOutputType | null
    _max: QuizMaxAggregateOutputType | null
  }

  type GetQuizGroupByPayload<T extends QuizGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<QuizGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizGroupByOutputType[P]>
            : GetScalarType<T[P], QuizGroupByOutputType[P]>
        }
      >
    >


  export type QuizSelect = {
    id?: boolean
    questionText?: boolean
    category?: boolean | QuizCategoryArgs
    quizCategoryId?: boolean
    choices?: boolean | Quiz$choicesArgs
    correctChoice?: boolean | ChoiceArgs
    correctChoiceId?: boolean
    rounds?: boolean | Quiz$roundsArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | QuizCountOutputTypeArgs
  }


  export type QuizInclude = {
    category?: boolean | QuizCategoryArgs
    choices?: boolean | Quiz$choicesArgs
    correctChoice?: boolean | ChoiceArgs
    rounds?: boolean | Quiz$roundsArgs
    _count?: boolean | QuizCountOutputTypeArgs
  }

  export type QuizGetPayload<S extends boolean | null | undefined | QuizArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Quiz :
    S extends undefined ? never :
    S extends { include: any } & (QuizArgs | QuizFindManyArgs)
    ? Quiz  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'category' ? QuizCategoryGetPayload<S['include'][P]> :
        P extends 'choices' ? Array < ChoiceGetPayload<S['include'][P]>>  :
        P extends 'correctChoice' ? ChoiceGetPayload<S['include'][P]> :
        P extends 'rounds' ? Array < RoundGetPayload<S['include'][P]>>  :
        P extends '_count' ? QuizCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (QuizArgs | QuizFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'category' ? QuizCategoryGetPayload<S['select'][P]> :
        P extends 'choices' ? Array < ChoiceGetPayload<S['select'][P]>>  :
        P extends 'correctChoice' ? ChoiceGetPayload<S['select'][P]> :
        P extends 'rounds' ? Array < RoundGetPayload<S['select'][P]>>  :
        P extends '_count' ? QuizCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Quiz ? Quiz[P] : never
  } 
      : Quiz


  type QuizCountArgs = 
    Omit<QuizFindManyArgs, 'select' | 'include'> & {
      select?: QuizCountAggregateInputType | true
    }

  export interface QuizDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Quiz that matches the filter.
     * @param {QuizFindUniqueArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuizFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, QuizFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Quiz'> extends True ? Prisma__QuizClient<QuizGetPayload<T>> : Prisma__QuizClient<QuizGetPayload<T> | null, null>

    /**
     * Find one Quiz that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {QuizFindUniqueOrThrowArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QuizFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, QuizFindUniqueOrThrowArgs>
    ): Prisma__QuizClient<QuizGetPayload<T>>

    /**
     * Find the first Quiz that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizFindFirstArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuizFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, QuizFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Quiz'> extends True ? Prisma__QuizClient<QuizGetPayload<T>> : Prisma__QuizClient<QuizGetPayload<T> | null, null>

    /**
     * Find the first Quiz that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizFindFirstOrThrowArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QuizFindFirstOrThrowArgs>(
      args?: SelectSubset<T, QuizFindFirstOrThrowArgs>
    ): Prisma__QuizClient<QuizGetPayload<T>>

    /**
     * Find zero or more Quizzes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quizzes
     * const quizzes = await prisma.quiz.findMany()
     * 
     * // Get first 10 Quizzes
     * const quizzes = await prisma.quiz.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizWithIdOnly = await prisma.quiz.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends QuizFindManyArgs>(
      args?: SelectSubset<T, QuizFindManyArgs>
    ): Prisma.PrismaPromise<Array<QuizGetPayload<T>>>

    /**
     * Create a Quiz.
     * @param {QuizCreateArgs} args - Arguments to create a Quiz.
     * @example
     * // Create one Quiz
     * const Quiz = await prisma.quiz.create({
     *   data: {
     *     // ... data to create a Quiz
     *   }
     * })
     * 
    **/
    create<T extends QuizCreateArgs>(
      args: SelectSubset<T, QuizCreateArgs>
    ): Prisma__QuizClient<QuizGetPayload<T>>

    /**
     * Create many Quizzes.
     *     @param {QuizCreateManyArgs} args - Arguments to create many Quizzes.
     *     @example
     *     // Create many Quizzes
     *     const quiz = await prisma.quiz.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QuizCreateManyArgs>(
      args?: SelectSubset<T, QuizCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Quiz.
     * @param {QuizDeleteArgs} args - Arguments to delete one Quiz.
     * @example
     * // Delete one Quiz
     * const Quiz = await prisma.quiz.delete({
     *   where: {
     *     // ... filter to delete one Quiz
     *   }
     * })
     * 
    **/
    delete<T extends QuizDeleteArgs>(
      args: SelectSubset<T, QuizDeleteArgs>
    ): Prisma__QuizClient<QuizGetPayload<T>>

    /**
     * Update one Quiz.
     * @param {QuizUpdateArgs} args - Arguments to update one Quiz.
     * @example
     * // Update one Quiz
     * const quiz = await prisma.quiz.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuizUpdateArgs>(
      args: SelectSubset<T, QuizUpdateArgs>
    ): Prisma__QuizClient<QuizGetPayload<T>>

    /**
     * Delete zero or more Quizzes.
     * @param {QuizDeleteManyArgs} args - Arguments to filter Quizzes to delete.
     * @example
     * // Delete a few Quizzes
     * const { count } = await prisma.quiz.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuizDeleteManyArgs>(
      args?: SelectSubset<T, QuizDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quizzes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quizzes
     * const quiz = await prisma.quiz.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuizUpdateManyArgs>(
      args: SelectSubset<T, QuizUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Quiz.
     * @param {QuizUpsertArgs} args - Arguments to update or create a Quiz.
     * @example
     * // Update or create a Quiz
     * const quiz = await prisma.quiz.upsert({
     *   create: {
     *     // ... data to create a Quiz
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quiz we want to update
     *   }
     * })
    **/
    upsert<T extends QuizUpsertArgs>(
      args: SelectSubset<T, QuizUpsertArgs>
    ): Prisma__QuizClient<QuizGetPayload<T>>

    /**
     * Count the number of Quizzes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizCountArgs} args - Arguments to filter Quizzes to count.
     * @example
     * // Count the number of Quizzes
     * const count = await prisma.quiz.count({
     *   where: {
     *     // ... the filter for the Quizzes we want to count
     *   }
     * })
    **/
    count<T extends QuizCountArgs>(
      args?: Subset<T, QuizCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quiz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizAggregateArgs>(args: Subset<T, QuizAggregateArgs>): Prisma.PrismaPromise<GetQuizAggregateType<T>>

    /**
     * Group by Quiz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizGroupByArgs['orderBy'] }
        : { orderBy?: QuizGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Quiz.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__QuizClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    category<T extends QuizCategoryArgs= {}>(args?: Subset<T, QuizCategoryArgs>): Prisma__QuizCategoryClient<QuizCategoryGetPayload<T> | Null>;

    choices<T extends Quiz$choicesArgs= {}>(args?: Subset<T, Quiz$choicesArgs>): Prisma.PrismaPromise<Array<ChoiceGetPayload<T>>| Null>;

    correctChoice<T extends ChoiceArgs= {}>(args?: Subset<T, ChoiceArgs>): Prisma__ChoiceClient<ChoiceGetPayload<T> | Null>;

    rounds<T extends Quiz$roundsArgs= {}>(args?: Subset<T, Quiz$roundsArgs>): Prisma.PrismaPromise<Array<RoundGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Quiz base type for findUnique actions
   */
  export type QuizFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizInclude | null
    /**
     * Filter, which Quiz to fetch.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz findUnique
   */
  export interface QuizFindUniqueArgs extends QuizFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Quiz findUniqueOrThrow
   */
  export type QuizFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizInclude | null
    /**
     * Filter, which Quiz to fetch.
     */
    where: QuizWhereUniqueInput
  }


  /**
   * Quiz base type for findFirst actions
   */
  export type QuizFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizInclude | null
    /**
     * Filter, which Quiz to fetch.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: Enumerable<QuizOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quizzes.
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quizzes.
     */
    distinct?: Enumerable<QuizScalarFieldEnum>
  }

  /**
   * Quiz findFirst
   */
  export interface QuizFindFirstArgs extends QuizFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Quiz findFirstOrThrow
   */
  export type QuizFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizInclude | null
    /**
     * Filter, which Quiz to fetch.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: Enumerable<QuizOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quizzes.
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quizzes.
     */
    distinct?: Enumerable<QuizScalarFieldEnum>
  }


  /**
   * Quiz findMany
   */
  export type QuizFindManyArgs = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizInclude | null
    /**
     * Filter, which Quizzes to fetch.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: Enumerable<QuizOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Quizzes.
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    distinct?: Enumerable<QuizScalarFieldEnum>
  }


  /**
   * Quiz create
   */
  export type QuizCreateArgs = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizInclude | null
    /**
     * The data needed to create a Quiz.
     */
    data: XOR<QuizCreateInput, QuizUncheckedCreateInput>
  }


  /**
   * Quiz createMany
   */
  export type QuizCreateManyArgs = {
    /**
     * The data used to create many Quizzes.
     */
    data: Enumerable<QuizCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Quiz update
   */
  export type QuizUpdateArgs = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizInclude | null
    /**
     * The data needed to update a Quiz.
     */
    data: XOR<QuizUpdateInput, QuizUncheckedUpdateInput>
    /**
     * Choose, which Quiz to update.
     */
    where: QuizWhereUniqueInput
  }


  /**
   * Quiz updateMany
   */
  export type QuizUpdateManyArgs = {
    /**
     * The data used to update Quizzes.
     */
    data: XOR<QuizUpdateManyMutationInput, QuizUncheckedUpdateManyInput>
    /**
     * Filter which Quizzes to update
     */
    where?: QuizWhereInput
  }


  /**
   * Quiz upsert
   */
  export type QuizUpsertArgs = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizInclude | null
    /**
     * The filter to search for the Quiz to update in case it exists.
     */
    where: QuizWhereUniqueInput
    /**
     * In case the Quiz found by the `where` argument doesn't exist, create a new Quiz with this data.
     */
    create: XOR<QuizCreateInput, QuizUncheckedCreateInput>
    /**
     * In case the Quiz was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizUpdateInput, QuizUncheckedUpdateInput>
  }


  /**
   * Quiz delete
   */
  export type QuizDeleteArgs = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizInclude | null
    /**
     * Filter which Quiz to delete.
     */
    where: QuizWhereUniqueInput
  }


  /**
   * Quiz deleteMany
   */
  export type QuizDeleteManyArgs = {
    /**
     * Filter which Quizzes to delete
     */
    where?: QuizWhereInput
  }


  /**
   * Quiz.choices
   */
  export type Quiz$choicesArgs = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceInclude | null
    where?: ChoiceWhereInput
    orderBy?: Enumerable<ChoiceOrderByWithRelationInput>
    cursor?: ChoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ChoiceScalarFieldEnum>
  }


  /**
   * Quiz.rounds
   */
  export type Quiz$roundsArgs = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoundInclude | null
    where?: RoundWhereInput
    orderBy?: Enumerable<RoundOrderByWithRelationInput>
    cursor?: RoundWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RoundScalarFieldEnum>
  }


  /**
   * Quiz without action
   */
  export type QuizArgs = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizInclude | null
  }



  /**
   * Model Round
   */


  export type AggregateRound = {
    _count: RoundCountAggregateOutputType | null
    _avg: RoundAvgAggregateOutputType | null
    _sum: RoundSumAggregateOutputType | null
    _min: RoundMinAggregateOutputType | null
    _max: RoundMaxAggregateOutputType | null
  }

  export type RoundAvgAggregateOutputType = {
    id: number | null
  }

  export type RoundSumAggregateOutputType = {
    id: number | null
  }

  export type RoundMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoundMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoundCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoundAvgAggregateInputType = {
    id?: true
  }

  export type RoundSumAggregateInputType = {
    id?: true
  }

  export type RoundMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoundMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoundCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoundAggregateArgs = {
    /**
     * Filter which Round to aggregate.
     */
    where?: RoundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rounds to fetch.
     */
    orderBy?: Enumerable<RoundOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rounds
    **/
    _count?: true | RoundCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoundAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoundSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoundMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoundMaxAggregateInputType
  }

  export type GetRoundAggregateType<T extends RoundAggregateArgs> = {
        [P in keyof T & keyof AggregateRound]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRound[P]>
      : GetScalarType<T[P], AggregateRound[P]>
  }




  export type RoundGroupByArgs = {
    where?: RoundWhereInput
    orderBy?: Enumerable<RoundOrderByWithAggregationInput>
    by: RoundScalarFieldEnum[]
    having?: RoundScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoundCountAggregateInputType | true
    _avg?: RoundAvgAggregateInputType
    _sum?: RoundSumAggregateInputType
    _min?: RoundMinAggregateInputType
    _max?: RoundMaxAggregateInputType
  }


  export type RoundGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    _count: RoundCountAggregateOutputType | null
    _avg: RoundAvgAggregateOutputType | null
    _sum: RoundSumAggregateOutputType | null
    _min: RoundMinAggregateOutputType | null
    _max: RoundMaxAggregateOutputType | null
  }

  type GetRoundGroupByPayload<T extends RoundGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RoundGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoundGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoundGroupByOutputType[P]>
            : GetScalarType<T[P], RoundGroupByOutputType[P]>
        }
      >
    >


  export type RoundSelect = {
    id?: boolean
    quizzes?: boolean | Round$quizzesArgs
    selectedChoices?: boolean | Round$selectedChoicesArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | RoundCountOutputTypeArgs
  }


  export type RoundInclude = {
    quizzes?: boolean | Round$quizzesArgs
    selectedChoices?: boolean | Round$selectedChoicesArgs
    _count?: boolean | RoundCountOutputTypeArgs
  }

  export type RoundGetPayload<S extends boolean | null | undefined | RoundArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Round :
    S extends undefined ? never :
    S extends { include: any } & (RoundArgs | RoundFindManyArgs)
    ? Round  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'quizzes' ? Array < QuizGetPayload<S['include'][P]>>  :
        P extends 'selectedChoices' ? Array < ChoiceGetPayload<S['include'][P]>>  :
        P extends '_count' ? RoundCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (RoundArgs | RoundFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'quizzes' ? Array < QuizGetPayload<S['select'][P]>>  :
        P extends 'selectedChoices' ? Array < ChoiceGetPayload<S['select'][P]>>  :
        P extends '_count' ? RoundCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Round ? Round[P] : never
  } 
      : Round


  type RoundCountArgs = 
    Omit<RoundFindManyArgs, 'select' | 'include'> & {
      select?: RoundCountAggregateInputType | true
    }

  export interface RoundDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Round that matches the filter.
     * @param {RoundFindUniqueArgs} args - Arguments to find a Round
     * @example
     * // Get one Round
     * const round = await prisma.round.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RoundFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RoundFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Round'> extends True ? Prisma__RoundClient<RoundGetPayload<T>> : Prisma__RoundClient<RoundGetPayload<T> | null, null>

    /**
     * Find one Round that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RoundFindUniqueOrThrowArgs} args - Arguments to find a Round
     * @example
     * // Get one Round
     * const round = await prisma.round.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RoundFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RoundFindUniqueOrThrowArgs>
    ): Prisma__RoundClient<RoundGetPayload<T>>

    /**
     * Find the first Round that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundFindFirstArgs} args - Arguments to find a Round
     * @example
     * // Get one Round
     * const round = await prisma.round.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RoundFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RoundFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Round'> extends True ? Prisma__RoundClient<RoundGetPayload<T>> : Prisma__RoundClient<RoundGetPayload<T> | null, null>

    /**
     * Find the first Round that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundFindFirstOrThrowArgs} args - Arguments to find a Round
     * @example
     * // Get one Round
     * const round = await prisma.round.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RoundFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RoundFindFirstOrThrowArgs>
    ): Prisma__RoundClient<RoundGetPayload<T>>

    /**
     * Find zero or more Rounds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rounds
     * const rounds = await prisma.round.findMany()
     * 
     * // Get first 10 Rounds
     * const rounds = await prisma.round.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roundWithIdOnly = await prisma.round.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RoundFindManyArgs>(
      args?: SelectSubset<T, RoundFindManyArgs>
    ): Prisma.PrismaPromise<Array<RoundGetPayload<T>>>

    /**
     * Create a Round.
     * @param {RoundCreateArgs} args - Arguments to create a Round.
     * @example
     * // Create one Round
     * const Round = await prisma.round.create({
     *   data: {
     *     // ... data to create a Round
     *   }
     * })
     * 
    **/
    create<T extends RoundCreateArgs>(
      args: SelectSubset<T, RoundCreateArgs>
    ): Prisma__RoundClient<RoundGetPayload<T>>

    /**
     * Create many Rounds.
     *     @param {RoundCreateManyArgs} args - Arguments to create many Rounds.
     *     @example
     *     // Create many Rounds
     *     const round = await prisma.round.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RoundCreateManyArgs>(
      args?: SelectSubset<T, RoundCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Round.
     * @param {RoundDeleteArgs} args - Arguments to delete one Round.
     * @example
     * // Delete one Round
     * const Round = await prisma.round.delete({
     *   where: {
     *     // ... filter to delete one Round
     *   }
     * })
     * 
    **/
    delete<T extends RoundDeleteArgs>(
      args: SelectSubset<T, RoundDeleteArgs>
    ): Prisma__RoundClient<RoundGetPayload<T>>

    /**
     * Update one Round.
     * @param {RoundUpdateArgs} args - Arguments to update one Round.
     * @example
     * // Update one Round
     * const round = await prisma.round.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RoundUpdateArgs>(
      args: SelectSubset<T, RoundUpdateArgs>
    ): Prisma__RoundClient<RoundGetPayload<T>>

    /**
     * Delete zero or more Rounds.
     * @param {RoundDeleteManyArgs} args - Arguments to filter Rounds to delete.
     * @example
     * // Delete a few Rounds
     * const { count } = await prisma.round.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RoundDeleteManyArgs>(
      args?: SelectSubset<T, RoundDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rounds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rounds
     * const round = await prisma.round.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RoundUpdateManyArgs>(
      args: SelectSubset<T, RoundUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Round.
     * @param {RoundUpsertArgs} args - Arguments to update or create a Round.
     * @example
     * // Update or create a Round
     * const round = await prisma.round.upsert({
     *   create: {
     *     // ... data to create a Round
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Round we want to update
     *   }
     * })
    **/
    upsert<T extends RoundUpsertArgs>(
      args: SelectSubset<T, RoundUpsertArgs>
    ): Prisma__RoundClient<RoundGetPayload<T>>

    /**
     * Count the number of Rounds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundCountArgs} args - Arguments to filter Rounds to count.
     * @example
     * // Count the number of Rounds
     * const count = await prisma.round.count({
     *   where: {
     *     // ... the filter for the Rounds we want to count
     *   }
     * })
    **/
    count<T extends RoundCountArgs>(
      args?: Subset<T, RoundCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoundCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Round.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoundAggregateArgs>(args: Subset<T, RoundAggregateArgs>): Prisma.PrismaPromise<GetRoundAggregateType<T>>

    /**
     * Group by Round.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoundGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoundGroupByArgs['orderBy'] }
        : { orderBy?: RoundGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoundGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoundGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Round.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RoundClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    quizzes<T extends Round$quizzesArgs= {}>(args?: Subset<T, Round$quizzesArgs>): Prisma.PrismaPromise<Array<QuizGetPayload<T>>| Null>;

    selectedChoices<T extends Round$selectedChoicesArgs= {}>(args?: Subset<T, Round$selectedChoicesArgs>): Prisma.PrismaPromise<Array<ChoiceGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Round base type for findUnique actions
   */
  export type RoundFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoundInclude | null
    /**
     * Filter, which Round to fetch.
     */
    where: RoundWhereUniqueInput
  }

  /**
   * Round findUnique
   */
  export interface RoundFindUniqueArgs extends RoundFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Round findUniqueOrThrow
   */
  export type RoundFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoundInclude | null
    /**
     * Filter, which Round to fetch.
     */
    where: RoundWhereUniqueInput
  }


  /**
   * Round base type for findFirst actions
   */
  export type RoundFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoundInclude | null
    /**
     * Filter, which Round to fetch.
     */
    where?: RoundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rounds to fetch.
     */
    orderBy?: Enumerable<RoundOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rounds.
     */
    cursor?: RoundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rounds.
     */
    distinct?: Enumerable<RoundScalarFieldEnum>
  }

  /**
   * Round findFirst
   */
  export interface RoundFindFirstArgs extends RoundFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Round findFirstOrThrow
   */
  export type RoundFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoundInclude | null
    /**
     * Filter, which Round to fetch.
     */
    where?: RoundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rounds to fetch.
     */
    orderBy?: Enumerable<RoundOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rounds.
     */
    cursor?: RoundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rounds.
     */
    distinct?: Enumerable<RoundScalarFieldEnum>
  }


  /**
   * Round findMany
   */
  export type RoundFindManyArgs = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoundInclude | null
    /**
     * Filter, which Rounds to fetch.
     */
    where?: RoundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rounds to fetch.
     */
    orderBy?: Enumerable<RoundOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rounds.
     */
    cursor?: RoundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rounds.
     */
    skip?: number
    distinct?: Enumerable<RoundScalarFieldEnum>
  }


  /**
   * Round create
   */
  export type RoundCreateArgs = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoundInclude | null
    /**
     * The data needed to create a Round.
     */
    data: XOR<RoundCreateInput, RoundUncheckedCreateInput>
  }


  /**
   * Round createMany
   */
  export type RoundCreateManyArgs = {
    /**
     * The data used to create many Rounds.
     */
    data: Enumerable<RoundCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Round update
   */
  export type RoundUpdateArgs = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoundInclude | null
    /**
     * The data needed to update a Round.
     */
    data: XOR<RoundUpdateInput, RoundUncheckedUpdateInput>
    /**
     * Choose, which Round to update.
     */
    where: RoundWhereUniqueInput
  }


  /**
   * Round updateMany
   */
  export type RoundUpdateManyArgs = {
    /**
     * The data used to update Rounds.
     */
    data: XOR<RoundUpdateManyMutationInput, RoundUncheckedUpdateManyInput>
    /**
     * Filter which Rounds to update
     */
    where?: RoundWhereInput
  }


  /**
   * Round upsert
   */
  export type RoundUpsertArgs = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoundInclude | null
    /**
     * The filter to search for the Round to update in case it exists.
     */
    where: RoundWhereUniqueInput
    /**
     * In case the Round found by the `where` argument doesn't exist, create a new Round with this data.
     */
    create: XOR<RoundCreateInput, RoundUncheckedCreateInput>
    /**
     * In case the Round was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoundUpdateInput, RoundUncheckedUpdateInput>
  }


  /**
   * Round delete
   */
  export type RoundDeleteArgs = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoundInclude | null
    /**
     * Filter which Round to delete.
     */
    where: RoundWhereUniqueInput
  }


  /**
   * Round deleteMany
   */
  export type RoundDeleteManyArgs = {
    /**
     * Filter which Rounds to delete
     */
    where?: RoundWhereInput
  }


  /**
   * Round.quizzes
   */
  export type Round$quizzesArgs = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizInclude | null
    where?: QuizWhereInput
    orderBy?: Enumerable<QuizOrderByWithRelationInput>
    cursor?: QuizWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<QuizScalarFieldEnum>
  }


  /**
   * Round.selectedChoices
   */
  export type Round$selectedChoicesArgs = {
    /**
     * Select specific fields to fetch from the Choice
     */
    select?: ChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceInclude | null
    where?: ChoiceWhereInput
    orderBy?: Enumerable<ChoiceOrderByWithRelationInput>
    cursor?: ChoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ChoiceScalarFieldEnum>
  }


  /**
   * Round without action
   */
  export type RoundArgs = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoundInclude | null
  }



  /**
   * Model BinWashUser
   */


  export type AggregateBinWashUser = {
    _count: BinWashUserCountAggregateOutputType | null
    _avg: BinWashUserAvgAggregateOutputType | null
    _sum: BinWashUserSumAggregateOutputType | null
    _min: BinWashUserMinAggregateOutputType | null
    _max: BinWashUserMaxAggregateOutputType | null
  }

  export type BinWashUserAvgAggregateOutputType = {
    id: number | null
    balance: number | null
  }

  export type BinWashUserSumAggregateOutputType = {
    id: number | null
    balance: number | null
  }

  export type BinWashUserMinAggregateOutputType = {
    id: number | null
    name: string | null
    balance: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BinWashUserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    balance: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BinWashUserCountAggregateOutputType = {
    id: number
    name: number
    balance: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BinWashUserAvgAggregateInputType = {
    id?: true
    balance?: true
  }

  export type BinWashUserSumAggregateInputType = {
    id?: true
    balance?: true
  }

  export type BinWashUserMinAggregateInputType = {
    id?: true
    name?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BinWashUserMaxAggregateInputType = {
    id?: true
    name?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BinWashUserCountAggregateInputType = {
    id?: true
    name?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BinWashUserAggregateArgs = {
    /**
     * Filter which BinWashUser to aggregate.
     */
    where?: BinWashUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BinWashUsers to fetch.
     */
    orderBy?: Enumerable<BinWashUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BinWashUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BinWashUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BinWashUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BinWashUsers
    **/
    _count?: true | BinWashUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BinWashUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BinWashUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BinWashUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BinWashUserMaxAggregateInputType
  }

  export type GetBinWashUserAggregateType<T extends BinWashUserAggregateArgs> = {
        [P in keyof T & keyof AggregateBinWashUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBinWashUser[P]>
      : GetScalarType<T[P], AggregateBinWashUser[P]>
  }




  export type BinWashUserGroupByArgs = {
    where?: BinWashUserWhereInput
    orderBy?: Enumerable<BinWashUserOrderByWithAggregationInput>
    by: BinWashUserScalarFieldEnum[]
    having?: BinWashUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BinWashUserCountAggregateInputType | true
    _avg?: BinWashUserAvgAggregateInputType
    _sum?: BinWashUserSumAggregateInputType
    _min?: BinWashUserMinAggregateInputType
    _max?: BinWashUserMaxAggregateInputType
  }


  export type BinWashUserGroupByOutputType = {
    id: number
    name: string
    balance: number
    createdAt: Date
    updatedAt: Date
    _count: BinWashUserCountAggregateOutputType | null
    _avg: BinWashUserAvgAggregateOutputType | null
    _sum: BinWashUserSumAggregateOutputType | null
    _min: BinWashUserMinAggregateOutputType | null
    _max: BinWashUserMaxAggregateOutputType | null
  }

  type GetBinWashUserGroupByPayload<T extends BinWashUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BinWashUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BinWashUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BinWashUserGroupByOutputType[P]>
            : GetScalarType<T[P], BinWashUserGroupByOutputType[P]>
        }
      >
    >


  export type BinWashUserSelect = {
    id?: boolean
    name?: boolean
    balance?: boolean
    owningBranches?: boolean | BinWashUser$owningBranchesArgs
    wMMaintenanceRecords?: boolean | BinWashUser$wMMaintenanceRecordsArgs
    usageRecords?: boolean | BinWashUser$usageRecordsArgs
    topUpRecords?: boolean | BinWashUser$topUpRecordsArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | BinWashUserCountOutputTypeArgs
  }


  export type BinWashUserInclude = {
    owningBranches?: boolean | BinWashUser$owningBranchesArgs
    wMMaintenanceRecords?: boolean | BinWashUser$wMMaintenanceRecordsArgs
    usageRecords?: boolean | BinWashUser$usageRecordsArgs
    topUpRecords?: boolean | BinWashUser$topUpRecordsArgs
    _count?: boolean | BinWashUserCountOutputTypeArgs
  }

  export type BinWashUserGetPayload<S extends boolean | null | undefined | BinWashUserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BinWashUser :
    S extends undefined ? never :
    S extends { include: any } & (BinWashUserArgs | BinWashUserFindManyArgs)
    ? BinWashUser  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'owningBranches' ? Array < BranchGetPayload<S['include'][P]>>  :
        P extends 'wMMaintenanceRecords' ? Array < WMMaintenanceRecordGetPayload<S['include'][P]>>  :
        P extends 'usageRecords' ? Array < UsageRecordGetPayload<S['include'][P]>>  :
        P extends 'topUpRecords' ? Array < TopUpRecordGetPayload<S['include'][P]>>  :
        P extends '_count' ? BinWashUserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BinWashUserArgs | BinWashUserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'owningBranches' ? Array < BranchGetPayload<S['select'][P]>>  :
        P extends 'wMMaintenanceRecords' ? Array < WMMaintenanceRecordGetPayload<S['select'][P]>>  :
        P extends 'usageRecords' ? Array < UsageRecordGetPayload<S['select'][P]>>  :
        P extends 'topUpRecords' ? Array < TopUpRecordGetPayload<S['select'][P]>>  :
        P extends '_count' ? BinWashUserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof BinWashUser ? BinWashUser[P] : never
  } 
      : BinWashUser


  type BinWashUserCountArgs = 
    Omit<BinWashUserFindManyArgs, 'select' | 'include'> & {
      select?: BinWashUserCountAggregateInputType | true
    }

  export interface BinWashUserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one BinWashUser that matches the filter.
     * @param {BinWashUserFindUniqueArgs} args - Arguments to find a BinWashUser
     * @example
     * // Get one BinWashUser
     * const binWashUser = await prisma.binWashUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BinWashUserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BinWashUserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BinWashUser'> extends True ? Prisma__BinWashUserClient<BinWashUserGetPayload<T>> : Prisma__BinWashUserClient<BinWashUserGetPayload<T> | null, null>

    /**
     * Find one BinWashUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BinWashUserFindUniqueOrThrowArgs} args - Arguments to find a BinWashUser
     * @example
     * // Get one BinWashUser
     * const binWashUser = await prisma.binWashUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BinWashUserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BinWashUserFindUniqueOrThrowArgs>
    ): Prisma__BinWashUserClient<BinWashUserGetPayload<T>>

    /**
     * Find the first BinWashUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinWashUserFindFirstArgs} args - Arguments to find a BinWashUser
     * @example
     * // Get one BinWashUser
     * const binWashUser = await prisma.binWashUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BinWashUserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BinWashUserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BinWashUser'> extends True ? Prisma__BinWashUserClient<BinWashUserGetPayload<T>> : Prisma__BinWashUserClient<BinWashUserGetPayload<T> | null, null>

    /**
     * Find the first BinWashUser that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinWashUserFindFirstOrThrowArgs} args - Arguments to find a BinWashUser
     * @example
     * // Get one BinWashUser
     * const binWashUser = await prisma.binWashUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BinWashUserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BinWashUserFindFirstOrThrowArgs>
    ): Prisma__BinWashUserClient<BinWashUserGetPayload<T>>

    /**
     * Find zero or more BinWashUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinWashUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BinWashUsers
     * const binWashUsers = await prisma.binWashUser.findMany()
     * 
     * // Get first 10 BinWashUsers
     * const binWashUsers = await prisma.binWashUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const binWashUserWithIdOnly = await prisma.binWashUser.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BinWashUserFindManyArgs>(
      args?: SelectSubset<T, BinWashUserFindManyArgs>
    ): Prisma.PrismaPromise<Array<BinWashUserGetPayload<T>>>

    /**
     * Create a BinWashUser.
     * @param {BinWashUserCreateArgs} args - Arguments to create a BinWashUser.
     * @example
     * // Create one BinWashUser
     * const BinWashUser = await prisma.binWashUser.create({
     *   data: {
     *     // ... data to create a BinWashUser
     *   }
     * })
     * 
    **/
    create<T extends BinWashUserCreateArgs>(
      args: SelectSubset<T, BinWashUserCreateArgs>
    ): Prisma__BinWashUserClient<BinWashUserGetPayload<T>>

    /**
     * Create many BinWashUsers.
     *     @param {BinWashUserCreateManyArgs} args - Arguments to create many BinWashUsers.
     *     @example
     *     // Create many BinWashUsers
     *     const binWashUser = await prisma.binWashUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BinWashUserCreateManyArgs>(
      args?: SelectSubset<T, BinWashUserCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BinWashUser.
     * @param {BinWashUserDeleteArgs} args - Arguments to delete one BinWashUser.
     * @example
     * // Delete one BinWashUser
     * const BinWashUser = await prisma.binWashUser.delete({
     *   where: {
     *     // ... filter to delete one BinWashUser
     *   }
     * })
     * 
    **/
    delete<T extends BinWashUserDeleteArgs>(
      args: SelectSubset<T, BinWashUserDeleteArgs>
    ): Prisma__BinWashUserClient<BinWashUserGetPayload<T>>

    /**
     * Update one BinWashUser.
     * @param {BinWashUserUpdateArgs} args - Arguments to update one BinWashUser.
     * @example
     * // Update one BinWashUser
     * const binWashUser = await prisma.binWashUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BinWashUserUpdateArgs>(
      args: SelectSubset<T, BinWashUserUpdateArgs>
    ): Prisma__BinWashUserClient<BinWashUserGetPayload<T>>

    /**
     * Delete zero or more BinWashUsers.
     * @param {BinWashUserDeleteManyArgs} args - Arguments to filter BinWashUsers to delete.
     * @example
     * // Delete a few BinWashUsers
     * const { count } = await prisma.binWashUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BinWashUserDeleteManyArgs>(
      args?: SelectSubset<T, BinWashUserDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BinWashUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinWashUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BinWashUsers
     * const binWashUser = await prisma.binWashUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BinWashUserUpdateManyArgs>(
      args: SelectSubset<T, BinWashUserUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BinWashUser.
     * @param {BinWashUserUpsertArgs} args - Arguments to update or create a BinWashUser.
     * @example
     * // Update or create a BinWashUser
     * const binWashUser = await prisma.binWashUser.upsert({
     *   create: {
     *     // ... data to create a BinWashUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BinWashUser we want to update
     *   }
     * })
    **/
    upsert<T extends BinWashUserUpsertArgs>(
      args: SelectSubset<T, BinWashUserUpsertArgs>
    ): Prisma__BinWashUserClient<BinWashUserGetPayload<T>>

    /**
     * Count the number of BinWashUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinWashUserCountArgs} args - Arguments to filter BinWashUsers to count.
     * @example
     * // Count the number of BinWashUsers
     * const count = await prisma.binWashUser.count({
     *   where: {
     *     // ... the filter for the BinWashUsers we want to count
     *   }
     * })
    **/
    count<T extends BinWashUserCountArgs>(
      args?: Subset<T, BinWashUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BinWashUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BinWashUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinWashUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BinWashUserAggregateArgs>(args: Subset<T, BinWashUserAggregateArgs>): Prisma.PrismaPromise<GetBinWashUserAggregateType<T>>

    /**
     * Group by BinWashUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinWashUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BinWashUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BinWashUserGroupByArgs['orderBy'] }
        : { orderBy?: BinWashUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BinWashUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBinWashUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BinWashUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BinWashUserClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    owningBranches<T extends BinWashUser$owningBranchesArgs= {}>(args?: Subset<T, BinWashUser$owningBranchesArgs>): Prisma.PrismaPromise<Array<BranchGetPayload<T>>| Null>;

    wMMaintenanceRecords<T extends BinWashUser$wMMaintenanceRecordsArgs= {}>(args?: Subset<T, BinWashUser$wMMaintenanceRecordsArgs>): Prisma.PrismaPromise<Array<WMMaintenanceRecordGetPayload<T>>| Null>;

    usageRecords<T extends BinWashUser$usageRecordsArgs= {}>(args?: Subset<T, BinWashUser$usageRecordsArgs>): Prisma.PrismaPromise<Array<UsageRecordGetPayload<T>>| Null>;

    topUpRecords<T extends BinWashUser$topUpRecordsArgs= {}>(args?: Subset<T, BinWashUser$topUpRecordsArgs>): Prisma.PrismaPromise<Array<TopUpRecordGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BinWashUser base type for findUnique actions
   */
  export type BinWashUserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BinWashUser
     */
    select?: BinWashUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinWashUserInclude | null
    /**
     * Filter, which BinWashUser to fetch.
     */
    where: BinWashUserWhereUniqueInput
  }

  /**
   * BinWashUser findUnique
   */
  export interface BinWashUserFindUniqueArgs extends BinWashUserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BinWashUser findUniqueOrThrow
   */
  export type BinWashUserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BinWashUser
     */
    select?: BinWashUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinWashUserInclude | null
    /**
     * Filter, which BinWashUser to fetch.
     */
    where: BinWashUserWhereUniqueInput
  }


  /**
   * BinWashUser base type for findFirst actions
   */
  export type BinWashUserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BinWashUser
     */
    select?: BinWashUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinWashUserInclude | null
    /**
     * Filter, which BinWashUser to fetch.
     */
    where?: BinWashUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BinWashUsers to fetch.
     */
    orderBy?: Enumerable<BinWashUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BinWashUsers.
     */
    cursor?: BinWashUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BinWashUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BinWashUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BinWashUsers.
     */
    distinct?: Enumerable<BinWashUserScalarFieldEnum>
  }

  /**
   * BinWashUser findFirst
   */
  export interface BinWashUserFindFirstArgs extends BinWashUserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BinWashUser findFirstOrThrow
   */
  export type BinWashUserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BinWashUser
     */
    select?: BinWashUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinWashUserInclude | null
    /**
     * Filter, which BinWashUser to fetch.
     */
    where?: BinWashUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BinWashUsers to fetch.
     */
    orderBy?: Enumerable<BinWashUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BinWashUsers.
     */
    cursor?: BinWashUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BinWashUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BinWashUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BinWashUsers.
     */
    distinct?: Enumerable<BinWashUserScalarFieldEnum>
  }


  /**
   * BinWashUser findMany
   */
  export type BinWashUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the BinWashUser
     */
    select?: BinWashUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinWashUserInclude | null
    /**
     * Filter, which BinWashUsers to fetch.
     */
    where?: BinWashUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BinWashUsers to fetch.
     */
    orderBy?: Enumerable<BinWashUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BinWashUsers.
     */
    cursor?: BinWashUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BinWashUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BinWashUsers.
     */
    skip?: number
    distinct?: Enumerable<BinWashUserScalarFieldEnum>
  }


  /**
   * BinWashUser create
   */
  export type BinWashUserCreateArgs = {
    /**
     * Select specific fields to fetch from the BinWashUser
     */
    select?: BinWashUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinWashUserInclude | null
    /**
     * The data needed to create a BinWashUser.
     */
    data: XOR<BinWashUserCreateInput, BinWashUserUncheckedCreateInput>
  }


  /**
   * BinWashUser createMany
   */
  export type BinWashUserCreateManyArgs = {
    /**
     * The data used to create many BinWashUsers.
     */
    data: Enumerable<BinWashUserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BinWashUser update
   */
  export type BinWashUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the BinWashUser
     */
    select?: BinWashUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinWashUserInclude | null
    /**
     * The data needed to update a BinWashUser.
     */
    data: XOR<BinWashUserUpdateInput, BinWashUserUncheckedUpdateInput>
    /**
     * Choose, which BinWashUser to update.
     */
    where: BinWashUserWhereUniqueInput
  }


  /**
   * BinWashUser updateMany
   */
  export type BinWashUserUpdateManyArgs = {
    /**
     * The data used to update BinWashUsers.
     */
    data: XOR<BinWashUserUpdateManyMutationInput, BinWashUserUncheckedUpdateManyInput>
    /**
     * Filter which BinWashUsers to update
     */
    where?: BinWashUserWhereInput
  }


  /**
   * BinWashUser upsert
   */
  export type BinWashUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the BinWashUser
     */
    select?: BinWashUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinWashUserInclude | null
    /**
     * The filter to search for the BinWashUser to update in case it exists.
     */
    where: BinWashUserWhereUniqueInput
    /**
     * In case the BinWashUser found by the `where` argument doesn't exist, create a new BinWashUser with this data.
     */
    create: XOR<BinWashUserCreateInput, BinWashUserUncheckedCreateInput>
    /**
     * In case the BinWashUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BinWashUserUpdateInput, BinWashUserUncheckedUpdateInput>
  }


  /**
   * BinWashUser delete
   */
  export type BinWashUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the BinWashUser
     */
    select?: BinWashUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinWashUserInclude | null
    /**
     * Filter which BinWashUser to delete.
     */
    where: BinWashUserWhereUniqueInput
  }


  /**
   * BinWashUser deleteMany
   */
  export type BinWashUserDeleteManyArgs = {
    /**
     * Filter which BinWashUsers to delete
     */
    where?: BinWashUserWhereInput
  }


  /**
   * BinWashUser.owningBranches
   */
  export type BinWashUser$owningBranchesArgs = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchInclude | null
    where?: BranchWhereInput
    orderBy?: Enumerable<BranchOrderByWithRelationInput>
    cursor?: BranchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BranchScalarFieldEnum>
  }


  /**
   * BinWashUser.wMMaintenanceRecords
   */
  export type BinWashUser$wMMaintenanceRecordsArgs = {
    /**
     * Select specific fields to fetch from the WMMaintenanceRecord
     */
    select?: WMMaintenanceRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WMMaintenanceRecordInclude | null
    where?: WMMaintenanceRecordWhereInput
    orderBy?: Enumerable<WMMaintenanceRecordOrderByWithRelationInput>
    cursor?: WMMaintenanceRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WMMaintenanceRecordScalarFieldEnum>
  }


  /**
   * BinWashUser.usageRecords
   */
  export type BinWashUser$usageRecordsArgs = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsageRecordInclude | null
    where?: UsageRecordWhereInput
    orderBy?: Enumerable<UsageRecordOrderByWithRelationInput>
    cursor?: UsageRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UsageRecordScalarFieldEnum>
  }


  /**
   * BinWashUser.topUpRecords
   */
  export type BinWashUser$topUpRecordsArgs = {
    /**
     * Select specific fields to fetch from the TopUpRecord
     */
    select?: TopUpRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TopUpRecordInclude | null
    where?: TopUpRecordWhereInput
    orderBy?: Enumerable<TopUpRecordOrderByWithRelationInput>
    cursor?: TopUpRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TopUpRecordScalarFieldEnum>
  }


  /**
   * BinWashUser without action
   */
  export type BinWashUserArgs = {
    /**
     * Select specific fields to fetch from the BinWashUser
     */
    select?: BinWashUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinWashUserInclude | null
  }



  /**
   * Model Branch
   */


  export type AggregateBranch = {
    _count: BranchCountAggregateOutputType | null
    _avg: BranchAvgAggregateOutputType | null
    _sum: BranchSumAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  export type BranchAvgAggregateOutputType = {
    id: number | null
    area: number | null
    binWashUserId: number | null
  }

  export type BranchSumAggregateOutputType = {
    id: number | null
    area: number | null
    binWashUserId: number | null
  }

  export type BranchMinAggregateOutputType = {
    id: number | null
    name: string | null
    location: string | null
    telephoneNo: string | null
    area: number | null
    binWashUserId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BranchMaxAggregateOutputType = {
    id: number | null
    name: string | null
    location: string | null
    telephoneNo: string | null
    area: number | null
    binWashUserId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BranchCountAggregateOutputType = {
    id: number
    name: number
    location: number
    telephoneNo: number
    area: number
    binWashUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BranchAvgAggregateInputType = {
    id?: true
    area?: true
    binWashUserId?: true
  }

  export type BranchSumAggregateInputType = {
    id?: true
    area?: true
    binWashUserId?: true
  }

  export type BranchMinAggregateInputType = {
    id?: true
    name?: true
    location?: true
    telephoneNo?: true
    area?: true
    binWashUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BranchMaxAggregateInputType = {
    id?: true
    name?: true
    location?: true
    telephoneNo?: true
    area?: true
    binWashUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BranchCountAggregateInputType = {
    id?: true
    name?: true
    location?: true
    telephoneNo?: true
    area?: true
    binWashUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BranchAggregateArgs = {
    /**
     * Filter which Branch to aggregate.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: Enumerable<BranchOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Branches
    **/
    _count?: true | BranchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BranchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BranchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BranchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BranchMaxAggregateInputType
  }

  export type GetBranchAggregateType<T extends BranchAggregateArgs> = {
        [P in keyof T & keyof AggregateBranch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBranch[P]>
      : GetScalarType<T[P], AggregateBranch[P]>
  }




  export type BranchGroupByArgs = {
    where?: BranchWhereInput
    orderBy?: Enumerable<BranchOrderByWithAggregationInput>
    by: BranchScalarFieldEnum[]
    having?: BranchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BranchCountAggregateInputType | true
    _avg?: BranchAvgAggregateInputType
    _sum?: BranchSumAggregateInputType
    _min?: BranchMinAggregateInputType
    _max?: BranchMaxAggregateInputType
  }


  export type BranchGroupByOutputType = {
    id: number
    name: string
    location: string
    telephoneNo: string
    area: number
    binWashUserId: number
    createdAt: Date
    updatedAt: Date
    _count: BranchCountAggregateOutputType | null
    _avg: BranchAvgAggregateOutputType | null
    _sum: BranchSumAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  type GetBranchGroupByPayload<T extends BranchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BranchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BranchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BranchGroupByOutputType[P]>
            : GetScalarType<T[P], BranchGroupByOutputType[P]>
        }
      >
    >


  export type BranchSelect = {
    id?: boolean
    name?: boolean
    location?: boolean
    telephoneNo?: boolean
    area?: boolean
    branchOwner?: boolean | BinWashUserArgs
    binWashUserId?: boolean
    washingMachines?: boolean | Branch$washingMachinesArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | BranchCountOutputTypeArgs
  }


  export type BranchInclude = {
    branchOwner?: boolean | BinWashUserArgs
    washingMachines?: boolean | Branch$washingMachinesArgs
    _count?: boolean | BranchCountOutputTypeArgs
  }

  export type BranchGetPayload<S extends boolean | null | undefined | BranchArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Branch :
    S extends undefined ? never :
    S extends { include: any } & (BranchArgs | BranchFindManyArgs)
    ? Branch  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'branchOwner' ? BinWashUserGetPayload<S['include'][P]> :
        P extends 'washingMachines' ? Array < WashingMachineGetPayload<S['include'][P]>>  :
        P extends '_count' ? BranchCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BranchArgs | BranchFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'branchOwner' ? BinWashUserGetPayload<S['select'][P]> :
        P extends 'washingMachines' ? Array < WashingMachineGetPayload<S['select'][P]>>  :
        P extends '_count' ? BranchCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Branch ? Branch[P] : never
  } 
      : Branch


  type BranchCountArgs = 
    Omit<BranchFindManyArgs, 'select' | 'include'> & {
      select?: BranchCountAggregateInputType | true
    }

  export interface BranchDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Branch that matches the filter.
     * @param {BranchFindUniqueArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BranchFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BranchFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Branch'> extends True ? Prisma__BranchClient<BranchGetPayload<T>> : Prisma__BranchClient<BranchGetPayload<T> | null, null>

    /**
     * Find one Branch that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BranchFindUniqueOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BranchFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BranchFindUniqueOrThrowArgs>
    ): Prisma__BranchClient<BranchGetPayload<T>>

    /**
     * Find the first Branch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BranchFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BranchFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Branch'> extends True ? Prisma__BranchClient<BranchGetPayload<T>> : Prisma__BranchClient<BranchGetPayload<T> | null, null>

    /**
     * Find the first Branch that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BranchFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BranchFindFirstOrThrowArgs>
    ): Prisma__BranchClient<BranchGetPayload<T>>

    /**
     * Find zero or more Branches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Branches
     * const branches = await prisma.branch.findMany()
     * 
     * // Get first 10 Branches
     * const branches = await prisma.branch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const branchWithIdOnly = await prisma.branch.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BranchFindManyArgs>(
      args?: SelectSubset<T, BranchFindManyArgs>
    ): Prisma.PrismaPromise<Array<BranchGetPayload<T>>>

    /**
     * Create a Branch.
     * @param {BranchCreateArgs} args - Arguments to create a Branch.
     * @example
     * // Create one Branch
     * const Branch = await prisma.branch.create({
     *   data: {
     *     // ... data to create a Branch
     *   }
     * })
     * 
    **/
    create<T extends BranchCreateArgs>(
      args: SelectSubset<T, BranchCreateArgs>
    ): Prisma__BranchClient<BranchGetPayload<T>>

    /**
     * Create many Branches.
     *     @param {BranchCreateManyArgs} args - Arguments to create many Branches.
     *     @example
     *     // Create many Branches
     *     const branch = await prisma.branch.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BranchCreateManyArgs>(
      args?: SelectSubset<T, BranchCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Branch.
     * @param {BranchDeleteArgs} args - Arguments to delete one Branch.
     * @example
     * // Delete one Branch
     * const Branch = await prisma.branch.delete({
     *   where: {
     *     // ... filter to delete one Branch
     *   }
     * })
     * 
    **/
    delete<T extends BranchDeleteArgs>(
      args: SelectSubset<T, BranchDeleteArgs>
    ): Prisma__BranchClient<BranchGetPayload<T>>

    /**
     * Update one Branch.
     * @param {BranchUpdateArgs} args - Arguments to update one Branch.
     * @example
     * // Update one Branch
     * const branch = await prisma.branch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BranchUpdateArgs>(
      args: SelectSubset<T, BranchUpdateArgs>
    ): Prisma__BranchClient<BranchGetPayload<T>>

    /**
     * Delete zero or more Branches.
     * @param {BranchDeleteManyArgs} args - Arguments to filter Branches to delete.
     * @example
     * // Delete a few Branches
     * const { count } = await prisma.branch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BranchDeleteManyArgs>(
      args?: SelectSubset<T, BranchDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Branches
     * const branch = await prisma.branch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BranchUpdateManyArgs>(
      args: SelectSubset<T, BranchUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Branch.
     * @param {BranchUpsertArgs} args - Arguments to update or create a Branch.
     * @example
     * // Update or create a Branch
     * const branch = await prisma.branch.upsert({
     *   create: {
     *     // ... data to create a Branch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Branch we want to update
     *   }
     * })
    **/
    upsert<T extends BranchUpsertArgs>(
      args: SelectSubset<T, BranchUpsertArgs>
    ): Prisma__BranchClient<BranchGetPayload<T>>

    /**
     * Count the number of Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchCountArgs} args - Arguments to filter Branches to count.
     * @example
     * // Count the number of Branches
     * const count = await prisma.branch.count({
     *   where: {
     *     // ... the filter for the Branches we want to count
     *   }
     * })
    **/
    count<T extends BranchCountArgs>(
      args?: Subset<T, BranchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BranchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BranchAggregateArgs>(args: Subset<T, BranchAggregateArgs>): Prisma.PrismaPromise<GetBranchAggregateType<T>>

    /**
     * Group by Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BranchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BranchGroupByArgs['orderBy'] }
        : { orderBy?: BranchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BranchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBranchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Branch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BranchClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    branchOwner<T extends BinWashUserArgs= {}>(args?: Subset<T, BinWashUserArgs>): Prisma__BinWashUserClient<BinWashUserGetPayload<T> | Null>;

    washingMachines<T extends Branch$washingMachinesArgs= {}>(args?: Subset<T, Branch$washingMachinesArgs>): Prisma.PrismaPromise<Array<WashingMachineGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Branch base type for findUnique actions
   */
  export type BranchFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchInclude | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch findUnique
   */
  export interface BranchFindUniqueArgs extends BranchFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Branch findUniqueOrThrow
   */
  export type BranchFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchInclude | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }


  /**
   * Branch base type for findFirst actions
   */
  export type BranchFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchInclude | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: Enumerable<BranchOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: Enumerable<BranchScalarFieldEnum>
  }

  /**
   * Branch findFirst
   */
  export interface BranchFindFirstArgs extends BranchFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Branch findFirstOrThrow
   */
  export type BranchFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchInclude | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: Enumerable<BranchOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: Enumerable<BranchScalarFieldEnum>
  }


  /**
   * Branch findMany
   */
  export type BranchFindManyArgs = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchInclude | null
    /**
     * Filter, which Branches to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: Enumerable<BranchOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    distinct?: Enumerable<BranchScalarFieldEnum>
  }


  /**
   * Branch create
   */
  export type BranchCreateArgs = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchInclude | null
    /**
     * The data needed to create a Branch.
     */
    data: XOR<BranchCreateInput, BranchUncheckedCreateInput>
  }


  /**
   * Branch createMany
   */
  export type BranchCreateManyArgs = {
    /**
     * The data used to create many Branches.
     */
    data: Enumerable<BranchCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Branch update
   */
  export type BranchUpdateArgs = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchInclude | null
    /**
     * The data needed to update a Branch.
     */
    data: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
    /**
     * Choose, which Branch to update.
     */
    where: BranchWhereUniqueInput
  }


  /**
   * Branch updateMany
   */
  export type BranchUpdateManyArgs = {
    /**
     * The data used to update Branches.
     */
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyInput>
    /**
     * Filter which Branches to update
     */
    where?: BranchWhereInput
  }


  /**
   * Branch upsert
   */
  export type BranchUpsertArgs = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchInclude | null
    /**
     * The filter to search for the Branch to update in case it exists.
     */
    where: BranchWhereUniqueInput
    /**
     * In case the Branch found by the `where` argument doesn't exist, create a new Branch with this data.
     */
    create: XOR<BranchCreateInput, BranchUncheckedCreateInput>
    /**
     * In case the Branch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
  }


  /**
   * Branch delete
   */
  export type BranchDeleteArgs = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchInclude | null
    /**
     * Filter which Branch to delete.
     */
    where: BranchWhereUniqueInput
  }


  /**
   * Branch deleteMany
   */
  export type BranchDeleteManyArgs = {
    /**
     * Filter which Branches to delete
     */
    where?: BranchWhereInput
  }


  /**
   * Branch.washingMachines
   */
  export type Branch$washingMachinesArgs = {
    /**
     * Select specific fields to fetch from the WashingMachine
     */
    select?: WashingMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WashingMachineInclude | null
    where?: WashingMachineWhereInput
    orderBy?: Enumerable<WashingMachineOrderByWithRelationInput>
    cursor?: WashingMachineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WashingMachineScalarFieldEnum>
  }


  /**
   * Branch without action
   */
  export type BranchArgs = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchInclude | null
  }



  /**
   * Model WashingMachine
   */


  export type AggregateWashingMachine = {
    _count: WashingMachineCountAggregateOutputType | null
    _avg: WashingMachineAvgAggregateOutputType | null
    _sum: WashingMachineSumAggregateOutputType | null
    _min: WashingMachineMinAggregateOutputType | null
    _max: WashingMachineMaxAggregateOutputType | null
  }

  export type WashingMachineAvgAggregateOutputType = {
    id: number | null
    capacity: number | null
    branchId: number | null
  }

  export type WashingMachineSumAggregateOutputType = {
    id: number | null
    capacity: number | null
    branchId: number | null
  }

  export type WashingMachineMinAggregateOutputType = {
    id: number | null
    brand: string | null
    model: string | null
    type: WMTypeEnum | null
    capacity: number | null
    manufacturedYear: Date | null
    warrantyEndDate: Date | null
    branchId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WashingMachineMaxAggregateOutputType = {
    id: number | null
    brand: string | null
    model: string | null
    type: WMTypeEnum | null
    capacity: number | null
    manufacturedYear: Date | null
    warrantyEndDate: Date | null
    branchId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WashingMachineCountAggregateOutputType = {
    id: number
    brand: number
    model: number
    type: number
    capacity: number
    manufacturedYear: number
    warrantyEndDate: number
    branchId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WashingMachineAvgAggregateInputType = {
    id?: true
    capacity?: true
    branchId?: true
  }

  export type WashingMachineSumAggregateInputType = {
    id?: true
    capacity?: true
    branchId?: true
  }

  export type WashingMachineMinAggregateInputType = {
    id?: true
    brand?: true
    model?: true
    type?: true
    capacity?: true
    manufacturedYear?: true
    warrantyEndDate?: true
    branchId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WashingMachineMaxAggregateInputType = {
    id?: true
    brand?: true
    model?: true
    type?: true
    capacity?: true
    manufacturedYear?: true
    warrantyEndDate?: true
    branchId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WashingMachineCountAggregateInputType = {
    id?: true
    brand?: true
    model?: true
    type?: true
    capacity?: true
    manufacturedYear?: true
    warrantyEndDate?: true
    branchId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WashingMachineAggregateArgs = {
    /**
     * Filter which WashingMachine to aggregate.
     */
    where?: WashingMachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WashingMachines to fetch.
     */
    orderBy?: Enumerable<WashingMachineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WashingMachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WashingMachines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WashingMachines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WashingMachines
    **/
    _count?: true | WashingMachineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WashingMachineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WashingMachineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WashingMachineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WashingMachineMaxAggregateInputType
  }

  export type GetWashingMachineAggregateType<T extends WashingMachineAggregateArgs> = {
        [P in keyof T & keyof AggregateWashingMachine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWashingMachine[P]>
      : GetScalarType<T[P], AggregateWashingMachine[P]>
  }




  export type WashingMachineGroupByArgs = {
    where?: WashingMachineWhereInput
    orderBy?: Enumerable<WashingMachineOrderByWithAggregationInput>
    by: WashingMachineScalarFieldEnum[]
    having?: WashingMachineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WashingMachineCountAggregateInputType | true
    _avg?: WashingMachineAvgAggregateInputType
    _sum?: WashingMachineSumAggregateInputType
    _min?: WashingMachineMinAggregateInputType
    _max?: WashingMachineMaxAggregateInputType
  }


  export type WashingMachineGroupByOutputType = {
    id: number
    brand: string
    model: string
    type: WMTypeEnum
    capacity: number
    manufacturedYear: Date
    warrantyEndDate: Date
    branchId: number
    createdAt: Date
    updatedAt: Date
    _count: WashingMachineCountAggregateOutputType | null
    _avg: WashingMachineAvgAggregateOutputType | null
    _sum: WashingMachineSumAggregateOutputType | null
    _min: WashingMachineMinAggregateOutputType | null
    _max: WashingMachineMaxAggregateOutputType | null
  }

  type GetWashingMachineGroupByPayload<T extends WashingMachineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<WashingMachineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WashingMachineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WashingMachineGroupByOutputType[P]>
            : GetScalarType<T[P], WashingMachineGroupByOutputType[P]>
        }
      >
    >


  export type WashingMachineSelect = {
    id?: boolean
    brand?: boolean
    model?: boolean
    type?: boolean
    capacity?: boolean
    manufacturedYear?: boolean
    warrantyEndDate?: boolean
    locatedBranch?: boolean | BranchArgs
    branchId?: boolean
    equippedPrograms?: boolean | WashingMachine$equippedProgramsArgs
    usageRecords?: boolean | WashingMachine$usageRecordsArgs
    wMMaintenanceRecords?: boolean | WashingMachine$wMMaintenanceRecordsArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | WashingMachineCountOutputTypeArgs
  }


  export type WashingMachineInclude = {
    locatedBranch?: boolean | BranchArgs
    equippedPrograms?: boolean | WashingMachine$equippedProgramsArgs
    usageRecords?: boolean | WashingMachine$usageRecordsArgs
    wMMaintenanceRecords?: boolean | WashingMachine$wMMaintenanceRecordsArgs
    _count?: boolean | WashingMachineCountOutputTypeArgs
  }

  export type WashingMachineGetPayload<S extends boolean | null | undefined | WashingMachineArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? WashingMachine :
    S extends undefined ? never :
    S extends { include: any } & (WashingMachineArgs | WashingMachineFindManyArgs)
    ? WashingMachine  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'locatedBranch' ? BranchGetPayload<S['include'][P]> :
        P extends 'equippedPrograms' ? Array < WMProgramGetPayload<S['include'][P]>>  :
        P extends 'usageRecords' ? Array < UsageRecordGetPayload<S['include'][P]>>  :
        P extends 'wMMaintenanceRecords' ? Array < WMMaintenanceRecordGetPayload<S['include'][P]>>  :
        P extends '_count' ? WashingMachineCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (WashingMachineArgs | WashingMachineFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'locatedBranch' ? BranchGetPayload<S['select'][P]> :
        P extends 'equippedPrograms' ? Array < WMProgramGetPayload<S['select'][P]>>  :
        P extends 'usageRecords' ? Array < UsageRecordGetPayload<S['select'][P]>>  :
        P extends 'wMMaintenanceRecords' ? Array < WMMaintenanceRecordGetPayload<S['select'][P]>>  :
        P extends '_count' ? WashingMachineCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof WashingMachine ? WashingMachine[P] : never
  } 
      : WashingMachine


  type WashingMachineCountArgs = 
    Omit<WashingMachineFindManyArgs, 'select' | 'include'> & {
      select?: WashingMachineCountAggregateInputType | true
    }

  export interface WashingMachineDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one WashingMachine that matches the filter.
     * @param {WashingMachineFindUniqueArgs} args - Arguments to find a WashingMachine
     * @example
     * // Get one WashingMachine
     * const washingMachine = await prisma.washingMachine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WashingMachineFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WashingMachineFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'WashingMachine'> extends True ? Prisma__WashingMachineClient<WashingMachineGetPayload<T>> : Prisma__WashingMachineClient<WashingMachineGetPayload<T> | null, null>

    /**
     * Find one WashingMachine that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WashingMachineFindUniqueOrThrowArgs} args - Arguments to find a WashingMachine
     * @example
     * // Get one WashingMachine
     * const washingMachine = await prisma.washingMachine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WashingMachineFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, WashingMachineFindUniqueOrThrowArgs>
    ): Prisma__WashingMachineClient<WashingMachineGetPayload<T>>

    /**
     * Find the first WashingMachine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WashingMachineFindFirstArgs} args - Arguments to find a WashingMachine
     * @example
     * // Get one WashingMachine
     * const washingMachine = await prisma.washingMachine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WashingMachineFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WashingMachineFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'WashingMachine'> extends True ? Prisma__WashingMachineClient<WashingMachineGetPayload<T>> : Prisma__WashingMachineClient<WashingMachineGetPayload<T> | null, null>

    /**
     * Find the first WashingMachine that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WashingMachineFindFirstOrThrowArgs} args - Arguments to find a WashingMachine
     * @example
     * // Get one WashingMachine
     * const washingMachine = await prisma.washingMachine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WashingMachineFindFirstOrThrowArgs>(
      args?: SelectSubset<T, WashingMachineFindFirstOrThrowArgs>
    ): Prisma__WashingMachineClient<WashingMachineGetPayload<T>>

    /**
     * Find zero or more WashingMachines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WashingMachineFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WashingMachines
     * const washingMachines = await prisma.washingMachine.findMany()
     * 
     * // Get first 10 WashingMachines
     * const washingMachines = await prisma.washingMachine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const washingMachineWithIdOnly = await prisma.washingMachine.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WashingMachineFindManyArgs>(
      args?: SelectSubset<T, WashingMachineFindManyArgs>
    ): Prisma.PrismaPromise<Array<WashingMachineGetPayload<T>>>

    /**
     * Create a WashingMachine.
     * @param {WashingMachineCreateArgs} args - Arguments to create a WashingMachine.
     * @example
     * // Create one WashingMachine
     * const WashingMachine = await prisma.washingMachine.create({
     *   data: {
     *     // ... data to create a WashingMachine
     *   }
     * })
     * 
    **/
    create<T extends WashingMachineCreateArgs>(
      args: SelectSubset<T, WashingMachineCreateArgs>
    ): Prisma__WashingMachineClient<WashingMachineGetPayload<T>>

    /**
     * Create many WashingMachines.
     *     @param {WashingMachineCreateManyArgs} args - Arguments to create many WashingMachines.
     *     @example
     *     // Create many WashingMachines
     *     const washingMachine = await prisma.washingMachine.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WashingMachineCreateManyArgs>(
      args?: SelectSubset<T, WashingMachineCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WashingMachine.
     * @param {WashingMachineDeleteArgs} args - Arguments to delete one WashingMachine.
     * @example
     * // Delete one WashingMachine
     * const WashingMachine = await prisma.washingMachine.delete({
     *   where: {
     *     // ... filter to delete one WashingMachine
     *   }
     * })
     * 
    **/
    delete<T extends WashingMachineDeleteArgs>(
      args: SelectSubset<T, WashingMachineDeleteArgs>
    ): Prisma__WashingMachineClient<WashingMachineGetPayload<T>>

    /**
     * Update one WashingMachine.
     * @param {WashingMachineUpdateArgs} args - Arguments to update one WashingMachine.
     * @example
     * // Update one WashingMachine
     * const washingMachine = await prisma.washingMachine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WashingMachineUpdateArgs>(
      args: SelectSubset<T, WashingMachineUpdateArgs>
    ): Prisma__WashingMachineClient<WashingMachineGetPayload<T>>

    /**
     * Delete zero or more WashingMachines.
     * @param {WashingMachineDeleteManyArgs} args - Arguments to filter WashingMachines to delete.
     * @example
     * // Delete a few WashingMachines
     * const { count } = await prisma.washingMachine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WashingMachineDeleteManyArgs>(
      args?: SelectSubset<T, WashingMachineDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WashingMachines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WashingMachineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WashingMachines
     * const washingMachine = await prisma.washingMachine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WashingMachineUpdateManyArgs>(
      args: SelectSubset<T, WashingMachineUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WashingMachine.
     * @param {WashingMachineUpsertArgs} args - Arguments to update or create a WashingMachine.
     * @example
     * // Update or create a WashingMachine
     * const washingMachine = await prisma.washingMachine.upsert({
     *   create: {
     *     // ... data to create a WashingMachine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WashingMachine we want to update
     *   }
     * })
    **/
    upsert<T extends WashingMachineUpsertArgs>(
      args: SelectSubset<T, WashingMachineUpsertArgs>
    ): Prisma__WashingMachineClient<WashingMachineGetPayload<T>>

    /**
     * Count the number of WashingMachines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WashingMachineCountArgs} args - Arguments to filter WashingMachines to count.
     * @example
     * // Count the number of WashingMachines
     * const count = await prisma.washingMachine.count({
     *   where: {
     *     // ... the filter for the WashingMachines we want to count
     *   }
     * })
    **/
    count<T extends WashingMachineCountArgs>(
      args?: Subset<T, WashingMachineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WashingMachineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WashingMachine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WashingMachineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WashingMachineAggregateArgs>(args: Subset<T, WashingMachineAggregateArgs>): Prisma.PrismaPromise<GetWashingMachineAggregateType<T>>

    /**
     * Group by WashingMachine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WashingMachineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WashingMachineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WashingMachineGroupByArgs['orderBy'] }
        : { orderBy?: WashingMachineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WashingMachineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWashingMachineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for WashingMachine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WashingMachineClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    locatedBranch<T extends BranchArgs= {}>(args?: Subset<T, BranchArgs>): Prisma__BranchClient<BranchGetPayload<T> | Null>;

    equippedPrograms<T extends WashingMachine$equippedProgramsArgs= {}>(args?: Subset<T, WashingMachine$equippedProgramsArgs>): Prisma.PrismaPromise<Array<WMProgramGetPayload<T>>| Null>;

    usageRecords<T extends WashingMachine$usageRecordsArgs= {}>(args?: Subset<T, WashingMachine$usageRecordsArgs>): Prisma.PrismaPromise<Array<UsageRecordGetPayload<T>>| Null>;

    wMMaintenanceRecords<T extends WashingMachine$wMMaintenanceRecordsArgs= {}>(args?: Subset<T, WashingMachine$wMMaintenanceRecordsArgs>): Prisma.PrismaPromise<Array<WMMaintenanceRecordGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * WashingMachine base type for findUnique actions
   */
  export type WashingMachineFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the WashingMachine
     */
    select?: WashingMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WashingMachineInclude | null
    /**
     * Filter, which WashingMachine to fetch.
     */
    where: WashingMachineWhereUniqueInput
  }

  /**
   * WashingMachine findUnique
   */
  export interface WashingMachineFindUniqueArgs extends WashingMachineFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WashingMachine findUniqueOrThrow
   */
  export type WashingMachineFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the WashingMachine
     */
    select?: WashingMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WashingMachineInclude | null
    /**
     * Filter, which WashingMachine to fetch.
     */
    where: WashingMachineWhereUniqueInput
  }


  /**
   * WashingMachine base type for findFirst actions
   */
  export type WashingMachineFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the WashingMachine
     */
    select?: WashingMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WashingMachineInclude | null
    /**
     * Filter, which WashingMachine to fetch.
     */
    where?: WashingMachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WashingMachines to fetch.
     */
    orderBy?: Enumerable<WashingMachineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WashingMachines.
     */
    cursor?: WashingMachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WashingMachines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WashingMachines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WashingMachines.
     */
    distinct?: Enumerable<WashingMachineScalarFieldEnum>
  }

  /**
   * WashingMachine findFirst
   */
  export interface WashingMachineFindFirstArgs extends WashingMachineFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WashingMachine findFirstOrThrow
   */
  export type WashingMachineFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the WashingMachine
     */
    select?: WashingMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WashingMachineInclude | null
    /**
     * Filter, which WashingMachine to fetch.
     */
    where?: WashingMachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WashingMachines to fetch.
     */
    orderBy?: Enumerable<WashingMachineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WashingMachines.
     */
    cursor?: WashingMachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WashingMachines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WashingMachines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WashingMachines.
     */
    distinct?: Enumerable<WashingMachineScalarFieldEnum>
  }


  /**
   * WashingMachine findMany
   */
  export type WashingMachineFindManyArgs = {
    /**
     * Select specific fields to fetch from the WashingMachine
     */
    select?: WashingMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WashingMachineInclude | null
    /**
     * Filter, which WashingMachines to fetch.
     */
    where?: WashingMachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WashingMachines to fetch.
     */
    orderBy?: Enumerable<WashingMachineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WashingMachines.
     */
    cursor?: WashingMachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WashingMachines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WashingMachines.
     */
    skip?: number
    distinct?: Enumerable<WashingMachineScalarFieldEnum>
  }


  /**
   * WashingMachine create
   */
  export type WashingMachineCreateArgs = {
    /**
     * Select specific fields to fetch from the WashingMachine
     */
    select?: WashingMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WashingMachineInclude | null
    /**
     * The data needed to create a WashingMachine.
     */
    data: XOR<WashingMachineCreateInput, WashingMachineUncheckedCreateInput>
  }


  /**
   * WashingMachine createMany
   */
  export type WashingMachineCreateManyArgs = {
    /**
     * The data used to create many WashingMachines.
     */
    data: Enumerable<WashingMachineCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * WashingMachine update
   */
  export type WashingMachineUpdateArgs = {
    /**
     * Select specific fields to fetch from the WashingMachine
     */
    select?: WashingMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WashingMachineInclude | null
    /**
     * The data needed to update a WashingMachine.
     */
    data: XOR<WashingMachineUpdateInput, WashingMachineUncheckedUpdateInput>
    /**
     * Choose, which WashingMachine to update.
     */
    where: WashingMachineWhereUniqueInput
  }


  /**
   * WashingMachine updateMany
   */
  export type WashingMachineUpdateManyArgs = {
    /**
     * The data used to update WashingMachines.
     */
    data: XOR<WashingMachineUpdateManyMutationInput, WashingMachineUncheckedUpdateManyInput>
    /**
     * Filter which WashingMachines to update
     */
    where?: WashingMachineWhereInput
  }


  /**
   * WashingMachine upsert
   */
  export type WashingMachineUpsertArgs = {
    /**
     * Select specific fields to fetch from the WashingMachine
     */
    select?: WashingMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WashingMachineInclude | null
    /**
     * The filter to search for the WashingMachine to update in case it exists.
     */
    where: WashingMachineWhereUniqueInput
    /**
     * In case the WashingMachine found by the `where` argument doesn't exist, create a new WashingMachine with this data.
     */
    create: XOR<WashingMachineCreateInput, WashingMachineUncheckedCreateInput>
    /**
     * In case the WashingMachine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WashingMachineUpdateInput, WashingMachineUncheckedUpdateInput>
  }


  /**
   * WashingMachine delete
   */
  export type WashingMachineDeleteArgs = {
    /**
     * Select specific fields to fetch from the WashingMachine
     */
    select?: WashingMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WashingMachineInclude | null
    /**
     * Filter which WashingMachine to delete.
     */
    where: WashingMachineWhereUniqueInput
  }


  /**
   * WashingMachine deleteMany
   */
  export type WashingMachineDeleteManyArgs = {
    /**
     * Filter which WashingMachines to delete
     */
    where?: WashingMachineWhereInput
  }


  /**
   * WashingMachine.equippedPrograms
   */
  export type WashingMachine$equippedProgramsArgs = {
    /**
     * Select specific fields to fetch from the WMProgram
     */
    select?: WMProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WMProgramInclude | null
    where?: WMProgramWhereInput
    orderBy?: Enumerable<WMProgramOrderByWithRelationInput>
    cursor?: WMProgramWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WMProgramScalarFieldEnum>
  }


  /**
   * WashingMachine.usageRecords
   */
  export type WashingMachine$usageRecordsArgs = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsageRecordInclude | null
    where?: UsageRecordWhereInput
    orderBy?: Enumerable<UsageRecordOrderByWithRelationInput>
    cursor?: UsageRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UsageRecordScalarFieldEnum>
  }


  /**
   * WashingMachine.wMMaintenanceRecords
   */
  export type WashingMachine$wMMaintenanceRecordsArgs = {
    /**
     * Select specific fields to fetch from the WMMaintenanceRecord
     */
    select?: WMMaintenanceRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WMMaintenanceRecordInclude | null
    where?: WMMaintenanceRecordWhereInput
    orderBy?: Enumerable<WMMaintenanceRecordOrderByWithRelationInput>
    cursor?: WMMaintenanceRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WMMaintenanceRecordScalarFieldEnum>
  }


  /**
   * WashingMachine without action
   */
  export type WashingMachineArgs = {
    /**
     * Select specific fields to fetch from the WashingMachine
     */
    select?: WashingMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WashingMachineInclude | null
  }



  /**
   * Model WMProgram
   */


  export type AggregateWMProgram = {
    _count: WMProgramCountAggregateOutputType | null
    _avg: WMProgramAvgAggregateOutputType | null
    _sum: WMProgramSumAggregateOutputType | null
    _min: WMProgramMinAggregateOutputType | null
    _max: WMProgramMaxAggregateOutputType | null
  }

  export type WMProgramAvgAggregateOutputType = {
    id: number | null
    maxCapacity: number | null
    duration: number | null
    price: number | null
  }

  export type WMProgramSumAggregateOutputType = {
    id: number | null
    maxCapacity: number | null
    duration: number | null
    price: number | null
  }

  export type WMProgramMinAggregateOutputType = {
    id: number | null
    name: string | null
    maxCapacity: number | null
    duration: number | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WMProgramMaxAggregateOutputType = {
    id: number | null
    name: string | null
    maxCapacity: number | null
    duration: number | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WMProgramCountAggregateOutputType = {
    id: number
    name: number
    maxCapacity: number
    duration: number
    price: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WMProgramAvgAggregateInputType = {
    id?: true
    maxCapacity?: true
    duration?: true
    price?: true
  }

  export type WMProgramSumAggregateInputType = {
    id?: true
    maxCapacity?: true
    duration?: true
    price?: true
  }

  export type WMProgramMinAggregateInputType = {
    id?: true
    name?: true
    maxCapacity?: true
    duration?: true
    price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WMProgramMaxAggregateInputType = {
    id?: true
    name?: true
    maxCapacity?: true
    duration?: true
    price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WMProgramCountAggregateInputType = {
    id?: true
    name?: true
    maxCapacity?: true
    duration?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WMProgramAggregateArgs = {
    /**
     * Filter which WMProgram to aggregate.
     */
    where?: WMProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WMPrograms to fetch.
     */
    orderBy?: Enumerable<WMProgramOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WMProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WMPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WMPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WMPrograms
    **/
    _count?: true | WMProgramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WMProgramAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WMProgramSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WMProgramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WMProgramMaxAggregateInputType
  }

  export type GetWMProgramAggregateType<T extends WMProgramAggregateArgs> = {
        [P in keyof T & keyof AggregateWMProgram]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWMProgram[P]>
      : GetScalarType<T[P], AggregateWMProgram[P]>
  }




  export type WMProgramGroupByArgs = {
    where?: WMProgramWhereInput
    orderBy?: Enumerable<WMProgramOrderByWithAggregationInput>
    by: WMProgramScalarFieldEnum[]
    having?: WMProgramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WMProgramCountAggregateInputType | true
    _avg?: WMProgramAvgAggregateInputType
    _sum?: WMProgramSumAggregateInputType
    _min?: WMProgramMinAggregateInputType
    _max?: WMProgramMaxAggregateInputType
  }


  export type WMProgramGroupByOutputType = {
    id: number
    name: string
    maxCapacity: number
    duration: number
    price: number
    createdAt: Date
    updatedAt: Date
    _count: WMProgramCountAggregateOutputType | null
    _avg: WMProgramAvgAggregateOutputType | null
    _sum: WMProgramSumAggregateOutputType | null
    _min: WMProgramMinAggregateOutputType | null
    _max: WMProgramMaxAggregateOutputType | null
  }

  type GetWMProgramGroupByPayload<T extends WMProgramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<WMProgramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WMProgramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WMProgramGroupByOutputType[P]>
            : GetScalarType<T[P], WMProgramGroupByOutputType[P]>
        }
      >
    >


  export type WMProgramSelect = {
    id?: boolean
    name?: boolean
    maxCapacity?: boolean
    duration?: boolean
    price?: boolean
    equippingWMs?: boolean | WMProgram$equippingWMsArgs
    usageRecords?: boolean | WMProgram$usageRecordsArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | WMProgramCountOutputTypeArgs
  }


  export type WMProgramInclude = {
    equippingWMs?: boolean | WMProgram$equippingWMsArgs
    usageRecords?: boolean | WMProgram$usageRecordsArgs
    _count?: boolean | WMProgramCountOutputTypeArgs
  }

  export type WMProgramGetPayload<S extends boolean | null | undefined | WMProgramArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? WMProgram :
    S extends undefined ? never :
    S extends { include: any } & (WMProgramArgs | WMProgramFindManyArgs)
    ? WMProgram  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'equippingWMs' ? Array < WashingMachineGetPayload<S['include'][P]>>  :
        P extends 'usageRecords' ? Array < UsageRecordGetPayload<S['include'][P]>>  :
        P extends '_count' ? WMProgramCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (WMProgramArgs | WMProgramFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'equippingWMs' ? Array < WashingMachineGetPayload<S['select'][P]>>  :
        P extends 'usageRecords' ? Array < UsageRecordGetPayload<S['select'][P]>>  :
        P extends '_count' ? WMProgramCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof WMProgram ? WMProgram[P] : never
  } 
      : WMProgram


  type WMProgramCountArgs = 
    Omit<WMProgramFindManyArgs, 'select' | 'include'> & {
      select?: WMProgramCountAggregateInputType | true
    }

  export interface WMProgramDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one WMProgram that matches the filter.
     * @param {WMProgramFindUniqueArgs} args - Arguments to find a WMProgram
     * @example
     * // Get one WMProgram
     * const wMProgram = await prisma.wMProgram.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WMProgramFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WMProgramFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'WMProgram'> extends True ? Prisma__WMProgramClient<WMProgramGetPayload<T>> : Prisma__WMProgramClient<WMProgramGetPayload<T> | null, null>

    /**
     * Find one WMProgram that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WMProgramFindUniqueOrThrowArgs} args - Arguments to find a WMProgram
     * @example
     * // Get one WMProgram
     * const wMProgram = await prisma.wMProgram.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WMProgramFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, WMProgramFindUniqueOrThrowArgs>
    ): Prisma__WMProgramClient<WMProgramGetPayload<T>>

    /**
     * Find the first WMProgram that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WMProgramFindFirstArgs} args - Arguments to find a WMProgram
     * @example
     * // Get one WMProgram
     * const wMProgram = await prisma.wMProgram.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WMProgramFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WMProgramFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'WMProgram'> extends True ? Prisma__WMProgramClient<WMProgramGetPayload<T>> : Prisma__WMProgramClient<WMProgramGetPayload<T> | null, null>

    /**
     * Find the first WMProgram that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WMProgramFindFirstOrThrowArgs} args - Arguments to find a WMProgram
     * @example
     * // Get one WMProgram
     * const wMProgram = await prisma.wMProgram.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WMProgramFindFirstOrThrowArgs>(
      args?: SelectSubset<T, WMProgramFindFirstOrThrowArgs>
    ): Prisma__WMProgramClient<WMProgramGetPayload<T>>

    /**
     * Find zero or more WMPrograms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WMProgramFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WMPrograms
     * const wMPrograms = await prisma.wMProgram.findMany()
     * 
     * // Get first 10 WMPrograms
     * const wMPrograms = await prisma.wMProgram.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wMProgramWithIdOnly = await prisma.wMProgram.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WMProgramFindManyArgs>(
      args?: SelectSubset<T, WMProgramFindManyArgs>
    ): Prisma.PrismaPromise<Array<WMProgramGetPayload<T>>>

    /**
     * Create a WMProgram.
     * @param {WMProgramCreateArgs} args - Arguments to create a WMProgram.
     * @example
     * // Create one WMProgram
     * const WMProgram = await prisma.wMProgram.create({
     *   data: {
     *     // ... data to create a WMProgram
     *   }
     * })
     * 
    **/
    create<T extends WMProgramCreateArgs>(
      args: SelectSubset<T, WMProgramCreateArgs>
    ): Prisma__WMProgramClient<WMProgramGetPayload<T>>

    /**
     * Create many WMPrograms.
     *     @param {WMProgramCreateManyArgs} args - Arguments to create many WMPrograms.
     *     @example
     *     // Create many WMPrograms
     *     const wMProgram = await prisma.wMProgram.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WMProgramCreateManyArgs>(
      args?: SelectSubset<T, WMProgramCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WMProgram.
     * @param {WMProgramDeleteArgs} args - Arguments to delete one WMProgram.
     * @example
     * // Delete one WMProgram
     * const WMProgram = await prisma.wMProgram.delete({
     *   where: {
     *     // ... filter to delete one WMProgram
     *   }
     * })
     * 
    **/
    delete<T extends WMProgramDeleteArgs>(
      args: SelectSubset<T, WMProgramDeleteArgs>
    ): Prisma__WMProgramClient<WMProgramGetPayload<T>>

    /**
     * Update one WMProgram.
     * @param {WMProgramUpdateArgs} args - Arguments to update one WMProgram.
     * @example
     * // Update one WMProgram
     * const wMProgram = await prisma.wMProgram.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WMProgramUpdateArgs>(
      args: SelectSubset<T, WMProgramUpdateArgs>
    ): Prisma__WMProgramClient<WMProgramGetPayload<T>>

    /**
     * Delete zero or more WMPrograms.
     * @param {WMProgramDeleteManyArgs} args - Arguments to filter WMPrograms to delete.
     * @example
     * // Delete a few WMPrograms
     * const { count } = await prisma.wMProgram.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WMProgramDeleteManyArgs>(
      args?: SelectSubset<T, WMProgramDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WMPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WMProgramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WMPrograms
     * const wMProgram = await prisma.wMProgram.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WMProgramUpdateManyArgs>(
      args: SelectSubset<T, WMProgramUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WMProgram.
     * @param {WMProgramUpsertArgs} args - Arguments to update or create a WMProgram.
     * @example
     * // Update or create a WMProgram
     * const wMProgram = await prisma.wMProgram.upsert({
     *   create: {
     *     // ... data to create a WMProgram
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WMProgram we want to update
     *   }
     * })
    **/
    upsert<T extends WMProgramUpsertArgs>(
      args: SelectSubset<T, WMProgramUpsertArgs>
    ): Prisma__WMProgramClient<WMProgramGetPayload<T>>

    /**
     * Count the number of WMPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WMProgramCountArgs} args - Arguments to filter WMPrograms to count.
     * @example
     * // Count the number of WMPrograms
     * const count = await prisma.wMProgram.count({
     *   where: {
     *     // ... the filter for the WMPrograms we want to count
     *   }
     * })
    **/
    count<T extends WMProgramCountArgs>(
      args?: Subset<T, WMProgramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WMProgramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WMProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WMProgramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WMProgramAggregateArgs>(args: Subset<T, WMProgramAggregateArgs>): Prisma.PrismaPromise<GetWMProgramAggregateType<T>>

    /**
     * Group by WMProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WMProgramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WMProgramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WMProgramGroupByArgs['orderBy'] }
        : { orderBy?: WMProgramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WMProgramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWMProgramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for WMProgram.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WMProgramClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    equippingWMs<T extends WMProgram$equippingWMsArgs= {}>(args?: Subset<T, WMProgram$equippingWMsArgs>): Prisma.PrismaPromise<Array<WashingMachineGetPayload<T>>| Null>;

    usageRecords<T extends WMProgram$usageRecordsArgs= {}>(args?: Subset<T, WMProgram$usageRecordsArgs>): Prisma.PrismaPromise<Array<UsageRecordGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * WMProgram base type for findUnique actions
   */
  export type WMProgramFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the WMProgram
     */
    select?: WMProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WMProgramInclude | null
    /**
     * Filter, which WMProgram to fetch.
     */
    where: WMProgramWhereUniqueInput
  }

  /**
   * WMProgram findUnique
   */
  export interface WMProgramFindUniqueArgs extends WMProgramFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WMProgram findUniqueOrThrow
   */
  export type WMProgramFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the WMProgram
     */
    select?: WMProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WMProgramInclude | null
    /**
     * Filter, which WMProgram to fetch.
     */
    where: WMProgramWhereUniqueInput
  }


  /**
   * WMProgram base type for findFirst actions
   */
  export type WMProgramFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the WMProgram
     */
    select?: WMProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WMProgramInclude | null
    /**
     * Filter, which WMProgram to fetch.
     */
    where?: WMProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WMPrograms to fetch.
     */
    orderBy?: Enumerable<WMProgramOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WMPrograms.
     */
    cursor?: WMProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WMPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WMPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WMPrograms.
     */
    distinct?: Enumerable<WMProgramScalarFieldEnum>
  }

  /**
   * WMProgram findFirst
   */
  export interface WMProgramFindFirstArgs extends WMProgramFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WMProgram findFirstOrThrow
   */
  export type WMProgramFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the WMProgram
     */
    select?: WMProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WMProgramInclude | null
    /**
     * Filter, which WMProgram to fetch.
     */
    where?: WMProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WMPrograms to fetch.
     */
    orderBy?: Enumerable<WMProgramOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WMPrograms.
     */
    cursor?: WMProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WMPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WMPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WMPrograms.
     */
    distinct?: Enumerable<WMProgramScalarFieldEnum>
  }


  /**
   * WMProgram findMany
   */
  export type WMProgramFindManyArgs = {
    /**
     * Select specific fields to fetch from the WMProgram
     */
    select?: WMProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WMProgramInclude | null
    /**
     * Filter, which WMPrograms to fetch.
     */
    where?: WMProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WMPrograms to fetch.
     */
    orderBy?: Enumerable<WMProgramOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WMPrograms.
     */
    cursor?: WMProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WMPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WMPrograms.
     */
    skip?: number
    distinct?: Enumerable<WMProgramScalarFieldEnum>
  }


  /**
   * WMProgram create
   */
  export type WMProgramCreateArgs = {
    /**
     * Select specific fields to fetch from the WMProgram
     */
    select?: WMProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WMProgramInclude | null
    /**
     * The data needed to create a WMProgram.
     */
    data: XOR<WMProgramCreateInput, WMProgramUncheckedCreateInput>
  }


  /**
   * WMProgram createMany
   */
  export type WMProgramCreateManyArgs = {
    /**
     * The data used to create many WMPrograms.
     */
    data: Enumerable<WMProgramCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * WMProgram update
   */
  export type WMProgramUpdateArgs = {
    /**
     * Select specific fields to fetch from the WMProgram
     */
    select?: WMProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WMProgramInclude | null
    /**
     * The data needed to update a WMProgram.
     */
    data: XOR<WMProgramUpdateInput, WMProgramUncheckedUpdateInput>
    /**
     * Choose, which WMProgram to update.
     */
    where: WMProgramWhereUniqueInput
  }


  /**
   * WMProgram updateMany
   */
  export type WMProgramUpdateManyArgs = {
    /**
     * The data used to update WMPrograms.
     */
    data: XOR<WMProgramUpdateManyMutationInput, WMProgramUncheckedUpdateManyInput>
    /**
     * Filter which WMPrograms to update
     */
    where?: WMProgramWhereInput
  }


  /**
   * WMProgram upsert
   */
  export type WMProgramUpsertArgs = {
    /**
     * Select specific fields to fetch from the WMProgram
     */
    select?: WMProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WMProgramInclude | null
    /**
     * The filter to search for the WMProgram to update in case it exists.
     */
    where: WMProgramWhereUniqueInput
    /**
     * In case the WMProgram found by the `where` argument doesn't exist, create a new WMProgram with this data.
     */
    create: XOR<WMProgramCreateInput, WMProgramUncheckedCreateInput>
    /**
     * In case the WMProgram was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WMProgramUpdateInput, WMProgramUncheckedUpdateInput>
  }


  /**
   * WMProgram delete
   */
  export type WMProgramDeleteArgs = {
    /**
     * Select specific fields to fetch from the WMProgram
     */
    select?: WMProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WMProgramInclude | null
    /**
     * Filter which WMProgram to delete.
     */
    where: WMProgramWhereUniqueInput
  }


  /**
   * WMProgram deleteMany
   */
  export type WMProgramDeleteManyArgs = {
    /**
     * Filter which WMPrograms to delete
     */
    where?: WMProgramWhereInput
  }


  /**
   * WMProgram.equippingWMs
   */
  export type WMProgram$equippingWMsArgs = {
    /**
     * Select specific fields to fetch from the WashingMachine
     */
    select?: WashingMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WashingMachineInclude | null
    where?: WashingMachineWhereInput
    orderBy?: Enumerable<WashingMachineOrderByWithRelationInput>
    cursor?: WashingMachineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WashingMachineScalarFieldEnum>
  }


  /**
   * WMProgram.usageRecords
   */
  export type WMProgram$usageRecordsArgs = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsageRecordInclude | null
    where?: UsageRecordWhereInput
    orderBy?: Enumerable<UsageRecordOrderByWithRelationInput>
    cursor?: UsageRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UsageRecordScalarFieldEnum>
  }


  /**
   * WMProgram without action
   */
  export type WMProgramArgs = {
    /**
     * Select specific fields to fetch from the WMProgram
     */
    select?: WMProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WMProgramInclude | null
  }



  /**
   * Model WMMaintenanceRecord
   */


  export type AggregateWMMaintenanceRecord = {
    _count: WMMaintenanceRecordCountAggregateOutputType | null
    _avg: WMMaintenanceRecordAvgAggregateOutputType | null
    _sum: WMMaintenanceRecordSumAggregateOutputType | null
    _min: WMMaintenanceRecordMinAggregateOutputType | null
    _max: WMMaintenanceRecordMaxAggregateOutputType | null
  }

  export type WMMaintenanceRecordAvgAggregateOutputType = {
    id: number | null
    washingMachineId: number | null
    level: number | null
    binWashUserId: number | null
  }

  export type WMMaintenanceRecordSumAggregateOutputType = {
    id: number | null
    washingMachineId: number | null
    level: number | null
    binWashUserId: number | null
  }

  export type WMMaintenanceRecordMinAggregateOutputType = {
    id: number | null
    washingMachineId: number | null
    maintenanceDateTime: Date | null
    level: number | null
    details: string | null
    binWashUserId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WMMaintenanceRecordMaxAggregateOutputType = {
    id: number | null
    washingMachineId: number | null
    maintenanceDateTime: Date | null
    level: number | null
    details: string | null
    binWashUserId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WMMaintenanceRecordCountAggregateOutputType = {
    id: number
    washingMachineId: number
    maintenanceDateTime: number
    level: number
    details: number
    binWashUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WMMaintenanceRecordAvgAggregateInputType = {
    id?: true
    washingMachineId?: true
    level?: true
    binWashUserId?: true
  }

  export type WMMaintenanceRecordSumAggregateInputType = {
    id?: true
    washingMachineId?: true
    level?: true
    binWashUserId?: true
  }

  export type WMMaintenanceRecordMinAggregateInputType = {
    id?: true
    washingMachineId?: true
    maintenanceDateTime?: true
    level?: true
    details?: true
    binWashUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WMMaintenanceRecordMaxAggregateInputType = {
    id?: true
    washingMachineId?: true
    maintenanceDateTime?: true
    level?: true
    details?: true
    binWashUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WMMaintenanceRecordCountAggregateInputType = {
    id?: true
    washingMachineId?: true
    maintenanceDateTime?: true
    level?: true
    details?: true
    binWashUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WMMaintenanceRecordAggregateArgs = {
    /**
     * Filter which WMMaintenanceRecord to aggregate.
     */
    where?: WMMaintenanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WMMaintenanceRecords to fetch.
     */
    orderBy?: Enumerable<WMMaintenanceRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WMMaintenanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WMMaintenanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WMMaintenanceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WMMaintenanceRecords
    **/
    _count?: true | WMMaintenanceRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WMMaintenanceRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WMMaintenanceRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WMMaintenanceRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WMMaintenanceRecordMaxAggregateInputType
  }

  export type GetWMMaintenanceRecordAggregateType<T extends WMMaintenanceRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateWMMaintenanceRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWMMaintenanceRecord[P]>
      : GetScalarType<T[P], AggregateWMMaintenanceRecord[P]>
  }




  export type WMMaintenanceRecordGroupByArgs = {
    where?: WMMaintenanceRecordWhereInput
    orderBy?: Enumerable<WMMaintenanceRecordOrderByWithAggregationInput>
    by: WMMaintenanceRecordScalarFieldEnum[]
    having?: WMMaintenanceRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WMMaintenanceRecordCountAggregateInputType | true
    _avg?: WMMaintenanceRecordAvgAggregateInputType
    _sum?: WMMaintenanceRecordSumAggregateInputType
    _min?: WMMaintenanceRecordMinAggregateInputType
    _max?: WMMaintenanceRecordMaxAggregateInputType
  }


  export type WMMaintenanceRecordGroupByOutputType = {
    id: number
    washingMachineId: number
    maintenanceDateTime: Date
    level: number
    details: string
    binWashUserId: number
    createdAt: Date
    updatedAt: Date
    _count: WMMaintenanceRecordCountAggregateOutputType | null
    _avg: WMMaintenanceRecordAvgAggregateOutputType | null
    _sum: WMMaintenanceRecordSumAggregateOutputType | null
    _min: WMMaintenanceRecordMinAggregateOutputType | null
    _max: WMMaintenanceRecordMaxAggregateOutputType | null
  }

  type GetWMMaintenanceRecordGroupByPayload<T extends WMMaintenanceRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<WMMaintenanceRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WMMaintenanceRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WMMaintenanceRecordGroupByOutputType[P]>
            : GetScalarType<T[P], WMMaintenanceRecordGroupByOutputType[P]>
        }
      >
    >


  export type WMMaintenanceRecordSelect = {
    id?: boolean
    maintainedWM?: boolean | WashingMachineArgs
    washingMachineId?: boolean
    maintenanceDateTime?: boolean
    level?: boolean
    details?: boolean
    maintainer?: boolean | BinWashUserArgs
    binWashUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type WMMaintenanceRecordInclude = {
    maintainedWM?: boolean | WashingMachineArgs
    maintainer?: boolean | BinWashUserArgs
  }

  export type WMMaintenanceRecordGetPayload<S extends boolean | null | undefined | WMMaintenanceRecordArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? WMMaintenanceRecord :
    S extends undefined ? never :
    S extends { include: any } & (WMMaintenanceRecordArgs | WMMaintenanceRecordFindManyArgs)
    ? WMMaintenanceRecord  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'maintainedWM' ? WashingMachineGetPayload<S['include'][P]> :
        P extends 'maintainer' ? BinWashUserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (WMMaintenanceRecordArgs | WMMaintenanceRecordFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'maintainedWM' ? WashingMachineGetPayload<S['select'][P]> :
        P extends 'maintainer' ? BinWashUserGetPayload<S['select'][P]> :  P extends keyof WMMaintenanceRecord ? WMMaintenanceRecord[P] : never
  } 
      : WMMaintenanceRecord


  type WMMaintenanceRecordCountArgs = 
    Omit<WMMaintenanceRecordFindManyArgs, 'select' | 'include'> & {
      select?: WMMaintenanceRecordCountAggregateInputType | true
    }

  export interface WMMaintenanceRecordDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one WMMaintenanceRecord that matches the filter.
     * @param {WMMaintenanceRecordFindUniqueArgs} args - Arguments to find a WMMaintenanceRecord
     * @example
     * // Get one WMMaintenanceRecord
     * const wMMaintenanceRecord = await prisma.wMMaintenanceRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WMMaintenanceRecordFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WMMaintenanceRecordFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'WMMaintenanceRecord'> extends True ? Prisma__WMMaintenanceRecordClient<WMMaintenanceRecordGetPayload<T>> : Prisma__WMMaintenanceRecordClient<WMMaintenanceRecordGetPayload<T> | null, null>

    /**
     * Find one WMMaintenanceRecord that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WMMaintenanceRecordFindUniqueOrThrowArgs} args - Arguments to find a WMMaintenanceRecord
     * @example
     * // Get one WMMaintenanceRecord
     * const wMMaintenanceRecord = await prisma.wMMaintenanceRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WMMaintenanceRecordFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, WMMaintenanceRecordFindUniqueOrThrowArgs>
    ): Prisma__WMMaintenanceRecordClient<WMMaintenanceRecordGetPayload<T>>

    /**
     * Find the first WMMaintenanceRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WMMaintenanceRecordFindFirstArgs} args - Arguments to find a WMMaintenanceRecord
     * @example
     * // Get one WMMaintenanceRecord
     * const wMMaintenanceRecord = await prisma.wMMaintenanceRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WMMaintenanceRecordFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WMMaintenanceRecordFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'WMMaintenanceRecord'> extends True ? Prisma__WMMaintenanceRecordClient<WMMaintenanceRecordGetPayload<T>> : Prisma__WMMaintenanceRecordClient<WMMaintenanceRecordGetPayload<T> | null, null>

    /**
     * Find the first WMMaintenanceRecord that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WMMaintenanceRecordFindFirstOrThrowArgs} args - Arguments to find a WMMaintenanceRecord
     * @example
     * // Get one WMMaintenanceRecord
     * const wMMaintenanceRecord = await prisma.wMMaintenanceRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WMMaintenanceRecordFindFirstOrThrowArgs>(
      args?: SelectSubset<T, WMMaintenanceRecordFindFirstOrThrowArgs>
    ): Prisma__WMMaintenanceRecordClient<WMMaintenanceRecordGetPayload<T>>

    /**
     * Find zero or more WMMaintenanceRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WMMaintenanceRecordFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WMMaintenanceRecords
     * const wMMaintenanceRecords = await prisma.wMMaintenanceRecord.findMany()
     * 
     * // Get first 10 WMMaintenanceRecords
     * const wMMaintenanceRecords = await prisma.wMMaintenanceRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wMMaintenanceRecordWithIdOnly = await prisma.wMMaintenanceRecord.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WMMaintenanceRecordFindManyArgs>(
      args?: SelectSubset<T, WMMaintenanceRecordFindManyArgs>
    ): Prisma.PrismaPromise<Array<WMMaintenanceRecordGetPayload<T>>>

    /**
     * Create a WMMaintenanceRecord.
     * @param {WMMaintenanceRecordCreateArgs} args - Arguments to create a WMMaintenanceRecord.
     * @example
     * // Create one WMMaintenanceRecord
     * const WMMaintenanceRecord = await prisma.wMMaintenanceRecord.create({
     *   data: {
     *     // ... data to create a WMMaintenanceRecord
     *   }
     * })
     * 
    **/
    create<T extends WMMaintenanceRecordCreateArgs>(
      args: SelectSubset<T, WMMaintenanceRecordCreateArgs>
    ): Prisma__WMMaintenanceRecordClient<WMMaintenanceRecordGetPayload<T>>

    /**
     * Create many WMMaintenanceRecords.
     *     @param {WMMaintenanceRecordCreateManyArgs} args - Arguments to create many WMMaintenanceRecords.
     *     @example
     *     // Create many WMMaintenanceRecords
     *     const wMMaintenanceRecord = await prisma.wMMaintenanceRecord.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WMMaintenanceRecordCreateManyArgs>(
      args?: SelectSubset<T, WMMaintenanceRecordCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WMMaintenanceRecord.
     * @param {WMMaintenanceRecordDeleteArgs} args - Arguments to delete one WMMaintenanceRecord.
     * @example
     * // Delete one WMMaintenanceRecord
     * const WMMaintenanceRecord = await prisma.wMMaintenanceRecord.delete({
     *   where: {
     *     // ... filter to delete one WMMaintenanceRecord
     *   }
     * })
     * 
    **/
    delete<T extends WMMaintenanceRecordDeleteArgs>(
      args: SelectSubset<T, WMMaintenanceRecordDeleteArgs>
    ): Prisma__WMMaintenanceRecordClient<WMMaintenanceRecordGetPayload<T>>

    /**
     * Update one WMMaintenanceRecord.
     * @param {WMMaintenanceRecordUpdateArgs} args - Arguments to update one WMMaintenanceRecord.
     * @example
     * // Update one WMMaintenanceRecord
     * const wMMaintenanceRecord = await prisma.wMMaintenanceRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WMMaintenanceRecordUpdateArgs>(
      args: SelectSubset<T, WMMaintenanceRecordUpdateArgs>
    ): Prisma__WMMaintenanceRecordClient<WMMaintenanceRecordGetPayload<T>>

    /**
     * Delete zero or more WMMaintenanceRecords.
     * @param {WMMaintenanceRecordDeleteManyArgs} args - Arguments to filter WMMaintenanceRecords to delete.
     * @example
     * // Delete a few WMMaintenanceRecords
     * const { count } = await prisma.wMMaintenanceRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WMMaintenanceRecordDeleteManyArgs>(
      args?: SelectSubset<T, WMMaintenanceRecordDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WMMaintenanceRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WMMaintenanceRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WMMaintenanceRecords
     * const wMMaintenanceRecord = await prisma.wMMaintenanceRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WMMaintenanceRecordUpdateManyArgs>(
      args: SelectSubset<T, WMMaintenanceRecordUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WMMaintenanceRecord.
     * @param {WMMaintenanceRecordUpsertArgs} args - Arguments to update or create a WMMaintenanceRecord.
     * @example
     * // Update or create a WMMaintenanceRecord
     * const wMMaintenanceRecord = await prisma.wMMaintenanceRecord.upsert({
     *   create: {
     *     // ... data to create a WMMaintenanceRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WMMaintenanceRecord we want to update
     *   }
     * })
    **/
    upsert<T extends WMMaintenanceRecordUpsertArgs>(
      args: SelectSubset<T, WMMaintenanceRecordUpsertArgs>
    ): Prisma__WMMaintenanceRecordClient<WMMaintenanceRecordGetPayload<T>>

    /**
     * Count the number of WMMaintenanceRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WMMaintenanceRecordCountArgs} args - Arguments to filter WMMaintenanceRecords to count.
     * @example
     * // Count the number of WMMaintenanceRecords
     * const count = await prisma.wMMaintenanceRecord.count({
     *   where: {
     *     // ... the filter for the WMMaintenanceRecords we want to count
     *   }
     * })
    **/
    count<T extends WMMaintenanceRecordCountArgs>(
      args?: Subset<T, WMMaintenanceRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WMMaintenanceRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WMMaintenanceRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WMMaintenanceRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WMMaintenanceRecordAggregateArgs>(args: Subset<T, WMMaintenanceRecordAggregateArgs>): Prisma.PrismaPromise<GetWMMaintenanceRecordAggregateType<T>>

    /**
     * Group by WMMaintenanceRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WMMaintenanceRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WMMaintenanceRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WMMaintenanceRecordGroupByArgs['orderBy'] }
        : { orderBy?: WMMaintenanceRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WMMaintenanceRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWMMaintenanceRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for WMMaintenanceRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WMMaintenanceRecordClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    maintainedWM<T extends WashingMachineArgs= {}>(args?: Subset<T, WashingMachineArgs>): Prisma__WashingMachineClient<WashingMachineGetPayload<T> | Null>;

    maintainer<T extends BinWashUserArgs= {}>(args?: Subset<T, BinWashUserArgs>): Prisma__BinWashUserClient<BinWashUserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * WMMaintenanceRecord base type for findUnique actions
   */
  export type WMMaintenanceRecordFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the WMMaintenanceRecord
     */
    select?: WMMaintenanceRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WMMaintenanceRecordInclude | null
    /**
     * Filter, which WMMaintenanceRecord to fetch.
     */
    where: WMMaintenanceRecordWhereUniqueInput
  }

  /**
   * WMMaintenanceRecord findUnique
   */
  export interface WMMaintenanceRecordFindUniqueArgs extends WMMaintenanceRecordFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WMMaintenanceRecord findUniqueOrThrow
   */
  export type WMMaintenanceRecordFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the WMMaintenanceRecord
     */
    select?: WMMaintenanceRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WMMaintenanceRecordInclude | null
    /**
     * Filter, which WMMaintenanceRecord to fetch.
     */
    where: WMMaintenanceRecordWhereUniqueInput
  }


  /**
   * WMMaintenanceRecord base type for findFirst actions
   */
  export type WMMaintenanceRecordFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the WMMaintenanceRecord
     */
    select?: WMMaintenanceRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WMMaintenanceRecordInclude | null
    /**
     * Filter, which WMMaintenanceRecord to fetch.
     */
    where?: WMMaintenanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WMMaintenanceRecords to fetch.
     */
    orderBy?: Enumerable<WMMaintenanceRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WMMaintenanceRecords.
     */
    cursor?: WMMaintenanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WMMaintenanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WMMaintenanceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WMMaintenanceRecords.
     */
    distinct?: Enumerable<WMMaintenanceRecordScalarFieldEnum>
  }

  /**
   * WMMaintenanceRecord findFirst
   */
  export interface WMMaintenanceRecordFindFirstArgs extends WMMaintenanceRecordFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WMMaintenanceRecord findFirstOrThrow
   */
  export type WMMaintenanceRecordFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the WMMaintenanceRecord
     */
    select?: WMMaintenanceRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WMMaintenanceRecordInclude | null
    /**
     * Filter, which WMMaintenanceRecord to fetch.
     */
    where?: WMMaintenanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WMMaintenanceRecords to fetch.
     */
    orderBy?: Enumerable<WMMaintenanceRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WMMaintenanceRecords.
     */
    cursor?: WMMaintenanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WMMaintenanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WMMaintenanceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WMMaintenanceRecords.
     */
    distinct?: Enumerable<WMMaintenanceRecordScalarFieldEnum>
  }


  /**
   * WMMaintenanceRecord findMany
   */
  export type WMMaintenanceRecordFindManyArgs = {
    /**
     * Select specific fields to fetch from the WMMaintenanceRecord
     */
    select?: WMMaintenanceRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WMMaintenanceRecordInclude | null
    /**
     * Filter, which WMMaintenanceRecords to fetch.
     */
    where?: WMMaintenanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WMMaintenanceRecords to fetch.
     */
    orderBy?: Enumerable<WMMaintenanceRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WMMaintenanceRecords.
     */
    cursor?: WMMaintenanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WMMaintenanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WMMaintenanceRecords.
     */
    skip?: number
    distinct?: Enumerable<WMMaintenanceRecordScalarFieldEnum>
  }


  /**
   * WMMaintenanceRecord create
   */
  export type WMMaintenanceRecordCreateArgs = {
    /**
     * Select specific fields to fetch from the WMMaintenanceRecord
     */
    select?: WMMaintenanceRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WMMaintenanceRecordInclude | null
    /**
     * The data needed to create a WMMaintenanceRecord.
     */
    data: XOR<WMMaintenanceRecordCreateInput, WMMaintenanceRecordUncheckedCreateInput>
  }


  /**
   * WMMaintenanceRecord createMany
   */
  export type WMMaintenanceRecordCreateManyArgs = {
    /**
     * The data used to create many WMMaintenanceRecords.
     */
    data: Enumerable<WMMaintenanceRecordCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * WMMaintenanceRecord update
   */
  export type WMMaintenanceRecordUpdateArgs = {
    /**
     * Select specific fields to fetch from the WMMaintenanceRecord
     */
    select?: WMMaintenanceRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WMMaintenanceRecordInclude | null
    /**
     * The data needed to update a WMMaintenanceRecord.
     */
    data: XOR<WMMaintenanceRecordUpdateInput, WMMaintenanceRecordUncheckedUpdateInput>
    /**
     * Choose, which WMMaintenanceRecord to update.
     */
    where: WMMaintenanceRecordWhereUniqueInput
  }


  /**
   * WMMaintenanceRecord updateMany
   */
  export type WMMaintenanceRecordUpdateManyArgs = {
    /**
     * The data used to update WMMaintenanceRecords.
     */
    data: XOR<WMMaintenanceRecordUpdateManyMutationInput, WMMaintenanceRecordUncheckedUpdateManyInput>
    /**
     * Filter which WMMaintenanceRecords to update
     */
    where?: WMMaintenanceRecordWhereInput
  }


  /**
   * WMMaintenanceRecord upsert
   */
  export type WMMaintenanceRecordUpsertArgs = {
    /**
     * Select specific fields to fetch from the WMMaintenanceRecord
     */
    select?: WMMaintenanceRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WMMaintenanceRecordInclude | null
    /**
     * The filter to search for the WMMaintenanceRecord to update in case it exists.
     */
    where: WMMaintenanceRecordWhereUniqueInput
    /**
     * In case the WMMaintenanceRecord found by the `where` argument doesn't exist, create a new WMMaintenanceRecord with this data.
     */
    create: XOR<WMMaintenanceRecordCreateInput, WMMaintenanceRecordUncheckedCreateInput>
    /**
     * In case the WMMaintenanceRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WMMaintenanceRecordUpdateInput, WMMaintenanceRecordUncheckedUpdateInput>
  }


  /**
   * WMMaintenanceRecord delete
   */
  export type WMMaintenanceRecordDeleteArgs = {
    /**
     * Select specific fields to fetch from the WMMaintenanceRecord
     */
    select?: WMMaintenanceRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WMMaintenanceRecordInclude | null
    /**
     * Filter which WMMaintenanceRecord to delete.
     */
    where: WMMaintenanceRecordWhereUniqueInput
  }


  /**
   * WMMaintenanceRecord deleteMany
   */
  export type WMMaintenanceRecordDeleteManyArgs = {
    /**
     * Filter which WMMaintenanceRecords to delete
     */
    where?: WMMaintenanceRecordWhereInput
  }


  /**
   * WMMaintenanceRecord without action
   */
  export type WMMaintenanceRecordArgs = {
    /**
     * Select specific fields to fetch from the WMMaintenanceRecord
     */
    select?: WMMaintenanceRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WMMaintenanceRecordInclude | null
  }



  /**
   * Model UsageRecord
   */


  export type AggregateUsageRecord = {
    _count: UsageRecordCountAggregateOutputType | null
    _avg: UsageRecordAvgAggregateOutputType | null
    _sum: UsageRecordSumAggregateOutputType | null
    _min: UsageRecordMinAggregateOutputType | null
    _max: UsageRecordMaxAggregateOutputType | null
  }

  export type UsageRecordAvgAggregateOutputType = {
    id: number | null
    binWashUserId: number | null
    washingMachineId: number | null
    wMProgramId: number | null
    price: number | null
  }

  export type UsageRecordSumAggregateOutputType = {
    id: number | null
    binWashUserId: number | null
    washingMachineId: number | null
    wMProgramId: number | null
    price: number | null
  }

  export type UsageRecordMinAggregateOutputType = {
    id: number | null
    dateTime: Date | null
    binWashUserId: number | null
    washingMachineId: number | null
    wMProgramId: number | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsageRecordMaxAggregateOutputType = {
    id: number | null
    dateTime: Date | null
    binWashUserId: number | null
    washingMachineId: number | null
    wMProgramId: number | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsageRecordCountAggregateOutputType = {
    id: number
    dateTime: number
    binWashUserId: number
    washingMachineId: number
    wMProgramId: number
    price: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UsageRecordAvgAggregateInputType = {
    id?: true
    binWashUserId?: true
    washingMachineId?: true
    wMProgramId?: true
    price?: true
  }

  export type UsageRecordSumAggregateInputType = {
    id?: true
    binWashUserId?: true
    washingMachineId?: true
    wMProgramId?: true
    price?: true
  }

  export type UsageRecordMinAggregateInputType = {
    id?: true
    dateTime?: true
    binWashUserId?: true
    washingMachineId?: true
    wMProgramId?: true
    price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsageRecordMaxAggregateInputType = {
    id?: true
    dateTime?: true
    binWashUserId?: true
    washingMachineId?: true
    wMProgramId?: true
    price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsageRecordCountAggregateInputType = {
    id?: true
    dateTime?: true
    binWashUserId?: true
    washingMachineId?: true
    wMProgramId?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UsageRecordAggregateArgs = {
    /**
     * Filter which UsageRecord to aggregate.
     */
    where?: UsageRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageRecords to fetch.
     */
    orderBy?: Enumerable<UsageRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsageRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsageRecords
    **/
    _count?: true | UsageRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsageRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsageRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsageRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsageRecordMaxAggregateInputType
  }

  export type GetUsageRecordAggregateType<T extends UsageRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateUsageRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsageRecord[P]>
      : GetScalarType<T[P], AggregateUsageRecord[P]>
  }




  export type UsageRecordGroupByArgs = {
    where?: UsageRecordWhereInput
    orderBy?: Enumerable<UsageRecordOrderByWithAggregationInput>
    by: UsageRecordScalarFieldEnum[]
    having?: UsageRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsageRecordCountAggregateInputType | true
    _avg?: UsageRecordAvgAggregateInputType
    _sum?: UsageRecordSumAggregateInputType
    _min?: UsageRecordMinAggregateInputType
    _max?: UsageRecordMaxAggregateInputType
  }


  export type UsageRecordGroupByOutputType = {
    id: number
    dateTime: Date
    binWashUserId: number
    washingMachineId: number
    wMProgramId: number
    price: number
    createdAt: Date
    updatedAt: Date
    _count: UsageRecordCountAggregateOutputType | null
    _avg: UsageRecordAvgAggregateOutputType | null
    _sum: UsageRecordSumAggregateOutputType | null
    _min: UsageRecordMinAggregateOutputType | null
    _max: UsageRecordMaxAggregateOutputType | null
  }

  type GetUsageRecordGroupByPayload<T extends UsageRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UsageRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsageRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsageRecordGroupByOutputType[P]>
            : GetScalarType<T[P], UsageRecordGroupByOutputType[P]>
        }
      >
    >


  export type UsageRecordSelect = {
    id?: boolean
    dateTime?: boolean
    user?: boolean | BinWashUserArgs
    binWashUserId?: boolean
    washingMachine?: boolean | WashingMachineArgs
    washingMachineId?: boolean
    program?: boolean | WMProgramArgs
    wMProgramId?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type UsageRecordInclude = {
    user?: boolean | BinWashUserArgs
    washingMachine?: boolean | WashingMachineArgs
    program?: boolean | WMProgramArgs
  }

  export type UsageRecordGetPayload<S extends boolean | null | undefined | UsageRecordArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UsageRecord :
    S extends undefined ? never :
    S extends { include: any } & (UsageRecordArgs | UsageRecordFindManyArgs)
    ? UsageRecord  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? BinWashUserGetPayload<S['include'][P]> :
        P extends 'washingMachine' ? WashingMachineGetPayload<S['include'][P]> :
        P extends 'program' ? WMProgramGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UsageRecordArgs | UsageRecordFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? BinWashUserGetPayload<S['select'][P]> :
        P extends 'washingMachine' ? WashingMachineGetPayload<S['select'][P]> :
        P extends 'program' ? WMProgramGetPayload<S['select'][P]> :  P extends keyof UsageRecord ? UsageRecord[P] : never
  } 
      : UsageRecord


  type UsageRecordCountArgs = 
    Omit<UsageRecordFindManyArgs, 'select' | 'include'> & {
      select?: UsageRecordCountAggregateInputType | true
    }

  export interface UsageRecordDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one UsageRecord that matches the filter.
     * @param {UsageRecordFindUniqueArgs} args - Arguments to find a UsageRecord
     * @example
     * // Get one UsageRecord
     * const usageRecord = await prisma.usageRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UsageRecordFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UsageRecordFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UsageRecord'> extends True ? Prisma__UsageRecordClient<UsageRecordGetPayload<T>> : Prisma__UsageRecordClient<UsageRecordGetPayload<T> | null, null>

    /**
     * Find one UsageRecord that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UsageRecordFindUniqueOrThrowArgs} args - Arguments to find a UsageRecord
     * @example
     * // Get one UsageRecord
     * const usageRecord = await prisma.usageRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UsageRecordFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UsageRecordFindUniqueOrThrowArgs>
    ): Prisma__UsageRecordClient<UsageRecordGetPayload<T>>

    /**
     * Find the first UsageRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageRecordFindFirstArgs} args - Arguments to find a UsageRecord
     * @example
     * // Get one UsageRecord
     * const usageRecord = await prisma.usageRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UsageRecordFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UsageRecordFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UsageRecord'> extends True ? Prisma__UsageRecordClient<UsageRecordGetPayload<T>> : Prisma__UsageRecordClient<UsageRecordGetPayload<T> | null, null>

    /**
     * Find the first UsageRecord that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageRecordFindFirstOrThrowArgs} args - Arguments to find a UsageRecord
     * @example
     * // Get one UsageRecord
     * const usageRecord = await prisma.usageRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UsageRecordFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UsageRecordFindFirstOrThrowArgs>
    ): Prisma__UsageRecordClient<UsageRecordGetPayload<T>>

    /**
     * Find zero or more UsageRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageRecordFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsageRecords
     * const usageRecords = await prisma.usageRecord.findMany()
     * 
     * // Get first 10 UsageRecords
     * const usageRecords = await prisma.usageRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usageRecordWithIdOnly = await prisma.usageRecord.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UsageRecordFindManyArgs>(
      args?: SelectSubset<T, UsageRecordFindManyArgs>
    ): Prisma.PrismaPromise<Array<UsageRecordGetPayload<T>>>

    /**
     * Create a UsageRecord.
     * @param {UsageRecordCreateArgs} args - Arguments to create a UsageRecord.
     * @example
     * // Create one UsageRecord
     * const UsageRecord = await prisma.usageRecord.create({
     *   data: {
     *     // ... data to create a UsageRecord
     *   }
     * })
     * 
    **/
    create<T extends UsageRecordCreateArgs>(
      args: SelectSubset<T, UsageRecordCreateArgs>
    ): Prisma__UsageRecordClient<UsageRecordGetPayload<T>>

    /**
     * Create many UsageRecords.
     *     @param {UsageRecordCreateManyArgs} args - Arguments to create many UsageRecords.
     *     @example
     *     // Create many UsageRecords
     *     const usageRecord = await prisma.usageRecord.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UsageRecordCreateManyArgs>(
      args?: SelectSubset<T, UsageRecordCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UsageRecord.
     * @param {UsageRecordDeleteArgs} args - Arguments to delete one UsageRecord.
     * @example
     * // Delete one UsageRecord
     * const UsageRecord = await prisma.usageRecord.delete({
     *   where: {
     *     // ... filter to delete one UsageRecord
     *   }
     * })
     * 
    **/
    delete<T extends UsageRecordDeleteArgs>(
      args: SelectSubset<T, UsageRecordDeleteArgs>
    ): Prisma__UsageRecordClient<UsageRecordGetPayload<T>>

    /**
     * Update one UsageRecord.
     * @param {UsageRecordUpdateArgs} args - Arguments to update one UsageRecord.
     * @example
     * // Update one UsageRecord
     * const usageRecord = await prisma.usageRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UsageRecordUpdateArgs>(
      args: SelectSubset<T, UsageRecordUpdateArgs>
    ): Prisma__UsageRecordClient<UsageRecordGetPayload<T>>

    /**
     * Delete zero or more UsageRecords.
     * @param {UsageRecordDeleteManyArgs} args - Arguments to filter UsageRecords to delete.
     * @example
     * // Delete a few UsageRecords
     * const { count } = await prisma.usageRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UsageRecordDeleteManyArgs>(
      args?: SelectSubset<T, UsageRecordDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsageRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsageRecords
     * const usageRecord = await prisma.usageRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UsageRecordUpdateManyArgs>(
      args: SelectSubset<T, UsageRecordUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UsageRecord.
     * @param {UsageRecordUpsertArgs} args - Arguments to update or create a UsageRecord.
     * @example
     * // Update or create a UsageRecord
     * const usageRecord = await prisma.usageRecord.upsert({
     *   create: {
     *     // ... data to create a UsageRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsageRecord we want to update
     *   }
     * })
    **/
    upsert<T extends UsageRecordUpsertArgs>(
      args: SelectSubset<T, UsageRecordUpsertArgs>
    ): Prisma__UsageRecordClient<UsageRecordGetPayload<T>>

    /**
     * Count the number of UsageRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageRecordCountArgs} args - Arguments to filter UsageRecords to count.
     * @example
     * // Count the number of UsageRecords
     * const count = await prisma.usageRecord.count({
     *   where: {
     *     // ... the filter for the UsageRecords we want to count
     *   }
     * })
    **/
    count<T extends UsageRecordCountArgs>(
      args?: Subset<T, UsageRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsageRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsageRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsageRecordAggregateArgs>(args: Subset<T, UsageRecordAggregateArgs>): Prisma.PrismaPromise<GetUsageRecordAggregateType<T>>

    /**
     * Group by UsageRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsageRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsageRecordGroupByArgs['orderBy'] }
        : { orderBy?: UsageRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsageRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsageRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UsageRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UsageRecordClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends BinWashUserArgs= {}>(args?: Subset<T, BinWashUserArgs>): Prisma__BinWashUserClient<BinWashUserGetPayload<T> | Null>;

    washingMachine<T extends WashingMachineArgs= {}>(args?: Subset<T, WashingMachineArgs>): Prisma__WashingMachineClient<WashingMachineGetPayload<T> | Null>;

    program<T extends WMProgramArgs= {}>(args?: Subset<T, WMProgramArgs>): Prisma__WMProgramClient<WMProgramGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UsageRecord base type for findUnique actions
   */
  export type UsageRecordFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsageRecordInclude | null
    /**
     * Filter, which UsageRecord to fetch.
     */
    where: UsageRecordWhereUniqueInput
  }

  /**
   * UsageRecord findUnique
   */
  export interface UsageRecordFindUniqueArgs extends UsageRecordFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UsageRecord findUniqueOrThrow
   */
  export type UsageRecordFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsageRecordInclude | null
    /**
     * Filter, which UsageRecord to fetch.
     */
    where: UsageRecordWhereUniqueInput
  }


  /**
   * UsageRecord base type for findFirst actions
   */
  export type UsageRecordFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsageRecordInclude | null
    /**
     * Filter, which UsageRecord to fetch.
     */
    where?: UsageRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageRecords to fetch.
     */
    orderBy?: Enumerable<UsageRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageRecords.
     */
    cursor?: UsageRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageRecords.
     */
    distinct?: Enumerable<UsageRecordScalarFieldEnum>
  }

  /**
   * UsageRecord findFirst
   */
  export interface UsageRecordFindFirstArgs extends UsageRecordFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UsageRecord findFirstOrThrow
   */
  export type UsageRecordFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsageRecordInclude | null
    /**
     * Filter, which UsageRecord to fetch.
     */
    where?: UsageRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageRecords to fetch.
     */
    orderBy?: Enumerable<UsageRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageRecords.
     */
    cursor?: UsageRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageRecords.
     */
    distinct?: Enumerable<UsageRecordScalarFieldEnum>
  }


  /**
   * UsageRecord findMany
   */
  export type UsageRecordFindManyArgs = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsageRecordInclude | null
    /**
     * Filter, which UsageRecords to fetch.
     */
    where?: UsageRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageRecords to fetch.
     */
    orderBy?: Enumerable<UsageRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsageRecords.
     */
    cursor?: UsageRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageRecords.
     */
    skip?: number
    distinct?: Enumerable<UsageRecordScalarFieldEnum>
  }


  /**
   * UsageRecord create
   */
  export type UsageRecordCreateArgs = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsageRecordInclude | null
    /**
     * The data needed to create a UsageRecord.
     */
    data: XOR<UsageRecordCreateInput, UsageRecordUncheckedCreateInput>
  }


  /**
   * UsageRecord createMany
   */
  export type UsageRecordCreateManyArgs = {
    /**
     * The data used to create many UsageRecords.
     */
    data: Enumerable<UsageRecordCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UsageRecord update
   */
  export type UsageRecordUpdateArgs = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsageRecordInclude | null
    /**
     * The data needed to update a UsageRecord.
     */
    data: XOR<UsageRecordUpdateInput, UsageRecordUncheckedUpdateInput>
    /**
     * Choose, which UsageRecord to update.
     */
    where: UsageRecordWhereUniqueInput
  }


  /**
   * UsageRecord updateMany
   */
  export type UsageRecordUpdateManyArgs = {
    /**
     * The data used to update UsageRecords.
     */
    data: XOR<UsageRecordUpdateManyMutationInput, UsageRecordUncheckedUpdateManyInput>
    /**
     * Filter which UsageRecords to update
     */
    where?: UsageRecordWhereInput
  }


  /**
   * UsageRecord upsert
   */
  export type UsageRecordUpsertArgs = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsageRecordInclude | null
    /**
     * The filter to search for the UsageRecord to update in case it exists.
     */
    where: UsageRecordWhereUniqueInput
    /**
     * In case the UsageRecord found by the `where` argument doesn't exist, create a new UsageRecord with this data.
     */
    create: XOR<UsageRecordCreateInput, UsageRecordUncheckedCreateInput>
    /**
     * In case the UsageRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsageRecordUpdateInput, UsageRecordUncheckedUpdateInput>
  }


  /**
   * UsageRecord delete
   */
  export type UsageRecordDeleteArgs = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsageRecordInclude | null
    /**
     * Filter which UsageRecord to delete.
     */
    where: UsageRecordWhereUniqueInput
  }


  /**
   * UsageRecord deleteMany
   */
  export type UsageRecordDeleteManyArgs = {
    /**
     * Filter which UsageRecords to delete
     */
    where?: UsageRecordWhereInput
  }


  /**
   * UsageRecord without action
   */
  export type UsageRecordArgs = {
    /**
     * Select specific fields to fetch from the UsageRecord
     */
    select?: UsageRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsageRecordInclude | null
  }



  /**
   * Model TopUpRecord
   */


  export type AggregateTopUpRecord = {
    _count: TopUpRecordCountAggregateOutputType | null
    _avg: TopUpRecordAvgAggregateOutputType | null
    _sum: TopUpRecordSumAggregateOutputType | null
    _min: TopUpRecordMinAggregateOutputType | null
    _max: TopUpRecordMaxAggregateOutputType | null
  }

  export type TopUpRecordAvgAggregateOutputType = {
    id: number | null
    binWashUserId: number | null
    price: number | null
  }

  export type TopUpRecordSumAggregateOutputType = {
    id: number | null
    binWashUserId: number | null
    price: number | null
  }

  export type TopUpRecordMinAggregateOutputType = {
    id: number | null
    dateTime: Date | null
    binWashUserId: number | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TopUpRecordMaxAggregateOutputType = {
    id: number | null
    dateTime: Date | null
    binWashUserId: number | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TopUpRecordCountAggregateOutputType = {
    id: number
    dateTime: number
    binWashUserId: number
    price: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TopUpRecordAvgAggregateInputType = {
    id?: true
    binWashUserId?: true
    price?: true
  }

  export type TopUpRecordSumAggregateInputType = {
    id?: true
    binWashUserId?: true
    price?: true
  }

  export type TopUpRecordMinAggregateInputType = {
    id?: true
    dateTime?: true
    binWashUserId?: true
    price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TopUpRecordMaxAggregateInputType = {
    id?: true
    dateTime?: true
    binWashUserId?: true
    price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TopUpRecordCountAggregateInputType = {
    id?: true
    dateTime?: true
    binWashUserId?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TopUpRecordAggregateArgs = {
    /**
     * Filter which TopUpRecord to aggregate.
     */
    where?: TopUpRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TopUpRecords to fetch.
     */
    orderBy?: Enumerable<TopUpRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TopUpRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TopUpRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TopUpRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TopUpRecords
    **/
    _count?: true | TopUpRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TopUpRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TopUpRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TopUpRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TopUpRecordMaxAggregateInputType
  }

  export type GetTopUpRecordAggregateType<T extends TopUpRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateTopUpRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTopUpRecord[P]>
      : GetScalarType<T[P], AggregateTopUpRecord[P]>
  }




  export type TopUpRecordGroupByArgs = {
    where?: TopUpRecordWhereInput
    orderBy?: Enumerable<TopUpRecordOrderByWithAggregationInput>
    by: TopUpRecordScalarFieldEnum[]
    having?: TopUpRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TopUpRecordCountAggregateInputType | true
    _avg?: TopUpRecordAvgAggregateInputType
    _sum?: TopUpRecordSumAggregateInputType
    _min?: TopUpRecordMinAggregateInputType
    _max?: TopUpRecordMaxAggregateInputType
  }


  export type TopUpRecordGroupByOutputType = {
    id: number
    dateTime: Date
    binWashUserId: number
    price: number
    createdAt: Date
    updatedAt: Date
    _count: TopUpRecordCountAggregateOutputType | null
    _avg: TopUpRecordAvgAggregateOutputType | null
    _sum: TopUpRecordSumAggregateOutputType | null
    _min: TopUpRecordMinAggregateOutputType | null
    _max: TopUpRecordMaxAggregateOutputType | null
  }

  type GetTopUpRecordGroupByPayload<T extends TopUpRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TopUpRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TopUpRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TopUpRecordGroupByOutputType[P]>
            : GetScalarType<T[P], TopUpRecordGroupByOutputType[P]>
        }
      >
    >


  export type TopUpRecordSelect = {
    id?: boolean
    dateTime?: boolean
    user?: boolean | BinWashUserArgs
    binWashUserId?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type TopUpRecordInclude = {
    user?: boolean | BinWashUserArgs
  }

  export type TopUpRecordGetPayload<S extends boolean | null | undefined | TopUpRecordArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TopUpRecord :
    S extends undefined ? never :
    S extends { include: any } & (TopUpRecordArgs | TopUpRecordFindManyArgs)
    ? TopUpRecord  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? BinWashUserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TopUpRecordArgs | TopUpRecordFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? BinWashUserGetPayload<S['select'][P]> :  P extends keyof TopUpRecord ? TopUpRecord[P] : never
  } 
      : TopUpRecord


  type TopUpRecordCountArgs = 
    Omit<TopUpRecordFindManyArgs, 'select' | 'include'> & {
      select?: TopUpRecordCountAggregateInputType | true
    }

  export interface TopUpRecordDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TopUpRecord that matches the filter.
     * @param {TopUpRecordFindUniqueArgs} args - Arguments to find a TopUpRecord
     * @example
     * // Get one TopUpRecord
     * const topUpRecord = await prisma.topUpRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TopUpRecordFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TopUpRecordFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TopUpRecord'> extends True ? Prisma__TopUpRecordClient<TopUpRecordGetPayload<T>> : Prisma__TopUpRecordClient<TopUpRecordGetPayload<T> | null, null>

    /**
     * Find one TopUpRecord that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TopUpRecordFindUniqueOrThrowArgs} args - Arguments to find a TopUpRecord
     * @example
     * // Get one TopUpRecord
     * const topUpRecord = await prisma.topUpRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TopUpRecordFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TopUpRecordFindUniqueOrThrowArgs>
    ): Prisma__TopUpRecordClient<TopUpRecordGetPayload<T>>

    /**
     * Find the first TopUpRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopUpRecordFindFirstArgs} args - Arguments to find a TopUpRecord
     * @example
     * // Get one TopUpRecord
     * const topUpRecord = await prisma.topUpRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TopUpRecordFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TopUpRecordFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TopUpRecord'> extends True ? Prisma__TopUpRecordClient<TopUpRecordGetPayload<T>> : Prisma__TopUpRecordClient<TopUpRecordGetPayload<T> | null, null>

    /**
     * Find the first TopUpRecord that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopUpRecordFindFirstOrThrowArgs} args - Arguments to find a TopUpRecord
     * @example
     * // Get one TopUpRecord
     * const topUpRecord = await prisma.topUpRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TopUpRecordFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TopUpRecordFindFirstOrThrowArgs>
    ): Prisma__TopUpRecordClient<TopUpRecordGetPayload<T>>

    /**
     * Find zero or more TopUpRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopUpRecordFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TopUpRecords
     * const topUpRecords = await prisma.topUpRecord.findMany()
     * 
     * // Get first 10 TopUpRecords
     * const topUpRecords = await prisma.topUpRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const topUpRecordWithIdOnly = await prisma.topUpRecord.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TopUpRecordFindManyArgs>(
      args?: SelectSubset<T, TopUpRecordFindManyArgs>
    ): Prisma.PrismaPromise<Array<TopUpRecordGetPayload<T>>>

    /**
     * Create a TopUpRecord.
     * @param {TopUpRecordCreateArgs} args - Arguments to create a TopUpRecord.
     * @example
     * // Create one TopUpRecord
     * const TopUpRecord = await prisma.topUpRecord.create({
     *   data: {
     *     // ... data to create a TopUpRecord
     *   }
     * })
     * 
    **/
    create<T extends TopUpRecordCreateArgs>(
      args: SelectSubset<T, TopUpRecordCreateArgs>
    ): Prisma__TopUpRecordClient<TopUpRecordGetPayload<T>>

    /**
     * Create many TopUpRecords.
     *     @param {TopUpRecordCreateManyArgs} args - Arguments to create many TopUpRecords.
     *     @example
     *     // Create many TopUpRecords
     *     const topUpRecord = await prisma.topUpRecord.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TopUpRecordCreateManyArgs>(
      args?: SelectSubset<T, TopUpRecordCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TopUpRecord.
     * @param {TopUpRecordDeleteArgs} args - Arguments to delete one TopUpRecord.
     * @example
     * // Delete one TopUpRecord
     * const TopUpRecord = await prisma.topUpRecord.delete({
     *   where: {
     *     // ... filter to delete one TopUpRecord
     *   }
     * })
     * 
    **/
    delete<T extends TopUpRecordDeleteArgs>(
      args: SelectSubset<T, TopUpRecordDeleteArgs>
    ): Prisma__TopUpRecordClient<TopUpRecordGetPayload<T>>

    /**
     * Update one TopUpRecord.
     * @param {TopUpRecordUpdateArgs} args - Arguments to update one TopUpRecord.
     * @example
     * // Update one TopUpRecord
     * const topUpRecord = await prisma.topUpRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TopUpRecordUpdateArgs>(
      args: SelectSubset<T, TopUpRecordUpdateArgs>
    ): Prisma__TopUpRecordClient<TopUpRecordGetPayload<T>>

    /**
     * Delete zero or more TopUpRecords.
     * @param {TopUpRecordDeleteManyArgs} args - Arguments to filter TopUpRecords to delete.
     * @example
     * // Delete a few TopUpRecords
     * const { count } = await prisma.topUpRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TopUpRecordDeleteManyArgs>(
      args?: SelectSubset<T, TopUpRecordDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TopUpRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopUpRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TopUpRecords
     * const topUpRecord = await prisma.topUpRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TopUpRecordUpdateManyArgs>(
      args: SelectSubset<T, TopUpRecordUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TopUpRecord.
     * @param {TopUpRecordUpsertArgs} args - Arguments to update or create a TopUpRecord.
     * @example
     * // Update or create a TopUpRecord
     * const topUpRecord = await prisma.topUpRecord.upsert({
     *   create: {
     *     // ... data to create a TopUpRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TopUpRecord we want to update
     *   }
     * })
    **/
    upsert<T extends TopUpRecordUpsertArgs>(
      args: SelectSubset<T, TopUpRecordUpsertArgs>
    ): Prisma__TopUpRecordClient<TopUpRecordGetPayload<T>>

    /**
     * Count the number of TopUpRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopUpRecordCountArgs} args - Arguments to filter TopUpRecords to count.
     * @example
     * // Count the number of TopUpRecords
     * const count = await prisma.topUpRecord.count({
     *   where: {
     *     // ... the filter for the TopUpRecords we want to count
     *   }
     * })
    **/
    count<T extends TopUpRecordCountArgs>(
      args?: Subset<T, TopUpRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TopUpRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TopUpRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopUpRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TopUpRecordAggregateArgs>(args: Subset<T, TopUpRecordAggregateArgs>): Prisma.PrismaPromise<GetTopUpRecordAggregateType<T>>

    /**
     * Group by TopUpRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopUpRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TopUpRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TopUpRecordGroupByArgs['orderBy'] }
        : { orderBy?: TopUpRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TopUpRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTopUpRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TopUpRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TopUpRecordClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends BinWashUserArgs= {}>(args?: Subset<T, BinWashUserArgs>): Prisma__BinWashUserClient<BinWashUserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TopUpRecord base type for findUnique actions
   */
  export type TopUpRecordFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TopUpRecord
     */
    select?: TopUpRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TopUpRecordInclude | null
    /**
     * Filter, which TopUpRecord to fetch.
     */
    where: TopUpRecordWhereUniqueInput
  }

  /**
   * TopUpRecord findUnique
   */
  export interface TopUpRecordFindUniqueArgs extends TopUpRecordFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TopUpRecord findUniqueOrThrow
   */
  export type TopUpRecordFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TopUpRecord
     */
    select?: TopUpRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TopUpRecordInclude | null
    /**
     * Filter, which TopUpRecord to fetch.
     */
    where: TopUpRecordWhereUniqueInput
  }


  /**
   * TopUpRecord base type for findFirst actions
   */
  export type TopUpRecordFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TopUpRecord
     */
    select?: TopUpRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TopUpRecordInclude | null
    /**
     * Filter, which TopUpRecord to fetch.
     */
    where?: TopUpRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TopUpRecords to fetch.
     */
    orderBy?: Enumerable<TopUpRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TopUpRecords.
     */
    cursor?: TopUpRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TopUpRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TopUpRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TopUpRecords.
     */
    distinct?: Enumerable<TopUpRecordScalarFieldEnum>
  }

  /**
   * TopUpRecord findFirst
   */
  export interface TopUpRecordFindFirstArgs extends TopUpRecordFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TopUpRecord findFirstOrThrow
   */
  export type TopUpRecordFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TopUpRecord
     */
    select?: TopUpRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TopUpRecordInclude | null
    /**
     * Filter, which TopUpRecord to fetch.
     */
    where?: TopUpRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TopUpRecords to fetch.
     */
    orderBy?: Enumerable<TopUpRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TopUpRecords.
     */
    cursor?: TopUpRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TopUpRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TopUpRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TopUpRecords.
     */
    distinct?: Enumerable<TopUpRecordScalarFieldEnum>
  }


  /**
   * TopUpRecord findMany
   */
  export type TopUpRecordFindManyArgs = {
    /**
     * Select specific fields to fetch from the TopUpRecord
     */
    select?: TopUpRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TopUpRecordInclude | null
    /**
     * Filter, which TopUpRecords to fetch.
     */
    where?: TopUpRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TopUpRecords to fetch.
     */
    orderBy?: Enumerable<TopUpRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TopUpRecords.
     */
    cursor?: TopUpRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TopUpRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TopUpRecords.
     */
    skip?: number
    distinct?: Enumerable<TopUpRecordScalarFieldEnum>
  }


  /**
   * TopUpRecord create
   */
  export type TopUpRecordCreateArgs = {
    /**
     * Select specific fields to fetch from the TopUpRecord
     */
    select?: TopUpRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TopUpRecordInclude | null
    /**
     * The data needed to create a TopUpRecord.
     */
    data: XOR<TopUpRecordCreateInput, TopUpRecordUncheckedCreateInput>
  }


  /**
   * TopUpRecord createMany
   */
  export type TopUpRecordCreateManyArgs = {
    /**
     * The data used to create many TopUpRecords.
     */
    data: Enumerable<TopUpRecordCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TopUpRecord update
   */
  export type TopUpRecordUpdateArgs = {
    /**
     * Select specific fields to fetch from the TopUpRecord
     */
    select?: TopUpRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TopUpRecordInclude | null
    /**
     * The data needed to update a TopUpRecord.
     */
    data: XOR<TopUpRecordUpdateInput, TopUpRecordUncheckedUpdateInput>
    /**
     * Choose, which TopUpRecord to update.
     */
    where: TopUpRecordWhereUniqueInput
  }


  /**
   * TopUpRecord updateMany
   */
  export type TopUpRecordUpdateManyArgs = {
    /**
     * The data used to update TopUpRecords.
     */
    data: XOR<TopUpRecordUpdateManyMutationInput, TopUpRecordUncheckedUpdateManyInput>
    /**
     * Filter which TopUpRecords to update
     */
    where?: TopUpRecordWhereInput
  }


  /**
   * TopUpRecord upsert
   */
  export type TopUpRecordUpsertArgs = {
    /**
     * Select specific fields to fetch from the TopUpRecord
     */
    select?: TopUpRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TopUpRecordInclude | null
    /**
     * The filter to search for the TopUpRecord to update in case it exists.
     */
    where: TopUpRecordWhereUniqueInput
    /**
     * In case the TopUpRecord found by the `where` argument doesn't exist, create a new TopUpRecord with this data.
     */
    create: XOR<TopUpRecordCreateInput, TopUpRecordUncheckedCreateInput>
    /**
     * In case the TopUpRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TopUpRecordUpdateInput, TopUpRecordUncheckedUpdateInput>
  }


  /**
   * TopUpRecord delete
   */
  export type TopUpRecordDeleteArgs = {
    /**
     * Select specific fields to fetch from the TopUpRecord
     */
    select?: TopUpRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TopUpRecordInclude | null
    /**
     * Filter which TopUpRecord to delete.
     */
    where: TopUpRecordWhereUniqueInput
  }


  /**
   * TopUpRecord deleteMany
   */
  export type TopUpRecordDeleteManyArgs = {
    /**
     * Filter which TopUpRecords to delete
     */
    where?: TopUpRecordWhereInput
  }


  /**
   * TopUpRecord without action
   */
  export type TopUpRecordArgs = {
    /**
     * Select specific fields to fetch from the TopUpRecord
     */
    select?: TopUpRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TopUpRecordInclude | null
  }



  /**
   * Model FacebookUser
   */


  export type AggregateFacebookUser = {
    _count: FacebookUserCountAggregateOutputType | null
    _avg: FacebookUserAvgAggregateOutputType | null
    _sum: FacebookUserSumAggregateOutputType | null
    _min: FacebookUserMinAggregateOutputType | null
    _max: FacebookUserMaxAggregateOutputType | null
  }

  export type FacebookUserAvgAggregateOutputType = {
    id: number | null
  }

  export type FacebookUserSumAggregateOutputType = {
    id: number | null
  }

  export type FacebookUserMinAggregateOutputType = {
    id: number | null
    name: string | null
    imageUrl: string | null
    bio: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacebookUserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    imageUrl: string | null
    bio: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacebookUserCountAggregateOutputType = {
    id: number
    name: number
    imageUrl: number
    bio: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FacebookUserAvgAggregateInputType = {
    id?: true
  }

  export type FacebookUserSumAggregateInputType = {
    id?: true
  }

  export type FacebookUserMinAggregateInputType = {
    id?: true
    name?: true
    imageUrl?: true
    bio?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacebookUserMaxAggregateInputType = {
    id?: true
    name?: true
    imageUrl?: true
    bio?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacebookUserCountAggregateInputType = {
    id?: true
    name?: true
    imageUrl?: true
    bio?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FacebookUserAggregateArgs = {
    /**
     * Filter which FacebookUser to aggregate.
     */
    where?: FacebookUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookUsers to fetch.
     */
    orderBy?: Enumerable<FacebookUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacebookUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FacebookUsers
    **/
    _count?: true | FacebookUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FacebookUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FacebookUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacebookUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacebookUserMaxAggregateInputType
  }

  export type GetFacebookUserAggregateType<T extends FacebookUserAggregateArgs> = {
        [P in keyof T & keyof AggregateFacebookUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacebookUser[P]>
      : GetScalarType<T[P], AggregateFacebookUser[P]>
  }




  export type FacebookUserGroupByArgs = {
    where?: FacebookUserWhereInput
    orderBy?: Enumerable<FacebookUserOrderByWithAggregationInput>
    by: FacebookUserScalarFieldEnum[]
    having?: FacebookUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacebookUserCountAggregateInputType | true
    _avg?: FacebookUserAvgAggregateInputType
    _sum?: FacebookUserSumAggregateInputType
    _min?: FacebookUserMinAggregateInputType
    _max?: FacebookUserMaxAggregateInputType
  }


  export type FacebookUserGroupByOutputType = {
    id: number
    name: string
    imageUrl: string
    bio: string
    createdAt: Date
    updatedAt: Date
    _count: FacebookUserCountAggregateOutputType | null
    _avg: FacebookUserAvgAggregateOutputType | null
    _sum: FacebookUserSumAggregateOutputType | null
    _min: FacebookUserMinAggregateOutputType | null
    _max: FacebookUserMaxAggregateOutputType | null
  }

  type GetFacebookUserGroupByPayload<T extends FacebookUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FacebookUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacebookUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacebookUserGroupByOutputType[P]>
            : GetScalarType<T[P], FacebookUserGroupByOutputType[P]>
        }
      >
    >


  export type FacebookUserSelect = {
    id?: boolean
    name?: boolean
    imageUrl?: boolean
    bio?: boolean
    followingUserRelations?: boolean | FacebookUser$followingUserRelationsArgs
    followedUserRelations?: boolean | FacebookUser$followedUserRelationsArgs
    posts?: boolean | FacebookUser$postsArgs
    comments?: boolean | FacebookUser$commentsArgs
    messengerMessagesFrom?: boolean | FacebookUser$messengerMessagesFromArgs
    messengerMessagesTo?: boolean | FacebookUser$messengerMessagesToArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | FacebookUserCountOutputTypeArgs
  }


  export type FacebookUserInclude = {
    followingUserRelations?: boolean | FacebookUser$followingUserRelationsArgs
    followedUserRelations?: boolean | FacebookUser$followedUserRelationsArgs
    posts?: boolean | FacebookUser$postsArgs
    comments?: boolean | FacebookUser$commentsArgs
    messengerMessagesFrom?: boolean | FacebookUser$messengerMessagesFromArgs
    messengerMessagesTo?: boolean | FacebookUser$messengerMessagesToArgs
    _count?: boolean | FacebookUserCountOutputTypeArgs
  }

  export type FacebookUserGetPayload<S extends boolean | null | undefined | FacebookUserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FacebookUser :
    S extends undefined ? never :
    S extends { include: any } & (FacebookUserArgs | FacebookUserFindManyArgs)
    ? FacebookUser  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'followingUserRelations' ? Array < FacebookUserRelationGetPayload<S['include'][P]>>  :
        P extends 'followedUserRelations' ? Array < FacebookUserRelationGetPayload<S['include'][P]>>  :
        P extends 'posts' ? Array < PostGetPayload<S['include'][P]>>  :
        P extends 'comments' ? Array < CommentGetPayload<S['include'][P]>>  :
        P extends 'messengerMessagesFrom' ? Array < MessengerMessageGetPayload<S['include'][P]>>  :
        P extends 'messengerMessagesTo' ? Array < MessengerMessageGetPayload<S['include'][P]>>  :
        P extends '_count' ? FacebookUserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FacebookUserArgs | FacebookUserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'followingUserRelations' ? Array < FacebookUserRelationGetPayload<S['select'][P]>>  :
        P extends 'followedUserRelations' ? Array < FacebookUserRelationGetPayload<S['select'][P]>>  :
        P extends 'posts' ? Array < PostGetPayload<S['select'][P]>>  :
        P extends 'comments' ? Array < CommentGetPayload<S['select'][P]>>  :
        P extends 'messengerMessagesFrom' ? Array < MessengerMessageGetPayload<S['select'][P]>>  :
        P extends 'messengerMessagesTo' ? Array < MessengerMessageGetPayload<S['select'][P]>>  :
        P extends '_count' ? FacebookUserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof FacebookUser ? FacebookUser[P] : never
  } 
      : FacebookUser


  type FacebookUserCountArgs = 
    Omit<FacebookUserFindManyArgs, 'select' | 'include'> & {
      select?: FacebookUserCountAggregateInputType | true
    }

  export interface FacebookUserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one FacebookUser that matches the filter.
     * @param {FacebookUserFindUniqueArgs} args - Arguments to find a FacebookUser
     * @example
     * // Get one FacebookUser
     * const facebookUser = await prisma.facebookUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FacebookUserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FacebookUserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FacebookUser'> extends True ? Prisma__FacebookUserClient<FacebookUserGetPayload<T>> : Prisma__FacebookUserClient<FacebookUserGetPayload<T> | null, null>

    /**
     * Find one FacebookUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FacebookUserFindUniqueOrThrowArgs} args - Arguments to find a FacebookUser
     * @example
     * // Get one FacebookUser
     * const facebookUser = await prisma.facebookUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FacebookUserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FacebookUserFindUniqueOrThrowArgs>
    ): Prisma__FacebookUserClient<FacebookUserGetPayload<T>>

    /**
     * Find the first FacebookUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserFindFirstArgs} args - Arguments to find a FacebookUser
     * @example
     * // Get one FacebookUser
     * const facebookUser = await prisma.facebookUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FacebookUserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FacebookUserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FacebookUser'> extends True ? Prisma__FacebookUserClient<FacebookUserGetPayload<T>> : Prisma__FacebookUserClient<FacebookUserGetPayload<T> | null, null>

    /**
     * Find the first FacebookUser that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserFindFirstOrThrowArgs} args - Arguments to find a FacebookUser
     * @example
     * // Get one FacebookUser
     * const facebookUser = await prisma.facebookUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FacebookUserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FacebookUserFindFirstOrThrowArgs>
    ): Prisma__FacebookUserClient<FacebookUserGetPayload<T>>

    /**
     * Find zero or more FacebookUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FacebookUsers
     * const facebookUsers = await prisma.facebookUser.findMany()
     * 
     * // Get first 10 FacebookUsers
     * const facebookUsers = await prisma.facebookUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facebookUserWithIdOnly = await prisma.facebookUser.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FacebookUserFindManyArgs>(
      args?: SelectSubset<T, FacebookUserFindManyArgs>
    ): Prisma.PrismaPromise<Array<FacebookUserGetPayload<T>>>

    /**
     * Create a FacebookUser.
     * @param {FacebookUserCreateArgs} args - Arguments to create a FacebookUser.
     * @example
     * // Create one FacebookUser
     * const FacebookUser = await prisma.facebookUser.create({
     *   data: {
     *     // ... data to create a FacebookUser
     *   }
     * })
     * 
    **/
    create<T extends FacebookUserCreateArgs>(
      args: SelectSubset<T, FacebookUserCreateArgs>
    ): Prisma__FacebookUserClient<FacebookUserGetPayload<T>>

    /**
     * Create many FacebookUsers.
     *     @param {FacebookUserCreateManyArgs} args - Arguments to create many FacebookUsers.
     *     @example
     *     // Create many FacebookUsers
     *     const facebookUser = await prisma.facebookUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FacebookUserCreateManyArgs>(
      args?: SelectSubset<T, FacebookUserCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FacebookUser.
     * @param {FacebookUserDeleteArgs} args - Arguments to delete one FacebookUser.
     * @example
     * // Delete one FacebookUser
     * const FacebookUser = await prisma.facebookUser.delete({
     *   where: {
     *     // ... filter to delete one FacebookUser
     *   }
     * })
     * 
    **/
    delete<T extends FacebookUserDeleteArgs>(
      args: SelectSubset<T, FacebookUserDeleteArgs>
    ): Prisma__FacebookUserClient<FacebookUserGetPayload<T>>

    /**
     * Update one FacebookUser.
     * @param {FacebookUserUpdateArgs} args - Arguments to update one FacebookUser.
     * @example
     * // Update one FacebookUser
     * const facebookUser = await prisma.facebookUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FacebookUserUpdateArgs>(
      args: SelectSubset<T, FacebookUserUpdateArgs>
    ): Prisma__FacebookUserClient<FacebookUserGetPayload<T>>

    /**
     * Delete zero or more FacebookUsers.
     * @param {FacebookUserDeleteManyArgs} args - Arguments to filter FacebookUsers to delete.
     * @example
     * // Delete a few FacebookUsers
     * const { count } = await prisma.facebookUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FacebookUserDeleteManyArgs>(
      args?: SelectSubset<T, FacebookUserDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacebookUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FacebookUsers
     * const facebookUser = await prisma.facebookUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FacebookUserUpdateManyArgs>(
      args: SelectSubset<T, FacebookUserUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FacebookUser.
     * @param {FacebookUserUpsertArgs} args - Arguments to update or create a FacebookUser.
     * @example
     * // Update or create a FacebookUser
     * const facebookUser = await prisma.facebookUser.upsert({
     *   create: {
     *     // ... data to create a FacebookUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FacebookUser we want to update
     *   }
     * })
    **/
    upsert<T extends FacebookUserUpsertArgs>(
      args: SelectSubset<T, FacebookUserUpsertArgs>
    ): Prisma__FacebookUserClient<FacebookUserGetPayload<T>>

    /**
     * Count the number of FacebookUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserCountArgs} args - Arguments to filter FacebookUsers to count.
     * @example
     * // Count the number of FacebookUsers
     * const count = await prisma.facebookUser.count({
     *   where: {
     *     // ... the filter for the FacebookUsers we want to count
     *   }
     * })
    **/
    count<T extends FacebookUserCountArgs>(
      args?: Subset<T, FacebookUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacebookUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FacebookUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacebookUserAggregateArgs>(args: Subset<T, FacebookUserAggregateArgs>): Prisma.PrismaPromise<GetFacebookUserAggregateType<T>>

    /**
     * Group by FacebookUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacebookUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacebookUserGroupByArgs['orderBy'] }
        : { orderBy?: FacebookUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacebookUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacebookUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FacebookUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FacebookUserClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    followingUserRelations<T extends FacebookUser$followingUserRelationsArgs= {}>(args?: Subset<T, FacebookUser$followingUserRelationsArgs>): Prisma.PrismaPromise<Array<FacebookUserRelationGetPayload<T>>| Null>;

    followedUserRelations<T extends FacebookUser$followedUserRelationsArgs= {}>(args?: Subset<T, FacebookUser$followedUserRelationsArgs>): Prisma.PrismaPromise<Array<FacebookUserRelationGetPayload<T>>| Null>;

    posts<T extends FacebookUser$postsArgs= {}>(args?: Subset<T, FacebookUser$postsArgs>): Prisma.PrismaPromise<Array<PostGetPayload<T>>| Null>;

    comments<T extends FacebookUser$commentsArgs= {}>(args?: Subset<T, FacebookUser$commentsArgs>): Prisma.PrismaPromise<Array<CommentGetPayload<T>>| Null>;

    messengerMessagesFrom<T extends FacebookUser$messengerMessagesFromArgs= {}>(args?: Subset<T, FacebookUser$messengerMessagesFromArgs>): Prisma.PrismaPromise<Array<MessengerMessageGetPayload<T>>| Null>;

    messengerMessagesTo<T extends FacebookUser$messengerMessagesToArgs= {}>(args?: Subset<T, FacebookUser$messengerMessagesToArgs>): Prisma.PrismaPromise<Array<MessengerMessageGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FacebookUser base type for findUnique actions
   */
  export type FacebookUserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FacebookUser
     */
    select?: FacebookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserInclude | null
    /**
     * Filter, which FacebookUser to fetch.
     */
    where: FacebookUserWhereUniqueInput
  }

  /**
   * FacebookUser findUnique
   */
  export interface FacebookUserFindUniqueArgs extends FacebookUserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FacebookUser findUniqueOrThrow
   */
  export type FacebookUserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FacebookUser
     */
    select?: FacebookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserInclude | null
    /**
     * Filter, which FacebookUser to fetch.
     */
    where: FacebookUserWhereUniqueInput
  }


  /**
   * FacebookUser base type for findFirst actions
   */
  export type FacebookUserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FacebookUser
     */
    select?: FacebookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserInclude | null
    /**
     * Filter, which FacebookUser to fetch.
     */
    where?: FacebookUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookUsers to fetch.
     */
    orderBy?: Enumerable<FacebookUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacebookUsers.
     */
    cursor?: FacebookUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacebookUsers.
     */
    distinct?: Enumerable<FacebookUserScalarFieldEnum>
  }

  /**
   * FacebookUser findFirst
   */
  export interface FacebookUserFindFirstArgs extends FacebookUserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FacebookUser findFirstOrThrow
   */
  export type FacebookUserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FacebookUser
     */
    select?: FacebookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserInclude | null
    /**
     * Filter, which FacebookUser to fetch.
     */
    where?: FacebookUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookUsers to fetch.
     */
    orderBy?: Enumerable<FacebookUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacebookUsers.
     */
    cursor?: FacebookUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacebookUsers.
     */
    distinct?: Enumerable<FacebookUserScalarFieldEnum>
  }


  /**
   * FacebookUser findMany
   */
  export type FacebookUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the FacebookUser
     */
    select?: FacebookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserInclude | null
    /**
     * Filter, which FacebookUsers to fetch.
     */
    where?: FacebookUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookUsers to fetch.
     */
    orderBy?: Enumerable<FacebookUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FacebookUsers.
     */
    cursor?: FacebookUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookUsers.
     */
    skip?: number
    distinct?: Enumerable<FacebookUserScalarFieldEnum>
  }


  /**
   * FacebookUser create
   */
  export type FacebookUserCreateArgs = {
    /**
     * Select specific fields to fetch from the FacebookUser
     */
    select?: FacebookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserInclude | null
    /**
     * The data needed to create a FacebookUser.
     */
    data: XOR<FacebookUserCreateInput, FacebookUserUncheckedCreateInput>
  }


  /**
   * FacebookUser createMany
   */
  export type FacebookUserCreateManyArgs = {
    /**
     * The data used to create many FacebookUsers.
     */
    data: Enumerable<FacebookUserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FacebookUser update
   */
  export type FacebookUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the FacebookUser
     */
    select?: FacebookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserInclude | null
    /**
     * The data needed to update a FacebookUser.
     */
    data: XOR<FacebookUserUpdateInput, FacebookUserUncheckedUpdateInput>
    /**
     * Choose, which FacebookUser to update.
     */
    where: FacebookUserWhereUniqueInput
  }


  /**
   * FacebookUser updateMany
   */
  export type FacebookUserUpdateManyArgs = {
    /**
     * The data used to update FacebookUsers.
     */
    data: XOR<FacebookUserUpdateManyMutationInput, FacebookUserUncheckedUpdateManyInput>
    /**
     * Filter which FacebookUsers to update
     */
    where?: FacebookUserWhereInput
  }


  /**
   * FacebookUser upsert
   */
  export type FacebookUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the FacebookUser
     */
    select?: FacebookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserInclude | null
    /**
     * The filter to search for the FacebookUser to update in case it exists.
     */
    where: FacebookUserWhereUniqueInput
    /**
     * In case the FacebookUser found by the `where` argument doesn't exist, create a new FacebookUser with this data.
     */
    create: XOR<FacebookUserCreateInput, FacebookUserUncheckedCreateInput>
    /**
     * In case the FacebookUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacebookUserUpdateInput, FacebookUserUncheckedUpdateInput>
  }


  /**
   * FacebookUser delete
   */
  export type FacebookUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the FacebookUser
     */
    select?: FacebookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserInclude | null
    /**
     * Filter which FacebookUser to delete.
     */
    where: FacebookUserWhereUniqueInput
  }


  /**
   * FacebookUser deleteMany
   */
  export type FacebookUserDeleteManyArgs = {
    /**
     * Filter which FacebookUsers to delete
     */
    where?: FacebookUserWhereInput
  }


  /**
   * FacebookUser.followingUserRelations
   */
  export type FacebookUser$followingUserRelationsArgs = {
    /**
     * Select specific fields to fetch from the FacebookUserRelation
     */
    select?: FacebookUserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserRelationInclude | null
    where?: FacebookUserRelationWhereInput
    orderBy?: Enumerable<FacebookUserRelationOrderByWithRelationInput>
    cursor?: FacebookUserRelationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FacebookUserRelationScalarFieldEnum>
  }


  /**
   * FacebookUser.followedUserRelations
   */
  export type FacebookUser$followedUserRelationsArgs = {
    /**
     * Select specific fields to fetch from the FacebookUserRelation
     */
    select?: FacebookUserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserRelationInclude | null
    where?: FacebookUserRelationWhereInput
    orderBy?: Enumerable<FacebookUserRelationOrderByWithRelationInput>
    cursor?: FacebookUserRelationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FacebookUserRelationScalarFieldEnum>
  }


  /**
   * FacebookUser.posts
   */
  export type FacebookUser$postsArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    where?: PostWhereInput
    orderBy?: Enumerable<PostOrderByWithRelationInput>
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PostScalarFieldEnum>
  }


  /**
   * FacebookUser.comments
   */
  export type FacebookUser$commentsArgs = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
    where?: CommentWhereInput
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CommentScalarFieldEnum>
  }


  /**
   * FacebookUser.messengerMessagesFrom
   */
  export type FacebookUser$messengerMessagesFromArgs = {
    /**
     * Select specific fields to fetch from the MessengerMessage
     */
    select?: MessengerMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessengerMessageInclude | null
    where?: MessengerMessageWhereInput
    orderBy?: Enumerable<MessengerMessageOrderByWithRelationInput>
    cursor?: MessengerMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MessengerMessageScalarFieldEnum>
  }


  /**
   * FacebookUser.messengerMessagesTo
   */
  export type FacebookUser$messengerMessagesToArgs = {
    /**
     * Select specific fields to fetch from the MessengerMessage
     */
    select?: MessengerMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessengerMessageInclude | null
    where?: MessengerMessageWhereInput
    orderBy?: Enumerable<MessengerMessageOrderByWithRelationInput>
    cursor?: MessengerMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MessengerMessageScalarFieldEnum>
  }


  /**
   * FacebookUser without action
   */
  export type FacebookUserArgs = {
    /**
     * Select specific fields to fetch from the FacebookUser
     */
    select?: FacebookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserInclude | null
  }



  /**
   * Model FacebookUserRelation
   */


  export type AggregateFacebookUserRelation = {
    _count: FacebookUserRelationCountAggregateOutputType | null
    _avg: FacebookUserRelationAvgAggregateOutputType | null
    _sum: FacebookUserRelationSumAggregateOutputType | null
    _min: FacebookUserRelationMinAggregateOutputType | null
    _max: FacebookUserRelationMaxAggregateOutputType | null
  }

  export type FacebookUserRelationAvgAggregateOutputType = {
    id: number | null
    followingUserId: number | null
    followedUserId: number | null
  }

  export type FacebookUserRelationSumAggregateOutputType = {
    id: number | null
    followingUserId: number | null
    followedUserId: number | null
  }

  export type FacebookUserRelationMinAggregateOutputType = {
    id: number | null
    followingUserId: number | null
    followedUserId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacebookUserRelationMaxAggregateOutputType = {
    id: number | null
    followingUserId: number | null
    followedUserId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacebookUserRelationCountAggregateOutputType = {
    id: number
    followingUserId: number
    followedUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FacebookUserRelationAvgAggregateInputType = {
    id?: true
    followingUserId?: true
    followedUserId?: true
  }

  export type FacebookUserRelationSumAggregateInputType = {
    id?: true
    followingUserId?: true
    followedUserId?: true
  }

  export type FacebookUserRelationMinAggregateInputType = {
    id?: true
    followingUserId?: true
    followedUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacebookUserRelationMaxAggregateInputType = {
    id?: true
    followingUserId?: true
    followedUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacebookUserRelationCountAggregateInputType = {
    id?: true
    followingUserId?: true
    followedUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FacebookUserRelationAggregateArgs = {
    /**
     * Filter which FacebookUserRelation to aggregate.
     */
    where?: FacebookUserRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookUserRelations to fetch.
     */
    orderBy?: Enumerable<FacebookUserRelationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacebookUserRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookUserRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookUserRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FacebookUserRelations
    **/
    _count?: true | FacebookUserRelationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FacebookUserRelationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FacebookUserRelationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacebookUserRelationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacebookUserRelationMaxAggregateInputType
  }

  export type GetFacebookUserRelationAggregateType<T extends FacebookUserRelationAggregateArgs> = {
        [P in keyof T & keyof AggregateFacebookUserRelation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacebookUserRelation[P]>
      : GetScalarType<T[P], AggregateFacebookUserRelation[P]>
  }




  export type FacebookUserRelationGroupByArgs = {
    where?: FacebookUserRelationWhereInput
    orderBy?: Enumerable<FacebookUserRelationOrderByWithAggregationInput>
    by: FacebookUserRelationScalarFieldEnum[]
    having?: FacebookUserRelationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacebookUserRelationCountAggregateInputType | true
    _avg?: FacebookUserRelationAvgAggregateInputType
    _sum?: FacebookUserRelationSumAggregateInputType
    _min?: FacebookUserRelationMinAggregateInputType
    _max?: FacebookUserRelationMaxAggregateInputType
  }


  export type FacebookUserRelationGroupByOutputType = {
    id: number
    followingUserId: number
    followedUserId: number
    createdAt: Date
    updatedAt: Date
    _count: FacebookUserRelationCountAggregateOutputType | null
    _avg: FacebookUserRelationAvgAggregateOutputType | null
    _sum: FacebookUserRelationSumAggregateOutputType | null
    _min: FacebookUserRelationMinAggregateOutputType | null
    _max: FacebookUserRelationMaxAggregateOutputType | null
  }

  type GetFacebookUserRelationGroupByPayload<T extends FacebookUserRelationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FacebookUserRelationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacebookUserRelationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacebookUserRelationGroupByOutputType[P]>
            : GetScalarType<T[P], FacebookUserRelationGroupByOutputType[P]>
        }
      >
    >


  export type FacebookUserRelationSelect = {
    id?: boolean
    followingUser?: boolean | FacebookUserArgs
    followingUserId?: boolean
    followedUser?: boolean | FacebookUserArgs
    followedUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type FacebookUserRelationInclude = {
    followingUser?: boolean | FacebookUserArgs
    followedUser?: boolean | FacebookUserArgs
  }

  export type FacebookUserRelationGetPayload<S extends boolean | null | undefined | FacebookUserRelationArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FacebookUserRelation :
    S extends undefined ? never :
    S extends { include: any } & (FacebookUserRelationArgs | FacebookUserRelationFindManyArgs)
    ? FacebookUserRelation  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'followingUser' ? FacebookUserGetPayload<S['include'][P]> :
        P extends 'followedUser' ? FacebookUserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FacebookUserRelationArgs | FacebookUserRelationFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'followingUser' ? FacebookUserGetPayload<S['select'][P]> :
        P extends 'followedUser' ? FacebookUserGetPayload<S['select'][P]> :  P extends keyof FacebookUserRelation ? FacebookUserRelation[P] : never
  } 
      : FacebookUserRelation


  type FacebookUserRelationCountArgs = 
    Omit<FacebookUserRelationFindManyArgs, 'select' | 'include'> & {
      select?: FacebookUserRelationCountAggregateInputType | true
    }

  export interface FacebookUserRelationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one FacebookUserRelation that matches the filter.
     * @param {FacebookUserRelationFindUniqueArgs} args - Arguments to find a FacebookUserRelation
     * @example
     * // Get one FacebookUserRelation
     * const facebookUserRelation = await prisma.facebookUserRelation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FacebookUserRelationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FacebookUserRelationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FacebookUserRelation'> extends True ? Prisma__FacebookUserRelationClient<FacebookUserRelationGetPayload<T>> : Prisma__FacebookUserRelationClient<FacebookUserRelationGetPayload<T> | null, null>

    /**
     * Find one FacebookUserRelation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FacebookUserRelationFindUniqueOrThrowArgs} args - Arguments to find a FacebookUserRelation
     * @example
     * // Get one FacebookUserRelation
     * const facebookUserRelation = await prisma.facebookUserRelation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FacebookUserRelationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FacebookUserRelationFindUniqueOrThrowArgs>
    ): Prisma__FacebookUserRelationClient<FacebookUserRelationGetPayload<T>>

    /**
     * Find the first FacebookUserRelation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserRelationFindFirstArgs} args - Arguments to find a FacebookUserRelation
     * @example
     * // Get one FacebookUserRelation
     * const facebookUserRelation = await prisma.facebookUserRelation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FacebookUserRelationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FacebookUserRelationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FacebookUserRelation'> extends True ? Prisma__FacebookUserRelationClient<FacebookUserRelationGetPayload<T>> : Prisma__FacebookUserRelationClient<FacebookUserRelationGetPayload<T> | null, null>

    /**
     * Find the first FacebookUserRelation that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserRelationFindFirstOrThrowArgs} args - Arguments to find a FacebookUserRelation
     * @example
     * // Get one FacebookUserRelation
     * const facebookUserRelation = await prisma.facebookUserRelation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FacebookUserRelationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FacebookUserRelationFindFirstOrThrowArgs>
    ): Prisma__FacebookUserRelationClient<FacebookUserRelationGetPayload<T>>

    /**
     * Find zero or more FacebookUserRelations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserRelationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FacebookUserRelations
     * const facebookUserRelations = await prisma.facebookUserRelation.findMany()
     * 
     * // Get first 10 FacebookUserRelations
     * const facebookUserRelations = await prisma.facebookUserRelation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facebookUserRelationWithIdOnly = await prisma.facebookUserRelation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FacebookUserRelationFindManyArgs>(
      args?: SelectSubset<T, FacebookUserRelationFindManyArgs>
    ): Prisma.PrismaPromise<Array<FacebookUserRelationGetPayload<T>>>

    /**
     * Create a FacebookUserRelation.
     * @param {FacebookUserRelationCreateArgs} args - Arguments to create a FacebookUserRelation.
     * @example
     * // Create one FacebookUserRelation
     * const FacebookUserRelation = await prisma.facebookUserRelation.create({
     *   data: {
     *     // ... data to create a FacebookUserRelation
     *   }
     * })
     * 
    **/
    create<T extends FacebookUserRelationCreateArgs>(
      args: SelectSubset<T, FacebookUserRelationCreateArgs>
    ): Prisma__FacebookUserRelationClient<FacebookUserRelationGetPayload<T>>

    /**
     * Create many FacebookUserRelations.
     *     @param {FacebookUserRelationCreateManyArgs} args - Arguments to create many FacebookUserRelations.
     *     @example
     *     // Create many FacebookUserRelations
     *     const facebookUserRelation = await prisma.facebookUserRelation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FacebookUserRelationCreateManyArgs>(
      args?: SelectSubset<T, FacebookUserRelationCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FacebookUserRelation.
     * @param {FacebookUserRelationDeleteArgs} args - Arguments to delete one FacebookUserRelation.
     * @example
     * // Delete one FacebookUserRelation
     * const FacebookUserRelation = await prisma.facebookUserRelation.delete({
     *   where: {
     *     // ... filter to delete one FacebookUserRelation
     *   }
     * })
     * 
    **/
    delete<T extends FacebookUserRelationDeleteArgs>(
      args: SelectSubset<T, FacebookUserRelationDeleteArgs>
    ): Prisma__FacebookUserRelationClient<FacebookUserRelationGetPayload<T>>

    /**
     * Update one FacebookUserRelation.
     * @param {FacebookUserRelationUpdateArgs} args - Arguments to update one FacebookUserRelation.
     * @example
     * // Update one FacebookUserRelation
     * const facebookUserRelation = await prisma.facebookUserRelation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FacebookUserRelationUpdateArgs>(
      args: SelectSubset<T, FacebookUserRelationUpdateArgs>
    ): Prisma__FacebookUserRelationClient<FacebookUserRelationGetPayload<T>>

    /**
     * Delete zero or more FacebookUserRelations.
     * @param {FacebookUserRelationDeleteManyArgs} args - Arguments to filter FacebookUserRelations to delete.
     * @example
     * // Delete a few FacebookUserRelations
     * const { count } = await prisma.facebookUserRelation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FacebookUserRelationDeleteManyArgs>(
      args?: SelectSubset<T, FacebookUserRelationDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacebookUserRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserRelationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FacebookUserRelations
     * const facebookUserRelation = await prisma.facebookUserRelation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FacebookUserRelationUpdateManyArgs>(
      args: SelectSubset<T, FacebookUserRelationUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FacebookUserRelation.
     * @param {FacebookUserRelationUpsertArgs} args - Arguments to update or create a FacebookUserRelation.
     * @example
     * // Update or create a FacebookUserRelation
     * const facebookUserRelation = await prisma.facebookUserRelation.upsert({
     *   create: {
     *     // ... data to create a FacebookUserRelation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FacebookUserRelation we want to update
     *   }
     * })
    **/
    upsert<T extends FacebookUserRelationUpsertArgs>(
      args: SelectSubset<T, FacebookUserRelationUpsertArgs>
    ): Prisma__FacebookUserRelationClient<FacebookUserRelationGetPayload<T>>

    /**
     * Count the number of FacebookUserRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserRelationCountArgs} args - Arguments to filter FacebookUserRelations to count.
     * @example
     * // Count the number of FacebookUserRelations
     * const count = await prisma.facebookUserRelation.count({
     *   where: {
     *     // ... the filter for the FacebookUserRelations we want to count
     *   }
     * })
    **/
    count<T extends FacebookUserRelationCountArgs>(
      args?: Subset<T, FacebookUserRelationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacebookUserRelationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FacebookUserRelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserRelationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacebookUserRelationAggregateArgs>(args: Subset<T, FacebookUserRelationAggregateArgs>): Prisma.PrismaPromise<GetFacebookUserRelationAggregateType<T>>

    /**
     * Group by FacebookUserRelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserRelationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacebookUserRelationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacebookUserRelationGroupByArgs['orderBy'] }
        : { orderBy?: FacebookUserRelationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacebookUserRelationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacebookUserRelationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FacebookUserRelation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FacebookUserRelationClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    followingUser<T extends FacebookUserArgs= {}>(args?: Subset<T, FacebookUserArgs>): Prisma__FacebookUserClient<FacebookUserGetPayload<T> | Null>;

    followedUser<T extends FacebookUserArgs= {}>(args?: Subset<T, FacebookUserArgs>): Prisma__FacebookUserClient<FacebookUserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FacebookUserRelation base type for findUnique actions
   */
  export type FacebookUserRelationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FacebookUserRelation
     */
    select?: FacebookUserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserRelationInclude | null
    /**
     * Filter, which FacebookUserRelation to fetch.
     */
    where: FacebookUserRelationWhereUniqueInput
  }

  /**
   * FacebookUserRelation findUnique
   */
  export interface FacebookUserRelationFindUniqueArgs extends FacebookUserRelationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FacebookUserRelation findUniqueOrThrow
   */
  export type FacebookUserRelationFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FacebookUserRelation
     */
    select?: FacebookUserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserRelationInclude | null
    /**
     * Filter, which FacebookUserRelation to fetch.
     */
    where: FacebookUserRelationWhereUniqueInput
  }


  /**
   * FacebookUserRelation base type for findFirst actions
   */
  export type FacebookUserRelationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FacebookUserRelation
     */
    select?: FacebookUserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserRelationInclude | null
    /**
     * Filter, which FacebookUserRelation to fetch.
     */
    where?: FacebookUserRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookUserRelations to fetch.
     */
    orderBy?: Enumerable<FacebookUserRelationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacebookUserRelations.
     */
    cursor?: FacebookUserRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookUserRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookUserRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacebookUserRelations.
     */
    distinct?: Enumerable<FacebookUserRelationScalarFieldEnum>
  }

  /**
   * FacebookUserRelation findFirst
   */
  export interface FacebookUserRelationFindFirstArgs extends FacebookUserRelationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FacebookUserRelation findFirstOrThrow
   */
  export type FacebookUserRelationFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FacebookUserRelation
     */
    select?: FacebookUserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserRelationInclude | null
    /**
     * Filter, which FacebookUserRelation to fetch.
     */
    where?: FacebookUserRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookUserRelations to fetch.
     */
    orderBy?: Enumerable<FacebookUserRelationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacebookUserRelations.
     */
    cursor?: FacebookUserRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookUserRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookUserRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacebookUserRelations.
     */
    distinct?: Enumerable<FacebookUserRelationScalarFieldEnum>
  }


  /**
   * FacebookUserRelation findMany
   */
  export type FacebookUserRelationFindManyArgs = {
    /**
     * Select specific fields to fetch from the FacebookUserRelation
     */
    select?: FacebookUserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserRelationInclude | null
    /**
     * Filter, which FacebookUserRelations to fetch.
     */
    where?: FacebookUserRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookUserRelations to fetch.
     */
    orderBy?: Enumerable<FacebookUserRelationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FacebookUserRelations.
     */
    cursor?: FacebookUserRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookUserRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookUserRelations.
     */
    skip?: number
    distinct?: Enumerable<FacebookUserRelationScalarFieldEnum>
  }


  /**
   * FacebookUserRelation create
   */
  export type FacebookUserRelationCreateArgs = {
    /**
     * Select specific fields to fetch from the FacebookUserRelation
     */
    select?: FacebookUserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserRelationInclude | null
    /**
     * The data needed to create a FacebookUserRelation.
     */
    data: XOR<FacebookUserRelationCreateInput, FacebookUserRelationUncheckedCreateInput>
  }


  /**
   * FacebookUserRelation createMany
   */
  export type FacebookUserRelationCreateManyArgs = {
    /**
     * The data used to create many FacebookUserRelations.
     */
    data: Enumerable<FacebookUserRelationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FacebookUserRelation update
   */
  export type FacebookUserRelationUpdateArgs = {
    /**
     * Select specific fields to fetch from the FacebookUserRelation
     */
    select?: FacebookUserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserRelationInclude | null
    /**
     * The data needed to update a FacebookUserRelation.
     */
    data: XOR<FacebookUserRelationUpdateInput, FacebookUserRelationUncheckedUpdateInput>
    /**
     * Choose, which FacebookUserRelation to update.
     */
    where: FacebookUserRelationWhereUniqueInput
  }


  /**
   * FacebookUserRelation updateMany
   */
  export type FacebookUserRelationUpdateManyArgs = {
    /**
     * The data used to update FacebookUserRelations.
     */
    data: XOR<FacebookUserRelationUpdateManyMutationInput, FacebookUserRelationUncheckedUpdateManyInput>
    /**
     * Filter which FacebookUserRelations to update
     */
    where?: FacebookUserRelationWhereInput
  }


  /**
   * FacebookUserRelation upsert
   */
  export type FacebookUserRelationUpsertArgs = {
    /**
     * Select specific fields to fetch from the FacebookUserRelation
     */
    select?: FacebookUserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserRelationInclude | null
    /**
     * The filter to search for the FacebookUserRelation to update in case it exists.
     */
    where: FacebookUserRelationWhereUniqueInput
    /**
     * In case the FacebookUserRelation found by the `where` argument doesn't exist, create a new FacebookUserRelation with this data.
     */
    create: XOR<FacebookUserRelationCreateInput, FacebookUserRelationUncheckedCreateInput>
    /**
     * In case the FacebookUserRelation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacebookUserRelationUpdateInput, FacebookUserRelationUncheckedUpdateInput>
  }


  /**
   * FacebookUserRelation delete
   */
  export type FacebookUserRelationDeleteArgs = {
    /**
     * Select specific fields to fetch from the FacebookUserRelation
     */
    select?: FacebookUserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserRelationInclude | null
    /**
     * Filter which FacebookUserRelation to delete.
     */
    where: FacebookUserRelationWhereUniqueInput
  }


  /**
   * FacebookUserRelation deleteMany
   */
  export type FacebookUserRelationDeleteManyArgs = {
    /**
     * Filter which FacebookUserRelations to delete
     */
    where?: FacebookUserRelationWhereInput
  }


  /**
   * FacebookUserRelation without action
   */
  export type FacebookUserRelationArgs = {
    /**
     * Select specific fields to fetch from the FacebookUserRelation
     */
    select?: FacebookUserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserRelationInclude | null
  }



  /**
   * Model Post
   */


  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type PostSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type PostMinAggregateOutputType = {
    id: number | null
    postText: string | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostMaxAggregateOutputType = {
    id: number | null
    postText: string | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    postText: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PostAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type PostSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type PostMinAggregateInputType = {
    id?: true
    postText?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    postText?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    postText?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PostAggregateArgs = {
    /**
     * Filter which Post to aggregate.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: Enumerable<PostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs = {
    where?: PostWhereInput
    orderBy?: Enumerable<PostOrderByWithAggregationInput>
    by: PostScalarFieldEnum[]
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _avg?: PostAvgAggregateInputType
    _sum?: PostSumAggregateInputType
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }


  export type PostGroupByOutputType = {
    id: number
    postText: string
    userId: number
    createdAt: Date
    updatedAt: Date
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect = {
    id?: boolean
    postText?: boolean
    postingUser?: boolean | FacebookUserArgs
    userId?: boolean
    comments?: boolean | Post$commentsArgs
    hashTags?: boolean | Post$hashTagsArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | PostCountOutputTypeArgs
  }


  export type PostInclude = {
    postingUser?: boolean | FacebookUserArgs
    comments?: boolean | Post$commentsArgs
    hashTags?: boolean | Post$hashTagsArgs
    _count?: boolean | PostCountOutputTypeArgs
  }

  export type PostGetPayload<S extends boolean | null | undefined | PostArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Post :
    S extends undefined ? never :
    S extends { include: any } & (PostArgs | PostFindManyArgs)
    ? Post  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'postingUser' ? FacebookUserGetPayload<S['include'][P]> :
        P extends 'comments' ? Array < CommentGetPayload<S['include'][P]>>  :
        P extends 'hashTags' ? Array < FacebookHashTagGetPayload<S['include'][P]>>  :
        P extends '_count' ? PostCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PostArgs | PostFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'postingUser' ? FacebookUserGetPayload<S['select'][P]> :
        P extends 'comments' ? Array < CommentGetPayload<S['select'][P]>>  :
        P extends 'hashTags' ? Array < FacebookHashTagGetPayload<S['select'][P]>>  :
        P extends '_count' ? PostCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Post ? Post[P] : never
  } 
      : Post


  type PostCountArgs = 
    Omit<PostFindManyArgs, 'select' | 'include'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface PostDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PostFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PostFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Post'> extends True ? Prisma__PostClient<PostGetPayload<T>> : Prisma__PostClient<PostGetPayload<T> | null, null>

    /**
     * Find one Post that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PostFindUniqueOrThrowArgs>
    ): Prisma__PostClient<PostGetPayload<T>>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PostFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PostFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Post'> extends True ? Prisma__PostClient<PostGetPayload<T>> : Prisma__PostClient<PostGetPayload<T> | null, null>

    /**
     * Find the first Post that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PostFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PostFindFirstOrThrowArgs>
    ): Prisma__PostClient<PostGetPayload<T>>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PostFindManyArgs>(
      args?: SelectSubset<T, PostFindManyArgs>
    ): Prisma.PrismaPromise<Array<PostGetPayload<T>>>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
    **/
    create<T extends PostCreateArgs>(
      args: SelectSubset<T, PostCreateArgs>
    ): Prisma__PostClient<PostGetPayload<T>>

    /**
     * Create many Posts.
     *     @param {PostCreateManyArgs} args - Arguments to create many Posts.
     *     @example
     *     // Create many Posts
     *     const post = await prisma.post.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PostCreateManyArgs>(
      args?: SelectSubset<T, PostCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
    **/
    delete<T extends PostDeleteArgs>(
      args: SelectSubset<T, PostDeleteArgs>
    ): Prisma__PostClient<PostGetPayload<T>>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PostUpdateArgs>(
      args: SelectSubset<T, PostUpdateArgs>
    ): Prisma__PostClient<PostGetPayload<T>>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PostDeleteManyArgs>(
      args?: SelectSubset<T, PostDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PostUpdateManyArgs>(
      args: SelectSubset<T, PostUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
    **/
    upsert<T extends PostUpsertArgs>(
      args: SelectSubset<T, PostUpsertArgs>
    ): Prisma__PostClient<PostGetPayload<T>>

    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PostClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    postingUser<T extends FacebookUserArgs= {}>(args?: Subset<T, FacebookUserArgs>): Prisma__FacebookUserClient<FacebookUserGetPayload<T> | Null>;

    comments<T extends Post$commentsArgs= {}>(args?: Subset<T, Post$commentsArgs>): Prisma.PrismaPromise<Array<CommentGetPayload<T>>| Null>;

    hashTags<T extends Post$hashTagsArgs= {}>(args?: Subset<T, Post$hashTagsArgs>): Prisma.PrismaPromise<Array<FacebookHashTagGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Post base type for findUnique actions
   */
  export type PostFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findUnique
   */
  export interface PostFindUniqueArgs extends PostFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Post findUniqueOrThrow
   */
  export type PostFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }


  /**
   * Post base type for findFirst actions
   */
  export type PostFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: Enumerable<PostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: Enumerable<PostScalarFieldEnum>
  }

  /**
   * Post findFirst
   */
  export interface PostFindFirstArgs extends PostFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Post findFirstOrThrow
   */
  export type PostFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: Enumerable<PostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: Enumerable<PostScalarFieldEnum>
  }


  /**
   * Post findMany
   */
  export type PostFindManyArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: Enumerable<PostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: Enumerable<PostScalarFieldEnum>
  }


  /**
   * Post create
   */
  export type PostCreateArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    /**
     * The data needed to create a Post.
     */
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
  }


  /**
   * Post createMany
   */
  export type PostCreateManyArgs = {
    /**
     * The data used to create many Posts.
     */
    data: Enumerable<PostCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Post update
   */
  export type PostUpdateArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    /**
     * The data needed to update a Post.
     */
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     */
    where: PostWhereUniqueInput
  }


  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
  }


  /**
   * Post upsert
   */
  export type PostUpsertArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    /**
     * The filter to search for the Post to update in case it exists.
     */
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
     */
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }


  /**
   * Post delete
   */
  export type PostDeleteArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    /**
     * Filter which Post to delete.
     */
    where: PostWhereUniqueInput
  }


  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs = {
    /**
     * Filter which Posts to delete
     */
    where?: PostWhereInput
  }


  /**
   * Post.comments
   */
  export type Post$commentsArgs = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
    where?: CommentWhereInput
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CommentScalarFieldEnum>
  }


  /**
   * Post.hashTags
   */
  export type Post$hashTagsArgs = {
    /**
     * Select specific fields to fetch from the FacebookHashTag
     */
    select?: FacebookHashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookHashTagInclude | null
    where?: FacebookHashTagWhereInput
    orderBy?: Enumerable<FacebookHashTagOrderByWithRelationInput>
    cursor?: FacebookHashTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FacebookHashTagScalarFieldEnum>
  }


  /**
   * Post without action
   */
  export type PostArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
  }



  /**
   * Model Comment
   */


  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    postId: number | null
    parentCommentId: number | null
  }

  export type CommentSumAggregateOutputType = {
    id: number | null
    userId: number | null
    postId: number | null
    parentCommentId: number | null
  }

  export type CommentMinAggregateOutputType = {
    id: number | null
    commentText: string | null
    userId: number | null
    postId: number | null
    parentCommentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: number | null
    commentText: string | null
    userId: number | null
    postId: number | null
    parentCommentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    commentText: number
    userId: number
    postId: number
    parentCommentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommentAvgAggregateInputType = {
    id?: true
    userId?: true
    postId?: true
    parentCommentId?: true
  }

  export type CommentSumAggregateInputType = {
    id?: true
    userId?: true
    postId?: true
    parentCommentId?: true
  }

  export type CommentMinAggregateInputType = {
    id?: true
    commentText?: true
    userId?: true
    postId?: true
    parentCommentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    commentText?: true
    userId?: true
    postId?: true
    parentCommentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    commentText?: true
    userId?: true
    postId?: true
    parentCommentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommentAggregateArgs = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs = {
    where?: CommentWhereInput
    orderBy?: Enumerable<CommentOrderByWithAggregationInput>
    by: CommentScalarFieldEnum[]
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _avg?: CommentAvgAggregateInputType
    _sum?: CommentSumAggregateInputType
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }


  export type CommentGroupByOutputType = {
    id: number
    commentText: string
    userId: number
    postId: number
    parentCommentId: number | null
    createdAt: Date
    updatedAt: Date
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect = {
    id?: boolean
    commentText?: boolean
    commentingUser?: boolean | FacebookUserArgs
    userId?: boolean
    parentPost?: boolean | PostArgs
    postId?: boolean
    parentComment?: boolean | CommentArgs
    parentCommentId?: boolean
    childComments?: boolean | Comment$childCommentsArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | CommentCountOutputTypeArgs
  }


  export type CommentInclude = {
    commentingUser?: boolean | FacebookUserArgs
    parentPost?: boolean | PostArgs
    parentComment?: boolean | CommentArgs
    childComments?: boolean | Comment$childCommentsArgs
    _count?: boolean | CommentCountOutputTypeArgs
  }

  export type CommentGetPayload<S extends boolean | null | undefined | CommentArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Comment :
    S extends undefined ? never :
    S extends { include: any } & (CommentArgs | CommentFindManyArgs)
    ? Comment  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'commentingUser' ? FacebookUserGetPayload<S['include'][P]> :
        P extends 'parentPost' ? PostGetPayload<S['include'][P]> :
        P extends 'parentComment' ? CommentGetPayload<S['include'][P]> | null :
        P extends 'childComments' ? Array < CommentGetPayload<S['include'][P]>>  :
        P extends '_count' ? CommentCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CommentArgs | CommentFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'commentingUser' ? FacebookUserGetPayload<S['select'][P]> :
        P extends 'parentPost' ? PostGetPayload<S['select'][P]> :
        P extends 'parentComment' ? CommentGetPayload<S['select'][P]> | null :
        P extends 'childComments' ? Array < CommentGetPayload<S['select'][P]>>  :
        P extends '_count' ? CommentCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Comment ? Comment[P] : never
  } 
      : Comment


  type CommentCountArgs = 
    Omit<CommentFindManyArgs, 'select' | 'include'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CommentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Comment'> extends True ? Prisma__CommentClient<CommentGetPayload<T>> : Prisma__CommentClient<CommentGetPayload<T> | null, null>

    /**
     * Find one Comment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CommentFindUniqueOrThrowArgs>
    ): Prisma__CommentClient<CommentGetPayload<T>>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CommentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Comment'> extends True ? Prisma__CommentClient<CommentGetPayload<T>> : Prisma__CommentClient<CommentGetPayload<T> | null, null>

    /**
     * Find the first Comment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CommentFindFirstOrThrowArgs>
    ): Prisma__CommentClient<CommentGetPayload<T>>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommentFindManyArgs>(
      args?: SelectSubset<T, CommentFindManyArgs>
    ): Prisma.PrismaPromise<Array<CommentGetPayload<T>>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
    **/
    create<T extends CommentCreateArgs>(
      args: SelectSubset<T, CommentCreateArgs>
    ): Prisma__CommentClient<CommentGetPayload<T>>

    /**
     * Create many Comments.
     *     @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     *     @example
     *     // Create many Comments
     *     const comment = await prisma.comment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommentCreateManyArgs>(
      args?: SelectSubset<T, CommentCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
    **/
    delete<T extends CommentDeleteArgs>(
      args: SelectSubset<T, CommentDeleteArgs>
    ): Prisma__CommentClient<CommentGetPayload<T>>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommentUpdateArgs>(
      args: SelectSubset<T, CommentUpdateArgs>
    ): Prisma__CommentClient<CommentGetPayload<T>>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommentDeleteManyArgs>(
      args?: SelectSubset<T, CommentDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommentUpdateManyArgs>(
      args: SelectSubset<T, CommentUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
    **/
    upsert<T extends CommentUpsertArgs>(
      args: SelectSubset<T, CommentUpsertArgs>
    ): Prisma__CommentClient<CommentGetPayload<T>>

    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CommentClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    commentingUser<T extends FacebookUserArgs= {}>(args?: Subset<T, FacebookUserArgs>): Prisma__FacebookUserClient<FacebookUserGetPayload<T> | Null>;

    parentPost<T extends PostArgs= {}>(args?: Subset<T, PostArgs>): Prisma__PostClient<PostGetPayload<T> | Null>;

    parentComment<T extends CommentArgs= {}>(args?: Subset<T, CommentArgs>): Prisma__CommentClient<CommentGetPayload<T> | Null>;

    childComments<T extends Comment$childCommentsArgs= {}>(args?: Subset<T, Comment$childCommentsArgs>): Prisma.PrismaPromise<Array<CommentGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Comment base type for findUnique actions
   */
  export type CommentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUnique
   */
  export interface CommentFindUniqueArgs extends CommentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment base type for findFirst actions
   */
  export type CommentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: Enumerable<CommentScalarFieldEnum>
  }

  /**
   * Comment findFirst
   */
  export interface CommentFindFirstArgs extends CommentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: Enumerable<CommentScalarFieldEnum>
  }


  /**
   * Comment findMany
   */
  export type CommentFindManyArgs = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: Enumerable<CommentScalarFieldEnum>
  }


  /**
   * Comment create
   */
  export type CommentCreateArgs = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }


  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs = {
    /**
     * The data used to create many Comments.
     */
    data: Enumerable<CommentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Comment update
   */
  export type CommentUpdateArgs = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
  }


  /**
   * Comment upsert
   */
  export type CommentUpsertArgs = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }


  /**
   * Comment delete
   */
  export type CommentDeleteArgs = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
  }


  /**
   * Comment.childComments
   */
  export type Comment$childCommentsArgs = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
    where?: CommentWhereInput
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CommentScalarFieldEnum>
  }


  /**
   * Comment without action
   */
  export type CommentArgs = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
  }



  /**
   * Model FacebookHashTag
   */


  export type AggregateFacebookHashTag = {
    _count: FacebookHashTagCountAggregateOutputType | null
    _avg: FacebookHashTagAvgAggregateOutputType | null
    _sum: FacebookHashTagSumAggregateOutputType | null
    _min: FacebookHashTagMinAggregateOutputType | null
    _max: FacebookHashTagMaxAggregateOutputType | null
  }

  export type FacebookHashTagAvgAggregateOutputType = {
    id: number | null
  }

  export type FacebookHashTagSumAggregateOutputType = {
    id: number | null
  }

  export type FacebookHashTagMinAggregateOutputType = {
    id: number | null
    hashTagText: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacebookHashTagMaxAggregateOutputType = {
    id: number | null
    hashTagText: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacebookHashTagCountAggregateOutputType = {
    id: number
    hashTagText: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FacebookHashTagAvgAggregateInputType = {
    id?: true
  }

  export type FacebookHashTagSumAggregateInputType = {
    id?: true
  }

  export type FacebookHashTagMinAggregateInputType = {
    id?: true
    hashTagText?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacebookHashTagMaxAggregateInputType = {
    id?: true
    hashTagText?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacebookHashTagCountAggregateInputType = {
    id?: true
    hashTagText?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FacebookHashTagAggregateArgs = {
    /**
     * Filter which FacebookHashTag to aggregate.
     */
    where?: FacebookHashTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookHashTags to fetch.
     */
    orderBy?: Enumerable<FacebookHashTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacebookHashTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookHashTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookHashTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FacebookHashTags
    **/
    _count?: true | FacebookHashTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FacebookHashTagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FacebookHashTagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacebookHashTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacebookHashTagMaxAggregateInputType
  }

  export type GetFacebookHashTagAggregateType<T extends FacebookHashTagAggregateArgs> = {
        [P in keyof T & keyof AggregateFacebookHashTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacebookHashTag[P]>
      : GetScalarType<T[P], AggregateFacebookHashTag[P]>
  }




  export type FacebookHashTagGroupByArgs = {
    where?: FacebookHashTagWhereInput
    orderBy?: Enumerable<FacebookHashTagOrderByWithAggregationInput>
    by: FacebookHashTagScalarFieldEnum[]
    having?: FacebookHashTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacebookHashTagCountAggregateInputType | true
    _avg?: FacebookHashTagAvgAggregateInputType
    _sum?: FacebookHashTagSumAggregateInputType
    _min?: FacebookHashTagMinAggregateInputType
    _max?: FacebookHashTagMaxAggregateInputType
  }


  export type FacebookHashTagGroupByOutputType = {
    id: number
    hashTagText: string
    createdAt: Date
    updatedAt: Date
    _count: FacebookHashTagCountAggregateOutputType | null
    _avg: FacebookHashTagAvgAggregateOutputType | null
    _sum: FacebookHashTagSumAggregateOutputType | null
    _min: FacebookHashTagMinAggregateOutputType | null
    _max: FacebookHashTagMaxAggregateOutputType | null
  }

  type GetFacebookHashTagGroupByPayload<T extends FacebookHashTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FacebookHashTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacebookHashTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacebookHashTagGroupByOutputType[P]>
            : GetScalarType<T[P], FacebookHashTagGroupByOutputType[P]>
        }
      >
    >


  export type FacebookHashTagSelect = {
    id?: boolean
    hashTagText?: boolean
    isInPosts?: boolean | FacebookHashTag$isInPostsArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | FacebookHashTagCountOutputTypeArgs
  }


  export type FacebookHashTagInclude = {
    isInPosts?: boolean | FacebookHashTag$isInPostsArgs
    _count?: boolean | FacebookHashTagCountOutputTypeArgs
  }

  export type FacebookHashTagGetPayload<S extends boolean | null | undefined | FacebookHashTagArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FacebookHashTag :
    S extends undefined ? never :
    S extends { include: any } & (FacebookHashTagArgs | FacebookHashTagFindManyArgs)
    ? FacebookHashTag  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'isInPosts' ? Array < PostGetPayload<S['include'][P]>>  :
        P extends '_count' ? FacebookHashTagCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FacebookHashTagArgs | FacebookHashTagFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'isInPosts' ? Array < PostGetPayload<S['select'][P]>>  :
        P extends '_count' ? FacebookHashTagCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof FacebookHashTag ? FacebookHashTag[P] : never
  } 
      : FacebookHashTag


  type FacebookHashTagCountArgs = 
    Omit<FacebookHashTagFindManyArgs, 'select' | 'include'> & {
      select?: FacebookHashTagCountAggregateInputType | true
    }

  export interface FacebookHashTagDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one FacebookHashTag that matches the filter.
     * @param {FacebookHashTagFindUniqueArgs} args - Arguments to find a FacebookHashTag
     * @example
     * // Get one FacebookHashTag
     * const facebookHashTag = await prisma.facebookHashTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FacebookHashTagFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FacebookHashTagFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FacebookHashTag'> extends True ? Prisma__FacebookHashTagClient<FacebookHashTagGetPayload<T>> : Prisma__FacebookHashTagClient<FacebookHashTagGetPayload<T> | null, null>

    /**
     * Find one FacebookHashTag that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FacebookHashTagFindUniqueOrThrowArgs} args - Arguments to find a FacebookHashTag
     * @example
     * // Get one FacebookHashTag
     * const facebookHashTag = await prisma.facebookHashTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FacebookHashTagFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FacebookHashTagFindUniqueOrThrowArgs>
    ): Prisma__FacebookHashTagClient<FacebookHashTagGetPayload<T>>

    /**
     * Find the first FacebookHashTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookHashTagFindFirstArgs} args - Arguments to find a FacebookHashTag
     * @example
     * // Get one FacebookHashTag
     * const facebookHashTag = await prisma.facebookHashTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FacebookHashTagFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FacebookHashTagFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FacebookHashTag'> extends True ? Prisma__FacebookHashTagClient<FacebookHashTagGetPayload<T>> : Prisma__FacebookHashTagClient<FacebookHashTagGetPayload<T> | null, null>

    /**
     * Find the first FacebookHashTag that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookHashTagFindFirstOrThrowArgs} args - Arguments to find a FacebookHashTag
     * @example
     * // Get one FacebookHashTag
     * const facebookHashTag = await prisma.facebookHashTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FacebookHashTagFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FacebookHashTagFindFirstOrThrowArgs>
    ): Prisma__FacebookHashTagClient<FacebookHashTagGetPayload<T>>

    /**
     * Find zero or more FacebookHashTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookHashTagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FacebookHashTags
     * const facebookHashTags = await prisma.facebookHashTag.findMany()
     * 
     * // Get first 10 FacebookHashTags
     * const facebookHashTags = await prisma.facebookHashTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facebookHashTagWithIdOnly = await prisma.facebookHashTag.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FacebookHashTagFindManyArgs>(
      args?: SelectSubset<T, FacebookHashTagFindManyArgs>
    ): Prisma.PrismaPromise<Array<FacebookHashTagGetPayload<T>>>

    /**
     * Create a FacebookHashTag.
     * @param {FacebookHashTagCreateArgs} args - Arguments to create a FacebookHashTag.
     * @example
     * // Create one FacebookHashTag
     * const FacebookHashTag = await prisma.facebookHashTag.create({
     *   data: {
     *     // ... data to create a FacebookHashTag
     *   }
     * })
     * 
    **/
    create<T extends FacebookHashTagCreateArgs>(
      args: SelectSubset<T, FacebookHashTagCreateArgs>
    ): Prisma__FacebookHashTagClient<FacebookHashTagGetPayload<T>>

    /**
     * Create many FacebookHashTags.
     *     @param {FacebookHashTagCreateManyArgs} args - Arguments to create many FacebookHashTags.
     *     @example
     *     // Create many FacebookHashTags
     *     const facebookHashTag = await prisma.facebookHashTag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FacebookHashTagCreateManyArgs>(
      args?: SelectSubset<T, FacebookHashTagCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FacebookHashTag.
     * @param {FacebookHashTagDeleteArgs} args - Arguments to delete one FacebookHashTag.
     * @example
     * // Delete one FacebookHashTag
     * const FacebookHashTag = await prisma.facebookHashTag.delete({
     *   where: {
     *     // ... filter to delete one FacebookHashTag
     *   }
     * })
     * 
    **/
    delete<T extends FacebookHashTagDeleteArgs>(
      args: SelectSubset<T, FacebookHashTagDeleteArgs>
    ): Prisma__FacebookHashTagClient<FacebookHashTagGetPayload<T>>

    /**
     * Update one FacebookHashTag.
     * @param {FacebookHashTagUpdateArgs} args - Arguments to update one FacebookHashTag.
     * @example
     * // Update one FacebookHashTag
     * const facebookHashTag = await prisma.facebookHashTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FacebookHashTagUpdateArgs>(
      args: SelectSubset<T, FacebookHashTagUpdateArgs>
    ): Prisma__FacebookHashTagClient<FacebookHashTagGetPayload<T>>

    /**
     * Delete zero or more FacebookHashTags.
     * @param {FacebookHashTagDeleteManyArgs} args - Arguments to filter FacebookHashTags to delete.
     * @example
     * // Delete a few FacebookHashTags
     * const { count } = await prisma.facebookHashTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FacebookHashTagDeleteManyArgs>(
      args?: SelectSubset<T, FacebookHashTagDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacebookHashTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookHashTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FacebookHashTags
     * const facebookHashTag = await prisma.facebookHashTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FacebookHashTagUpdateManyArgs>(
      args: SelectSubset<T, FacebookHashTagUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FacebookHashTag.
     * @param {FacebookHashTagUpsertArgs} args - Arguments to update or create a FacebookHashTag.
     * @example
     * // Update or create a FacebookHashTag
     * const facebookHashTag = await prisma.facebookHashTag.upsert({
     *   create: {
     *     // ... data to create a FacebookHashTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FacebookHashTag we want to update
     *   }
     * })
    **/
    upsert<T extends FacebookHashTagUpsertArgs>(
      args: SelectSubset<T, FacebookHashTagUpsertArgs>
    ): Prisma__FacebookHashTagClient<FacebookHashTagGetPayload<T>>

    /**
     * Count the number of FacebookHashTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookHashTagCountArgs} args - Arguments to filter FacebookHashTags to count.
     * @example
     * // Count the number of FacebookHashTags
     * const count = await prisma.facebookHashTag.count({
     *   where: {
     *     // ... the filter for the FacebookHashTags we want to count
     *   }
     * })
    **/
    count<T extends FacebookHashTagCountArgs>(
      args?: Subset<T, FacebookHashTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacebookHashTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FacebookHashTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookHashTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacebookHashTagAggregateArgs>(args: Subset<T, FacebookHashTagAggregateArgs>): Prisma.PrismaPromise<GetFacebookHashTagAggregateType<T>>

    /**
     * Group by FacebookHashTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookHashTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacebookHashTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacebookHashTagGroupByArgs['orderBy'] }
        : { orderBy?: FacebookHashTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacebookHashTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacebookHashTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FacebookHashTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FacebookHashTagClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    isInPosts<T extends FacebookHashTag$isInPostsArgs= {}>(args?: Subset<T, FacebookHashTag$isInPostsArgs>): Prisma.PrismaPromise<Array<PostGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FacebookHashTag base type for findUnique actions
   */
  export type FacebookHashTagFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FacebookHashTag
     */
    select?: FacebookHashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookHashTagInclude | null
    /**
     * Filter, which FacebookHashTag to fetch.
     */
    where: FacebookHashTagWhereUniqueInput
  }

  /**
   * FacebookHashTag findUnique
   */
  export interface FacebookHashTagFindUniqueArgs extends FacebookHashTagFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FacebookHashTag findUniqueOrThrow
   */
  export type FacebookHashTagFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FacebookHashTag
     */
    select?: FacebookHashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookHashTagInclude | null
    /**
     * Filter, which FacebookHashTag to fetch.
     */
    where: FacebookHashTagWhereUniqueInput
  }


  /**
   * FacebookHashTag base type for findFirst actions
   */
  export type FacebookHashTagFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FacebookHashTag
     */
    select?: FacebookHashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookHashTagInclude | null
    /**
     * Filter, which FacebookHashTag to fetch.
     */
    where?: FacebookHashTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookHashTags to fetch.
     */
    orderBy?: Enumerable<FacebookHashTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacebookHashTags.
     */
    cursor?: FacebookHashTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookHashTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookHashTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacebookHashTags.
     */
    distinct?: Enumerable<FacebookHashTagScalarFieldEnum>
  }

  /**
   * FacebookHashTag findFirst
   */
  export interface FacebookHashTagFindFirstArgs extends FacebookHashTagFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FacebookHashTag findFirstOrThrow
   */
  export type FacebookHashTagFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FacebookHashTag
     */
    select?: FacebookHashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookHashTagInclude | null
    /**
     * Filter, which FacebookHashTag to fetch.
     */
    where?: FacebookHashTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookHashTags to fetch.
     */
    orderBy?: Enumerable<FacebookHashTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacebookHashTags.
     */
    cursor?: FacebookHashTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookHashTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookHashTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacebookHashTags.
     */
    distinct?: Enumerable<FacebookHashTagScalarFieldEnum>
  }


  /**
   * FacebookHashTag findMany
   */
  export type FacebookHashTagFindManyArgs = {
    /**
     * Select specific fields to fetch from the FacebookHashTag
     */
    select?: FacebookHashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookHashTagInclude | null
    /**
     * Filter, which FacebookHashTags to fetch.
     */
    where?: FacebookHashTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookHashTags to fetch.
     */
    orderBy?: Enumerable<FacebookHashTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FacebookHashTags.
     */
    cursor?: FacebookHashTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookHashTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookHashTags.
     */
    skip?: number
    distinct?: Enumerable<FacebookHashTagScalarFieldEnum>
  }


  /**
   * FacebookHashTag create
   */
  export type FacebookHashTagCreateArgs = {
    /**
     * Select specific fields to fetch from the FacebookHashTag
     */
    select?: FacebookHashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookHashTagInclude | null
    /**
     * The data needed to create a FacebookHashTag.
     */
    data: XOR<FacebookHashTagCreateInput, FacebookHashTagUncheckedCreateInput>
  }


  /**
   * FacebookHashTag createMany
   */
  export type FacebookHashTagCreateManyArgs = {
    /**
     * The data used to create many FacebookHashTags.
     */
    data: Enumerable<FacebookHashTagCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FacebookHashTag update
   */
  export type FacebookHashTagUpdateArgs = {
    /**
     * Select specific fields to fetch from the FacebookHashTag
     */
    select?: FacebookHashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookHashTagInclude | null
    /**
     * The data needed to update a FacebookHashTag.
     */
    data: XOR<FacebookHashTagUpdateInput, FacebookHashTagUncheckedUpdateInput>
    /**
     * Choose, which FacebookHashTag to update.
     */
    where: FacebookHashTagWhereUniqueInput
  }


  /**
   * FacebookHashTag updateMany
   */
  export type FacebookHashTagUpdateManyArgs = {
    /**
     * The data used to update FacebookHashTags.
     */
    data: XOR<FacebookHashTagUpdateManyMutationInput, FacebookHashTagUncheckedUpdateManyInput>
    /**
     * Filter which FacebookHashTags to update
     */
    where?: FacebookHashTagWhereInput
  }


  /**
   * FacebookHashTag upsert
   */
  export type FacebookHashTagUpsertArgs = {
    /**
     * Select specific fields to fetch from the FacebookHashTag
     */
    select?: FacebookHashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookHashTagInclude | null
    /**
     * The filter to search for the FacebookHashTag to update in case it exists.
     */
    where: FacebookHashTagWhereUniqueInput
    /**
     * In case the FacebookHashTag found by the `where` argument doesn't exist, create a new FacebookHashTag with this data.
     */
    create: XOR<FacebookHashTagCreateInput, FacebookHashTagUncheckedCreateInput>
    /**
     * In case the FacebookHashTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacebookHashTagUpdateInput, FacebookHashTagUncheckedUpdateInput>
  }


  /**
   * FacebookHashTag delete
   */
  export type FacebookHashTagDeleteArgs = {
    /**
     * Select specific fields to fetch from the FacebookHashTag
     */
    select?: FacebookHashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookHashTagInclude | null
    /**
     * Filter which FacebookHashTag to delete.
     */
    where: FacebookHashTagWhereUniqueInput
  }


  /**
   * FacebookHashTag deleteMany
   */
  export type FacebookHashTagDeleteManyArgs = {
    /**
     * Filter which FacebookHashTags to delete
     */
    where?: FacebookHashTagWhereInput
  }


  /**
   * FacebookHashTag.isInPosts
   */
  export type FacebookHashTag$isInPostsArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    where?: PostWhereInput
    orderBy?: Enumerable<PostOrderByWithRelationInput>
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PostScalarFieldEnum>
  }


  /**
   * FacebookHashTag without action
   */
  export type FacebookHashTagArgs = {
    /**
     * Select specific fields to fetch from the FacebookHashTag
     */
    select?: FacebookHashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookHashTagInclude | null
  }



  /**
   * Model MessengerMessage
   */


  export type AggregateMessengerMessage = {
    _count: MessengerMessageCountAggregateOutputType | null
    _avg: MessengerMessageAvgAggregateOutputType | null
    _sum: MessengerMessageSumAggregateOutputType | null
    _min: MessengerMessageMinAggregateOutputType | null
    _max: MessengerMessageMaxAggregateOutputType | null
  }

  export type MessengerMessageAvgAggregateOutputType = {
    id: number | null
    fromUserId: number | null
    toUserId: number | null
  }

  export type MessengerMessageSumAggregateOutputType = {
    id: number | null
    fromUserId: number | null
    toUserId: number | null
  }

  export type MessengerMessageMinAggregateOutputType = {
    id: number | null
    messengerText: string | null
    fromUserId: number | null
    toUserId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessengerMessageMaxAggregateOutputType = {
    id: number | null
    messengerText: string | null
    fromUserId: number | null
    toUserId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessengerMessageCountAggregateOutputType = {
    id: number
    messengerText: number
    fromUserId: number
    toUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MessengerMessageAvgAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
  }

  export type MessengerMessageSumAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
  }

  export type MessengerMessageMinAggregateInputType = {
    id?: true
    messengerText?: true
    fromUserId?: true
    toUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessengerMessageMaxAggregateInputType = {
    id?: true
    messengerText?: true
    fromUserId?: true
    toUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessengerMessageCountAggregateInputType = {
    id?: true
    messengerText?: true
    fromUserId?: true
    toUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MessengerMessageAggregateArgs = {
    /**
     * Filter which MessengerMessage to aggregate.
     */
    where?: MessengerMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessengerMessages to fetch.
     */
    orderBy?: Enumerable<MessengerMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessengerMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessengerMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessengerMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessengerMessages
    **/
    _count?: true | MessengerMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessengerMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessengerMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessengerMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessengerMessageMaxAggregateInputType
  }

  export type GetMessengerMessageAggregateType<T extends MessengerMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessengerMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessengerMessage[P]>
      : GetScalarType<T[P], AggregateMessengerMessage[P]>
  }




  export type MessengerMessageGroupByArgs = {
    where?: MessengerMessageWhereInput
    orderBy?: Enumerable<MessengerMessageOrderByWithAggregationInput>
    by: MessengerMessageScalarFieldEnum[]
    having?: MessengerMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessengerMessageCountAggregateInputType | true
    _avg?: MessengerMessageAvgAggregateInputType
    _sum?: MessengerMessageSumAggregateInputType
    _min?: MessengerMessageMinAggregateInputType
    _max?: MessengerMessageMaxAggregateInputType
  }


  export type MessengerMessageGroupByOutputType = {
    id: number
    messengerText: string
    fromUserId: number
    toUserId: number
    createdAt: Date
    updatedAt: Date
    _count: MessengerMessageCountAggregateOutputType | null
    _avg: MessengerMessageAvgAggregateOutputType | null
    _sum: MessengerMessageSumAggregateOutputType | null
    _min: MessengerMessageMinAggregateOutputType | null
    _max: MessengerMessageMaxAggregateOutputType | null
  }

  type GetMessengerMessageGroupByPayload<T extends MessengerMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MessengerMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessengerMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessengerMessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessengerMessageGroupByOutputType[P]>
        }
      >
    >


  export type MessengerMessageSelect = {
    id?: boolean
    messengerText?: boolean
    fromUser?: boolean | FacebookUserArgs
    toUser?: boolean | FacebookUserArgs
    fromUserId?: boolean
    toUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type MessengerMessageInclude = {
    fromUser?: boolean | FacebookUserArgs
    toUser?: boolean | FacebookUserArgs
  }

  export type MessengerMessageGetPayload<S extends boolean | null | undefined | MessengerMessageArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MessengerMessage :
    S extends undefined ? never :
    S extends { include: any } & (MessengerMessageArgs | MessengerMessageFindManyArgs)
    ? MessengerMessage  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'fromUser' ? FacebookUserGetPayload<S['include'][P]> :
        P extends 'toUser' ? FacebookUserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (MessengerMessageArgs | MessengerMessageFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'fromUser' ? FacebookUserGetPayload<S['select'][P]> :
        P extends 'toUser' ? FacebookUserGetPayload<S['select'][P]> :  P extends keyof MessengerMessage ? MessengerMessage[P] : never
  } 
      : MessengerMessage


  type MessengerMessageCountArgs = 
    Omit<MessengerMessageFindManyArgs, 'select' | 'include'> & {
      select?: MessengerMessageCountAggregateInputType | true
    }

  export interface MessengerMessageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one MessengerMessage that matches the filter.
     * @param {MessengerMessageFindUniqueArgs} args - Arguments to find a MessengerMessage
     * @example
     * // Get one MessengerMessage
     * const messengerMessage = await prisma.messengerMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MessengerMessageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MessengerMessageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MessengerMessage'> extends True ? Prisma__MessengerMessageClient<MessengerMessageGetPayload<T>> : Prisma__MessengerMessageClient<MessengerMessageGetPayload<T> | null, null>

    /**
     * Find one MessengerMessage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MessengerMessageFindUniqueOrThrowArgs} args - Arguments to find a MessengerMessage
     * @example
     * // Get one MessengerMessage
     * const messengerMessage = await prisma.messengerMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MessengerMessageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MessengerMessageFindUniqueOrThrowArgs>
    ): Prisma__MessengerMessageClient<MessengerMessageGetPayload<T>>

    /**
     * Find the first MessengerMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessengerMessageFindFirstArgs} args - Arguments to find a MessengerMessage
     * @example
     * // Get one MessengerMessage
     * const messengerMessage = await prisma.messengerMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MessengerMessageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MessengerMessageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MessengerMessage'> extends True ? Prisma__MessengerMessageClient<MessengerMessageGetPayload<T>> : Prisma__MessengerMessageClient<MessengerMessageGetPayload<T> | null, null>

    /**
     * Find the first MessengerMessage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessengerMessageFindFirstOrThrowArgs} args - Arguments to find a MessengerMessage
     * @example
     * // Get one MessengerMessage
     * const messengerMessage = await prisma.messengerMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MessengerMessageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MessengerMessageFindFirstOrThrowArgs>
    ): Prisma__MessengerMessageClient<MessengerMessageGetPayload<T>>

    /**
     * Find zero or more MessengerMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessengerMessageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessengerMessages
     * const messengerMessages = await prisma.messengerMessage.findMany()
     * 
     * // Get first 10 MessengerMessages
     * const messengerMessages = await prisma.messengerMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messengerMessageWithIdOnly = await prisma.messengerMessage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MessengerMessageFindManyArgs>(
      args?: SelectSubset<T, MessengerMessageFindManyArgs>
    ): Prisma.PrismaPromise<Array<MessengerMessageGetPayload<T>>>

    /**
     * Create a MessengerMessage.
     * @param {MessengerMessageCreateArgs} args - Arguments to create a MessengerMessage.
     * @example
     * // Create one MessengerMessage
     * const MessengerMessage = await prisma.messengerMessage.create({
     *   data: {
     *     // ... data to create a MessengerMessage
     *   }
     * })
     * 
    **/
    create<T extends MessengerMessageCreateArgs>(
      args: SelectSubset<T, MessengerMessageCreateArgs>
    ): Prisma__MessengerMessageClient<MessengerMessageGetPayload<T>>

    /**
     * Create many MessengerMessages.
     *     @param {MessengerMessageCreateManyArgs} args - Arguments to create many MessengerMessages.
     *     @example
     *     // Create many MessengerMessages
     *     const messengerMessage = await prisma.messengerMessage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MessengerMessageCreateManyArgs>(
      args?: SelectSubset<T, MessengerMessageCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MessengerMessage.
     * @param {MessengerMessageDeleteArgs} args - Arguments to delete one MessengerMessage.
     * @example
     * // Delete one MessengerMessage
     * const MessengerMessage = await prisma.messengerMessage.delete({
     *   where: {
     *     // ... filter to delete one MessengerMessage
     *   }
     * })
     * 
    **/
    delete<T extends MessengerMessageDeleteArgs>(
      args: SelectSubset<T, MessengerMessageDeleteArgs>
    ): Prisma__MessengerMessageClient<MessengerMessageGetPayload<T>>

    /**
     * Update one MessengerMessage.
     * @param {MessengerMessageUpdateArgs} args - Arguments to update one MessengerMessage.
     * @example
     * // Update one MessengerMessage
     * const messengerMessage = await prisma.messengerMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MessengerMessageUpdateArgs>(
      args: SelectSubset<T, MessengerMessageUpdateArgs>
    ): Prisma__MessengerMessageClient<MessengerMessageGetPayload<T>>

    /**
     * Delete zero or more MessengerMessages.
     * @param {MessengerMessageDeleteManyArgs} args - Arguments to filter MessengerMessages to delete.
     * @example
     * // Delete a few MessengerMessages
     * const { count } = await prisma.messengerMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MessengerMessageDeleteManyArgs>(
      args?: SelectSubset<T, MessengerMessageDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessengerMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessengerMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessengerMessages
     * const messengerMessage = await prisma.messengerMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MessengerMessageUpdateManyArgs>(
      args: SelectSubset<T, MessengerMessageUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MessengerMessage.
     * @param {MessengerMessageUpsertArgs} args - Arguments to update or create a MessengerMessage.
     * @example
     * // Update or create a MessengerMessage
     * const messengerMessage = await prisma.messengerMessage.upsert({
     *   create: {
     *     // ... data to create a MessengerMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessengerMessage we want to update
     *   }
     * })
    **/
    upsert<T extends MessengerMessageUpsertArgs>(
      args: SelectSubset<T, MessengerMessageUpsertArgs>
    ): Prisma__MessengerMessageClient<MessengerMessageGetPayload<T>>

    /**
     * Count the number of MessengerMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessengerMessageCountArgs} args - Arguments to filter MessengerMessages to count.
     * @example
     * // Count the number of MessengerMessages
     * const count = await prisma.messengerMessage.count({
     *   where: {
     *     // ... the filter for the MessengerMessages we want to count
     *   }
     * })
    **/
    count<T extends MessengerMessageCountArgs>(
      args?: Subset<T, MessengerMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessengerMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessengerMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessengerMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessengerMessageAggregateArgs>(args: Subset<T, MessengerMessageAggregateArgs>): Prisma.PrismaPromise<GetMessengerMessageAggregateType<T>>

    /**
     * Group by MessengerMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessengerMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessengerMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessengerMessageGroupByArgs['orderBy'] }
        : { orderBy?: MessengerMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessengerMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessengerMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for MessengerMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MessengerMessageClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    fromUser<T extends FacebookUserArgs= {}>(args?: Subset<T, FacebookUserArgs>): Prisma__FacebookUserClient<FacebookUserGetPayload<T> | Null>;

    toUser<T extends FacebookUserArgs= {}>(args?: Subset<T, FacebookUserArgs>): Prisma__FacebookUserClient<FacebookUserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * MessengerMessage base type for findUnique actions
   */
  export type MessengerMessageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the MessengerMessage
     */
    select?: MessengerMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessengerMessageInclude | null
    /**
     * Filter, which MessengerMessage to fetch.
     */
    where: MessengerMessageWhereUniqueInput
  }

  /**
   * MessengerMessage findUnique
   */
  export interface MessengerMessageFindUniqueArgs extends MessengerMessageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MessengerMessage findUniqueOrThrow
   */
  export type MessengerMessageFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MessengerMessage
     */
    select?: MessengerMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessengerMessageInclude | null
    /**
     * Filter, which MessengerMessage to fetch.
     */
    where: MessengerMessageWhereUniqueInput
  }


  /**
   * MessengerMessage base type for findFirst actions
   */
  export type MessengerMessageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the MessengerMessage
     */
    select?: MessengerMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessengerMessageInclude | null
    /**
     * Filter, which MessengerMessage to fetch.
     */
    where?: MessengerMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessengerMessages to fetch.
     */
    orderBy?: Enumerable<MessengerMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessengerMessages.
     */
    cursor?: MessengerMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessengerMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessengerMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessengerMessages.
     */
    distinct?: Enumerable<MessengerMessageScalarFieldEnum>
  }

  /**
   * MessengerMessage findFirst
   */
  export interface MessengerMessageFindFirstArgs extends MessengerMessageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MessengerMessage findFirstOrThrow
   */
  export type MessengerMessageFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MessengerMessage
     */
    select?: MessengerMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessengerMessageInclude | null
    /**
     * Filter, which MessengerMessage to fetch.
     */
    where?: MessengerMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessengerMessages to fetch.
     */
    orderBy?: Enumerable<MessengerMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessengerMessages.
     */
    cursor?: MessengerMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessengerMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessengerMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessengerMessages.
     */
    distinct?: Enumerable<MessengerMessageScalarFieldEnum>
  }


  /**
   * MessengerMessage findMany
   */
  export type MessengerMessageFindManyArgs = {
    /**
     * Select specific fields to fetch from the MessengerMessage
     */
    select?: MessengerMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessengerMessageInclude | null
    /**
     * Filter, which MessengerMessages to fetch.
     */
    where?: MessengerMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessengerMessages to fetch.
     */
    orderBy?: Enumerable<MessengerMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessengerMessages.
     */
    cursor?: MessengerMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessengerMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessengerMessages.
     */
    skip?: number
    distinct?: Enumerable<MessengerMessageScalarFieldEnum>
  }


  /**
   * MessengerMessage create
   */
  export type MessengerMessageCreateArgs = {
    /**
     * Select specific fields to fetch from the MessengerMessage
     */
    select?: MessengerMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessengerMessageInclude | null
    /**
     * The data needed to create a MessengerMessage.
     */
    data: XOR<MessengerMessageCreateInput, MessengerMessageUncheckedCreateInput>
  }


  /**
   * MessengerMessage createMany
   */
  export type MessengerMessageCreateManyArgs = {
    /**
     * The data used to create many MessengerMessages.
     */
    data: Enumerable<MessengerMessageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * MessengerMessage update
   */
  export type MessengerMessageUpdateArgs = {
    /**
     * Select specific fields to fetch from the MessengerMessage
     */
    select?: MessengerMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessengerMessageInclude | null
    /**
     * The data needed to update a MessengerMessage.
     */
    data: XOR<MessengerMessageUpdateInput, MessengerMessageUncheckedUpdateInput>
    /**
     * Choose, which MessengerMessage to update.
     */
    where: MessengerMessageWhereUniqueInput
  }


  /**
   * MessengerMessage updateMany
   */
  export type MessengerMessageUpdateManyArgs = {
    /**
     * The data used to update MessengerMessages.
     */
    data: XOR<MessengerMessageUpdateManyMutationInput, MessengerMessageUncheckedUpdateManyInput>
    /**
     * Filter which MessengerMessages to update
     */
    where?: MessengerMessageWhereInput
  }


  /**
   * MessengerMessage upsert
   */
  export type MessengerMessageUpsertArgs = {
    /**
     * Select specific fields to fetch from the MessengerMessage
     */
    select?: MessengerMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessengerMessageInclude | null
    /**
     * The filter to search for the MessengerMessage to update in case it exists.
     */
    where: MessengerMessageWhereUniqueInput
    /**
     * In case the MessengerMessage found by the `where` argument doesn't exist, create a new MessengerMessage with this data.
     */
    create: XOR<MessengerMessageCreateInput, MessengerMessageUncheckedCreateInput>
    /**
     * In case the MessengerMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessengerMessageUpdateInput, MessengerMessageUncheckedUpdateInput>
  }


  /**
   * MessengerMessage delete
   */
  export type MessengerMessageDeleteArgs = {
    /**
     * Select specific fields to fetch from the MessengerMessage
     */
    select?: MessengerMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessengerMessageInclude | null
    /**
     * Filter which MessengerMessage to delete.
     */
    where: MessengerMessageWhereUniqueInput
  }


  /**
   * MessengerMessage deleteMany
   */
  export type MessengerMessageDeleteManyArgs = {
    /**
     * Filter which MessengerMessages to delete
     */
    where?: MessengerMessageWhereInput
  }


  /**
   * MessengerMessage without action
   */
  export type MessengerMessageArgs = {
    /**
     * Select specific fields to fetch from the MessengerMessage
     */
    select?: MessengerMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessengerMessageInclude | null
  }



  /**
   * Model Author
   */


  export type AggregateAuthor = {
    _count: AuthorCountAggregateOutputType | null
    _avg: AuthorAvgAggregateOutputType | null
    _sum: AuthorSumAggregateOutputType | null
    _min: AuthorMinAggregateOutputType | null
    _max: AuthorMaxAggregateOutputType | null
  }

  export type AuthorAvgAggregateOutputType = {
    id: number | null
  }

  export type AuthorSumAggregateOutputType = {
    id: number | null
  }

  export type AuthorMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuthorMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuthorCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AuthorAvgAggregateInputType = {
    id?: true
  }

  export type AuthorSumAggregateInputType = {
    id?: true
  }

  export type AuthorMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuthorMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuthorCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AuthorAggregateArgs = {
    /**
     * Filter which Author to aggregate.
     */
    where?: AuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authors to fetch.
     */
    orderBy?: Enumerable<AuthorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Authors
    **/
    _count?: true | AuthorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuthorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuthorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuthorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuthorMaxAggregateInputType
  }

  export type GetAuthorAggregateType<T extends AuthorAggregateArgs> = {
        [P in keyof T & keyof AggregateAuthor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuthor[P]>
      : GetScalarType<T[P], AggregateAuthor[P]>
  }




  export type AuthorGroupByArgs = {
    where?: AuthorWhereInput
    orderBy?: Enumerable<AuthorOrderByWithAggregationInput>
    by: AuthorScalarFieldEnum[]
    having?: AuthorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuthorCountAggregateInputType | true
    _avg?: AuthorAvgAggregateInputType
    _sum?: AuthorSumAggregateInputType
    _min?: AuthorMinAggregateInputType
    _max?: AuthorMaxAggregateInputType
  }


  export type AuthorGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: AuthorCountAggregateOutputType | null
    _avg: AuthorAvgAggregateOutputType | null
    _sum: AuthorSumAggregateOutputType | null
    _min: AuthorMinAggregateOutputType | null
    _max: AuthorMaxAggregateOutputType | null
  }

  type GetAuthorGroupByPayload<T extends AuthorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AuthorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuthorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuthorGroupByOutputType[P]>
            : GetScalarType<T[P], AuthorGroupByOutputType[P]>
        }
      >
    >


  export type AuthorSelect = {
    id?: boolean
    name?: boolean
    bookTitles?: boolean | Author$bookTitlesArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | AuthorCountOutputTypeArgs
  }


  export type AuthorInclude = {
    bookTitles?: boolean | Author$bookTitlesArgs
    _count?: boolean | AuthorCountOutputTypeArgs
  }

  export type AuthorGetPayload<S extends boolean | null | undefined | AuthorArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Author :
    S extends undefined ? never :
    S extends { include: any } & (AuthorArgs | AuthorFindManyArgs)
    ? Author  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'bookTitles' ? Array < BookTitleGetPayload<S['include'][P]>>  :
        P extends '_count' ? AuthorCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (AuthorArgs | AuthorFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'bookTitles' ? Array < BookTitleGetPayload<S['select'][P]>>  :
        P extends '_count' ? AuthorCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Author ? Author[P] : never
  } 
      : Author


  type AuthorCountArgs = 
    Omit<AuthorFindManyArgs, 'select' | 'include'> & {
      select?: AuthorCountAggregateInputType | true
    }

  export interface AuthorDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Author that matches the filter.
     * @param {AuthorFindUniqueArgs} args - Arguments to find a Author
     * @example
     * // Get one Author
     * const author = await prisma.author.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AuthorFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AuthorFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Author'> extends True ? Prisma__AuthorClient<AuthorGetPayload<T>> : Prisma__AuthorClient<AuthorGetPayload<T> | null, null>

    /**
     * Find one Author that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AuthorFindUniqueOrThrowArgs} args - Arguments to find a Author
     * @example
     * // Get one Author
     * const author = await prisma.author.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AuthorFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AuthorFindUniqueOrThrowArgs>
    ): Prisma__AuthorClient<AuthorGetPayload<T>>

    /**
     * Find the first Author that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorFindFirstArgs} args - Arguments to find a Author
     * @example
     * // Get one Author
     * const author = await prisma.author.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AuthorFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AuthorFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Author'> extends True ? Prisma__AuthorClient<AuthorGetPayload<T>> : Prisma__AuthorClient<AuthorGetPayload<T> | null, null>

    /**
     * Find the first Author that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorFindFirstOrThrowArgs} args - Arguments to find a Author
     * @example
     * // Get one Author
     * const author = await prisma.author.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AuthorFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AuthorFindFirstOrThrowArgs>
    ): Prisma__AuthorClient<AuthorGetPayload<T>>

    /**
     * Find zero or more Authors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Authors
     * const authors = await prisma.author.findMany()
     * 
     * // Get first 10 Authors
     * const authors = await prisma.author.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const authorWithIdOnly = await prisma.author.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AuthorFindManyArgs>(
      args?: SelectSubset<T, AuthorFindManyArgs>
    ): Prisma.PrismaPromise<Array<AuthorGetPayload<T>>>

    /**
     * Create a Author.
     * @param {AuthorCreateArgs} args - Arguments to create a Author.
     * @example
     * // Create one Author
     * const Author = await prisma.author.create({
     *   data: {
     *     // ... data to create a Author
     *   }
     * })
     * 
    **/
    create<T extends AuthorCreateArgs>(
      args: SelectSubset<T, AuthorCreateArgs>
    ): Prisma__AuthorClient<AuthorGetPayload<T>>

    /**
     * Create many Authors.
     *     @param {AuthorCreateManyArgs} args - Arguments to create many Authors.
     *     @example
     *     // Create many Authors
     *     const author = await prisma.author.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AuthorCreateManyArgs>(
      args?: SelectSubset<T, AuthorCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Author.
     * @param {AuthorDeleteArgs} args - Arguments to delete one Author.
     * @example
     * // Delete one Author
     * const Author = await prisma.author.delete({
     *   where: {
     *     // ... filter to delete one Author
     *   }
     * })
     * 
    **/
    delete<T extends AuthorDeleteArgs>(
      args: SelectSubset<T, AuthorDeleteArgs>
    ): Prisma__AuthorClient<AuthorGetPayload<T>>

    /**
     * Update one Author.
     * @param {AuthorUpdateArgs} args - Arguments to update one Author.
     * @example
     * // Update one Author
     * const author = await prisma.author.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AuthorUpdateArgs>(
      args: SelectSubset<T, AuthorUpdateArgs>
    ): Prisma__AuthorClient<AuthorGetPayload<T>>

    /**
     * Delete zero or more Authors.
     * @param {AuthorDeleteManyArgs} args - Arguments to filter Authors to delete.
     * @example
     * // Delete a few Authors
     * const { count } = await prisma.author.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AuthorDeleteManyArgs>(
      args?: SelectSubset<T, AuthorDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Authors
     * const author = await prisma.author.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AuthorUpdateManyArgs>(
      args: SelectSubset<T, AuthorUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Author.
     * @param {AuthorUpsertArgs} args - Arguments to update or create a Author.
     * @example
     * // Update or create a Author
     * const author = await prisma.author.upsert({
     *   create: {
     *     // ... data to create a Author
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Author we want to update
     *   }
     * })
    **/
    upsert<T extends AuthorUpsertArgs>(
      args: SelectSubset<T, AuthorUpsertArgs>
    ): Prisma__AuthorClient<AuthorGetPayload<T>>

    /**
     * Count the number of Authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorCountArgs} args - Arguments to filter Authors to count.
     * @example
     * // Count the number of Authors
     * const count = await prisma.author.count({
     *   where: {
     *     // ... the filter for the Authors we want to count
     *   }
     * })
    **/
    count<T extends AuthorCountArgs>(
      args?: Subset<T, AuthorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuthorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Author.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuthorAggregateArgs>(args: Subset<T, AuthorAggregateArgs>): Prisma.PrismaPromise<GetAuthorAggregateType<T>>

    /**
     * Group by Author.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuthorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuthorGroupByArgs['orderBy'] }
        : { orderBy?: AuthorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuthorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Author.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AuthorClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    bookTitles<T extends Author$bookTitlesArgs= {}>(args?: Subset<T, Author$bookTitlesArgs>): Prisma.PrismaPromise<Array<BookTitleGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Author base type for findUnique actions
   */
  export type AuthorFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthorInclude | null
    /**
     * Filter, which Author to fetch.
     */
    where: AuthorWhereUniqueInput
  }

  /**
   * Author findUnique
   */
  export interface AuthorFindUniqueArgs extends AuthorFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Author findUniqueOrThrow
   */
  export type AuthorFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthorInclude | null
    /**
     * Filter, which Author to fetch.
     */
    where: AuthorWhereUniqueInput
  }


  /**
   * Author base type for findFirst actions
   */
  export type AuthorFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthorInclude | null
    /**
     * Filter, which Author to fetch.
     */
    where?: AuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authors to fetch.
     */
    orderBy?: Enumerable<AuthorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Authors.
     */
    cursor?: AuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Authors.
     */
    distinct?: Enumerable<AuthorScalarFieldEnum>
  }

  /**
   * Author findFirst
   */
  export interface AuthorFindFirstArgs extends AuthorFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Author findFirstOrThrow
   */
  export type AuthorFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthorInclude | null
    /**
     * Filter, which Author to fetch.
     */
    where?: AuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authors to fetch.
     */
    orderBy?: Enumerable<AuthorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Authors.
     */
    cursor?: AuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Authors.
     */
    distinct?: Enumerable<AuthorScalarFieldEnum>
  }


  /**
   * Author findMany
   */
  export type AuthorFindManyArgs = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthorInclude | null
    /**
     * Filter, which Authors to fetch.
     */
    where?: AuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authors to fetch.
     */
    orderBy?: Enumerable<AuthorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Authors.
     */
    cursor?: AuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authors.
     */
    skip?: number
    distinct?: Enumerable<AuthorScalarFieldEnum>
  }


  /**
   * Author create
   */
  export type AuthorCreateArgs = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthorInclude | null
    /**
     * The data needed to create a Author.
     */
    data: XOR<AuthorCreateInput, AuthorUncheckedCreateInput>
  }


  /**
   * Author createMany
   */
  export type AuthorCreateManyArgs = {
    /**
     * The data used to create many Authors.
     */
    data: Enumerable<AuthorCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Author update
   */
  export type AuthorUpdateArgs = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthorInclude | null
    /**
     * The data needed to update a Author.
     */
    data: XOR<AuthorUpdateInput, AuthorUncheckedUpdateInput>
    /**
     * Choose, which Author to update.
     */
    where: AuthorWhereUniqueInput
  }


  /**
   * Author updateMany
   */
  export type AuthorUpdateManyArgs = {
    /**
     * The data used to update Authors.
     */
    data: XOR<AuthorUpdateManyMutationInput, AuthorUncheckedUpdateManyInput>
    /**
     * Filter which Authors to update
     */
    where?: AuthorWhereInput
  }


  /**
   * Author upsert
   */
  export type AuthorUpsertArgs = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthorInclude | null
    /**
     * The filter to search for the Author to update in case it exists.
     */
    where: AuthorWhereUniqueInput
    /**
     * In case the Author found by the `where` argument doesn't exist, create a new Author with this data.
     */
    create: XOR<AuthorCreateInput, AuthorUncheckedCreateInput>
    /**
     * In case the Author was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuthorUpdateInput, AuthorUncheckedUpdateInput>
  }


  /**
   * Author delete
   */
  export type AuthorDeleteArgs = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthorInclude | null
    /**
     * Filter which Author to delete.
     */
    where: AuthorWhereUniqueInput
  }


  /**
   * Author deleteMany
   */
  export type AuthorDeleteManyArgs = {
    /**
     * Filter which Authors to delete
     */
    where?: AuthorWhereInput
  }


  /**
   * Author.bookTitles
   */
  export type Author$bookTitlesArgs = {
    /**
     * Select specific fields to fetch from the BookTitle
     */
    select?: BookTitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookTitleInclude | null
    where?: BookTitleWhereInput
    orderBy?: Enumerable<BookTitleOrderByWithRelationInput>
    cursor?: BookTitleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BookTitleScalarFieldEnum>
  }


  /**
   * Author without action
   */
  export type AuthorArgs = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthorInclude | null
  }



  /**
   * Model BookTitle
   */


  export type AggregateBookTitle = {
    _count: BookTitleCountAggregateOutputType | null
    _avg: BookTitleAvgAggregateOutputType | null
    _sum: BookTitleSumAggregateOutputType | null
    _min: BookTitleMinAggregateOutputType | null
    _max: BookTitleMaxAggregateOutputType | null
  }

  export type BookTitleAvgAggregateOutputType = {
    id: number | null
  }

  export type BookTitleSumAggregateOutputType = {
    id: number | null
  }

  export type BookTitleMinAggregateOutputType = {
    id: number | null
    title: string | null
    isbn: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookTitleMaxAggregateOutputType = {
    id: number | null
    title: string | null
    isbn: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookTitleCountAggregateOutputType = {
    id: number
    title: number
    isbn: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BookTitleAvgAggregateInputType = {
    id?: true
  }

  export type BookTitleSumAggregateInputType = {
    id?: true
  }

  export type BookTitleMinAggregateInputType = {
    id?: true
    title?: true
    isbn?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookTitleMaxAggregateInputType = {
    id?: true
    title?: true
    isbn?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookTitleCountAggregateInputType = {
    id?: true
    title?: true
    isbn?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BookTitleAggregateArgs = {
    /**
     * Filter which BookTitle to aggregate.
     */
    where?: BookTitleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookTitles to fetch.
     */
    orderBy?: Enumerable<BookTitleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookTitleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookTitles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookTitles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookTitles
    **/
    _count?: true | BookTitleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookTitleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookTitleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookTitleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookTitleMaxAggregateInputType
  }

  export type GetBookTitleAggregateType<T extends BookTitleAggregateArgs> = {
        [P in keyof T & keyof AggregateBookTitle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookTitle[P]>
      : GetScalarType<T[P], AggregateBookTitle[P]>
  }




  export type BookTitleGroupByArgs = {
    where?: BookTitleWhereInput
    orderBy?: Enumerable<BookTitleOrderByWithAggregationInput>
    by: BookTitleScalarFieldEnum[]
    having?: BookTitleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookTitleCountAggregateInputType | true
    _avg?: BookTitleAvgAggregateInputType
    _sum?: BookTitleSumAggregateInputType
    _min?: BookTitleMinAggregateInputType
    _max?: BookTitleMaxAggregateInputType
  }


  export type BookTitleGroupByOutputType = {
    id: number
    title: string
    isbn: string
    createdAt: Date
    updatedAt: Date
    _count: BookTitleCountAggregateOutputType | null
    _avg: BookTitleAvgAggregateOutputType | null
    _sum: BookTitleSumAggregateOutputType | null
    _min: BookTitleMinAggregateOutputType | null
    _max: BookTitleMaxAggregateOutputType | null
  }

  type GetBookTitleGroupByPayload<T extends BookTitleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BookTitleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookTitleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookTitleGroupByOutputType[P]>
            : GetScalarType<T[P], BookTitleGroupByOutputType[P]>
        }
      >
    >


  export type BookTitleSelect = {
    id?: boolean
    title?: boolean
    isbn?: boolean
    authors?: boolean | BookTitle$authorsArgs
    categories?: boolean | BookTitle$categoriesArgs
    books?: boolean | BookTitle$booksArgs
    requestRecords?: boolean | BookTitle$requestRecordsArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | BookTitleCountOutputTypeArgs
  }


  export type BookTitleInclude = {
    authors?: boolean | BookTitle$authorsArgs
    categories?: boolean | BookTitle$categoriesArgs
    books?: boolean | BookTitle$booksArgs
    requestRecords?: boolean | BookTitle$requestRecordsArgs
    _count?: boolean | BookTitleCountOutputTypeArgs
  }

  export type BookTitleGetPayload<S extends boolean | null | undefined | BookTitleArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BookTitle :
    S extends undefined ? never :
    S extends { include: any } & (BookTitleArgs | BookTitleFindManyArgs)
    ? BookTitle  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'authors' ? Array < AuthorGetPayload<S['include'][P]>>  :
        P extends 'categories' ? Array < BookCategoryGetPayload<S['include'][P]>>  :
        P extends 'books' ? Array < BookGetPayload<S['include'][P]>>  :
        P extends 'requestRecords' ? Array < RequestRecordGetPayload<S['include'][P]>>  :
        P extends '_count' ? BookTitleCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BookTitleArgs | BookTitleFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'authors' ? Array < AuthorGetPayload<S['select'][P]>>  :
        P extends 'categories' ? Array < BookCategoryGetPayload<S['select'][P]>>  :
        P extends 'books' ? Array < BookGetPayload<S['select'][P]>>  :
        P extends 'requestRecords' ? Array < RequestRecordGetPayload<S['select'][P]>>  :
        P extends '_count' ? BookTitleCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof BookTitle ? BookTitle[P] : never
  } 
      : BookTitle


  type BookTitleCountArgs = 
    Omit<BookTitleFindManyArgs, 'select' | 'include'> & {
      select?: BookTitleCountAggregateInputType | true
    }

  export interface BookTitleDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one BookTitle that matches the filter.
     * @param {BookTitleFindUniqueArgs} args - Arguments to find a BookTitle
     * @example
     * // Get one BookTitle
     * const bookTitle = await prisma.bookTitle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BookTitleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BookTitleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BookTitle'> extends True ? Prisma__BookTitleClient<BookTitleGetPayload<T>> : Prisma__BookTitleClient<BookTitleGetPayload<T> | null, null>

    /**
     * Find one BookTitle that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BookTitleFindUniqueOrThrowArgs} args - Arguments to find a BookTitle
     * @example
     * // Get one BookTitle
     * const bookTitle = await prisma.bookTitle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BookTitleFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BookTitleFindUniqueOrThrowArgs>
    ): Prisma__BookTitleClient<BookTitleGetPayload<T>>

    /**
     * Find the first BookTitle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookTitleFindFirstArgs} args - Arguments to find a BookTitle
     * @example
     * // Get one BookTitle
     * const bookTitle = await prisma.bookTitle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BookTitleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BookTitleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BookTitle'> extends True ? Prisma__BookTitleClient<BookTitleGetPayload<T>> : Prisma__BookTitleClient<BookTitleGetPayload<T> | null, null>

    /**
     * Find the first BookTitle that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookTitleFindFirstOrThrowArgs} args - Arguments to find a BookTitle
     * @example
     * // Get one BookTitle
     * const bookTitle = await prisma.bookTitle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BookTitleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BookTitleFindFirstOrThrowArgs>
    ): Prisma__BookTitleClient<BookTitleGetPayload<T>>

    /**
     * Find zero or more BookTitles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookTitleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookTitles
     * const bookTitles = await prisma.bookTitle.findMany()
     * 
     * // Get first 10 BookTitles
     * const bookTitles = await prisma.bookTitle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookTitleWithIdOnly = await prisma.bookTitle.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BookTitleFindManyArgs>(
      args?: SelectSubset<T, BookTitleFindManyArgs>
    ): Prisma.PrismaPromise<Array<BookTitleGetPayload<T>>>

    /**
     * Create a BookTitle.
     * @param {BookTitleCreateArgs} args - Arguments to create a BookTitle.
     * @example
     * // Create one BookTitle
     * const BookTitle = await prisma.bookTitle.create({
     *   data: {
     *     // ... data to create a BookTitle
     *   }
     * })
     * 
    **/
    create<T extends BookTitleCreateArgs>(
      args: SelectSubset<T, BookTitleCreateArgs>
    ): Prisma__BookTitleClient<BookTitleGetPayload<T>>

    /**
     * Create many BookTitles.
     *     @param {BookTitleCreateManyArgs} args - Arguments to create many BookTitles.
     *     @example
     *     // Create many BookTitles
     *     const bookTitle = await prisma.bookTitle.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BookTitleCreateManyArgs>(
      args?: SelectSubset<T, BookTitleCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BookTitle.
     * @param {BookTitleDeleteArgs} args - Arguments to delete one BookTitle.
     * @example
     * // Delete one BookTitle
     * const BookTitle = await prisma.bookTitle.delete({
     *   where: {
     *     // ... filter to delete one BookTitle
     *   }
     * })
     * 
    **/
    delete<T extends BookTitleDeleteArgs>(
      args: SelectSubset<T, BookTitleDeleteArgs>
    ): Prisma__BookTitleClient<BookTitleGetPayload<T>>

    /**
     * Update one BookTitle.
     * @param {BookTitleUpdateArgs} args - Arguments to update one BookTitle.
     * @example
     * // Update one BookTitle
     * const bookTitle = await prisma.bookTitle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BookTitleUpdateArgs>(
      args: SelectSubset<T, BookTitleUpdateArgs>
    ): Prisma__BookTitleClient<BookTitleGetPayload<T>>

    /**
     * Delete zero or more BookTitles.
     * @param {BookTitleDeleteManyArgs} args - Arguments to filter BookTitles to delete.
     * @example
     * // Delete a few BookTitles
     * const { count } = await prisma.bookTitle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BookTitleDeleteManyArgs>(
      args?: SelectSubset<T, BookTitleDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookTitles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookTitleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookTitles
     * const bookTitle = await prisma.bookTitle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BookTitleUpdateManyArgs>(
      args: SelectSubset<T, BookTitleUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BookTitle.
     * @param {BookTitleUpsertArgs} args - Arguments to update or create a BookTitle.
     * @example
     * // Update or create a BookTitle
     * const bookTitle = await prisma.bookTitle.upsert({
     *   create: {
     *     // ... data to create a BookTitle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookTitle we want to update
     *   }
     * })
    **/
    upsert<T extends BookTitleUpsertArgs>(
      args: SelectSubset<T, BookTitleUpsertArgs>
    ): Prisma__BookTitleClient<BookTitleGetPayload<T>>

    /**
     * Count the number of BookTitles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookTitleCountArgs} args - Arguments to filter BookTitles to count.
     * @example
     * // Count the number of BookTitles
     * const count = await prisma.bookTitle.count({
     *   where: {
     *     // ... the filter for the BookTitles we want to count
     *   }
     * })
    **/
    count<T extends BookTitleCountArgs>(
      args?: Subset<T, BookTitleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookTitleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookTitle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookTitleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookTitleAggregateArgs>(args: Subset<T, BookTitleAggregateArgs>): Prisma.PrismaPromise<GetBookTitleAggregateType<T>>

    /**
     * Group by BookTitle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookTitleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookTitleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookTitleGroupByArgs['orderBy'] }
        : { orderBy?: BookTitleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookTitleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookTitleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BookTitle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BookTitleClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    authors<T extends BookTitle$authorsArgs= {}>(args?: Subset<T, BookTitle$authorsArgs>): Prisma.PrismaPromise<Array<AuthorGetPayload<T>>| Null>;

    categories<T extends BookTitle$categoriesArgs= {}>(args?: Subset<T, BookTitle$categoriesArgs>): Prisma.PrismaPromise<Array<BookCategoryGetPayload<T>>| Null>;

    books<T extends BookTitle$booksArgs= {}>(args?: Subset<T, BookTitle$booksArgs>): Prisma.PrismaPromise<Array<BookGetPayload<T>>| Null>;

    requestRecords<T extends BookTitle$requestRecordsArgs= {}>(args?: Subset<T, BookTitle$requestRecordsArgs>): Prisma.PrismaPromise<Array<RequestRecordGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BookTitle base type for findUnique actions
   */
  export type BookTitleFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BookTitle
     */
    select?: BookTitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookTitleInclude | null
    /**
     * Filter, which BookTitle to fetch.
     */
    where: BookTitleWhereUniqueInput
  }

  /**
   * BookTitle findUnique
   */
  export interface BookTitleFindUniqueArgs extends BookTitleFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BookTitle findUniqueOrThrow
   */
  export type BookTitleFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BookTitle
     */
    select?: BookTitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookTitleInclude | null
    /**
     * Filter, which BookTitle to fetch.
     */
    where: BookTitleWhereUniqueInput
  }


  /**
   * BookTitle base type for findFirst actions
   */
  export type BookTitleFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BookTitle
     */
    select?: BookTitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookTitleInclude | null
    /**
     * Filter, which BookTitle to fetch.
     */
    where?: BookTitleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookTitles to fetch.
     */
    orderBy?: Enumerable<BookTitleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookTitles.
     */
    cursor?: BookTitleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookTitles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookTitles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookTitles.
     */
    distinct?: Enumerable<BookTitleScalarFieldEnum>
  }

  /**
   * BookTitle findFirst
   */
  export interface BookTitleFindFirstArgs extends BookTitleFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BookTitle findFirstOrThrow
   */
  export type BookTitleFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BookTitle
     */
    select?: BookTitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookTitleInclude | null
    /**
     * Filter, which BookTitle to fetch.
     */
    where?: BookTitleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookTitles to fetch.
     */
    orderBy?: Enumerable<BookTitleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookTitles.
     */
    cursor?: BookTitleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookTitles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookTitles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookTitles.
     */
    distinct?: Enumerable<BookTitleScalarFieldEnum>
  }


  /**
   * BookTitle findMany
   */
  export type BookTitleFindManyArgs = {
    /**
     * Select specific fields to fetch from the BookTitle
     */
    select?: BookTitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookTitleInclude | null
    /**
     * Filter, which BookTitles to fetch.
     */
    where?: BookTitleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookTitles to fetch.
     */
    orderBy?: Enumerable<BookTitleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookTitles.
     */
    cursor?: BookTitleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookTitles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookTitles.
     */
    skip?: number
    distinct?: Enumerable<BookTitleScalarFieldEnum>
  }


  /**
   * BookTitle create
   */
  export type BookTitleCreateArgs = {
    /**
     * Select specific fields to fetch from the BookTitle
     */
    select?: BookTitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookTitleInclude | null
    /**
     * The data needed to create a BookTitle.
     */
    data: XOR<BookTitleCreateInput, BookTitleUncheckedCreateInput>
  }


  /**
   * BookTitle createMany
   */
  export type BookTitleCreateManyArgs = {
    /**
     * The data used to create many BookTitles.
     */
    data: Enumerable<BookTitleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BookTitle update
   */
  export type BookTitleUpdateArgs = {
    /**
     * Select specific fields to fetch from the BookTitle
     */
    select?: BookTitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookTitleInclude | null
    /**
     * The data needed to update a BookTitle.
     */
    data: XOR<BookTitleUpdateInput, BookTitleUncheckedUpdateInput>
    /**
     * Choose, which BookTitle to update.
     */
    where: BookTitleWhereUniqueInput
  }


  /**
   * BookTitle updateMany
   */
  export type BookTitleUpdateManyArgs = {
    /**
     * The data used to update BookTitles.
     */
    data: XOR<BookTitleUpdateManyMutationInput, BookTitleUncheckedUpdateManyInput>
    /**
     * Filter which BookTitles to update
     */
    where?: BookTitleWhereInput
  }


  /**
   * BookTitle upsert
   */
  export type BookTitleUpsertArgs = {
    /**
     * Select specific fields to fetch from the BookTitle
     */
    select?: BookTitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookTitleInclude | null
    /**
     * The filter to search for the BookTitle to update in case it exists.
     */
    where: BookTitleWhereUniqueInput
    /**
     * In case the BookTitle found by the `where` argument doesn't exist, create a new BookTitle with this data.
     */
    create: XOR<BookTitleCreateInput, BookTitleUncheckedCreateInput>
    /**
     * In case the BookTitle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookTitleUpdateInput, BookTitleUncheckedUpdateInput>
  }


  /**
   * BookTitle delete
   */
  export type BookTitleDeleteArgs = {
    /**
     * Select specific fields to fetch from the BookTitle
     */
    select?: BookTitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookTitleInclude | null
    /**
     * Filter which BookTitle to delete.
     */
    where: BookTitleWhereUniqueInput
  }


  /**
   * BookTitle deleteMany
   */
  export type BookTitleDeleteManyArgs = {
    /**
     * Filter which BookTitles to delete
     */
    where?: BookTitleWhereInput
  }


  /**
   * BookTitle.authors
   */
  export type BookTitle$authorsArgs = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthorInclude | null
    where?: AuthorWhereInput
    orderBy?: Enumerable<AuthorOrderByWithRelationInput>
    cursor?: AuthorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AuthorScalarFieldEnum>
  }


  /**
   * BookTitle.categories
   */
  export type BookTitle$categoriesArgs = {
    /**
     * Select specific fields to fetch from the BookCategory
     */
    select?: BookCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookCategoryInclude | null
    where?: BookCategoryWhereInput
    orderBy?: Enumerable<BookCategoryOrderByWithRelationInput>
    cursor?: BookCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BookCategoryScalarFieldEnum>
  }


  /**
   * BookTitle.books
   */
  export type BookTitle$booksArgs = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookInclude | null
    where?: BookWhereInput
    orderBy?: Enumerable<BookOrderByWithRelationInput>
    cursor?: BookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BookScalarFieldEnum>
  }


  /**
   * BookTitle.requestRecords
   */
  export type BookTitle$requestRecordsArgs = {
    /**
     * Select specific fields to fetch from the RequestRecord
     */
    select?: RequestRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestRecordInclude | null
    where?: RequestRecordWhereInput
    orderBy?: Enumerable<RequestRecordOrderByWithRelationInput>
    cursor?: RequestRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RequestRecordScalarFieldEnum>
  }


  /**
   * BookTitle without action
   */
  export type BookTitleArgs = {
    /**
     * Select specific fields to fetch from the BookTitle
     */
    select?: BookTitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookTitleInclude | null
  }



  /**
   * Model BookCategory
   */


  export type AggregateBookCategory = {
    _count: BookCategoryCountAggregateOutputType | null
    _avg: BookCategoryAvgAggregateOutputType | null
    _sum: BookCategorySumAggregateOutputType | null
    _min: BookCategoryMinAggregateOutputType | null
    _max: BookCategoryMaxAggregateOutputType | null
  }

  export type BookCategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type BookCategorySumAggregateOutputType = {
    id: number | null
  }

  export type BookCategoryMinAggregateOutputType = {
    id: number | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookCategoryMaxAggregateOutputType = {
    id: number | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookCategoryCountAggregateOutputType = {
    id: number
    category: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BookCategoryAvgAggregateInputType = {
    id?: true
  }

  export type BookCategorySumAggregateInputType = {
    id?: true
  }

  export type BookCategoryMinAggregateInputType = {
    id?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookCategoryMaxAggregateInputType = {
    id?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookCategoryCountAggregateInputType = {
    id?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BookCategoryAggregateArgs = {
    /**
     * Filter which BookCategory to aggregate.
     */
    where?: BookCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookCategories to fetch.
     */
    orderBy?: Enumerable<BookCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookCategories
    **/
    _count?: true | BookCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookCategoryMaxAggregateInputType
  }

  export type GetBookCategoryAggregateType<T extends BookCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateBookCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookCategory[P]>
      : GetScalarType<T[P], AggregateBookCategory[P]>
  }




  export type BookCategoryGroupByArgs = {
    where?: BookCategoryWhereInput
    orderBy?: Enumerable<BookCategoryOrderByWithAggregationInput>
    by: BookCategoryScalarFieldEnum[]
    having?: BookCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookCategoryCountAggregateInputType | true
    _avg?: BookCategoryAvgAggregateInputType
    _sum?: BookCategorySumAggregateInputType
    _min?: BookCategoryMinAggregateInputType
    _max?: BookCategoryMaxAggregateInputType
  }


  export type BookCategoryGroupByOutputType = {
    id: number
    category: string
    createdAt: Date
    updatedAt: Date
    _count: BookCategoryCountAggregateOutputType | null
    _avg: BookCategoryAvgAggregateOutputType | null
    _sum: BookCategorySumAggregateOutputType | null
    _min: BookCategoryMinAggregateOutputType | null
    _max: BookCategoryMaxAggregateOutputType | null
  }

  type GetBookCategoryGroupByPayload<T extends BookCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BookCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], BookCategoryGroupByOutputType[P]>
        }
      >
    >


  export type BookCategorySelect = {
    id?: boolean
    category?: boolean
    bookTitles?: boolean | BookCategory$bookTitlesArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | BookCategoryCountOutputTypeArgs
  }


  export type BookCategoryInclude = {
    bookTitles?: boolean | BookCategory$bookTitlesArgs
    _count?: boolean | BookCategoryCountOutputTypeArgs
  }

  export type BookCategoryGetPayload<S extends boolean | null | undefined | BookCategoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BookCategory :
    S extends undefined ? never :
    S extends { include: any } & (BookCategoryArgs | BookCategoryFindManyArgs)
    ? BookCategory  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'bookTitles' ? Array < BookTitleGetPayload<S['include'][P]>>  :
        P extends '_count' ? BookCategoryCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BookCategoryArgs | BookCategoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'bookTitles' ? Array < BookTitleGetPayload<S['select'][P]>>  :
        P extends '_count' ? BookCategoryCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof BookCategory ? BookCategory[P] : never
  } 
      : BookCategory


  type BookCategoryCountArgs = 
    Omit<BookCategoryFindManyArgs, 'select' | 'include'> & {
      select?: BookCategoryCountAggregateInputType | true
    }

  export interface BookCategoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one BookCategory that matches the filter.
     * @param {BookCategoryFindUniqueArgs} args - Arguments to find a BookCategory
     * @example
     * // Get one BookCategory
     * const bookCategory = await prisma.bookCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BookCategoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BookCategoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BookCategory'> extends True ? Prisma__BookCategoryClient<BookCategoryGetPayload<T>> : Prisma__BookCategoryClient<BookCategoryGetPayload<T> | null, null>

    /**
     * Find one BookCategory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BookCategoryFindUniqueOrThrowArgs} args - Arguments to find a BookCategory
     * @example
     * // Get one BookCategory
     * const bookCategory = await prisma.bookCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BookCategoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BookCategoryFindUniqueOrThrowArgs>
    ): Prisma__BookCategoryClient<BookCategoryGetPayload<T>>

    /**
     * Find the first BookCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookCategoryFindFirstArgs} args - Arguments to find a BookCategory
     * @example
     * // Get one BookCategory
     * const bookCategory = await prisma.bookCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BookCategoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BookCategoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BookCategory'> extends True ? Prisma__BookCategoryClient<BookCategoryGetPayload<T>> : Prisma__BookCategoryClient<BookCategoryGetPayload<T> | null, null>

    /**
     * Find the first BookCategory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookCategoryFindFirstOrThrowArgs} args - Arguments to find a BookCategory
     * @example
     * // Get one BookCategory
     * const bookCategory = await prisma.bookCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BookCategoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BookCategoryFindFirstOrThrowArgs>
    ): Prisma__BookCategoryClient<BookCategoryGetPayload<T>>

    /**
     * Find zero or more BookCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookCategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookCategories
     * const bookCategories = await prisma.bookCategory.findMany()
     * 
     * // Get first 10 BookCategories
     * const bookCategories = await prisma.bookCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookCategoryWithIdOnly = await prisma.bookCategory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BookCategoryFindManyArgs>(
      args?: SelectSubset<T, BookCategoryFindManyArgs>
    ): Prisma.PrismaPromise<Array<BookCategoryGetPayload<T>>>

    /**
     * Create a BookCategory.
     * @param {BookCategoryCreateArgs} args - Arguments to create a BookCategory.
     * @example
     * // Create one BookCategory
     * const BookCategory = await prisma.bookCategory.create({
     *   data: {
     *     // ... data to create a BookCategory
     *   }
     * })
     * 
    **/
    create<T extends BookCategoryCreateArgs>(
      args: SelectSubset<T, BookCategoryCreateArgs>
    ): Prisma__BookCategoryClient<BookCategoryGetPayload<T>>

    /**
     * Create many BookCategories.
     *     @param {BookCategoryCreateManyArgs} args - Arguments to create many BookCategories.
     *     @example
     *     // Create many BookCategories
     *     const bookCategory = await prisma.bookCategory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BookCategoryCreateManyArgs>(
      args?: SelectSubset<T, BookCategoryCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BookCategory.
     * @param {BookCategoryDeleteArgs} args - Arguments to delete one BookCategory.
     * @example
     * // Delete one BookCategory
     * const BookCategory = await prisma.bookCategory.delete({
     *   where: {
     *     // ... filter to delete one BookCategory
     *   }
     * })
     * 
    **/
    delete<T extends BookCategoryDeleteArgs>(
      args: SelectSubset<T, BookCategoryDeleteArgs>
    ): Prisma__BookCategoryClient<BookCategoryGetPayload<T>>

    /**
     * Update one BookCategory.
     * @param {BookCategoryUpdateArgs} args - Arguments to update one BookCategory.
     * @example
     * // Update one BookCategory
     * const bookCategory = await prisma.bookCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BookCategoryUpdateArgs>(
      args: SelectSubset<T, BookCategoryUpdateArgs>
    ): Prisma__BookCategoryClient<BookCategoryGetPayload<T>>

    /**
     * Delete zero or more BookCategories.
     * @param {BookCategoryDeleteManyArgs} args - Arguments to filter BookCategories to delete.
     * @example
     * // Delete a few BookCategories
     * const { count } = await prisma.bookCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BookCategoryDeleteManyArgs>(
      args?: SelectSubset<T, BookCategoryDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookCategories
     * const bookCategory = await prisma.bookCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BookCategoryUpdateManyArgs>(
      args: SelectSubset<T, BookCategoryUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BookCategory.
     * @param {BookCategoryUpsertArgs} args - Arguments to update or create a BookCategory.
     * @example
     * // Update or create a BookCategory
     * const bookCategory = await prisma.bookCategory.upsert({
     *   create: {
     *     // ... data to create a BookCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookCategory we want to update
     *   }
     * })
    **/
    upsert<T extends BookCategoryUpsertArgs>(
      args: SelectSubset<T, BookCategoryUpsertArgs>
    ): Prisma__BookCategoryClient<BookCategoryGetPayload<T>>

    /**
     * Count the number of BookCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookCategoryCountArgs} args - Arguments to filter BookCategories to count.
     * @example
     * // Count the number of BookCategories
     * const count = await prisma.bookCategory.count({
     *   where: {
     *     // ... the filter for the BookCategories we want to count
     *   }
     * })
    **/
    count<T extends BookCategoryCountArgs>(
      args?: Subset<T, BookCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookCategoryAggregateArgs>(args: Subset<T, BookCategoryAggregateArgs>): Prisma.PrismaPromise<GetBookCategoryAggregateType<T>>

    /**
     * Group by BookCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookCategoryGroupByArgs['orderBy'] }
        : { orderBy?: BookCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BookCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BookCategoryClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    bookTitles<T extends BookCategory$bookTitlesArgs= {}>(args?: Subset<T, BookCategory$bookTitlesArgs>): Prisma.PrismaPromise<Array<BookTitleGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BookCategory base type for findUnique actions
   */
  export type BookCategoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BookCategory
     */
    select?: BookCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookCategoryInclude | null
    /**
     * Filter, which BookCategory to fetch.
     */
    where: BookCategoryWhereUniqueInput
  }

  /**
   * BookCategory findUnique
   */
  export interface BookCategoryFindUniqueArgs extends BookCategoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BookCategory findUniqueOrThrow
   */
  export type BookCategoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BookCategory
     */
    select?: BookCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookCategoryInclude | null
    /**
     * Filter, which BookCategory to fetch.
     */
    where: BookCategoryWhereUniqueInput
  }


  /**
   * BookCategory base type for findFirst actions
   */
  export type BookCategoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BookCategory
     */
    select?: BookCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookCategoryInclude | null
    /**
     * Filter, which BookCategory to fetch.
     */
    where?: BookCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookCategories to fetch.
     */
    orderBy?: Enumerable<BookCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookCategories.
     */
    cursor?: BookCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookCategories.
     */
    distinct?: Enumerable<BookCategoryScalarFieldEnum>
  }

  /**
   * BookCategory findFirst
   */
  export interface BookCategoryFindFirstArgs extends BookCategoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BookCategory findFirstOrThrow
   */
  export type BookCategoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BookCategory
     */
    select?: BookCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookCategoryInclude | null
    /**
     * Filter, which BookCategory to fetch.
     */
    where?: BookCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookCategories to fetch.
     */
    orderBy?: Enumerable<BookCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookCategories.
     */
    cursor?: BookCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookCategories.
     */
    distinct?: Enumerable<BookCategoryScalarFieldEnum>
  }


  /**
   * BookCategory findMany
   */
  export type BookCategoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the BookCategory
     */
    select?: BookCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookCategoryInclude | null
    /**
     * Filter, which BookCategories to fetch.
     */
    where?: BookCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookCategories to fetch.
     */
    orderBy?: Enumerable<BookCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookCategories.
     */
    cursor?: BookCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookCategories.
     */
    skip?: number
    distinct?: Enumerable<BookCategoryScalarFieldEnum>
  }


  /**
   * BookCategory create
   */
  export type BookCategoryCreateArgs = {
    /**
     * Select specific fields to fetch from the BookCategory
     */
    select?: BookCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookCategoryInclude | null
    /**
     * The data needed to create a BookCategory.
     */
    data: XOR<BookCategoryCreateInput, BookCategoryUncheckedCreateInput>
  }


  /**
   * BookCategory createMany
   */
  export type BookCategoryCreateManyArgs = {
    /**
     * The data used to create many BookCategories.
     */
    data: Enumerable<BookCategoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BookCategory update
   */
  export type BookCategoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the BookCategory
     */
    select?: BookCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookCategoryInclude | null
    /**
     * The data needed to update a BookCategory.
     */
    data: XOR<BookCategoryUpdateInput, BookCategoryUncheckedUpdateInput>
    /**
     * Choose, which BookCategory to update.
     */
    where: BookCategoryWhereUniqueInput
  }


  /**
   * BookCategory updateMany
   */
  export type BookCategoryUpdateManyArgs = {
    /**
     * The data used to update BookCategories.
     */
    data: XOR<BookCategoryUpdateManyMutationInput, BookCategoryUncheckedUpdateManyInput>
    /**
     * Filter which BookCategories to update
     */
    where?: BookCategoryWhereInput
  }


  /**
   * BookCategory upsert
   */
  export type BookCategoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the BookCategory
     */
    select?: BookCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookCategoryInclude | null
    /**
     * The filter to search for the BookCategory to update in case it exists.
     */
    where: BookCategoryWhereUniqueInput
    /**
     * In case the BookCategory found by the `where` argument doesn't exist, create a new BookCategory with this data.
     */
    create: XOR<BookCategoryCreateInput, BookCategoryUncheckedCreateInput>
    /**
     * In case the BookCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookCategoryUpdateInput, BookCategoryUncheckedUpdateInput>
  }


  /**
   * BookCategory delete
   */
  export type BookCategoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the BookCategory
     */
    select?: BookCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookCategoryInclude | null
    /**
     * Filter which BookCategory to delete.
     */
    where: BookCategoryWhereUniqueInput
  }


  /**
   * BookCategory deleteMany
   */
  export type BookCategoryDeleteManyArgs = {
    /**
     * Filter which BookCategories to delete
     */
    where?: BookCategoryWhereInput
  }


  /**
   * BookCategory.bookTitles
   */
  export type BookCategory$bookTitlesArgs = {
    /**
     * Select specific fields to fetch from the BookTitle
     */
    select?: BookTitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookTitleInclude | null
    where?: BookTitleWhereInput
    orderBy?: Enumerable<BookTitleOrderByWithRelationInput>
    cursor?: BookTitleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BookTitleScalarFieldEnum>
  }


  /**
   * BookCategory without action
   */
  export type BookCategoryArgs = {
    /**
     * Select specific fields to fetch from the BookCategory
     */
    select?: BookCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookCategoryInclude | null
  }



  /**
   * Model Book
   */


  export type AggregateBook = {
    _count: BookCountAggregateOutputType | null
    _avg: BookAvgAggregateOutputType | null
    _sum: BookSumAggregateOutputType | null
    _min: BookMinAggregateOutputType | null
    _max: BookMaxAggregateOutputType | null
  }

  export type BookAvgAggregateOutputType = {
    id: number | null
    bookTitleId: number | null
    libraryId: number | null
  }

  export type BookSumAggregateOutputType = {
    id: number | null
    bookTitleId: number | null
    libraryId: number | null
  }

  export type BookMinAggregateOutputType = {
    id: number | null
    bookTitleId: number | null
    libraryId: number | null
    isAvailable: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookMaxAggregateOutputType = {
    id: number | null
    bookTitleId: number | null
    libraryId: number | null
    isAvailable: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookCountAggregateOutputType = {
    id: number
    bookTitleId: number
    libraryId: number
    isAvailable: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BookAvgAggregateInputType = {
    id?: true
    bookTitleId?: true
    libraryId?: true
  }

  export type BookSumAggregateInputType = {
    id?: true
    bookTitleId?: true
    libraryId?: true
  }

  export type BookMinAggregateInputType = {
    id?: true
    bookTitleId?: true
    libraryId?: true
    isAvailable?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookMaxAggregateInputType = {
    id?: true
    bookTitleId?: true
    libraryId?: true
    isAvailable?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookCountAggregateInputType = {
    id?: true
    bookTitleId?: true
    libraryId?: true
    isAvailable?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BookAggregateArgs = {
    /**
     * Filter which Book to aggregate.
     */
    where?: BookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Books to fetch.
     */
    orderBy?: Enumerable<BookOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Books.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Books
    **/
    _count?: true | BookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookMaxAggregateInputType
  }

  export type GetBookAggregateType<T extends BookAggregateArgs> = {
        [P in keyof T & keyof AggregateBook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBook[P]>
      : GetScalarType<T[P], AggregateBook[P]>
  }




  export type BookGroupByArgs = {
    where?: BookWhereInput
    orderBy?: Enumerable<BookOrderByWithAggregationInput>
    by: BookScalarFieldEnum[]
    having?: BookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookCountAggregateInputType | true
    _avg?: BookAvgAggregateInputType
    _sum?: BookSumAggregateInputType
    _min?: BookMinAggregateInputType
    _max?: BookMaxAggregateInputType
  }


  export type BookGroupByOutputType = {
    id: number
    bookTitleId: number
    libraryId: number
    isAvailable: boolean
    createdAt: Date
    updatedAt: Date
    _count: BookCountAggregateOutputType | null
    _avg: BookAvgAggregateOutputType | null
    _sum: BookSumAggregateOutputType | null
    _min: BookMinAggregateOutputType | null
    _max: BookMaxAggregateOutputType | null
  }

  type GetBookGroupByPayload<T extends BookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookGroupByOutputType[P]>
            : GetScalarType<T[P], BookGroupByOutputType[P]>
        }
      >
    >


  export type BookSelect = {
    id?: boolean
    title?: boolean | BookTitleArgs
    bookTitleId?: boolean
    belongsToLibrary?: boolean | LibraryArgs
    libraryId?: boolean
    isAvailable?: boolean
    borrowingRecords?: boolean | Book$borrowingRecordsArgs
    requestRecords?: boolean | Book$requestRecordsArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | BookCountOutputTypeArgs
  }


  export type BookInclude = {
    title?: boolean | BookTitleArgs
    belongsToLibrary?: boolean | LibraryArgs
    borrowingRecords?: boolean | Book$borrowingRecordsArgs
    requestRecords?: boolean | Book$requestRecordsArgs
    _count?: boolean | BookCountOutputTypeArgs
  }

  export type BookGetPayload<S extends boolean | null | undefined | BookArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Book :
    S extends undefined ? never :
    S extends { include: any } & (BookArgs | BookFindManyArgs)
    ? Book  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'title' ? BookTitleGetPayload<S['include'][P]> :
        P extends 'belongsToLibrary' ? LibraryGetPayload<S['include'][P]> :
        P extends 'borrowingRecords' ? Array < BorrowingRecordGetPayload<S['include'][P]>>  :
        P extends 'requestRecords' ? Array < RequestRecordGetPayload<S['include'][P]>>  :
        P extends '_count' ? BookCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BookArgs | BookFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'title' ? BookTitleGetPayload<S['select'][P]> :
        P extends 'belongsToLibrary' ? LibraryGetPayload<S['select'][P]> :
        P extends 'borrowingRecords' ? Array < BorrowingRecordGetPayload<S['select'][P]>>  :
        P extends 'requestRecords' ? Array < RequestRecordGetPayload<S['select'][P]>>  :
        P extends '_count' ? BookCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Book ? Book[P] : never
  } 
      : Book


  type BookCountArgs = 
    Omit<BookFindManyArgs, 'select' | 'include'> & {
      select?: BookCountAggregateInputType | true
    }

  export interface BookDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Book that matches the filter.
     * @param {BookFindUniqueArgs} args - Arguments to find a Book
     * @example
     * // Get one Book
     * const book = await prisma.book.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BookFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BookFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Book'> extends True ? Prisma__BookClient<BookGetPayload<T>> : Prisma__BookClient<BookGetPayload<T> | null, null>

    /**
     * Find one Book that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BookFindUniqueOrThrowArgs} args - Arguments to find a Book
     * @example
     * // Get one Book
     * const book = await prisma.book.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BookFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BookFindUniqueOrThrowArgs>
    ): Prisma__BookClient<BookGetPayload<T>>

    /**
     * Find the first Book that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookFindFirstArgs} args - Arguments to find a Book
     * @example
     * // Get one Book
     * const book = await prisma.book.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BookFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BookFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Book'> extends True ? Prisma__BookClient<BookGetPayload<T>> : Prisma__BookClient<BookGetPayload<T> | null, null>

    /**
     * Find the first Book that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookFindFirstOrThrowArgs} args - Arguments to find a Book
     * @example
     * // Get one Book
     * const book = await prisma.book.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BookFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BookFindFirstOrThrowArgs>
    ): Prisma__BookClient<BookGetPayload<T>>

    /**
     * Find zero or more Books that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Books
     * const books = await prisma.book.findMany()
     * 
     * // Get first 10 Books
     * const books = await prisma.book.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookWithIdOnly = await prisma.book.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BookFindManyArgs>(
      args?: SelectSubset<T, BookFindManyArgs>
    ): Prisma.PrismaPromise<Array<BookGetPayload<T>>>

    /**
     * Create a Book.
     * @param {BookCreateArgs} args - Arguments to create a Book.
     * @example
     * // Create one Book
     * const Book = await prisma.book.create({
     *   data: {
     *     // ... data to create a Book
     *   }
     * })
     * 
    **/
    create<T extends BookCreateArgs>(
      args: SelectSubset<T, BookCreateArgs>
    ): Prisma__BookClient<BookGetPayload<T>>

    /**
     * Create many Books.
     *     @param {BookCreateManyArgs} args - Arguments to create many Books.
     *     @example
     *     // Create many Books
     *     const book = await prisma.book.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BookCreateManyArgs>(
      args?: SelectSubset<T, BookCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Book.
     * @param {BookDeleteArgs} args - Arguments to delete one Book.
     * @example
     * // Delete one Book
     * const Book = await prisma.book.delete({
     *   where: {
     *     // ... filter to delete one Book
     *   }
     * })
     * 
    **/
    delete<T extends BookDeleteArgs>(
      args: SelectSubset<T, BookDeleteArgs>
    ): Prisma__BookClient<BookGetPayload<T>>

    /**
     * Update one Book.
     * @param {BookUpdateArgs} args - Arguments to update one Book.
     * @example
     * // Update one Book
     * const book = await prisma.book.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BookUpdateArgs>(
      args: SelectSubset<T, BookUpdateArgs>
    ): Prisma__BookClient<BookGetPayload<T>>

    /**
     * Delete zero or more Books.
     * @param {BookDeleteManyArgs} args - Arguments to filter Books to delete.
     * @example
     * // Delete a few Books
     * const { count } = await prisma.book.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BookDeleteManyArgs>(
      args?: SelectSubset<T, BookDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Books
     * const book = await prisma.book.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BookUpdateManyArgs>(
      args: SelectSubset<T, BookUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Book.
     * @param {BookUpsertArgs} args - Arguments to update or create a Book.
     * @example
     * // Update or create a Book
     * const book = await prisma.book.upsert({
     *   create: {
     *     // ... data to create a Book
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Book we want to update
     *   }
     * })
    **/
    upsert<T extends BookUpsertArgs>(
      args: SelectSubset<T, BookUpsertArgs>
    ): Prisma__BookClient<BookGetPayload<T>>

    /**
     * Count the number of Books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookCountArgs} args - Arguments to filter Books to count.
     * @example
     * // Count the number of Books
     * const count = await prisma.book.count({
     *   where: {
     *     // ... the filter for the Books we want to count
     *   }
     * })
    **/
    count<T extends BookCountArgs>(
      args?: Subset<T, BookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Book.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookAggregateArgs>(args: Subset<T, BookAggregateArgs>): Prisma.PrismaPromise<GetBookAggregateType<T>>

    /**
     * Group by Book.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookGroupByArgs['orderBy'] }
        : { orderBy?: BookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Book.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BookClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    title<T extends BookTitleArgs= {}>(args?: Subset<T, BookTitleArgs>): Prisma__BookTitleClient<BookTitleGetPayload<T> | Null>;

    belongsToLibrary<T extends LibraryArgs= {}>(args?: Subset<T, LibraryArgs>): Prisma__LibraryClient<LibraryGetPayload<T> | Null>;

    borrowingRecords<T extends Book$borrowingRecordsArgs= {}>(args?: Subset<T, Book$borrowingRecordsArgs>): Prisma.PrismaPromise<Array<BorrowingRecordGetPayload<T>>| Null>;

    requestRecords<T extends Book$requestRecordsArgs= {}>(args?: Subset<T, Book$requestRecordsArgs>): Prisma.PrismaPromise<Array<RequestRecordGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Book base type for findUnique actions
   */
  export type BookFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookInclude | null
    /**
     * Filter, which Book to fetch.
     */
    where: BookWhereUniqueInput
  }

  /**
   * Book findUnique
   */
  export interface BookFindUniqueArgs extends BookFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Book findUniqueOrThrow
   */
  export type BookFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookInclude | null
    /**
     * Filter, which Book to fetch.
     */
    where: BookWhereUniqueInput
  }


  /**
   * Book base type for findFirst actions
   */
  export type BookFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookInclude | null
    /**
     * Filter, which Book to fetch.
     */
    where?: BookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Books to fetch.
     */
    orderBy?: Enumerable<BookOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Books.
     */
    cursor?: BookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Books.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Books.
     */
    distinct?: Enumerable<BookScalarFieldEnum>
  }

  /**
   * Book findFirst
   */
  export interface BookFindFirstArgs extends BookFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Book findFirstOrThrow
   */
  export type BookFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookInclude | null
    /**
     * Filter, which Book to fetch.
     */
    where?: BookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Books to fetch.
     */
    orderBy?: Enumerable<BookOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Books.
     */
    cursor?: BookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Books.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Books.
     */
    distinct?: Enumerable<BookScalarFieldEnum>
  }


  /**
   * Book findMany
   */
  export type BookFindManyArgs = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookInclude | null
    /**
     * Filter, which Books to fetch.
     */
    where?: BookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Books to fetch.
     */
    orderBy?: Enumerable<BookOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Books.
     */
    cursor?: BookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Books.
     */
    skip?: number
    distinct?: Enumerable<BookScalarFieldEnum>
  }


  /**
   * Book create
   */
  export type BookCreateArgs = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookInclude | null
    /**
     * The data needed to create a Book.
     */
    data: XOR<BookCreateInput, BookUncheckedCreateInput>
  }


  /**
   * Book createMany
   */
  export type BookCreateManyArgs = {
    /**
     * The data used to create many Books.
     */
    data: Enumerable<BookCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Book update
   */
  export type BookUpdateArgs = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookInclude | null
    /**
     * The data needed to update a Book.
     */
    data: XOR<BookUpdateInput, BookUncheckedUpdateInput>
    /**
     * Choose, which Book to update.
     */
    where: BookWhereUniqueInput
  }


  /**
   * Book updateMany
   */
  export type BookUpdateManyArgs = {
    /**
     * The data used to update Books.
     */
    data: XOR<BookUpdateManyMutationInput, BookUncheckedUpdateManyInput>
    /**
     * Filter which Books to update
     */
    where?: BookWhereInput
  }


  /**
   * Book upsert
   */
  export type BookUpsertArgs = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookInclude | null
    /**
     * The filter to search for the Book to update in case it exists.
     */
    where: BookWhereUniqueInput
    /**
     * In case the Book found by the `where` argument doesn't exist, create a new Book with this data.
     */
    create: XOR<BookCreateInput, BookUncheckedCreateInput>
    /**
     * In case the Book was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookUpdateInput, BookUncheckedUpdateInput>
  }


  /**
   * Book delete
   */
  export type BookDeleteArgs = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookInclude | null
    /**
     * Filter which Book to delete.
     */
    where: BookWhereUniqueInput
  }


  /**
   * Book deleteMany
   */
  export type BookDeleteManyArgs = {
    /**
     * Filter which Books to delete
     */
    where?: BookWhereInput
  }


  /**
   * Book.borrowingRecords
   */
  export type Book$borrowingRecordsArgs = {
    /**
     * Select specific fields to fetch from the BorrowingRecord
     */
    select?: BorrowingRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BorrowingRecordInclude | null
    where?: BorrowingRecordWhereInput
    orderBy?: Enumerable<BorrowingRecordOrderByWithRelationInput>
    cursor?: BorrowingRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BorrowingRecordScalarFieldEnum>
  }


  /**
   * Book.requestRecords
   */
  export type Book$requestRecordsArgs = {
    /**
     * Select specific fields to fetch from the RequestRecord
     */
    select?: RequestRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestRecordInclude | null
    where?: RequestRecordWhereInput
    orderBy?: Enumerable<RequestRecordOrderByWithRelationInput>
    cursor?: RequestRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RequestRecordScalarFieldEnum>
  }


  /**
   * Book without action
   */
  export type BookArgs = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookInclude | null
  }



  /**
   * Model Library
   */


  export type AggregateLibrary = {
    _count: LibraryCountAggregateOutputType | null
    _avg: LibraryAvgAggregateOutputType | null
    _sum: LibrarySumAggregateOutputType | null
    _min: LibraryMinAggregateOutputType | null
    _max: LibraryMaxAggregateOutputType | null
  }

  export type LibraryAvgAggregateOutputType = {
    id: number | null
    universityId: number | null
  }

  export type LibrarySumAggregateOutputType = {
    id: number | null
    universityId: number | null
  }

  export type LibraryMinAggregateOutputType = {
    id: number | null
    name: string | null
    location: string | null
    universityId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LibraryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    location: string | null
    universityId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LibraryCountAggregateOutputType = {
    id: number
    name: number
    location: number
    universityId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LibraryAvgAggregateInputType = {
    id?: true
    universityId?: true
  }

  export type LibrarySumAggregateInputType = {
    id?: true
    universityId?: true
  }

  export type LibraryMinAggregateInputType = {
    id?: true
    name?: true
    location?: true
    universityId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LibraryMaxAggregateInputType = {
    id?: true
    name?: true
    location?: true
    universityId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LibraryCountAggregateInputType = {
    id?: true
    name?: true
    location?: true
    universityId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LibraryAggregateArgs = {
    /**
     * Filter which Library to aggregate.
     */
    where?: LibraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Libraries to fetch.
     */
    orderBy?: Enumerable<LibraryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LibraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Libraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Libraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Libraries
    **/
    _count?: true | LibraryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LibraryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LibrarySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LibraryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LibraryMaxAggregateInputType
  }

  export type GetLibraryAggregateType<T extends LibraryAggregateArgs> = {
        [P in keyof T & keyof AggregateLibrary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLibrary[P]>
      : GetScalarType<T[P], AggregateLibrary[P]>
  }




  export type LibraryGroupByArgs = {
    where?: LibraryWhereInput
    orderBy?: Enumerable<LibraryOrderByWithAggregationInput>
    by: LibraryScalarFieldEnum[]
    having?: LibraryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LibraryCountAggregateInputType | true
    _avg?: LibraryAvgAggregateInputType
    _sum?: LibrarySumAggregateInputType
    _min?: LibraryMinAggregateInputType
    _max?: LibraryMaxAggregateInputType
  }


  export type LibraryGroupByOutputType = {
    id: number
    name: string
    location: string
    universityId: number
    createdAt: Date
    updatedAt: Date
    _count: LibraryCountAggregateOutputType | null
    _avg: LibraryAvgAggregateOutputType | null
    _sum: LibrarySumAggregateOutputType | null
    _min: LibraryMinAggregateOutputType | null
    _max: LibraryMaxAggregateOutputType | null
  }

  type GetLibraryGroupByPayload<T extends LibraryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LibraryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LibraryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LibraryGroupByOutputType[P]>
            : GetScalarType<T[P], LibraryGroupByOutputType[P]>
        }
      >
    >


  export type LibrarySelect = {
    id?: boolean
    name?: boolean
    location?: boolean
    belongsToUniversity?: boolean | UniversityArgs
    universityId?: boolean
    books?: boolean | Library$booksArgs
    requestingRecords?: boolean | Library$requestingRecordsArgs
    requestedRecords?: boolean | Library$requestedRecordsArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | LibraryCountOutputTypeArgs
  }


  export type LibraryInclude = {
    belongsToUniversity?: boolean | UniversityArgs
    books?: boolean | Library$booksArgs
    requestingRecords?: boolean | Library$requestingRecordsArgs
    requestedRecords?: boolean | Library$requestedRecordsArgs
    _count?: boolean | LibraryCountOutputTypeArgs
  }

  export type LibraryGetPayload<S extends boolean | null | undefined | LibraryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Library :
    S extends undefined ? never :
    S extends { include: any } & (LibraryArgs | LibraryFindManyArgs)
    ? Library  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'belongsToUniversity' ? UniversityGetPayload<S['include'][P]> :
        P extends 'books' ? Array < BookGetPayload<S['include'][P]>>  :
        P extends 'requestingRecords' ? Array < RequestRecordGetPayload<S['include'][P]>>  :
        P extends 'requestedRecords' ? Array < RequestRecordGetPayload<S['include'][P]>>  :
        P extends '_count' ? LibraryCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (LibraryArgs | LibraryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'belongsToUniversity' ? UniversityGetPayload<S['select'][P]> :
        P extends 'books' ? Array < BookGetPayload<S['select'][P]>>  :
        P extends 'requestingRecords' ? Array < RequestRecordGetPayload<S['select'][P]>>  :
        P extends 'requestedRecords' ? Array < RequestRecordGetPayload<S['select'][P]>>  :
        P extends '_count' ? LibraryCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Library ? Library[P] : never
  } 
      : Library


  type LibraryCountArgs = 
    Omit<LibraryFindManyArgs, 'select' | 'include'> & {
      select?: LibraryCountAggregateInputType | true
    }

  export interface LibraryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Library that matches the filter.
     * @param {LibraryFindUniqueArgs} args - Arguments to find a Library
     * @example
     * // Get one Library
     * const library = await prisma.library.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LibraryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LibraryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Library'> extends True ? Prisma__LibraryClient<LibraryGetPayload<T>> : Prisma__LibraryClient<LibraryGetPayload<T> | null, null>

    /**
     * Find one Library that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LibraryFindUniqueOrThrowArgs} args - Arguments to find a Library
     * @example
     * // Get one Library
     * const library = await prisma.library.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LibraryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LibraryFindUniqueOrThrowArgs>
    ): Prisma__LibraryClient<LibraryGetPayload<T>>

    /**
     * Find the first Library that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryFindFirstArgs} args - Arguments to find a Library
     * @example
     * // Get one Library
     * const library = await prisma.library.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LibraryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LibraryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Library'> extends True ? Prisma__LibraryClient<LibraryGetPayload<T>> : Prisma__LibraryClient<LibraryGetPayload<T> | null, null>

    /**
     * Find the first Library that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryFindFirstOrThrowArgs} args - Arguments to find a Library
     * @example
     * // Get one Library
     * const library = await prisma.library.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LibraryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LibraryFindFirstOrThrowArgs>
    ): Prisma__LibraryClient<LibraryGetPayload<T>>

    /**
     * Find zero or more Libraries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Libraries
     * const libraries = await prisma.library.findMany()
     * 
     * // Get first 10 Libraries
     * const libraries = await prisma.library.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const libraryWithIdOnly = await prisma.library.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LibraryFindManyArgs>(
      args?: SelectSubset<T, LibraryFindManyArgs>
    ): Prisma.PrismaPromise<Array<LibraryGetPayload<T>>>

    /**
     * Create a Library.
     * @param {LibraryCreateArgs} args - Arguments to create a Library.
     * @example
     * // Create one Library
     * const Library = await prisma.library.create({
     *   data: {
     *     // ... data to create a Library
     *   }
     * })
     * 
    **/
    create<T extends LibraryCreateArgs>(
      args: SelectSubset<T, LibraryCreateArgs>
    ): Prisma__LibraryClient<LibraryGetPayload<T>>

    /**
     * Create many Libraries.
     *     @param {LibraryCreateManyArgs} args - Arguments to create many Libraries.
     *     @example
     *     // Create many Libraries
     *     const library = await prisma.library.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LibraryCreateManyArgs>(
      args?: SelectSubset<T, LibraryCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Library.
     * @param {LibraryDeleteArgs} args - Arguments to delete one Library.
     * @example
     * // Delete one Library
     * const Library = await prisma.library.delete({
     *   where: {
     *     // ... filter to delete one Library
     *   }
     * })
     * 
    **/
    delete<T extends LibraryDeleteArgs>(
      args: SelectSubset<T, LibraryDeleteArgs>
    ): Prisma__LibraryClient<LibraryGetPayload<T>>

    /**
     * Update one Library.
     * @param {LibraryUpdateArgs} args - Arguments to update one Library.
     * @example
     * // Update one Library
     * const library = await prisma.library.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LibraryUpdateArgs>(
      args: SelectSubset<T, LibraryUpdateArgs>
    ): Prisma__LibraryClient<LibraryGetPayload<T>>

    /**
     * Delete zero or more Libraries.
     * @param {LibraryDeleteManyArgs} args - Arguments to filter Libraries to delete.
     * @example
     * // Delete a few Libraries
     * const { count } = await prisma.library.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LibraryDeleteManyArgs>(
      args?: SelectSubset<T, LibraryDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Libraries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Libraries
     * const library = await prisma.library.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LibraryUpdateManyArgs>(
      args: SelectSubset<T, LibraryUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Library.
     * @param {LibraryUpsertArgs} args - Arguments to update or create a Library.
     * @example
     * // Update or create a Library
     * const library = await prisma.library.upsert({
     *   create: {
     *     // ... data to create a Library
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Library we want to update
     *   }
     * })
    **/
    upsert<T extends LibraryUpsertArgs>(
      args: SelectSubset<T, LibraryUpsertArgs>
    ): Prisma__LibraryClient<LibraryGetPayload<T>>

    /**
     * Count the number of Libraries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryCountArgs} args - Arguments to filter Libraries to count.
     * @example
     * // Count the number of Libraries
     * const count = await prisma.library.count({
     *   where: {
     *     // ... the filter for the Libraries we want to count
     *   }
     * })
    **/
    count<T extends LibraryCountArgs>(
      args?: Subset<T, LibraryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LibraryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Library.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LibraryAggregateArgs>(args: Subset<T, LibraryAggregateArgs>): Prisma.PrismaPromise<GetLibraryAggregateType<T>>

    /**
     * Group by Library.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LibraryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LibraryGroupByArgs['orderBy'] }
        : { orderBy?: LibraryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LibraryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLibraryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Library.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LibraryClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    belongsToUniversity<T extends UniversityArgs= {}>(args?: Subset<T, UniversityArgs>): Prisma__UniversityClient<UniversityGetPayload<T> | Null>;

    books<T extends Library$booksArgs= {}>(args?: Subset<T, Library$booksArgs>): Prisma.PrismaPromise<Array<BookGetPayload<T>>| Null>;

    requestingRecords<T extends Library$requestingRecordsArgs= {}>(args?: Subset<T, Library$requestingRecordsArgs>): Prisma.PrismaPromise<Array<RequestRecordGetPayload<T>>| Null>;

    requestedRecords<T extends Library$requestedRecordsArgs= {}>(args?: Subset<T, Library$requestedRecordsArgs>): Prisma.PrismaPromise<Array<RequestRecordGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Library base type for findUnique actions
   */
  export type LibraryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryInclude | null
    /**
     * Filter, which Library to fetch.
     */
    where: LibraryWhereUniqueInput
  }

  /**
   * Library findUnique
   */
  export interface LibraryFindUniqueArgs extends LibraryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Library findUniqueOrThrow
   */
  export type LibraryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryInclude | null
    /**
     * Filter, which Library to fetch.
     */
    where: LibraryWhereUniqueInput
  }


  /**
   * Library base type for findFirst actions
   */
  export type LibraryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryInclude | null
    /**
     * Filter, which Library to fetch.
     */
    where?: LibraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Libraries to fetch.
     */
    orderBy?: Enumerable<LibraryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Libraries.
     */
    cursor?: LibraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Libraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Libraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Libraries.
     */
    distinct?: Enumerable<LibraryScalarFieldEnum>
  }

  /**
   * Library findFirst
   */
  export interface LibraryFindFirstArgs extends LibraryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Library findFirstOrThrow
   */
  export type LibraryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryInclude | null
    /**
     * Filter, which Library to fetch.
     */
    where?: LibraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Libraries to fetch.
     */
    orderBy?: Enumerable<LibraryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Libraries.
     */
    cursor?: LibraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Libraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Libraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Libraries.
     */
    distinct?: Enumerable<LibraryScalarFieldEnum>
  }


  /**
   * Library findMany
   */
  export type LibraryFindManyArgs = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryInclude | null
    /**
     * Filter, which Libraries to fetch.
     */
    where?: LibraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Libraries to fetch.
     */
    orderBy?: Enumerable<LibraryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Libraries.
     */
    cursor?: LibraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Libraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Libraries.
     */
    skip?: number
    distinct?: Enumerable<LibraryScalarFieldEnum>
  }


  /**
   * Library create
   */
  export type LibraryCreateArgs = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryInclude | null
    /**
     * The data needed to create a Library.
     */
    data: XOR<LibraryCreateInput, LibraryUncheckedCreateInput>
  }


  /**
   * Library createMany
   */
  export type LibraryCreateManyArgs = {
    /**
     * The data used to create many Libraries.
     */
    data: Enumerable<LibraryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Library update
   */
  export type LibraryUpdateArgs = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryInclude | null
    /**
     * The data needed to update a Library.
     */
    data: XOR<LibraryUpdateInput, LibraryUncheckedUpdateInput>
    /**
     * Choose, which Library to update.
     */
    where: LibraryWhereUniqueInput
  }


  /**
   * Library updateMany
   */
  export type LibraryUpdateManyArgs = {
    /**
     * The data used to update Libraries.
     */
    data: XOR<LibraryUpdateManyMutationInput, LibraryUncheckedUpdateManyInput>
    /**
     * Filter which Libraries to update
     */
    where?: LibraryWhereInput
  }


  /**
   * Library upsert
   */
  export type LibraryUpsertArgs = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryInclude | null
    /**
     * The filter to search for the Library to update in case it exists.
     */
    where: LibraryWhereUniqueInput
    /**
     * In case the Library found by the `where` argument doesn't exist, create a new Library with this data.
     */
    create: XOR<LibraryCreateInput, LibraryUncheckedCreateInput>
    /**
     * In case the Library was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LibraryUpdateInput, LibraryUncheckedUpdateInput>
  }


  /**
   * Library delete
   */
  export type LibraryDeleteArgs = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryInclude | null
    /**
     * Filter which Library to delete.
     */
    where: LibraryWhereUniqueInput
  }


  /**
   * Library deleteMany
   */
  export type LibraryDeleteManyArgs = {
    /**
     * Filter which Libraries to delete
     */
    where?: LibraryWhereInput
  }


  /**
   * Library.books
   */
  export type Library$booksArgs = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookInclude | null
    where?: BookWhereInput
    orderBy?: Enumerable<BookOrderByWithRelationInput>
    cursor?: BookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BookScalarFieldEnum>
  }


  /**
   * Library.requestingRecords
   */
  export type Library$requestingRecordsArgs = {
    /**
     * Select specific fields to fetch from the RequestRecord
     */
    select?: RequestRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestRecordInclude | null
    where?: RequestRecordWhereInput
    orderBy?: Enumerable<RequestRecordOrderByWithRelationInput>
    cursor?: RequestRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RequestRecordScalarFieldEnum>
  }


  /**
   * Library.requestedRecords
   */
  export type Library$requestedRecordsArgs = {
    /**
     * Select specific fields to fetch from the RequestRecord
     */
    select?: RequestRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestRecordInclude | null
    where?: RequestRecordWhereInput
    orderBy?: Enumerable<RequestRecordOrderByWithRelationInput>
    cursor?: RequestRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RequestRecordScalarFieldEnum>
  }


  /**
   * Library without action
   */
  export type LibraryArgs = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryInclude | null
  }



  /**
   * Model University
   */


  export type AggregateUniversity = {
    _count: UniversityCountAggregateOutputType | null
    _avg: UniversityAvgAggregateOutputType | null
    _sum: UniversitySumAggregateOutputType | null
    _min: UniversityMinAggregateOutputType | null
    _max: UniversityMaxAggregateOutputType | null
  }

  export type UniversityAvgAggregateOutputType = {
    id: number | null
  }

  export type UniversitySumAggregateOutputType = {
    id: number | null
  }

  export type UniversityMinAggregateOutputType = {
    id: number | null
    name: string | null
    location: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UniversityMaxAggregateOutputType = {
    id: number | null
    name: string | null
    location: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UniversityCountAggregateOutputType = {
    id: number
    name: number
    location: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UniversityAvgAggregateInputType = {
    id?: true
  }

  export type UniversitySumAggregateInputType = {
    id?: true
  }

  export type UniversityMinAggregateInputType = {
    id?: true
    name?: true
    location?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UniversityMaxAggregateInputType = {
    id?: true
    name?: true
    location?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UniversityCountAggregateInputType = {
    id?: true
    name?: true
    location?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UniversityAggregateArgs = {
    /**
     * Filter which University to aggregate.
     */
    where?: UniversityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Universities to fetch.
     */
    orderBy?: Enumerable<UniversityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UniversityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Universities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Universities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Universities
    **/
    _count?: true | UniversityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UniversityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UniversitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UniversityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UniversityMaxAggregateInputType
  }

  export type GetUniversityAggregateType<T extends UniversityAggregateArgs> = {
        [P in keyof T & keyof AggregateUniversity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUniversity[P]>
      : GetScalarType<T[P], AggregateUniversity[P]>
  }




  export type UniversityGroupByArgs = {
    where?: UniversityWhereInput
    orderBy?: Enumerable<UniversityOrderByWithAggregationInput>
    by: UniversityScalarFieldEnum[]
    having?: UniversityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UniversityCountAggregateInputType | true
    _avg?: UniversityAvgAggregateInputType
    _sum?: UniversitySumAggregateInputType
    _min?: UniversityMinAggregateInputType
    _max?: UniversityMaxAggregateInputType
  }


  export type UniversityGroupByOutputType = {
    id: number
    name: string
    location: string
    createdAt: Date
    updatedAt: Date
    _count: UniversityCountAggregateOutputType | null
    _avg: UniversityAvgAggregateOutputType | null
    _sum: UniversitySumAggregateOutputType | null
    _min: UniversityMinAggregateOutputType | null
    _max: UniversityMaxAggregateOutputType | null
  }

  type GetUniversityGroupByPayload<T extends UniversityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UniversityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UniversityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UniversityGroupByOutputType[P]>
            : GetScalarType<T[P], UniversityGroupByOutputType[P]>
        }
      >
    >


  export type UniversitySelect = {
    id?: boolean
    name?: boolean
    location?: boolean
    libraries?: boolean | University$librariesArgs
    students?: boolean | University$studentsArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | UniversityCountOutputTypeArgs
  }


  export type UniversityInclude = {
    libraries?: boolean | University$librariesArgs
    students?: boolean | University$studentsArgs
    _count?: boolean | UniversityCountOutputTypeArgs
  }

  export type UniversityGetPayload<S extends boolean | null | undefined | UniversityArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? University :
    S extends undefined ? never :
    S extends { include: any } & (UniversityArgs | UniversityFindManyArgs)
    ? University  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'libraries' ? Array < LibraryGetPayload<S['include'][P]>>  :
        P extends 'students' ? Array < StudentGetPayload<S['include'][P]>>  :
        P extends '_count' ? UniversityCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UniversityArgs | UniversityFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'libraries' ? Array < LibraryGetPayload<S['select'][P]>>  :
        P extends 'students' ? Array < StudentGetPayload<S['select'][P]>>  :
        P extends '_count' ? UniversityCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof University ? University[P] : never
  } 
      : University


  type UniversityCountArgs = 
    Omit<UniversityFindManyArgs, 'select' | 'include'> & {
      select?: UniversityCountAggregateInputType | true
    }

  export interface UniversityDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one University that matches the filter.
     * @param {UniversityFindUniqueArgs} args - Arguments to find a University
     * @example
     * // Get one University
     * const university = await prisma.university.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UniversityFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UniversityFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'University'> extends True ? Prisma__UniversityClient<UniversityGetPayload<T>> : Prisma__UniversityClient<UniversityGetPayload<T> | null, null>

    /**
     * Find one University that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UniversityFindUniqueOrThrowArgs} args - Arguments to find a University
     * @example
     * // Get one University
     * const university = await prisma.university.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UniversityFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UniversityFindUniqueOrThrowArgs>
    ): Prisma__UniversityClient<UniversityGetPayload<T>>

    /**
     * Find the first University that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityFindFirstArgs} args - Arguments to find a University
     * @example
     * // Get one University
     * const university = await prisma.university.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UniversityFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UniversityFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'University'> extends True ? Prisma__UniversityClient<UniversityGetPayload<T>> : Prisma__UniversityClient<UniversityGetPayload<T> | null, null>

    /**
     * Find the first University that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityFindFirstOrThrowArgs} args - Arguments to find a University
     * @example
     * // Get one University
     * const university = await prisma.university.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UniversityFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UniversityFindFirstOrThrowArgs>
    ): Prisma__UniversityClient<UniversityGetPayload<T>>

    /**
     * Find zero or more Universities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Universities
     * const universities = await prisma.university.findMany()
     * 
     * // Get first 10 Universities
     * const universities = await prisma.university.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const universityWithIdOnly = await prisma.university.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UniversityFindManyArgs>(
      args?: SelectSubset<T, UniversityFindManyArgs>
    ): Prisma.PrismaPromise<Array<UniversityGetPayload<T>>>

    /**
     * Create a University.
     * @param {UniversityCreateArgs} args - Arguments to create a University.
     * @example
     * // Create one University
     * const University = await prisma.university.create({
     *   data: {
     *     // ... data to create a University
     *   }
     * })
     * 
    **/
    create<T extends UniversityCreateArgs>(
      args: SelectSubset<T, UniversityCreateArgs>
    ): Prisma__UniversityClient<UniversityGetPayload<T>>

    /**
     * Create many Universities.
     *     @param {UniversityCreateManyArgs} args - Arguments to create many Universities.
     *     @example
     *     // Create many Universities
     *     const university = await prisma.university.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UniversityCreateManyArgs>(
      args?: SelectSubset<T, UniversityCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a University.
     * @param {UniversityDeleteArgs} args - Arguments to delete one University.
     * @example
     * // Delete one University
     * const University = await prisma.university.delete({
     *   where: {
     *     // ... filter to delete one University
     *   }
     * })
     * 
    **/
    delete<T extends UniversityDeleteArgs>(
      args: SelectSubset<T, UniversityDeleteArgs>
    ): Prisma__UniversityClient<UniversityGetPayload<T>>

    /**
     * Update one University.
     * @param {UniversityUpdateArgs} args - Arguments to update one University.
     * @example
     * // Update one University
     * const university = await prisma.university.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UniversityUpdateArgs>(
      args: SelectSubset<T, UniversityUpdateArgs>
    ): Prisma__UniversityClient<UniversityGetPayload<T>>

    /**
     * Delete zero or more Universities.
     * @param {UniversityDeleteManyArgs} args - Arguments to filter Universities to delete.
     * @example
     * // Delete a few Universities
     * const { count } = await prisma.university.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UniversityDeleteManyArgs>(
      args?: SelectSubset<T, UniversityDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Universities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Universities
     * const university = await prisma.university.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UniversityUpdateManyArgs>(
      args: SelectSubset<T, UniversityUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one University.
     * @param {UniversityUpsertArgs} args - Arguments to update or create a University.
     * @example
     * // Update or create a University
     * const university = await prisma.university.upsert({
     *   create: {
     *     // ... data to create a University
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the University we want to update
     *   }
     * })
    **/
    upsert<T extends UniversityUpsertArgs>(
      args: SelectSubset<T, UniversityUpsertArgs>
    ): Prisma__UniversityClient<UniversityGetPayload<T>>

    /**
     * Count the number of Universities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityCountArgs} args - Arguments to filter Universities to count.
     * @example
     * // Count the number of Universities
     * const count = await prisma.university.count({
     *   where: {
     *     // ... the filter for the Universities we want to count
     *   }
     * })
    **/
    count<T extends UniversityCountArgs>(
      args?: Subset<T, UniversityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UniversityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a University.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UniversityAggregateArgs>(args: Subset<T, UniversityAggregateArgs>): Prisma.PrismaPromise<GetUniversityAggregateType<T>>

    /**
     * Group by University.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UniversityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UniversityGroupByArgs['orderBy'] }
        : { orderBy?: UniversityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UniversityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUniversityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for University.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UniversityClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    libraries<T extends University$librariesArgs= {}>(args?: Subset<T, University$librariesArgs>): Prisma.PrismaPromise<Array<LibraryGetPayload<T>>| Null>;

    students<T extends University$studentsArgs= {}>(args?: Subset<T, University$studentsArgs>): Prisma.PrismaPromise<Array<StudentGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * University base type for findUnique actions
   */
  export type UniversityFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the University
     */
    select?: UniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UniversityInclude | null
    /**
     * Filter, which University to fetch.
     */
    where: UniversityWhereUniqueInput
  }

  /**
   * University findUnique
   */
  export interface UniversityFindUniqueArgs extends UniversityFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * University findUniqueOrThrow
   */
  export type UniversityFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the University
     */
    select?: UniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UniversityInclude | null
    /**
     * Filter, which University to fetch.
     */
    where: UniversityWhereUniqueInput
  }


  /**
   * University base type for findFirst actions
   */
  export type UniversityFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the University
     */
    select?: UniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UniversityInclude | null
    /**
     * Filter, which University to fetch.
     */
    where?: UniversityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Universities to fetch.
     */
    orderBy?: Enumerable<UniversityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Universities.
     */
    cursor?: UniversityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Universities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Universities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Universities.
     */
    distinct?: Enumerable<UniversityScalarFieldEnum>
  }

  /**
   * University findFirst
   */
  export interface UniversityFindFirstArgs extends UniversityFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * University findFirstOrThrow
   */
  export type UniversityFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the University
     */
    select?: UniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UniversityInclude | null
    /**
     * Filter, which University to fetch.
     */
    where?: UniversityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Universities to fetch.
     */
    orderBy?: Enumerable<UniversityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Universities.
     */
    cursor?: UniversityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Universities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Universities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Universities.
     */
    distinct?: Enumerable<UniversityScalarFieldEnum>
  }


  /**
   * University findMany
   */
  export type UniversityFindManyArgs = {
    /**
     * Select specific fields to fetch from the University
     */
    select?: UniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UniversityInclude | null
    /**
     * Filter, which Universities to fetch.
     */
    where?: UniversityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Universities to fetch.
     */
    orderBy?: Enumerable<UniversityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Universities.
     */
    cursor?: UniversityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Universities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Universities.
     */
    skip?: number
    distinct?: Enumerable<UniversityScalarFieldEnum>
  }


  /**
   * University create
   */
  export type UniversityCreateArgs = {
    /**
     * Select specific fields to fetch from the University
     */
    select?: UniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UniversityInclude | null
    /**
     * The data needed to create a University.
     */
    data: XOR<UniversityCreateInput, UniversityUncheckedCreateInput>
  }


  /**
   * University createMany
   */
  export type UniversityCreateManyArgs = {
    /**
     * The data used to create many Universities.
     */
    data: Enumerable<UniversityCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * University update
   */
  export type UniversityUpdateArgs = {
    /**
     * Select specific fields to fetch from the University
     */
    select?: UniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UniversityInclude | null
    /**
     * The data needed to update a University.
     */
    data: XOR<UniversityUpdateInput, UniversityUncheckedUpdateInput>
    /**
     * Choose, which University to update.
     */
    where: UniversityWhereUniqueInput
  }


  /**
   * University updateMany
   */
  export type UniversityUpdateManyArgs = {
    /**
     * The data used to update Universities.
     */
    data: XOR<UniversityUpdateManyMutationInput, UniversityUncheckedUpdateManyInput>
    /**
     * Filter which Universities to update
     */
    where?: UniversityWhereInput
  }


  /**
   * University upsert
   */
  export type UniversityUpsertArgs = {
    /**
     * Select specific fields to fetch from the University
     */
    select?: UniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UniversityInclude | null
    /**
     * The filter to search for the University to update in case it exists.
     */
    where: UniversityWhereUniqueInput
    /**
     * In case the University found by the `where` argument doesn't exist, create a new University with this data.
     */
    create: XOR<UniversityCreateInput, UniversityUncheckedCreateInput>
    /**
     * In case the University was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UniversityUpdateInput, UniversityUncheckedUpdateInput>
  }


  /**
   * University delete
   */
  export type UniversityDeleteArgs = {
    /**
     * Select specific fields to fetch from the University
     */
    select?: UniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UniversityInclude | null
    /**
     * Filter which University to delete.
     */
    where: UniversityWhereUniqueInput
  }


  /**
   * University deleteMany
   */
  export type UniversityDeleteManyArgs = {
    /**
     * Filter which Universities to delete
     */
    where?: UniversityWhereInput
  }


  /**
   * University.libraries
   */
  export type University$librariesArgs = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryInclude | null
    where?: LibraryWhereInput
    orderBy?: Enumerable<LibraryOrderByWithRelationInput>
    cursor?: LibraryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LibraryScalarFieldEnum>
  }


  /**
   * University.students
   */
  export type University$studentsArgs = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude | null
    where?: StudentWhereInput
    orderBy?: Enumerable<StudentOrderByWithRelationInput>
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<StudentScalarFieldEnum>
  }


  /**
   * University without action
   */
  export type UniversityArgs = {
    /**
     * Select specific fields to fetch from the University
     */
    select?: UniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UniversityInclude | null
  }



  /**
   * Model Student
   */


  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  export type StudentAvgAggregateOutputType = {
    id: number | null
    universityId: number | null
  }

  export type StudentSumAggregateOutputType = {
    id: number | null
    universityId: number | null
  }

  export type StudentMinAggregateOutputType = {
    id: number | null
    Name: string | null
    universityId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentMaxAggregateOutputType = {
    id: number | null
    Name: string | null
    universityId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentCountAggregateOutputType = {
    id: number
    Name: number
    universityId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentAvgAggregateInputType = {
    id?: true
    universityId?: true
  }

  export type StudentSumAggregateInputType = {
    id?: true
    universityId?: true
  }

  export type StudentMinAggregateInputType = {
    id?: true
    Name?: true
    universityId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentMaxAggregateInputType = {
    id?: true
    Name?: true
    universityId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentCountAggregateInputType = {
    id?: true
    Name?: true
    universityId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentAggregateArgs = {
    /**
     * Filter which Student to aggregate.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: Enumerable<StudentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }




  export type StudentGroupByArgs = {
    where?: StudentWhereInput
    orderBy?: Enumerable<StudentOrderByWithAggregationInput>
    by: StudentScalarFieldEnum[]
    having?: StudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _avg?: StudentAvgAggregateInputType
    _sum?: StudentSumAggregateInputType
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }


  export type StudentGroupByOutputType = {
    id: number
    Name: string
    universityId: number
    createdAt: Date
    updatedAt: Date
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends StudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<StudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      >
    >


  export type StudentSelect = {
    id?: boolean
    Name?: boolean
    belongsToUniversity?: boolean | UniversityArgs
    universityId?: boolean
    borrowingRecords?: boolean | Student$borrowingRecordsArgs
    requestRecords?: boolean | Student$requestRecordsArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | StudentCountOutputTypeArgs
  }


  export type StudentInclude = {
    belongsToUniversity?: boolean | UniversityArgs
    borrowingRecords?: boolean | Student$borrowingRecordsArgs
    requestRecords?: boolean | Student$requestRecordsArgs
    _count?: boolean | StudentCountOutputTypeArgs
  }

  export type StudentGetPayload<S extends boolean | null | undefined | StudentArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Student :
    S extends undefined ? never :
    S extends { include: any } & (StudentArgs | StudentFindManyArgs)
    ? Student  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'belongsToUniversity' ? UniversityGetPayload<S['include'][P]> :
        P extends 'borrowingRecords' ? Array < BorrowingRecordGetPayload<S['include'][P]>>  :
        P extends 'requestRecords' ? Array < RequestRecordGetPayload<S['include'][P]>>  :
        P extends '_count' ? StudentCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (StudentArgs | StudentFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'belongsToUniversity' ? UniversityGetPayload<S['select'][P]> :
        P extends 'borrowingRecords' ? Array < BorrowingRecordGetPayload<S['select'][P]>>  :
        P extends 'requestRecords' ? Array < RequestRecordGetPayload<S['select'][P]>>  :
        P extends '_count' ? StudentCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Student ? Student[P] : never
  } 
      : Student


  type StudentCountArgs = 
    Omit<StudentFindManyArgs, 'select' | 'include'> & {
      select?: StudentCountAggregateInputType | true
    }

  export interface StudentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Student that matches the filter.
     * @param {StudentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StudentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StudentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Student'> extends True ? Prisma__StudentClient<StudentGetPayload<T>> : Prisma__StudentClient<StudentGetPayload<T> | null, null>

    /**
     * Find one Student that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StudentFindUniqueOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StudentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, StudentFindUniqueOrThrowArgs>
    ): Prisma__StudentClient<StudentGetPayload<T>>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StudentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StudentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Student'> extends True ? Prisma__StudentClient<StudentGetPayload<T>> : Prisma__StudentClient<StudentGetPayload<T> | null, null>

    /**
     * Find the first Student that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StudentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, StudentFindFirstOrThrowArgs>
    ): Prisma__StudentClient<StudentGetPayload<T>>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentWithIdOnly = await prisma.student.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StudentFindManyArgs>(
      args?: SelectSubset<T, StudentFindManyArgs>
    ): Prisma.PrismaPromise<Array<StudentGetPayload<T>>>

    /**
     * Create a Student.
     * @param {StudentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
    **/
    create<T extends StudentCreateArgs>(
      args: SelectSubset<T, StudentCreateArgs>
    ): Prisma__StudentClient<StudentGetPayload<T>>

    /**
     * Create many Students.
     *     @param {StudentCreateManyArgs} args - Arguments to create many Students.
     *     @example
     *     // Create many Students
     *     const student = await prisma.student.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StudentCreateManyArgs>(
      args?: SelectSubset<T, StudentCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Student.
     * @param {StudentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
    **/
    delete<T extends StudentDeleteArgs>(
      args: SelectSubset<T, StudentDeleteArgs>
    ): Prisma__StudentClient<StudentGetPayload<T>>

    /**
     * Update one Student.
     * @param {StudentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StudentUpdateArgs>(
      args: SelectSubset<T, StudentUpdateArgs>
    ): Prisma__StudentClient<StudentGetPayload<T>>

    /**
     * Delete zero or more Students.
     * @param {StudentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StudentDeleteManyArgs>(
      args?: SelectSubset<T, StudentDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StudentUpdateManyArgs>(
      args: SelectSubset<T, StudentUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Student.
     * @param {StudentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
    **/
    upsert<T extends StudentUpsertArgs>(
      args: SelectSubset<T, StudentUpsertArgs>
    ): Prisma__StudentClient<StudentGetPayload<T>>

    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends StudentCountArgs>(
      args?: Subset<T, StudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): Prisma.PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentGroupByArgs['orderBy'] }
        : { orderBy?: StudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StudentClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    belongsToUniversity<T extends UniversityArgs= {}>(args?: Subset<T, UniversityArgs>): Prisma__UniversityClient<UniversityGetPayload<T> | Null>;

    borrowingRecords<T extends Student$borrowingRecordsArgs= {}>(args?: Subset<T, Student$borrowingRecordsArgs>): Prisma.PrismaPromise<Array<BorrowingRecordGetPayload<T>>| Null>;

    requestRecords<T extends Student$requestRecordsArgs= {}>(args?: Subset<T, Student$requestRecordsArgs>): Prisma.PrismaPromise<Array<RequestRecordGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Student base type for findUnique actions
   */
  export type StudentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findUnique
   */
  export interface StudentFindUniqueArgs extends StudentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Student findUniqueOrThrow
   */
  export type StudentFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }


  /**
   * Student base type for findFirst actions
   */
  export type StudentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: Enumerable<StudentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: Enumerable<StudentScalarFieldEnum>
  }

  /**
   * Student findFirst
   */
  export interface StudentFindFirstArgs extends StudentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Student findFirstOrThrow
   */
  export type StudentFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: Enumerable<StudentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: Enumerable<StudentScalarFieldEnum>
  }


  /**
   * Student findMany
   */
  export type StudentFindManyArgs = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: Enumerable<StudentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    distinct?: Enumerable<StudentScalarFieldEnum>
  }


  /**
   * Student create
   */
  export type StudentCreateArgs = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude | null
    /**
     * The data needed to create a Student.
     */
    data: XOR<StudentCreateInput, StudentUncheckedCreateInput>
  }


  /**
   * Student createMany
   */
  export type StudentCreateManyArgs = {
    /**
     * The data used to create many Students.
     */
    data: Enumerable<StudentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Student update
   */
  export type StudentUpdateArgs = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude | null
    /**
     * The data needed to update a Student.
     */
    data: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
    /**
     * Choose, which Student to update.
     */
    where: StudentWhereUniqueInput
  }


  /**
   * Student updateMany
   */
  export type StudentUpdateManyArgs = {
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
  }


  /**
   * Student upsert
   */
  export type StudentUpsertArgs = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude | null
    /**
     * The filter to search for the Student to update in case it exists.
     */
    where: StudentWhereUniqueInput
    /**
     * In case the Student found by the `where` argument doesn't exist, create a new Student with this data.
     */
    create: XOR<StudentCreateInput, StudentUncheckedCreateInput>
    /**
     * In case the Student was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
  }


  /**
   * Student delete
   */
  export type StudentDeleteArgs = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude | null
    /**
     * Filter which Student to delete.
     */
    where: StudentWhereUniqueInput
  }


  /**
   * Student deleteMany
   */
  export type StudentDeleteManyArgs = {
    /**
     * Filter which Students to delete
     */
    where?: StudentWhereInput
  }


  /**
   * Student.borrowingRecords
   */
  export type Student$borrowingRecordsArgs = {
    /**
     * Select specific fields to fetch from the BorrowingRecord
     */
    select?: BorrowingRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BorrowingRecordInclude | null
    where?: BorrowingRecordWhereInput
    orderBy?: Enumerable<BorrowingRecordOrderByWithRelationInput>
    cursor?: BorrowingRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BorrowingRecordScalarFieldEnum>
  }


  /**
   * Student.requestRecords
   */
  export type Student$requestRecordsArgs = {
    /**
     * Select specific fields to fetch from the RequestRecord
     */
    select?: RequestRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestRecordInclude | null
    where?: RequestRecordWhereInput
    orderBy?: Enumerable<RequestRecordOrderByWithRelationInput>
    cursor?: RequestRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RequestRecordScalarFieldEnum>
  }


  /**
   * Student without action
   */
  export type StudentArgs = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude | null
  }



  /**
   * Model BorrowingRecord
   */


  export type AggregateBorrowingRecord = {
    _count: BorrowingRecordCountAggregateOutputType | null
    _avg: BorrowingRecordAvgAggregateOutputType | null
    _sum: BorrowingRecordSumAggregateOutputType | null
    _min: BorrowingRecordMinAggregateOutputType | null
    _max: BorrowingRecordMaxAggregateOutputType | null
  }

  export type BorrowingRecordAvgAggregateOutputType = {
    id: number | null
    studentId: number | null
    bookId: number | null
  }

  export type BorrowingRecordSumAggregateOutputType = {
    id: number | null
    studentId: number | null
    bookId: number | null
  }

  export type BorrowingRecordMinAggregateOutputType = {
    id: number | null
    studentId: number | null
    bookId: number | null
    startDate: Date | null
    endDate: Date | null
    actualEndDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BorrowingRecordMaxAggregateOutputType = {
    id: number | null
    studentId: number | null
    bookId: number | null
    startDate: Date | null
    endDate: Date | null
    actualEndDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BorrowingRecordCountAggregateOutputType = {
    id: number
    studentId: number
    bookId: number
    startDate: number
    endDate: number
    actualEndDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BorrowingRecordAvgAggregateInputType = {
    id?: true
    studentId?: true
    bookId?: true
  }

  export type BorrowingRecordSumAggregateInputType = {
    id?: true
    studentId?: true
    bookId?: true
  }

  export type BorrowingRecordMinAggregateInputType = {
    id?: true
    studentId?: true
    bookId?: true
    startDate?: true
    endDate?: true
    actualEndDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BorrowingRecordMaxAggregateInputType = {
    id?: true
    studentId?: true
    bookId?: true
    startDate?: true
    endDate?: true
    actualEndDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BorrowingRecordCountAggregateInputType = {
    id?: true
    studentId?: true
    bookId?: true
    startDate?: true
    endDate?: true
    actualEndDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BorrowingRecordAggregateArgs = {
    /**
     * Filter which BorrowingRecord to aggregate.
     */
    where?: BorrowingRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BorrowingRecords to fetch.
     */
    orderBy?: Enumerable<BorrowingRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BorrowingRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BorrowingRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BorrowingRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BorrowingRecords
    **/
    _count?: true | BorrowingRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BorrowingRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BorrowingRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BorrowingRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BorrowingRecordMaxAggregateInputType
  }

  export type GetBorrowingRecordAggregateType<T extends BorrowingRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateBorrowingRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBorrowingRecord[P]>
      : GetScalarType<T[P], AggregateBorrowingRecord[P]>
  }




  export type BorrowingRecordGroupByArgs = {
    where?: BorrowingRecordWhereInput
    orderBy?: Enumerable<BorrowingRecordOrderByWithAggregationInput>
    by: BorrowingRecordScalarFieldEnum[]
    having?: BorrowingRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BorrowingRecordCountAggregateInputType | true
    _avg?: BorrowingRecordAvgAggregateInputType
    _sum?: BorrowingRecordSumAggregateInputType
    _min?: BorrowingRecordMinAggregateInputType
    _max?: BorrowingRecordMaxAggregateInputType
  }


  export type BorrowingRecordGroupByOutputType = {
    id: number
    studentId: number
    bookId: number
    startDate: Date
    endDate: Date | null
    actualEndDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: BorrowingRecordCountAggregateOutputType | null
    _avg: BorrowingRecordAvgAggregateOutputType | null
    _sum: BorrowingRecordSumAggregateOutputType | null
    _min: BorrowingRecordMinAggregateOutputType | null
    _max: BorrowingRecordMaxAggregateOutputType | null
  }

  type GetBorrowingRecordGroupByPayload<T extends BorrowingRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BorrowingRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BorrowingRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BorrowingRecordGroupByOutputType[P]>
            : GetScalarType<T[P], BorrowingRecordGroupByOutputType[P]>
        }
      >
    >


  export type BorrowingRecordSelect = {
    id?: boolean
    borrowingStudent?: boolean | StudentArgs
    studentId?: boolean
    borrowedBook?: boolean | BookArgs
    bookId?: boolean
    startDate?: boolean
    endDate?: boolean
    actualEndDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type BorrowingRecordInclude = {
    borrowingStudent?: boolean | StudentArgs
    borrowedBook?: boolean | BookArgs
  }

  export type BorrowingRecordGetPayload<S extends boolean | null | undefined | BorrowingRecordArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BorrowingRecord :
    S extends undefined ? never :
    S extends { include: any } & (BorrowingRecordArgs | BorrowingRecordFindManyArgs)
    ? BorrowingRecord  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'borrowingStudent' ? StudentGetPayload<S['include'][P]> :
        P extends 'borrowedBook' ? BookGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BorrowingRecordArgs | BorrowingRecordFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'borrowingStudent' ? StudentGetPayload<S['select'][P]> :
        P extends 'borrowedBook' ? BookGetPayload<S['select'][P]> :  P extends keyof BorrowingRecord ? BorrowingRecord[P] : never
  } 
      : BorrowingRecord


  type BorrowingRecordCountArgs = 
    Omit<BorrowingRecordFindManyArgs, 'select' | 'include'> & {
      select?: BorrowingRecordCountAggregateInputType | true
    }

  export interface BorrowingRecordDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one BorrowingRecord that matches the filter.
     * @param {BorrowingRecordFindUniqueArgs} args - Arguments to find a BorrowingRecord
     * @example
     * // Get one BorrowingRecord
     * const borrowingRecord = await prisma.borrowingRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BorrowingRecordFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BorrowingRecordFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BorrowingRecord'> extends True ? Prisma__BorrowingRecordClient<BorrowingRecordGetPayload<T>> : Prisma__BorrowingRecordClient<BorrowingRecordGetPayload<T> | null, null>

    /**
     * Find one BorrowingRecord that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BorrowingRecordFindUniqueOrThrowArgs} args - Arguments to find a BorrowingRecord
     * @example
     * // Get one BorrowingRecord
     * const borrowingRecord = await prisma.borrowingRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BorrowingRecordFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BorrowingRecordFindUniqueOrThrowArgs>
    ): Prisma__BorrowingRecordClient<BorrowingRecordGetPayload<T>>

    /**
     * Find the first BorrowingRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorrowingRecordFindFirstArgs} args - Arguments to find a BorrowingRecord
     * @example
     * // Get one BorrowingRecord
     * const borrowingRecord = await prisma.borrowingRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BorrowingRecordFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BorrowingRecordFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BorrowingRecord'> extends True ? Prisma__BorrowingRecordClient<BorrowingRecordGetPayload<T>> : Prisma__BorrowingRecordClient<BorrowingRecordGetPayload<T> | null, null>

    /**
     * Find the first BorrowingRecord that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorrowingRecordFindFirstOrThrowArgs} args - Arguments to find a BorrowingRecord
     * @example
     * // Get one BorrowingRecord
     * const borrowingRecord = await prisma.borrowingRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BorrowingRecordFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BorrowingRecordFindFirstOrThrowArgs>
    ): Prisma__BorrowingRecordClient<BorrowingRecordGetPayload<T>>

    /**
     * Find zero or more BorrowingRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorrowingRecordFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BorrowingRecords
     * const borrowingRecords = await prisma.borrowingRecord.findMany()
     * 
     * // Get first 10 BorrowingRecords
     * const borrowingRecords = await prisma.borrowingRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const borrowingRecordWithIdOnly = await prisma.borrowingRecord.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BorrowingRecordFindManyArgs>(
      args?: SelectSubset<T, BorrowingRecordFindManyArgs>
    ): Prisma.PrismaPromise<Array<BorrowingRecordGetPayload<T>>>

    /**
     * Create a BorrowingRecord.
     * @param {BorrowingRecordCreateArgs} args - Arguments to create a BorrowingRecord.
     * @example
     * // Create one BorrowingRecord
     * const BorrowingRecord = await prisma.borrowingRecord.create({
     *   data: {
     *     // ... data to create a BorrowingRecord
     *   }
     * })
     * 
    **/
    create<T extends BorrowingRecordCreateArgs>(
      args: SelectSubset<T, BorrowingRecordCreateArgs>
    ): Prisma__BorrowingRecordClient<BorrowingRecordGetPayload<T>>

    /**
     * Create many BorrowingRecords.
     *     @param {BorrowingRecordCreateManyArgs} args - Arguments to create many BorrowingRecords.
     *     @example
     *     // Create many BorrowingRecords
     *     const borrowingRecord = await prisma.borrowingRecord.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BorrowingRecordCreateManyArgs>(
      args?: SelectSubset<T, BorrowingRecordCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BorrowingRecord.
     * @param {BorrowingRecordDeleteArgs} args - Arguments to delete one BorrowingRecord.
     * @example
     * // Delete one BorrowingRecord
     * const BorrowingRecord = await prisma.borrowingRecord.delete({
     *   where: {
     *     // ... filter to delete one BorrowingRecord
     *   }
     * })
     * 
    **/
    delete<T extends BorrowingRecordDeleteArgs>(
      args: SelectSubset<T, BorrowingRecordDeleteArgs>
    ): Prisma__BorrowingRecordClient<BorrowingRecordGetPayload<T>>

    /**
     * Update one BorrowingRecord.
     * @param {BorrowingRecordUpdateArgs} args - Arguments to update one BorrowingRecord.
     * @example
     * // Update one BorrowingRecord
     * const borrowingRecord = await prisma.borrowingRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BorrowingRecordUpdateArgs>(
      args: SelectSubset<T, BorrowingRecordUpdateArgs>
    ): Prisma__BorrowingRecordClient<BorrowingRecordGetPayload<T>>

    /**
     * Delete zero or more BorrowingRecords.
     * @param {BorrowingRecordDeleteManyArgs} args - Arguments to filter BorrowingRecords to delete.
     * @example
     * // Delete a few BorrowingRecords
     * const { count } = await prisma.borrowingRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BorrowingRecordDeleteManyArgs>(
      args?: SelectSubset<T, BorrowingRecordDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BorrowingRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorrowingRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BorrowingRecords
     * const borrowingRecord = await prisma.borrowingRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BorrowingRecordUpdateManyArgs>(
      args: SelectSubset<T, BorrowingRecordUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BorrowingRecord.
     * @param {BorrowingRecordUpsertArgs} args - Arguments to update or create a BorrowingRecord.
     * @example
     * // Update or create a BorrowingRecord
     * const borrowingRecord = await prisma.borrowingRecord.upsert({
     *   create: {
     *     // ... data to create a BorrowingRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BorrowingRecord we want to update
     *   }
     * })
    **/
    upsert<T extends BorrowingRecordUpsertArgs>(
      args: SelectSubset<T, BorrowingRecordUpsertArgs>
    ): Prisma__BorrowingRecordClient<BorrowingRecordGetPayload<T>>

    /**
     * Count the number of BorrowingRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorrowingRecordCountArgs} args - Arguments to filter BorrowingRecords to count.
     * @example
     * // Count the number of BorrowingRecords
     * const count = await prisma.borrowingRecord.count({
     *   where: {
     *     // ... the filter for the BorrowingRecords we want to count
     *   }
     * })
    **/
    count<T extends BorrowingRecordCountArgs>(
      args?: Subset<T, BorrowingRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BorrowingRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BorrowingRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorrowingRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BorrowingRecordAggregateArgs>(args: Subset<T, BorrowingRecordAggregateArgs>): Prisma.PrismaPromise<GetBorrowingRecordAggregateType<T>>

    /**
     * Group by BorrowingRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorrowingRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BorrowingRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BorrowingRecordGroupByArgs['orderBy'] }
        : { orderBy?: BorrowingRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BorrowingRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBorrowingRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BorrowingRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BorrowingRecordClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    borrowingStudent<T extends StudentArgs= {}>(args?: Subset<T, StudentArgs>): Prisma__StudentClient<StudentGetPayload<T> | Null>;

    borrowedBook<T extends BookArgs= {}>(args?: Subset<T, BookArgs>): Prisma__BookClient<BookGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BorrowingRecord base type for findUnique actions
   */
  export type BorrowingRecordFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BorrowingRecord
     */
    select?: BorrowingRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BorrowingRecordInclude | null
    /**
     * Filter, which BorrowingRecord to fetch.
     */
    where: BorrowingRecordWhereUniqueInput
  }

  /**
   * BorrowingRecord findUnique
   */
  export interface BorrowingRecordFindUniqueArgs extends BorrowingRecordFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BorrowingRecord findUniqueOrThrow
   */
  export type BorrowingRecordFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BorrowingRecord
     */
    select?: BorrowingRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BorrowingRecordInclude | null
    /**
     * Filter, which BorrowingRecord to fetch.
     */
    where: BorrowingRecordWhereUniqueInput
  }


  /**
   * BorrowingRecord base type for findFirst actions
   */
  export type BorrowingRecordFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BorrowingRecord
     */
    select?: BorrowingRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BorrowingRecordInclude | null
    /**
     * Filter, which BorrowingRecord to fetch.
     */
    where?: BorrowingRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BorrowingRecords to fetch.
     */
    orderBy?: Enumerable<BorrowingRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BorrowingRecords.
     */
    cursor?: BorrowingRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BorrowingRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BorrowingRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BorrowingRecords.
     */
    distinct?: Enumerable<BorrowingRecordScalarFieldEnum>
  }

  /**
   * BorrowingRecord findFirst
   */
  export interface BorrowingRecordFindFirstArgs extends BorrowingRecordFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BorrowingRecord findFirstOrThrow
   */
  export type BorrowingRecordFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BorrowingRecord
     */
    select?: BorrowingRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BorrowingRecordInclude | null
    /**
     * Filter, which BorrowingRecord to fetch.
     */
    where?: BorrowingRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BorrowingRecords to fetch.
     */
    orderBy?: Enumerable<BorrowingRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BorrowingRecords.
     */
    cursor?: BorrowingRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BorrowingRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BorrowingRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BorrowingRecords.
     */
    distinct?: Enumerable<BorrowingRecordScalarFieldEnum>
  }


  /**
   * BorrowingRecord findMany
   */
  export type BorrowingRecordFindManyArgs = {
    /**
     * Select specific fields to fetch from the BorrowingRecord
     */
    select?: BorrowingRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BorrowingRecordInclude | null
    /**
     * Filter, which BorrowingRecords to fetch.
     */
    where?: BorrowingRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BorrowingRecords to fetch.
     */
    orderBy?: Enumerable<BorrowingRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BorrowingRecords.
     */
    cursor?: BorrowingRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BorrowingRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BorrowingRecords.
     */
    skip?: number
    distinct?: Enumerable<BorrowingRecordScalarFieldEnum>
  }


  /**
   * BorrowingRecord create
   */
  export type BorrowingRecordCreateArgs = {
    /**
     * Select specific fields to fetch from the BorrowingRecord
     */
    select?: BorrowingRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BorrowingRecordInclude | null
    /**
     * The data needed to create a BorrowingRecord.
     */
    data: XOR<BorrowingRecordCreateInput, BorrowingRecordUncheckedCreateInput>
  }


  /**
   * BorrowingRecord createMany
   */
  export type BorrowingRecordCreateManyArgs = {
    /**
     * The data used to create many BorrowingRecords.
     */
    data: Enumerable<BorrowingRecordCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BorrowingRecord update
   */
  export type BorrowingRecordUpdateArgs = {
    /**
     * Select specific fields to fetch from the BorrowingRecord
     */
    select?: BorrowingRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BorrowingRecordInclude | null
    /**
     * The data needed to update a BorrowingRecord.
     */
    data: XOR<BorrowingRecordUpdateInput, BorrowingRecordUncheckedUpdateInput>
    /**
     * Choose, which BorrowingRecord to update.
     */
    where: BorrowingRecordWhereUniqueInput
  }


  /**
   * BorrowingRecord updateMany
   */
  export type BorrowingRecordUpdateManyArgs = {
    /**
     * The data used to update BorrowingRecords.
     */
    data: XOR<BorrowingRecordUpdateManyMutationInput, BorrowingRecordUncheckedUpdateManyInput>
    /**
     * Filter which BorrowingRecords to update
     */
    where?: BorrowingRecordWhereInput
  }


  /**
   * BorrowingRecord upsert
   */
  export type BorrowingRecordUpsertArgs = {
    /**
     * Select specific fields to fetch from the BorrowingRecord
     */
    select?: BorrowingRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BorrowingRecordInclude | null
    /**
     * The filter to search for the BorrowingRecord to update in case it exists.
     */
    where: BorrowingRecordWhereUniqueInput
    /**
     * In case the BorrowingRecord found by the `where` argument doesn't exist, create a new BorrowingRecord with this data.
     */
    create: XOR<BorrowingRecordCreateInput, BorrowingRecordUncheckedCreateInput>
    /**
     * In case the BorrowingRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BorrowingRecordUpdateInput, BorrowingRecordUncheckedUpdateInput>
  }


  /**
   * BorrowingRecord delete
   */
  export type BorrowingRecordDeleteArgs = {
    /**
     * Select specific fields to fetch from the BorrowingRecord
     */
    select?: BorrowingRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BorrowingRecordInclude | null
    /**
     * Filter which BorrowingRecord to delete.
     */
    where: BorrowingRecordWhereUniqueInput
  }


  /**
   * BorrowingRecord deleteMany
   */
  export type BorrowingRecordDeleteManyArgs = {
    /**
     * Filter which BorrowingRecords to delete
     */
    where?: BorrowingRecordWhereInput
  }


  /**
   * BorrowingRecord without action
   */
  export type BorrowingRecordArgs = {
    /**
     * Select specific fields to fetch from the BorrowingRecord
     */
    select?: BorrowingRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BorrowingRecordInclude | null
  }



  /**
   * Model RequestRecord
   */


  export type AggregateRequestRecord = {
    _count: RequestRecordCountAggregateOutputType | null
    _avg: RequestRecordAvgAggregateOutputType | null
    _sum: RequestRecordSumAggregateOutputType | null
    _min: RequestRecordMinAggregateOutputType | null
    _max: RequestRecordMaxAggregateOutputType | null
  }

  export type RequestRecordAvgAggregateOutputType = {
    id: number | null
    studentId: number | null
    bookTitleId: number | null
    requestingLibraryId: number | null
    requestedLibraryId: number | null
    bookId: number | null
  }

  export type RequestRecordSumAggregateOutputType = {
    id: number | null
    studentId: number | null
    bookTitleId: number | null
    requestingLibraryId: number | null
    requestedLibraryId: number | null
    bookId: number | null
  }

  export type RequestRecordMinAggregateOutputType = {
    id: number | null
    studentId: number | null
    bookTitleId: number | null
    requestingLibraryId: number | null
    requestedLibraryId: number | null
    requestDate: Date | null
    acquiredDate: Date | null
    returnDate: Date | null
    bookId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RequestRecordMaxAggregateOutputType = {
    id: number | null
    studentId: number | null
    bookTitleId: number | null
    requestingLibraryId: number | null
    requestedLibraryId: number | null
    requestDate: Date | null
    acquiredDate: Date | null
    returnDate: Date | null
    bookId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RequestRecordCountAggregateOutputType = {
    id: number
    studentId: number
    bookTitleId: number
    requestingLibraryId: number
    requestedLibraryId: number
    requestDate: number
    acquiredDate: number
    returnDate: number
    bookId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RequestRecordAvgAggregateInputType = {
    id?: true
    studentId?: true
    bookTitleId?: true
    requestingLibraryId?: true
    requestedLibraryId?: true
    bookId?: true
  }

  export type RequestRecordSumAggregateInputType = {
    id?: true
    studentId?: true
    bookTitleId?: true
    requestingLibraryId?: true
    requestedLibraryId?: true
    bookId?: true
  }

  export type RequestRecordMinAggregateInputType = {
    id?: true
    studentId?: true
    bookTitleId?: true
    requestingLibraryId?: true
    requestedLibraryId?: true
    requestDate?: true
    acquiredDate?: true
    returnDate?: true
    bookId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RequestRecordMaxAggregateInputType = {
    id?: true
    studentId?: true
    bookTitleId?: true
    requestingLibraryId?: true
    requestedLibraryId?: true
    requestDate?: true
    acquiredDate?: true
    returnDate?: true
    bookId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RequestRecordCountAggregateInputType = {
    id?: true
    studentId?: true
    bookTitleId?: true
    requestingLibraryId?: true
    requestedLibraryId?: true
    requestDate?: true
    acquiredDate?: true
    returnDate?: true
    bookId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RequestRecordAggregateArgs = {
    /**
     * Filter which RequestRecord to aggregate.
     */
    where?: RequestRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestRecords to fetch.
     */
    orderBy?: Enumerable<RequestRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RequestRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RequestRecords
    **/
    _count?: true | RequestRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RequestRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RequestRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestRecordMaxAggregateInputType
  }

  export type GetRequestRecordAggregateType<T extends RequestRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateRequestRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequestRecord[P]>
      : GetScalarType<T[P], AggregateRequestRecord[P]>
  }




  export type RequestRecordGroupByArgs = {
    where?: RequestRecordWhereInput
    orderBy?: Enumerable<RequestRecordOrderByWithAggregationInput>
    by: RequestRecordScalarFieldEnum[]
    having?: RequestRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestRecordCountAggregateInputType | true
    _avg?: RequestRecordAvgAggregateInputType
    _sum?: RequestRecordSumAggregateInputType
    _min?: RequestRecordMinAggregateInputType
    _max?: RequestRecordMaxAggregateInputType
  }


  export type RequestRecordGroupByOutputType = {
    id: number
    studentId: number
    bookTitleId: number
    requestingLibraryId: number
    requestedLibraryId: number
    requestDate: Date
    acquiredDate: Date | null
    returnDate: Date | null
    bookId: number
    createdAt: Date
    updatedAt: Date
    _count: RequestRecordCountAggregateOutputType | null
    _avg: RequestRecordAvgAggregateOutputType | null
    _sum: RequestRecordSumAggregateOutputType | null
    _min: RequestRecordMinAggregateOutputType | null
    _max: RequestRecordMaxAggregateOutputType | null
  }

  type GetRequestRecordGroupByPayload<T extends RequestRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RequestRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequestRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequestRecordGroupByOutputType[P]>
            : GetScalarType<T[P], RequestRecordGroupByOutputType[P]>
        }
      >
    >


  export type RequestRecordSelect = {
    id?: boolean
    requestingStudent?: boolean | StudentArgs
    studentId?: boolean
    requestedBookTitle?: boolean | BookTitleArgs
    bookTitleId?: boolean
    requestingLibrary?: boolean | LibraryArgs
    requestingLibraryId?: boolean
    requestedLibrary?: boolean | LibraryArgs
    requestedLibraryId?: boolean
    requestDate?: boolean
    acquiredDate?: boolean
    returnDate?: boolean
    acquiredBook?: boolean | BookArgs
    bookId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type RequestRecordInclude = {
    requestingStudent?: boolean | StudentArgs
    requestedBookTitle?: boolean | BookTitleArgs
    requestingLibrary?: boolean | LibraryArgs
    requestedLibrary?: boolean | LibraryArgs
    acquiredBook?: boolean | BookArgs
  }

  export type RequestRecordGetPayload<S extends boolean | null | undefined | RequestRecordArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RequestRecord :
    S extends undefined ? never :
    S extends { include: any } & (RequestRecordArgs | RequestRecordFindManyArgs)
    ? RequestRecord  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'requestingStudent' ? StudentGetPayload<S['include'][P]> :
        P extends 'requestedBookTitle' ? BookTitleGetPayload<S['include'][P]> :
        P extends 'requestingLibrary' ? LibraryGetPayload<S['include'][P]> :
        P extends 'requestedLibrary' ? LibraryGetPayload<S['include'][P]> :
        P extends 'acquiredBook' ? BookGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (RequestRecordArgs | RequestRecordFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'requestingStudent' ? StudentGetPayload<S['select'][P]> :
        P extends 'requestedBookTitle' ? BookTitleGetPayload<S['select'][P]> :
        P extends 'requestingLibrary' ? LibraryGetPayload<S['select'][P]> :
        P extends 'requestedLibrary' ? LibraryGetPayload<S['select'][P]> :
        P extends 'acquiredBook' ? BookGetPayload<S['select'][P]> | null :  P extends keyof RequestRecord ? RequestRecord[P] : never
  } 
      : RequestRecord


  type RequestRecordCountArgs = 
    Omit<RequestRecordFindManyArgs, 'select' | 'include'> & {
      select?: RequestRecordCountAggregateInputType | true
    }

  export interface RequestRecordDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one RequestRecord that matches the filter.
     * @param {RequestRecordFindUniqueArgs} args - Arguments to find a RequestRecord
     * @example
     * // Get one RequestRecord
     * const requestRecord = await prisma.requestRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RequestRecordFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RequestRecordFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RequestRecord'> extends True ? Prisma__RequestRecordClient<RequestRecordGetPayload<T>> : Prisma__RequestRecordClient<RequestRecordGetPayload<T> | null, null>

    /**
     * Find one RequestRecord that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RequestRecordFindUniqueOrThrowArgs} args - Arguments to find a RequestRecord
     * @example
     * // Get one RequestRecord
     * const requestRecord = await prisma.requestRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RequestRecordFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RequestRecordFindUniqueOrThrowArgs>
    ): Prisma__RequestRecordClient<RequestRecordGetPayload<T>>

    /**
     * Find the first RequestRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestRecordFindFirstArgs} args - Arguments to find a RequestRecord
     * @example
     * // Get one RequestRecord
     * const requestRecord = await prisma.requestRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RequestRecordFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RequestRecordFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RequestRecord'> extends True ? Prisma__RequestRecordClient<RequestRecordGetPayload<T>> : Prisma__RequestRecordClient<RequestRecordGetPayload<T> | null, null>

    /**
     * Find the first RequestRecord that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestRecordFindFirstOrThrowArgs} args - Arguments to find a RequestRecord
     * @example
     * // Get one RequestRecord
     * const requestRecord = await prisma.requestRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RequestRecordFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RequestRecordFindFirstOrThrowArgs>
    ): Prisma__RequestRecordClient<RequestRecordGetPayload<T>>

    /**
     * Find zero or more RequestRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestRecordFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RequestRecords
     * const requestRecords = await prisma.requestRecord.findMany()
     * 
     * // Get first 10 RequestRecords
     * const requestRecords = await prisma.requestRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requestRecordWithIdOnly = await prisma.requestRecord.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RequestRecordFindManyArgs>(
      args?: SelectSubset<T, RequestRecordFindManyArgs>
    ): Prisma.PrismaPromise<Array<RequestRecordGetPayload<T>>>

    /**
     * Create a RequestRecord.
     * @param {RequestRecordCreateArgs} args - Arguments to create a RequestRecord.
     * @example
     * // Create one RequestRecord
     * const RequestRecord = await prisma.requestRecord.create({
     *   data: {
     *     // ... data to create a RequestRecord
     *   }
     * })
     * 
    **/
    create<T extends RequestRecordCreateArgs>(
      args: SelectSubset<T, RequestRecordCreateArgs>
    ): Prisma__RequestRecordClient<RequestRecordGetPayload<T>>

    /**
     * Create many RequestRecords.
     *     @param {RequestRecordCreateManyArgs} args - Arguments to create many RequestRecords.
     *     @example
     *     // Create many RequestRecords
     *     const requestRecord = await prisma.requestRecord.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RequestRecordCreateManyArgs>(
      args?: SelectSubset<T, RequestRecordCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RequestRecord.
     * @param {RequestRecordDeleteArgs} args - Arguments to delete one RequestRecord.
     * @example
     * // Delete one RequestRecord
     * const RequestRecord = await prisma.requestRecord.delete({
     *   where: {
     *     // ... filter to delete one RequestRecord
     *   }
     * })
     * 
    **/
    delete<T extends RequestRecordDeleteArgs>(
      args: SelectSubset<T, RequestRecordDeleteArgs>
    ): Prisma__RequestRecordClient<RequestRecordGetPayload<T>>

    /**
     * Update one RequestRecord.
     * @param {RequestRecordUpdateArgs} args - Arguments to update one RequestRecord.
     * @example
     * // Update one RequestRecord
     * const requestRecord = await prisma.requestRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RequestRecordUpdateArgs>(
      args: SelectSubset<T, RequestRecordUpdateArgs>
    ): Prisma__RequestRecordClient<RequestRecordGetPayload<T>>

    /**
     * Delete zero or more RequestRecords.
     * @param {RequestRecordDeleteManyArgs} args - Arguments to filter RequestRecords to delete.
     * @example
     * // Delete a few RequestRecords
     * const { count } = await prisma.requestRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RequestRecordDeleteManyArgs>(
      args?: SelectSubset<T, RequestRecordDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RequestRecords
     * const requestRecord = await prisma.requestRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RequestRecordUpdateManyArgs>(
      args: SelectSubset<T, RequestRecordUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RequestRecord.
     * @param {RequestRecordUpsertArgs} args - Arguments to update or create a RequestRecord.
     * @example
     * // Update or create a RequestRecord
     * const requestRecord = await prisma.requestRecord.upsert({
     *   create: {
     *     // ... data to create a RequestRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RequestRecord we want to update
     *   }
     * })
    **/
    upsert<T extends RequestRecordUpsertArgs>(
      args: SelectSubset<T, RequestRecordUpsertArgs>
    ): Prisma__RequestRecordClient<RequestRecordGetPayload<T>>

    /**
     * Count the number of RequestRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestRecordCountArgs} args - Arguments to filter RequestRecords to count.
     * @example
     * // Count the number of RequestRecords
     * const count = await prisma.requestRecord.count({
     *   where: {
     *     // ... the filter for the RequestRecords we want to count
     *   }
     * })
    **/
    count<T extends RequestRecordCountArgs>(
      args?: Subset<T, RequestRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RequestRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestRecordAggregateArgs>(args: Subset<T, RequestRecordAggregateArgs>): Prisma.PrismaPromise<GetRequestRecordAggregateType<T>>

    /**
     * Group by RequestRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequestRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequestRecordGroupByArgs['orderBy'] }
        : { orderBy?: RequestRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequestRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for RequestRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RequestRecordClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    requestingStudent<T extends StudentArgs= {}>(args?: Subset<T, StudentArgs>): Prisma__StudentClient<StudentGetPayload<T> | Null>;

    requestedBookTitle<T extends BookTitleArgs= {}>(args?: Subset<T, BookTitleArgs>): Prisma__BookTitleClient<BookTitleGetPayload<T> | Null>;

    requestingLibrary<T extends LibraryArgs= {}>(args?: Subset<T, LibraryArgs>): Prisma__LibraryClient<LibraryGetPayload<T> | Null>;

    requestedLibrary<T extends LibraryArgs= {}>(args?: Subset<T, LibraryArgs>): Prisma__LibraryClient<LibraryGetPayload<T> | Null>;

    acquiredBook<T extends BookArgs= {}>(args?: Subset<T, BookArgs>): Prisma__BookClient<BookGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * RequestRecord base type for findUnique actions
   */
  export type RequestRecordFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the RequestRecord
     */
    select?: RequestRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestRecordInclude | null
    /**
     * Filter, which RequestRecord to fetch.
     */
    where: RequestRecordWhereUniqueInput
  }

  /**
   * RequestRecord findUnique
   */
  export interface RequestRecordFindUniqueArgs extends RequestRecordFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RequestRecord findUniqueOrThrow
   */
  export type RequestRecordFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the RequestRecord
     */
    select?: RequestRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestRecordInclude | null
    /**
     * Filter, which RequestRecord to fetch.
     */
    where: RequestRecordWhereUniqueInput
  }


  /**
   * RequestRecord base type for findFirst actions
   */
  export type RequestRecordFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the RequestRecord
     */
    select?: RequestRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestRecordInclude | null
    /**
     * Filter, which RequestRecord to fetch.
     */
    where?: RequestRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestRecords to fetch.
     */
    orderBy?: Enumerable<RequestRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestRecords.
     */
    cursor?: RequestRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestRecords.
     */
    distinct?: Enumerable<RequestRecordScalarFieldEnum>
  }

  /**
   * RequestRecord findFirst
   */
  export interface RequestRecordFindFirstArgs extends RequestRecordFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RequestRecord findFirstOrThrow
   */
  export type RequestRecordFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the RequestRecord
     */
    select?: RequestRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestRecordInclude | null
    /**
     * Filter, which RequestRecord to fetch.
     */
    where?: RequestRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestRecords to fetch.
     */
    orderBy?: Enumerable<RequestRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestRecords.
     */
    cursor?: RequestRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestRecords.
     */
    distinct?: Enumerable<RequestRecordScalarFieldEnum>
  }


  /**
   * RequestRecord findMany
   */
  export type RequestRecordFindManyArgs = {
    /**
     * Select specific fields to fetch from the RequestRecord
     */
    select?: RequestRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestRecordInclude | null
    /**
     * Filter, which RequestRecords to fetch.
     */
    where?: RequestRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestRecords to fetch.
     */
    orderBy?: Enumerable<RequestRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RequestRecords.
     */
    cursor?: RequestRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestRecords.
     */
    skip?: number
    distinct?: Enumerable<RequestRecordScalarFieldEnum>
  }


  /**
   * RequestRecord create
   */
  export type RequestRecordCreateArgs = {
    /**
     * Select specific fields to fetch from the RequestRecord
     */
    select?: RequestRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestRecordInclude | null
    /**
     * The data needed to create a RequestRecord.
     */
    data: XOR<RequestRecordCreateInput, RequestRecordUncheckedCreateInput>
  }


  /**
   * RequestRecord createMany
   */
  export type RequestRecordCreateManyArgs = {
    /**
     * The data used to create many RequestRecords.
     */
    data: Enumerable<RequestRecordCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RequestRecord update
   */
  export type RequestRecordUpdateArgs = {
    /**
     * Select specific fields to fetch from the RequestRecord
     */
    select?: RequestRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestRecordInclude | null
    /**
     * The data needed to update a RequestRecord.
     */
    data: XOR<RequestRecordUpdateInput, RequestRecordUncheckedUpdateInput>
    /**
     * Choose, which RequestRecord to update.
     */
    where: RequestRecordWhereUniqueInput
  }


  /**
   * RequestRecord updateMany
   */
  export type RequestRecordUpdateManyArgs = {
    /**
     * The data used to update RequestRecords.
     */
    data: XOR<RequestRecordUpdateManyMutationInput, RequestRecordUncheckedUpdateManyInput>
    /**
     * Filter which RequestRecords to update
     */
    where?: RequestRecordWhereInput
  }


  /**
   * RequestRecord upsert
   */
  export type RequestRecordUpsertArgs = {
    /**
     * Select specific fields to fetch from the RequestRecord
     */
    select?: RequestRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestRecordInclude | null
    /**
     * The filter to search for the RequestRecord to update in case it exists.
     */
    where: RequestRecordWhereUniqueInput
    /**
     * In case the RequestRecord found by the `where` argument doesn't exist, create a new RequestRecord with this data.
     */
    create: XOR<RequestRecordCreateInput, RequestRecordUncheckedCreateInput>
    /**
     * In case the RequestRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RequestRecordUpdateInput, RequestRecordUncheckedUpdateInput>
  }


  /**
   * RequestRecord delete
   */
  export type RequestRecordDeleteArgs = {
    /**
     * Select specific fields to fetch from the RequestRecord
     */
    select?: RequestRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestRecordInclude | null
    /**
     * Filter which RequestRecord to delete.
     */
    where: RequestRecordWhereUniqueInput
  }


  /**
   * RequestRecord deleteMany
   */
  export type RequestRecordDeleteManyArgs = {
    /**
     * Filter which RequestRecords to delete
     */
    where?: RequestRecordWhereInput
  }


  /**
   * RequestRecord without action
   */
  export type RequestRecordArgs = {
    /**
     * Select specific fields to fetch from the RequestRecord
     */
    select?: RequestRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestRecordInclude | null
  }



  /**
   * Model TodoList
   */


  export type AggregateTodoList = {
    _count: TodoListCountAggregateOutputType | null
    _avg: TodoListAvgAggregateOutputType | null
    _sum: TodoListSumAggregateOutputType | null
    _min: TodoListMinAggregateOutputType | null
    _max: TodoListMaxAggregateOutputType | null
  }

  export type TodoListAvgAggregateOutputType = {
    id: number | null
  }

  export type TodoListSumAggregateOutputType = {
    id: number | null
  }

  export type TodoListMinAggregateOutputType = {
    id: number | null
    task: string | null
    status: string | null
    bgColor: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TodoListMaxAggregateOutputType = {
    id: number | null
    task: string | null
    status: string | null
    bgColor: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TodoListCountAggregateOutputType = {
    id: number
    task: number
    status: number
    bgColor: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TodoListAvgAggregateInputType = {
    id?: true
  }

  export type TodoListSumAggregateInputType = {
    id?: true
  }

  export type TodoListMinAggregateInputType = {
    id?: true
    task?: true
    status?: true
    bgColor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TodoListMaxAggregateInputType = {
    id?: true
    task?: true
    status?: true
    bgColor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TodoListCountAggregateInputType = {
    id?: true
    task?: true
    status?: true
    bgColor?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TodoListAggregateArgs = {
    /**
     * Filter which TodoList to aggregate.
     */
    where?: TodoListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TodoLists to fetch.
     */
    orderBy?: Enumerable<TodoListOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TodoListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TodoLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TodoLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TodoLists
    **/
    _count?: true | TodoListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TodoListAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TodoListSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TodoListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TodoListMaxAggregateInputType
  }

  export type GetTodoListAggregateType<T extends TodoListAggregateArgs> = {
        [P in keyof T & keyof AggregateTodoList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTodoList[P]>
      : GetScalarType<T[P], AggregateTodoList[P]>
  }




  export type TodoListGroupByArgs = {
    where?: TodoListWhereInput
    orderBy?: Enumerable<TodoListOrderByWithAggregationInput>
    by: TodoListScalarFieldEnum[]
    having?: TodoListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TodoListCountAggregateInputType | true
    _avg?: TodoListAvgAggregateInputType
    _sum?: TodoListSumAggregateInputType
    _min?: TodoListMinAggregateInputType
    _max?: TodoListMaxAggregateInputType
  }


  export type TodoListGroupByOutputType = {
    id: number
    task: string
    status: string
    bgColor: string
    createdAt: Date
    updatedAt: Date
    _count: TodoListCountAggregateOutputType | null
    _avg: TodoListAvgAggregateOutputType | null
    _sum: TodoListSumAggregateOutputType | null
    _min: TodoListMinAggregateOutputType | null
    _max: TodoListMaxAggregateOutputType | null
  }

  type GetTodoListGroupByPayload<T extends TodoListGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TodoListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TodoListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TodoListGroupByOutputType[P]>
            : GetScalarType<T[P], TodoListGroupByOutputType[P]>
        }
      >
    >


  export type TodoListSelect = {
    id?: boolean
    task?: boolean
    status?: boolean
    bgColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type TodoListGetPayload<S extends boolean | null | undefined | TodoListArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TodoList :
    S extends undefined ? never :
    S extends { include: any } & (TodoListArgs | TodoListFindManyArgs)
    ? TodoList 
    : S extends { select: any } & (TodoListArgs | TodoListFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TodoList ? TodoList[P] : never
  } 
      : TodoList


  type TodoListCountArgs = 
    Omit<TodoListFindManyArgs, 'select' | 'include'> & {
      select?: TodoListCountAggregateInputType | true
    }

  export interface TodoListDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TodoList that matches the filter.
     * @param {TodoListFindUniqueArgs} args - Arguments to find a TodoList
     * @example
     * // Get one TodoList
     * const todoList = await prisma.todoList.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TodoListFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TodoListFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TodoList'> extends True ? Prisma__TodoListClient<TodoListGetPayload<T>> : Prisma__TodoListClient<TodoListGetPayload<T> | null, null>

    /**
     * Find one TodoList that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TodoListFindUniqueOrThrowArgs} args - Arguments to find a TodoList
     * @example
     * // Get one TodoList
     * const todoList = await prisma.todoList.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TodoListFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TodoListFindUniqueOrThrowArgs>
    ): Prisma__TodoListClient<TodoListGetPayload<T>>

    /**
     * Find the first TodoList that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoListFindFirstArgs} args - Arguments to find a TodoList
     * @example
     * // Get one TodoList
     * const todoList = await prisma.todoList.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TodoListFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TodoListFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TodoList'> extends True ? Prisma__TodoListClient<TodoListGetPayload<T>> : Prisma__TodoListClient<TodoListGetPayload<T> | null, null>

    /**
     * Find the first TodoList that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoListFindFirstOrThrowArgs} args - Arguments to find a TodoList
     * @example
     * // Get one TodoList
     * const todoList = await prisma.todoList.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TodoListFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TodoListFindFirstOrThrowArgs>
    ): Prisma__TodoListClient<TodoListGetPayload<T>>

    /**
     * Find zero or more TodoLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoListFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TodoLists
     * const todoLists = await prisma.todoList.findMany()
     * 
     * // Get first 10 TodoLists
     * const todoLists = await prisma.todoList.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const todoListWithIdOnly = await prisma.todoList.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TodoListFindManyArgs>(
      args?: SelectSubset<T, TodoListFindManyArgs>
    ): Prisma.PrismaPromise<Array<TodoListGetPayload<T>>>

    /**
     * Create a TodoList.
     * @param {TodoListCreateArgs} args - Arguments to create a TodoList.
     * @example
     * // Create one TodoList
     * const TodoList = await prisma.todoList.create({
     *   data: {
     *     // ... data to create a TodoList
     *   }
     * })
     * 
    **/
    create<T extends TodoListCreateArgs>(
      args: SelectSubset<T, TodoListCreateArgs>
    ): Prisma__TodoListClient<TodoListGetPayload<T>>

    /**
     * Create many TodoLists.
     *     @param {TodoListCreateManyArgs} args - Arguments to create many TodoLists.
     *     @example
     *     // Create many TodoLists
     *     const todoList = await prisma.todoList.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TodoListCreateManyArgs>(
      args?: SelectSubset<T, TodoListCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TodoList.
     * @param {TodoListDeleteArgs} args - Arguments to delete one TodoList.
     * @example
     * // Delete one TodoList
     * const TodoList = await prisma.todoList.delete({
     *   where: {
     *     // ... filter to delete one TodoList
     *   }
     * })
     * 
    **/
    delete<T extends TodoListDeleteArgs>(
      args: SelectSubset<T, TodoListDeleteArgs>
    ): Prisma__TodoListClient<TodoListGetPayload<T>>

    /**
     * Update one TodoList.
     * @param {TodoListUpdateArgs} args - Arguments to update one TodoList.
     * @example
     * // Update one TodoList
     * const todoList = await prisma.todoList.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TodoListUpdateArgs>(
      args: SelectSubset<T, TodoListUpdateArgs>
    ): Prisma__TodoListClient<TodoListGetPayload<T>>

    /**
     * Delete zero or more TodoLists.
     * @param {TodoListDeleteManyArgs} args - Arguments to filter TodoLists to delete.
     * @example
     * // Delete a few TodoLists
     * const { count } = await prisma.todoList.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TodoListDeleteManyArgs>(
      args?: SelectSubset<T, TodoListDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TodoLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TodoLists
     * const todoList = await prisma.todoList.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TodoListUpdateManyArgs>(
      args: SelectSubset<T, TodoListUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TodoList.
     * @param {TodoListUpsertArgs} args - Arguments to update or create a TodoList.
     * @example
     * // Update or create a TodoList
     * const todoList = await prisma.todoList.upsert({
     *   create: {
     *     // ... data to create a TodoList
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TodoList we want to update
     *   }
     * })
    **/
    upsert<T extends TodoListUpsertArgs>(
      args: SelectSubset<T, TodoListUpsertArgs>
    ): Prisma__TodoListClient<TodoListGetPayload<T>>

    /**
     * Count the number of TodoLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoListCountArgs} args - Arguments to filter TodoLists to count.
     * @example
     * // Count the number of TodoLists
     * const count = await prisma.todoList.count({
     *   where: {
     *     // ... the filter for the TodoLists we want to count
     *   }
     * })
    **/
    count<T extends TodoListCountArgs>(
      args?: Subset<T, TodoListCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TodoListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TodoList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TodoListAggregateArgs>(args: Subset<T, TodoListAggregateArgs>): Prisma.PrismaPromise<GetTodoListAggregateType<T>>

    /**
     * Group by TodoList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TodoListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TodoListGroupByArgs['orderBy'] }
        : { orderBy?: TodoListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TodoListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTodoListGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TodoList.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TodoListClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TodoList base type for findUnique actions
   */
  export type TodoListFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
    /**
     * Filter, which TodoList to fetch.
     */
    where: TodoListWhereUniqueInput
  }

  /**
   * TodoList findUnique
   */
  export interface TodoListFindUniqueArgs extends TodoListFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TodoList findUniqueOrThrow
   */
  export type TodoListFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
    /**
     * Filter, which TodoList to fetch.
     */
    where: TodoListWhereUniqueInput
  }


  /**
   * TodoList base type for findFirst actions
   */
  export type TodoListFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
    /**
     * Filter, which TodoList to fetch.
     */
    where?: TodoListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TodoLists to fetch.
     */
    orderBy?: Enumerable<TodoListOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TodoLists.
     */
    cursor?: TodoListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TodoLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TodoLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TodoLists.
     */
    distinct?: Enumerable<TodoListScalarFieldEnum>
  }

  /**
   * TodoList findFirst
   */
  export interface TodoListFindFirstArgs extends TodoListFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TodoList findFirstOrThrow
   */
  export type TodoListFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
    /**
     * Filter, which TodoList to fetch.
     */
    where?: TodoListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TodoLists to fetch.
     */
    orderBy?: Enumerable<TodoListOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TodoLists.
     */
    cursor?: TodoListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TodoLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TodoLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TodoLists.
     */
    distinct?: Enumerable<TodoListScalarFieldEnum>
  }


  /**
   * TodoList findMany
   */
  export type TodoListFindManyArgs = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
    /**
     * Filter, which TodoLists to fetch.
     */
    where?: TodoListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TodoLists to fetch.
     */
    orderBy?: Enumerable<TodoListOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TodoLists.
     */
    cursor?: TodoListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TodoLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TodoLists.
     */
    skip?: number
    distinct?: Enumerable<TodoListScalarFieldEnum>
  }


  /**
   * TodoList create
   */
  export type TodoListCreateArgs = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
    /**
     * The data needed to create a TodoList.
     */
    data: XOR<TodoListCreateInput, TodoListUncheckedCreateInput>
  }


  /**
   * TodoList createMany
   */
  export type TodoListCreateManyArgs = {
    /**
     * The data used to create many TodoLists.
     */
    data: Enumerable<TodoListCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TodoList update
   */
  export type TodoListUpdateArgs = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
    /**
     * The data needed to update a TodoList.
     */
    data: XOR<TodoListUpdateInput, TodoListUncheckedUpdateInput>
    /**
     * Choose, which TodoList to update.
     */
    where: TodoListWhereUniqueInput
  }


  /**
   * TodoList updateMany
   */
  export type TodoListUpdateManyArgs = {
    /**
     * The data used to update TodoLists.
     */
    data: XOR<TodoListUpdateManyMutationInput, TodoListUncheckedUpdateManyInput>
    /**
     * Filter which TodoLists to update
     */
    where?: TodoListWhereInput
  }


  /**
   * TodoList upsert
   */
  export type TodoListUpsertArgs = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
    /**
     * The filter to search for the TodoList to update in case it exists.
     */
    where: TodoListWhereUniqueInput
    /**
     * In case the TodoList found by the `where` argument doesn't exist, create a new TodoList with this data.
     */
    create: XOR<TodoListCreateInput, TodoListUncheckedCreateInput>
    /**
     * In case the TodoList was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TodoListUpdateInput, TodoListUncheckedUpdateInput>
  }


  /**
   * TodoList delete
   */
  export type TodoListDeleteArgs = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
    /**
     * Filter which TodoList to delete.
     */
    where: TodoListWhereUniqueInput
  }


  /**
   * TodoList deleteMany
   */
  export type TodoListDeleteManyArgs = {
    /**
     * Filter which TodoLists to delete
     */
    where?: TodoListWhereInput
  }


  /**
   * TodoList without action
   */
  export type TodoListArgs = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    name: string | null
    imageUrl: string | null
    bio: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    imageUrl: string | null
    bio: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    imageUrl: number
    bio: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    imageUrl?: true
    bio?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    imageUrl?: true
    bio?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    imageUrl?: true
    bio?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: UserScalarFieldEnum[]
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: number
    name: string
    imageUrl: string
    bio: string
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    name?: boolean
    imageUrl?: boolean
    bio?: boolean
    followingUserRelations?: boolean | User$followingUserRelationsArgs
    followedUserRelations?: boolean | User$followedUserRelationsArgs
    tweets?: boolean | User$tweetsArgs
    directMessagesFrom?: boolean | User$directMessagesFromArgs
    directMessagesTo?: boolean | User$directMessagesToArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | UserCountOutputTypeArgs
  }


  export type UserInclude = {
    followingUserRelations?: boolean | User$followingUserRelationsArgs
    followedUserRelations?: boolean | User$followedUserRelationsArgs
    tweets?: boolean | User$tweetsArgs
    directMessagesFrom?: boolean | User$directMessagesFromArgs
    directMessagesTo?: boolean | User$directMessagesToArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<S extends boolean | null | undefined | UserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? User :
    S extends undefined ? never :
    S extends { include: any } & (UserArgs | UserFindManyArgs)
    ? User  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'followingUserRelations' ? Array < UserRelationGetPayload<S['include'][P]>>  :
        P extends 'followedUserRelations' ? Array < UserRelationGetPayload<S['include'][P]>>  :
        P extends 'tweets' ? Array < TweetGetPayload<S['include'][P]>>  :
        P extends 'directMessagesFrom' ? Array < DirectMessageGetPayload<S['include'][P]>>  :
        P extends 'directMessagesTo' ? Array < DirectMessageGetPayload<S['include'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserArgs | UserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'followingUserRelations' ? Array < UserRelationGetPayload<S['select'][P]>>  :
        P extends 'followedUserRelations' ? Array < UserRelationGetPayload<S['select'][P]>>  :
        P extends 'tweets' ? Array < TweetGetPayload<S['select'][P]>>  :
        P extends 'directMessagesFrom' ? Array < DirectMessageGetPayload<S['select'][P]>>  :
        P extends 'directMessagesTo' ? Array < DirectMessageGetPayload<S['select'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof User ? User[P] : never
  } 
      : User


  type UserCountArgs = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserGetPayload<T>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    followingUserRelations<T extends User$followingUserRelationsArgs= {}>(args?: Subset<T, User$followingUserRelationsArgs>): Prisma.PrismaPromise<Array<UserRelationGetPayload<T>>| Null>;

    followedUserRelations<T extends User$followedUserRelationsArgs= {}>(args?: Subset<T, User$followedUserRelationsArgs>): Prisma.PrismaPromise<Array<UserRelationGetPayload<T>>| Null>;

    tweets<T extends User$tweetsArgs= {}>(args?: Subset<T, User$tweetsArgs>): Prisma.PrismaPromise<Array<TweetGetPayload<T>>| Null>;

    directMessagesFrom<T extends User$directMessagesFromArgs= {}>(args?: Subset<T, User$directMessagesFromArgs>): Prisma.PrismaPromise<Array<DirectMessageGetPayload<T>>| Null>;

    directMessagesTo<T extends User$directMessagesToArgs= {}>(args?: Subset<T, User$directMessagesToArgs>): Prisma.PrismaPromise<Array<DirectMessageGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUnique
   */
  export interface UserFindUniqueArgs extends UserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User findFirst
   */
  export interface UserFindFirstArgs extends UserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     */
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.followingUserRelations
   */
  export type User$followingUserRelationsArgs = {
    /**
     * Select specific fields to fetch from the UserRelation
     */
    select?: UserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRelationInclude | null
    where?: UserRelationWhereInput
    orderBy?: Enumerable<UserRelationOrderByWithRelationInput>
    cursor?: UserRelationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserRelationScalarFieldEnum>
  }


  /**
   * User.followedUserRelations
   */
  export type User$followedUserRelationsArgs = {
    /**
     * Select specific fields to fetch from the UserRelation
     */
    select?: UserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRelationInclude | null
    where?: UserRelationWhereInput
    orderBy?: Enumerable<UserRelationOrderByWithRelationInput>
    cursor?: UserRelationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserRelationScalarFieldEnum>
  }


  /**
   * User.tweets
   */
  export type User$tweetsArgs = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TweetInclude | null
    where?: TweetWhereInput
    orderBy?: Enumerable<TweetOrderByWithRelationInput>
    cursor?: TweetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TweetScalarFieldEnum>
  }


  /**
   * User.directMessagesFrom
   */
  export type User$directMessagesFromArgs = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
    where?: DirectMessageWhereInput
    orderBy?: Enumerable<DirectMessageOrderByWithRelationInput>
    cursor?: DirectMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DirectMessageScalarFieldEnum>
  }


  /**
   * User.directMessagesTo
   */
  export type User$directMessagesToArgs = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
    where?: DirectMessageWhereInput
    orderBy?: Enumerable<DirectMessageOrderByWithRelationInput>
    cursor?: DirectMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DirectMessageScalarFieldEnum>
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
  }



  /**
   * Model UserRelation
   */


  export type AggregateUserRelation = {
    _count: UserRelationCountAggregateOutputType | null
    _avg: UserRelationAvgAggregateOutputType | null
    _sum: UserRelationSumAggregateOutputType | null
    _min: UserRelationMinAggregateOutputType | null
    _max: UserRelationMaxAggregateOutputType | null
  }

  export type UserRelationAvgAggregateOutputType = {
    id: number | null
    followingUserId: number | null
    followedUserId: number | null
  }

  export type UserRelationSumAggregateOutputType = {
    id: number | null
    followingUserId: number | null
    followedUserId: number | null
  }

  export type UserRelationMinAggregateOutputType = {
    id: number | null
    followingUserId: number | null
    followedUserId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserRelationMaxAggregateOutputType = {
    id: number | null
    followingUserId: number | null
    followedUserId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserRelationCountAggregateOutputType = {
    id: number
    followingUserId: number
    followedUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserRelationAvgAggregateInputType = {
    id?: true
    followingUserId?: true
    followedUserId?: true
  }

  export type UserRelationSumAggregateInputType = {
    id?: true
    followingUserId?: true
    followedUserId?: true
  }

  export type UserRelationMinAggregateInputType = {
    id?: true
    followingUserId?: true
    followedUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserRelationMaxAggregateInputType = {
    id?: true
    followingUserId?: true
    followedUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserRelationCountAggregateInputType = {
    id?: true
    followingUserId?: true
    followedUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserRelationAggregateArgs = {
    /**
     * Filter which UserRelation to aggregate.
     */
    where?: UserRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRelations to fetch.
     */
    orderBy?: Enumerable<UserRelationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRelations
    **/
    _count?: true | UserRelationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserRelationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserRelationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRelationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRelationMaxAggregateInputType
  }

  export type GetUserRelationAggregateType<T extends UserRelationAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRelation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRelation[P]>
      : GetScalarType<T[P], AggregateUserRelation[P]>
  }




  export type UserRelationGroupByArgs = {
    where?: UserRelationWhereInput
    orderBy?: Enumerable<UserRelationOrderByWithAggregationInput>
    by: UserRelationScalarFieldEnum[]
    having?: UserRelationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRelationCountAggregateInputType | true
    _avg?: UserRelationAvgAggregateInputType
    _sum?: UserRelationSumAggregateInputType
    _min?: UserRelationMinAggregateInputType
    _max?: UserRelationMaxAggregateInputType
  }


  export type UserRelationGroupByOutputType = {
    id: number
    followingUserId: number
    followedUserId: number
    createdAt: Date
    updatedAt: Date
    _count: UserRelationCountAggregateOutputType | null
    _avg: UserRelationAvgAggregateOutputType | null
    _sum: UserRelationSumAggregateOutputType | null
    _min: UserRelationMinAggregateOutputType | null
    _max: UserRelationMaxAggregateOutputType | null
  }

  type GetUserRelationGroupByPayload<T extends UserRelationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserRelationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRelationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRelationGroupByOutputType[P]>
            : GetScalarType<T[P], UserRelationGroupByOutputType[P]>
        }
      >
    >


  export type UserRelationSelect = {
    id?: boolean
    followingUser?: boolean | UserArgs
    followingUserId?: boolean
    followedUser?: boolean | UserArgs
    followedUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type UserRelationInclude = {
    followingUser?: boolean | UserArgs
    followedUser?: boolean | UserArgs
  }

  export type UserRelationGetPayload<S extends boolean | null | undefined | UserRelationArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserRelation :
    S extends undefined ? never :
    S extends { include: any } & (UserRelationArgs | UserRelationFindManyArgs)
    ? UserRelation  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'followingUser' ? UserGetPayload<S['include'][P]> :
        P extends 'followedUser' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserRelationArgs | UserRelationFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'followingUser' ? UserGetPayload<S['select'][P]> :
        P extends 'followedUser' ? UserGetPayload<S['select'][P]> :  P extends keyof UserRelation ? UserRelation[P] : never
  } 
      : UserRelation


  type UserRelationCountArgs = 
    Omit<UserRelationFindManyArgs, 'select' | 'include'> & {
      select?: UserRelationCountAggregateInputType | true
    }

  export interface UserRelationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one UserRelation that matches the filter.
     * @param {UserRelationFindUniqueArgs} args - Arguments to find a UserRelation
     * @example
     * // Get one UserRelation
     * const userRelation = await prisma.userRelation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserRelationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserRelationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserRelation'> extends True ? Prisma__UserRelationClient<UserRelationGetPayload<T>> : Prisma__UserRelationClient<UserRelationGetPayload<T> | null, null>

    /**
     * Find one UserRelation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserRelationFindUniqueOrThrowArgs} args - Arguments to find a UserRelation
     * @example
     * // Get one UserRelation
     * const userRelation = await prisma.userRelation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserRelationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserRelationFindUniqueOrThrowArgs>
    ): Prisma__UserRelationClient<UserRelationGetPayload<T>>

    /**
     * Find the first UserRelation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRelationFindFirstArgs} args - Arguments to find a UserRelation
     * @example
     * // Get one UserRelation
     * const userRelation = await prisma.userRelation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserRelationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserRelationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserRelation'> extends True ? Prisma__UserRelationClient<UserRelationGetPayload<T>> : Prisma__UserRelationClient<UserRelationGetPayload<T> | null, null>

    /**
     * Find the first UserRelation that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRelationFindFirstOrThrowArgs} args - Arguments to find a UserRelation
     * @example
     * // Get one UserRelation
     * const userRelation = await prisma.userRelation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserRelationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserRelationFindFirstOrThrowArgs>
    ): Prisma__UserRelationClient<UserRelationGetPayload<T>>

    /**
     * Find zero or more UserRelations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRelationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRelations
     * const userRelations = await prisma.userRelation.findMany()
     * 
     * // Get first 10 UserRelations
     * const userRelations = await prisma.userRelation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userRelationWithIdOnly = await prisma.userRelation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserRelationFindManyArgs>(
      args?: SelectSubset<T, UserRelationFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserRelationGetPayload<T>>>

    /**
     * Create a UserRelation.
     * @param {UserRelationCreateArgs} args - Arguments to create a UserRelation.
     * @example
     * // Create one UserRelation
     * const UserRelation = await prisma.userRelation.create({
     *   data: {
     *     // ... data to create a UserRelation
     *   }
     * })
     * 
    **/
    create<T extends UserRelationCreateArgs>(
      args: SelectSubset<T, UserRelationCreateArgs>
    ): Prisma__UserRelationClient<UserRelationGetPayload<T>>

    /**
     * Create many UserRelations.
     *     @param {UserRelationCreateManyArgs} args - Arguments to create many UserRelations.
     *     @example
     *     // Create many UserRelations
     *     const userRelation = await prisma.userRelation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserRelationCreateManyArgs>(
      args?: SelectSubset<T, UserRelationCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserRelation.
     * @param {UserRelationDeleteArgs} args - Arguments to delete one UserRelation.
     * @example
     * // Delete one UserRelation
     * const UserRelation = await prisma.userRelation.delete({
     *   where: {
     *     // ... filter to delete one UserRelation
     *   }
     * })
     * 
    **/
    delete<T extends UserRelationDeleteArgs>(
      args: SelectSubset<T, UserRelationDeleteArgs>
    ): Prisma__UserRelationClient<UserRelationGetPayload<T>>

    /**
     * Update one UserRelation.
     * @param {UserRelationUpdateArgs} args - Arguments to update one UserRelation.
     * @example
     * // Update one UserRelation
     * const userRelation = await prisma.userRelation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserRelationUpdateArgs>(
      args: SelectSubset<T, UserRelationUpdateArgs>
    ): Prisma__UserRelationClient<UserRelationGetPayload<T>>

    /**
     * Delete zero or more UserRelations.
     * @param {UserRelationDeleteManyArgs} args - Arguments to filter UserRelations to delete.
     * @example
     * // Delete a few UserRelations
     * const { count } = await prisma.userRelation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserRelationDeleteManyArgs>(
      args?: SelectSubset<T, UserRelationDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRelationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRelations
     * const userRelation = await prisma.userRelation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserRelationUpdateManyArgs>(
      args: SelectSubset<T, UserRelationUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserRelation.
     * @param {UserRelationUpsertArgs} args - Arguments to update or create a UserRelation.
     * @example
     * // Update or create a UserRelation
     * const userRelation = await prisma.userRelation.upsert({
     *   create: {
     *     // ... data to create a UserRelation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRelation we want to update
     *   }
     * })
    **/
    upsert<T extends UserRelationUpsertArgs>(
      args: SelectSubset<T, UserRelationUpsertArgs>
    ): Prisma__UserRelationClient<UserRelationGetPayload<T>>

    /**
     * Count the number of UserRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRelationCountArgs} args - Arguments to filter UserRelations to count.
     * @example
     * // Count the number of UserRelations
     * const count = await prisma.userRelation.count({
     *   where: {
     *     // ... the filter for the UserRelations we want to count
     *   }
     * })
    **/
    count<T extends UserRelationCountArgs>(
      args?: Subset<T, UserRelationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRelationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRelationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRelationAggregateArgs>(args: Subset<T, UserRelationAggregateArgs>): Prisma.PrismaPromise<GetUserRelationAggregateType<T>>

    /**
     * Group by UserRelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRelationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRelationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRelationGroupByArgs['orderBy'] }
        : { orderBy?: UserRelationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRelationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRelationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRelation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserRelationClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    followingUser<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    followedUser<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserRelation base type for findUnique actions
   */
  export type UserRelationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the UserRelation
     */
    select?: UserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRelationInclude | null
    /**
     * Filter, which UserRelation to fetch.
     */
    where: UserRelationWhereUniqueInput
  }

  /**
   * UserRelation findUnique
   */
  export interface UserRelationFindUniqueArgs extends UserRelationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserRelation findUniqueOrThrow
   */
  export type UserRelationFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserRelation
     */
    select?: UserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRelationInclude | null
    /**
     * Filter, which UserRelation to fetch.
     */
    where: UserRelationWhereUniqueInput
  }


  /**
   * UserRelation base type for findFirst actions
   */
  export type UserRelationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the UserRelation
     */
    select?: UserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRelationInclude | null
    /**
     * Filter, which UserRelation to fetch.
     */
    where?: UserRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRelations to fetch.
     */
    orderBy?: Enumerable<UserRelationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRelations.
     */
    cursor?: UserRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRelations.
     */
    distinct?: Enumerable<UserRelationScalarFieldEnum>
  }

  /**
   * UserRelation findFirst
   */
  export interface UserRelationFindFirstArgs extends UserRelationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserRelation findFirstOrThrow
   */
  export type UserRelationFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserRelation
     */
    select?: UserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRelationInclude | null
    /**
     * Filter, which UserRelation to fetch.
     */
    where?: UserRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRelations to fetch.
     */
    orderBy?: Enumerable<UserRelationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRelations.
     */
    cursor?: UserRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRelations.
     */
    distinct?: Enumerable<UserRelationScalarFieldEnum>
  }


  /**
   * UserRelation findMany
   */
  export type UserRelationFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserRelation
     */
    select?: UserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRelationInclude | null
    /**
     * Filter, which UserRelations to fetch.
     */
    where?: UserRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRelations to fetch.
     */
    orderBy?: Enumerable<UserRelationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRelations.
     */
    cursor?: UserRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRelations.
     */
    skip?: number
    distinct?: Enumerable<UserRelationScalarFieldEnum>
  }


  /**
   * UserRelation create
   */
  export type UserRelationCreateArgs = {
    /**
     * Select specific fields to fetch from the UserRelation
     */
    select?: UserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRelationInclude | null
    /**
     * The data needed to create a UserRelation.
     */
    data: XOR<UserRelationCreateInput, UserRelationUncheckedCreateInput>
  }


  /**
   * UserRelation createMany
   */
  export type UserRelationCreateManyArgs = {
    /**
     * The data used to create many UserRelations.
     */
    data: Enumerable<UserRelationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserRelation update
   */
  export type UserRelationUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserRelation
     */
    select?: UserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRelationInclude | null
    /**
     * The data needed to update a UserRelation.
     */
    data: XOR<UserRelationUpdateInput, UserRelationUncheckedUpdateInput>
    /**
     * Choose, which UserRelation to update.
     */
    where: UserRelationWhereUniqueInput
  }


  /**
   * UserRelation updateMany
   */
  export type UserRelationUpdateManyArgs = {
    /**
     * The data used to update UserRelations.
     */
    data: XOR<UserRelationUpdateManyMutationInput, UserRelationUncheckedUpdateManyInput>
    /**
     * Filter which UserRelations to update
     */
    where?: UserRelationWhereInput
  }


  /**
   * UserRelation upsert
   */
  export type UserRelationUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserRelation
     */
    select?: UserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRelationInclude | null
    /**
     * The filter to search for the UserRelation to update in case it exists.
     */
    where: UserRelationWhereUniqueInput
    /**
     * In case the UserRelation found by the `where` argument doesn't exist, create a new UserRelation with this data.
     */
    create: XOR<UserRelationCreateInput, UserRelationUncheckedCreateInput>
    /**
     * In case the UserRelation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRelationUpdateInput, UserRelationUncheckedUpdateInput>
  }


  /**
   * UserRelation delete
   */
  export type UserRelationDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserRelation
     */
    select?: UserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRelationInclude | null
    /**
     * Filter which UserRelation to delete.
     */
    where: UserRelationWhereUniqueInput
  }


  /**
   * UserRelation deleteMany
   */
  export type UserRelationDeleteManyArgs = {
    /**
     * Filter which UserRelations to delete
     */
    where?: UserRelationWhereInput
  }


  /**
   * UserRelation without action
   */
  export type UserRelationArgs = {
    /**
     * Select specific fields to fetch from the UserRelation
     */
    select?: UserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRelationInclude | null
  }



  /**
   * Model Tweet
   */


  export type AggregateTweet = {
    _count: TweetCountAggregateOutputType | null
    _avg: TweetAvgAggregateOutputType | null
    _sum: TweetSumAggregateOutputType | null
    _min: TweetMinAggregateOutputType | null
    _max: TweetMaxAggregateOutputType | null
  }

  export type TweetAvgAggregateOutputType = {
    id: number | null
    parentTweetId: number | null
    userId: number | null
  }

  export type TweetSumAggregateOutputType = {
    id: number | null
    parentTweetId: number | null
    userId: number | null
  }

  export type TweetMinAggregateOutputType = {
    id: number | null
    tweetText: string | null
    parentTweetId: number | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TweetMaxAggregateOutputType = {
    id: number | null
    tweetText: string | null
    parentTweetId: number | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TweetCountAggregateOutputType = {
    id: number
    tweetText: number
    parentTweetId: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TweetAvgAggregateInputType = {
    id?: true
    parentTweetId?: true
    userId?: true
  }

  export type TweetSumAggregateInputType = {
    id?: true
    parentTweetId?: true
    userId?: true
  }

  export type TweetMinAggregateInputType = {
    id?: true
    tweetText?: true
    parentTweetId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TweetMaxAggregateInputType = {
    id?: true
    tweetText?: true
    parentTweetId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TweetCountAggregateInputType = {
    id?: true
    tweetText?: true
    parentTweetId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TweetAggregateArgs = {
    /**
     * Filter which Tweet to aggregate.
     */
    where?: TweetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tweets to fetch.
     */
    orderBy?: Enumerable<TweetOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TweetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tweets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tweets
    **/
    _count?: true | TweetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TweetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TweetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TweetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TweetMaxAggregateInputType
  }

  export type GetTweetAggregateType<T extends TweetAggregateArgs> = {
        [P in keyof T & keyof AggregateTweet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTweet[P]>
      : GetScalarType<T[P], AggregateTweet[P]>
  }




  export type TweetGroupByArgs = {
    where?: TweetWhereInput
    orderBy?: Enumerable<TweetOrderByWithAggregationInput>
    by: TweetScalarFieldEnum[]
    having?: TweetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TweetCountAggregateInputType | true
    _avg?: TweetAvgAggregateInputType
    _sum?: TweetSumAggregateInputType
    _min?: TweetMinAggregateInputType
    _max?: TweetMaxAggregateInputType
  }


  export type TweetGroupByOutputType = {
    id: number
    tweetText: string
    parentTweetId: number | null
    userId: number
    createdAt: Date
    updatedAt: Date
    _count: TweetCountAggregateOutputType | null
    _avg: TweetAvgAggregateOutputType | null
    _sum: TweetSumAggregateOutputType | null
    _min: TweetMinAggregateOutputType | null
    _max: TweetMaxAggregateOutputType | null
  }

  type GetTweetGroupByPayload<T extends TweetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TweetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TweetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TweetGroupByOutputType[P]>
            : GetScalarType<T[P], TweetGroupByOutputType[P]>
        }
      >
    >


  export type TweetSelect = {
    id?: boolean
    tweetText?: boolean
    tweetingUser?: boolean | UserArgs
    parentTweet?: boolean | TweetArgs
    parentTweetId?: boolean
    childTweets?: boolean | Tweet$childTweetsArgs
    userId?: boolean
    hashTags?: boolean | Tweet$hashTagsArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | TweetCountOutputTypeArgs
  }


  export type TweetInclude = {
    tweetingUser?: boolean | UserArgs
    parentTweet?: boolean | TweetArgs
    childTweets?: boolean | Tweet$childTweetsArgs
    hashTags?: boolean | Tweet$hashTagsArgs
    _count?: boolean | TweetCountOutputTypeArgs
  }

  export type TweetGetPayload<S extends boolean | null | undefined | TweetArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Tweet :
    S extends undefined ? never :
    S extends { include: any } & (TweetArgs | TweetFindManyArgs)
    ? Tweet  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'tweetingUser' ? UserGetPayload<S['include'][P]> :
        P extends 'parentTweet' ? TweetGetPayload<S['include'][P]> | null :
        P extends 'childTweets' ? Array < TweetGetPayload<S['include'][P]>>  :
        P extends 'hashTags' ? Array < HashTagGetPayload<S['include'][P]>>  :
        P extends '_count' ? TweetCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TweetArgs | TweetFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'tweetingUser' ? UserGetPayload<S['select'][P]> :
        P extends 'parentTweet' ? TweetGetPayload<S['select'][P]> | null :
        P extends 'childTweets' ? Array < TweetGetPayload<S['select'][P]>>  :
        P extends 'hashTags' ? Array < HashTagGetPayload<S['select'][P]>>  :
        P extends '_count' ? TweetCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Tweet ? Tweet[P] : never
  } 
      : Tweet


  type TweetCountArgs = 
    Omit<TweetFindManyArgs, 'select' | 'include'> & {
      select?: TweetCountAggregateInputType | true
    }

  export interface TweetDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Tweet that matches the filter.
     * @param {TweetFindUniqueArgs} args - Arguments to find a Tweet
     * @example
     * // Get one Tweet
     * const tweet = await prisma.tweet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TweetFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TweetFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Tweet'> extends True ? Prisma__TweetClient<TweetGetPayload<T>> : Prisma__TweetClient<TweetGetPayload<T> | null, null>

    /**
     * Find one Tweet that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TweetFindUniqueOrThrowArgs} args - Arguments to find a Tweet
     * @example
     * // Get one Tweet
     * const tweet = await prisma.tweet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TweetFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TweetFindUniqueOrThrowArgs>
    ): Prisma__TweetClient<TweetGetPayload<T>>

    /**
     * Find the first Tweet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetFindFirstArgs} args - Arguments to find a Tweet
     * @example
     * // Get one Tweet
     * const tweet = await prisma.tweet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TweetFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TweetFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Tweet'> extends True ? Prisma__TweetClient<TweetGetPayload<T>> : Prisma__TweetClient<TweetGetPayload<T> | null, null>

    /**
     * Find the first Tweet that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetFindFirstOrThrowArgs} args - Arguments to find a Tweet
     * @example
     * // Get one Tweet
     * const tweet = await prisma.tweet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TweetFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TweetFindFirstOrThrowArgs>
    ): Prisma__TweetClient<TweetGetPayload<T>>

    /**
     * Find zero or more Tweets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tweets
     * const tweets = await prisma.tweet.findMany()
     * 
     * // Get first 10 Tweets
     * const tweets = await prisma.tweet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tweetWithIdOnly = await prisma.tweet.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TweetFindManyArgs>(
      args?: SelectSubset<T, TweetFindManyArgs>
    ): Prisma.PrismaPromise<Array<TweetGetPayload<T>>>

    /**
     * Create a Tweet.
     * @param {TweetCreateArgs} args - Arguments to create a Tweet.
     * @example
     * // Create one Tweet
     * const Tweet = await prisma.tweet.create({
     *   data: {
     *     // ... data to create a Tweet
     *   }
     * })
     * 
    **/
    create<T extends TweetCreateArgs>(
      args: SelectSubset<T, TweetCreateArgs>
    ): Prisma__TweetClient<TweetGetPayload<T>>

    /**
     * Create many Tweets.
     *     @param {TweetCreateManyArgs} args - Arguments to create many Tweets.
     *     @example
     *     // Create many Tweets
     *     const tweet = await prisma.tweet.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TweetCreateManyArgs>(
      args?: SelectSubset<T, TweetCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tweet.
     * @param {TweetDeleteArgs} args - Arguments to delete one Tweet.
     * @example
     * // Delete one Tweet
     * const Tweet = await prisma.tweet.delete({
     *   where: {
     *     // ... filter to delete one Tweet
     *   }
     * })
     * 
    **/
    delete<T extends TweetDeleteArgs>(
      args: SelectSubset<T, TweetDeleteArgs>
    ): Prisma__TweetClient<TweetGetPayload<T>>

    /**
     * Update one Tweet.
     * @param {TweetUpdateArgs} args - Arguments to update one Tweet.
     * @example
     * // Update one Tweet
     * const tweet = await prisma.tweet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TweetUpdateArgs>(
      args: SelectSubset<T, TweetUpdateArgs>
    ): Prisma__TweetClient<TweetGetPayload<T>>

    /**
     * Delete zero or more Tweets.
     * @param {TweetDeleteManyArgs} args - Arguments to filter Tweets to delete.
     * @example
     * // Delete a few Tweets
     * const { count } = await prisma.tweet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TweetDeleteManyArgs>(
      args?: SelectSubset<T, TweetDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tweets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tweets
     * const tweet = await prisma.tweet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TweetUpdateManyArgs>(
      args: SelectSubset<T, TweetUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tweet.
     * @param {TweetUpsertArgs} args - Arguments to update or create a Tweet.
     * @example
     * // Update or create a Tweet
     * const tweet = await prisma.tweet.upsert({
     *   create: {
     *     // ... data to create a Tweet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tweet we want to update
     *   }
     * })
    **/
    upsert<T extends TweetUpsertArgs>(
      args: SelectSubset<T, TweetUpsertArgs>
    ): Prisma__TweetClient<TweetGetPayload<T>>

    /**
     * Count the number of Tweets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetCountArgs} args - Arguments to filter Tweets to count.
     * @example
     * // Count the number of Tweets
     * const count = await prisma.tweet.count({
     *   where: {
     *     // ... the filter for the Tweets we want to count
     *   }
     * })
    **/
    count<T extends TweetCountArgs>(
      args?: Subset<T, TweetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TweetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tweet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TweetAggregateArgs>(args: Subset<T, TweetAggregateArgs>): Prisma.PrismaPromise<GetTweetAggregateType<T>>

    /**
     * Group by Tweet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TweetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TweetGroupByArgs['orderBy'] }
        : { orderBy?: TweetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TweetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTweetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Tweet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TweetClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    tweetingUser<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    parentTweet<T extends TweetArgs= {}>(args?: Subset<T, TweetArgs>): Prisma__TweetClient<TweetGetPayload<T> | Null>;

    childTweets<T extends Tweet$childTweetsArgs= {}>(args?: Subset<T, Tweet$childTweetsArgs>): Prisma.PrismaPromise<Array<TweetGetPayload<T>>| Null>;

    hashTags<T extends Tweet$hashTagsArgs= {}>(args?: Subset<T, Tweet$hashTagsArgs>): Prisma.PrismaPromise<Array<HashTagGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Tweet base type for findUnique actions
   */
  export type TweetFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TweetInclude | null
    /**
     * Filter, which Tweet to fetch.
     */
    where: TweetWhereUniqueInput
  }

  /**
   * Tweet findUnique
   */
  export interface TweetFindUniqueArgs extends TweetFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Tweet findUniqueOrThrow
   */
  export type TweetFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TweetInclude | null
    /**
     * Filter, which Tweet to fetch.
     */
    where: TweetWhereUniqueInput
  }


  /**
   * Tweet base type for findFirst actions
   */
  export type TweetFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TweetInclude | null
    /**
     * Filter, which Tweet to fetch.
     */
    where?: TweetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tweets to fetch.
     */
    orderBy?: Enumerable<TweetOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tweets.
     */
    cursor?: TweetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tweets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tweets.
     */
    distinct?: Enumerable<TweetScalarFieldEnum>
  }

  /**
   * Tweet findFirst
   */
  export interface TweetFindFirstArgs extends TweetFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Tweet findFirstOrThrow
   */
  export type TweetFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TweetInclude | null
    /**
     * Filter, which Tweet to fetch.
     */
    where?: TweetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tweets to fetch.
     */
    orderBy?: Enumerable<TweetOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tweets.
     */
    cursor?: TweetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tweets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tweets.
     */
    distinct?: Enumerable<TweetScalarFieldEnum>
  }


  /**
   * Tweet findMany
   */
  export type TweetFindManyArgs = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TweetInclude | null
    /**
     * Filter, which Tweets to fetch.
     */
    where?: TweetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tweets to fetch.
     */
    orderBy?: Enumerable<TweetOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tweets.
     */
    cursor?: TweetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tweets.
     */
    skip?: number
    distinct?: Enumerable<TweetScalarFieldEnum>
  }


  /**
   * Tweet create
   */
  export type TweetCreateArgs = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TweetInclude | null
    /**
     * The data needed to create a Tweet.
     */
    data: XOR<TweetCreateInput, TweetUncheckedCreateInput>
  }


  /**
   * Tweet createMany
   */
  export type TweetCreateManyArgs = {
    /**
     * The data used to create many Tweets.
     */
    data: Enumerable<TweetCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Tweet update
   */
  export type TweetUpdateArgs = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TweetInclude | null
    /**
     * The data needed to update a Tweet.
     */
    data: XOR<TweetUpdateInput, TweetUncheckedUpdateInput>
    /**
     * Choose, which Tweet to update.
     */
    where: TweetWhereUniqueInput
  }


  /**
   * Tweet updateMany
   */
  export type TweetUpdateManyArgs = {
    /**
     * The data used to update Tweets.
     */
    data: XOR<TweetUpdateManyMutationInput, TweetUncheckedUpdateManyInput>
    /**
     * Filter which Tweets to update
     */
    where?: TweetWhereInput
  }


  /**
   * Tweet upsert
   */
  export type TweetUpsertArgs = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TweetInclude | null
    /**
     * The filter to search for the Tweet to update in case it exists.
     */
    where: TweetWhereUniqueInput
    /**
     * In case the Tweet found by the `where` argument doesn't exist, create a new Tweet with this data.
     */
    create: XOR<TweetCreateInput, TweetUncheckedCreateInput>
    /**
     * In case the Tweet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TweetUpdateInput, TweetUncheckedUpdateInput>
  }


  /**
   * Tweet delete
   */
  export type TweetDeleteArgs = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TweetInclude | null
    /**
     * Filter which Tweet to delete.
     */
    where: TweetWhereUniqueInput
  }


  /**
   * Tweet deleteMany
   */
  export type TweetDeleteManyArgs = {
    /**
     * Filter which Tweets to delete
     */
    where?: TweetWhereInput
  }


  /**
   * Tweet.childTweets
   */
  export type Tweet$childTweetsArgs = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TweetInclude | null
    where?: TweetWhereInput
    orderBy?: Enumerable<TweetOrderByWithRelationInput>
    cursor?: TweetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TweetScalarFieldEnum>
  }


  /**
   * Tweet.hashTags
   */
  export type Tweet$hashTagsArgs = {
    /**
     * Select specific fields to fetch from the HashTag
     */
    select?: HashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HashTagInclude | null
    where?: HashTagWhereInput
    orderBy?: Enumerable<HashTagOrderByWithRelationInput>
    cursor?: HashTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<HashTagScalarFieldEnum>
  }


  /**
   * Tweet without action
   */
  export type TweetArgs = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TweetInclude | null
  }



  /**
   * Model HashTag
   */


  export type AggregateHashTag = {
    _count: HashTagCountAggregateOutputType | null
    _avg: HashTagAvgAggregateOutputType | null
    _sum: HashTagSumAggregateOutputType | null
    _min: HashTagMinAggregateOutputType | null
    _max: HashTagMaxAggregateOutputType | null
  }

  export type HashTagAvgAggregateOutputType = {
    id: number | null
  }

  export type HashTagSumAggregateOutputType = {
    id: number | null
  }

  export type HashTagMinAggregateOutputType = {
    id: number | null
    hashTagText: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HashTagMaxAggregateOutputType = {
    id: number | null
    hashTagText: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HashTagCountAggregateOutputType = {
    id: number
    hashTagText: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HashTagAvgAggregateInputType = {
    id?: true
  }

  export type HashTagSumAggregateInputType = {
    id?: true
  }

  export type HashTagMinAggregateInputType = {
    id?: true
    hashTagText?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HashTagMaxAggregateInputType = {
    id?: true
    hashTagText?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HashTagCountAggregateInputType = {
    id?: true
    hashTagText?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HashTagAggregateArgs = {
    /**
     * Filter which HashTag to aggregate.
     */
    where?: HashTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HashTags to fetch.
     */
    orderBy?: Enumerable<HashTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HashTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HashTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HashTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HashTags
    **/
    _count?: true | HashTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HashTagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HashTagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HashTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HashTagMaxAggregateInputType
  }

  export type GetHashTagAggregateType<T extends HashTagAggregateArgs> = {
        [P in keyof T & keyof AggregateHashTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHashTag[P]>
      : GetScalarType<T[P], AggregateHashTag[P]>
  }




  export type HashTagGroupByArgs = {
    where?: HashTagWhereInput
    orderBy?: Enumerable<HashTagOrderByWithAggregationInput>
    by: HashTagScalarFieldEnum[]
    having?: HashTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HashTagCountAggregateInputType | true
    _avg?: HashTagAvgAggregateInputType
    _sum?: HashTagSumAggregateInputType
    _min?: HashTagMinAggregateInputType
    _max?: HashTagMaxAggregateInputType
  }


  export type HashTagGroupByOutputType = {
    id: number
    hashTagText: string
    createdAt: Date
    updatedAt: Date
    _count: HashTagCountAggregateOutputType | null
    _avg: HashTagAvgAggregateOutputType | null
    _sum: HashTagSumAggregateOutputType | null
    _min: HashTagMinAggregateOutputType | null
    _max: HashTagMaxAggregateOutputType | null
  }

  type GetHashTagGroupByPayload<T extends HashTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<HashTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HashTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HashTagGroupByOutputType[P]>
            : GetScalarType<T[P], HashTagGroupByOutputType[P]>
        }
      >
    >


  export type HashTagSelect = {
    id?: boolean
    hashTagText?: boolean
    isInTweets?: boolean | HashTag$isInTweetsArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | HashTagCountOutputTypeArgs
  }


  export type HashTagInclude = {
    isInTweets?: boolean | HashTag$isInTweetsArgs
    _count?: boolean | HashTagCountOutputTypeArgs
  }

  export type HashTagGetPayload<S extends boolean | null | undefined | HashTagArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? HashTag :
    S extends undefined ? never :
    S extends { include: any } & (HashTagArgs | HashTagFindManyArgs)
    ? HashTag  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'isInTweets' ? Array < TweetGetPayload<S['include'][P]>>  :
        P extends '_count' ? HashTagCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (HashTagArgs | HashTagFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'isInTweets' ? Array < TweetGetPayload<S['select'][P]>>  :
        P extends '_count' ? HashTagCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof HashTag ? HashTag[P] : never
  } 
      : HashTag


  type HashTagCountArgs = 
    Omit<HashTagFindManyArgs, 'select' | 'include'> & {
      select?: HashTagCountAggregateInputType | true
    }

  export interface HashTagDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one HashTag that matches the filter.
     * @param {HashTagFindUniqueArgs} args - Arguments to find a HashTag
     * @example
     * // Get one HashTag
     * const hashTag = await prisma.hashTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends HashTagFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, HashTagFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'HashTag'> extends True ? Prisma__HashTagClient<HashTagGetPayload<T>> : Prisma__HashTagClient<HashTagGetPayload<T> | null, null>

    /**
     * Find one HashTag that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {HashTagFindUniqueOrThrowArgs} args - Arguments to find a HashTag
     * @example
     * // Get one HashTag
     * const hashTag = await prisma.hashTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends HashTagFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, HashTagFindUniqueOrThrowArgs>
    ): Prisma__HashTagClient<HashTagGetPayload<T>>

    /**
     * Find the first HashTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HashTagFindFirstArgs} args - Arguments to find a HashTag
     * @example
     * // Get one HashTag
     * const hashTag = await prisma.hashTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends HashTagFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, HashTagFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'HashTag'> extends True ? Prisma__HashTagClient<HashTagGetPayload<T>> : Prisma__HashTagClient<HashTagGetPayload<T> | null, null>

    /**
     * Find the first HashTag that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HashTagFindFirstOrThrowArgs} args - Arguments to find a HashTag
     * @example
     * // Get one HashTag
     * const hashTag = await prisma.hashTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends HashTagFindFirstOrThrowArgs>(
      args?: SelectSubset<T, HashTagFindFirstOrThrowArgs>
    ): Prisma__HashTagClient<HashTagGetPayload<T>>

    /**
     * Find zero or more HashTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HashTagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HashTags
     * const hashTags = await prisma.hashTag.findMany()
     * 
     * // Get first 10 HashTags
     * const hashTags = await prisma.hashTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hashTagWithIdOnly = await prisma.hashTag.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends HashTagFindManyArgs>(
      args?: SelectSubset<T, HashTagFindManyArgs>
    ): Prisma.PrismaPromise<Array<HashTagGetPayload<T>>>

    /**
     * Create a HashTag.
     * @param {HashTagCreateArgs} args - Arguments to create a HashTag.
     * @example
     * // Create one HashTag
     * const HashTag = await prisma.hashTag.create({
     *   data: {
     *     // ... data to create a HashTag
     *   }
     * })
     * 
    **/
    create<T extends HashTagCreateArgs>(
      args: SelectSubset<T, HashTagCreateArgs>
    ): Prisma__HashTagClient<HashTagGetPayload<T>>

    /**
     * Create many HashTags.
     *     @param {HashTagCreateManyArgs} args - Arguments to create many HashTags.
     *     @example
     *     // Create many HashTags
     *     const hashTag = await prisma.hashTag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends HashTagCreateManyArgs>(
      args?: SelectSubset<T, HashTagCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HashTag.
     * @param {HashTagDeleteArgs} args - Arguments to delete one HashTag.
     * @example
     * // Delete one HashTag
     * const HashTag = await prisma.hashTag.delete({
     *   where: {
     *     // ... filter to delete one HashTag
     *   }
     * })
     * 
    **/
    delete<T extends HashTagDeleteArgs>(
      args: SelectSubset<T, HashTagDeleteArgs>
    ): Prisma__HashTagClient<HashTagGetPayload<T>>

    /**
     * Update one HashTag.
     * @param {HashTagUpdateArgs} args - Arguments to update one HashTag.
     * @example
     * // Update one HashTag
     * const hashTag = await prisma.hashTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends HashTagUpdateArgs>(
      args: SelectSubset<T, HashTagUpdateArgs>
    ): Prisma__HashTagClient<HashTagGetPayload<T>>

    /**
     * Delete zero or more HashTags.
     * @param {HashTagDeleteManyArgs} args - Arguments to filter HashTags to delete.
     * @example
     * // Delete a few HashTags
     * const { count } = await prisma.hashTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends HashTagDeleteManyArgs>(
      args?: SelectSubset<T, HashTagDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HashTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HashTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HashTags
     * const hashTag = await prisma.hashTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends HashTagUpdateManyArgs>(
      args: SelectSubset<T, HashTagUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HashTag.
     * @param {HashTagUpsertArgs} args - Arguments to update or create a HashTag.
     * @example
     * // Update or create a HashTag
     * const hashTag = await prisma.hashTag.upsert({
     *   create: {
     *     // ... data to create a HashTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HashTag we want to update
     *   }
     * })
    **/
    upsert<T extends HashTagUpsertArgs>(
      args: SelectSubset<T, HashTagUpsertArgs>
    ): Prisma__HashTagClient<HashTagGetPayload<T>>

    /**
     * Count the number of HashTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HashTagCountArgs} args - Arguments to filter HashTags to count.
     * @example
     * // Count the number of HashTags
     * const count = await prisma.hashTag.count({
     *   where: {
     *     // ... the filter for the HashTags we want to count
     *   }
     * })
    **/
    count<T extends HashTagCountArgs>(
      args?: Subset<T, HashTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HashTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HashTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HashTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HashTagAggregateArgs>(args: Subset<T, HashTagAggregateArgs>): Prisma.PrismaPromise<GetHashTagAggregateType<T>>

    /**
     * Group by HashTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HashTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HashTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HashTagGroupByArgs['orderBy'] }
        : { orderBy?: HashTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HashTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHashTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for HashTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__HashTagClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    isInTweets<T extends HashTag$isInTweetsArgs= {}>(args?: Subset<T, HashTag$isInTweetsArgs>): Prisma.PrismaPromise<Array<TweetGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * HashTag base type for findUnique actions
   */
  export type HashTagFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the HashTag
     */
    select?: HashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HashTagInclude | null
    /**
     * Filter, which HashTag to fetch.
     */
    where: HashTagWhereUniqueInput
  }

  /**
   * HashTag findUnique
   */
  export interface HashTagFindUniqueArgs extends HashTagFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * HashTag findUniqueOrThrow
   */
  export type HashTagFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the HashTag
     */
    select?: HashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HashTagInclude | null
    /**
     * Filter, which HashTag to fetch.
     */
    where: HashTagWhereUniqueInput
  }


  /**
   * HashTag base type for findFirst actions
   */
  export type HashTagFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the HashTag
     */
    select?: HashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HashTagInclude | null
    /**
     * Filter, which HashTag to fetch.
     */
    where?: HashTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HashTags to fetch.
     */
    orderBy?: Enumerable<HashTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HashTags.
     */
    cursor?: HashTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HashTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HashTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HashTags.
     */
    distinct?: Enumerable<HashTagScalarFieldEnum>
  }

  /**
   * HashTag findFirst
   */
  export interface HashTagFindFirstArgs extends HashTagFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * HashTag findFirstOrThrow
   */
  export type HashTagFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the HashTag
     */
    select?: HashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HashTagInclude | null
    /**
     * Filter, which HashTag to fetch.
     */
    where?: HashTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HashTags to fetch.
     */
    orderBy?: Enumerable<HashTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HashTags.
     */
    cursor?: HashTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HashTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HashTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HashTags.
     */
    distinct?: Enumerable<HashTagScalarFieldEnum>
  }


  /**
   * HashTag findMany
   */
  export type HashTagFindManyArgs = {
    /**
     * Select specific fields to fetch from the HashTag
     */
    select?: HashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HashTagInclude | null
    /**
     * Filter, which HashTags to fetch.
     */
    where?: HashTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HashTags to fetch.
     */
    orderBy?: Enumerable<HashTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HashTags.
     */
    cursor?: HashTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HashTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HashTags.
     */
    skip?: number
    distinct?: Enumerable<HashTagScalarFieldEnum>
  }


  /**
   * HashTag create
   */
  export type HashTagCreateArgs = {
    /**
     * Select specific fields to fetch from the HashTag
     */
    select?: HashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HashTagInclude | null
    /**
     * The data needed to create a HashTag.
     */
    data: XOR<HashTagCreateInput, HashTagUncheckedCreateInput>
  }


  /**
   * HashTag createMany
   */
  export type HashTagCreateManyArgs = {
    /**
     * The data used to create many HashTags.
     */
    data: Enumerable<HashTagCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * HashTag update
   */
  export type HashTagUpdateArgs = {
    /**
     * Select specific fields to fetch from the HashTag
     */
    select?: HashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HashTagInclude | null
    /**
     * The data needed to update a HashTag.
     */
    data: XOR<HashTagUpdateInput, HashTagUncheckedUpdateInput>
    /**
     * Choose, which HashTag to update.
     */
    where: HashTagWhereUniqueInput
  }


  /**
   * HashTag updateMany
   */
  export type HashTagUpdateManyArgs = {
    /**
     * The data used to update HashTags.
     */
    data: XOR<HashTagUpdateManyMutationInput, HashTagUncheckedUpdateManyInput>
    /**
     * Filter which HashTags to update
     */
    where?: HashTagWhereInput
  }


  /**
   * HashTag upsert
   */
  export type HashTagUpsertArgs = {
    /**
     * Select specific fields to fetch from the HashTag
     */
    select?: HashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HashTagInclude | null
    /**
     * The filter to search for the HashTag to update in case it exists.
     */
    where: HashTagWhereUniqueInput
    /**
     * In case the HashTag found by the `where` argument doesn't exist, create a new HashTag with this data.
     */
    create: XOR<HashTagCreateInput, HashTagUncheckedCreateInput>
    /**
     * In case the HashTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HashTagUpdateInput, HashTagUncheckedUpdateInput>
  }


  /**
   * HashTag delete
   */
  export type HashTagDeleteArgs = {
    /**
     * Select specific fields to fetch from the HashTag
     */
    select?: HashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HashTagInclude | null
    /**
     * Filter which HashTag to delete.
     */
    where: HashTagWhereUniqueInput
  }


  /**
   * HashTag deleteMany
   */
  export type HashTagDeleteManyArgs = {
    /**
     * Filter which HashTags to delete
     */
    where?: HashTagWhereInput
  }


  /**
   * HashTag.isInTweets
   */
  export type HashTag$isInTweetsArgs = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TweetInclude | null
    where?: TweetWhereInput
    orderBy?: Enumerable<TweetOrderByWithRelationInput>
    cursor?: TweetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TweetScalarFieldEnum>
  }


  /**
   * HashTag without action
   */
  export type HashTagArgs = {
    /**
     * Select specific fields to fetch from the HashTag
     */
    select?: HashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HashTagInclude | null
  }



  /**
   * Model DirectMessage
   */


  export type AggregateDirectMessage = {
    _count: DirectMessageCountAggregateOutputType | null
    _avg: DirectMessageAvgAggregateOutputType | null
    _sum: DirectMessageSumAggregateOutputType | null
    _min: DirectMessageMinAggregateOutputType | null
    _max: DirectMessageMaxAggregateOutputType | null
  }

  export type DirectMessageAvgAggregateOutputType = {
    id: number | null
    fromUserId: number | null
    toUserId: number | null
  }

  export type DirectMessageSumAggregateOutputType = {
    id: number | null
    fromUserId: number | null
    toUserId: number | null
  }

  export type DirectMessageMinAggregateOutputType = {
    id: number | null
    dmText: string | null
    fromUserId: number | null
    toUserId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DirectMessageMaxAggregateOutputType = {
    id: number | null
    dmText: string | null
    fromUserId: number | null
    toUserId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DirectMessageCountAggregateOutputType = {
    id: number
    dmText: number
    fromUserId: number
    toUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DirectMessageAvgAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
  }

  export type DirectMessageSumAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
  }

  export type DirectMessageMinAggregateInputType = {
    id?: true
    dmText?: true
    fromUserId?: true
    toUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DirectMessageMaxAggregateInputType = {
    id?: true
    dmText?: true
    fromUserId?: true
    toUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DirectMessageCountAggregateInputType = {
    id?: true
    dmText?: true
    fromUserId?: true
    toUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DirectMessageAggregateArgs = {
    /**
     * Filter which DirectMessage to aggregate.
     */
    where?: DirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DirectMessages to fetch.
     */
    orderBy?: Enumerable<DirectMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DirectMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DirectMessages
    **/
    _count?: true | DirectMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DirectMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DirectMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DirectMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DirectMessageMaxAggregateInputType
  }

  export type GetDirectMessageAggregateType<T extends DirectMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateDirectMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDirectMessage[P]>
      : GetScalarType<T[P], AggregateDirectMessage[P]>
  }




  export type DirectMessageGroupByArgs = {
    where?: DirectMessageWhereInput
    orderBy?: Enumerable<DirectMessageOrderByWithAggregationInput>
    by: DirectMessageScalarFieldEnum[]
    having?: DirectMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DirectMessageCountAggregateInputType | true
    _avg?: DirectMessageAvgAggregateInputType
    _sum?: DirectMessageSumAggregateInputType
    _min?: DirectMessageMinAggregateInputType
    _max?: DirectMessageMaxAggregateInputType
  }


  export type DirectMessageGroupByOutputType = {
    id: number
    dmText: string
    fromUserId: number
    toUserId: number
    createdAt: Date
    updatedAt: Date
    _count: DirectMessageCountAggregateOutputType | null
    _avg: DirectMessageAvgAggregateOutputType | null
    _sum: DirectMessageSumAggregateOutputType | null
    _min: DirectMessageMinAggregateOutputType | null
    _max: DirectMessageMaxAggregateOutputType | null
  }

  type GetDirectMessageGroupByPayload<T extends DirectMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DirectMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DirectMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DirectMessageGroupByOutputType[P]>
            : GetScalarType<T[P], DirectMessageGroupByOutputType[P]>
        }
      >
    >


  export type DirectMessageSelect = {
    id?: boolean
    dmText?: boolean
    fromUser?: boolean | UserArgs
    toUser?: boolean | UserArgs
    fromUserId?: boolean
    toUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type DirectMessageInclude = {
    fromUser?: boolean | UserArgs
    toUser?: boolean | UserArgs
  }

  export type DirectMessageGetPayload<S extends boolean | null | undefined | DirectMessageArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? DirectMessage :
    S extends undefined ? never :
    S extends { include: any } & (DirectMessageArgs | DirectMessageFindManyArgs)
    ? DirectMessage  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'fromUser' ? UserGetPayload<S['include'][P]> :
        P extends 'toUser' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (DirectMessageArgs | DirectMessageFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'fromUser' ? UserGetPayload<S['select'][P]> :
        P extends 'toUser' ? UserGetPayload<S['select'][P]> :  P extends keyof DirectMessage ? DirectMessage[P] : never
  } 
      : DirectMessage


  type DirectMessageCountArgs = 
    Omit<DirectMessageFindManyArgs, 'select' | 'include'> & {
      select?: DirectMessageCountAggregateInputType | true
    }

  export interface DirectMessageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one DirectMessage that matches the filter.
     * @param {DirectMessageFindUniqueArgs} args - Arguments to find a DirectMessage
     * @example
     * // Get one DirectMessage
     * const directMessage = await prisma.directMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DirectMessageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DirectMessageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DirectMessage'> extends True ? Prisma__DirectMessageClient<DirectMessageGetPayload<T>> : Prisma__DirectMessageClient<DirectMessageGetPayload<T> | null, null>

    /**
     * Find one DirectMessage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DirectMessageFindUniqueOrThrowArgs} args - Arguments to find a DirectMessage
     * @example
     * // Get one DirectMessage
     * const directMessage = await prisma.directMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DirectMessageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DirectMessageFindUniqueOrThrowArgs>
    ): Prisma__DirectMessageClient<DirectMessageGetPayload<T>>

    /**
     * Find the first DirectMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageFindFirstArgs} args - Arguments to find a DirectMessage
     * @example
     * // Get one DirectMessage
     * const directMessage = await prisma.directMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DirectMessageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DirectMessageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DirectMessage'> extends True ? Prisma__DirectMessageClient<DirectMessageGetPayload<T>> : Prisma__DirectMessageClient<DirectMessageGetPayload<T> | null, null>

    /**
     * Find the first DirectMessage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageFindFirstOrThrowArgs} args - Arguments to find a DirectMessage
     * @example
     * // Get one DirectMessage
     * const directMessage = await prisma.directMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DirectMessageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DirectMessageFindFirstOrThrowArgs>
    ): Prisma__DirectMessageClient<DirectMessageGetPayload<T>>

    /**
     * Find zero or more DirectMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DirectMessages
     * const directMessages = await prisma.directMessage.findMany()
     * 
     * // Get first 10 DirectMessages
     * const directMessages = await prisma.directMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const directMessageWithIdOnly = await prisma.directMessage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DirectMessageFindManyArgs>(
      args?: SelectSubset<T, DirectMessageFindManyArgs>
    ): Prisma.PrismaPromise<Array<DirectMessageGetPayload<T>>>

    /**
     * Create a DirectMessage.
     * @param {DirectMessageCreateArgs} args - Arguments to create a DirectMessage.
     * @example
     * // Create one DirectMessage
     * const DirectMessage = await prisma.directMessage.create({
     *   data: {
     *     // ... data to create a DirectMessage
     *   }
     * })
     * 
    **/
    create<T extends DirectMessageCreateArgs>(
      args: SelectSubset<T, DirectMessageCreateArgs>
    ): Prisma__DirectMessageClient<DirectMessageGetPayload<T>>

    /**
     * Create many DirectMessages.
     *     @param {DirectMessageCreateManyArgs} args - Arguments to create many DirectMessages.
     *     @example
     *     // Create many DirectMessages
     *     const directMessage = await prisma.directMessage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DirectMessageCreateManyArgs>(
      args?: SelectSubset<T, DirectMessageCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DirectMessage.
     * @param {DirectMessageDeleteArgs} args - Arguments to delete one DirectMessage.
     * @example
     * // Delete one DirectMessage
     * const DirectMessage = await prisma.directMessage.delete({
     *   where: {
     *     // ... filter to delete one DirectMessage
     *   }
     * })
     * 
    **/
    delete<T extends DirectMessageDeleteArgs>(
      args: SelectSubset<T, DirectMessageDeleteArgs>
    ): Prisma__DirectMessageClient<DirectMessageGetPayload<T>>

    /**
     * Update one DirectMessage.
     * @param {DirectMessageUpdateArgs} args - Arguments to update one DirectMessage.
     * @example
     * // Update one DirectMessage
     * const directMessage = await prisma.directMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DirectMessageUpdateArgs>(
      args: SelectSubset<T, DirectMessageUpdateArgs>
    ): Prisma__DirectMessageClient<DirectMessageGetPayload<T>>

    /**
     * Delete zero or more DirectMessages.
     * @param {DirectMessageDeleteManyArgs} args - Arguments to filter DirectMessages to delete.
     * @example
     * // Delete a few DirectMessages
     * const { count } = await prisma.directMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DirectMessageDeleteManyArgs>(
      args?: SelectSubset<T, DirectMessageDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DirectMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DirectMessages
     * const directMessage = await prisma.directMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DirectMessageUpdateManyArgs>(
      args: SelectSubset<T, DirectMessageUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DirectMessage.
     * @param {DirectMessageUpsertArgs} args - Arguments to update or create a DirectMessage.
     * @example
     * // Update or create a DirectMessage
     * const directMessage = await prisma.directMessage.upsert({
     *   create: {
     *     // ... data to create a DirectMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DirectMessage we want to update
     *   }
     * })
    **/
    upsert<T extends DirectMessageUpsertArgs>(
      args: SelectSubset<T, DirectMessageUpsertArgs>
    ): Prisma__DirectMessageClient<DirectMessageGetPayload<T>>

    /**
     * Count the number of DirectMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageCountArgs} args - Arguments to filter DirectMessages to count.
     * @example
     * // Count the number of DirectMessages
     * const count = await prisma.directMessage.count({
     *   where: {
     *     // ... the filter for the DirectMessages we want to count
     *   }
     * })
    **/
    count<T extends DirectMessageCountArgs>(
      args?: Subset<T, DirectMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DirectMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DirectMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DirectMessageAggregateArgs>(args: Subset<T, DirectMessageAggregateArgs>): Prisma.PrismaPromise<GetDirectMessageAggregateType<T>>

    /**
     * Group by DirectMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DirectMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DirectMessageGroupByArgs['orderBy'] }
        : { orderBy?: DirectMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DirectMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDirectMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for DirectMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DirectMessageClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    fromUser<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    toUser<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * DirectMessage base type for findUnique actions
   */
  export type DirectMessageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
    /**
     * Filter, which DirectMessage to fetch.
     */
    where: DirectMessageWhereUniqueInput
  }

  /**
   * DirectMessage findUnique
   */
  export interface DirectMessageFindUniqueArgs extends DirectMessageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DirectMessage findUniqueOrThrow
   */
  export type DirectMessageFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
    /**
     * Filter, which DirectMessage to fetch.
     */
    where: DirectMessageWhereUniqueInput
  }


  /**
   * DirectMessage base type for findFirst actions
   */
  export type DirectMessageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
    /**
     * Filter, which DirectMessage to fetch.
     */
    where?: DirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DirectMessages to fetch.
     */
    orderBy?: Enumerable<DirectMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DirectMessages.
     */
    cursor?: DirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DirectMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DirectMessages.
     */
    distinct?: Enumerable<DirectMessageScalarFieldEnum>
  }

  /**
   * DirectMessage findFirst
   */
  export interface DirectMessageFindFirstArgs extends DirectMessageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DirectMessage findFirstOrThrow
   */
  export type DirectMessageFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
    /**
     * Filter, which DirectMessage to fetch.
     */
    where?: DirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DirectMessages to fetch.
     */
    orderBy?: Enumerable<DirectMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DirectMessages.
     */
    cursor?: DirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DirectMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DirectMessages.
     */
    distinct?: Enumerable<DirectMessageScalarFieldEnum>
  }


  /**
   * DirectMessage findMany
   */
  export type DirectMessageFindManyArgs = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
    /**
     * Filter, which DirectMessages to fetch.
     */
    where?: DirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DirectMessages to fetch.
     */
    orderBy?: Enumerable<DirectMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DirectMessages.
     */
    cursor?: DirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DirectMessages.
     */
    skip?: number
    distinct?: Enumerable<DirectMessageScalarFieldEnum>
  }


  /**
   * DirectMessage create
   */
  export type DirectMessageCreateArgs = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
    /**
     * The data needed to create a DirectMessage.
     */
    data: XOR<DirectMessageCreateInput, DirectMessageUncheckedCreateInput>
  }


  /**
   * DirectMessage createMany
   */
  export type DirectMessageCreateManyArgs = {
    /**
     * The data used to create many DirectMessages.
     */
    data: Enumerable<DirectMessageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DirectMessage update
   */
  export type DirectMessageUpdateArgs = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
    /**
     * The data needed to update a DirectMessage.
     */
    data: XOR<DirectMessageUpdateInput, DirectMessageUncheckedUpdateInput>
    /**
     * Choose, which DirectMessage to update.
     */
    where: DirectMessageWhereUniqueInput
  }


  /**
   * DirectMessage updateMany
   */
  export type DirectMessageUpdateManyArgs = {
    /**
     * The data used to update DirectMessages.
     */
    data: XOR<DirectMessageUpdateManyMutationInput, DirectMessageUncheckedUpdateManyInput>
    /**
     * Filter which DirectMessages to update
     */
    where?: DirectMessageWhereInput
  }


  /**
   * DirectMessage upsert
   */
  export type DirectMessageUpsertArgs = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
    /**
     * The filter to search for the DirectMessage to update in case it exists.
     */
    where: DirectMessageWhereUniqueInput
    /**
     * In case the DirectMessage found by the `where` argument doesn't exist, create a new DirectMessage with this data.
     */
    create: XOR<DirectMessageCreateInput, DirectMessageUncheckedCreateInput>
    /**
     * In case the DirectMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DirectMessageUpdateInput, DirectMessageUncheckedUpdateInput>
  }


  /**
   * DirectMessage delete
   */
  export type DirectMessageDeleteArgs = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
    /**
     * Filter which DirectMessage to delete.
     */
    where: DirectMessageWhereUniqueInput
  }


  /**
   * DirectMessage deleteMany
   */
  export type DirectMessageDeleteManyArgs = {
    /**
     * Filter which DirectMessages to delete
     */
    where?: DirectMessageWhereInput
  }


  /**
   * DirectMessage without action
   */
  export type DirectMessageArgs = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
  }



  /**
   * Model YouTubeUser
   */


  export type AggregateYouTubeUser = {
    _count: YouTubeUserCountAggregateOutputType | null
    _avg: YouTubeUserAvgAggregateOutputType | null
    _sum: YouTubeUserSumAggregateOutputType | null
    _min: YouTubeUserMinAggregateOutputType | null
    _max: YouTubeUserMaxAggregateOutputType | null
  }

  export type YouTubeUserAvgAggregateOutputType = {
    id: number | null
  }

  export type YouTubeUserSumAggregateOutputType = {
    id: number | null
  }

  export type YouTubeUserMinAggregateOutputType = {
    id: number | null
    name: string | null
    profileImageUrl: string | null
    bio: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type YouTubeUserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    profileImageUrl: string | null
    bio: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type YouTubeUserCountAggregateOutputType = {
    id: number
    name: number
    profileImageUrl: number
    bio: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type YouTubeUserAvgAggregateInputType = {
    id?: true
  }

  export type YouTubeUserSumAggregateInputType = {
    id?: true
  }

  export type YouTubeUserMinAggregateInputType = {
    id?: true
    name?: true
    profileImageUrl?: true
    bio?: true
    createdAt?: true
    updatedAt?: true
  }

  export type YouTubeUserMaxAggregateInputType = {
    id?: true
    name?: true
    profileImageUrl?: true
    bio?: true
    createdAt?: true
    updatedAt?: true
  }

  export type YouTubeUserCountAggregateInputType = {
    id?: true
    name?: true
    profileImageUrl?: true
    bio?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type YouTubeUserAggregateArgs = {
    /**
     * Filter which YouTubeUser to aggregate.
     */
    where?: YouTubeUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YouTubeUsers to fetch.
     */
    orderBy?: Enumerable<YouTubeUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YouTubeUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YouTubeUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YouTubeUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YouTubeUsers
    **/
    _count?: true | YouTubeUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YouTubeUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YouTubeUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YouTubeUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YouTubeUserMaxAggregateInputType
  }

  export type GetYouTubeUserAggregateType<T extends YouTubeUserAggregateArgs> = {
        [P in keyof T & keyof AggregateYouTubeUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYouTubeUser[P]>
      : GetScalarType<T[P], AggregateYouTubeUser[P]>
  }




  export type YouTubeUserGroupByArgs = {
    where?: YouTubeUserWhereInput
    orderBy?: Enumerable<YouTubeUserOrderByWithAggregationInput>
    by: YouTubeUserScalarFieldEnum[]
    having?: YouTubeUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YouTubeUserCountAggregateInputType | true
    _avg?: YouTubeUserAvgAggregateInputType
    _sum?: YouTubeUserSumAggregateInputType
    _min?: YouTubeUserMinAggregateInputType
    _max?: YouTubeUserMaxAggregateInputType
  }


  export type YouTubeUserGroupByOutputType = {
    id: number
    name: string
    profileImageUrl: string | null
    bio: string | null
    createdAt: Date
    updatedAt: Date
    _count: YouTubeUserCountAggregateOutputType | null
    _avg: YouTubeUserAvgAggregateOutputType | null
    _sum: YouTubeUserSumAggregateOutputType | null
    _min: YouTubeUserMinAggregateOutputType | null
    _max: YouTubeUserMaxAggregateOutputType | null
  }

  type GetYouTubeUserGroupByPayload<T extends YouTubeUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<YouTubeUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YouTubeUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YouTubeUserGroupByOutputType[P]>
            : GetScalarType<T[P], YouTubeUserGroupByOutputType[P]>
        }
      >
    >


  export type YouTubeUserSelect = {
    id?: boolean
    name?: boolean
    profileImageUrl?: boolean
    bio?: boolean
    adminOfChannels?: boolean | YouTubeUser$adminOfChannelsArgs
    usersToChannelswithRoles?: boolean | YouTubeUser$usersToChannelswithRolesArgs
    subscribingToChannels?: boolean | YouTubeUser$subscribingToChannelsArgs
    reactedVideos?: boolean | YouTubeUser$reactedVideosArgs
    usersToVideosWithReactions?: boolean | YouTubeUser$usersToVideosWithReactionsArgs
    videoComments?: boolean | YouTubeUser$videoCommentsArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | YouTubeUserCountOutputTypeArgs
  }


  export type YouTubeUserInclude = {
    adminOfChannels?: boolean | YouTubeUser$adminOfChannelsArgs
    usersToChannelswithRoles?: boolean | YouTubeUser$usersToChannelswithRolesArgs
    subscribingToChannels?: boolean | YouTubeUser$subscribingToChannelsArgs
    reactedVideos?: boolean | YouTubeUser$reactedVideosArgs
    usersToVideosWithReactions?: boolean | YouTubeUser$usersToVideosWithReactionsArgs
    videoComments?: boolean | YouTubeUser$videoCommentsArgs
    _count?: boolean | YouTubeUserCountOutputTypeArgs
  }

  export type YouTubeUserGetPayload<S extends boolean | null | undefined | YouTubeUserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YouTubeUser :
    S extends undefined ? never :
    S extends { include: any } & (YouTubeUserArgs | YouTubeUserFindManyArgs)
    ? YouTubeUser  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'adminOfChannels' ? Array < ChannelGetPayload<S['include'][P]>>  :
        P extends 'usersToChannelswithRoles' ? Array < UserToChannelwithRoleGetPayload<S['include'][P]>>  :
        P extends 'subscribingToChannels' ? Array < ChannelGetPayload<S['include'][P]>>  :
        P extends 'reactedVideos' ? Array < VideoGetPayload<S['include'][P]>>  :
        P extends 'usersToVideosWithReactions' ? Array < UserToVideoWithReactionGetPayload<S['include'][P]>>  :
        P extends 'videoComments' ? Array < VideoCommentGetPayload<S['include'][P]>>  :
        P extends '_count' ? YouTubeUserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (YouTubeUserArgs | YouTubeUserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'adminOfChannels' ? Array < ChannelGetPayload<S['select'][P]>>  :
        P extends 'usersToChannelswithRoles' ? Array < UserToChannelwithRoleGetPayload<S['select'][P]>>  :
        P extends 'subscribingToChannels' ? Array < ChannelGetPayload<S['select'][P]>>  :
        P extends 'reactedVideos' ? Array < VideoGetPayload<S['select'][P]>>  :
        P extends 'usersToVideosWithReactions' ? Array < UserToVideoWithReactionGetPayload<S['select'][P]>>  :
        P extends 'videoComments' ? Array < VideoCommentGetPayload<S['select'][P]>>  :
        P extends '_count' ? YouTubeUserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof YouTubeUser ? YouTubeUser[P] : never
  } 
      : YouTubeUser


  type YouTubeUserCountArgs = 
    Omit<YouTubeUserFindManyArgs, 'select' | 'include'> & {
      select?: YouTubeUserCountAggregateInputType | true
    }

  export interface YouTubeUserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one YouTubeUser that matches the filter.
     * @param {YouTubeUserFindUniqueArgs} args - Arguments to find a YouTubeUser
     * @example
     * // Get one YouTubeUser
     * const youTubeUser = await prisma.youTubeUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends YouTubeUserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, YouTubeUserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'YouTubeUser'> extends True ? Prisma__YouTubeUserClient<YouTubeUserGetPayload<T>> : Prisma__YouTubeUserClient<YouTubeUserGetPayload<T> | null, null>

    /**
     * Find one YouTubeUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {YouTubeUserFindUniqueOrThrowArgs} args - Arguments to find a YouTubeUser
     * @example
     * // Get one YouTubeUser
     * const youTubeUser = await prisma.youTubeUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends YouTubeUserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, YouTubeUserFindUniqueOrThrowArgs>
    ): Prisma__YouTubeUserClient<YouTubeUserGetPayload<T>>

    /**
     * Find the first YouTubeUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YouTubeUserFindFirstArgs} args - Arguments to find a YouTubeUser
     * @example
     * // Get one YouTubeUser
     * const youTubeUser = await prisma.youTubeUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends YouTubeUserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, YouTubeUserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'YouTubeUser'> extends True ? Prisma__YouTubeUserClient<YouTubeUserGetPayload<T>> : Prisma__YouTubeUserClient<YouTubeUserGetPayload<T> | null, null>

    /**
     * Find the first YouTubeUser that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YouTubeUserFindFirstOrThrowArgs} args - Arguments to find a YouTubeUser
     * @example
     * // Get one YouTubeUser
     * const youTubeUser = await prisma.youTubeUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends YouTubeUserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, YouTubeUserFindFirstOrThrowArgs>
    ): Prisma__YouTubeUserClient<YouTubeUserGetPayload<T>>

    /**
     * Find zero or more YouTubeUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YouTubeUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YouTubeUsers
     * const youTubeUsers = await prisma.youTubeUser.findMany()
     * 
     * // Get first 10 YouTubeUsers
     * const youTubeUsers = await prisma.youTubeUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const youTubeUserWithIdOnly = await prisma.youTubeUser.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends YouTubeUserFindManyArgs>(
      args?: SelectSubset<T, YouTubeUserFindManyArgs>
    ): Prisma.PrismaPromise<Array<YouTubeUserGetPayload<T>>>

    /**
     * Create a YouTubeUser.
     * @param {YouTubeUserCreateArgs} args - Arguments to create a YouTubeUser.
     * @example
     * // Create one YouTubeUser
     * const YouTubeUser = await prisma.youTubeUser.create({
     *   data: {
     *     // ... data to create a YouTubeUser
     *   }
     * })
     * 
    **/
    create<T extends YouTubeUserCreateArgs>(
      args: SelectSubset<T, YouTubeUserCreateArgs>
    ): Prisma__YouTubeUserClient<YouTubeUserGetPayload<T>>

    /**
     * Create many YouTubeUsers.
     *     @param {YouTubeUserCreateManyArgs} args - Arguments to create many YouTubeUsers.
     *     @example
     *     // Create many YouTubeUsers
     *     const youTubeUser = await prisma.youTubeUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends YouTubeUserCreateManyArgs>(
      args?: SelectSubset<T, YouTubeUserCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a YouTubeUser.
     * @param {YouTubeUserDeleteArgs} args - Arguments to delete one YouTubeUser.
     * @example
     * // Delete one YouTubeUser
     * const YouTubeUser = await prisma.youTubeUser.delete({
     *   where: {
     *     // ... filter to delete one YouTubeUser
     *   }
     * })
     * 
    **/
    delete<T extends YouTubeUserDeleteArgs>(
      args: SelectSubset<T, YouTubeUserDeleteArgs>
    ): Prisma__YouTubeUserClient<YouTubeUserGetPayload<T>>

    /**
     * Update one YouTubeUser.
     * @param {YouTubeUserUpdateArgs} args - Arguments to update one YouTubeUser.
     * @example
     * // Update one YouTubeUser
     * const youTubeUser = await prisma.youTubeUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends YouTubeUserUpdateArgs>(
      args: SelectSubset<T, YouTubeUserUpdateArgs>
    ): Prisma__YouTubeUserClient<YouTubeUserGetPayload<T>>

    /**
     * Delete zero or more YouTubeUsers.
     * @param {YouTubeUserDeleteManyArgs} args - Arguments to filter YouTubeUsers to delete.
     * @example
     * // Delete a few YouTubeUsers
     * const { count } = await prisma.youTubeUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends YouTubeUserDeleteManyArgs>(
      args?: SelectSubset<T, YouTubeUserDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YouTubeUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YouTubeUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YouTubeUsers
     * const youTubeUser = await prisma.youTubeUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends YouTubeUserUpdateManyArgs>(
      args: SelectSubset<T, YouTubeUserUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one YouTubeUser.
     * @param {YouTubeUserUpsertArgs} args - Arguments to update or create a YouTubeUser.
     * @example
     * // Update or create a YouTubeUser
     * const youTubeUser = await prisma.youTubeUser.upsert({
     *   create: {
     *     // ... data to create a YouTubeUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YouTubeUser we want to update
     *   }
     * })
    **/
    upsert<T extends YouTubeUserUpsertArgs>(
      args: SelectSubset<T, YouTubeUserUpsertArgs>
    ): Prisma__YouTubeUserClient<YouTubeUserGetPayload<T>>

    /**
     * Count the number of YouTubeUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YouTubeUserCountArgs} args - Arguments to filter YouTubeUsers to count.
     * @example
     * // Count the number of YouTubeUsers
     * const count = await prisma.youTubeUser.count({
     *   where: {
     *     // ... the filter for the YouTubeUsers we want to count
     *   }
     * })
    **/
    count<T extends YouTubeUserCountArgs>(
      args?: Subset<T, YouTubeUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YouTubeUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YouTubeUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YouTubeUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YouTubeUserAggregateArgs>(args: Subset<T, YouTubeUserAggregateArgs>): Prisma.PrismaPromise<GetYouTubeUserAggregateType<T>>

    /**
     * Group by YouTubeUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YouTubeUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YouTubeUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YouTubeUserGroupByArgs['orderBy'] }
        : { orderBy?: YouTubeUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YouTubeUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYouTubeUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for YouTubeUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__YouTubeUserClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    adminOfChannels<T extends YouTubeUser$adminOfChannelsArgs= {}>(args?: Subset<T, YouTubeUser$adminOfChannelsArgs>): Prisma.PrismaPromise<Array<ChannelGetPayload<T>>| Null>;

    usersToChannelswithRoles<T extends YouTubeUser$usersToChannelswithRolesArgs= {}>(args?: Subset<T, YouTubeUser$usersToChannelswithRolesArgs>): Prisma.PrismaPromise<Array<UserToChannelwithRoleGetPayload<T>>| Null>;

    subscribingToChannels<T extends YouTubeUser$subscribingToChannelsArgs= {}>(args?: Subset<T, YouTubeUser$subscribingToChannelsArgs>): Prisma.PrismaPromise<Array<ChannelGetPayload<T>>| Null>;

    reactedVideos<T extends YouTubeUser$reactedVideosArgs= {}>(args?: Subset<T, YouTubeUser$reactedVideosArgs>): Prisma.PrismaPromise<Array<VideoGetPayload<T>>| Null>;

    usersToVideosWithReactions<T extends YouTubeUser$usersToVideosWithReactionsArgs= {}>(args?: Subset<T, YouTubeUser$usersToVideosWithReactionsArgs>): Prisma.PrismaPromise<Array<UserToVideoWithReactionGetPayload<T>>| Null>;

    videoComments<T extends YouTubeUser$videoCommentsArgs= {}>(args?: Subset<T, YouTubeUser$videoCommentsArgs>): Prisma.PrismaPromise<Array<VideoCommentGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * YouTubeUser base type for findUnique actions
   */
  export type YouTubeUserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the YouTubeUser
     */
    select?: YouTubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YouTubeUserInclude | null
    /**
     * Filter, which YouTubeUser to fetch.
     */
    where: YouTubeUserWhereUniqueInput
  }

  /**
   * YouTubeUser findUnique
   */
  export interface YouTubeUserFindUniqueArgs extends YouTubeUserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YouTubeUser findUniqueOrThrow
   */
  export type YouTubeUserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YouTubeUser
     */
    select?: YouTubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YouTubeUserInclude | null
    /**
     * Filter, which YouTubeUser to fetch.
     */
    where: YouTubeUserWhereUniqueInput
  }


  /**
   * YouTubeUser base type for findFirst actions
   */
  export type YouTubeUserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the YouTubeUser
     */
    select?: YouTubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YouTubeUserInclude | null
    /**
     * Filter, which YouTubeUser to fetch.
     */
    where?: YouTubeUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YouTubeUsers to fetch.
     */
    orderBy?: Enumerable<YouTubeUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YouTubeUsers.
     */
    cursor?: YouTubeUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YouTubeUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YouTubeUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YouTubeUsers.
     */
    distinct?: Enumerable<YouTubeUserScalarFieldEnum>
  }

  /**
   * YouTubeUser findFirst
   */
  export interface YouTubeUserFindFirstArgs extends YouTubeUserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YouTubeUser findFirstOrThrow
   */
  export type YouTubeUserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YouTubeUser
     */
    select?: YouTubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YouTubeUserInclude | null
    /**
     * Filter, which YouTubeUser to fetch.
     */
    where?: YouTubeUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YouTubeUsers to fetch.
     */
    orderBy?: Enumerable<YouTubeUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YouTubeUsers.
     */
    cursor?: YouTubeUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YouTubeUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YouTubeUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YouTubeUsers.
     */
    distinct?: Enumerable<YouTubeUserScalarFieldEnum>
  }


  /**
   * YouTubeUser findMany
   */
  export type YouTubeUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the YouTubeUser
     */
    select?: YouTubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YouTubeUserInclude | null
    /**
     * Filter, which YouTubeUsers to fetch.
     */
    where?: YouTubeUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YouTubeUsers to fetch.
     */
    orderBy?: Enumerable<YouTubeUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YouTubeUsers.
     */
    cursor?: YouTubeUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YouTubeUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YouTubeUsers.
     */
    skip?: number
    distinct?: Enumerable<YouTubeUserScalarFieldEnum>
  }


  /**
   * YouTubeUser create
   */
  export type YouTubeUserCreateArgs = {
    /**
     * Select specific fields to fetch from the YouTubeUser
     */
    select?: YouTubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YouTubeUserInclude | null
    /**
     * The data needed to create a YouTubeUser.
     */
    data: XOR<YouTubeUserCreateInput, YouTubeUserUncheckedCreateInput>
  }


  /**
   * YouTubeUser createMany
   */
  export type YouTubeUserCreateManyArgs = {
    /**
     * The data used to create many YouTubeUsers.
     */
    data: Enumerable<YouTubeUserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * YouTubeUser update
   */
  export type YouTubeUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the YouTubeUser
     */
    select?: YouTubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YouTubeUserInclude | null
    /**
     * The data needed to update a YouTubeUser.
     */
    data: XOR<YouTubeUserUpdateInput, YouTubeUserUncheckedUpdateInput>
    /**
     * Choose, which YouTubeUser to update.
     */
    where: YouTubeUserWhereUniqueInput
  }


  /**
   * YouTubeUser updateMany
   */
  export type YouTubeUserUpdateManyArgs = {
    /**
     * The data used to update YouTubeUsers.
     */
    data: XOR<YouTubeUserUpdateManyMutationInput, YouTubeUserUncheckedUpdateManyInput>
    /**
     * Filter which YouTubeUsers to update
     */
    where?: YouTubeUserWhereInput
  }


  /**
   * YouTubeUser upsert
   */
  export type YouTubeUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the YouTubeUser
     */
    select?: YouTubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YouTubeUserInclude | null
    /**
     * The filter to search for the YouTubeUser to update in case it exists.
     */
    where: YouTubeUserWhereUniqueInput
    /**
     * In case the YouTubeUser found by the `where` argument doesn't exist, create a new YouTubeUser with this data.
     */
    create: XOR<YouTubeUserCreateInput, YouTubeUserUncheckedCreateInput>
    /**
     * In case the YouTubeUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YouTubeUserUpdateInput, YouTubeUserUncheckedUpdateInput>
  }


  /**
   * YouTubeUser delete
   */
  export type YouTubeUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the YouTubeUser
     */
    select?: YouTubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YouTubeUserInclude | null
    /**
     * Filter which YouTubeUser to delete.
     */
    where: YouTubeUserWhereUniqueInput
  }


  /**
   * YouTubeUser deleteMany
   */
  export type YouTubeUserDeleteManyArgs = {
    /**
     * Filter which YouTubeUsers to delete
     */
    where?: YouTubeUserWhereInput
  }


  /**
   * YouTubeUser.adminOfChannels
   */
  export type YouTubeUser$adminOfChannelsArgs = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChannelInclude | null
    where?: ChannelWhereInput
    orderBy?: Enumerable<ChannelOrderByWithRelationInput>
    cursor?: ChannelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ChannelScalarFieldEnum>
  }


  /**
   * YouTubeUser.usersToChannelswithRoles
   */
  export type YouTubeUser$usersToChannelswithRolesArgs = {
    /**
     * Select specific fields to fetch from the UserToChannelwithRole
     */
    select?: UserToChannelwithRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToChannelwithRoleInclude | null
    where?: UserToChannelwithRoleWhereInput
    orderBy?: Enumerable<UserToChannelwithRoleOrderByWithRelationInput>
    cursor?: UserToChannelwithRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserToChannelwithRoleScalarFieldEnum>
  }


  /**
   * YouTubeUser.subscribingToChannels
   */
  export type YouTubeUser$subscribingToChannelsArgs = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChannelInclude | null
    where?: ChannelWhereInput
    orderBy?: Enumerable<ChannelOrderByWithRelationInput>
    cursor?: ChannelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ChannelScalarFieldEnum>
  }


  /**
   * YouTubeUser.reactedVideos
   */
  export type YouTubeUser$reactedVideosArgs = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude | null
    where?: VideoWhereInput
    orderBy?: Enumerable<VideoOrderByWithRelationInput>
    cursor?: VideoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<VideoScalarFieldEnum>
  }


  /**
   * YouTubeUser.usersToVideosWithReactions
   */
  export type YouTubeUser$usersToVideosWithReactionsArgs = {
    /**
     * Select specific fields to fetch from the UserToVideoWithReaction
     */
    select?: UserToVideoWithReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToVideoWithReactionInclude | null
    where?: UserToVideoWithReactionWhereInput
    orderBy?: Enumerable<UserToVideoWithReactionOrderByWithRelationInput>
    cursor?: UserToVideoWithReactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserToVideoWithReactionScalarFieldEnum>
  }


  /**
   * YouTubeUser.videoComments
   */
  export type YouTubeUser$videoCommentsArgs = {
    /**
     * Select specific fields to fetch from the VideoComment
     */
    select?: VideoCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoCommentInclude | null
    where?: VideoCommentWhereInput
    orderBy?: Enumerable<VideoCommentOrderByWithRelationInput>
    cursor?: VideoCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<VideoCommentScalarFieldEnum>
  }


  /**
   * YouTubeUser without action
   */
  export type YouTubeUserArgs = {
    /**
     * Select specific fields to fetch from the YouTubeUser
     */
    select?: YouTubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YouTubeUserInclude | null
  }



  /**
   * Model Channel
   */


  export type AggregateChannel = {
    _count: ChannelCountAggregateOutputType | null
    _avg: ChannelAvgAggregateOutputType | null
    _sum: ChannelSumAggregateOutputType | null
    _min: ChannelMinAggregateOutputType | null
    _max: ChannelMaxAggregateOutputType | null
  }

  export type ChannelAvgAggregateOutputType = {
    id: number | null
  }

  export type ChannelSumAggregateOutputType = {
    id: number | null
  }

  export type ChannelMinAggregateOutputType = {
    id: number | null
    name: string | null
    profileImageUrl: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChannelMaxAggregateOutputType = {
    id: number | null
    name: string | null
    profileImageUrl: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChannelCountAggregateOutputType = {
    id: number
    name: number
    profileImageUrl: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChannelAvgAggregateInputType = {
    id?: true
  }

  export type ChannelSumAggregateInputType = {
    id?: true
  }

  export type ChannelMinAggregateInputType = {
    id?: true
    name?: true
    profileImageUrl?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChannelMaxAggregateInputType = {
    id?: true
    name?: true
    profileImageUrl?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChannelCountAggregateInputType = {
    id?: true
    name?: true
    profileImageUrl?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChannelAggregateArgs = {
    /**
     * Filter which Channel to aggregate.
     */
    where?: ChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Channels to fetch.
     */
    orderBy?: Enumerable<ChannelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Channels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Channels
    **/
    _count?: true | ChannelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChannelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChannelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChannelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChannelMaxAggregateInputType
  }

  export type GetChannelAggregateType<T extends ChannelAggregateArgs> = {
        [P in keyof T & keyof AggregateChannel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChannel[P]>
      : GetScalarType<T[P], AggregateChannel[P]>
  }




  export type ChannelGroupByArgs = {
    where?: ChannelWhereInput
    orderBy?: Enumerable<ChannelOrderByWithAggregationInput>
    by: ChannelScalarFieldEnum[]
    having?: ChannelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChannelCountAggregateInputType | true
    _avg?: ChannelAvgAggregateInputType
    _sum?: ChannelSumAggregateInputType
    _min?: ChannelMinAggregateInputType
    _max?: ChannelMaxAggregateInputType
  }


  export type ChannelGroupByOutputType = {
    id: number
    name: string
    profileImageUrl: string | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: ChannelCountAggregateOutputType | null
    _avg: ChannelAvgAggregateOutputType | null
    _sum: ChannelSumAggregateOutputType | null
    _min: ChannelMinAggregateOutputType | null
    _max: ChannelMaxAggregateOutputType | null
  }

  type GetChannelGroupByPayload<T extends ChannelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ChannelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChannelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChannelGroupByOutputType[P]>
            : GetScalarType<T[P], ChannelGroupByOutputType[P]>
        }
      >
    >


  export type ChannelSelect = {
    id?: boolean
    name?: boolean
    profileImageUrl?: boolean
    description?: boolean
    adminUsers?: boolean | Channel$adminUsersArgs
    subscribedUsers?: boolean | Channel$subscribedUsersArgs
    usersToChannelswithRoles?: boolean | Channel$usersToChannelswithRolesArgs
    owningVideos?: boolean | Channel$owningVideosArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | ChannelCountOutputTypeArgs
  }


  export type ChannelInclude = {
    adminUsers?: boolean | Channel$adminUsersArgs
    subscribedUsers?: boolean | Channel$subscribedUsersArgs
    usersToChannelswithRoles?: boolean | Channel$usersToChannelswithRolesArgs
    owningVideos?: boolean | Channel$owningVideosArgs
    _count?: boolean | ChannelCountOutputTypeArgs
  }

  export type ChannelGetPayload<S extends boolean | null | undefined | ChannelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Channel :
    S extends undefined ? never :
    S extends { include: any } & (ChannelArgs | ChannelFindManyArgs)
    ? Channel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'adminUsers' ? Array < YouTubeUserGetPayload<S['include'][P]>>  :
        P extends 'subscribedUsers' ? Array < YouTubeUserGetPayload<S['include'][P]>>  :
        P extends 'usersToChannelswithRoles' ? Array < UserToChannelwithRoleGetPayload<S['include'][P]>>  :
        P extends 'owningVideos' ? Array < VideoGetPayload<S['include'][P]>>  :
        P extends '_count' ? ChannelCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ChannelArgs | ChannelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'adminUsers' ? Array < YouTubeUserGetPayload<S['select'][P]>>  :
        P extends 'subscribedUsers' ? Array < YouTubeUserGetPayload<S['select'][P]>>  :
        P extends 'usersToChannelswithRoles' ? Array < UserToChannelwithRoleGetPayload<S['select'][P]>>  :
        P extends 'owningVideos' ? Array < VideoGetPayload<S['select'][P]>>  :
        P extends '_count' ? ChannelCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Channel ? Channel[P] : never
  } 
      : Channel


  type ChannelCountArgs = 
    Omit<ChannelFindManyArgs, 'select' | 'include'> & {
      select?: ChannelCountAggregateInputType | true
    }

  export interface ChannelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Channel that matches the filter.
     * @param {ChannelFindUniqueArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ChannelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ChannelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Channel'> extends True ? Prisma__ChannelClient<ChannelGetPayload<T>> : Prisma__ChannelClient<ChannelGetPayload<T> | null, null>

    /**
     * Find one Channel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ChannelFindUniqueOrThrowArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ChannelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ChannelFindUniqueOrThrowArgs>
    ): Prisma__ChannelClient<ChannelGetPayload<T>>

    /**
     * Find the first Channel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelFindFirstArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ChannelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ChannelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Channel'> extends True ? Prisma__ChannelClient<ChannelGetPayload<T>> : Prisma__ChannelClient<ChannelGetPayload<T> | null, null>

    /**
     * Find the first Channel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelFindFirstOrThrowArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ChannelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ChannelFindFirstOrThrowArgs>
    ): Prisma__ChannelClient<ChannelGetPayload<T>>

    /**
     * Find zero or more Channels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Channels
     * const channels = await prisma.channel.findMany()
     * 
     * // Get first 10 Channels
     * const channels = await prisma.channel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const channelWithIdOnly = await prisma.channel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ChannelFindManyArgs>(
      args?: SelectSubset<T, ChannelFindManyArgs>
    ): Prisma.PrismaPromise<Array<ChannelGetPayload<T>>>

    /**
     * Create a Channel.
     * @param {ChannelCreateArgs} args - Arguments to create a Channel.
     * @example
     * // Create one Channel
     * const Channel = await prisma.channel.create({
     *   data: {
     *     // ... data to create a Channel
     *   }
     * })
     * 
    **/
    create<T extends ChannelCreateArgs>(
      args: SelectSubset<T, ChannelCreateArgs>
    ): Prisma__ChannelClient<ChannelGetPayload<T>>

    /**
     * Create many Channels.
     *     @param {ChannelCreateManyArgs} args - Arguments to create many Channels.
     *     @example
     *     // Create many Channels
     *     const channel = await prisma.channel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ChannelCreateManyArgs>(
      args?: SelectSubset<T, ChannelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Channel.
     * @param {ChannelDeleteArgs} args - Arguments to delete one Channel.
     * @example
     * // Delete one Channel
     * const Channel = await prisma.channel.delete({
     *   where: {
     *     // ... filter to delete one Channel
     *   }
     * })
     * 
    **/
    delete<T extends ChannelDeleteArgs>(
      args: SelectSubset<T, ChannelDeleteArgs>
    ): Prisma__ChannelClient<ChannelGetPayload<T>>

    /**
     * Update one Channel.
     * @param {ChannelUpdateArgs} args - Arguments to update one Channel.
     * @example
     * // Update one Channel
     * const channel = await prisma.channel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ChannelUpdateArgs>(
      args: SelectSubset<T, ChannelUpdateArgs>
    ): Prisma__ChannelClient<ChannelGetPayload<T>>

    /**
     * Delete zero or more Channels.
     * @param {ChannelDeleteManyArgs} args - Arguments to filter Channels to delete.
     * @example
     * // Delete a few Channels
     * const { count } = await prisma.channel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ChannelDeleteManyArgs>(
      args?: SelectSubset<T, ChannelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Channels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Channels
     * const channel = await prisma.channel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ChannelUpdateManyArgs>(
      args: SelectSubset<T, ChannelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Channel.
     * @param {ChannelUpsertArgs} args - Arguments to update or create a Channel.
     * @example
     * // Update or create a Channel
     * const channel = await prisma.channel.upsert({
     *   create: {
     *     // ... data to create a Channel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Channel we want to update
     *   }
     * })
    **/
    upsert<T extends ChannelUpsertArgs>(
      args: SelectSubset<T, ChannelUpsertArgs>
    ): Prisma__ChannelClient<ChannelGetPayload<T>>

    /**
     * Count the number of Channels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelCountArgs} args - Arguments to filter Channels to count.
     * @example
     * // Count the number of Channels
     * const count = await prisma.channel.count({
     *   where: {
     *     // ... the filter for the Channels we want to count
     *   }
     * })
    **/
    count<T extends ChannelCountArgs>(
      args?: Subset<T, ChannelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChannelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Channel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChannelAggregateArgs>(args: Subset<T, ChannelAggregateArgs>): Prisma.PrismaPromise<GetChannelAggregateType<T>>

    /**
     * Group by Channel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChannelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChannelGroupByArgs['orderBy'] }
        : { orderBy?: ChannelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChannelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChannelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Channel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ChannelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    adminUsers<T extends Channel$adminUsersArgs= {}>(args?: Subset<T, Channel$adminUsersArgs>): Prisma.PrismaPromise<Array<YouTubeUserGetPayload<T>>| Null>;

    subscribedUsers<T extends Channel$subscribedUsersArgs= {}>(args?: Subset<T, Channel$subscribedUsersArgs>): Prisma.PrismaPromise<Array<YouTubeUserGetPayload<T>>| Null>;

    usersToChannelswithRoles<T extends Channel$usersToChannelswithRolesArgs= {}>(args?: Subset<T, Channel$usersToChannelswithRolesArgs>): Prisma.PrismaPromise<Array<UserToChannelwithRoleGetPayload<T>>| Null>;

    owningVideos<T extends Channel$owningVideosArgs= {}>(args?: Subset<T, Channel$owningVideosArgs>): Prisma.PrismaPromise<Array<VideoGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Channel base type for findUnique actions
   */
  export type ChannelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChannelInclude | null
    /**
     * Filter, which Channel to fetch.
     */
    where: ChannelWhereUniqueInput
  }

  /**
   * Channel findUnique
   */
  export interface ChannelFindUniqueArgs extends ChannelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Channel findUniqueOrThrow
   */
  export type ChannelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChannelInclude | null
    /**
     * Filter, which Channel to fetch.
     */
    where: ChannelWhereUniqueInput
  }


  /**
   * Channel base type for findFirst actions
   */
  export type ChannelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChannelInclude | null
    /**
     * Filter, which Channel to fetch.
     */
    where?: ChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Channels to fetch.
     */
    orderBy?: Enumerable<ChannelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Channels.
     */
    cursor?: ChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Channels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Channels.
     */
    distinct?: Enumerable<ChannelScalarFieldEnum>
  }

  /**
   * Channel findFirst
   */
  export interface ChannelFindFirstArgs extends ChannelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Channel findFirstOrThrow
   */
  export type ChannelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChannelInclude | null
    /**
     * Filter, which Channel to fetch.
     */
    where?: ChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Channels to fetch.
     */
    orderBy?: Enumerable<ChannelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Channels.
     */
    cursor?: ChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Channels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Channels.
     */
    distinct?: Enumerable<ChannelScalarFieldEnum>
  }


  /**
   * Channel findMany
   */
  export type ChannelFindManyArgs = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChannelInclude | null
    /**
     * Filter, which Channels to fetch.
     */
    where?: ChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Channels to fetch.
     */
    orderBy?: Enumerable<ChannelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Channels.
     */
    cursor?: ChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Channels.
     */
    skip?: number
    distinct?: Enumerable<ChannelScalarFieldEnum>
  }


  /**
   * Channel create
   */
  export type ChannelCreateArgs = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChannelInclude | null
    /**
     * The data needed to create a Channel.
     */
    data: XOR<ChannelCreateInput, ChannelUncheckedCreateInput>
  }


  /**
   * Channel createMany
   */
  export type ChannelCreateManyArgs = {
    /**
     * The data used to create many Channels.
     */
    data: Enumerable<ChannelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Channel update
   */
  export type ChannelUpdateArgs = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChannelInclude | null
    /**
     * The data needed to update a Channel.
     */
    data: XOR<ChannelUpdateInput, ChannelUncheckedUpdateInput>
    /**
     * Choose, which Channel to update.
     */
    where: ChannelWhereUniqueInput
  }


  /**
   * Channel updateMany
   */
  export type ChannelUpdateManyArgs = {
    /**
     * The data used to update Channels.
     */
    data: XOR<ChannelUpdateManyMutationInput, ChannelUncheckedUpdateManyInput>
    /**
     * Filter which Channels to update
     */
    where?: ChannelWhereInput
  }


  /**
   * Channel upsert
   */
  export type ChannelUpsertArgs = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChannelInclude | null
    /**
     * The filter to search for the Channel to update in case it exists.
     */
    where: ChannelWhereUniqueInput
    /**
     * In case the Channel found by the `where` argument doesn't exist, create a new Channel with this data.
     */
    create: XOR<ChannelCreateInput, ChannelUncheckedCreateInput>
    /**
     * In case the Channel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChannelUpdateInput, ChannelUncheckedUpdateInput>
  }


  /**
   * Channel delete
   */
  export type ChannelDeleteArgs = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChannelInclude | null
    /**
     * Filter which Channel to delete.
     */
    where: ChannelWhereUniqueInput
  }


  /**
   * Channel deleteMany
   */
  export type ChannelDeleteManyArgs = {
    /**
     * Filter which Channels to delete
     */
    where?: ChannelWhereInput
  }


  /**
   * Channel.adminUsers
   */
  export type Channel$adminUsersArgs = {
    /**
     * Select specific fields to fetch from the YouTubeUser
     */
    select?: YouTubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YouTubeUserInclude | null
    where?: YouTubeUserWhereInput
    orderBy?: Enumerable<YouTubeUserOrderByWithRelationInput>
    cursor?: YouTubeUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YouTubeUserScalarFieldEnum>
  }


  /**
   * Channel.subscribedUsers
   */
  export type Channel$subscribedUsersArgs = {
    /**
     * Select specific fields to fetch from the YouTubeUser
     */
    select?: YouTubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YouTubeUserInclude | null
    where?: YouTubeUserWhereInput
    orderBy?: Enumerable<YouTubeUserOrderByWithRelationInput>
    cursor?: YouTubeUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YouTubeUserScalarFieldEnum>
  }


  /**
   * Channel.usersToChannelswithRoles
   */
  export type Channel$usersToChannelswithRolesArgs = {
    /**
     * Select specific fields to fetch from the UserToChannelwithRole
     */
    select?: UserToChannelwithRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToChannelwithRoleInclude | null
    where?: UserToChannelwithRoleWhereInput
    orderBy?: Enumerable<UserToChannelwithRoleOrderByWithRelationInput>
    cursor?: UserToChannelwithRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserToChannelwithRoleScalarFieldEnum>
  }


  /**
   * Channel.owningVideos
   */
  export type Channel$owningVideosArgs = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude | null
    where?: VideoWhereInput
    orderBy?: Enumerable<VideoOrderByWithRelationInput>
    cursor?: VideoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<VideoScalarFieldEnum>
  }


  /**
   * Channel without action
   */
  export type ChannelArgs = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChannelInclude | null
  }



  /**
   * Model UserToChannelwithRole
   */


  export type AggregateUserToChannelwithRole = {
    _count: UserToChannelwithRoleCountAggregateOutputType | null
    _avg: UserToChannelwithRoleAvgAggregateOutputType | null
    _sum: UserToChannelwithRoleSumAggregateOutputType | null
    _min: UserToChannelwithRoleMinAggregateOutputType | null
    _max: UserToChannelwithRoleMaxAggregateOutputType | null
  }

  export type UserToChannelwithRoleAvgAggregateOutputType = {
    id: number | null
    youTubeUserId: number | null
    channelId: number | null
  }

  export type UserToChannelwithRoleSumAggregateOutputType = {
    id: number | null
    youTubeUserId: number | null
    channelId: number | null
  }

  export type UserToChannelwithRoleMinAggregateOutputType = {
    id: number | null
    youTubeUserId: number | null
    channelId: number | null
    role: RoleEnum | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserToChannelwithRoleMaxAggregateOutputType = {
    id: number | null
    youTubeUserId: number | null
    channelId: number | null
    role: RoleEnum | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserToChannelwithRoleCountAggregateOutputType = {
    id: number
    youTubeUserId: number
    channelId: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserToChannelwithRoleAvgAggregateInputType = {
    id?: true
    youTubeUserId?: true
    channelId?: true
  }

  export type UserToChannelwithRoleSumAggregateInputType = {
    id?: true
    youTubeUserId?: true
    channelId?: true
  }

  export type UserToChannelwithRoleMinAggregateInputType = {
    id?: true
    youTubeUserId?: true
    channelId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserToChannelwithRoleMaxAggregateInputType = {
    id?: true
    youTubeUserId?: true
    channelId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserToChannelwithRoleCountAggregateInputType = {
    id?: true
    youTubeUserId?: true
    channelId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserToChannelwithRoleAggregateArgs = {
    /**
     * Filter which UserToChannelwithRole to aggregate.
     */
    where?: UserToChannelwithRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToChannelwithRoles to fetch.
     */
    orderBy?: Enumerable<UserToChannelwithRoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserToChannelwithRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToChannelwithRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToChannelwithRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserToChannelwithRoles
    **/
    _count?: true | UserToChannelwithRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserToChannelwithRoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserToChannelwithRoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserToChannelwithRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserToChannelwithRoleMaxAggregateInputType
  }

  export type GetUserToChannelwithRoleAggregateType<T extends UserToChannelwithRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserToChannelwithRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserToChannelwithRole[P]>
      : GetScalarType<T[P], AggregateUserToChannelwithRole[P]>
  }




  export type UserToChannelwithRoleGroupByArgs = {
    where?: UserToChannelwithRoleWhereInput
    orderBy?: Enumerable<UserToChannelwithRoleOrderByWithAggregationInput>
    by: UserToChannelwithRoleScalarFieldEnum[]
    having?: UserToChannelwithRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserToChannelwithRoleCountAggregateInputType | true
    _avg?: UserToChannelwithRoleAvgAggregateInputType
    _sum?: UserToChannelwithRoleSumAggregateInputType
    _min?: UserToChannelwithRoleMinAggregateInputType
    _max?: UserToChannelwithRoleMaxAggregateInputType
  }


  export type UserToChannelwithRoleGroupByOutputType = {
    id: number
    youTubeUserId: number
    channelId: number
    role: RoleEnum
    createdAt: Date
    updatedAt: Date
    _count: UserToChannelwithRoleCountAggregateOutputType | null
    _avg: UserToChannelwithRoleAvgAggregateOutputType | null
    _sum: UserToChannelwithRoleSumAggregateOutputType | null
    _min: UserToChannelwithRoleMinAggregateOutputType | null
    _max: UserToChannelwithRoleMaxAggregateOutputType | null
  }

  type GetUserToChannelwithRoleGroupByPayload<T extends UserToChannelwithRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserToChannelwithRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserToChannelwithRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserToChannelwithRoleGroupByOutputType[P]>
            : GetScalarType<T[P], UserToChannelwithRoleGroupByOutputType[P]>
        }
      >
    >


  export type UserToChannelwithRoleSelect = {
    id?: boolean
    user?: boolean | YouTubeUserArgs
    youTubeUserId?: boolean
    channel?: boolean | ChannelArgs
    channelId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type UserToChannelwithRoleInclude = {
    user?: boolean | YouTubeUserArgs
    channel?: boolean | ChannelArgs
  }

  export type UserToChannelwithRoleGetPayload<S extends boolean | null | undefined | UserToChannelwithRoleArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserToChannelwithRole :
    S extends undefined ? never :
    S extends { include: any } & (UserToChannelwithRoleArgs | UserToChannelwithRoleFindManyArgs)
    ? UserToChannelwithRole  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? YouTubeUserGetPayload<S['include'][P]> :
        P extends 'channel' ? ChannelGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserToChannelwithRoleArgs | UserToChannelwithRoleFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? YouTubeUserGetPayload<S['select'][P]> :
        P extends 'channel' ? ChannelGetPayload<S['select'][P]> :  P extends keyof UserToChannelwithRole ? UserToChannelwithRole[P] : never
  } 
      : UserToChannelwithRole


  type UserToChannelwithRoleCountArgs = 
    Omit<UserToChannelwithRoleFindManyArgs, 'select' | 'include'> & {
      select?: UserToChannelwithRoleCountAggregateInputType | true
    }

  export interface UserToChannelwithRoleDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one UserToChannelwithRole that matches the filter.
     * @param {UserToChannelwithRoleFindUniqueArgs} args - Arguments to find a UserToChannelwithRole
     * @example
     * // Get one UserToChannelwithRole
     * const userToChannelwithRole = await prisma.userToChannelwithRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserToChannelwithRoleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserToChannelwithRoleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserToChannelwithRole'> extends True ? Prisma__UserToChannelwithRoleClient<UserToChannelwithRoleGetPayload<T>> : Prisma__UserToChannelwithRoleClient<UserToChannelwithRoleGetPayload<T> | null, null>

    /**
     * Find one UserToChannelwithRole that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserToChannelwithRoleFindUniqueOrThrowArgs} args - Arguments to find a UserToChannelwithRole
     * @example
     * // Get one UserToChannelwithRole
     * const userToChannelwithRole = await prisma.userToChannelwithRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserToChannelwithRoleFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserToChannelwithRoleFindUniqueOrThrowArgs>
    ): Prisma__UserToChannelwithRoleClient<UserToChannelwithRoleGetPayload<T>>

    /**
     * Find the first UserToChannelwithRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToChannelwithRoleFindFirstArgs} args - Arguments to find a UserToChannelwithRole
     * @example
     * // Get one UserToChannelwithRole
     * const userToChannelwithRole = await prisma.userToChannelwithRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserToChannelwithRoleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserToChannelwithRoleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserToChannelwithRole'> extends True ? Prisma__UserToChannelwithRoleClient<UserToChannelwithRoleGetPayload<T>> : Prisma__UserToChannelwithRoleClient<UserToChannelwithRoleGetPayload<T> | null, null>

    /**
     * Find the first UserToChannelwithRole that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToChannelwithRoleFindFirstOrThrowArgs} args - Arguments to find a UserToChannelwithRole
     * @example
     * // Get one UserToChannelwithRole
     * const userToChannelwithRole = await prisma.userToChannelwithRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserToChannelwithRoleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserToChannelwithRoleFindFirstOrThrowArgs>
    ): Prisma__UserToChannelwithRoleClient<UserToChannelwithRoleGetPayload<T>>

    /**
     * Find zero or more UserToChannelwithRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToChannelwithRoleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserToChannelwithRoles
     * const userToChannelwithRoles = await prisma.userToChannelwithRole.findMany()
     * 
     * // Get first 10 UserToChannelwithRoles
     * const userToChannelwithRoles = await prisma.userToChannelwithRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userToChannelwithRoleWithIdOnly = await prisma.userToChannelwithRole.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserToChannelwithRoleFindManyArgs>(
      args?: SelectSubset<T, UserToChannelwithRoleFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserToChannelwithRoleGetPayload<T>>>

    /**
     * Create a UserToChannelwithRole.
     * @param {UserToChannelwithRoleCreateArgs} args - Arguments to create a UserToChannelwithRole.
     * @example
     * // Create one UserToChannelwithRole
     * const UserToChannelwithRole = await prisma.userToChannelwithRole.create({
     *   data: {
     *     // ... data to create a UserToChannelwithRole
     *   }
     * })
     * 
    **/
    create<T extends UserToChannelwithRoleCreateArgs>(
      args: SelectSubset<T, UserToChannelwithRoleCreateArgs>
    ): Prisma__UserToChannelwithRoleClient<UserToChannelwithRoleGetPayload<T>>

    /**
     * Create many UserToChannelwithRoles.
     *     @param {UserToChannelwithRoleCreateManyArgs} args - Arguments to create many UserToChannelwithRoles.
     *     @example
     *     // Create many UserToChannelwithRoles
     *     const userToChannelwithRole = await prisma.userToChannelwithRole.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserToChannelwithRoleCreateManyArgs>(
      args?: SelectSubset<T, UserToChannelwithRoleCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserToChannelwithRole.
     * @param {UserToChannelwithRoleDeleteArgs} args - Arguments to delete one UserToChannelwithRole.
     * @example
     * // Delete one UserToChannelwithRole
     * const UserToChannelwithRole = await prisma.userToChannelwithRole.delete({
     *   where: {
     *     // ... filter to delete one UserToChannelwithRole
     *   }
     * })
     * 
    **/
    delete<T extends UserToChannelwithRoleDeleteArgs>(
      args: SelectSubset<T, UserToChannelwithRoleDeleteArgs>
    ): Prisma__UserToChannelwithRoleClient<UserToChannelwithRoleGetPayload<T>>

    /**
     * Update one UserToChannelwithRole.
     * @param {UserToChannelwithRoleUpdateArgs} args - Arguments to update one UserToChannelwithRole.
     * @example
     * // Update one UserToChannelwithRole
     * const userToChannelwithRole = await prisma.userToChannelwithRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserToChannelwithRoleUpdateArgs>(
      args: SelectSubset<T, UserToChannelwithRoleUpdateArgs>
    ): Prisma__UserToChannelwithRoleClient<UserToChannelwithRoleGetPayload<T>>

    /**
     * Delete zero or more UserToChannelwithRoles.
     * @param {UserToChannelwithRoleDeleteManyArgs} args - Arguments to filter UserToChannelwithRoles to delete.
     * @example
     * // Delete a few UserToChannelwithRoles
     * const { count } = await prisma.userToChannelwithRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserToChannelwithRoleDeleteManyArgs>(
      args?: SelectSubset<T, UserToChannelwithRoleDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserToChannelwithRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToChannelwithRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserToChannelwithRoles
     * const userToChannelwithRole = await prisma.userToChannelwithRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserToChannelwithRoleUpdateManyArgs>(
      args: SelectSubset<T, UserToChannelwithRoleUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserToChannelwithRole.
     * @param {UserToChannelwithRoleUpsertArgs} args - Arguments to update or create a UserToChannelwithRole.
     * @example
     * // Update or create a UserToChannelwithRole
     * const userToChannelwithRole = await prisma.userToChannelwithRole.upsert({
     *   create: {
     *     // ... data to create a UserToChannelwithRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserToChannelwithRole we want to update
     *   }
     * })
    **/
    upsert<T extends UserToChannelwithRoleUpsertArgs>(
      args: SelectSubset<T, UserToChannelwithRoleUpsertArgs>
    ): Prisma__UserToChannelwithRoleClient<UserToChannelwithRoleGetPayload<T>>

    /**
     * Count the number of UserToChannelwithRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToChannelwithRoleCountArgs} args - Arguments to filter UserToChannelwithRoles to count.
     * @example
     * // Count the number of UserToChannelwithRoles
     * const count = await prisma.userToChannelwithRole.count({
     *   where: {
     *     // ... the filter for the UserToChannelwithRoles we want to count
     *   }
     * })
    **/
    count<T extends UserToChannelwithRoleCountArgs>(
      args?: Subset<T, UserToChannelwithRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserToChannelwithRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserToChannelwithRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToChannelwithRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserToChannelwithRoleAggregateArgs>(args: Subset<T, UserToChannelwithRoleAggregateArgs>): Prisma.PrismaPromise<GetUserToChannelwithRoleAggregateType<T>>

    /**
     * Group by UserToChannelwithRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToChannelwithRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserToChannelwithRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserToChannelwithRoleGroupByArgs['orderBy'] }
        : { orderBy?: UserToChannelwithRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserToChannelwithRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserToChannelwithRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserToChannelwithRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserToChannelwithRoleClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends YouTubeUserArgs= {}>(args?: Subset<T, YouTubeUserArgs>): Prisma__YouTubeUserClient<YouTubeUserGetPayload<T> | Null>;

    channel<T extends ChannelArgs= {}>(args?: Subset<T, ChannelArgs>): Prisma__ChannelClient<ChannelGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserToChannelwithRole base type for findUnique actions
   */
  export type UserToChannelwithRoleFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the UserToChannelwithRole
     */
    select?: UserToChannelwithRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToChannelwithRoleInclude | null
    /**
     * Filter, which UserToChannelwithRole to fetch.
     */
    where: UserToChannelwithRoleWhereUniqueInput
  }

  /**
   * UserToChannelwithRole findUnique
   */
  export interface UserToChannelwithRoleFindUniqueArgs extends UserToChannelwithRoleFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserToChannelwithRole findUniqueOrThrow
   */
  export type UserToChannelwithRoleFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserToChannelwithRole
     */
    select?: UserToChannelwithRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToChannelwithRoleInclude | null
    /**
     * Filter, which UserToChannelwithRole to fetch.
     */
    where: UserToChannelwithRoleWhereUniqueInput
  }


  /**
   * UserToChannelwithRole base type for findFirst actions
   */
  export type UserToChannelwithRoleFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the UserToChannelwithRole
     */
    select?: UserToChannelwithRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToChannelwithRoleInclude | null
    /**
     * Filter, which UserToChannelwithRole to fetch.
     */
    where?: UserToChannelwithRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToChannelwithRoles to fetch.
     */
    orderBy?: Enumerable<UserToChannelwithRoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserToChannelwithRoles.
     */
    cursor?: UserToChannelwithRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToChannelwithRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToChannelwithRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserToChannelwithRoles.
     */
    distinct?: Enumerable<UserToChannelwithRoleScalarFieldEnum>
  }

  /**
   * UserToChannelwithRole findFirst
   */
  export interface UserToChannelwithRoleFindFirstArgs extends UserToChannelwithRoleFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserToChannelwithRole findFirstOrThrow
   */
  export type UserToChannelwithRoleFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserToChannelwithRole
     */
    select?: UserToChannelwithRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToChannelwithRoleInclude | null
    /**
     * Filter, which UserToChannelwithRole to fetch.
     */
    where?: UserToChannelwithRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToChannelwithRoles to fetch.
     */
    orderBy?: Enumerable<UserToChannelwithRoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserToChannelwithRoles.
     */
    cursor?: UserToChannelwithRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToChannelwithRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToChannelwithRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserToChannelwithRoles.
     */
    distinct?: Enumerable<UserToChannelwithRoleScalarFieldEnum>
  }


  /**
   * UserToChannelwithRole findMany
   */
  export type UserToChannelwithRoleFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserToChannelwithRole
     */
    select?: UserToChannelwithRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToChannelwithRoleInclude | null
    /**
     * Filter, which UserToChannelwithRoles to fetch.
     */
    where?: UserToChannelwithRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToChannelwithRoles to fetch.
     */
    orderBy?: Enumerable<UserToChannelwithRoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserToChannelwithRoles.
     */
    cursor?: UserToChannelwithRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToChannelwithRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToChannelwithRoles.
     */
    skip?: number
    distinct?: Enumerable<UserToChannelwithRoleScalarFieldEnum>
  }


  /**
   * UserToChannelwithRole create
   */
  export type UserToChannelwithRoleCreateArgs = {
    /**
     * Select specific fields to fetch from the UserToChannelwithRole
     */
    select?: UserToChannelwithRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToChannelwithRoleInclude | null
    /**
     * The data needed to create a UserToChannelwithRole.
     */
    data: XOR<UserToChannelwithRoleCreateInput, UserToChannelwithRoleUncheckedCreateInput>
  }


  /**
   * UserToChannelwithRole createMany
   */
  export type UserToChannelwithRoleCreateManyArgs = {
    /**
     * The data used to create many UserToChannelwithRoles.
     */
    data: Enumerable<UserToChannelwithRoleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserToChannelwithRole update
   */
  export type UserToChannelwithRoleUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserToChannelwithRole
     */
    select?: UserToChannelwithRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToChannelwithRoleInclude | null
    /**
     * The data needed to update a UserToChannelwithRole.
     */
    data: XOR<UserToChannelwithRoleUpdateInput, UserToChannelwithRoleUncheckedUpdateInput>
    /**
     * Choose, which UserToChannelwithRole to update.
     */
    where: UserToChannelwithRoleWhereUniqueInput
  }


  /**
   * UserToChannelwithRole updateMany
   */
  export type UserToChannelwithRoleUpdateManyArgs = {
    /**
     * The data used to update UserToChannelwithRoles.
     */
    data: XOR<UserToChannelwithRoleUpdateManyMutationInput, UserToChannelwithRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserToChannelwithRoles to update
     */
    where?: UserToChannelwithRoleWhereInput
  }


  /**
   * UserToChannelwithRole upsert
   */
  export type UserToChannelwithRoleUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserToChannelwithRole
     */
    select?: UserToChannelwithRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToChannelwithRoleInclude | null
    /**
     * The filter to search for the UserToChannelwithRole to update in case it exists.
     */
    where: UserToChannelwithRoleWhereUniqueInput
    /**
     * In case the UserToChannelwithRole found by the `where` argument doesn't exist, create a new UserToChannelwithRole with this data.
     */
    create: XOR<UserToChannelwithRoleCreateInput, UserToChannelwithRoleUncheckedCreateInput>
    /**
     * In case the UserToChannelwithRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserToChannelwithRoleUpdateInput, UserToChannelwithRoleUncheckedUpdateInput>
  }


  /**
   * UserToChannelwithRole delete
   */
  export type UserToChannelwithRoleDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserToChannelwithRole
     */
    select?: UserToChannelwithRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToChannelwithRoleInclude | null
    /**
     * Filter which UserToChannelwithRole to delete.
     */
    where: UserToChannelwithRoleWhereUniqueInput
  }


  /**
   * UserToChannelwithRole deleteMany
   */
  export type UserToChannelwithRoleDeleteManyArgs = {
    /**
     * Filter which UserToChannelwithRoles to delete
     */
    where?: UserToChannelwithRoleWhereInput
  }


  /**
   * UserToChannelwithRole without action
   */
  export type UserToChannelwithRoleArgs = {
    /**
     * Select specific fields to fetch from the UserToChannelwithRole
     */
    select?: UserToChannelwithRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToChannelwithRoleInclude | null
  }



  /**
   * Model Video
   */


  export type AggregateVideo = {
    _count: VideoCountAggregateOutputType | null
    _avg: VideoAvgAggregateOutputType | null
    _sum: VideoSumAggregateOutputType | null
    _min: VideoMinAggregateOutputType | null
    _max: VideoMaxAggregateOutputType | null
  }

  export type VideoAvgAggregateOutputType = {
    id: number | null
    channelId: number | null
  }

  export type VideoSumAggregateOutputType = {
    id: number | null
    channelId: number | null
  }

  export type VideoMinAggregateOutputType = {
    id: number | null
    title: string | null
    videoUrl: string | null
    thumbnailImageUrl: string | null
    description: string | null
    channelId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VideoMaxAggregateOutputType = {
    id: number | null
    title: string | null
    videoUrl: string | null
    thumbnailImageUrl: string | null
    description: string | null
    channelId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VideoCountAggregateOutputType = {
    id: number
    title: number
    videoUrl: number
    thumbnailImageUrl: number
    description: number
    channelId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VideoAvgAggregateInputType = {
    id?: true
    channelId?: true
  }

  export type VideoSumAggregateInputType = {
    id?: true
    channelId?: true
  }

  export type VideoMinAggregateInputType = {
    id?: true
    title?: true
    videoUrl?: true
    thumbnailImageUrl?: true
    description?: true
    channelId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VideoMaxAggregateInputType = {
    id?: true
    title?: true
    videoUrl?: true
    thumbnailImageUrl?: true
    description?: true
    channelId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VideoCountAggregateInputType = {
    id?: true
    title?: true
    videoUrl?: true
    thumbnailImageUrl?: true
    description?: true
    channelId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VideoAggregateArgs = {
    /**
     * Filter which Video to aggregate.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: Enumerable<VideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Videos
    **/
    _count?: true | VideoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VideoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VideoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideoMaxAggregateInputType
  }

  export type GetVideoAggregateType<T extends VideoAggregateArgs> = {
        [P in keyof T & keyof AggregateVideo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideo[P]>
      : GetScalarType<T[P], AggregateVideo[P]>
  }




  export type VideoGroupByArgs = {
    where?: VideoWhereInput
    orderBy?: Enumerable<VideoOrderByWithAggregationInput>
    by: VideoScalarFieldEnum[]
    having?: VideoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideoCountAggregateInputType | true
    _avg?: VideoAvgAggregateInputType
    _sum?: VideoSumAggregateInputType
    _min?: VideoMinAggregateInputType
    _max?: VideoMaxAggregateInputType
  }


  export type VideoGroupByOutputType = {
    id: number
    title: string
    videoUrl: string
    thumbnailImageUrl: string | null
    description: string | null
    channelId: number
    createdAt: Date
    updatedAt: Date
    _count: VideoCountAggregateOutputType | null
    _avg: VideoAvgAggregateOutputType | null
    _sum: VideoSumAggregateOutputType | null
    _min: VideoMinAggregateOutputType | null
    _max: VideoMaxAggregateOutputType | null
  }

  type GetVideoGroupByPayload<T extends VideoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<VideoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideoGroupByOutputType[P]>
            : GetScalarType<T[P], VideoGroupByOutputType[P]>
        }
      >
    >


  export type VideoSelect = {
    id?: boolean
    title?: boolean
    videoUrl?: boolean
    thumbnailImageUrl?: boolean
    description?: boolean
    belongsToChannel?: boolean | ChannelArgs
    channelId?: boolean
    reactedByYouTubeUsers?: boolean | Video$reactedByYouTubeUsersArgs
    usersToVideosWithReactions?: boolean | Video$usersToVideosWithReactionsArgs
    videoComments?: boolean | Video$videoCommentsArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | VideoCountOutputTypeArgs
  }


  export type VideoInclude = {
    belongsToChannel?: boolean | ChannelArgs
    reactedByYouTubeUsers?: boolean | Video$reactedByYouTubeUsersArgs
    usersToVideosWithReactions?: boolean | Video$usersToVideosWithReactionsArgs
    videoComments?: boolean | Video$videoCommentsArgs
    _count?: boolean | VideoCountOutputTypeArgs
  }

  export type VideoGetPayload<S extends boolean | null | undefined | VideoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Video :
    S extends undefined ? never :
    S extends { include: any } & (VideoArgs | VideoFindManyArgs)
    ? Video  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'belongsToChannel' ? ChannelGetPayload<S['include'][P]> :
        P extends 'reactedByYouTubeUsers' ? Array < YouTubeUserGetPayload<S['include'][P]>>  :
        P extends 'usersToVideosWithReactions' ? Array < UserToVideoWithReactionGetPayload<S['include'][P]>>  :
        P extends 'videoComments' ? Array < VideoCommentGetPayload<S['include'][P]>>  :
        P extends '_count' ? VideoCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (VideoArgs | VideoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'belongsToChannel' ? ChannelGetPayload<S['select'][P]> :
        P extends 'reactedByYouTubeUsers' ? Array < YouTubeUserGetPayload<S['select'][P]>>  :
        P extends 'usersToVideosWithReactions' ? Array < UserToVideoWithReactionGetPayload<S['select'][P]>>  :
        P extends 'videoComments' ? Array < VideoCommentGetPayload<S['select'][P]>>  :
        P extends '_count' ? VideoCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Video ? Video[P] : never
  } 
      : Video


  type VideoCountArgs = 
    Omit<VideoFindManyArgs, 'select' | 'include'> & {
      select?: VideoCountAggregateInputType | true
    }

  export interface VideoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Video that matches the filter.
     * @param {VideoFindUniqueArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VideoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, VideoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Video'> extends True ? Prisma__VideoClient<VideoGetPayload<T>> : Prisma__VideoClient<VideoGetPayload<T> | null, null>

    /**
     * Find one Video that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {VideoFindUniqueOrThrowArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends VideoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, VideoFindUniqueOrThrowArgs>
    ): Prisma__VideoClient<VideoGetPayload<T>>

    /**
     * Find the first Video that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFindFirstArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VideoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, VideoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Video'> extends True ? Prisma__VideoClient<VideoGetPayload<T>> : Prisma__VideoClient<VideoGetPayload<T> | null, null>

    /**
     * Find the first Video that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFindFirstOrThrowArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends VideoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, VideoFindFirstOrThrowArgs>
    ): Prisma__VideoClient<VideoGetPayload<T>>

    /**
     * Find zero or more Videos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Videos
     * const videos = await prisma.video.findMany()
     * 
     * // Get first 10 Videos
     * const videos = await prisma.video.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videoWithIdOnly = await prisma.video.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VideoFindManyArgs>(
      args?: SelectSubset<T, VideoFindManyArgs>
    ): Prisma.PrismaPromise<Array<VideoGetPayload<T>>>

    /**
     * Create a Video.
     * @param {VideoCreateArgs} args - Arguments to create a Video.
     * @example
     * // Create one Video
     * const Video = await prisma.video.create({
     *   data: {
     *     // ... data to create a Video
     *   }
     * })
     * 
    **/
    create<T extends VideoCreateArgs>(
      args: SelectSubset<T, VideoCreateArgs>
    ): Prisma__VideoClient<VideoGetPayload<T>>

    /**
     * Create many Videos.
     *     @param {VideoCreateManyArgs} args - Arguments to create many Videos.
     *     @example
     *     // Create many Videos
     *     const video = await prisma.video.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VideoCreateManyArgs>(
      args?: SelectSubset<T, VideoCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Video.
     * @param {VideoDeleteArgs} args - Arguments to delete one Video.
     * @example
     * // Delete one Video
     * const Video = await prisma.video.delete({
     *   where: {
     *     // ... filter to delete one Video
     *   }
     * })
     * 
    **/
    delete<T extends VideoDeleteArgs>(
      args: SelectSubset<T, VideoDeleteArgs>
    ): Prisma__VideoClient<VideoGetPayload<T>>

    /**
     * Update one Video.
     * @param {VideoUpdateArgs} args - Arguments to update one Video.
     * @example
     * // Update one Video
     * const video = await prisma.video.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VideoUpdateArgs>(
      args: SelectSubset<T, VideoUpdateArgs>
    ): Prisma__VideoClient<VideoGetPayload<T>>

    /**
     * Delete zero or more Videos.
     * @param {VideoDeleteManyArgs} args - Arguments to filter Videos to delete.
     * @example
     * // Delete a few Videos
     * const { count } = await prisma.video.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VideoDeleteManyArgs>(
      args?: SelectSubset<T, VideoDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Videos
     * const video = await prisma.video.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VideoUpdateManyArgs>(
      args: SelectSubset<T, VideoUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Video.
     * @param {VideoUpsertArgs} args - Arguments to update or create a Video.
     * @example
     * // Update or create a Video
     * const video = await prisma.video.upsert({
     *   create: {
     *     // ... data to create a Video
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Video we want to update
     *   }
     * })
    **/
    upsert<T extends VideoUpsertArgs>(
      args: SelectSubset<T, VideoUpsertArgs>
    ): Prisma__VideoClient<VideoGetPayload<T>>

    /**
     * Count the number of Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCountArgs} args - Arguments to filter Videos to count.
     * @example
     * // Count the number of Videos
     * const count = await prisma.video.count({
     *   where: {
     *     // ... the filter for the Videos we want to count
     *   }
     * })
    **/
    count<T extends VideoCountArgs>(
      args?: Subset<T, VideoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Video.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideoAggregateArgs>(args: Subset<T, VideoAggregateArgs>): Prisma.PrismaPromise<GetVideoAggregateType<T>>

    /**
     * Group by Video.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideoGroupByArgs['orderBy'] }
        : { orderBy?: VideoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Video.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VideoClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    belongsToChannel<T extends ChannelArgs= {}>(args?: Subset<T, ChannelArgs>): Prisma__ChannelClient<ChannelGetPayload<T> | Null>;

    reactedByYouTubeUsers<T extends Video$reactedByYouTubeUsersArgs= {}>(args?: Subset<T, Video$reactedByYouTubeUsersArgs>): Prisma.PrismaPromise<Array<YouTubeUserGetPayload<T>>| Null>;

    usersToVideosWithReactions<T extends Video$usersToVideosWithReactionsArgs= {}>(args?: Subset<T, Video$usersToVideosWithReactionsArgs>): Prisma.PrismaPromise<Array<UserToVideoWithReactionGetPayload<T>>| Null>;

    videoComments<T extends Video$videoCommentsArgs= {}>(args?: Subset<T, Video$videoCommentsArgs>): Prisma.PrismaPromise<Array<VideoCommentGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Video base type for findUnique actions
   */
  export type VideoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude | null
    /**
     * Filter, which Video to fetch.
     */
    where: VideoWhereUniqueInput
  }

  /**
   * Video findUnique
   */
  export interface VideoFindUniqueArgs extends VideoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Video findUniqueOrThrow
   */
  export type VideoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude | null
    /**
     * Filter, which Video to fetch.
     */
    where: VideoWhereUniqueInput
  }


  /**
   * Video base type for findFirst actions
   */
  export type VideoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude | null
    /**
     * Filter, which Video to fetch.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: Enumerable<VideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Videos.
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Videos.
     */
    distinct?: Enumerable<VideoScalarFieldEnum>
  }

  /**
   * Video findFirst
   */
  export interface VideoFindFirstArgs extends VideoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Video findFirstOrThrow
   */
  export type VideoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude | null
    /**
     * Filter, which Video to fetch.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: Enumerable<VideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Videos.
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Videos.
     */
    distinct?: Enumerable<VideoScalarFieldEnum>
  }


  /**
   * Video findMany
   */
  export type VideoFindManyArgs = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude | null
    /**
     * Filter, which Videos to fetch.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: Enumerable<VideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Videos.
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    distinct?: Enumerable<VideoScalarFieldEnum>
  }


  /**
   * Video create
   */
  export type VideoCreateArgs = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude | null
    /**
     * The data needed to create a Video.
     */
    data: XOR<VideoCreateInput, VideoUncheckedCreateInput>
  }


  /**
   * Video createMany
   */
  export type VideoCreateManyArgs = {
    /**
     * The data used to create many Videos.
     */
    data: Enumerable<VideoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Video update
   */
  export type VideoUpdateArgs = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude | null
    /**
     * The data needed to update a Video.
     */
    data: XOR<VideoUpdateInput, VideoUncheckedUpdateInput>
    /**
     * Choose, which Video to update.
     */
    where: VideoWhereUniqueInput
  }


  /**
   * Video updateMany
   */
  export type VideoUpdateManyArgs = {
    /**
     * The data used to update Videos.
     */
    data: XOR<VideoUpdateManyMutationInput, VideoUncheckedUpdateManyInput>
    /**
     * Filter which Videos to update
     */
    where?: VideoWhereInput
  }


  /**
   * Video upsert
   */
  export type VideoUpsertArgs = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude | null
    /**
     * The filter to search for the Video to update in case it exists.
     */
    where: VideoWhereUniqueInput
    /**
     * In case the Video found by the `where` argument doesn't exist, create a new Video with this data.
     */
    create: XOR<VideoCreateInput, VideoUncheckedCreateInput>
    /**
     * In case the Video was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VideoUpdateInput, VideoUncheckedUpdateInput>
  }


  /**
   * Video delete
   */
  export type VideoDeleteArgs = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude | null
    /**
     * Filter which Video to delete.
     */
    where: VideoWhereUniqueInput
  }


  /**
   * Video deleteMany
   */
  export type VideoDeleteManyArgs = {
    /**
     * Filter which Videos to delete
     */
    where?: VideoWhereInput
  }


  /**
   * Video.reactedByYouTubeUsers
   */
  export type Video$reactedByYouTubeUsersArgs = {
    /**
     * Select specific fields to fetch from the YouTubeUser
     */
    select?: YouTubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YouTubeUserInclude | null
    where?: YouTubeUserWhereInput
    orderBy?: Enumerable<YouTubeUserOrderByWithRelationInput>
    cursor?: YouTubeUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YouTubeUserScalarFieldEnum>
  }


  /**
   * Video.usersToVideosWithReactions
   */
  export type Video$usersToVideosWithReactionsArgs = {
    /**
     * Select specific fields to fetch from the UserToVideoWithReaction
     */
    select?: UserToVideoWithReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToVideoWithReactionInclude | null
    where?: UserToVideoWithReactionWhereInput
    orderBy?: Enumerable<UserToVideoWithReactionOrderByWithRelationInput>
    cursor?: UserToVideoWithReactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserToVideoWithReactionScalarFieldEnum>
  }


  /**
   * Video.videoComments
   */
  export type Video$videoCommentsArgs = {
    /**
     * Select specific fields to fetch from the VideoComment
     */
    select?: VideoCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoCommentInclude | null
    where?: VideoCommentWhereInput
    orderBy?: Enumerable<VideoCommentOrderByWithRelationInput>
    cursor?: VideoCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<VideoCommentScalarFieldEnum>
  }


  /**
   * Video without action
   */
  export type VideoArgs = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoInclude | null
  }



  /**
   * Model UserToVideoWithReaction
   */


  export type AggregateUserToVideoWithReaction = {
    _count: UserToVideoWithReactionCountAggregateOutputType | null
    _avg: UserToVideoWithReactionAvgAggregateOutputType | null
    _sum: UserToVideoWithReactionSumAggregateOutputType | null
    _min: UserToVideoWithReactionMinAggregateOutputType | null
    _max: UserToVideoWithReactionMaxAggregateOutputType | null
  }

  export type UserToVideoWithReactionAvgAggregateOutputType = {
    id: number | null
    youTubeUserId: number | null
    videoId: number | null
  }

  export type UserToVideoWithReactionSumAggregateOutputType = {
    id: number | null
    youTubeUserId: number | null
    videoId: number | null
  }

  export type UserToVideoWithReactionMinAggregateOutputType = {
    id: number | null
    youTubeUserId: number | null
    videoId: number | null
    reaction: ReactionEnum | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserToVideoWithReactionMaxAggregateOutputType = {
    id: number | null
    youTubeUserId: number | null
    videoId: number | null
    reaction: ReactionEnum | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserToVideoWithReactionCountAggregateOutputType = {
    id: number
    youTubeUserId: number
    videoId: number
    reaction: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserToVideoWithReactionAvgAggregateInputType = {
    id?: true
    youTubeUserId?: true
    videoId?: true
  }

  export type UserToVideoWithReactionSumAggregateInputType = {
    id?: true
    youTubeUserId?: true
    videoId?: true
  }

  export type UserToVideoWithReactionMinAggregateInputType = {
    id?: true
    youTubeUserId?: true
    videoId?: true
    reaction?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserToVideoWithReactionMaxAggregateInputType = {
    id?: true
    youTubeUserId?: true
    videoId?: true
    reaction?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserToVideoWithReactionCountAggregateInputType = {
    id?: true
    youTubeUserId?: true
    videoId?: true
    reaction?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserToVideoWithReactionAggregateArgs = {
    /**
     * Filter which UserToVideoWithReaction to aggregate.
     */
    where?: UserToVideoWithReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToVideoWithReactions to fetch.
     */
    orderBy?: Enumerable<UserToVideoWithReactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserToVideoWithReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToVideoWithReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToVideoWithReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserToVideoWithReactions
    **/
    _count?: true | UserToVideoWithReactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserToVideoWithReactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserToVideoWithReactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserToVideoWithReactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserToVideoWithReactionMaxAggregateInputType
  }

  export type GetUserToVideoWithReactionAggregateType<T extends UserToVideoWithReactionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserToVideoWithReaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserToVideoWithReaction[P]>
      : GetScalarType<T[P], AggregateUserToVideoWithReaction[P]>
  }




  export type UserToVideoWithReactionGroupByArgs = {
    where?: UserToVideoWithReactionWhereInput
    orderBy?: Enumerable<UserToVideoWithReactionOrderByWithAggregationInput>
    by: UserToVideoWithReactionScalarFieldEnum[]
    having?: UserToVideoWithReactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserToVideoWithReactionCountAggregateInputType | true
    _avg?: UserToVideoWithReactionAvgAggregateInputType
    _sum?: UserToVideoWithReactionSumAggregateInputType
    _min?: UserToVideoWithReactionMinAggregateInputType
    _max?: UserToVideoWithReactionMaxAggregateInputType
  }


  export type UserToVideoWithReactionGroupByOutputType = {
    id: number
    youTubeUserId: number
    videoId: number
    reaction: ReactionEnum
    createdAt: Date
    updatedAt: Date
    _count: UserToVideoWithReactionCountAggregateOutputType | null
    _avg: UserToVideoWithReactionAvgAggregateOutputType | null
    _sum: UserToVideoWithReactionSumAggregateOutputType | null
    _min: UserToVideoWithReactionMinAggregateOutputType | null
    _max: UserToVideoWithReactionMaxAggregateOutputType | null
  }

  type GetUserToVideoWithReactionGroupByPayload<T extends UserToVideoWithReactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserToVideoWithReactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserToVideoWithReactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserToVideoWithReactionGroupByOutputType[P]>
            : GetScalarType<T[P], UserToVideoWithReactionGroupByOutputType[P]>
        }
      >
    >


  export type UserToVideoWithReactionSelect = {
    id?: boolean
    user?: boolean | YouTubeUserArgs
    youTubeUserId?: boolean
    video?: boolean | VideoArgs
    videoId?: boolean
    reaction?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type UserToVideoWithReactionInclude = {
    user?: boolean | YouTubeUserArgs
    video?: boolean | VideoArgs
  }

  export type UserToVideoWithReactionGetPayload<S extends boolean | null | undefined | UserToVideoWithReactionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserToVideoWithReaction :
    S extends undefined ? never :
    S extends { include: any } & (UserToVideoWithReactionArgs | UserToVideoWithReactionFindManyArgs)
    ? UserToVideoWithReaction  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? YouTubeUserGetPayload<S['include'][P]> :
        P extends 'video' ? VideoGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserToVideoWithReactionArgs | UserToVideoWithReactionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? YouTubeUserGetPayload<S['select'][P]> :
        P extends 'video' ? VideoGetPayload<S['select'][P]> :  P extends keyof UserToVideoWithReaction ? UserToVideoWithReaction[P] : never
  } 
      : UserToVideoWithReaction


  type UserToVideoWithReactionCountArgs = 
    Omit<UserToVideoWithReactionFindManyArgs, 'select' | 'include'> & {
      select?: UserToVideoWithReactionCountAggregateInputType | true
    }

  export interface UserToVideoWithReactionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one UserToVideoWithReaction that matches the filter.
     * @param {UserToVideoWithReactionFindUniqueArgs} args - Arguments to find a UserToVideoWithReaction
     * @example
     * // Get one UserToVideoWithReaction
     * const userToVideoWithReaction = await prisma.userToVideoWithReaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserToVideoWithReactionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserToVideoWithReactionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserToVideoWithReaction'> extends True ? Prisma__UserToVideoWithReactionClient<UserToVideoWithReactionGetPayload<T>> : Prisma__UserToVideoWithReactionClient<UserToVideoWithReactionGetPayload<T> | null, null>

    /**
     * Find one UserToVideoWithReaction that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserToVideoWithReactionFindUniqueOrThrowArgs} args - Arguments to find a UserToVideoWithReaction
     * @example
     * // Get one UserToVideoWithReaction
     * const userToVideoWithReaction = await prisma.userToVideoWithReaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserToVideoWithReactionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserToVideoWithReactionFindUniqueOrThrowArgs>
    ): Prisma__UserToVideoWithReactionClient<UserToVideoWithReactionGetPayload<T>>

    /**
     * Find the first UserToVideoWithReaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToVideoWithReactionFindFirstArgs} args - Arguments to find a UserToVideoWithReaction
     * @example
     * // Get one UserToVideoWithReaction
     * const userToVideoWithReaction = await prisma.userToVideoWithReaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserToVideoWithReactionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserToVideoWithReactionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserToVideoWithReaction'> extends True ? Prisma__UserToVideoWithReactionClient<UserToVideoWithReactionGetPayload<T>> : Prisma__UserToVideoWithReactionClient<UserToVideoWithReactionGetPayload<T> | null, null>

    /**
     * Find the first UserToVideoWithReaction that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToVideoWithReactionFindFirstOrThrowArgs} args - Arguments to find a UserToVideoWithReaction
     * @example
     * // Get one UserToVideoWithReaction
     * const userToVideoWithReaction = await prisma.userToVideoWithReaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserToVideoWithReactionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserToVideoWithReactionFindFirstOrThrowArgs>
    ): Prisma__UserToVideoWithReactionClient<UserToVideoWithReactionGetPayload<T>>

    /**
     * Find zero or more UserToVideoWithReactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToVideoWithReactionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserToVideoWithReactions
     * const userToVideoWithReactions = await prisma.userToVideoWithReaction.findMany()
     * 
     * // Get first 10 UserToVideoWithReactions
     * const userToVideoWithReactions = await prisma.userToVideoWithReaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userToVideoWithReactionWithIdOnly = await prisma.userToVideoWithReaction.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserToVideoWithReactionFindManyArgs>(
      args?: SelectSubset<T, UserToVideoWithReactionFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserToVideoWithReactionGetPayload<T>>>

    /**
     * Create a UserToVideoWithReaction.
     * @param {UserToVideoWithReactionCreateArgs} args - Arguments to create a UserToVideoWithReaction.
     * @example
     * // Create one UserToVideoWithReaction
     * const UserToVideoWithReaction = await prisma.userToVideoWithReaction.create({
     *   data: {
     *     // ... data to create a UserToVideoWithReaction
     *   }
     * })
     * 
    **/
    create<T extends UserToVideoWithReactionCreateArgs>(
      args: SelectSubset<T, UserToVideoWithReactionCreateArgs>
    ): Prisma__UserToVideoWithReactionClient<UserToVideoWithReactionGetPayload<T>>

    /**
     * Create many UserToVideoWithReactions.
     *     @param {UserToVideoWithReactionCreateManyArgs} args - Arguments to create many UserToVideoWithReactions.
     *     @example
     *     // Create many UserToVideoWithReactions
     *     const userToVideoWithReaction = await prisma.userToVideoWithReaction.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserToVideoWithReactionCreateManyArgs>(
      args?: SelectSubset<T, UserToVideoWithReactionCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserToVideoWithReaction.
     * @param {UserToVideoWithReactionDeleteArgs} args - Arguments to delete one UserToVideoWithReaction.
     * @example
     * // Delete one UserToVideoWithReaction
     * const UserToVideoWithReaction = await prisma.userToVideoWithReaction.delete({
     *   where: {
     *     // ... filter to delete one UserToVideoWithReaction
     *   }
     * })
     * 
    **/
    delete<T extends UserToVideoWithReactionDeleteArgs>(
      args: SelectSubset<T, UserToVideoWithReactionDeleteArgs>
    ): Prisma__UserToVideoWithReactionClient<UserToVideoWithReactionGetPayload<T>>

    /**
     * Update one UserToVideoWithReaction.
     * @param {UserToVideoWithReactionUpdateArgs} args - Arguments to update one UserToVideoWithReaction.
     * @example
     * // Update one UserToVideoWithReaction
     * const userToVideoWithReaction = await prisma.userToVideoWithReaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserToVideoWithReactionUpdateArgs>(
      args: SelectSubset<T, UserToVideoWithReactionUpdateArgs>
    ): Prisma__UserToVideoWithReactionClient<UserToVideoWithReactionGetPayload<T>>

    /**
     * Delete zero or more UserToVideoWithReactions.
     * @param {UserToVideoWithReactionDeleteManyArgs} args - Arguments to filter UserToVideoWithReactions to delete.
     * @example
     * // Delete a few UserToVideoWithReactions
     * const { count } = await prisma.userToVideoWithReaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserToVideoWithReactionDeleteManyArgs>(
      args?: SelectSubset<T, UserToVideoWithReactionDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserToVideoWithReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToVideoWithReactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserToVideoWithReactions
     * const userToVideoWithReaction = await prisma.userToVideoWithReaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserToVideoWithReactionUpdateManyArgs>(
      args: SelectSubset<T, UserToVideoWithReactionUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserToVideoWithReaction.
     * @param {UserToVideoWithReactionUpsertArgs} args - Arguments to update or create a UserToVideoWithReaction.
     * @example
     * // Update or create a UserToVideoWithReaction
     * const userToVideoWithReaction = await prisma.userToVideoWithReaction.upsert({
     *   create: {
     *     // ... data to create a UserToVideoWithReaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserToVideoWithReaction we want to update
     *   }
     * })
    **/
    upsert<T extends UserToVideoWithReactionUpsertArgs>(
      args: SelectSubset<T, UserToVideoWithReactionUpsertArgs>
    ): Prisma__UserToVideoWithReactionClient<UserToVideoWithReactionGetPayload<T>>

    /**
     * Count the number of UserToVideoWithReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToVideoWithReactionCountArgs} args - Arguments to filter UserToVideoWithReactions to count.
     * @example
     * // Count the number of UserToVideoWithReactions
     * const count = await prisma.userToVideoWithReaction.count({
     *   where: {
     *     // ... the filter for the UserToVideoWithReactions we want to count
     *   }
     * })
    **/
    count<T extends UserToVideoWithReactionCountArgs>(
      args?: Subset<T, UserToVideoWithReactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserToVideoWithReactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserToVideoWithReaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToVideoWithReactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserToVideoWithReactionAggregateArgs>(args: Subset<T, UserToVideoWithReactionAggregateArgs>): Prisma.PrismaPromise<GetUserToVideoWithReactionAggregateType<T>>

    /**
     * Group by UserToVideoWithReaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToVideoWithReactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserToVideoWithReactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserToVideoWithReactionGroupByArgs['orderBy'] }
        : { orderBy?: UserToVideoWithReactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserToVideoWithReactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserToVideoWithReactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserToVideoWithReaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserToVideoWithReactionClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends YouTubeUserArgs= {}>(args?: Subset<T, YouTubeUserArgs>): Prisma__YouTubeUserClient<YouTubeUserGetPayload<T> | Null>;

    video<T extends VideoArgs= {}>(args?: Subset<T, VideoArgs>): Prisma__VideoClient<VideoGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserToVideoWithReaction base type for findUnique actions
   */
  export type UserToVideoWithReactionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the UserToVideoWithReaction
     */
    select?: UserToVideoWithReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToVideoWithReactionInclude | null
    /**
     * Filter, which UserToVideoWithReaction to fetch.
     */
    where: UserToVideoWithReactionWhereUniqueInput
  }

  /**
   * UserToVideoWithReaction findUnique
   */
  export interface UserToVideoWithReactionFindUniqueArgs extends UserToVideoWithReactionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserToVideoWithReaction findUniqueOrThrow
   */
  export type UserToVideoWithReactionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserToVideoWithReaction
     */
    select?: UserToVideoWithReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToVideoWithReactionInclude | null
    /**
     * Filter, which UserToVideoWithReaction to fetch.
     */
    where: UserToVideoWithReactionWhereUniqueInput
  }


  /**
   * UserToVideoWithReaction base type for findFirst actions
   */
  export type UserToVideoWithReactionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the UserToVideoWithReaction
     */
    select?: UserToVideoWithReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToVideoWithReactionInclude | null
    /**
     * Filter, which UserToVideoWithReaction to fetch.
     */
    where?: UserToVideoWithReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToVideoWithReactions to fetch.
     */
    orderBy?: Enumerable<UserToVideoWithReactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserToVideoWithReactions.
     */
    cursor?: UserToVideoWithReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToVideoWithReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToVideoWithReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserToVideoWithReactions.
     */
    distinct?: Enumerable<UserToVideoWithReactionScalarFieldEnum>
  }

  /**
   * UserToVideoWithReaction findFirst
   */
  export interface UserToVideoWithReactionFindFirstArgs extends UserToVideoWithReactionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserToVideoWithReaction findFirstOrThrow
   */
  export type UserToVideoWithReactionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserToVideoWithReaction
     */
    select?: UserToVideoWithReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToVideoWithReactionInclude | null
    /**
     * Filter, which UserToVideoWithReaction to fetch.
     */
    where?: UserToVideoWithReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToVideoWithReactions to fetch.
     */
    orderBy?: Enumerable<UserToVideoWithReactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserToVideoWithReactions.
     */
    cursor?: UserToVideoWithReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToVideoWithReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToVideoWithReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserToVideoWithReactions.
     */
    distinct?: Enumerable<UserToVideoWithReactionScalarFieldEnum>
  }


  /**
   * UserToVideoWithReaction findMany
   */
  export type UserToVideoWithReactionFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserToVideoWithReaction
     */
    select?: UserToVideoWithReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToVideoWithReactionInclude | null
    /**
     * Filter, which UserToVideoWithReactions to fetch.
     */
    where?: UserToVideoWithReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToVideoWithReactions to fetch.
     */
    orderBy?: Enumerable<UserToVideoWithReactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserToVideoWithReactions.
     */
    cursor?: UserToVideoWithReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToVideoWithReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToVideoWithReactions.
     */
    skip?: number
    distinct?: Enumerable<UserToVideoWithReactionScalarFieldEnum>
  }


  /**
   * UserToVideoWithReaction create
   */
  export type UserToVideoWithReactionCreateArgs = {
    /**
     * Select specific fields to fetch from the UserToVideoWithReaction
     */
    select?: UserToVideoWithReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToVideoWithReactionInclude | null
    /**
     * The data needed to create a UserToVideoWithReaction.
     */
    data: XOR<UserToVideoWithReactionCreateInput, UserToVideoWithReactionUncheckedCreateInput>
  }


  /**
   * UserToVideoWithReaction createMany
   */
  export type UserToVideoWithReactionCreateManyArgs = {
    /**
     * The data used to create many UserToVideoWithReactions.
     */
    data: Enumerable<UserToVideoWithReactionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserToVideoWithReaction update
   */
  export type UserToVideoWithReactionUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserToVideoWithReaction
     */
    select?: UserToVideoWithReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToVideoWithReactionInclude | null
    /**
     * The data needed to update a UserToVideoWithReaction.
     */
    data: XOR<UserToVideoWithReactionUpdateInput, UserToVideoWithReactionUncheckedUpdateInput>
    /**
     * Choose, which UserToVideoWithReaction to update.
     */
    where: UserToVideoWithReactionWhereUniqueInput
  }


  /**
   * UserToVideoWithReaction updateMany
   */
  export type UserToVideoWithReactionUpdateManyArgs = {
    /**
     * The data used to update UserToVideoWithReactions.
     */
    data: XOR<UserToVideoWithReactionUpdateManyMutationInput, UserToVideoWithReactionUncheckedUpdateManyInput>
    /**
     * Filter which UserToVideoWithReactions to update
     */
    where?: UserToVideoWithReactionWhereInput
  }


  /**
   * UserToVideoWithReaction upsert
   */
  export type UserToVideoWithReactionUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserToVideoWithReaction
     */
    select?: UserToVideoWithReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToVideoWithReactionInclude | null
    /**
     * The filter to search for the UserToVideoWithReaction to update in case it exists.
     */
    where: UserToVideoWithReactionWhereUniqueInput
    /**
     * In case the UserToVideoWithReaction found by the `where` argument doesn't exist, create a new UserToVideoWithReaction with this data.
     */
    create: XOR<UserToVideoWithReactionCreateInput, UserToVideoWithReactionUncheckedCreateInput>
    /**
     * In case the UserToVideoWithReaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserToVideoWithReactionUpdateInput, UserToVideoWithReactionUncheckedUpdateInput>
  }


  /**
   * UserToVideoWithReaction delete
   */
  export type UserToVideoWithReactionDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserToVideoWithReaction
     */
    select?: UserToVideoWithReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToVideoWithReactionInclude | null
    /**
     * Filter which UserToVideoWithReaction to delete.
     */
    where: UserToVideoWithReactionWhereUniqueInput
  }


  /**
   * UserToVideoWithReaction deleteMany
   */
  export type UserToVideoWithReactionDeleteManyArgs = {
    /**
     * Filter which UserToVideoWithReactions to delete
     */
    where?: UserToVideoWithReactionWhereInput
  }


  /**
   * UserToVideoWithReaction without action
   */
  export type UserToVideoWithReactionArgs = {
    /**
     * Select specific fields to fetch from the UserToVideoWithReaction
     */
    select?: UserToVideoWithReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToVideoWithReactionInclude | null
  }



  /**
   * Model VideoComment
   */


  export type AggregateVideoComment = {
    _count: VideoCommentCountAggregateOutputType | null
    _avg: VideoCommentAvgAggregateOutputType | null
    _sum: VideoCommentSumAggregateOutputType | null
    _min: VideoCommentMinAggregateOutputType | null
    _max: VideoCommentMaxAggregateOutputType | null
  }

  export type VideoCommentAvgAggregateOutputType = {
    id: number | null
    youTubeUserId: number | null
    videoId: number | null
    parentVideoCommentId: number | null
  }

  export type VideoCommentSumAggregateOutputType = {
    id: number | null
    youTubeUserId: number | null
    videoId: number | null
    parentVideoCommentId: number | null
  }

  export type VideoCommentMinAggregateOutputType = {
    id: number | null
    commentText: string | null
    youTubeUserId: number | null
    videoId: number | null
    parentVideoCommentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VideoCommentMaxAggregateOutputType = {
    id: number | null
    commentText: string | null
    youTubeUserId: number | null
    videoId: number | null
    parentVideoCommentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VideoCommentCountAggregateOutputType = {
    id: number
    commentText: number
    youTubeUserId: number
    videoId: number
    parentVideoCommentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VideoCommentAvgAggregateInputType = {
    id?: true
    youTubeUserId?: true
    videoId?: true
    parentVideoCommentId?: true
  }

  export type VideoCommentSumAggregateInputType = {
    id?: true
    youTubeUserId?: true
    videoId?: true
    parentVideoCommentId?: true
  }

  export type VideoCommentMinAggregateInputType = {
    id?: true
    commentText?: true
    youTubeUserId?: true
    videoId?: true
    parentVideoCommentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VideoCommentMaxAggregateInputType = {
    id?: true
    commentText?: true
    youTubeUserId?: true
    videoId?: true
    parentVideoCommentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VideoCommentCountAggregateInputType = {
    id?: true
    commentText?: true
    youTubeUserId?: true
    videoId?: true
    parentVideoCommentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VideoCommentAggregateArgs = {
    /**
     * Filter which VideoComment to aggregate.
     */
    where?: VideoCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoComments to fetch.
     */
    orderBy?: Enumerable<VideoCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VideoCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VideoComments
    **/
    _count?: true | VideoCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VideoCommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VideoCommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideoCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideoCommentMaxAggregateInputType
  }

  export type GetVideoCommentAggregateType<T extends VideoCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateVideoComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideoComment[P]>
      : GetScalarType<T[P], AggregateVideoComment[P]>
  }




  export type VideoCommentGroupByArgs = {
    where?: VideoCommentWhereInput
    orderBy?: Enumerable<VideoCommentOrderByWithAggregationInput>
    by: VideoCommentScalarFieldEnum[]
    having?: VideoCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideoCommentCountAggregateInputType | true
    _avg?: VideoCommentAvgAggregateInputType
    _sum?: VideoCommentSumAggregateInputType
    _min?: VideoCommentMinAggregateInputType
    _max?: VideoCommentMaxAggregateInputType
  }


  export type VideoCommentGroupByOutputType = {
    id: number
    commentText: string
    youTubeUserId: number
    videoId: number
    parentVideoCommentId: number | null
    createdAt: Date
    updatedAt: Date
    _count: VideoCommentCountAggregateOutputType | null
    _avg: VideoCommentAvgAggregateOutputType | null
    _sum: VideoCommentSumAggregateOutputType | null
    _min: VideoCommentMinAggregateOutputType | null
    _max: VideoCommentMaxAggregateOutputType | null
  }

  type GetVideoCommentGroupByPayload<T extends VideoCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<VideoCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideoCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideoCommentGroupByOutputType[P]>
            : GetScalarType<T[P], VideoCommentGroupByOutputType[P]>
        }
      >
    >


  export type VideoCommentSelect = {
    id?: boolean
    commentText?: boolean
    commentingUser?: boolean | YouTubeUserArgs
    youTubeUserId?: boolean
    parentVideo?: boolean | VideoArgs
    videoId?: boolean
    parentVideoComment?: boolean | VideoCommentArgs
    parentVideoCommentId?: boolean
    childVideoComments?: boolean | VideoComment$childVideoCommentsArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | VideoCommentCountOutputTypeArgs
  }


  export type VideoCommentInclude = {
    commentingUser?: boolean | YouTubeUserArgs
    parentVideo?: boolean | VideoArgs
    parentVideoComment?: boolean | VideoCommentArgs
    childVideoComments?: boolean | VideoComment$childVideoCommentsArgs
    _count?: boolean | VideoCommentCountOutputTypeArgs
  }

  export type VideoCommentGetPayload<S extends boolean | null | undefined | VideoCommentArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? VideoComment :
    S extends undefined ? never :
    S extends { include: any } & (VideoCommentArgs | VideoCommentFindManyArgs)
    ? VideoComment  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'commentingUser' ? YouTubeUserGetPayload<S['include'][P]> :
        P extends 'parentVideo' ? VideoGetPayload<S['include'][P]> :
        P extends 'parentVideoComment' ? VideoCommentGetPayload<S['include'][P]> | null :
        P extends 'childVideoComments' ? Array < VideoCommentGetPayload<S['include'][P]>>  :
        P extends '_count' ? VideoCommentCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (VideoCommentArgs | VideoCommentFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'commentingUser' ? YouTubeUserGetPayload<S['select'][P]> :
        P extends 'parentVideo' ? VideoGetPayload<S['select'][P]> :
        P extends 'parentVideoComment' ? VideoCommentGetPayload<S['select'][P]> | null :
        P extends 'childVideoComments' ? Array < VideoCommentGetPayload<S['select'][P]>>  :
        P extends '_count' ? VideoCommentCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof VideoComment ? VideoComment[P] : never
  } 
      : VideoComment


  type VideoCommentCountArgs = 
    Omit<VideoCommentFindManyArgs, 'select' | 'include'> & {
      select?: VideoCommentCountAggregateInputType | true
    }

  export interface VideoCommentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one VideoComment that matches the filter.
     * @param {VideoCommentFindUniqueArgs} args - Arguments to find a VideoComment
     * @example
     * // Get one VideoComment
     * const videoComment = await prisma.videoComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VideoCommentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, VideoCommentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'VideoComment'> extends True ? Prisma__VideoCommentClient<VideoCommentGetPayload<T>> : Prisma__VideoCommentClient<VideoCommentGetPayload<T> | null, null>

    /**
     * Find one VideoComment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {VideoCommentFindUniqueOrThrowArgs} args - Arguments to find a VideoComment
     * @example
     * // Get one VideoComment
     * const videoComment = await prisma.videoComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends VideoCommentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, VideoCommentFindUniqueOrThrowArgs>
    ): Prisma__VideoCommentClient<VideoCommentGetPayload<T>>

    /**
     * Find the first VideoComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCommentFindFirstArgs} args - Arguments to find a VideoComment
     * @example
     * // Get one VideoComment
     * const videoComment = await prisma.videoComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VideoCommentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, VideoCommentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'VideoComment'> extends True ? Prisma__VideoCommentClient<VideoCommentGetPayload<T>> : Prisma__VideoCommentClient<VideoCommentGetPayload<T> | null, null>

    /**
     * Find the first VideoComment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCommentFindFirstOrThrowArgs} args - Arguments to find a VideoComment
     * @example
     * // Get one VideoComment
     * const videoComment = await prisma.videoComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends VideoCommentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, VideoCommentFindFirstOrThrowArgs>
    ): Prisma__VideoCommentClient<VideoCommentGetPayload<T>>

    /**
     * Find zero or more VideoComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VideoComments
     * const videoComments = await prisma.videoComment.findMany()
     * 
     * // Get first 10 VideoComments
     * const videoComments = await prisma.videoComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videoCommentWithIdOnly = await prisma.videoComment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VideoCommentFindManyArgs>(
      args?: SelectSubset<T, VideoCommentFindManyArgs>
    ): Prisma.PrismaPromise<Array<VideoCommentGetPayload<T>>>

    /**
     * Create a VideoComment.
     * @param {VideoCommentCreateArgs} args - Arguments to create a VideoComment.
     * @example
     * // Create one VideoComment
     * const VideoComment = await prisma.videoComment.create({
     *   data: {
     *     // ... data to create a VideoComment
     *   }
     * })
     * 
    **/
    create<T extends VideoCommentCreateArgs>(
      args: SelectSubset<T, VideoCommentCreateArgs>
    ): Prisma__VideoCommentClient<VideoCommentGetPayload<T>>

    /**
     * Create many VideoComments.
     *     @param {VideoCommentCreateManyArgs} args - Arguments to create many VideoComments.
     *     @example
     *     // Create many VideoComments
     *     const videoComment = await prisma.videoComment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VideoCommentCreateManyArgs>(
      args?: SelectSubset<T, VideoCommentCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a VideoComment.
     * @param {VideoCommentDeleteArgs} args - Arguments to delete one VideoComment.
     * @example
     * // Delete one VideoComment
     * const VideoComment = await prisma.videoComment.delete({
     *   where: {
     *     // ... filter to delete one VideoComment
     *   }
     * })
     * 
    **/
    delete<T extends VideoCommentDeleteArgs>(
      args: SelectSubset<T, VideoCommentDeleteArgs>
    ): Prisma__VideoCommentClient<VideoCommentGetPayload<T>>

    /**
     * Update one VideoComment.
     * @param {VideoCommentUpdateArgs} args - Arguments to update one VideoComment.
     * @example
     * // Update one VideoComment
     * const videoComment = await prisma.videoComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VideoCommentUpdateArgs>(
      args: SelectSubset<T, VideoCommentUpdateArgs>
    ): Prisma__VideoCommentClient<VideoCommentGetPayload<T>>

    /**
     * Delete zero or more VideoComments.
     * @param {VideoCommentDeleteManyArgs} args - Arguments to filter VideoComments to delete.
     * @example
     * // Delete a few VideoComments
     * const { count } = await prisma.videoComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VideoCommentDeleteManyArgs>(
      args?: SelectSubset<T, VideoCommentDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VideoComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VideoComments
     * const videoComment = await prisma.videoComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VideoCommentUpdateManyArgs>(
      args: SelectSubset<T, VideoCommentUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VideoComment.
     * @param {VideoCommentUpsertArgs} args - Arguments to update or create a VideoComment.
     * @example
     * // Update or create a VideoComment
     * const videoComment = await prisma.videoComment.upsert({
     *   create: {
     *     // ... data to create a VideoComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VideoComment we want to update
     *   }
     * })
    **/
    upsert<T extends VideoCommentUpsertArgs>(
      args: SelectSubset<T, VideoCommentUpsertArgs>
    ): Prisma__VideoCommentClient<VideoCommentGetPayload<T>>

    /**
     * Count the number of VideoComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCommentCountArgs} args - Arguments to filter VideoComments to count.
     * @example
     * // Count the number of VideoComments
     * const count = await prisma.videoComment.count({
     *   where: {
     *     // ... the filter for the VideoComments we want to count
     *   }
     * })
    **/
    count<T extends VideoCommentCountArgs>(
      args?: Subset<T, VideoCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideoCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VideoComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideoCommentAggregateArgs>(args: Subset<T, VideoCommentAggregateArgs>): Prisma.PrismaPromise<GetVideoCommentAggregateType<T>>

    /**
     * Group by VideoComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideoCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideoCommentGroupByArgs['orderBy'] }
        : { orderBy?: VideoCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideoCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for VideoComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VideoCommentClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    commentingUser<T extends YouTubeUserArgs= {}>(args?: Subset<T, YouTubeUserArgs>): Prisma__YouTubeUserClient<YouTubeUserGetPayload<T> | Null>;

    parentVideo<T extends VideoArgs= {}>(args?: Subset<T, VideoArgs>): Prisma__VideoClient<VideoGetPayload<T> | Null>;

    parentVideoComment<T extends VideoCommentArgs= {}>(args?: Subset<T, VideoCommentArgs>): Prisma__VideoCommentClient<VideoCommentGetPayload<T> | Null>;

    childVideoComments<T extends VideoComment$childVideoCommentsArgs= {}>(args?: Subset<T, VideoComment$childVideoCommentsArgs>): Prisma.PrismaPromise<Array<VideoCommentGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * VideoComment base type for findUnique actions
   */
  export type VideoCommentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the VideoComment
     */
    select?: VideoCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoCommentInclude | null
    /**
     * Filter, which VideoComment to fetch.
     */
    where: VideoCommentWhereUniqueInput
  }

  /**
   * VideoComment findUnique
   */
  export interface VideoCommentFindUniqueArgs extends VideoCommentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * VideoComment findUniqueOrThrow
   */
  export type VideoCommentFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the VideoComment
     */
    select?: VideoCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoCommentInclude | null
    /**
     * Filter, which VideoComment to fetch.
     */
    where: VideoCommentWhereUniqueInput
  }


  /**
   * VideoComment base type for findFirst actions
   */
  export type VideoCommentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the VideoComment
     */
    select?: VideoCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoCommentInclude | null
    /**
     * Filter, which VideoComment to fetch.
     */
    where?: VideoCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoComments to fetch.
     */
    orderBy?: Enumerable<VideoCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoComments.
     */
    cursor?: VideoCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoComments.
     */
    distinct?: Enumerable<VideoCommentScalarFieldEnum>
  }

  /**
   * VideoComment findFirst
   */
  export interface VideoCommentFindFirstArgs extends VideoCommentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * VideoComment findFirstOrThrow
   */
  export type VideoCommentFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the VideoComment
     */
    select?: VideoCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoCommentInclude | null
    /**
     * Filter, which VideoComment to fetch.
     */
    where?: VideoCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoComments to fetch.
     */
    orderBy?: Enumerable<VideoCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoComments.
     */
    cursor?: VideoCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoComments.
     */
    distinct?: Enumerable<VideoCommentScalarFieldEnum>
  }


  /**
   * VideoComment findMany
   */
  export type VideoCommentFindManyArgs = {
    /**
     * Select specific fields to fetch from the VideoComment
     */
    select?: VideoCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoCommentInclude | null
    /**
     * Filter, which VideoComments to fetch.
     */
    where?: VideoCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoComments to fetch.
     */
    orderBy?: Enumerable<VideoCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VideoComments.
     */
    cursor?: VideoCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoComments.
     */
    skip?: number
    distinct?: Enumerable<VideoCommentScalarFieldEnum>
  }


  /**
   * VideoComment create
   */
  export type VideoCommentCreateArgs = {
    /**
     * Select specific fields to fetch from the VideoComment
     */
    select?: VideoCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoCommentInclude | null
    /**
     * The data needed to create a VideoComment.
     */
    data: XOR<VideoCommentCreateInput, VideoCommentUncheckedCreateInput>
  }


  /**
   * VideoComment createMany
   */
  export type VideoCommentCreateManyArgs = {
    /**
     * The data used to create many VideoComments.
     */
    data: Enumerable<VideoCommentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * VideoComment update
   */
  export type VideoCommentUpdateArgs = {
    /**
     * Select specific fields to fetch from the VideoComment
     */
    select?: VideoCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoCommentInclude | null
    /**
     * The data needed to update a VideoComment.
     */
    data: XOR<VideoCommentUpdateInput, VideoCommentUncheckedUpdateInput>
    /**
     * Choose, which VideoComment to update.
     */
    where: VideoCommentWhereUniqueInput
  }


  /**
   * VideoComment updateMany
   */
  export type VideoCommentUpdateManyArgs = {
    /**
     * The data used to update VideoComments.
     */
    data: XOR<VideoCommentUpdateManyMutationInput, VideoCommentUncheckedUpdateManyInput>
    /**
     * Filter which VideoComments to update
     */
    where?: VideoCommentWhereInput
  }


  /**
   * VideoComment upsert
   */
  export type VideoCommentUpsertArgs = {
    /**
     * Select specific fields to fetch from the VideoComment
     */
    select?: VideoCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoCommentInclude | null
    /**
     * The filter to search for the VideoComment to update in case it exists.
     */
    where: VideoCommentWhereUniqueInput
    /**
     * In case the VideoComment found by the `where` argument doesn't exist, create a new VideoComment with this data.
     */
    create: XOR<VideoCommentCreateInput, VideoCommentUncheckedCreateInput>
    /**
     * In case the VideoComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VideoCommentUpdateInput, VideoCommentUncheckedUpdateInput>
  }


  /**
   * VideoComment delete
   */
  export type VideoCommentDeleteArgs = {
    /**
     * Select specific fields to fetch from the VideoComment
     */
    select?: VideoCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoCommentInclude | null
    /**
     * Filter which VideoComment to delete.
     */
    where: VideoCommentWhereUniqueInput
  }


  /**
   * VideoComment deleteMany
   */
  export type VideoCommentDeleteManyArgs = {
    /**
     * Filter which VideoComments to delete
     */
    where?: VideoCommentWhereInput
  }


  /**
   * VideoComment.childVideoComments
   */
  export type VideoComment$childVideoCommentsArgs = {
    /**
     * Select specific fields to fetch from the VideoComment
     */
    select?: VideoCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoCommentInclude | null
    where?: VideoCommentWhereInput
    orderBy?: Enumerable<VideoCommentOrderByWithRelationInput>
    cursor?: VideoCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<VideoCommentScalarFieldEnum>
  }


  /**
   * VideoComment without action
   */
  export type VideoCommentArgs = {
    /**
     * Select specific fields to fetch from the VideoComment
     */
    select?: VideoCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VideoCommentInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AuthorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AuthorScalarFieldEnum = (typeof AuthorScalarFieldEnum)[keyof typeof AuthorScalarFieldEnum]


  export const BinWashUserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    balance: 'balance',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BinWashUserScalarFieldEnum = (typeof BinWashUserScalarFieldEnum)[keyof typeof BinWashUserScalarFieldEnum]


  export const BookCategoryScalarFieldEnum: {
    id: 'id',
    category: 'category',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BookCategoryScalarFieldEnum = (typeof BookCategoryScalarFieldEnum)[keyof typeof BookCategoryScalarFieldEnum]


  export const BookScalarFieldEnum: {
    id: 'id',
    bookTitleId: 'bookTitleId',
    libraryId: 'libraryId',
    isAvailable: 'isAvailable',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BookScalarFieldEnum = (typeof BookScalarFieldEnum)[keyof typeof BookScalarFieldEnum]


  export const BookTitleScalarFieldEnum: {
    id: 'id',
    title: 'title',
    isbn: 'isbn',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BookTitleScalarFieldEnum = (typeof BookTitleScalarFieldEnum)[keyof typeof BookTitleScalarFieldEnum]


  export const BorrowingRecordScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    bookId: 'bookId',
    startDate: 'startDate',
    endDate: 'endDate',
    actualEndDate: 'actualEndDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BorrowingRecordScalarFieldEnum = (typeof BorrowingRecordScalarFieldEnum)[keyof typeof BorrowingRecordScalarFieldEnum]


  export const BranchScalarFieldEnum: {
    id: 'id',
    name: 'name',
    location: 'location',
    telephoneNo: 'telephoneNo',
    area: 'area',
    binWashUserId: 'binWashUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BranchScalarFieldEnum = (typeof BranchScalarFieldEnum)[keyof typeof BranchScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const ChannelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    profileImageUrl: 'profileImageUrl',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChannelScalarFieldEnum = (typeof ChannelScalarFieldEnum)[keyof typeof ChannelScalarFieldEnum]


  export const ChoiceScalarFieldEnum: {
    id: 'id',
    answerText: 'answerText',
    quizId: 'quizId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChoiceScalarFieldEnum = (typeof ChoiceScalarFieldEnum)[keyof typeof ChoiceScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    commentText: 'commentText',
    userId: 'userId',
    postId: 'postId',
    parentCommentId: 'parentCommentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const DirectMessageScalarFieldEnum: {
    id: 'id',
    dmText: 'dmText',
    fromUserId: 'fromUserId',
    toUserId: 'toUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DirectMessageScalarFieldEnum = (typeof DirectMessageScalarFieldEnum)[keyof typeof DirectMessageScalarFieldEnum]


  export const FacebookHashTagScalarFieldEnum: {
    id: 'id',
    hashTagText: 'hashTagText',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FacebookHashTagScalarFieldEnum = (typeof FacebookHashTagScalarFieldEnum)[keyof typeof FacebookHashTagScalarFieldEnum]


  export const FacebookUserRelationScalarFieldEnum: {
    id: 'id',
    followingUserId: 'followingUserId',
    followedUserId: 'followedUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FacebookUserRelationScalarFieldEnum = (typeof FacebookUserRelationScalarFieldEnum)[keyof typeof FacebookUserRelationScalarFieldEnum]


  export const FacebookUserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    imageUrl: 'imageUrl',
    bio: 'bio',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FacebookUserScalarFieldEnum = (typeof FacebookUserScalarFieldEnum)[keyof typeof FacebookUserScalarFieldEnum]


  export const HashTagScalarFieldEnum: {
    id: 'id',
    hashTagText: 'hashTagText',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HashTagScalarFieldEnum = (typeof HashTagScalarFieldEnum)[keyof typeof HashTagScalarFieldEnum]


  export const LibraryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    location: 'location',
    universityId: 'universityId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LibraryScalarFieldEnum = (typeof LibraryScalarFieldEnum)[keyof typeof LibraryScalarFieldEnum]


  export const MenuScalarFieldEnum: {
    id: 'id',
    name: 'name',
    image: 'image',
    price: 'price',
    categoryId: 'categoryId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MenuScalarFieldEnum = (typeof MenuScalarFieldEnum)[keyof typeof MenuScalarFieldEnum]


  export const MessengerMessageScalarFieldEnum: {
    id: 'id',
    messengerText: 'messengerText',
    fromUserId: 'fromUserId',
    toUserId: 'toUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MessengerMessageScalarFieldEnum = (typeof MessengerMessageScalarFieldEnum)[keyof typeof MessengerMessageScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    id: 'id',
    menuId: 'menuId',
    orderId: 'orderId',
    quantity: 'quantity',
    totalPrice: 'totalPrice',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    status: 'status',
    tableId: 'tableId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const PostScalarFieldEnum: {
    id: 'id',
    postText: 'postText',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const QuizCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuizCategoryScalarFieldEnum = (typeof QuizCategoryScalarFieldEnum)[keyof typeof QuizCategoryScalarFieldEnum]


  export const QuizScalarFieldEnum: {
    id: 'id',
    questionText: 'questionText',
    quizCategoryId: 'quizCategoryId',
    correctChoiceId: 'correctChoiceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuizScalarFieldEnum = (typeof QuizScalarFieldEnum)[keyof typeof QuizScalarFieldEnum]


  export const RequestRecordScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    bookTitleId: 'bookTitleId',
    requestingLibraryId: 'requestingLibraryId',
    requestedLibraryId: 'requestedLibraryId',
    requestDate: 'requestDate',
    acquiredDate: 'acquiredDate',
    returnDate: 'returnDate',
    bookId: 'bookId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RequestRecordScalarFieldEnum = (typeof RequestRecordScalarFieldEnum)[keyof typeof RequestRecordScalarFieldEnum]


  export const RoundScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoundScalarFieldEnum = (typeof RoundScalarFieldEnum)[keyof typeof RoundScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const StudentScalarFieldEnum: {
    id: 'id',
    Name: 'Name',
    universityId: 'universityId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const TodoListScalarFieldEnum: {
    id: 'id',
    task: 'task',
    status: 'status',
    bgColor: 'bgColor',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TodoListScalarFieldEnum = (typeof TodoListScalarFieldEnum)[keyof typeof TodoListScalarFieldEnum]


  export const TopUpRecordScalarFieldEnum: {
    id: 'id',
    dateTime: 'dateTime',
    binWashUserId: 'binWashUserId',
    price: 'price',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TopUpRecordScalarFieldEnum = (typeof TopUpRecordScalarFieldEnum)[keyof typeof TopUpRecordScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TweetScalarFieldEnum: {
    id: 'id',
    tweetText: 'tweetText',
    parentTweetId: 'parentTweetId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TweetScalarFieldEnum = (typeof TweetScalarFieldEnum)[keyof typeof TweetScalarFieldEnum]


  export const UniversityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    location: 'location',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UniversityScalarFieldEnum = (typeof UniversityScalarFieldEnum)[keyof typeof UniversityScalarFieldEnum]


  export const UsageRecordScalarFieldEnum: {
    id: 'id',
    dateTime: 'dateTime',
    binWashUserId: 'binWashUserId',
    washingMachineId: 'washingMachineId',
    wMProgramId: 'wMProgramId',
    price: 'price',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UsageRecordScalarFieldEnum = (typeof UsageRecordScalarFieldEnum)[keyof typeof UsageRecordScalarFieldEnum]


  export const UserRelationScalarFieldEnum: {
    id: 'id',
    followingUserId: 'followingUserId',
    followedUserId: 'followedUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserRelationScalarFieldEnum = (typeof UserRelationScalarFieldEnum)[keyof typeof UserRelationScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    imageUrl: 'imageUrl',
    bio: 'bio',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserToChannelwithRoleScalarFieldEnum: {
    id: 'id',
    youTubeUserId: 'youTubeUserId',
    channelId: 'channelId',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserToChannelwithRoleScalarFieldEnum = (typeof UserToChannelwithRoleScalarFieldEnum)[keyof typeof UserToChannelwithRoleScalarFieldEnum]


  export const UserToVideoWithReactionScalarFieldEnum: {
    id: 'id',
    youTubeUserId: 'youTubeUserId',
    videoId: 'videoId',
    reaction: 'reaction',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserToVideoWithReactionScalarFieldEnum = (typeof UserToVideoWithReactionScalarFieldEnum)[keyof typeof UserToVideoWithReactionScalarFieldEnum]


  export const VideoCommentScalarFieldEnum: {
    id: 'id',
    commentText: 'commentText',
    youTubeUserId: 'youTubeUserId',
    videoId: 'videoId',
    parentVideoCommentId: 'parentVideoCommentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VideoCommentScalarFieldEnum = (typeof VideoCommentScalarFieldEnum)[keyof typeof VideoCommentScalarFieldEnum]


  export const VideoScalarFieldEnum: {
    id: 'id',
    title: 'title',
    videoUrl: 'videoUrl',
    thumbnailImageUrl: 'thumbnailImageUrl',
    description: 'description',
    channelId: 'channelId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VideoScalarFieldEnum = (typeof VideoScalarFieldEnum)[keyof typeof VideoScalarFieldEnum]


  export const WMMaintenanceRecordScalarFieldEnum: {
    id: 'id',
    washingMachineId: 'washingMachineId',
    maintenanceDateTime: 'maintenanceDateTime',
    level: 'level',
    details: 'details',
    binWashUserId: 'binWashUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WMMaintenanceRecordScalarFieldEnum = (typeof WMMaintenanceRecordScalarFieldEnum)[keyof typeof WMMaintenanceRecordScalarFieldEnum]


  export const WMProgramScalarFieldEnum: {
    id: 'id',
    name: 'name',
    maxCapacity: 'maxCapacity',
    duration: 'duration',
    price: 'price',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WMProgramScalarFieldEnum = (typeof WMProgramScalarFieldEnum)[keyof typeof WMProgramScalarFieldEnum]


  export const WashingMachineScalarFieldEnum: {
    id: 'id',
    brand: 'brand',
    model: 'model',
    type: 'type',
    capacity: 'capacity',
    manufacturedYear: 'manufacturedYear',
    warrantyEndDate: 'warrantyEndDate',
    branchId: 'branchId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WashingMachineScalarFieldEnum = (typeof WashingMachineScalarFieldEnum)[keyof typeof WashingMachineScalarFieldEnum]


  export const YouTubeUserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    profileImageUrl: 'profileImageUrl',
    bio: 'bio',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type YouTubeUserScalarFieldEnum = (typeof YouTubeUserScalarFieldEnum)[keyof typeof YouTubeUserScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type CategoryWhereInput = {
    AND?: Enumerable<CategoryWhereInput>
    OR?: Enumerable<CategoryWhereInput>
    NOT?: Enumerable<CategoryWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    Menu?: MenuListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Menu?: MenuOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = {
    id?: number
  }

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<CategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CategoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type MenuWhereInput = {
    AND?: Enumerable<MenuWhereInput>
    OR?: Enumerable<MenuWhereInput>
    NOT?: Enumerable<MenuWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    image?: StringFilter | string
    price?: FloatFilter | number
    category?: XOR<CategoryRelationFilter, CategoryWhereInput> | null
    categoryId?: IntNullableFilter | number | null
    orderItems?: OrderItemListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type MenuOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    price?: SortOrder
    category?: CategoryOrderByWithRelationInput
    categoryId?: SortOrder
    orderItems?: OrderItemOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuWhereUniqueInput = {
    id?: number
  }

  export type MenuOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    price?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MenuCountOrderByAggregateInput
    _avg?: MenuAvgOrderByAggregateInput
    _max?: MenuMaxOrderByAggregateInput
    _min?: MenuMinOrderByAggregateInput
    _sum?: MenuSumOrderByAggregateInput
  }

  export type MenuScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MenuScalarWhereWithAggregatesInput>
    OR?: Enumerable<MenuScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MenuScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    image?: StringWithAggregatesFilter | string
    price?: FloatWithAggregatesFilter | number
    categoryId?: IntNullableWithAggregatesFilter | number | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type OrderWhereInput = {
    AND?: Enumerable<OrderWhereInput>
    OR?: Enumerable<OrderWhereInput>
    NOT?: Enumerable<OrderWhereInput>
    id?: IntFilter | number
    status?: StringFilter | string
    tableId?: IntFilter | number
    items?: OrderItemListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    tableId?: SortOrder
    items?: OrderItemOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderWhereUniqueInput = {
    id?: number
  }

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    tableId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OrderScalarWhereWithAggregatesInput>
    OR?: Enumerable<OrderScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OrderScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    status?: StringWithAggregatesFilter | string
    tableId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type OrderItemWhereInput = {
    AND?: Enumerable<OrderItemWhereInput>
    OR?: Enumerable<OrderItemWhereInput>
    NOT?: Enumerable<OrderItemWhereInput>
    id?: IntFilter | number
    menu?: XOR<MenuRelationFilter, MenuWhereInput>
    menuId?: IntFilter | number
    order?: XOR<OrderRelationFilter, OrderWhereInput> | null
    orderId?: IntNullableFilter | number | null
    quantity?: IntFilter | number
    totalPrice?: FloatFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder
    menu?: MenuOrderByWithRelationInput
    menuId?: SortOrder
    order?: OrderOrderByWithRelationInput
    orderId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderItemWhereUniqueInput = {
    id?: number
  }

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    menuId?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderItemCountOrderByAggregateInput
    _avg?: OrderItemAvgOrderByAggregateInput
    _max?: OrderItemMaxOrderByAggregateInput
    _min?: OrderItemMinOrderByAggregateInput
    _sum?: OrderItemSumOrderByAggregateInput
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OrderItemScalarWhereWithAggregatesInput>
    OR?: Enumerable<OrderItemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OrderItemScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    menuId?: IntWithAggregatesFilter | number
    orderId?: IntNullableWithAggregatesFilter | number | null
    quantity?: IntWithAggregatesFilter | number
    totalPrice?: FloatWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type QuizCategoryWhereInput = {
    AND?: Enumerable<QuizCategoryWhereInput>
    OR?: Enumerable<QuizCategoryWhereInput>
    NOT?: Enumerable<QuizCategoryWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    quizzes?: QuizListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type QuizCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    quizzes?: QuizOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizCategoryWhereUniqueInput = {
    id?: number
  }

  export type QuizCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuizCategoryCountOrderByAggregateInput
    _avg?: QuizCategoryAvgOrderByAggregateInput
    _max?: QuizCategoryMaxOrderByAggregateInput
    _min?: QuizCategoryMinOrderByAggregateInput
    _sum?: QuizCategorySumOrderByAggregateInput
  }

  export type QuizCategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<QuizCategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<QuizCategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<QuizCategoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ChoiceWhereInput = {
    AND?: Enumerable<ChoiceWhereInput>
    OR?: Enumerable<ChoiceWhereInput>
    NOT?: Enumerable<ChoiceWhereInput>
    id?: IntFilter | number
    answerText?: StringFilter | string
    quiz?: XOR<QuizRelationFilter, QuizWhereInput> | null
    quizId?: IntNullableFilter | number | null
    correctQuizzes?: QuizListRelationFilter
    rounds?: RoundListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ChoiceOrderByWithRelationInput = {
    id?: SortOrder
    answerText?: SortOrder
    quiz?: QuizOrderByWithRelationInput
    quizId?: SortOrder
    correctQuizzes?: QuizOrderByRelationAggregateInput
    rounds?: RoundOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChoiceWhereUniqueInput = {
    id?: number
  }

  export type ChoiceOrderByWithAggregationInput = {
    id?: SortOrder
    answerText?: SortOrder
    quizId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChoiceCountOrderByAggregateInput
    _avg?: ChoiceAvgOrderByAggregateInput
    _max?: ChoiceMaxOrderByAggregateInput
    _min?: ChoiceMinOrderByAggregateInput
    _sum?: ChoiceSumOrderByAggregateInput
  }

  export type ChoiceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ChoiceScalarWhereWithAggregatesInput>
    OR?: Enumerable<ChoiceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ChoiceScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    answerText?: StringWithAggregatesFilter | string
    quizId?: IntNullableWithAggregatesFilter | number | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type QuizWhereInput = {
    AND?: Enumerable<QuizWhereInput>
    OR?: Enumerable<QuizWhereInput>
    NOT?: Enumerable<QuizWhereInput>
    id?: IntFilter | number
    questionText?: StringFilter | string
    category?: XOR<QuizCategoryRelationFilter, QuizCategoryWhereInput>
    quizCategoryId?: IntFilter | number
    choices?: ChoiceListRelationFilter
    correctChoice?: XOR<ChoiceRelationFilter, ChoiceWhereInput>
    correctChoiceId?: IntFilter | number
    rounds?: RoundListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type QuizOrderByWithRelationInput = {
    id?: SortOrder
    questionText?: SortOrder
    category?: QuizCategoryOrderByWithRelationInput
    quizCategoryId?: SortOrder
    choices?: ChoiceOrderByRelationAggregateInput
    correctChoice?: ChoiceOrderByWithRelationInput
    correctChoiceId?: SortOrder
    rounds?: RoundOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizWhereUniqueInput = {
    id?: number
  }

  export type QuizOrderByWithAggregationInput = {
    id?: SortOrder
    questionText?: SortOrder
    quizCategoryId?: SortOrder
    correctChoiceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuizCountOrderByAggregateInput
    _avg?: QuizAvgOrderByAggregateInput
    _max?: QuizMaxOrderByAggregateInput
    _min?: QuizMinOrderByAggregateInput
    _sum?: QuizSumOrderByAggregateInput
  }

  export type QuizScalarWhereWithAggregatesInput = {
    AND?: Enumerable<QuizScalarWhereWithAggregatesInput>
    OR?: Enumerable<QuizScalarWhereWithAggregatesInput>
    NOT?: Enumerable<QuizScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    questionText?: StringWithAggregatesFilter | string
    quizCategoryId?: IntWithAggregatesFilter | number
    correctChoiceId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type RoundWhereInput = {
    AND?: Enumerable<RoundWhereInput>
    OR?: Enumerable<RoundWhereInput>
    NOT?: Enumerable<RoundWhereInput>
    id?: IntFilter | number
    quizzes?: QuizListRelationFilter
    selectedChoices?: ChoiceListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type RoundOrderByWithRelationInput = {
    id?: SortOrder
    quizzes?: QuizOrderByRelationAggregateInput
    selectedChoices?: ChoiceOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoundWhereUniqueInput = {
    id?: number
  }

  export type RoundOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoundCountOrderByAggregateInput
    _avg?: RoundAvgOrderByAggregateInput
    _max?: RoundMaxOrderByAggregateInput
    _min?: RoundMinOrderByAggregateInput
    _sum?: RoundSumOrderByAggregateInput
  }

  export type RoundScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RoundScalarWhereWithAggregatesInput>
    OR?: Enumerable<RoundScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RoundScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type BinWashUserWhereInput = {
    AND?: Enumerable<BinWashUserWhereInput>
    OR?: Enumerable<BinWashUserWhereInput>
    NOT?: Enumerable<BinWashUserWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    balance?: FloatFilter | number
    owningBranches?: BranchListRelationFilter
    wMMaintenanceRecords?: WMMaintenanceRecordListRelationFilter
    usageRecords?: UsageRecordListRelationFilter
    topUpRecords?: TopUpRecordListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type BinWashUserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    balance?: SortOrder
    owningBranches?: BranchOrderByRelationAggregateInput
    wMMaintenanceRecords?: WMMaintenanceRecordOrderByRelationAggregateInput
    usageRecords?: UsageRecordOrderByRelationAggregateInput
    topUpRecords?: TopUpRecordOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BinWashUserWhereUniqueInput = {
    id?: number
  }

  export type BinWashUserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BinWashUserCountOrderByAggregateInput
    _avg?: BinWashUserAvgOrderByAggregateInput
    _max?: BinWashUserMaxOrderByAggregateInput
    _min?: BinWashUserMinOrderByAggregateInput
    _sum?: BinWashUserSumOrderByAggregateInput
  }

  export type BinWashUserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BinWashUserScalarWhereWithAggregatesInput>
    OR?: Enumerable<BinWashUserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BinWashUserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    balance?: FloatWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type BranchWhereInput = {
    AND?: Enumerable<BranchWhereInput>
    OR?: Enumerable<BranchWhereInput>
    NOT?: Enumerable<BranchWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    location?: StringFilter | string
    telephoneNo?: StringFilter | string
    area?: FloatFilter | number
    branchOwner?: XOR<BinWashUserRelationFilter, BinWashUserWhereInput>
    binWashUserId?: IntFilter | number
    washingMachines?: WashingMachineListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type BranchOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    telephoneNo?: SortOrder
    area?: SortOrder
    branchOwner?: BinWashUserOrderByWithRelationInput
    binWashUserId?: SortOrder
    washingMachines?: WashingMachineOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BranchWhereUniqueInput = {
    id?: number
  }

  export type BranchOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    telephoneNo?: SortOrder
    area?: SortOrder
    binWashUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BranchCountOrderByAggregateInput
    _avg?: BranchAvgOrderByAggregateInput
    _max?: BranchMaxOrderByAggregateInput
    _min?: BranchMinOrderByAggregateInput
    _sum?: BranchSumOrderByAggregateInput
  }

  export type BranchScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BranchScalarWhereWithAggregatesInput>
    OR?: Enumerable<BranchScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BranchScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    location?: StringWithAggregatesFilter | string
    telephoneNo?: StringWithAggregatesFilter | string
    area?: FloatWithAggregatesFilter | number
    binWashUserId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type WashingMachineWhereInput = {
    AND?: Enumerable<WashingMachineWhereInput>
    OR?: Enumerable<WashingMachineWhereInput>
    NOT?: Enumerable<WashingMachineWhereInput>
    id?: IntFilter | number
    brand?: StringFilter | string
    model?: StringFilter | string
    type?: EnumWMTypeEnumFilter | WMTypeEnum
    capacity?: FloatFilter | number
    manufacturedYear?: DateTimeFilter | Date | string
    warrantyEndDate?: DateTimeFilter | Date | string
    locatedBranch?: XOR<BranchRelationFilter, BranchWhereInput>
    branchId?: IntFilter | number
    equippedPrograms?: WMProgramListRelationFilter
    usageRecords?: UsageRecordListRelationFilter
    wMMaintenanceRecords?: WMMaintenanceRecordListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type WashingMachineOrderByWithRelationInput = {
    id?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    type?: SortOrder
    capacity?: SortOrder
    manufacturedYear?: SortOrder
    warrantyEndDate?: SortOrder
    locatedBranch?: BranchOrderByWithRelationInput
    branchId?: SortOrder
    equippedPrograms?: WMProgramOrderByRelationAggregateInput
    usageRecords?: UsageRecordOrderByRelationAggregateInput
    wMMaintenanceRecords?: WMMaintenanceRecordOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WashingMachineWhereUniqueInput = {
    id?: number
  }

  export type WashingMachineOrderByWithAggregationInput = {
    id?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    type?: SortOrder
    capacity?: SortOrder
    manufacturedYear?: SortOrder
    warrantyEndDate?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WashingMachineCountOrderByAggregateInput
    _avg?: WashingMachineAvgOrderByAggregateInput
    _max?: WashingMachineMaxOrderByAggregateInput
    _min?: WashingMachineMinOrderByAggregateInput
    _sum?: WashingMachineSumOrderByAggregateInput
  }

  export type WashingMachineScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WashingMachineScalarWhereWithAggregatesInput>
    OR?: Enumerable<WashingMachineScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WashingMachineScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    brand?: StringWithAggregatesFilter | string
    model?: StringWithAggregatesFilter | string
    type?: EnumWMTypeEnumWithAggregatesFilter | WMTypeEnum
    capacity?: FloatWithAggregatesFilter | number
    manufacturedYear?: DateTimeWithAggregatesFilter | Date | string
    warrantyEndDate?: DateTimeWithAggregatesFilter | Date | string
    branchId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type WMProgramWhereInput = {
    AND?: Enumerable<WMProgramWhereInput>
    OR?: Enumerable<WMProgramWhereInput>
    NOT?: Enumerable<WMProgramWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    maxCapacity?: FloatFilter | number
    duration?: IntFilter | number
    price?: FloatFilter | number
    equippingWMs?: WashingMachineListRelationFilter
    usageRecords?: UsageRecordListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type WMProgramOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    maxCapacity?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    equippingWMs?: WashingMachineOrderByRelationAggregateInput
    usageRecords?: UsageRecordOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WMProgramWhereUniqueInput = {
    id?: number
  }

  export type WMProgramOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    maxCapacity?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WMProgramCountOrderByAggregateInput
    _avg?: WMProgramAvgOrderByAggregateInput
    _max?: WMProgramMaxOrderByAggregateInput
    _min?: WMProgramMinOrderByAggregateInput
    _sum?: WMProgramSumOrderByAggregateInput
  }

  export type WMProgramScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WMProgramScalarWhereWithAggregatesInput>
    OR?: Enumerable<WMProgramScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WMProgramScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    maxCapacity?: FloatWithAggregatesFilter | number
    duration?: IntWithAggregatesFilter | number
    price?: FloatWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type WMMaintenanceRecordWhereInput = {
    AND?: Enumerable<WMMaintenanceRecordWhereInput>
    OR?: Enumerable<WMMaintenanceRecordWhereInput>
    NOT?: Enumerable<WMMaintenanceRecordWhereInput>
    id?: IntFilter | number
    maintainedWM?: XOR<WashingMachineRelationFilter, WashingMachineWhereInput>
    washingMachineId?: IntFilter | number
    maintenanceDateTime?: DateTimeFilter | Date | string
    level?: IntFilter | number
    details?: StringFilter | string
    maintainer?: XOR<BinWashUserRelationFilter, BinWashUserWhereInput>
    binWashUserId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type WMMaintenanceRecordOrderByWithRelationInput = {
    id?: SortOrder
    maintainedWM?: WashingMachineOrderByWithRelationInput
    washingMachineId?: SortOrder
    maintenanceDateTime?: SortOrder
    level?: SortOrder
    details?: SortOrder
    maintainer?: BinWashUserOrderByWithRelationInput
    binWashUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WMMaintenanceRecordWhereUniqueInput = {
    id?: number
  }

  export type WMMaintenanceRecordOrderByWithAggregationInput = {
    id?: SortOrder
    washingMachineId?: SortOrder
    maintenanceDateTime?: SortOrder
    level?: SortOrder
    details?: SortOrder
    binWashUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WMMaintenanceRecordCountOrderByAggregateInput
    _avg?: WMMaintenanceRecordAvgOrderByAggregateInput
    _max?: WMMaintenanceRecordMaxOrderByAggregateInput
    _min?: WMMaintenanceRecordMinOrderByAggregateInput
    _sum?: WMMaintenanceRecordSumOrderByAggregateInput
  }

  export type WMMaintenanceRecordScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WMMaintenanceRecordScalarWhereWithAggregatesInput>
    OR?: Enumerable<WMMaintenanceRecordScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WMMaintenanceRecordScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    washingMachineId?: IntWithAggregatesFilter | number
    maintenanceDateTime?: DateTimeWithAggregatesFilter | Date | string
    level?: IntWithAggregatesFilter | number
    details?: StringWithAggregatesFilter | string
    binWashUserId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UsageRecordWhereInput = {
    AND?: Enumerable<UsageRecordWhereInput>
    OR?: Enumerable<UsageRecordWhereInput>
    NOT?: Enumerable<UsageRecordWhereInput>
    id?: IntFilter | number
    dateTime?: DateTimeFilter | Date | string
    user?: XOR<BinWashUserRelationFilter, BinWashUserWhereInput>
    binWashUserId?: IntFilter | number
    washingMachine?: XOR<WashingMachineRelationFilter, WashingMachineWhereInput>
    washingMachineId?: IntFilter | number
    program?: XOR<WMProgramRelationFilter, WMProgramWhereInput>
    wMProgramId?: IntFilter | number
    price?: FloatFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type UsageRecordOrderByWithRelationInput = {
    id?: SortOrder
    dateTime?: SortOrder
    user?: BinWashUserOrderByWithRelationInput
    binWashUserId?: SortOrder
    washingMachine?: WashingMachineOrderByWithRelationInput
    washingMachineId?: SortOrder
    program?: WMProgramOrderByWithRelationInput
    wMProgramId?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsageRecordWhereUniqueInput = {
    id?: number
  }

  export type UsageRecordOrderByWithAggregationInput = {
    id?: SortOrder
    dateTime?: SortOrder
    binWashUserId?: SortOrder
    washingMachineId?: SortOrder
    wMProgramId?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UsageRecordCountOrderByAggregateInput
    _avg?: UsageRecordAvgOrderByAggregateInput
    _max?: UsageRecordMaxOrderByAggregateInput
    _min?: UsageRecordMinOrderByAggregateInput
    _sum?: UsageRecordSumOrderByAggregateInput
  }

  export type UsageRecordScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UsageRecordScalarWhereWithAggregatesInput>
    OR?: Enumerable<UsageRecordScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UsageRecordScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    dateTime?: DateTimeWithAggregatesFilter | Date | string
    binWashUserId?: IntWithAggregatesFilter | number
    washingMachineId?: IntWithAggregatesFilter | number
    wMProgramId?: IntWithAggregatesFilter | number
    price?: FloatWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TopUpRecordWhereInput = {
    AND?: Enumerable<TopUpRecordWhereInput>
    OR?: Enumerable<TopUpRecordWhereInput>
    NOT?: Enumerable<TopUpRecordWhereInput>
    id?: IntFilter | number
    dateTime?: DateTimeFilter | Date | string
    user?: XOR<BinWashUserRelationFilter, BinWashUserWhereInput>
    binWashUserId?: IntFilter | number
    price?: FloatFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TopUpRecordOrderByWithRelationInput = {
    id?: SortOrder
    dateTime?: SortOrder
    user?: BinWashUserOrderByWithRelationInput
    binWashUserId?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TopUpRecordWhereUniqueInput = {
    id?: number
  }

  export type TopUpRecordOrderByWithAggregationInput = {
    id?: SortOrder
    dateTime?: SortOrder
    binWashUserId?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TopUpRecordCountOrderByAggregateInput
    _avg?: TopUpRecordAvgOrderByAggregateInput
    _max?: TopUpRecordMaxOrderByAggregateInput
    _min?: TopUpRecordMinOrderByAggregateInput
    _sum?: TopUpRecordSumOrderByAggregateInput
  }

  export type TopUpRecordScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TopUpRecordScalarWhereWithAggregatesInput>
    OR?: Enumerable<TopUpRecordScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TopUpRecordScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    dateTime?: DateTimeWithAggregatesFilter | Date | string
    binWashUserId?: IntWithAggregatesFilter | number
    price?: FloatWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FacebookUserWhereInput = {
    AND?: Enumerable<FacebookUserWhereInput>
    OR?: Enumerable<FacebookUserWhereInput>
    NOT?: Enumerable<FacebookUserWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    imageUrl?: StringFilter | string
    bio?: StringFilter | string
    followingUserRelations?: FacebookUserRelationListRelationFilter
    followedUserRelations?: FacebookUserRelationListRelationFilter
    posts?: PostListRelationFilter
    comments?: CommentListRelationFilter
    messengerMessagesFrom?: MessengerMessageListRelationFilter
    messengerMessagesTo?: MessengerMessageListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type FacebookUserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    bio?: SortOrder
    followingUserRelations?: FacebookUserRelationOrderByRelationAggregateInput
    followedUserRelations?: FacebookUserRelationOrderByRelationAggregateInput
    posts?: PostOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    messengerMessagesFrom?: MessengerMessageOrderByRelationAggregateInput
    messengerMessagesTo?: MessengerMessageOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookUserWhereUniqueInput = {
    id?: number
  }

  export type FacebookUserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FacebookUserCountOrderByAggregateInput
    _avg?: FacebookUserAvgOrderByAggregateInput
    _max?: FacebookUserMaxOrderByAggregateInput
    _min?: FacebookUserMinOrderByAggregateInput
    _sum?: FacebookUserSumOrderByAggregateInput
  }

  export type FacebookUserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FacebookUserScalarWhereWithAggregatesInput>
    OR?: Enumerable<FacebookUserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FacebookUserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    imageUrl?: StringWithAggregatesFilter | string
    bio?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FacebookUserRelationWhereInput = {
    AND?: Enumerable<FacebookUserRelationWhereInput>
    OR?: Enumerable<FacebookUserRelationWhereInput>
    NOT?: Enumerable<FacebookUserRelationWhereInput>
    id?: IntFilter | number
    followingUser?: XOR<FacebookUserRelationFilter, FacebookUserWhereInput>
    followingUserId?: IntFilter | number
    followedUser?: XOR<FacebookUserRelationFilter, FacebookUserWhereInput>
    followedUserId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type FacebookUserRelationOrderByWithRelationInput = {
    id?: SortOrder
    followingUser?: FacebookUserOrderByWithRelationInput
    followingUserId?: SortOrder
    followedUser?: FacebookUserOrderByWithRelationInput
    followedUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookUserRelationWhereUniqueInput = {
    id?: number
  }

  export type FacebookUserRelationOrderByWithAggregationInput = {
    id?: SortOrder
    followingUserId?: SortOrder
    followedUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FacebookUserRelationCountOrderByAggregateInput
    _avg?: FacebookUserRelationAvgOrderByAggregateInput
    _max?: FacebookUserRelationMaxOrderByAggregateInput
    _min?: FacebookUserRelationMinOrderByAggregateInput
    _sum?: FacebookUserRelationSumOrderByAggregateInput
  }

  export type FacebookUserRelationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FacebookUserRelationScalarWhereWithAggregatesInput>
    OR?: Enumerable<FacebookUserRelationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FacebookUserRelationScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    followingUserId?: IntWithAggregatesFilter | number
    followedUserId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type PostWhereInput = {
    AND?: Enumerable<PostWhereInput>
    OR?: Enumerable<PostWhereInput>
    NOT?: Enumerable<PostWhereInput>
    id?: IntFilter | number
    postText?: StringFilter | string
    postingUser?: XOR<FacebookUserRelationFilter, FacebookUserWhereInput>
    userId?: IntFilter | number
    comments?: CommentListRelationFilter
    hashTags?: FacebookHashTagListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type PostOrderByWithRelationInput = {
    id?: SortOrder
    postText?: SortOrder
    postingUser?: FacebookUserOrderByWithRelationInput
    userId?: SortOrder
    comments?: CommentOrderByRelationAggregateInput
    hashTags?: FacebookHashTagOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostWhereUniqueInput = {
    id?: number
  }

  export type PostOrderByWithAggregationInput = {
    id?: SortOrder
    postText?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PostCountOrderByAggregateInput
    _avg?: PostAvgOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
    _sum?: PostSumOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PostScalarWhereWithAggregatesInput>
    OR?: Enumerable<PostScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PostScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    postText?: StringWithAggregatesFilter | string
    userId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CommentWhereInput = {
    AND?: Enumerable<CommentWhereInput>
    OR?: Enumerable<CommentWhereInput>
    NOT?: Enumerable<CommentWhereInput>
    id?: IntFilter | number
    commentText?: StringFilter | string
    commentingUser?: XOR<FacebookUserRelationFilter, FacebookUserWhereInput>
    userId?: IntFilter | number
    parentPost?: XOR<PostRelationFilter, PostWhereInput>
    postId?: IntFilter | number
    parentComment?: XOR<CommentRelationFilter, CommentWhereInput> | null
    parentCommentId?: IntNullableFilter | number | null
    childComments?: CommentListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    commentText?: SortOrder
    commentingUser?: FacebookUserOrderByWithRelationInput
    userId?: SortOrder
    parentPost?: PostOrderByWithRelationInput
    postId?: SortOrder
    parentComment?: CommentOrderByWithRelationInput
    parentCommentId?: SortOrder
    childComments?: CommentOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentWhereUniqueInput = {
    id?: number
  }

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    commentText?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    parentCommentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _avg?: CommentAvgOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
    _sum?: CommentSumOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CommentScalarWhereWithAggregatesInput>
    OR?: Enumerable<CommentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CommentScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    commentText?: StringWithAggregatesFilter | string
    userId?: IntWithAggregatesFilter | number
    postId?: IntWithAggregatesFilter | number
    parentCommentId?: IntNullableWithAggregatesFilter | number | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FacebookHashTagWhereInput = {
    AND?: Enumerable<FacebookHashTagWhereInput>
    OR?: Enumerable<FacebookHashTagWhereInput>
    NOT?: Enumerable<FacebookHashTagWhereInput>
    id?: IntFilter | number
    hashTagText?: StringFilter | string
    isInPosts?: PostListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type FacebookHashTagOrderByWithRelationInput = {
    id?: SortOrder
    hashTagText?: SortOrder
    isInPosts?: PostOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookHashTagWhereUniqueInput = {
    id?: number
  }

  export type FacebookHashTagOrderByWithAggregationInput = {
    id?: SortOrder
    hashTagText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FacebookHashTagCountOrderByAggregateInput
    _avg?: FacebookHashTagAvgOrderByAggregateInput
    _max?: FacebookHashTagMaxOrderByAggregateInput
    _min?: FacebookHashTagMinOrderByAggregateInput
    _sum?: FacebookHashTagSumOrderByAggregateInput
  }

  export type FacebookHashTagScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FacebookHashTagScalarWhereWithAggregatesInput>
    OR?: Enumerable<FacebookHashTagScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FacebookHashTagScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    hashTagText?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type MessengerMessageWhereInput = {
    AND?: Enumerable<MessengerMessageWhereInput>
    OR?: Enumerable<MessengerMessageWhereInput>
    NOT?: Enumerable<MessengerMessageWhereInput>
    id?: IntFilter | number
    messengerText?: StringFilter | string
    fromUser?: XOR<FacebookUserRelationFilter, FacebookUserWhereInput>
    toUser?: XOR<FacebookUserRelationFilter, FacebookUserWhereInput>
    fromUserId?: IntFilter | number
    toUserId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type MessengerMessageOrderByWithRelationInput = {
    id?: SortOrder
    messengerText?: SortOrder
    fromUser?: FacebookUserOrderByWithRelationInput
    toUser?: FacebookUserOrderByWithRelationInput
    fromUserId?: SortOrder
    toUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessengerMessageWhereUniqueInput = {
    id?: number
  }

  export type MessengerMessageOrderByWithAggregationInput = {
    id?: SortOrder
    messengerText?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MessengerMessageCountOrderByAggregateInput
    _avg?: MessengerMessageAvgOrderByAggregateInput
    _max?: MessengerMessageMaxOrderByAggregateInput
    _min?: MessengerMessageMinOrderByAggregateInput
    _sum?: MessengerMessageSumOrderByAggregateInput
  }

  export type MessengerMessageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MessengerMessageScalarWhereWithAggregatesInput>
    OR?: Enumerable<MessengerMessageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MessengerMessageScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    messengerText?: StringWithAggregatesFilter | string
    fromUserId?: IntWithAggregatesFilter | number
    toUserId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AuthorWhereInput = {
    AND?: Enumerable<AuthorWhereInput>
    OR?: Enumerable<AuthorWhereInput>
    NOT?: Enumerable<AuthorWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    bookTitles?: BookTitleListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type AuthorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    bookTitles?: BookTitleOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuthorWhereUniqueInput = {
    id?: number
  }

  export type AuthorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AuthorCountOrderByAggregateInput
    _avg?: AuthorAvgOrderByAggregateInput
    _max?: AuthorMaxOrderByAggregateInput
    _min?: AuthorMinOrderByAggregateInput
    _sum?: AuthorSumOrderByAggregateInput
  }

  export type AuthorScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AuthorScalarWhereWithAggregatesInput>
    OR?: Enumerable<AuthorScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AuthorScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type BookTitleWhereInput = {
    AND?: Enumerable<BookTitleWhereInput>
    OR?: Enumerable<BookTitleWhereInput>
    NOT?: Enumerable<BookTitleWhereInput>
    id?: IntFilter | number
    title?: StringFilter | string
    isbn?: StringFilter | string
    authors?: AuthorListRelationFilter
    categories?: BookCategoryListRelationFilter
    books?: BookListRelationFilter
    requestRecords?: RequestRecordListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type BookTitleOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    isbn?: SortOrder
    authors?: AuthorOrderByRelationAggregateInput
    categories?: BookCategoryOrderByRelationAggregateInput
    books?: BookOrderByRelationAggregateInput
    requestRecords?: RequestRecordOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookTitleWhereUniqueInput = {
    id?: number
  }

  export type BookTitleOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    isbn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BookTitleCountOrderByAggregateInput
    _avg?: BookTitleAvgOrderByAggregateInput
    _max?: BookTitleMaxOrderByAggregateInput
    _min?: BookTitleMinOrderByAggregateInput
    _sum?: BookTitleSumOrderByAggregateInput
  }

  export type BookTitleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BookTitleScalarWhereWithAggregatesInput>
    OR?: Enumerable<BookTitleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BookTitleScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    title?: StringWithAggregatesFilter | string
    isbn?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type BookCategoryWhereInput = {
    AND?: Enumerable<BookCategoryWhereInput>
    OR?: Enumerable<BookCategoryWhereInput>
    NOT?: Enumerable<BookCategoryWhereInput>
    id?: IntFilter | number
    category?: StringFilter | string
    bookTitles?: BookTitleListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type BookCategoryOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    bookTitles?: BookTitleOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookCategoryWhereUniqueInput = {
    id?: number
  }

  export type BookCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BookCategoryCountOrderByAggregateInput
    _avg?: BookCategoryAvgOrderByAggregateInput
    _max?: BookCategoryMaxOrderByAggregateInput
    _min?: BookCategoryMinOrderByAggregateInput
    _sum?: BookCategorySumOrderByAggregateInput
  }

  export type BookCategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BookCategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<BookCategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BookCategoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    category?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type BookWhereInput = {
    AND?: Enumerable<BookWhereInput>
    OR?: Enumerable<BookWhereInput>
    NOT?: Enumerable<BookWhereInput>
    id?: IntFilter | number
    title?: XOR<BookTitleRelationFilter, BookTitleWhereInput>
    bookTitleId?: IntFilter | number
    belongsToLibrary?: XOR<LibraryRelationFilter, LibraryWhereInput>
    libraryId?: IntFilter | number
    isAvailable?: BoolFilter | boolean
    borrowingRecords?: BorrowingRecordListRelationFilter
    requestRecords?: RequestRecordListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type BookOrderByWithRelationInput = {
    id?: SortOrder
    title?: BookTitleOrderByWithRelationInput
    bookTitleId?: SortOrder
    belongsToLibrary?: LibraryOrderByWithRelationInput
    libraryId?: SortOrder
    isAvailable?: SortOrder
    borrowingRecords?: BorrowingRecordOrderByRelationAggregateInput
    requestRecords?: RequestRecordOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookWhereUniqueInput = {
    id?: number
  }

  export type BookOrderByWithAggregationInput = {
    id?: SortOrder
    bookTitleId?: SortOrder
    libraryId?: SortOrder
    isAvailable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BookCountOrderByAggregateInput
    _avg?: BookAvgOrderByAggregateInput
    _max?: BookMaxOrderByAggregateInput
    _min?: BookMinOrderByAggregateInput
    _sum?: BookSumOrderByAggregateInput
  }

  export type BookScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BookScalarWhereWithAggregatesInput>
    OR?: Enumerable<BookScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BookScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    bookTitleId?: IntWithAggregatesFilter | number
    libraryId?: IntWithAggregatesFilter | number
    isAvailable?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type LibraryWhereInput = {
    AND?: Enumerable<LibraryWhereInput>
    OR?: Enumerable<LibraryWhereInput>
    NOT?: Enumerable<LibraryWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    location?: StringFilter | string
    belongsToUniversity?: XOR<UniversityRelationFilter, UniversityWhereInput>
    universityId?: IntFilter | number
    books?: BookListRelationFilter
    requestingRecords?: RequestRecordListRelationFilter
    requestedRecords?: RequestRecordListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type LibraryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    belongsToUniversity?: UniversityOrderByWithRelationInput
    universityId?: SortOrder
    books?: BookOrderByRelationAggregateInput
    requestingRecords?: RequestRecordOrderByRelationAggregateInput
    requestedRecords?: RequestRecordOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryWhereUniqueInput = {
    id?: number
  }

  export type LibraryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    universityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LibraryCountOrderByAggregateInput
    _avg?: LibraryAvgOrderByAggregateInput
    _max?: LibraryMaxOrderByAggregateInput
    _min?: LibraryMinOrderByAggregateInput
    _sum?: LibrarySumOrderByAggregateInput
  }

  export type LibraryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LibraryScalarWhereWithAggregatesInput>
    OR?: Enumerable<LibraryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LibraryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    location?: StringWithAggregatesFilter | string
    universityId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UniversityWhereInput = {
    AND?: Enumerable<UniversityWhereInput>
    OR?: Enumerable<UniversityWhereInput>
    NOT?: Enumerable<UniversityWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    location?: StringFilter | string
    libraries?: LibraryListRelationFilter
    students?: StudentListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type UniversityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    libraries?: LibraryOrderByRelationAggregateInput
    students?: StudentOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UniversityWhereUniqueInput = {
    id?: number
  }

  export type UniversityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UniversityCountOrderByAggregateInput
    _avg?: UniversityAvgOrderByAggregateInput
    _max?: UniversityMaxOrderByAggregateInput
    _min?: UniversityMinOrderByAggregateInput
    _sum?: UniversitySumOrderByAggregateInput
  }

  export type UniversityScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UniversityScalarWhereWithAggregatesInput>
    OR?: Enumerable<UniversityScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UniversityScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    location?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type StudentWhereInput = {
    AND?: Enumerable<StudentWhereInput>
    OR?: Enumerable<StudentWhereInput>
    NOT?: Enumerable<StudentWhereInput>
    id?: IntFilter | number
    Name?: StringFilter | string
    belongsToUniversity?: XOR<UniversityRelationFilter, UniversityWhereInput>
    universityId?: IntFilter | number
    borrowingRecords?: BorrowingRecordListRelationFilter
    requestRecords?: RequestRecordListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type StudentOrderByWithRelationInput = {
    id?: SortOrder
    Name?: SortOrder
    belongsToUniversity?: UniversityOrderByWithRelationInput
    universityId?: SortOrder
    borrowingRecords?: BorrowingRecordOrderByRelationAggregateInput
    requestRecords?: RequestRecordOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentWhereUniqueInput = {
    id?: number
  }

  export type StudentOrderByWithAggregationInput = {
    id?: SortOrder
    Name?: SortOrder
    universityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentCountOrderByAggregateInput
    _avg?: StudentAvgOrderByAggregateInput
    _max?: StudentMaxOrderByAggregateInput
    _min?: StudentMinOrderByAggregateInput
    _sum?: StudentSumOrderByAggregateInput
  }

  export type StudentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StudentScalarWhereWithAggregatesInput>
    OR?: Enumerable<StudentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StudentScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    Name?: StringWithAggregatesFilter | string
    universityId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type BorrowingRecordWhereInput = {
    AND?: Enumerable<BorrowingRecordWhereInput>
    OR?: Enumerable<BorrowingRecordWhereInput>
    NOT?: Enumerable<BorrowingRecordWhereInput>
    id?: IntFilter | number
    borrowingStudent?: XOR<StudentRelationFilter, StudentWhereInput>
    studentId?: IntFilter | number
    borrowedBook?: XOR<BookRelationFilter, BookWhereInput>
    bookId?: IntFilter | number
    startDate?: DateTimeFilter | Date | string
    endDate?: DateTimeNullableFilter | Date | string | null
    actualEndDate?: DateTimeNullableFilter | Date | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type BorrowingRecordOrderByWithRelationInput = {
    id?: SortOrder
    borrowingStudent?: StudentOrderByWithRelationInput
    studentId?: SortOrder
    borrowedBook?: BookOrderByWithRelationInput
    bookId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    actualEndDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BorrowingRecordWhereUniqueInput = {
    id?: number
  }

  export type BorrowingRecordOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    bookId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    actualEndDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BorrowingRecordCountOrderByAggregateInput
    _avg?: BorrowingRecordAvgOrderByAggregateInput
    _max?: BorrowingRecordMaxOrderByAggregateInput
    _min?: BorrowingRecordMinOrderByAggregateInput
    _sum?: BorrowingRecordSumOrderByAggregateInput
  }

  export type BorrowingRecordScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BorrowingRecordScalarWhereWithAggregatesInput>
    OR?: Enumerable<BorrowingRecordScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BorrowingRecordScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    studentId?: IntWithAggregatesFilter | number
    bookId?: IntWithAggregatesFilter | number
    startDate?: DateTimeWithAggregatesFilter | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    actualEndDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type RequestRecordWhereInput = {
    AND?: Enumerable<RequestRecordWhereInput>
    OR?: Enumerable<RequestRecordWhereInput>
    NOT?: Enumerable<RequestRecordWhereInput>
    id?: IntFilter | number
    requestingStudent?: XOR<StudentRelationFilter, StudentWhereInput>
    studentId?: IntFilter | number
    requestedBookTitle?: XOR<BookTitleRelationFilter, BookTitleWhereInput>
    bookTitleId?: IntFilter | number
    requestingLibrary?: XOR<LibraryRelationFilter, LibraryWhereInput>
    requestingLibraryId?: IntFilter | number
    requestedLibrary?: XOR<LibraryRelationFilter, LibraryWhereInput>
    requestedLibraryId?: IntFilter | number
    requestDate?: DateTimeFilter | Date | string
    acquiredDate?: DateTimeNullableFilter | Date | string | null
    returnDate?: DateTimeNullableFilter | Date | string | null
    acquiredBook?: XOR<BookRelationFilter, BookWhereInput> | null
    bookId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type RequestRecordOrderByWithRelationInput = {
    id?: SortOrder
    requestingStudent?: StudentOrderByWithRelationInput
    studentId?: SortOrder
    requestedBookTitle?: BookTitleOrderByWithRelationInput
    bookTitleId?: SortOrder
    requestingLibrary?: LibraryOrderByWithRelationInput
    requestingLibraryId?: SortOrder
    requestedLibrary?: LibraryOrderByWithRelationInput
    requestedLibraryId?: SortOrder
    requestDate?: SortOrder
    acquiredDate?: SortOrder
    returnDate?: SortOrder
    acquiredBook?: BookOrderByWithRelationInput
    bookId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RequestRecordWhereUniqueInput = {
    id?: number
  }

  export type RequestRecordOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    bookTitleId?: SortOrder
    requestingLibraryId?: SortOrder
    requestedLibraryId?: SortOrder
    requestDate?: SortOrder
    acquiredDate?: SortOrder
    returnDate?: SortOrder
    bookId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RequestRecordCountOrderByAggregateInput
    _avg?: RequestRecordAvgOrderByAggregateInput
    _max?: RequestRecordMaxOrderByAggregateInput
    _min?: RequestRecordMinOrderByAggregateInput
    _sum?: RequestRecordSumOrderByAggregateInput
  }

  export type RequestRecordScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RequestRecordScalarWhereWithAggregatesInput>
    OR?: Enumerable<RequestRecordScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RequestRecordScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    studentId?: IntWithAggregatesFilter | number
    bookTitleId?: IntWithAggregatesFilter | number
    requestingLibraryId?: IntWithAggregatesFilter | number
    requestedLibraryId?: IntWithAggregatesFilter | number
    requestDate?: DateTimeWithAggregatesFilter | Date | string
    acquiredDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    returnDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    bookId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TodoListWhereInput = {
    AND?: Enumerable<TodoListWhereInput>
    OR?: Enumerable<TodoListWhereInput>
    NOT?: Enumerable<TodoListWhereInput>
    id?: IntFilter | number
    task?: StringFilter | string
    status?: StringFilter | string
    bgColor?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TodoListOrderByWithRelationInput = {
    id?: SortOrder
    task?: SortOrder
    status?: SortOrder
    bgColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TodoListWhereUniqueInput = {
    id?: number
  }

  export type TodoListOrderByWithAggregationInput = {
    id?: SortOrder
    task?: SortOrder
    status?: SortOrder
    bgColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TodoListCountOrderByAggregateInput
    _avg?: TodoListAvgOrderByAggregateInput
    _max?: TodoListMaxOrderByAggregateInput
    _min?: TodoListMinOrderByAggregateInput
    _sum?: TodoListSumOrderByAggregateInput
  }

  export type TodoListScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TodoListScalarWhereWithAggregatesInput>
    OR?: Enumerable<TodoListScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TodoListScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    task?: StringWithAggregatesFilter | string
    status?: StringWithAggregatesFilter | string
    bgColor?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    imageUrl?: StringFilter | string
    bio?: StringFilter | string
    followingUserRelations?: UserRelationListRelationFilter
    followedUserRelations?: UserRelationListRelationFilter
    tweets?: TweetListRelationFilter
    directMessagesFrom?: DirectMessageListRelationFilter
    directMessagesTo?: DirectMessageListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    bio?: SortOrder
    followingUserRelations?: UserRelationOrderByRelationAggregateInput
    followedUserRelations?: UserRelationOrderByRelationAggregateInput
    tweets?: TweetOrderByRelationAggregateInput
    directMessagesFrom?: DirectMessageOrderByRelationAggregateInput
    directMessagesTo?: DirectMessageOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserWhereUniqueInput = {
    id?: number
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    imageUrl?: StringWithAggregatesFilter | string
    bio?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserRelationWhereInput = {
    AND?: Enumerable<UserRelationWhereInput>
    OR?: Enumerable<UserRelationWhereInput>
    NOT?: Enumerable<UserRelationWhereInput>
    id?: IntFilter | number
    followingUser?: XOR<UserRelationFilter, UserWhereInput>
    followingUserId?: IntFilter | number
    followedUser?: XOR<UserRelationFilter, UserWhereInput>
    followedUserId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type UserRelationOrderByWithRelationInput = {
    id?: SortOrder
    followingUser?: UserOrderByWithRelationInput
    followingUserId?: SortOrder
    followedUser?: UserOrderByWithRelationInput
    followedUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserRelationWhereUniqueInput = {
    id?: number
  }

  export type UserRelationOrderByWithAggregationInput = {
    id?: SortOrder
    followingUserId?: SortOrder
    followedUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserRelationCountOrderByAggregateInput
    _avg?: UserRelationAvgOrderByAggregateInput
    _max?: UserRelationMaxOrderByAggregateInput
    _min?: UserRelationMinOrderByAggregateInput
    _sum?: UserRelationSumOrderByAggregateInput
  }

  export type UserRelationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserRelationScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserRelationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserRelationScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    followingUserId?: IntWithAggregatesFilter | number
    followedUserId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TweetWhereInput = {
    AND?: Enumerable<TweetWhereInput>
    OR?: Enumerable<TweetWhereInput>
    NOT?: Enumerable<TweetWhereInput>
    id?: IntFilter | number
    tweetText?: StringFilter | string
    tweetingUser?: XOR<UserRelationFilter, UserWhereInput>
    parentTweet?: XOR<TweetRelationFilter, TweetWhereInput> | null
    parentTweetId?: IntNullableFilter | number | null
    childTweets?: TweetListRelationFilter
    userId?: IntFilter | number
    hashTags?: HashTagListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TweetOrderByWithRelationInput = {
    id?: SortOrder
    tweetText?: SortOrder
    tweetingUser?: UserOrderByWithRelationInput
    parentTweet?: TweetOrderByWithRelationInput
    parentTweetId?: SortOrder
    childTweets?: TweetOrderByRelationAggregateInput
    userId?: SortOrder
    hashTags?: HashTagOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TweetWhereUniqueInput = {
    id?: number
  }

  export type TweetOrderByWithAggregationInput = {
    id?: SortOrder
    tweetText?: SortOrder
    parentTweetId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TweetCountOrderByAggregateInput
    _avg?: TweetAvgOrderByAggregateInput
    _max?: TweetMaxOrderByAggregateInput
    _min?: TweetMinOrderByAggregateInput
    _sum?: TweetSumOrderByAggregateInput
  }

  export type TweetScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TweetScalarWhereWithAggregatesInput>
    OR?: Enumerable<TweetScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TweetScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    tweetText?: StringWithAggregatesFilter | string
    parentTweetId?: IntNullableWithAggregatesFilter | number | null
    userId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type HashTagWhereInput = {
    AND?: Enumerable<HashTagWhereInput>
    OR?: Enumerable<HashTagWhereInput>
    NOT?: Enumerable<HashTagWhereInput>
    id?: IntFilter | number
    hashTagText?: StringFilter | string
    isInTweets?: TweetListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type HashTagOrderByWithRelationInput = {
    id?: SortOrder
    hashTagText?: SortOrder
    isInTweets?: TweetOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HashTagWhereUniqueInput = {
    id?: number
  }

  export type HashTagOrderByWithAggregationInput = {
    id?: SortOrder
    hashTagText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HashTagCountOrderByAggregateInput
    _avg?: HashTagAvgOrderByAggregateInput
    _max?: HashTagMaxOrderByAggregateInput
    _min?: HashTagMinOrderByAggregateInput
    _sum?: HashTagSumOrderByAggregateInput
  }

  export type HashTagScalarWhereWithAggregatesInput = {
    AND?: Enumerable<HashTagScalarWhereWithAggregatesInput>
    OR?: Enumerable<HashTagScalarWhereWithAggregatesInput>
    NOT?: Enumerable<HashTagScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    hashTagText?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type DirectMessageWhereInput = {
    AND?: Enumerable<DirectMessageWhereInput>
    OR?: Enumerable<DirectMessageWhereInput>
    NOT?: Enumerable<DirectMessageWhereInput>
    id?: IntFilter | number
    dmText?: StringFilter | string
    fromUser?: XOR<UserRelationFilter, UserWhereInput>
    toUser?: XOR<UserRelationFilter, UserWhereInput>
    fromUserId?: IntFilter | number
    toUserId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type DirectMessageOrderByWithRelationInput = {
    id?: SortOrder
    dmText?: SortOrder
    fromUser?: UserOrderByWithRelationInput
    toUser?: UserOrderByWithRelationInput
    fromUserId?: SortOrder
    toUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DirectMessageWhereUniqueInput = {
    id?: number
  }

  export type DirectMessageOrderByWithAggregationInput = {
    id?: SortOrder
    dmText?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DirectMessageCountOrderByAggregateInput
    _avg?: DirectMessageAvgOrderByAggregateInput
    _max?: DirectMessageMaxOrderByAggregateInput
    _min?: DirectMessageMinOrderByAggregateInput
    _sum?: DirectMessageSumOrderByAggregateInput
  }

  export type DirectMessageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DirectMessageScalarWhereWithAggregatesInput>
    OR?: Enumerable<DirectMessageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DirectMessageScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    dmText?: StringWithAggregatesFilter | string
    fromUserId?: IntWithAggregatesFilter | number
    toUserId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type YouTubeUserWhereInput = {
    AND?: Enumerable<YouTubeUserWhereInput>
    OR?: Enumerable<YouTubeUserWhereInput>
    NOT?: Enumerable<YouTubeUserWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    profileImageUrl?: StringNullableFilter | string | null
    bio?: StringNullableFilter | string | null
    adminOfChannels?: ChannelListRelationFilter
    usersToChannelswithRoles?: UserToChannelwithRoleListRelationFilter
    subscribingToChannels?: ChannelListRelationFilter
    reactedVideos?: VideoListRelationFilter
    usersToVideosWithReactions?: UserToVideoWithReactionListRelationFilter
    videoComments?: VideoCommentListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type YouTubeUserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    profileImageUrl?: SortOrder
    bio?: SortOrder
    adminOfChannels?: ChannelOrderByRelationAggregateInput
    usersToChannelswithRoles?: UserToChannelwithRoleOrderByRelationAggregateInput
    subscribingToChannels?: ChannelOrderByRelationAggregateInput
    reactedVideos?: VideoOrderByRelationAggregateInput
    usersToVideosWithReactions?: UserToVideoWithReactionOrderByRelationAggregateInput
    videoComments?: VideoCommentOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YouTubeUserWhereUniqueInput = {
    id?: number
  }

  export type YouTubeUserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    profileImageUrl?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: YouTubeUserCountOrderByAggregateInput
    _avg?: YouTubeUserAvgOrderByAggregateInput
    _max?: YouTubeUserMaxOrderByAggregateInput
    _min?: YouTubeUserMinOrderByAggregateInput
    _sum?: YouTubeUserSumOrderByAggregateInput
  }

  export type YouTubeUserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<YouTubeUserScalarWhereWithAggregatesInput>
    OR?: Enumerable<YouTubeUserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<YouTubeUserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    profileImageUrl?: StringNullableWithAggregatesFilter | string | null
    bio?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ChannelWhereInput = {
    AND?: Enumerable<ChannelWhereInput>
    OR?: Enumerable<ChannelWhereInput>
    NOT?: Enumerable<ChannelWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    profileImageUrl?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    adminUsers?: YouTubeUserListRelationFilter
    subscribedUsers?: YouTubeUserListRelationFilter
    usersToChannelswithRoles?: UserToChannelwithRoleListRelationFilter
    owningVideos?: VideoListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ChannelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    profileImageUrl?: SortOrder
    description?: SortOrder
    adminUsers?: YouTubeUserOrderByRelationAggregateInput
    subscribedUsers?: YouTubeUserOrderByRelationAggregateInput
    usersToChannelswithRoles?: UserToChannelwithRoleOrderByRelationAggregateInput
    owningVideos?: VideoOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChannelWhereUniqueInput = {
    id?: number
  }

  export type ChannelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    profileImageUrl?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChannelCountOrderByAggregateInput
    _avg?: ChannelAvgOrderByAggregateInput
    _max?: ChannelMaxOrderByAggregateInput
    _min?: ChannelMinOrderByAggregateInput
    _sum?: ChannelSumOrderByAggregateInput
  }

  export type ChannelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ChannelScalarWhereWithAggregatesInput>
    OR?: Enumerable<ChannelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ChannelScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    profileImageUrl?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserToChannelwithRoleWhereInput = {
    AND?: Enumerable<UserToChannelwithRoleWhereInput>
    OR?: Enumerable<UserToChannelwithRoleWhereInput>
    NOT?: Enumerable<UserToChannelwithRoleWhereInput>
    id?: IntFilter | number
    user?: XOR<YouTubeUserRelationFilter, YouTubeUserWhereInput>
    youTubeUserId?: IntFilter | number
    channel?: XOR<ChannelRelationFilter, ChannelWhereInput>
    channelId?: IntFilter | number
    role?: EnumRoleEnumFilter | RoleEnum
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type UserToChannelwithRoleOrderByWithRelationInput = {
    id?: SortOrder
    user?: YouTubeUserOrderByWithRelationInput
    youTubeUserId?: SortOrder
    channel?: ChannelOrderByWithRelationInput
    channelId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserToChannelwithRoleWhereUniqueInput = {
    id?: number
  }

  export type UserToChannelwithRoleOrderByWithAggregationInput = {
    id?: SortOrder
    youTubeUserId?: SortOrder
    channelId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserToChannelwithRoleCountOrderByAggregateInput
    _avg?: UserToChannelwithRoleAvgOrderByAggregateInput
    _max?: UserToChannelwithRoleMaxOrderByAggregateInput
    _min?: UserToChannelwithRoleMinOrderByAggregateInput
    _sum?: UserToChannelwithRoleSumOrderByAggregateInput
  }

  export type UserToChannelwithRoleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserToChannelwithRoleScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserToChannelwithRoleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserToChannelwithRoleScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    youTubeUserId?: IntWithAggregatesFilter | number
    channelId?: IntWithAggregatesFilter | number
    role?: EnumRoleEnumWithAggregatesFilter | RoleEnum
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type VideoWhereInput = {
    AND?: Enumerable<VideoWhereInput>
    OR?: Enumerable<VideoWhereInput>
    NOT?: Enumerable<VideoWhereInput>
    id?: IntFilter | number
    title?: StringFilter | string
    videoUrl?: StringFilter | string
    thumbnailImageUrl?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    belongsToChannel?: XOR<ChannelRelationFilter, ChannelWhereInput>
    channelId?: IntFilter | number
    reactedByYouTubeUsers?: YouTubeUserListRelationFilter
    usersToVideosWithReactions?: UserToVideoWithReactionListRelationFilter
    videoComments?: VideoCommentListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type VideoOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    videoUrl?: SortOrder
    thumbnailImageUrl?: SortOrder
    description?: SortOrder
    belongsToChannel?: ChannelOrderByWithRelationInput
    channelId?: SortOrder
    reactedByYouTubeUsers?: YouTubeUserOrderByRelationAggregateInput
    usersToVideosWithReactions?: UserToVideoWithReactionOrderByRelationAggregateInput
    videoComments?: VideoCommentOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoWhereUniqueInput = {
    id?: number
  }

  export type VideoOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    videoUrl?: SortOrder
    thumbnailImageUrl?: SortOrder
    description?: SortOrder
    channelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VideoCountOrderByAggregateInput
    _avg?: VideoAvgOrderByAggregateInput
    _max?: VideoMaxOrderByAggregateInput
    _min?: VideoMinOrderByAggregateInput
    _sum?: VideoSumOrderByAggregateInput
  }

  export type VideoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<VideoScalarWhereWithAggregatesInput>
    OR?: Enumerable<VideoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<VideoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    title?: StringWithAggregatesFilter | string
    videoUrl?: StringWithAggregatesFilter | string
    thumbnailImageUrl?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    channelId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserToVideoWithReactionWhereInput = {
    AND?: Enumerable<UserToVideoWithReactionWhereInput>
    OR?: Enumerable<UserToVideoWithReactionWhereInput>
    NOT?: Enumerable<UserToVideoWithReactionWhereInput>
    id?: IntFilter | number
    user?: XOR<YouTubeUserRelationFilter, YouTubeUserWhereInput>
    youTubeUserId?: IntFilter | number
    video?: XOR<VideoRelationFilter, VideoWhereInput>
    videoId?: IntFilter | number
    reaction?: EnumReactionEnumFilter | ReactionEnum
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type UserToVideoWithReactionOrderByWithRelationInput = {
    id?: SortOrder
    user?: YouTubeUserOrderByWithRelationInput
    youTubeUserId?: SortOrder
    video?: VideoOrderByWithRelationInput
    videoId?: SortOrder
    reaction?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserToVideoWithReactionWhereUniqueInput = {
    id?: number
  }

  export type UserToVideoWithReactionOrderByWithAggregationInput = {
    id?: SortOrder
    youTubeUserId?: SortOrder
    videoId?: SortOrder
    reaction?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserToVideoWithReactionCountOrderByAggregateInput
    _avg?: UserToVideoWithReactionAvgOrderByAggregateInput
    _max?: UserToVideoWithReactionMaxOrderByAggregateInput
    _min?: UserToVideoWithReactionMinOrderByAggregateInput
    _sum?: UserToVideoWithReactionSumOrderByAggregateInput
  }

  export type UserToVideoWithReactionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserToVideoWithReactionScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserToVideoWithReactionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserToVideoWithReactionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    youTubeUserId?: IntWithAggregatesFilter | number
    videoId?: IntWithAggregatesFilter | number
    reaction?: EnumReactionEnumWithAggregatesFilter | ReactionEnum
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type VideoCommentWhereInput = {
    AND?: Enumerable<VideoCommentWhereInput>
    OR?: Enumerable<VideoCommentWhereInput>
    NOT?: Enumerable<VideoCommentWhereInput>
    id?: IntFilter | number
    commentText?: StringFilter | string
    commentingUser?: XOR<YouTubeUserRelationFilter, YouTubeUserWhereInput>
    youTubeUserId?: IntFilter | number
    parentVideo?: XOR<VideoRelationFilter, VideoWhereInput>
    videoId?: IntFilter | number
    parentVideoComment?: XOR<VideoCommentRelationFilter, VideoCommentWhereInput> | null
    parentVideoCommentId?: IntNullableFilter | number | null
    childVideoComments?: VideoCommentListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type VideoCommentOrderByWithRelationInput = {
    id?: SortOrder
    commentText?: SortOrder
    commentingUser?: YouTubeUserOrderByWithRelationInput
    youTubeUserId?: SortOrder
    parentVideo?: VideoOrderByWithRelationInput
    videoId?: SortOrder
    parentVideoComment?: VideoCommentOrderByWithRelationInput
    parentVideoCommentId?: SortOrder
    childVideoComments?: VideoCommentOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoCommentWhereUniqueInput = {
    id?: number
  }

  export type VideoCommentOrderByWithAggregationInput = {
    id?: SortOrder
    commentText?: SortOrder
    youTubeUserId?: SortOrder
    videoId?: SortOrder
    parentVideoCommentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VideoCommentCountOrderByAggregateInput
    _avg?: VideoCommentAvgOrderByAggregateInput
    _max?: VideoCommentMaxOrderByAggregateInput
    _min?: VideoCommentMinOrderByAggregateInput
    _sum?: VideoCommentSumOrderByAggregateInput
  }

  export type VideoCommentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<VideoCommentScalarWhereWithAggregatesInput>
    OR?: Enumerable<VideoCommentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<VideoCommentScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    commentText?: StringWithAggregatesFilter | string
    youTubeUserId?: IntWithAggregatesFilter | number
    videoId?: IntWithAggregatesFilter | number
    parentVideoCommentId?: IntNullableWithAggregatesFilter | number | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CategoryCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Menu?: MenuCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Menu?: MenuUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Menu?: MenuUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Menu?: MenuUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuCreateInput = {
    name: string
    image: string
    price: number
    category?: CategoryCreateNestedOneWithoutMenuInput
    orderItems?: OrderItemCreateNestedManyWithoutMenuInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuUncheckedCreateInput = {
    id?: number
    name: string
    image: string
    price: number
    categoryId?: number | null
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutMenuInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    category?: CategoryUpdateOneWithoutMenuNestedInput
    orderItems?: OrderItemUpdateManyWithoutMenuNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    orderItems?: OrderItemUncheckedUpdateManyWithoutMenuNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuCreateManyInput = {
    id?: number
    name: string
    image: string
    price: number
    categoryId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    status?: string
    tableId: number
    items?: OrderItemCreateNestedManyWithoutOrderInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUncheckedCreateInput = {
    id?: number
    status?: string
    tableId: number
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateInput = {
    status?: StringFieldUpdateOperationsInput | string
    tableId?: IntFieldUpdateOperationsInput | number
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    tableId?: IntFieldUpdateOperationsInput | number
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyInput = {
    id?: number
    status?: string
    tableId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateManyMutationInput = {
    status?: StringFieldUpdateOperationsInput | string
    tableId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    tableId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateInput = {
    menu: MenuCreateNestedOneWithoutOrderItemsInput
    order?: OrderCreateNestedOneWithoutItemsInput
    quantity: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemUncheckedCreateInput = {
    id?: number
    menuId: number
    orderId?: number | null
    quantity: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemUpdateInput = {
    menu?: MenuUpdateOneRequiredWithoutOrderItemsNestedInput
    order?: OrderUpdateOneWithoutItemsNestedInput
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuId?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManyInput = {
    id?: number
    menuId: number
    orderId?: number | null
    quantity: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuId?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizCategoryCreateInput = {
    name: string
    quizzes?: QuizCreateNestedManyWithoutCategoryInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizCategoryUncheckedCreateInput = {
    id?: number
    name: string
    quizzes?: QuizUncheckedCreateNestedManyWithoutCategoryInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizCategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    quizzes?: QuizUpdateManyWithoutCategoryNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    quizzes?: QuizUncheckedUpdateManyWithoutCategoryNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizCategoryCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizCategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoiceCreateInput = {
    answerText: string
    quiz?: QuizCreateNestedOneWithoutChoicesInput
    correctQuizzes?: QuizCreateNestedManyWithoutCorrectChoiceInput
    rounds?: RoundCreateNestedManyWithoutSelectedChoicesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChoiceUncheckedCreateInput = {
    id?: number
    answerText: string
    quizId?: number | null
    correctQuizzes?: QuizUncheckedCreateNestedManyWithoutCorrectChoiceInput
    rounds?: RoundUncheckedCreateNestedManyWithoutSelectedChoicesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChoiceUpdateInput = {
    answerText?: StringFieldUpdateOperationsInput | string
    quiz?: QuizUpdateOneWithoutChoicesNestedInput
    correctQuizzes?: QuizUpdateManyWithoutCorrectChoiceNestedInput
    rounds?: RoundUpdateManyWithoutSelectedChoicesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    answerText?: StringFieldUpdateOperationsInput | string
    quizId?: NullableIntFieldUpdateOperationsInput | number | null
    correctQuizzes?: QuizUncheckedUpdateManyWithoutCorrectChoiceNestedInput
    rounds?: RoundUncheckedUpdateManyWithoutSelectedChoicesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoiceCreateManyInput = {
    id?: number
    answerText: string
    quizId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChoiceUpdateManyMutationInput = {
    answerText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    answerText?: StringFieldUpdateOperationsInput | string
    quizId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizCreateInput = {
    questionText: string
    category: QuizCategoryCreateNestedOneWithoutQuizzesInput
    choices?: ChoiceCreateNestedManyWithoutQuizInput
    correctChoice: ChoiceCreateNestedOneWithoutCorrectQuizzesInput
    rounds?: RoundCreateNestedManyWithoutQuizzesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizUncheckedCreateInput = {
    id?: number
    questionText: string
    quizCategoryId: number
    choices?: ChoiceUncheckedCreateNestedManyWithoutQuizInput
    correctChoiceId: number
    rounds?: RoundUncheckedCreateNestedManyWithoutQuizzesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizUpdateInput = {
    questionText?: StringFieldUpdateOperationsInput | string
    category?: QuizCategoryUpdateOneRequiredWithoutQuizzesNestedInput
    choices?: ChoiceUpdateManyWithoutQuizNestedInput
    correctChoice?: ChoiceUpdateOneRequiredWithoutCorrectQuizzesNestedInput
    rounds?: RoundUpdateManyWithoutQuizzesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionText?: StringFieldUpdateOperationsInput | string
    quizCategoryId?: IntFieldUpdateOperationsInput | number
    choices?: ChoiceUncheckedUpdateManyWithoutQuizNestedInput
    correctChoiceId?: IntFieldUpdateOperationsInput | number
    rounds?: RoundUncheckedUpdateManyWithoutQuizzesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizCreateManyInput = {
    id?: number
    questionText: string
    quizCategoryId: number
    correctChoiceId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizUpdateManyMutationInput = {
    questionText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionText?: StringFieldUpdateOperationsInput | string
    quizCategoryId?: IntFieldUpdateOperationsInput | number
    correctChoiceId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoundCreateInput = {
    quizzes?: QuizCreateNestedManyWithoutRoundsInput
    selectedChoices?: ChoiceCreateNestedManyWithoutRoundsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoundUncheckedCreateInput = {
    id?: number
    quizzes?: QuizUncheckedCreateNestedManyWithoutRoundsInput
    selectedChoices?: ChoiceUncheckedCreateNestedManyWithoutRoundsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoundUpdateInput = {
    quizzes?: QuizUpdateManyWithoutRoundsNestedInput
    selectedChoices?: ChoiceUpdateManyWithoutRoundsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoundUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizzes?: QuizUncheckedUpdateManyWithoutRoundsNestedInput
    selectedChoices?: ChoiceUncheckedUpdateManyWithoutRoundsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoundCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoundUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoundUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinWashUserCreateInput = {
    name: string
    balance: number
    owningBranches?: BranchCreateNestedManyWithoutBranchOwnerInput
    wMMaintenanceRecords?: WMMaintenanceRecordCreateNestedManyWithoutMaintainerInput
    usageRecords?: UsageRecordCreateNestedManyWithoutUserInput
    topUpRecords?: TopUpRecordCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinWashUserUncheckedCreateInput = {
    id?: number
    name: string
    balance: number
    owningBranches?: BranchUncheckedCreateNestedManyWithoutBranchOwnerInput
    wMMaintenanceRecords?: WMMaintenanceRecordUncheckedCreateNestedManyWithoutMaintainerInput
    usageRecords?: UsageRecordUncheckedCreateNestedManyWithoutUserInput
    topUpRecords?: TopUpRecordUncheckedCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinWashUserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    owningBranches?: BranchUpdateManyWithoutBranchOwnerNestedInput
    wMMaintenanceRecords?: WMMaintenanceRecordUpdateManyWithoutMaintainerNestedInput
    usageRecords?: UsageRecordUpdateManyWithoutUserNestedInput
    topUpRecords?: TopUpRecordUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinWashUserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    owningBranches?: BranchUncheckedUpdateManyWithoutBranchOwnerNestedInput
    wMMaintenanceRecords?: WMMaintenanceRecordUncheckedUpdateManyWithoutMaintainerNestedInput
    usageRecords?: UsageRecordUncheckedUpdateManyWithoutUserNestedInput
    topUpRecords?: TopUpRecordUncheckedUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinWashUserCreateManyInput = {
    id?: number
    name: string
    balance: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinWashUserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinWashUserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchCreateInput = {
    name: string
    location: string
    telephoneNo: string
    area: number
    branchOwner: BinWashUserCreateNestedOneWithoutOwningBranchesInput
    washingMachines?: WashingMachineCreateNestedManyWithoutLocatedBranchInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BranchUncheckedCreateInput = {
    id?: number
    name: string
    location: string
    telephoneNo: string
    area: number
    binWashUserId: number
    washingMachines?: WashingMachineUncheckedCreateNestedManyWithoutLocatedBranchInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BranchUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    telephoneNo?: StringFieldUpdateOperationsInput | string
    area?: FloatFieldUpdateOperationsInput | number
    branchOwner?: BinWashUserUpdateOneRequiredWithoutOwningBranchesNestedInput
    washingMachines?: WashingMachineUpdateManyWithoutLocatedBranchNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    telephoneNo?: StringFieldUpdateOperationsInput | string
    area?: FloatFieldUpdateOperationsInput | number
    binWashUserId?: IntFieldUpdateOperationsInput | number
    washingMachines?: WashingMachineUncheckedUpdateManyWithoutLocatedBranchNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchCreateManyInput = {
    id?: number
    name: string
    location: string
    telephoneNo: string
    area: number
    binWashUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BranchUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    telephoneNo?: StringFieldUpdateOperationsInput | string
    area?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    telephoneNo?: StringFieldUpdateOperationsInput | string
    area?: FloatFieldUpdateOperationsInput | number
    binWashUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WashingMachineCreateInput = {
    brand: string
    model: string
    type: WMTypeEnum
    capacity: number
    manufacturedYear: Date | string
    warrantyEndDate: Date | string
    locatedBranch: BranchCreateNestedOneWithoutWashingMachinesInput
    equippedPrograms?: WMProgramCreateNestedManyWithoutEquippingWMsInput
    usageRecords?: UsageRecordCreateNestedManyWithoutWashingMachineInput
    wMMaintenanceRecords?: WMMaintenanceRecordCreateNestedManyWithoutMaintainedWMInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WashingMachineUncheckedCreateInput = {
    id?: number
    brand: string
    model: string
    type: WMTypeEnum
    capacity: number
    manufacturedYear: Date | string
    warrantyEndDate: Date | string
    branchId: number
    equippedPrograms?: WMProgramUncheckedCreateNestedManyWithoutEquippingWMsInput
    usageRecords?: UsageRecordUncheckedCreateNestedManyWithoutWashingMachineInput
    wMMaintenanceRecords?: WMMaintenanceRecordUncheckedCreateNestedManyWithoutMaintainedWMInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WashingMachineUpdateInput = {
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    type?: EnumWMTypeEnumFieldUpdateOperationsInput | WMTypeEnum
    capacity?: FloatFieldUpdateOperationsInput | number
    manufacturedYear?: DateTimeFieldUpdateOperationsInput | Date | string
    warrantyEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    locatedBranch?: BranchUpdateOneRequiredWithoutWashingMachinesNestedInput
    equippedPrograms?: WMProgramUpdateManyWithoutEquippingWMsNestedInput
    usageRecords?: UsageRecordUpdateManyWithoutWashingMachineNestedInput
    wMMaintenanceRecords?: WMMaintenanceRecordUpdateManyWithoutMaintainedWMNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WashingMachineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    type?: EnumWMTypeEnumFieldUpdateOperationsInput | WMTypeEnum
    capacity?: FloatFieldUpdateOperationsInput | number
    manufacturedYear?: DateTimeFieldUpdateOperationsInput | Date | string
    warrantyEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: IntFieldUpdateOperationsInput | number
    equippedPrograms?: WMProgramUncheckedUpdateManyWithoutEquippingWMsNestedInput
    usageRecords?: UsageRecordUncheckedUpdateManyWithoutWashingMachineNestedInput
    wMMaintenanceRecords?: WMMaintenanceRecordUncheckedUpdateManyWithoutMaintainedWMNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WashingMachineCreateManyInput = {
    id?: number
    brand: string
    model: string
    type: WMTypeEnum
    capacity: number
    manufacturedYear: Date | string
    warrantyEndDate: Date | string
    branchId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WashingMachineUpdateManyMutationInput = {
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    type?: EnumWMTypeEnumFieldUpdateOperationsInput | WMTypeEnum
    capacity?: FloatFieldUpdateOperationsInput | number
    manufacturedYear?: DateTimeFieldUpdateOperationsInput | Date | string
    warrantyEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WashingMachineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    type?: EnumWMTypeEnumFieldUpdateOperationsInput | WMTypeEnum
    capacity?: FloatFieldUpdateOperationsInput | number
    manufacturedYear?: DateTimeFieldUpdateOperationsInput | Date | string
    warrantyEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WMProgramCreateInput = {
    name: string
    maxCapacity: number
    duration: number
    price: number
    equippingWMs?: WashingMachineCreateNestedManyWithoutEquippedProgramsInput
    usageRecords?: UsageRecordCreateNestedManyWithoutProgramInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WMProgramUncheckedCreateInput = {
    id?: number
    name: string
    maxCapacity: number
    duration: number
    price: number
    equippingWMs?: WashingMachineUncheckedCreateNestedManyWithoutEquippedProgramsInput
    usageRecords?: UsageRecordUncheckedCreateNestedManyWithoutProgramInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WMProgramUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    maxCapacity?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    equippingWMs?: WashingMachineUpdateManyWithoutEquippedProgramsNestedInput
    usageRecords?: UsageRecordUpdateManyWithoutProgramNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WMProgramUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    maxCapacity?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    equippingWMs?: WashingMachineUncheckedUpdateManyWithoutEquippedProgramsNestedInput
    usageRecords?: UsageRecordUncheckedUpdateManyWithoutProgramNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WMProgramCreateManyInput = {
    id?: number
    name: string
    maxCapacity: number
    duration: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WMProgramUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    maxCapacity?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WMProgramUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    maxCapacity?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WMMaintenanceRecordCreateInput = {
    maintainedWM: WashingMachineCreateNestedOneWithoutWMMaintenanceRecordsInput
    maintenanceDateTime: Date | string
    level: number
    details: string
    maintainer: BinWashUserCreateNestedOneWithoutWMMaintenanceRecordsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WMMaintenanceRecordUncheckedCreateInput = {
    id?: number
    washingMachineId: number
    maintenanceDateTime: Date | string
    level: number
    details: string
    binWashUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WMMaintenanceRecordUpdateInput = {
    maintainedWM?: WashingMachineUpdateOneRequiredWithoutWMMaintenanceRecordsNestedInput
    maintenanceDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: IntFieldUpdateOperationsInput | number
    details?: StringFieldUpdateOperationsInput | string
    maintainer?: BinWashUserUpdateOneRequiredWithoutWMMaintenanceRecordsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WMMaintenanceRecordUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    washingMachineId?: IntFieldUpdateOperationsInput | number
    maintenanceDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: IntFieldUpdateOperationsInput | number
    details?: StringFieldUpdateOperationsInput | string
    binWashUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WMMaintenanceRecordCreateManyInput = {
    id?: number
    washingMachineId: number
    maintenanceDateTime: Date | string
    level: number
    details: string
    binWashUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WMMaintenanceRecordUpdateManyMutationInput = {
    maintenanceDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: IntFieldUpdateOperationsInput | number
    details?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WMMaintenanceRecordUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    washingMachineId?: IntFieldUpdateOperationsInput | number
    maintenanceDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: IntFieldUpdateOperationsInput | number
    details?: StringFieldUpdateOperationsInput | string
    binWashUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageRecordCreateInput = {
    dateTime: Date | string
    user: BinWashUserCreateNestedOneWithoutUsageRecordsInput
    washingMachine: WashingMachineCreateNestedOneWithoutUsageRecordsInput
    program: WMProgramCreateNestedOneWithoutUsageRecordsInput
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsageRecordUncheckedCreateInput = {
    id?: number
    dateTime: Date | string
    binWashUserId: number
    washingMachineId: number
    wMProgramId: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsageRecordUpdateInput = {
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: BinWashUserUpdateOneRequiredWithoutUsageRecordsNestedInput
    washingMachine?: WashingMachineUpdateOneRequiredWithoutUsageRecordsNestedInput
    program?: WMProgramUpdateOneRequiredWithoutUsageRecordsNestedInput
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageRecordUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    binWashUserId?: IntFieldUpdateOperationsInput | number
    washingMachineId?: IntFieldUpdateOperationsInput | number
    wMProgramId?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageRecordCreateManyInput = {
    id?: number
    dateTime: Date | string
    binWashUserId: number
    washingMachineId: number
    wMProgramId: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsageRecordUpdateManyMutationInput = {
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageRecordUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    binWashUserId?: IntFieldUpdateOperationsInput | number
    washingMachineId?: IntFieldUpdateOperationsInput | number
    wMProgramId?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopUpRecordCreateInput = {
    dateTime: Date | string
    user: BinWashUserCreateNestedOneWithoutTopUpRecordsInput
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TopUpRecordUncheckedCreateInput = {
    id?: number
    dateTime: Date | string
    binWashUserId: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TopUpRecordUpdateInput = {
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: BinWashUserUpdateOneRequiredWithoutTopUpRecordsNestedInput
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopUpRecordUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    binWashUserId?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopUpRecordCreateManyInput = {
    id?: number
    dateTime: Date | string
    binWashUserId: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TopUpRecordUpdateManyMutationInput = {
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopUpRecordUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    binWashUserId?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserCreateInput = {
    name: string
    imageUrl: string
    bio: string
    followingUserRelations?: FacebookUserRelationCreateNestedManyWithoutFollowingUserInput
    followedUserRelations?: FacebookUserRelationCreateNestedManyWithoutFollowedUserInput
    posts?: PostCreateNestedManyWithoutPostingUserInput
    comments?: CommentCreateNestedManyWithoutCommentingUserInput
    messengerMessagesFrom?: MessengerMessageCreateNestedManyWithoutFromUserInput
    messengerMessagesTo?: MessengerMessageCreateNestedManyWithoutToUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserUncheckedCreateInput = {
    id?: number
    name: string
    imageUrl: string
    bio: string
    followingUserRelations?: FacebookUserRelationUncheckedCreateNestedManyWithoutFollowingUserInput
    followedUserRelations?: FacebookUserRelationUncheckedCreateNestedManyWithoutFollowedUserInput
    posts?: PostUncheckedCreateNestedManyWithoutPostingUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutCommentingUserInput
    messengerMessagesFrom?: MessengerMessageUncheckedCreateNestedManyWithoutFromUserInput
    messengerMessagesTo?: MessengerMessageUncheckedCreateNestedManyWithoutToUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followingUserRelations?: FacebookUserRelationUpdateManyWithoutFollowingUserNestedInput
    followedUserRelations?: FacebookUserRelationUpdateManyWithoutFollowedUserNestedInput
    posts?: PostUpdateManyWithoutPostingUserNestedInput
    comments?: CommentUpdateManyWithoutCommentingUserNestedInput
    messengerMessagesFrom?: MessengerMessageUpdateManyWithoutFromUserNestedInput
    messengerMessagesTo?: MessengerMessageUpdateManyWithoutToUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followingUserRelations?: FacebookUserRelationUncheckedUpdateManyWithoutFollowingUserNestedInput
    followedUserRelations?: FacebookUserRelationUncheckedUpdateManyWithoutFollowedUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutPostingUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCommentingUserNestedInput
    messengerMessagesFrom?: MessengerMessageUncheckedUpdateManyWithoutFromUserNestedInput
    messengerMessagesTo?: MessengerMessageUncheckedUpdateManyWithoutToUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserCreateManyInput = {
    id?: number
    name: string
    imageUrl: string
    bio: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserRelationCreateInput = {
    followingUser: FacebookUserCreateNestedOneWithoutFollowingUserRelationsInput
    followedUser: FacebookUserCreateNestedOneWithoutFollowedUserRelationsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserRelationUncheckedCreateInput = {
    id?: number
    followingUserId: number
    followedUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserRelationUpdateInput = {
    followingUser?: FacebookUserUpdateOneRequiredWithoutFollowingUserRelationsNestedInput
    followedUser?: FacebookUserUpdateOneRequiredWithoutFollowedUserRelationsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserRelationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    followingUserId?: IntFieldUpdateOperationsInput | number
    followedUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserRelationCreateManyInput = {
    id?: number
    followingUserId: number
    followedUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserRelationUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserRelationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    followingUserId?: IntFieldUpdateOperationsInput | number
    followedUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCreateInput = {
    postText: string
    postingUser: FacebookUserCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutParentPostInput
    hashTags?: FacebookHashTagCreateNestedManyWithoutIsInPostsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostUncheckedCreateInput = {
    id?: number
    postText: string
    userId: number
    comments?: CommentUncheckedCreateNestedManyWithoutParentPostInput
    hashTags?: FacebookHashTagUncheckedCreateNestedManyWithoutIsInPostsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostUpdateInput = {
    postText?: StringFieldUpdateOperationsInput | string
    postingUser?: FacebookUserUpdateOneRequiredWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutParentPostNestedInput
    hashTags?: FacebookHashTagUpdateManyWithoutIsInPostsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    postText?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    comments?: CommentUncheckedUpdateManyWithoutParentPostNestedInput
    hashTags?: FacebookHashTagUncheckedUpdateManyWithoutIsInPostsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCreateManyInput = {
    id?: number
    postText: string
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostUpdateManyMutationInput = {
    postText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    postText?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    commentText: string
    commentingUser: FacebookUserCreateNestedOneWithoutCommentsInput
    parentPost: PostCreateNestedOneWithoutCommentsInput
    parentComment?: CommentCreateNestedOneWithoutChildCommentsInput
    childComments?: CommentCreateNestedManyWithoutParentCommentInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUncheckedCreateInput = {
    id?: number
    commentText: string
    userId: number
    postId: number
    parentCommentId?: number | null
    childComments?: CommentUncheckedCreateNestedManyWithoutParentCommentInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateInput = {
    commentText?: StringFieldUpdateOperationsInput | string
    commentingUser?: FacebookUserUpdateOneRequiredWithoutCommentsNestedInput
    parentPost?: PostUpdateOneRequiredWithoutCommentsNestedInput
    parentComment?: CommentUpdateOneWithoutChildCommentsNestedInput
    childComments?: CommentUpdateManyWithoutParentCommentNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentText?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    parentCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    childComments?: CommentUncheckedUpdateManyWithoutParentCommentNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyInput = {
    id?: number
    commentText: string
    userId: number
    postId: number
    parentCommentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    commentText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentText?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    parentCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookHashTagCreateInput = {
    hashTagText: string
    isInPosts?: PostCreateNestedManyWithoutHashTagsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookHashTagUncheckedCreateInput = {
    id?: number
    hashTagText: string
    isInPosts?: PostUncheckedCreateNestedManyWithoutHashTagsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookHashTagUpdateInput = {
    hashTagText?: StringFieldUpdateOperationsInput | string
    isInPosts?: PostUpdateManyWithoutHashTagsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookHashTagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    hashTagText?: StringFieldUpdateOperationsInput | string
    isInPosts?: PostUncheckedUpdateManyWithoutHashTagsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookHashTagCreateManyInput = {
    id?: number
    hashTagText: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookHashTagUpdateManyMutationInput = {
    hashTagText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookHashTagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    hashTagText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessengerMessageCreateInput = {
    messengerText: string
    fromUser: FacebookUserCreateNestedOneWithoutMessengerMessagesFromInput
    toUser: FacebookUserCreateNestedOneWithoutMessengerMessagesToInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessengerMessageUncheckedCreateInput = {
    id?: number
    messengerText: string
    fromUserId: number
    toUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessengerMessageUpdateInput = {
    messengerText?: StringFieldUpdateOperationsInput | string
    fromUser?: FacebookUserUpdateOneRequiredWithoutMessengerMessagesFromNestedInput
    toUser?: FacebookUserUpdateOneRequiredWithoutMessengerMessagesToNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessengerMessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    messengerText?: StringFieldUpdateOperationsInput | string
    fromUserId?: IntFieldUpdateOperationsInput | number
    toUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessengerMessageCreateManyInput = {
    id?: number
    messengerText: string
    fromUserId: number
    toUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessengerMessageUpdateManyMutationInput = {
    messengerText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessengerMessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    messengerText?: StringFieldUpdateOperationsInput | string
    fromUserId?: IntFieldUpdateOperationsInput | number
    toUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthorCreateInput = {
    name: string
    bookTitles?: BookTitleCreateNestedManyWithoutAuthorsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuthorUncheckedCreateInput = {
    id?: number
    name: string
    bookTitles?: BookTitleUncheckedCreateNestedManyWithoutAuthorsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuthorUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    bookTitles?: BookTitleUpdateManyWithoutAuthorsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    bookTitles?: BookTitleUncheckedUpdateManyWithoutAuthorsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthorCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuthorUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookTitleCreateInput = {
    title: string
    isbn: string
    authors?: AuthorCreateNestedManyWithoutBookTitlesInput
    categories?: BookCategoryCreateNestedManyWithoutBookTitlesInput
    books?: BookCreateNestedManyWithoutTitleInput
    requestRecords?: RequestRecordCreateNestedManyWithoutRequestedBookTitleInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookTitleUncheckedCreateInput = {
    id?: number
    title: string
    isbn: string
    authors?: AuthorUncheckedCreateNestedManyWithoutBookTitlesInput
    categories?: BookCategoryUncheckedCreateNestedManyWithoutBookTitlesInput
    books?: BookUncheckedCreateNestedManyWithoutTitleInput
    requestRecords?: RequestRecordUncheckedCreateNestedManyWithoutRequestedBookTitleInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookTitleUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    isbn?: StringFieldUpdateOperationsInput | string
    authors?: AuthorUpdateManyWithoutBookTitlesNestedInput
    categories?: BookCategoryUpdateManyWithoutBookTitlesNestedInput
    books?: BookUpdateManyWithoutTitleNestedInput
    requestRecords?: RequestRecordUpdateManyWithoutRequestedBookTitleNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookTitleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    isbn?: StringFieldUpdateOperationsInput | string
    authors?: AuthorUncheckedUpdateManyWithoutBookTitlesNestedInput
    categories?: BookCategoryUncheckedUpdateManyWithoutBookTitlesNestedInput
    books?: BookUncheckedUpdateManyWithoutTitleNestedInput
    requestRecords?: RequestRecordUncheckedUpdateManyWithoutRequestedBookTitleNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookTitleCreateManyInput = {
    id?: number
    title: string
    isbn: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookTitleUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    isbn?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookTitleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    isbn?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookCategoryCreateInput = {
    category: string
    bookTitles?: BookTitleCreateNestedManyWithoutCategoriesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookCategoryUncheckedCreateInput = {
    id?: number
    category: string
    bookTitles?: BookTitleUncheckedCreateNestedManyWithoutCategoriesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookCategoryUpdateInput = {
    category?: StringFieldUpdateOperationsInput | string
    bookTitles?: BookTitleUpdateManyWithoutCategoriesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    bookTitles?: BookTitleUncheckedUpdateManyWithoutCategoriesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookCategoryCreateManyInput = {
    id?: number
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookCategoryUpdateManyMutationInput = {
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookCreateInput = {
    title: BookTitleCreateNestedOneWithoutBooksInput
    belongsToLibrary: LibraryCreateNestedOneWithoutBooksInput
    isAvailable: boolean
    borrowingRecords?: BorrowingRecordCreateNestedManyWithoutBorrowedBookInput
    requestRecords?: RequestRecordCreateNestedManyWithoutAcquiredBookInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookUncheckedCreateInput = {
    id?: number
    bookTitleId: number
    libraryId: number
    isAvailable: boolean
    borrowingRecords?: BorrowingRecordUncheckedCreateNestedManyWithoutBorrowedBookInput
    requestRecords?: RequestRecordUncheckedCreateNestedManyWithoutAcquiredBookInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookUpdateInput = {
    title?: BookTitleUpdateOneRequiredWithoutBooksNestedInput
    belongsToLibrary?: LibraryUpdateOneRequiredWithoutBooksNestedInput
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    borrowingRecords?: BorrowingRecordUpdateManyWithoutBorrowedBookNestedInput
    requestRecords?: RequestRecordUpdateManyWithoutAcquiredBookNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookTitleId?: IntFieldUpdateOperationsInput | number
    libraryId?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    borrowingRecords?: BorrowingRecordUncheckedUpdateManyWithoutBorrowedBookNestedInput
    requestRecords?: RequestRecordUncheckedUpdateManyWithoutAcquiredBookNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookCreateManyInput = {
    id?: number
    bookTitleId: number
    libraryId: number
    isAvailable: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookUpdateManyMutationInput = {
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookTitleId?: IntFieldUpdateOperationsInput | number
    libraryId?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryCreateInput = {
    name: string
    location: string
    belongsToUniversity: UniversityCreateNestedOneWithoutLibrariesInput
    books?: BookCreateNestedManyWithoutBelongsToLibraryInput
    requestingRecords?: RequestRecordCreateNestedManyWithoutRequestingLibraryInput
    requestedRecords?: RequestRecordCreateNestedManyWithoutRequestedLibraryInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryUncheckedCreateInput = {
    id?: number
    name: string
    location: string
    universityId: number
    books?: BookUncheckedCreateNestedManyWithoutBelongsToLibraryInput
    requestingRecords?: RequestRecordUncheckedCreateNestedManyWithoutRequestingLibraryInput
    requestedRecords?: RequestRecordUncheckedCreateNestedManyWithoutRequestedLibraryInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    belongsToUniversity?: UniversityUpdateOneRequiredWithoutLibrariesNestedInput
    books?: BookUpdateManyWithoutBelongsToLibraryNestedInput
    requestingRecords?: RequestRecordUpdateManyWithoutRequestingLibraryNestedInput
    requestedRecords?: RequestRecordUpdateManyWithoutRequestedLibraryNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    universityId?: IntFieldUpdateOperationsInput | number
    books?: BookUncheckedUpdateManyWithoutBelongsToLibraryNestedInput
    requestingRecords?: RequestRecordUncheckedUpdateManyWithoutRequestingLibraryNestedInput
    requestedRecords?: RequestRecordUncheckedUpdateManyWithoutRequestedLibraryNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryCreateManyInput = {
    id?: number
    name: string
    location: string
    universityId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    universityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UniversityCreateInput = {
    name: string
    location: string
    libraries?: LibraryCreateNestedManyWithoutBelongsToUniversityInput
    students?: StudentCreateNestedManyWithoutBelongsToUniversityInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UniversityUncheckedCreateInput = {
    id?: number
    name: string
    location: string
    libraries?: LibraryUncheckedCreateNestedManyWithoutBelongsToUniversityInput
    students?: StudentUncheckedCreateNestedManyWithoutBelongsToUniversityInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UniversityUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    libraries?: LibraryUpdateManyWithoutBelongsToUniversityNestedInput
    students?: StudentUpdateManyWithoutBelongsToUniversityNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UniversityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    libraries?: LibraryUncheckedUpdateManyWithoutBelongsToUniversityNestedInput
    students?: StudentUncheckedUpdateManyWithoutBelongsToUniversityNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UniversityCreateManyInput = {
    id?: number
    name: string
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UniversityUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UniversityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCreateInput = {
    Name: string
    belongsToUniversity: UniversityCreateNestedOneWithoutStudentsInput
    borrowingRecords?: BorrowingRecordCreateNestedManyWithoutBorrowingStudentInput
    requestRecords?: RequestRecordCreateNestedManyWithoutRequestingStudentInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentUncheckedCreateInput = {
    id?: number
    Name: string
    universityId: number
    borrowingRecords?: BorrowingRecordUncheckedCreateNestedManyWithoutBorrowingStudentInput
    requestRecords?: RequestRecordUncheckedCreateNestedManyWithoutRequestingStudentInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    belongsToUniversity?: UniversityUpdateOneRequiredWithoutStudentsNestedInput
    borrowingRecords?: BorrowingRecordUpdateManyWithoutBorrowingStudentNestedInput
    requestRecords?: RequestRecordUpdateManyWithoutRequestingStudentNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    universityId?: IntFieldUpdateOperationsInput | number
    borrowingRecords?: BorrowingRecordUncheckedUpdateManyWithoutBorrowingStudentNestedInput
    requestRecords?: RequestRecordUncheckedUpdateManyWithoutRequestingStudentNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCreateManyInput = {
    id?: number
    Name: string
    universityId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    universityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BorrowingRecordCreateInput = {
    borrowingStudent: StudentCreateNestedOneWithoutBorrowingRecordsInput
    borrowedBook: BookCreateNestedOneWithoutBorrowingRecordsInput
    startDate: Date | string
    endDate?: Date | string | null
    actualEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BorrowingRecordUncheckedCreateInput = {
    id?: number
    studentId: number
    bookId: number
    startDate: Date | string
    endDate?: Date | string | null
    actualEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BorrowingRecordUpdateInput = {
    borrowingStudent?: StudentUpdateOneRequiredWithoutBorrowingRecordsNestedInput
    borrowedBook?: BookUpdateOneRequiredWithoutBorrowingRecordsNestedInput
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BorrowingRecordUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BorrowingRecordCreateManyInput = {
    id?: number
    studentId: number
    bookId: number
    startDate: Date | string
    endDate?: Date | string | null
    actualEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BorrowingRecordUpdateManyMutationInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BorrowingRecordUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestRecordCreateInput = {
    requestingStudent: StudentCreateNestedOneWithoutRequestRecordsInput
    requestedBookTitle: BookTitleCreateNestedOneWithoutRequestRecordsInput
    requestingLibrary: LibraryCreateNestedOneWithoutRequestingRecordsInput
    requestedLibrary: LibraryCreateNestedOneWithoutRequestedRecordsInput
    requestDate: Date | string
    acquiredDate?: Date | string | null
    returnDate?: Date | string | null
    acquiredBook?: BookCreateNestedOneWithoutRequestRecordsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestRecordUncheckedCreateInput = {
    id?: number
    studentId: number
    bookTitleId: number
    requestingLibraryId: number
    requestedLibraryId: number
    requestDate: Date | string
    acquiredDate?: Date | string | null
    returnDate?: Date | string | null
    bookId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestRecordUpdateInput = {
    requestingStudent?: StudentUpdateOneRequiredWithoutRequestRecordsNestedInput
    requestedBookTitle?: BookTitleUpdateOneRequiredWithoutRequestRecordsNestedInput
    requestingLibrary?: LibraryUpdateOneRequiredWithoutRequestingRecordsNestedInput
    requestedLibrary?: LibraryUpdateOneRequiredWithoutRequestedRecordsNestedInput
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acquiredBook?: BookUpdateOneWithoutRequestRecordsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestRecordUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    bookTitleId?: IntFieldUpdateOperationsInput | number
    requestingLibraryId?: IntFieldUpdateOperationsInput | number
    requestedLibraryId?: IntFieldUpdateOperationsInput | number
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestRecordCreateManyInput = {
    id?: number
    studentId: number
    bookTitleId: number
    requestingLibraryId: number
    requestedLibraryId: number
    requestDate: Date | string
    acquiredDate?: Date | string | null
    returnDate?: Date | string | null
    bookId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestRecordUpdateManyMutationInput = {
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestRecordUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    bookTitleId?: IntFieldUpdateOperationsInput | number
    requestingLibraryId?: IntFieldUpdateOperationsInput | number
    requestedLibraryId?: IntFieldUpdateOperationsInput | number
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TodoListCreateInput = {
    task: string
    status?: string
    bgColor?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TodoListUncheckedCreateInput = {
    id?: number
    task: string
    status?: string
    bgColor?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TodoListUpdateInput = {
    task?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    bgColor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TodoListUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    task?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    bgColor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TodoListCreateManyInput = {
    id?: number
    task: string
    status?: string
    bgColor?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TodoListUpdateManyMutationInput = {
    task?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    bgColor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TodoListUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    task?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    bgColor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    name: string
    imageUrl: string
    bio: string
    followingUserRelations?: UserRelationCreateNestedManyWithoutFollowingUserInput
    followedUserRelations?: UserRelationCreateNestedManyWithoutFollowedUserInput
    tweets?: TweetCreateNestedManyWithoutTweetingUserInput
    directMessagesFrom?: DirectMessageCreateNestedManyWithoutFromUserInput
    directMessagesTo?: DirectMessageCreateNestedManyWithoutToUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateInput = {
    id?: number
    name: string
    imageUrl: string
    bio: string
    followingUserRelations?: UserRelationUncheckedCreateNestedManyWithoutFollowingUserInput
    followedUserRelations?: UserRelationUncheckedCreateNestedManyWithoutFollowedUserInput
    tweets?: TweetUncheckedCreateNestedManyWithoutTweetingUserInput
    directMessagesFrom?: DirectMessageUncheckedCreateNestedManyWithoutFromUserInput
    directMessagesTo?: DirectMessageUncheckedCreateNestedManyWithoutToUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followingUserRelations?: UserRelationUpdateManyWithoutFollowingUserNestedInput
    followedUserRelations?: UserRelationUpdateManyWithoutFollowedUserNestedInput
    tweets?: TweetUpdateManyWithoutTweetingUserNestedInput
    directMessagesFrom?: DirectMessageUpdateManyWithoutFromUserNestedInput
    directMessagesTo?: DirectMessageUpdateManyWithoutToUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followingUserRelations?: UserRelationUncheckedUpdateManyWithoutFollowingUserNestedInput
    followedUserRelations?: UserRelationUncheckedUpdateManyWithoutFollowedUserNestedInput
    tweets?: TweetUncheckedUpdateManyWithoutTweetingUserNestedInput
    directMessagesFrom?: DirectMessageUncheckedUpdateManyWithoutFromUserNestedInput
    directMessagesTo?: DirectMessageUncheckedUpdateManyWithoutToUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyInput = {
    id?: number
    name: string
    imageUrl: string
    bio: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRelationCreateInput = {
    followingUser: UserCreateNestedOneWithoutFollowingUserRelationsInput
    followedUser: UserCreateNestedOneWithoutFollowedUserRelationsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserRelationUncheckedCreateInput = {
    id?: number
    followingUserId: number
    followedUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserRelationUpdateInput = {
    followingUser?: UserUpdateOneRequiredWithoutFollowingUserRelationsNestedInput
    followedUser?: UserUpdateOneRequiredWithoutFollowedUserRelationsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRelationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    followingUserId?: IntFieldUpdateOperationsInput | number
    followedUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRelationCreateManyInput = {
    id?: number
    followingUserId: number
    followedUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserRelationUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRelationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    followingUserId?: IntFieldUpdateOperationsInput | number
    followedUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TweetCreateInput = {
    tweetText: string
    tweetingUser: UserCreateNestedOneWithoutTweetsInput
    parentTweet?: TweetCreateNestedOneWithoutChildTweetsInput
    childTweets?: TweetCreateNestedManyWithoutParentTweetInput
    hashTags?: HashTagCreateNestedManyWithoutIsInTweetsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TweetUncheckedCreateInput = {
    id?: number
    tweetText: string
    parentTweetId?: number | null
    childTweets?: TweetUncheckedCreateNestedManyWithoutParentTweetInput
    userId: number
    hashTags?: HashTagUncheckedCreateNestedManyWithoutIsInTweetsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TweetUpdateInput = {
    tweetText?: StringFieldUpdateOperationsInput | string
    tweetingUser?: UserUpdateOneRequiredWithoutTweetsNestedInput
    parentTweet?: TweetUpdateOneWithoutChildTweetsNestedInput
    childTweets?: TweetUpdateManyWithoutParentTweetNestedInput
    hashTags?: HashTagUpdateManyWithoutIsInTweetsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TweetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tweetText?: StringFieldUpdateOperationsInput | string
    parentTweetId?: NullableIntFieldUpdateOperationsInput | number | null
    childTweets?: TweetUncheckedUpdateManyWithoutParentTweetNestedInput
    userId?: IntFieldUpdateOperationsInput | number
    hashTags?: HashTagUncheckedUpdateManyWithoutIsInTweetsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TweetCreateManyInput = {
    id?: number
    tweetText: string
    parentTweetId?: number | null
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TweetUpdateManyMutationInput = {
    tweetText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TweetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tweetText?: StringFieldUpdateOperationsInput | string
    parentTweetId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HashTagCreateInput = {
    hashTagText: string
    isInTweets?: TweetCreateNestedManyWithoutHashTagsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HashTagUncheckedCreateInput = {
    id?: number
    hashTagText: string
    isInTweets?: TweetUncheckedCreateNestedManyWithoutHashTagsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HashTagUpdateInput = {
    hashTagText?: StringFieldUpdateOperationsInput | string
    isInTweets?: TweetUpdateManyWithoutHashTagsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HashTagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    hashTagText?: StringFieldUpdateOperationsInput | string
    isInTweets?: TweetUncheckedUpdateManyWithoutHashTagsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HashTagCreateManyInput = {
    id?: number
    hashTagText: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HashTagUpdateManyMutationInput = {
    hashTagText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HashTagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    hashTagText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageCreateInput = {
    dmText: string
    fromUser: UserCreateNestedOneWithoutDirectMessagesFromInput
    toUser: UserCreateNestedOneWithoutDirectMessagesToInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DirectMessageUncheckedCreateInput = {
    id?: number
    dmText: string
    fromUserId: number
    toUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DirectMessageUpdateInput = {
    dmText?: StringFieldUpdateOperationsInput | string
    fromUser?: UserUpdateOneRequiredWithoutDirectMessagesFromNestedInput
    toUser?: UserUpdateOneRequiredWithoutDirectMessagesToNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dmText?: StringFieldUpdateOperationsInput | string
    fromUserId?: IntFieldUpdateOperationsInput | number
    toUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageCreateManyInput = {
    id?: number
    dmText: string
    fromUserId: number
    toUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DirectMessageUpdateManyMutationInput = {
    dmText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dmText?: StringFieldUpdateOperationsInput | string
    fromUserId?: IntFieldUpdateOperationsInput | number
    toUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YouTubeUserCreateInput = {
    name: string
    profileImageUrl?: string | null
    bio?: string | null
    adminOfChannels?: ChannelCreateNestedManyWithoutAdminUsersInput
    usersToChannelswithRoles?: UserToChannelwithRoleCreateNestedManyWithoutUserInput
    subscribingToChannels?: ChannelCreateNestedManyWithoutSubscribedUsersInput
    reactedVideos?: VideoCreateNestedManyWithoutReactedByYouTubeUsersInput
    usersToVideosWithReactions?: UserToVideoWithReactionCreateNestedManyWithoutUserInput
    videoComments?: VideoCommentCreateNestedManyWithoutCommentingUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YouTubeUserUncheckedCreateInput = {
    id?: number
    name: string
    profileImageUrl?: string | null
    bio?: string | null
    adminOfChannels?: ChannelUncheckedCreateNestedManyWithoutAdminUsersInput
    usersToChannelswithRoles?: UserToChannelwithRoleUncheckedCreateNestedManyWithoutUserInput
    subscribingToChannels?: ChannelUncheckedCreateNestedManyWithoutSubscribedUsersInput
    reactedVideos?: VideoUncheckedCreateNestedManyWithoutReactedByYouTubeUsersInput
    usersToVideosWithReactions?: UserToVideoWithReactionUncheckedCreateNestedManyWithoutUserInput
    videoComments?: VideoCommentUncheckedCreateNestedManyWithoutCommentingUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YouTubeUserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    adminOfChannels?: ChannelUpdateManyWithoutAdminUsersNestedInput
    usersToChannelswithRoles?: UserToChannelwithRoleUpdateManyWithoutUserNestedInput
    subscribingToChannels?: ChannelUpdateManyWithoutSubscribedUsersNestedInput
    reactedVideos?: VideoUpdateManyWithoutReactedByYouTubeUsersNestedInput
    usersToVideosWithReactions?: UserToVideoWithReactionUpdateManyWithoutUserNestedInput
    videoComments?: VideoCommentUpdateManyWithoutCommentingUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YouTubeUserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    adminOfChannels?: ChannelUncheckedUpdateManyWithoutAdminUsersNestedInput
    usersToChannelswithRoles?: UserToChannelwithRoleUncheckedUpdateManyWithoutUserNestedInput
    subscribingToChannels?: ChannelUncheckedUpdateManyWithoutSubscribedUsersNestedInput
    reactedVideos?: VideoUncheckedUpdateManyWithoutReactedByYouTubeUsersNestedInput
    usersToVideosWithReactions?: UserToVideoWithReactionUncheckedUpdateManyWithoutUserNestedInput
    videoComments?: VideoCommentUncheckedUpdateManyWithoutCommentingUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YouTubeUserCreateManyInput = {
    id?: number
    name: string
    profileImageUrl?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YouTubeUserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YouTubeUserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelCreateInput = {
    name: string
    profileImageUrl?: string | null
    description?: string | null
    adminUsers?: YouTubeUserCreateNestedManyWithoutAdminOfChannelsInput
    subscribedUsers?: YouTubeUserCreateNestedManyWithoutSubscribingToChannelsInput
    usersToChannelswithRoles?: UserToChannelwithRoleCreateNestedManyWithoutChannelInput
    owningVideos?: VideoCreateNestedManyWithoutBelongsToChannelInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChannelUncheckedCreateInput = {
    id?: number
    name: string
    profileImageUrl?: string | null
    description?: string | null
    adminUsers?: YouTubeUserUncheckedCreateNestedManyWithoutAdminOfChannelsInput
    subscribedUsers?: YouTubeUserUncheckedCreateNestedManyWithoutSubscribingToChannelsInput
    usersToChannelswithRoles?: UserToChannelwithRoleUncheckedCreateNestedManyWithoutChannelInput
    owningVideos?: VideoUncheckedCreateNestedManyWithoutBelongsToChannelInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChannelUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adminUsers?: YouTubeUserUpdateManyWithoutAdminOfChannelsNestedInput
    subscribedUsers?: YouTubeUserUpdateManyWithoutSubscribingToChannelsNestedInput
    usersToChannelswithRoles?: UserToChannelwithRoleUpdateManyWithoutChannelNestedInput
    owningVideos?: VideoUpdateManyWithoutBelongsToChannelNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adminUsers?: YouTubeUserUncheckedUpdateManyWithoutAdminOfChannelsNestedInput
    subscribedUsers?: YouTubeUserUncheckedUpdateManyWithoutSubscribingToChannelsNestedInput
    usersToChannelswithRoles?: UserToChannelwithRoleUncheckedUpdateManyWithoutChannelNestedInput
    owningVideos?: VideoUncheckedUpdateManyWithoutBelongsToChannelNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelCreateManyInput = {
    id?: number
    name: string
    profileImageUrl?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChannelUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToChannelwithRoleCreateInput = {
    user: YouTubeUserCreateNestedOneWithoutUsersToChannelswithRolesInput
    channel: ChannelCreateNestedOneWithoutUsersToChannelswithRolesInput
    role: RoleEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToChannelwithRoleUncheckedCreateInput = {
    id?: number
    youTubeUserId: number
    channelId: number
    role: RoleEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToChannelwithRoleUpdateInput = {
    user?: YouTubeUserUpdateOneRequiredWithoutUsersToChannelswithRolesNestedInput
    channel?: ChannelUpdateOneRequiredWithoutUsersToChannelswithRolesNestedInput
    role?: EnumRoleEnumFieldUpdateOperationsInput | RoleEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToChannelwithRoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    youTubeUserId?: IntFieldUpdateOperationsInput | number
    channelId?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleEnumFieldUpdateOperationsInput | RoleEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToChannelwithRoleCreateManyInput = {
    id?: number
    youTubeUserId: number
    channelId: number
    role: RoleEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToChannelwithRoleUpdateManyMutationInput = {
    role?: EnumRoleEnumFieldUpdateOperationsInput | RoleEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToChannelwithRoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    youTubeUserId?: IntFieldUpdateOperationsInput | number
    channelId?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleEnumFieldUpdateOperationsInput | RoleEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCreateInput = {
    title: string
    videoUrl: string
    thumbnailImageUrl?: string | null
    description?: string | null
    belongsToChannel: ChannelCreateNestedOneWithoutOwningVideosInput
    reactedByYouTubeUsers?: YouTubeUserCreateNestedManyWithoutReactedVideosInput
    usersToVideosWithReactions?: UserToVideoWithReactionCreateNestedManyWithoutVideoInput
    videoComments?: VideoCommentCreateNestedManyWithoutParentVideoInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoUncheckedCreateInput = {
    id?: number
    title: string
    videoUrl: string
    thumbnailImageUrl?: string | null
    description?: string | null
    channelId: number
    reactedByYouTubeUsers?: YouTubeUserUncheckedCreateNestedManyWithoutReactedVideosInput
    usersToVideosWithReactions?: UserToVideoWithReactionUncheckedCreateNestedManyWithoutVideoInput
    videoComments?: VideoCommentUncheckedCreateNestedManyWithoutParentVideoInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    belongsToChannel?: ChannelUpdateOneRequiredWithoutOwningVideosNestedInput
    reactedByYouTubeUsers?: YouTubeUserUpdateManyWithoutReactedVideosNestedInput
    usersToVideosWithReactions?: UserToVideoWithReactionUpdateManyWithoutVideoNestedInput
    videoComments?: VideoCommentUpdateManyWithoutParentVideoNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: IntFieldUpdateOperationsInput | number
    reactedByYouTubeUsers?: YouTubeUserUncheckedUpdateManyWithoutReactedVideosNestedInput
    usersToVideosWithReactions?: UserToVideoWithReactionUncheckedUpdateManyWithoutVideoNestedInput
    videoComments?: VideoCommentUncheckedUpdateManyWithoutParentVideoNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCreateManyInput = {
    id?: number
    title: string
    videoUrl: string
    thumbnailImageUrl?: string | null
    description?: string | null
    channelId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToVideoWithReactionCreateInput = {
    user: YouTubeUserCreateNestedOneWithoutUsersToVideosWithReactionsInput
    video: VideoCreateNestedOneWithoutUsersToVideosWithReactionsInput
    reaction: ReactionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToVideoWithReactionUncheckedCreateInput = {
    id?: number
    youTubeUserId: number
    videoId: number
    reaction: ReactionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToVideoWithReactionUpdateInput = {
    user?: YouTubeUserUpdateOneRequiredWithoutUsersToVideosWithReactionsNestedInput
    video?: VideoUpdateOneRequiredWithoutUsersToVideosWithReactionsNestedInput
    reaction?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToVideoWithReactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    youTubeUserId?: IntFieldUpdateOperationsInput | number
    videoId?: IntFieldUpdateOperationsInput | number
    reaction?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToVideoWithReactionCreateManyInput = {
    id?: number
    youTubeUserId: number
    videoId: number
    reaction: ReactionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToVideoWithReactionUpdateManyMutationInput = {
    reaction?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToVideoWithReactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    youTubeUserId?: IntFieldUpdateOperationsInput | number
    videoId?: IntFieldUpdateOperationsInput | number
    reaction?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCommentCreateInput = {
    commentText: string
    commentingUser: YouTubeUserCreateNestedOneWithoutVideoCommentsInput
    parentVideo: VideoCreateNestedOneWithoutVideoCommentsInput
    parentVideoComment?: VideoCommentCreateNestedOneWithoutChildVideoCommentsInput
    childVideoComments?: VideoCommentCreateNestedManyWithoutParentVideoCommentInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCommentUncheckedCreateInput = {
    id?: number
    commentText: string
    youTubeUserId: number
    videoId: number
    parentVideoCommentId?: number | null
    childVideoComments?: VideoCommentUncheckedCreateNestedManyWithoutParentVideoCommentInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCommentUpdateInput = {
    commentText?: StringFieldUpdateOperationsInput | string
    commentingUser?: YouTubeUserUpdateOneRequiredWithoutVideoCommentsNestedInput
    parentVideo?: VideoUpdateOneRequiredWithoutVideoCommentsNestedInput
    parentVideoComment?: VideoCommentUpdateOneWithoutChildVideoCommentsNestedInput
    childVideoComments?: VideoCommentUpdateManyWithoutParentVideoCommentNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentText?: StringFieldUpdateOperationsInput | string
    youTubeUserId?: IntFieldUpdateOperationsInput | number
    videoId?: IntFieldUpdateOperationsInput | number
    parentVideoCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    childVideoComments?: VideoCommentUncheckedUpdateManyWithoutParentVideoCommentNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCommentCreateManyInput = {
    id?: number
    commentText: string
    youTubeUserId: number
    videoId: number
    parentVideoCommentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCommentUpdateManyMutationInput = {
    commentText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentText?: StringFieldUpdateOperationsInput | string
    youTubeUserId?: IntFieldUpdateOperationsInput | number
    videoId?: IntFieldUpdateOperationsInput | number
    parentVideoCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type MenuListRelationFilter = {
    every?: MenuWhereInput
    some?: MenuWhereInput
    none?: MenuWhereInput
  }

  export type MenuOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type CategoryRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MenuCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    price?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    categoryId?: SortOrder
  }

  export type MenuMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    price?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    price?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    categoryId?: SortOrder
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    tableId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    tableId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    tableId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
  }

  export type MenuRelationFilter = {
    is?: MenuWhereInput
    isNot?: MenuWhereInput
  }

  export type OrderRelationFilter = {
    is?: OrderWhereInput | null
    isNot?: OrderWhereInput | null
  }

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderItemAvgOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
  }

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderItemSumOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
  }

  export type QuizListRelationFilter = {
    every?: QuizWhereInput
    some?: QuizWhereInput
    none?: QuizWhereInput
  }

  export type QuizOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type QuizCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizCategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type QuizRelationFilter = {
    is?: QuizWhereInput | null
    isNot?: QuizWhereInput | null
  }

  export type RoundListRelationFilter = {
    every?: RoundWhereInput
    some?: RoundWhereInput
    none?: RoundWhereInput
  }

  export type RoundOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChoiceCountOrderByAggregateInput = {
    id?: SortOrder
    answerText?: SortOrder
    quizId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChoiceAvgOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
  }

  export type ChoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    answerText?: SortOrder
    quizId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChoiceMinOrderByAggregateInput = {
    id?: SortOrder
    answerText?: SortOrder
    quizId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChoiceSumOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
  }

  export type QuizCategoryRelationFilter = {
    is?: QuizCategoryWhereInput
    isNot?: QuizCategoryWhereInput
  }

  export type ChoiceListRelationFilter = {
    every?: ChoiceWhereInput
    some?: ChoiceWhereInput
    none?: ChoiceWhereInput
  }

  export type ChoiceRelationFilter = {
    is?: ChoiceWhereInput
    isNot?: ChoiceWhereInput
  }

  export type ChoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizCountOrderByAggregateInput = {
    id?: SortOrder
    questionText?: SortOrder
    quizCategoryId?: SortOrder
    correctChoiceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizAvgOrderByAggregateInput = {
    id?: SortOrder
    quizCategoryId?: SortOrder
    correctChoiceId?: SortOrder
  }

  export type QuizMaxOrderByAggregateInput = {
    id?: SortOrder
    questionText?: SortOrder
    quizCategoryId?: SortOrder
    correctChoiceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizMinOrderByAggregateInput = {
    id?: SortOrder
    questionText?: SortOrder
    quizCategoryId?: SortOrder
    correctChoiceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizSumOrderByAggregateInput = {
    id?: SortOrder
    quizCategoryId?: SortOrder
    correctChoiceId?: SortOrder
  }

  export type RoundCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoundAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoundMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoundMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoundSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BranchListRelationFilter = {
    every?: BranchWhereInput
    some?: BranchWhereInput
    none?: BranchWhereInput
  }

  export type WMMaintenanceRecordListRelationFilter = {
    every?: WMMaintenanceRecordWhereInput
    some?: WMMaintenanceRecordWhereInput
    none?: WMMaintenanceRecordWhereInput
  }

  export type UsageRecordListRelationFilter = {
    every?: UsageRecordWhereInput
    some?: UsageRecordWhereInput
    none?: UsageRecordWhereInput
  }

  export type TopUpRecordListRelationFilter = {
    every?: TopUpRecordWhereInput
    some?: TopUpRecordWhereInput
    none?: TopUpRecordWhereInput
  }

  export type BranchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WMMaintenanceRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsageRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TopUpRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BinWashUserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BinWashUserAvgOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
  }

  export type BinWashUserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BinWashUserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BinWashUserSumOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
  }

  export type BinWashUserRelationFilter = {
    is?: BinWashUserWhereInput
    isNot?: BinWashUserWhereInput
  }

  export type WashingMachineListRelationFilter = {
    every?: WashingMachineWhereInput
    some?: WashingMachineWhereInput
    none?: WashingMachineWhereInput
  }

  export type WashingMachineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BranchCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    telephoneNo?: SortOrder
    area?: SortOrder
    binWashUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BranchAvgOrderByAggregateInput = {
    id?: SortOrder
    area?: SortOrder
    binWashUserId?: SortOrder
  }

  export type BranchMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    telephoneNo?: SortOrder
    area?: SortOrder
    binWashUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BranchMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    telephoneNo?: SortOrder
    area?: SortOrder
    binWashUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BranchSumOrderByAggregateInput = {
    id?: SortOrder
    area?: SortOrder
    binWashUserId?: SortOrder
  }

  export type EnumWMTypeEnumFilter = {
    equals?: WMTypeEnum
    in?: Enumerable<WMTypeEnum>
    notIn?: Enumerable<WMTypeEnum>
    not?: NestedEnumWMTypeEnumFilter | WMTypeEnum
  }

  export type BranchRelationFilter = {
    is?: BranchWhereInput
    isNot?: BranchWhereInput
  }

  export type WMProgramListRelationFilter = {
    every?: WMProgramWhereInput
    some?: WMProgramWhereInput
    none?: WMProgramWhereInput
  }

  export type WMProgramOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WashingMachineCountOrderByAggregateInput = {
    id?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    type?: SortOrder
    capacity?: SortOrder
    manufacturedYear?: SortOrder
    warrantyEndDate?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WashingMachineAvgOrderByAggregateInput = {
    id?: SortOrder
    capacity?: SortOrder
    branchId?: SortOrder
  }

  export type WashingMachineMaxOrderByAggregateInput = {
    id?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    type?: SortOrder
    capacity?: SortOrder
    manufacturedYear?: SortOrder
    warrantyEndDate?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WashingMachineMinOrderByAggregateInput = {
    id?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    type?: SortOrder
    capacity?: SortOrder
    manufacturedYear?: SortOrder
    warrantyEndDate?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WashingMachineSumOrderByAggregateInput = {
    id?: SortOrder
    capacity?: SortOrder
    branchId?: SortOrder
  }

  export type EnumWMTypeEnumWithAggregatesFilter = {
    equals?: WMTypeEnum
    in?: Enumerable<WMTypeEnum>
    notIn?: Enumerable<WMTypeEnum>
    not?: NestedEnumWMTypeEnumWithAggregatesFilter | WMTypeEnum
    _count?: NestedIntFilter
    _min?: NestedEnumWMTypeEnumFilter
    _max?: NestedEnumWMTypeEnumFilter
  }

  export type WMProgramCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    maxCapacity?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WMProgramAvgOrderByAggregateInput = {
    id?: SortOrder
    maxCapacity?: SortOrder
    duration?: SortOrder
    price?: SortOrder
  }

  export type WMProgramMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    maxCapacity?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WMProgramMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    maxCapacity?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WMProgramSumOrderByAggregateInput = {
    id?: SortOrder
    maxCapacity?: SortOrder
    duration?: SortOrder
    price?: SortOrder
  }

  export type WashingMachineRelationFilter = {
    is?: WashingMachineWhereInput
    isNot?: WashingMachineWhereInput
  }

  export type WMMaintenanceRecordCountOrderByAggregateInput = {
    id?: SortOrder
    washingMachineId?: SortOrder
    maintenanceDateTime?: SortOrder
    level?: SortOrder
    details?: SortOrder
    binWashUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WMMaintenanceRecordAvgOrderByAggregateInput = {
    id?: SortOrder
    washingMachineId?: SortOrder
    level?: SortOrder
    binWashUserId?: SortOrder
  }

  export type WMMaintenanceRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    washingMachineId?: SortOrder
    maintenanceDateTime?: SortOrder
    level?: SortOrder
    details?: SortOrder
    binWashUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WMMaintenanceRecordMinOrderByAggregateInput = {
    id?: SortOrder
    washingMachineId?: SortOrder
    maintenanceDateTime?: SortOrder
    level?: SortOrder
    details?: SortOrder
    binWashUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WMMaintenanceRecordSumOrderByAggregateInput = {
    id?: SortOrder
    washingMachineId?: SortOrder
    level?: SortOrder
    binWashUserId?: SortOrder
  }

  export type WMProgramRelationFilter = {
    is?: WMProgramWhereInput
    isNot?: WMProgramWhereInput
  }

  export type UsageRecordCountOrderByAggregateInput = {
    id?: SortOrder
    dateTime?: SortOrder
    binWashUserId?: SortOrder
    washingMachineId?: SortOrder
    wMProgramId?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsageRecordAvgOrderByAggregateInput = {
    id?: SortOrder
    binWashUserId?: SortOrder
    washingMachineId?: SortOrder
    wMProgramId?: SortOrder
    price?: SortOrder
  }

  export type UsageRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    dateTime?: SortOrder
    binWashUserId?: SortOrder
    washingMachineId?: SortOrder
    wMProgramId?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsageRecordMinOrderByAggregateInput = {
    id?: SortOrder
    dateTime?: SortOrder
    binWashUserId?: SortOrder
    washingMachineId?: SortOrder
    wMProgramId?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsageRecordSumOrderByAggregateInput = {
    id?: SortOrder
    binWashUserId?: SortOrder
    washingMachineId?: SortOrder
    wMProgramId?: SortOrder
    price?: SortOrder
  }

  export type TopUpRecordCountOrderByAggregateInput = {
    id?: SortOrder
    dateTime?: SortOrder
    binWashUserId?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TopUpRecordAvgOrderByAggregateInput = {
    id?: SortOrder
    binWashUserId?: SortOrder
    price?: SortOrder
  }

  export type TopUpRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    dateTime?: SortOrder
    binWashUserId?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TopUpRecordMinOrderByAggregateInput = {
    id?: SortOrder
    dateTime?: SortOrder
    binWashUserId?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TopUpRecordSumOrderByAggregateInput = {
    id?: SortOrder
    binWashUserId?: SortOrder
    price?: SortOrder
  }

  export type FacebookUserRelationListRelationFilter = {
    every?: FacebookUserRelationWhereInput
    some?: FacebookUserRelationWhereInput
    none?: FacebookUserRelationWhereInput
  }

  export type PostListRelationFilter = {
    every?: PostWhereInput
    some?: PostWhereInput
    none?: PostWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type MessengerMessageListRelationFilter = {
    every?: MessengerMessageWhereInput
    some?: MessengerMessageWhereInput
    none?: MessengerMessageWhereInput
  }

  export type FacebookUserRelationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessengerMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FacebookUserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookUserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FacebookUserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookUserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookUserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FacebookUserRelationFilter = {
    is?: FacebookUserWhereInput
    isNot?: FacebookUserWhereInput
  }

  export type FacebookUserRelationCountOrderByAggregateInput = {
    id?: SortOrder
    followingUserId?: SortOrder
    followedUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookUserRelationAvgOrderByAggregateInput = {
    id?: SortOrder
    followingUserId?: SortOrder
    followedUserId?: SortOrder
  }

  export type FacebookUserRelationMaxOrderByAggregateInput = {
    id?: SortOrder
    followingUserId?: SortOrder
    followedUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookUserRelationMinOrderByAggregateInput = {
    id?: SortOrder
    followingUserId?: SortOrder
    followedUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookUserRelationSumOrderByAggregateInput = {
    id?: SortOrder
    followingUserId?: SortOrder
    followedUserId?: SortOrder
  }

  export type FacebookHashTagListRelationFilter = {
    every?: FacebookHashTagWhereInput
    some?: FacebookHashTagWhereInput
    none?: FacebookHashTagWhereInput
  }

  export type FacebookHashTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostCountOrderByAggregateInput = {
    id?: SortOrder
    postText?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    id?: SortOrder
    postText?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    id?: SortOrder
    postText?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type PostRelationFilter = {
    is?: PostWhereInput
    isNot?: PostWhereInput
  }

  export type CommentRelationFilter = {
    is?: CommentWhereInput | null
    isNot?: CommentWhereInput | null
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    commentText?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    parentCommentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    parentCommentId?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    commentText?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    parentCommentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    commentText?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    parentCommentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    parentCommentId?: SortOrder
  }

  export type FacebookHashTagCountOrderByAggregateInput = {
    id?: SortOrder
    hashTagText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookHashTagAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FacebookHashTagMaxOrderByAggregateInput = {
    id?: SortOrder
    hashTagText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookHashTagMinOrderByAggregateInput = {
    id?: SortOrder
    hashTagText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookHashTagSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MessengerMessageCountOrderByAggregateInput = {
    id?: SortOrder
    messengerText?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessengerMessageAvgOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
  }

  export type MessengerMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    messengerText?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessengerMessageMinOrderByAggregateInput = {
    id?: SortOrder
    messengerText?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessengerMessageSumOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
  }

  export type BookTitleListRelationFilter = {
    every?: BookTitleWhereInput
    some?: BookTitleWhereInput
    none?: BookTitleWhereInput
  }

  export type BookTitleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuthorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuthorAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AuthorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuthorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuthorSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AuthorListRelationFilter = {
    every?: AuthorWhereInput
    some?: AuthorWhereInput
    none?: AuthorWhereInput
  }

  export type BookCategoryListRelationFilter = {
    every?: BookCategoryWhereInput
    some?: BookCategoryWhereInput
    none?: BookCategoryWhereInput
  }

  export type BookListRelationFilter = {
    every?: BookWhereInput
    some?: BookWhereInput
    none?: BookWhereInput
  }

  export type RequestRecordListRelationFilter = {
    every?: RequestRecordWhereInput
    some?: RequestRecordWhereInput
    none?: RequestRecordWhereInput
  }

  export type AuthorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RequestRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookTitleCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    isbn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookTitleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BookTitleMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    isbn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookTitleMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    isbn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookTitleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BookCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BookCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookCategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BookTitleRelationFilter = {
    is?: BookTitleWhereInput
    isNot?: BookTitleWhereInput
  }

  export type LibraryRelationFilter = {
    is?: LibraryWhereInput
    isNot?: LibraryWhereInput
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type BorrowingRecordListRelationFilter = {
    every?: BorrowingRecordWhereInput
    some?: BorrowingRecordWhereInput
    none?: BorrowingRecordWhereInput
  }

  export type BorrowingRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookCountOrderByAggregateInput = {
    id?: SortOrder
    bookTitleId?: SortOrder
    libraryId?: SortOrder
    isAvailable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookAvgOrderByAggregateInput = {
    id?: SortOrder
    bookTitleId?: SortOrder
    libraryId?: SortOrder
  }

  export type BookMaxOrderByAggregateInput = {
    id?: SortOrder
    bookTitleId?: SortOrder
    libraryId?: SortOrder
    isAvailable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookMinOrderByAggregateInput = {
    id?: SortOrder
    bookTitleId?: SortOrder
    libraryId?: SortOrder
    isAvailable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookSumOrderByAggregateInput = {
    id?: SortOrder
    bookTitleId?: SortOrder
    libraryId?: SortOrder
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type UniversityRelationFilter = {
    is?: UniversityWhereInput
    isNot?: UniversityWhereInput
  }

  export type LibraryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    universityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryAvgOrderByAggregateInput = {
    id?: SortOrder
    universityId?: SortOrder
  }

  export type LibraryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    universityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    universityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibrarySumOrderByAggregateInput = {
    id?: SortOrder
    universityId?: SortOrder
  }

  export type LibraryListRelationFilter = {
    every?: LibraryWhereInput
    some?: LibraryWhereInput
    none?: LibraryWhereInput
  }

  export type StudentListRelationFilter = {
    every?: StudentWhereInput
    some?: StudentWhereInput
    none?: StudentWhereInput
  }

  export type LibraryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UniversityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UniversityAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UniversityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UniversityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UniversitySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StudentCountOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    universityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentAvgOrderByAggregateInput = {
    id?: SortOrder
    universityId?: SortOrder
  }

  export type StudentMaxOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    universityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentMinOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    universityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentSumOrderByAggregateInput = {
    id?: SortOrder
    universityId?: SortOrder
  }

  export type StudentRelationFilter = {
    is?: StudentWhereInput
    isNot?: StudentWhereInput
  }

  export type BookRelationFilter = {
    is?: BookWhereInput
    isNot?: BookWhereInput
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type BorrowingRecordCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    bookId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    actualEndDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BorrowingRecordAvgOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    bookId?: SortOrder
  }

  export type BorrowingRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    bookId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    actualEndDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BorrowingRecordMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    bookId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    actualEndDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BorrowingRecordSumOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    bookId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type RequestRecordCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    bookTitleId?: SortOrder
    requestingLibraryId?: SortOrder
    requestedLibraryId?: SortOrder
    requestDate?: SortOrder
    acquiredDate?: SortOrder
    returnDate?: SortOrder
    bookId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RequestRecordAvgOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    bookTitleId?: SortOrder
    requestingLibraryId?: SortOrder
    requestedLibraryId?: SortOrder
    bookId?: SortOrder
  }

  export type RequestRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    bookTitleId?: SortOrder
    requestingLibraryId?: SortOrder
    requestedLibraryId?: SortOrder
    requestDate?: SortOrder
    acquiredDate?: SortOrder
    returnDate?: SortOrder
    bookId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RequestRecordMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    bookTitleId?: SortOrder
    requestingLibraryId?: SortOrder
    requestedLibraryId?: SortOrder
    requestDate?: SortOrder
    acquiredDate?: SortOrder
    returnDate?: SortOrder
    bookId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RequestRecordSumOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    bookTitleId?: SortOrder
    requestingLibraryId?: SortOrder
    requestedLibraryId?: SortOrder
    bookId?: SortOrder
  }

  export type TodoListCountOrderByAggregateInput = {
    id?: SortOrder
    task?: SortOrder
    status?: SortOrder
    bgColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TodoListAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TodoListMaxOrderByAggregateInput = {
    id?: SortOrder
    task?: SortOrder
    status?: SortOrder
    bgColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TodoListMinOrderByAggregateInput = {
    id?: SortOrder
    task?: SortOrder
    status?: SortOrder
    bgColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TodoListSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserRelationListRelationFilter = {
    every?: UserRelationWhereInput
    some?: UserRelationWhereInput
    none?: UserRelationWhereInput
  }

  export type TweetListRelationFilter = {
    every?: TweetWhereInput
    some?: TweetWhereInput
    none?: TweetWhereInput
  }

  export type DirectMessageListRelationFilter = {
    every?: DirectMessageWhereInput
    some?: DirectMessageWhereInput
    none?: DirectMessageWhereInput
  }

  export type UserRelationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TweetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DirectMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserRelationCountOrderByAggregateInput = {
    id?: SortOrder
    followingUserId?: SortOrder
    followedUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserRelationAvgOrderByAggregateInput = {
    id?: SortOrder
    followingUserId?: SortOrder
    followedUserId?: SortOrder
  }

  export type UserRelationMaxOrderByAggregateInput = {
    id?: SortOrder
    followingUserId?: SortOrder
    followedUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserRelationMinOrderByAggregateInput = {
    id?: SortOrder
    followingUserId?: SortOrder
    followedUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserRelationSumOrderByAggregateInput = {
    id?: SortOrder
    followingUserId?: SortOrder
    followedUserId?: SortOrder
  }

  export type TweetRelationFilter = {
    is?: TweetWhereInput | null
    isNot?: TweetWhereInput | null
  }

  export type HashTagListRelationFilter = {
    every?: HashTagWhereInput
    some?: HashTagWhereInput
    none?: HashTagWhereInput
  }

  export type HashTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TweetCountOrderByAggregateInput = {
    id?: SortOrder
    tweetText?: SortOrder
    parentTweetId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TweetAvgOrderByAggregateInput = {
    id?: SortOrder
    parentTweetId?: SortOrder
    userId?: SortOrder
  }

  export type TweetMaxOrderByAggregateInput = {
    id?: SortOrder
    tweetText?: SortOrder
    parentTweetId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TweetMinOrderByAggregateInput = {
    id?: SortOrder
    tweetText?: SortOrder
    parentTweetId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TweetSumOrderByAggregateInput = {
    id?: SortOrder
    parentTweetId?: SortOrder
    userId?: SortOrder
  }

  export type HashTagCountOrderByAggregateInput = {
    id?: SortOrder
    hashTagText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HashTagAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type HashTagMaxOrderByAggregateInput = {
    id?: SortOrder
    hashTagText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HashTagMinOrderByAggregateInput = {
    id?: SortOrder
    hashTagText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HashTagSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DirectMessageCountOrderByAggregateInput = {
    id?: SortOrder
    dmText?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DirectMessageAvgOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
  }

  export type DirectMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    dmText?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DirectMessageMinOrderByAggregateInput = {
    id?: SortOrder
    dmText?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DirectMessageSumOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type ChannelListRelationFilter = {
    every?: ChannelWhereInput
    some?: ChannelWhereInput
    none?: ChannelWhereInput
  }

  export type UserToChannelwithRoleListRelationFilter = {
    every?: UserToChannelwithRoleWhereInput
    some?: UserToChannelwithRoleWhereInput
    none?: UserToChannelwithRoleWhereInput
  }

  export type VideoListRelationFilter = {
    every?: VideoWhereInput
    some?: VideoWhereInput
    none?: VideoWhereInput
  }

  export type UserToVideoWithReactionListRelationFilter = {
    every?: UserToVideoWithReactionWhereInput
    some?: UserToVideoWithReactionWhereInput
    none?: UserToVideoWithReactionWhereInput
  }

  export type VideoCommentListRelationFilter = {
    every?: VideoCommentWhereInput
    some?: VideoCommentWhereInput
    none?: VideoCommentWhereInput
  }

  export type ChannelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserToChannelwithRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VideoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserToVideoWithReactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VideoCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type YouTubeUserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    profileImageUrl?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YouTubeUserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type YouTubeUserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    profileImageUrl?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YouTubeUserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    profileImageUrl?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YouTubeUserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type YouTubeUserListRelationFilter = {
    every?: YouTubeUserWhereInput
    some?: YouTubeUserWhereInput
    none?: YouTubeUserWhereInput
  }

  export type YouTubeUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChannelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    profileImageUrl?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChannelAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ChannelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    profileImageUrl?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChannelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    profileImageUrl?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChannelSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type YouTubeUserRelationFilter = {
    is?: YouTubeUserWhereInput
    isNot?: YouTubeUserWhereInput
  }

  export type ChannelRelationFilter = {
    is?: ChannelWhereInput
    isNot?: ChannelWhereInput
  }

  export type EnumRoleEnumFilter = {
    equals?: RoleEnum
    in?: Enumerable<RoleEnum>
    notIn?: Enumerable<RoleEnum>
    not?: NestedEnumRoleEnumFilter | RoleEnum
  }

  export type UserToChannelwithRoleCountOrderByAggregateInput = {
    id?: SortOrder
    youTubeUserId?: SortOrder
    channelId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserToChannelwithRoleAvgOrderByAggregateInput = {
    id?: SortOrder
    youTubeUserId?: SortOrder
    channelId?: SortOrder
  }

  export type UserToChannelwithRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    youTubeUserId?: SortOrder
    channelId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserToChannelwithRoleMinOrderByAggregateInput = {
    id?: SortOrder
    youTubeUserId?: SortOrder
    channelId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserToChannelwithRoleSumOrderByAggregateInput = {
    id?: SortOrder
    youTubeUserId?: SortOrder
    channelId?: SortOrder
  }

  export type EnumRoleEnumWithAggregatesFilter = {
    equals?: RoleEnum
    in?: Enumerable<RoleEnum>
    notIn?: Enumerable<RoleEnum>
    not?: NestedEnumRoleEnumWithAggregatesFilter | RoleEnum
    _count?: NestedIntFilter
    _min?: NestedEnumRoleEnumFilter
    _max?: NestedEnumRoleEnumFilter
  }

  export type VideoCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    videoUrl?: SortOrder
    thumbnailImageUrl?: SortOrder
    description?: SortOrder
    channelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoAvgOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
  }

  export type VideoMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    videoUrl?: SortOrder
    thumbnailImageUrl?: SortOrder
    description?: SortOrder
    channelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    videoUrl?: SortOrder
    thumbnailImageUrl?: SortOrder
    description?: SortOrder
    channelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoSumOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
  }

  export type VideoRelationFilter = {
    is?: VideoWhereInput
    isNot?: VideoWhereInput
  }

  export type EnumReactionEnumFilter = {
    equals?: ReactionEnum
    in?: Enumerable<ReactionEnum>
    notIn?: Enumerable<ReactionEnum>
    not?: NestedEnumReactionEnumFilter | ReactionEnum
  }

  export type UserToVideoWithReactionCountOrderByAggregateInput = {
    id?: SortOrder
    youTubeUserId?: SortOrder
    videoId?: SortOrder
    reaction?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserToVideoWithReactionAvgOrderByAggregateInput = {
    id?: SortOrder
    youTubeUserId?: SortOrder
    videoId?: SortOrder
  }

  export type UserToVideoWithReactionMaxOrderByAggregateInput = {
    id?: SortOrder
    youTubeUserId?: SortOrder
    videoId?: SortOrder
    reaction?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserToVideoWithReactionMinOrderByAggregateInput = {
    id?: SortOrder
    youTubeUserId?: SortOrder
    videoId?: SortOrder
    reaction?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserToVideoWithReactionSumOrderByAggregateInput = {
    id?: SortOrder
    youTubeUserId?: SortOrder
    videoId?: SortOrder
  }

  export type EnumReactionEnumWithAggregatesFilter = {
    equals?: ReactionEnum
    in?: Enumerable<ReactionEnum>
    notIn?: Enumerable<ReactionEnum>
    not?: NestedEnumReactionEnumWithAggregatesFilter | ReactionEnum
    _count?: NestedIntFilter
    _min?: NestedEnumReactionEnumFilter
    _max?: NestedEnumReactionEnumFilter
  }

  export type VideoCommentRelationFilter = {
    is?: VideoCommentWhereInput | null
    isNot?: VideoCommentWhereInput | null
  }

  export type VideoCommentCountOrderByAggregateInput = {
    id?: SortOrder
    commentText?: SortOrder
    youTubeUserId?: SortOrder
    videoId?: SortOrder
    parentVideoCommentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoCommentAvgOrderByAggregateInput = {
    id?: SortOrder
    youTubeUserId?: SortOrder
    videoId?: SortOrder
    parentVideoCommentId?: SortOrder
  }

  export type VideoCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    commentText?: SortOrder
    youTubeUserId?: SortOrder
    videoId?: SortOrder
    parentVideoCommentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoCommentMinOrderByAggregateInput = {
    id?: SortOrder
    commentText?: SortOrder
    youTubeUserId?: SortOrder
    videoId?: SortOrder
    parentVideoCommentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoCommentSumOrderByAggregateInput = {
    id?: SortOrder
    youTubeUserId?: SortOrder
    videoId?: SortOrder
    parentVideoCommentId?: SortOrder
  }

  export type MenuCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<MenuCreateWithoutCategoryInput>, Enumerable<MenuUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<MenuCreateOrConnectWithoutCategoryInput>
    createMany?: MenuCreateManyCategoryInputEnvelope
    connect?: Enumerable<MenuWhereUniqueInput>
  }

  export type MenuUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<MenuCreateWithoutCategoryInput>, Enumerable<MenuUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<MenuCreateOrConnectWithoutCategoryInput>
    createMany?: MenuCreateManyCategoryInputEnvelope
    connect?: Enumerable<MenuWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type MenuUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<MenuCreateWithoutCategoryInput>, Enumerable<MenuUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<MenuCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<MenuUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: MenuCreateManyCategoryInputEnvelope
    set?: Enumerable<MenuWhereUniqueInput>
    disconnect?: Enumerable<MenuWhereUniqueInput>
    delete?: Enumerable<MenuWhereUniqueInput>
    connect?: Enumerable<MenuWhereUniqueInput>
    update?: Enumerable<MenuUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<MenuUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<MenuScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MenuUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<MenuCreateWithoutCategoryInput>, Enumerable<MenuUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<MenuCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<MenuUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: MenuCreateManyCategoryInputEnvelope
    set?: Enumerable<MenuWhereUniqueInput>
    disconnect?: Enumerable<MenuWhereUniqueInput>
    delete?: Enumerable<MenuWhereUniqueInput>
    connect?: Enumerable<MenuWhereUniqueInput>
    update?: Enumerable<MenuUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<MenuUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<MenuScalarWhereInput>
  }

  export type CategoryCreateNestedOneWithoutMenuInput = {
    create?: XOR<CategoryCreateWithoutMenuInput, CategoryUncheckedCreateWithoutMenuInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutMenuInput
    connect?: CategoryWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutMenuInput = {
    create?: XOR<Enumerable<OrderItemCreateWithoutMenuInput>, Enumerable<OrderItemUncheckedCreateWithoutMenuInput>>
    connectOrCreate?: Enumerable<OrderItemCreateOrConnectWithoutMenuInput>
    createMany?: OrderItemCreateManyMenuInputEnvelope
    connect?: Enumerable<OrderItemWhereUniqueInput>
  }

  export type OrderItemUncheckedCreateNestedManyWithoutMenuInput = {
    create?: XOR<Enumerable<OrderItemCreateWithoutMenuInput>, Enumerable<OrderItemUncheckedCreateWithoutMenuInput>>
    connectOrCreate?: Enumerable<OrderItemCreateOrConnectWithoutMenuInput>
    createMany?: OrderItemCreateManyMenuInputEnvelope
    connect?: Enumerable<OrderItemWhereUniqueInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CategoryUpdateOneWithoutMenuNestedInput = {
    create?: XOR<CategoryCreateWithoutMenuInput, CategoryUncheckedCreateWithoutMenuInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutMenuInput
    upsert?: CategoryUpsertWithoutMenuInput
    disconnect?: boolean
    delete?: boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<CategoryUpdateWithoutMenuInput, CategoryUncheckedUpdateWithoutMenuInput>
  }

  export type OrderItemUpdateManyWithoutMenuNestedInput = {
    create?: XOR<Enumerable<OrderItemCreateWithoutMenuInput>, Enumerable<OrderItemUncheckedCreateWithoutMenuInput>>
    connectOrCreate?: Enumerable<OrderItemCreateOrConnectWithoutMenuInput>
    upsert?: Enumerable<OrderItemUpsertWithWhereUniqueWithoutMenuInput>
    createMany?: OrderItemCreateManyMenuInputEnvelope
    set?: Enumerable<OrderItemWhereUniqueInput>
    disconnect?: Enumerable<OrderItemWhereUniqueInput>
    delete?: Enumerable<OrderItemWhereUniqueInput>
    connect?: Enumerable<OrderItemWhereUniqueInput>
    update?: Enumerable<OrderItemUpdateWithWhereUniqueWithoutMenuInput>
    updateMany?: Enumerable<OrderItemUpdateManyWithWhereWithoutMenuInput>
    deleteMany?: Enumerable<OrderItemScalarWhereInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OrderItemUncheckedUpdateManyWithoutMenuNestedInput = {
    create?: XOR<Enumerable<OrderItemCreateWithoutMenuInput>, Enumerable<OrderItemUncheckedCreateWithoutMenuInput>>
    connectOrCreate?: Enumerable<OrderItemCreateOrConnectWithoutMenuInput>
    upsert?: Enumerable<OrderItemUpsertWithWhereUniqueWithoutMenuInput>
    createMany?: OrderItemCreateManyMenuInputEnvelope
    set?: Enumerable<OrderItemWhereUniqueInput>
    disconnect?: Enumerable<OrderItemWhereUniqueInput>
    delete?: Enumerable<OrderItemWhereUniqueInput>
    connect?: Enumerable<OrderItemWhereUniqueInput>
    update?: Enumerable<OrderItemUpdateWithWhereUniqueWithoutMenuInput>
    updateMany?: Enumerable<OrderItemUpdateManyWithWhereWithoutMenuInput>
    deleteMany?: Enumerable<OrderItemScalarWhereInput>
  }

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<Enumerable<OrderItemCreateWithoutOrderInput>, Enumerable<OrderItemUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<OrderItemCreateOrConnectWithoutOrderInput>
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: Enumerable<OrderItemWhereUniqueInput>
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<Enumerable<OrderItemCreateWithoutOrderInput>, Enumerable<OrderItemUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<OrderItemCreateOrConnectWithoutOrderInput>
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: Enumerable<OrderItemWhereUniqueInput>
  }

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<Enumerable<OrderItemCreateWithoutOrderInput>, Enumerable<OrderItemUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<OrderItemCreateOrConnectWithoutOrderInput>
    upsert?: Enumerable<OrderItemUpsertWithWhereUniqueWithoutOrderInput>
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: Enumerable<OrderItemWhereUniqueInput>
    disconnect?: Enumerable<OrderItemWhereUniqueInput>
    delete?: Enumerable<OrderItemWhereUniqueInput>
    connect?: Enumerable<OrderItemWhereUniqueInput>
    update?: Enumerable<OrderItemUpdateWithWhereUniqueWithoutOrderInput>
    updateMany?: Enumerable<OrderItemUpdateManyWithWhereWithoutOrderInput>
    deleteMany?: Enumerable<OrderItemScalarWhereInput>
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<Enumerable<OrderItemCreateWithoutOrderInput>, Enumerable<OrderItemUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<OrderItemCreateOrConnectWithoutOrderInput>
    upsert?: Enumerable<OrderItemUpsertWithWhereUniqueWithoutOrderInput>
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: Enumerable<OrderItemWhereUniqueInput>
    disconnect?: Enumerable<OrderItemWhereUniqueInput>
    delete?: Enumerable<OrderItemWhereUniqueInput>
    connect?: Enumerable<OrderItemWhereUniqueInput>
    update?: Enumerable<OrderItemUpdateWithWhereUniqueWithoutOrderInput>
    updateMany?: Enumerable<OrderItemUpdateManyWithWhereWithoutOrderInput>
    deleteMany?: Enumerable<OrderItemScalarWhereInput>
  }

  export type MenuCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<MenuCreateWithoutOrderItemsInput, MenuUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: MenuCreateOrConnectWithoutOrderItemsInput
    connect?: MenuWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    connect?: OrderWhereUniqueInput
  }

  export type MenuUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<MenuCreateWithoutOrderItemsInput, MenuUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: MenuCreateOrConnectWithoutOrderItemsInput
    upsert?: MenuUpsertWithoutOrderItemsInput
    connect?: MenuWhereUniqueInput
    update?: XOR<MenuUpdateWithoutOrderItemsInput, MenuUncheckedUpdateWithoutOrderItemsInput>
  }

  export type OrderUpdateOneWithoutItemsNestedInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    upsert?: OrderUpsertWithoutItemsInput
    disconnect?: boolean
    delete?: boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type QuizCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<QuizCreateWithoutCategoryInput>, Enumerable<QuizUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<QuizCreateOrConnectWithoutCategoryInput>
    createMany?: QuizCreateManyCategoryInputEnvelope
    connect?: Enumerable<QuizWhereUniqueInput>
  }

  export type QuizUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<QuizCreateWithoutCategoryInput>, Enumerable<QuizUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<QuizCreateOrConnectWithoutCategoryInput>
    createMany?: QuizCreateManyCategoryInputEnvelope
    connect?: Enumerable<QuizWhereUniqueInput>
  }

  export type QuizUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<QuizCreateWithoutCategoryInput>, Enumerable<QuizUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<QuizCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<QuizUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: QuizCreateManyCategoryInputEnvelope
    set?: Enumerable<QuizWhereUniqueInput>
    disconnect?: Enumerable<QuizWhereUniqueInput>
    delete?: Enumerable<QuizWhereUniqueInput>
    connect?: Enumerable<QuizWhereUniqueInput>
    update?: Enumerable<QuizUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<QuizUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<QuizScalarWhereInput>
  }

  export type QuizUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<QuizCreateWithoutCategoryInput>, Enumerable<QuizUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<QuizCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<QuizUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: QuizCreateManyCategoryInputEnvelope
    set?: Enumerable<QuizWhereUniqueInput>
    disconnect?: Enumerable<QuizWhereUniqueInput>
    delete?: Enumerable<QuizWhereUniqueInput>
    connect?: Enumerable<QuizWhereUniqueInput>
    update?: Enumerable<QuizUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<QuizUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<QuizScalarWhereInput>
  }

  export type QuizCreateNestedOneWithoutChoicesInput = {
    create?: XOR<QuizCreateWithoutChoicesInput, QuizUncheckedCreateWithoutChoicesInput>
    connectOrCreate?: QuizCreateOrConnectWithoutChoicesInput
    connect?: QuizWhereUniqueInput
  }

  export type QuizCreateNestedManyWithoutCorrectChoiceInput = {
    create?: XOR<Enumerable<QuizCreateWithoutCorrectChoiceInput>, Enumerable<QuizUncheckedCreateWithoutCorrectChoiceInput>>
    connectOrCreate?: Enumerable<QuizCreateOrConnectWithoutCorrectChoiceInput>
    createMany?: QuizCreateManyCorrectChoiceInputEnvelope
    connect?: Enumerable<QuizWhereUniqueInput>
  }

  export type RoundCreateNestedManyWithoutSelectedChoicesInput = {
    create?: XOR<Enumerable<RoundCreateWithoutSelectedChoicesInput>, Enumerable<RoundUncheckedCreateWithoutSelectedChoicesInput>>
    connectOrCreate?: Enumerable<RoundCreateOrConnectWithoutSelectedChoicesInput>
    connect?: Enumerable<RoundWhereUniqueInput>
  }

  export type QuizUncheckedCreateNestedManyWithoutCorrectChoiceInput = {
    create?: XOR<Enumerable<QuizCreateWithoutCorrectChoiceInput>, Enumerable<QuizUncheckedCreateWithoutCorrectChoiceInput>>
    connectOrCreate?: Enumerable<QuizCreateOrConnectWithoutCorrectChoiceInput>
    createMany?: QuizCreateManyCorrectChoiceInputEnvelope
    connect?: Enumerable<QuizWhereUniqueInput>
  }

  export type RoundUncheckedCreateNestedManyWithoutSelectedChoicesInput = {
    create?: XOR<Enumerable<RoundCreateWithoutSelectedChoicesInput>, Enumerable<RoundUncheckedCreateWithoutSelectedChoicesInput>>
    connectOrCreate?: Enumerable<RoundCreateOrConnectWithoutSelectedChoicesInput>
    connect?: Enumerable<RoundWhereUniqueInput>
  }

  export type QuizUpdateOneWithoutChoicesNestedInput = {
    create?: XOR<QuizCreateWithoutChoicesInput, QuizUncheckedCreateWithoutChoicesInput>
    connectOrCreate?: QuizCreateOrConnectWithoutChoicesInput
    upsert?: QuizUpsertWithoutChoicesInput
    disconnect?: boolean
    delete?: boolean
    connect?: QuizWhereUniqueInput
    update?: XOR<QuizUpdateWithoutChoicesInput, QuizUncheckedUpdateWithoutChoicesInput>
  }

  export type QuizUpdateManyWithoutCorrectChoiceNestedInput = {
    create?: XOR<Enumerable<QuizCreateWithoutCorrectChoiceInput>, Enumerable<QuizUncheckedCreateWithoutCorrectChoiceInput>>
    connectOrCreate?: Enumerable<QuizCreateOrConnectWithoutCorrectChoiceInput>
    upsert?: Enumerable<QuizUpsertWithWhereUniqueWithoutCorrectChoiceInput>
    createMany?: QuizCreateManyCorrectChoiceInputEnvelope
    set?: Enumerable<QuizWhereUniqueInput>
    disconnect?: Enumerable<QuizWhereUniqueInput>
    delete?: Enumerable<QuizWhereUniqueInput>
    connect?: Enumerable<QuizWhereUniqueInput>
    update?: Enumerable<QuizUpdateWithWhereUniqueWithoutCorrectChoiceInput>
    updateMany?: Enumerable<QuizUpdateManyWithWhereWithoutCorrectChoiceInput>
    deleteMany?: Enumerable<QuizScalarWhereInput>
  }

  export type RoundUpdateManyWithoutSelectedChoicesNestedInput = {
    create?: XOR<Enumerable<RoundCreateWithoutSelectedChoicesInput>, Enumerable<RoundUncheckedCreateWithoutSelectedChoicesInput>>
    connectOrCreate?: Enumerable<RoundCreateOrConnectWithoutSelectedChoicesInput>
    upsert?: Enumerable<RoundUpsertWithWhereUniqueWithoutSelectedChoicesInput>
    set?: Enumerable<RoundWhereUniqueInput>
    disconnect?: Enumerable<RoundWhereUniqueInput>
    delete?: Enumerable<RoundWhereUniqueInput>
    connect?: Enumerable<RoundWhereUniqueInput>
    update?: Enumerable<RoundUpdateWithWhereUniqueWithoutSelectedChoicesInput>
    updateMany?: Enumerable<RoundUpdateManyWithWhereWithoutSelectedChoicesInput>
    deleteMany?: Enumerable<RoundScalarWhereInput>
  }

  export type QuizUncheckedUpdateManyWithoutCorrectChoiceNestedInput = {
    create?: XOR<Enumerable<QuizCreateWithoutCorrectChoiceInput>, Enumerable<QuizUncheckedCreateWithoutCorrectChoiceInput>>
    connectOrCreate?: Enumerable<QuizCreateOrConnectWithoutCorrectChoiceInput>
    upsert?: Enumerable<QuizUpsertWithWhereUniqueWithoutCorrectChoiceInput>
    createMany?: QuizCreateManyCorrectChoiceInputEnvelope
    set?: Enumerable<QuizWhereUniqueInput>
    disconnect?: Enumerable<QuizWhereUniqueInput>
    delete?: Enumerable<QuizWhereUniqueInput>
    connect?: Enumerable<QuizWhereUniqueInput>
    update?: Enumerable<QuizUpdateWithWhereUniqueWithoutCorrectChoiceInput>
    updateMany?: Enumerable<QuizUpdateManyWithWhereWithoutCorrectChoiceInput>
    deleteMany?: Enumerable<QuizScalarWhereInput>
  }

  export type RoundUncheckedUpdateManyWithoutSelectedChoicesNestedInput = {
    create?: XOR<Enumerable<RoundCreateWithoutSelectedChoicesInput>, Enumerable<RoundUncheckedCreateWithoutSelectedChoicesInput>>
    connectOrCreate?: Enumerable<RoundCreateOrConnectWithoutSelectedChoicesInput>
    upsert?: Enumerable<RoundUpsertWithWhereUniqueWithoutSelectedChoicesInput>
    set?: Enumerable<RoundWhereUniqueInput>
    disconnect?: Enumerable<RoundWhereUniqueInput>
    delete?: Enumerable<RoundWhereUniqueInput>
    connect?: Enumerable<RoundWhereUniqueInput>
    update?: Enumerable<RoundUpdateWithWhereUniqueWithoutSelectedChoicesInput>
    updateMany?: Enumerable<RoundUpdateManyWithWhereWithoutSelectedChoicesInput>
    deleteMany?: Enumerable<RoundScalarWhereInput>
  }

  export type QuizCategoryCreateNestedOneWithoutQuizzesInput = {
    create?: XOR<QuizCategoryCreateWithoutQuizzesInput, QuizCategoryUncheckedCreateWithoutQuizzesInput>
    connectOrCreate?: QuizCategoryCreateOrConnectWithoutQuizzesInput
    connect?: QuizCategoryWhereUniqueInput
  }

  export type ChoiceCreateNestedManyWithoutQuizInput = {
    create?: XOR<Enumerable<ChoiceCreateWithoutQuizInput>, Enumerable<ChoiceUncheckedCreateWithoutQuizInput>>
    connectOrCreate?: Enumerable<ChoiceCreateOrConnectWithoutQuizInput>
    createMany?: ChoiceCreateManyQuizInputEnvelope
    connect?: Enumerable<ChoiceWhereUniqueInput>
  }

  export type ChoiceCreateNestedOneWithoutCorrectQuizzesInput = {
    create?: XOR<ChoiceCreateWithoutCorrectQuizzesInput, ChoiceUncheckedCreateWithoutCorrectQuizzesInput>
    connectOrCreate?: ChoiceCreateOrConnectWithoutCorrectQuizzesInput
    connect?: ChoiceWhereUniqueInput
  }

  export type RoundCreateNestedManyWithoutQuizzesInput = {
    create?: XOR<Enumerable<RoundCreateWithoutQuizzesInput>, Enumerable<RoundUncheckedCreateWithoutQuizzesInput>>
    connectOrCreate?: Enumerable<RoundCreateOrConnectWithoutQuizzesInput>
    connect?: Enumerable<RoundWhereUniqueInput>
  }

  export type ChoiceUncheckedCreateNestedManyWithoutQuizInput = {
    create?: XOR<Enumerable<ChoiceCreateWithoutQuizInput>, Enumerable<ChoiceUncheckedCreateWithoutQuizInput>>
    connectOrCreate?: Enumerable<ChoiceCreateOrConnectWithoutQuizInput>
    createMany?: ChoiceCreateManyQuizInputEnvelope
    connect?: Enumerable<ChoiceWhereUniqueInput>
  }

  export type RoundUncheckedCreateNestedManyWithoutQuizzesInput = {
    create?: XOR<Enumerable<RoundCreateWithoutQuizzesInput>, Enumerable<RoundUncheckedCreateWithoutQuizzesInput>>
    connectOrCreate?: Enumerable<RoundCreateOrConnectWithoutQuizzesInput>
    connect?: Enumerable<RoundWhereUniqueInput>
  }

  export type QuizCategoryUpdateOneRequiredWithoutQuizzesNestedInput = {
    create?: XOR<QuizCategoryCreateWithoutQuizzesInput, QuizCategoryUncheckedCreateWithoutQuizzesInput>
    connectOrCreate?: QuizCategoryCreateOrConnectWithoutQuizzesInput
    upsert?: QuizCategoryUpsertWithoutQuizzesInput
    connect?: QuizCategoryWhereUniqueInput
    update?: XOR<QuizCategoryUpdateWithoutQuizzesInput, QuizCategoryUncheckedUpdateWithoutQuizzesInput>
  }

  export type ChoiceUpdateManyWithoutQuizNestedInput = {
    create?: XOR<Enumerable<ChoiceCreateWithoutQuizInput>, Enumerable<ChoiceUncheckedCreateWithoutQuizInput>>
    connectOrCreate?: Enumerable<ChoiceCreateOrConnectWithoutQuizInput>
    upsert?: Enumerable<ChoiceUpsertWithWhereUniqueWithoutQuizInput>
    createMany?: ChoiceCreateManyQuizInputEnvelope
    set?: Enumerable<ChoiceWhereUniqueInput>
    disconnect?: Enumerable<ChoiceWhereUniqueInput>
    delete?: Enumerable<ChoiceWhereUniqueInput>
    connect?: Enumerable<ChoiceWhereUniqueInput>
    update?: Enumerable<ChoiceUpdateWithWhereUniqueWithoutQuizInput>
    updateMany?: Enumerable<ChoiceUpdateManyWithWhereWithoutQuizInput>
    deleteMany?: Enumerable<ChoiceScalarWhereInput>
  }

  export type ChoiceUpdateOneRequiredWithoutCorrectQuizzesNestedInput = {
    create?: XOR<ChoiceCreateWithoutCorrectQuizzesInput, ChoiceUncheckedCreateWithoutCorrectQuizzesInput>
    connectOrCreate?: ChoiceCreateOrConnectWithoutCorrectQuizzesInput
    upsert?: ChoiceUpsertWithoutCorrectQuizzesInput
    connect?: ChoiceWhereUniqueInput
    update?: XOR<ChoiceUpdateWithoutCorrectQuizzesInput, ChoiceUncheckedUpdateWithoutCorrectQuizzesInput>
  }

  export type RoundUpdateManyWithoutQuizzesNestedInput = {
    create?: XOR<Enumerable<RoundCreateWithoutQuizzesInput>, Enumerable<RoundUncheckedCreateWithoutQuizzesInput>>
    connectOrCreate?: Enumerable<RoundCreateOrConnectWithoutQuizzesInput>
    upsert?: Enumerable<RoundUpsertWithWhereUniqueWithoutQuizzesInput>
    set?: Enumerable<RoundWhereUniqueInput>
    disconnect?: Enumerable<RoundWhereUniqueInput>
    delete?: Enumerable<RoundWhereUniqueInput>
    connect?: Enumerable<RoundWhereUniqueInput>
    update?: Enumerable<RoundUpdateWithWhereUniqueWithoutQuizzesInput>
    updateMany?: Enumerable<RoundUpdateManyWithWhereWithoutQuizzesInput>
    deleteMany?: Enumerable<RoundScalarWhereInput>
  }

  export type ChoiceUncheckedUpdateManyWithoutQuizNestedInput = {
    create?: XOR<Enumerable<ChoiceCreateWithoutQuizInput>, Enumerable<ChoiceUncheckedCreateWithoutQuizInput>>
    connectOrCreate?: Enumerable<ChoiceCreateOrConnectWithoutQuizInput>
    upsert?: Enumerable<ChoiceUpsertWithWhereUniqueWithoutQuizInput>
    createMany?: ChoiceCreateManyQuizInputEnvelope
    set?: Enumerable<ChoiceWhereUniqueInput>
    disconnect?: Enumerable<ChoiceWhereUniqueInput>
    delete?: Enumerable<ChoiceWhereUniqueInput>
    connect?: Enumerable<ChoiceWhereUniqueInput>
    update?: Enumerable<ChoiceUpdateWithWhereUniqueWithoutQuizInput>
    updateMany?: Enumerable<ChoiceUpdateManyWithWhereWithoutQuizInput>
    deleteMany?: Enumerable<ChoiceScalarWhereInput>
  }

  export type RoundUncheckedUpdateManyWithoutQuizzesNestedInput = {
    create?: XOR<Enumerable<RoundCreateWithoutQuizzesInput>, Enumerable<RoundUncheckedCreateWithoutQuizzesInput>>
    connectOrCreate?: Enumerable<RoundCreateOrConnectWithoutQuizzesInput>
    upsert?: Enumerable<RoundUpsertWithWhereUniqueWithoutQuizzesInput>
    set?: Enumerable<RoundWhereUniqueInput>
    disconnect?: Enumerable<RoundWhereUniqueInput>
    delete?: Enumerable<RoundWhereUniqueInput>
    connect?: Enumerable<RoundWhereUniqueInput>
    update?: Enumerable<RoundUpdateWithWhereUniqueWithoutQuizzesInput>
    updateMany?: Enumerable<RoundUpdateManyWithWhereWithoutQuizzesInput>
    deleteMany?: Enumerable<RoundScalarWhereInput>
  }

  export type QuizCreateNestedManyWithoutRoundsInput = {
    create?: XOR<Enumerable<QuizCreateWithoutRoundsInput>, Enumerable<QuizUncheckedCreateWithoutRoundsInput>>
    connectOrCreate?: Enumerable<QuizCreateOrConnectWithoutRoundsInput>
    connect?: Enumerable<QuizWhereUniqueInput>
  }

  export type ChoiceCreateNestedManyWithoutRoundsInput = {
    create?: XOR<Enumerable<ChoiceCreateWithoutRoundsInput>, Enumerable<ChoiceUncheckedCreateWithoutRoundsInput>>
    connectOrCreate?: Enumerable<ChoiceCreateOrConnectWithoutRoundsInput>
    connect?: Enumerable<ChoiceWhereUniqueInput>
  }

  export type QuizUncheckedCreateNestedManyWithoutRoundsInput = {
    create?: XOR<Enumerable<QuizCreateWithoutRoundsInput>, Enumerable<QuizUncheckedCreateWithoutRoundsInput>>
    connectOrCreate?: Enumerable<QuizCreateOrConnectWithoutRoundsInput>
    connect?: Enumerable<QuizWhereUniqueInput>
  }

  export type ChoiceUncheckedCreateNestedManyWithoutRoundsInput = {
    create?: XOR<Enumerable<ChoiceCreateWithoutRoundsInput>, Enumerable<ChoiceUncheckedCreateWithoutRoundsInput>>
    connectOrCreate?: Enumerable<ChoiceCreateOrConnectWithoutRoundsInput>
    connect?: Enumerable<ChoiceWhereUniqueInput>
  }

  export type QuizUpdateManyWithoutRoundsNestedInput = {
    create?: XOR<Enumerable<QuizCreateWithoutRoundsInput>, Enumerable<QuizUncheckedCreateWithoutRoundsInput>>
    connectOrCreate?: Enumerable<QuizCreateOrConnectWithoutRoundsInput>
    upsert?: Enumerable<QuizUpsertWithWhereUniqueWithoutRoundsInput>
    set?: Enumerable<QuizWhereUniqueInput>
    disconnect?: Enumerable<QuizWhereUniqueInput>
    delete?: Enumerable<QuizWhereUniqueInput>
    connect?: Enumerable<QuizWhereUniqueInput>
    update?: Enumerable<QuizUpdateWithWhereUniqueWithoutRoundsInput>
    updateMany?: Enumerable<QuizUpdateManyWithWhereWithoutRoundsInput>
    deleteMany?: Enumerable<QuizScalarWhereInput>
  }

  export type ChoiceUpdateManyWithoutRoundsNestedInput = {
    create?: XOR<Enumerable<ChoiceCreateWithoutRoundsInput>, Enumerable<ChoiceUncheckedCreateWithoutRoundsInput>>
    connectOrCreate?: Enumerable<ChoiceCreateOrConnectWithoutRoundsInput>
    upsert?: Enumerable<ChoiceUpsertWithWhereUniqueWithoutRoundsInput>
    set?: Enumerable<ChoiceWhereUniqueInput>
    disconnect?: Enumerable<ChoiceWhereUniqueInput>
    delete?: Enumerable<ChoiceWhereUniqueInput>
    connect?: Enumerable<ChoiceWhereUniqueInput>
    update?: Enumerable<ChoiceUpdateWithWhereUniqueWithoutRoundsInput>
    updateMany?: Enumerable<ChoiceUpdateManyWithWhereWithoutRoundsInput>
    deleteMany?: Enumerable<ChoiceScalarWhereInput>
  }

  export type QuizUncheckedUpdateManyWithoutRoundsNestedInput = {
    create?: XOR<Enumerable<QuizCreateWithoutRoundsInput>, Enumerable<QuizUncheckedCreateWithoutRoundsInput>>
    connectOrCreate?: Enumerable<QuizCreateOrConnectWithoutRoundsInput>
    upsert?: Enumerable<QuizUpsertWithWhereUniqueWithoutRoundsInput>
    set?: Enumerable<QuizWhereUniqueInput>
    disconnect?: Enumerable<QuizWhereUniqueInput>
    delete?: Enumerable<QuizWhereUniqueInput>
    connect?: Enumerable<QuizWhereUniqueInput>
    update?: Enumerable<QuizUpdateWithWhereUniqueWithoutRoundsInput>
    updateMany?: Enumerable<QuizUpdateManyWithWhereWithoutRoundsInput>
    deleteMany?: Enumerable<QuizScalarWhereInput>
  }

  export type ChoiceUncheckedUpdateManyWithoutRoundsNestedInput = {
    create?: XOR<Enumerable<ChoiceCreateWithoutRoundsInput>, Enumerable<ChoiceUncheckedCreateWithoutRoundsInput>>
    connectOrCreate?: Enumerable<ChoiceCreateOrConnectWithoutRoundsInput>
    upsert?: Enumerable<ChoiceUpsertWithWhereUniqueWithoutRoundsInput>
    set?: Enumerable<ChoiceWhereUniqueInput>
    disconnect?: Enumerable<ChoiceWhereUniqueInput>
    delete?: Enumerable<ChoiceWhereUniqueInput>
    connect?: Enumerable<ChoiceWhereUniqueInput>
    update?: Enumerable<ChoiceUpdateWithWhereUniqueWithoutRoundsInput>
    updateMany?: Enumerable<ChoiceUpdateManyWithWhereWithoutRoundsInput>
    deleteMany?: Enumerable<ChoiceScalarWhereInput>
  }

  export type BranchCreateNestedManyWithoutBranchOwnerInput = {
    create?: XOR<Enumerable<BranchCreateWithoutBranchOwnerInput>, Enumerable<BranchUncheckedCreateWithoutBranchOwnerInput>>
    connectOrCreate?: Enumerable<BranchCreateOrConnectWithoutBranchOwnerInput>
    createMany?: BranchCreateManyBranchOwnerInputEnvelope
    connect?: Enumerable<BranchWhereUniqueInput>
  }

  export type WMMaintenanceRecordCreateNestedManyWithoutMaintainerInput = {
    create?: XOR<Enumerable<WMMaintenanceRecordCreateWithoutMaintainerInput>, Enumerable<WMMaintenanceRecordUncheckedCreateWithoutMaintainerInput>>
    connectOrCreate?: Enumerable<WMMaintenanceRecordCreateOrConnectWithoutMaintainerInput>
    createMany?: WMMaintenanceRecordCreateManyMaintainerInputEnvelope
    connect?: Enumerable<WMMaintenanceRecordWhereUniqueInput>
  }

  export type UsageRecordCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UsageRecordCreateWithoutUserInput>, Enumerable<UsageRecordUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UsageRecordCreateOrConnectWithoutUserInput>
    createMany?: UsageRecordCreateManyUserInputEnvelope
    connect?: Enumerable<UsageRecordWhereUniqueInput>
  }

  export type TopUpRecordCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TopUpRecordCreateWithoutUserInput>, Enumerable<TopUpRecordUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TopUpRecordCreateOrConnectWithoutUserInput>
    createMany?: TopUpRecordCreateManyUserInputEnvelope
    connect?: Enumerable<TopUpRecordWhereUniqueInput>
  }

  export type BranchUncheckedCreateNestedManyWithoutBranchOwnerInput = {
    create?: XOR<Enumerable<BranchCreateWithoutBranchOwnerInput>, Enumerable<BranchUncheckedCreateWithoutBranchOwnerInput>>
    connectOrCreate?: Enumerable<BranchCreateOrConnectWithoutBranchOwnerInput>
    createMany?: BranchCreateManyBranchOwnerInputEnvelope
    connect?: Enumerable<BranchWhereUniqueInput>
  }

  export type WMMaintenanceRecordUncheckedCreateNestedManyWithoutMaintainerInput = {
    create?: XOR<Enumerable<WMMaintenanceRecordCreateWithoutMaintainerInput>, Enumerable<WMMaintenanceRecordUncheckedCreateWithoutMaintainerInput>>
    connectOrCreate?: Enumerable<WMMaintenanceRecordCreateOrConnectWithoutMaintainerInput>
    createMany?: WMMaintenanceRecordCreateManyMaintainerInputEnvelope
    connect?: Enumerable<WMMaintenanceRecordWhereUniqueInput>
  }

  export type UsageRecordUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UsageRecordCreateWithoutUserInput>, Enumerable<UsageRecordUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UsageRecordCreateOrConnectWithoutUserInput>
    createMany?: UsageRecordCreateManyUserInputEnvelope
    connect?: Enumerable<UsageRecordWhereUniqueInput>
  }

  export type TopUpRecordUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TopUpRecordCreateWithoutUserInput>, Enumerable<TopUpRecordUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TopUpRecordCreateOrConnectWithoutUserInput>
    createMany?: TopUpRecordCreateManyUserInputEnvelope
    connect?: Enumerable<TopUpRecordWhereUniqueInput>
  }

  export type BranchUpdateManyWithoutBranchOwnerNestedInput = {
    create?: XOR<Enumerable<BranchCreateWithoutBranchOwnerInput>, Enumerable<BranchUncheckedCreateWithoutBranchOwnerInput>>
    connectOrCreate?: Enumerable<BranchCreateOrConnectWithoutBranchOwnerInput>
    upsert?: Enumerable<BranchUpsertWithWhereUniqueWithoutBranchOwnerInput>
    createMany?: BranchCreateManyBranchOwnerInputEnvelope
    set?: Enumerable<BranchWhereUniqueInput>
    disconnect?: Enumerable<BranchWhereUniqueInput>
    delete?: Enumerable<BranchWhereUniqueInput>
    connect?: Enumerable<BranchWhereUniqueInput>
    update?: Enumerable<BranchUpdateWithWhereUniqueWithoutBranchOwnerInput>
    updateMany?: Enumerable<BranchUpdateManyWithWhereWithoutBranchOwnerInput>
    deleteMany?: Enumerable<BranchScalarWhereInput>
  }

  export type WMMaintenanceRecordUpdateManyWithoutMaintainerNestedInput = {
    create?: XOR<Enumerable<WMMaintenanceRecordCreateWithoutMaintainerInput>, Enumerable<WMMaintenanceRecordUncheckedCreateWithoutMaintainerInput>>
    connectOrCreate?: Enumerable<WMMaintenanceRecordCreateOrConnectWithoutMaintainerInput>
    upsert?: Enumerable<WMMaintenanceRecordUpsertWithWhereUniqueWithoutMaintainerInput>
    createMany?: WMMaintenanceRecordCreateManyMaintainerInputEnvelope
    set?: Enumerable<WMMaintenanceRecordWhereUniqueInput>
    disconnect?: Enumerable<WMMaintenanceRecordWhereUniqueInput>
    delete?: Enumerable<WMMaintenanceRecordWhereUniqueInput>
    connect?: Enumerable<WMMaintenanceRecordWhereUniqueInput>
    update?: Enumerable<WMMaintenanceRecordUpdateWithWhereUniqueWithoutMaintainerInput>
    updateMany?: Enumerable<WMMaintenanceRecordUpdateManyWithWhereWithoutMaintainerInput>
    deleteMany?: Enumerable<WMMaintenanceRecordScalarWhereInput>
  }

  export type UsageRecordUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UsageRecordCreateWithoutUserInput>, Enumerable<UsageRecordUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UsageRecordCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UsageRecordUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UsageRecordCreateManyUserInputEnvelope
    set?: Enumerable<UsageRecordWhereUniqueInput>
    disconnect?: Enumerable<UsageRecordWhereUniqueInput>
    delete?: Enumerable<UsageRecordWhereUniqueInput>
    connect?: Enumerable<UsageRecordWhereUniqueInput>
    update?: Enumerable<UsageRecordUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UsageRecordUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UsageRecordScalarWhereInput>
  }

  export type TopUpRecordUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<TopUpRecordCreateWithoutUserInput>, Enumerable<TopUpRecordUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TopUpRecordCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TopUpRecordUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TopUpRecordCreateManyUserInputEnvelope
    set?: Enumerable<TopUpRecordWhereUniqueInput>
    disconnect?: Enumerable<TopUpRecordWhereUniqueInput>
    delete?: Enumerable<TopUpRecordWhereUniqueInput>
    connect?: Enumerable<TopUpRecordWhereUniqueInput>
    update?: Enumerable<TopUpRecordUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TopUpRecordUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TopUpRecordScalarWhereInput>
  }

  export type BranchUncheckedUpdateManyWithoutBranchOwnerNestedInput = {
    create?: XOR<Enumerable<BranchCreateWithoutBranchOwnerInput>, Enumerable<BranchUncheckedCreateWithoutBranchOwnerInput>>
    connectOrCreate?: Enumerable<BranchCreateOrConnectWithoutBranchOwnerInput>
    upsert?: Enumerable<BranchUpsertWithWhereUniqueWithoutBranchOwnerInput>
    createMany?: BranchCreateManyBranchOwnerInputEnvelope
    set?: Enumerable<BranchWhereUniqueInput>
    disconnect?: Enumerable<BranchWhereUniqueInput>
    delete?: Enumerable<BranchWhereUniqueInput>
    connect?: Enumerable<BranchWhereUniqueInput>
    update?: Enumerable<BranchUpdateWithWhereUniqueWithoutBranchOwnerInput>
    updateMany?: Enumerable<BranchUpdateManyWithWhereWithoutBranchOwnerInput>
    deleteMany?: Enumerable<BranchScalarWhereInput>
  }

  export type WMMaintenanceRecordUncheckedUpdateManyWithoutMaintainerNestedInput = {
    create?: XOR<Enumerable<WMMaintenanceRecordCreateWithoutMaintainerInput>, Enumerable<WMMaintenanceRecordUncheckedCreateWithoutMaintainerInput>>
    connectOrCreate?: Enumerable<WMMaintenanceRecordCreateOrConnectWithoutMaintainerInput>
    upsert?: Enumerable<WMMaintenanceRecordUpsertWithWhereUniqueWithoutMaintainerInput>
    createMany?: WMMaintenanceRecordCreateManyMaintainerInputEnvelope
    set?: Enumerable<WMMaintenanceRecordWhereUniqueInput>
    disconnect?: Enumerable<WMMaintenanceRecordWhereUniqueInput>
    delete?: Enumerable<WMMaintenanceRecordWhereUniqueInput>
    connect?: Enumerable<WMMaintenanceRecordWhereUniqueInput>
    update?: Enumerable<WMMaintenanceRecordUpdateWithWhereUniqueWithoutMaintainerInput>
    updateMany?: Enumerable<WMMaintenanceRecordUpdateManyWithWhereWithoutMaintainerInput>
    deleteMany?: Enumerable<WMMaintenanceRecordScalarWhereInput>
  }

  export type UsageRecordUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UsageRecordCreateWithoutUserInput>, Enumerable<UsageRecordUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UsageRecordCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UsageRecordUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UsageRecordCreateManyUserInputEnvelope
    set?: Enumerable<UsageRecordWhereUniqueInput>
    disconnect?: Enumerable<UsageRecordWhereUniqueInput>
    delete?: Enumerable<UsageRecordWhereUniqueInput>
    connect?: Enumerable<UsageRecordWhereUniqueInput>
    update?: Enumerable<UsageRecordUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UsageRecordUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UsageRecordScalarWhereInput>
  }

  export type TopUpRecordUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<TopUpRecordCreateWithoutUserInput>, Enumerable<TopUpRecordUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TopUpRecordCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TopUpRecordUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TopUpRecordCreateManyUserInputEnvelope
    set?: Enumerable<TopUpRecordWhereUniqueInput>
    disconnect?: Enumerable<TopUpRecordWhereUniqueInput>
    delete?: Enumerable<TopUpRecordWhereUniqueInput>
    connect?: Enumerable<TopUpRecordWhereUniqueInput>
    update?: Enumerable<TopUpRecordUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TopUpRecordUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TopUpRecordScalarWhereInput>
  }

  export type BinWashUserCreateNestedOneWithoutOwningBranchesInput = {
    create?: XOR<BinWashUserCreateWithoutOwningBranchesInput, BinWashUserUncheckedCreateWithoutOwningBranchesInput>
    connectOrCreate?: BinWashUserCreateOrConnectWithoutOwningBranchesInput
    connect?: BinWashUserWhereUniqueInput
  }

  export type WashingMachineCreateNestedManyWithoutLocatedBranchInput = {
    create?: XOR<Enumerable<WashingMachineCreateWithoutLocatedBranchInput>, Enumerable<WashingMachineUncheckedCreateWithoutLocatedBranchInput>>
    connectOrCreate?: Enumerable<WashingMachineCreateOrConnectWithoutLocatedBranchInput>
    createMany?: WashingMachineCreateManyLocatedBranchInputEnvelope
    connect?: Enumerable<WashingMachineWhereUniqueInput>
  }

  export type WashingMachineUncheckedCreateNestedManyWithoutLocatedBranchInput = {
    create?: XOR<Enumerable<WashingMachineCreateWithoutLocatedBranchInput>, Enumerable<WashingMachineUncheckedCreateWithoutLocatedBranchInput>>
    connectOrCreate?: Enumerable<WashingMachineCreateOrConnectWithoutLocatedBranchInput>
    createMany?: WashingMachineCreateManyLocatedBranchInputEnvelope
    connect?: Enumerable<WashingMachineWhereUniqueInput>
  }

  export type BinWashUserUpdateOneRequiredWithoutOwningBranchesNestedInput = {
    create?: XOR<BinWashUserCreateWithoutOwningBranchesInput, BinWashUserUncheckedCreateWithoutOwningBranchesInput>
    connectOrCreate?: BinWashUserCreateOrConnectWithoutOwningBranchesInput
    upsert?: BinWashUserUpsertWithoutOwningBranchesInput
    connect?: BinWashUserWhereUniqueInput
    update?: XOR<BinWashUserUpdateWithoutOwningBranchesInput, BinWashUserUncheckedUpdateWithoutOwningBranchesInput>
  }

  export type WashingMachineUpdateManyWithoutLocatedBranchNestedInput = {
    create?: XOR<Enumerable<WashingMachineCreateWithoutLocatedBranchInput>, Enumerable<WashingMachineUncheckedCreateWithoutLocatedBranchInput>>
    connectOrCreate?: Enumerable<WashingMachineCreateOrConnectWithoutLocatedBranchInput>
    upsert?: Enumerable<WashingMachineUpsertWithWhereUniqueWithoutLocatedBranchInput>
    createMany?: WashingMachineCreateManyLocatedBranchInputEnvelope
    set?: Enumerable<WashingMachineWhereUniqueInput>
    disconnect?: Enumerable<WashingMachineWhereUniqueInput>
    delete?: Enumerable<WashingMachineWhereUniqueInput>
    connect?: Enumerable<WashingMachineWhereUniqueInput>
    update?: Enumerable<WashingMachineUpdateWithWhereUniqueWithoutLocatedBranchInput>
    updateMany?: Enumerable<WashingMachineUpdateManyWithWhereWithoutLocatedBranchInput>
    deleteMany?: Enumerable<WashingMachineScalarWhereInput>
  }

  export type WashingMachineUncheckedUpdateManyWithoutLocatedBranchNestedInput = {
    create?: XOR<Enumerable<WashingMachineCreateWithoutLocatedBranchInput>, Enumerable<WashingMachineUncheckedCreateWithoutLocatedBranchInput>>
    connectOrCreate?: Enumerable<WashingMachineCreateOrConnectWithoutLocatedBranchInput>
    upsert?: Enumerable<WashingMachineUpsertWithWhereUniqueWithoutLocatedBranchInput>
    createMany?: WashingMachineCreateManyLocatedBranchInputEnvelope
    set?: Enumerable<WashingMachineWhereUniqueInput>
    disconnect?: Enumerable<WashingMachineWhereUniqueInput>
    delete?: Enumerable<WashingMachineWhereUniqueInput>
    connect?: Enumerable<WashingMachineWhereUniqueInput>
    update?: Enumerable<WashingMachineUpdateWithWhereUniqueWithoutLocatedBranchInput>
    updateMany?: Enumerable<WashingMachineUpdateManyWithWhereWithoutLocatedBranchInput>
    deleteMany?: Enumerable<WashingMachineScalarWhereInput>
  }

  export type BranchCreateNestedOneWithoutWashingMachinesInput = {
    create?: XOR<BranchCreateWithoutWashingMachinesInput, BranchUncheckedCreateWithoutWashingMachinesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutWashingMachinesInput
    connect?: BranchWhereUniqueInput
  }

  export type WMProgramCreateNestedManyWithoutEquippingWMsInput = {
    create?: XOR<Enumerable<WMProgramCreateWithoutEquippingWMsInput>, Enumerable<WMProgramUncheckedCreateWithoutEquippingWMsInput>>
    connectOrCreate?: Enumerable<WMProgramCreateOrConnectWithoutEquippingWMsInput>
    connect?: Enumerable<WMProgramWhereUniqueInput>
  }

  export type UsageRecordCreateNestedManyWithoutWashingMachineInput = {
    create?: XOR<Enumerable<UsageRecordCreateWithoutWashingMachineInput>, Enumerable<UsageRecordUncheckedCreateWithoutWashingMachineInput>>
    connectOrCreate?: Enumerable<UsageRecordCreateOrConnectWithoutWashingMachineInput>
    createMany?: UsageRecordCreateManyWashingMachineInputEnvelope
    connect?: Enumerable<UsageRecordWhereUniqueInput>
  }

  export type WMMaintenanceRecordCreateNestedManyWithoutMaintainedWMInput = {
    create?: XOR<Enumerable<WMMaintenanceRecordCreateWithoutMaintainedWMInput>, Enumerable<WMMaintenanceRecordUncheckedCreateWithoutMaintainedWMInput>>
    connectOrCreate?: Enumerable<WMMaintenanceRecordCreateOrConnectWithoutMaintainedWMInput>
    createMany?: WMMaintenanceRecordCreateManyMaintainedWMInputEnvelope
    connect?: Enumerable<WMMaintenanceRecordWhereUniqueInput>
  }

  export type WMProgramUncheckedCreateNestedManyWithoutEquippingWMsInput = {
    create?: XOR<Enumerable<WMProgramCreateWithoutEquippingWMsInput>, Enumerable<WMProgramUncheckedCreateWithoutEquippingWMsInput>>
    connectOrCreate?: Enumerable<WMProgramCreateOrConnectWithoutEquippingWMsInput>
    connect?: Enumerable<WMProgramWhereUniqueInput>
  }

  export type UsageRecordUncheckedCreateNestedManyWithoutWashingMachineInput = {
    create?: XOR<Enumerable<UsageRecordCreateWithoutWashingMachineInput>, Enumerable<UsageRecordUncheckedCreateWithoutWashingMachineInput>>
    connectOrCreate?: Enumerable<UsageRecordCreateOrConnectWithoutWashingMachineInput>
    createMany?: UsageRecordCreateManyWashingMachineInputEnvelope
    connect?: Enumerable<UsageRecordWhereUniqueInput>
  }

  export type WMMaintenanceRecordUncheckedCreateNestedManyWithoutMaintainedWMInput = {
    create?: XOR<Enumerable<WMMaintenanceRecordCreateWithoutMaintainedWMInput>, Enumerable<WMMaintenanceRecordUncheckedCreateWithoutMaintainedWMInput>>
    connectOrCreate?: Enumerable<WMMaintenanceRecordCreateOrConnectWithoutMaintainedWMInput>
    createMany?: WMMaintenanceRecordCreateManyMaintainedWMInputEnvelope
    connect?: Enumerable<WMMaintenanceRecordWhereUniqueInput>
  }

  export type EnumWMTypeEnumFieldUpdateOperationsInput = {
    set?: WMTypeEnum
  }

  export type BranchUpdateOneRequiredWithoutWashingMachinesNestedInput = {
    create?: XOR<BranchCreateWithoutWashingMachinesInput, BranchUncheckedCreateWithoutWashingMachinesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutWashingMachinesInput
    upsert?: BranchUpsertWithoutWashingMachinesInput
    connect?: BranchWhereUniqueInput
    update?: XOR<BranchUpdateWithoutWashingMachinesInput, BranchUncheckedUpdateWithoutWashingMachinesInput>
  }

  export type WMProgramUpdateManyWithoutEquippingWMsNestedInput = {
    create?: XOR<Enumerable<WMProgramCreateWithoutEquippingWMsInput>, Enumerable<WMProgramUncheckedCreateWithoutEquippingWMsInput>>
    connectOrCreate?: Enumerable<WMProgramCreateOrConnectWithoutEquippingWMsInput>
    upsert?: Enumerable<WMProgramUpsertWithWhereUniqueWithoutEquippingWMsInput>
    set?: Enumerable<WMProgramWhereUniqueInput>
    disconnect?: Enumerable<WMProgramWhereUniqueInput>
    delete?: Enumerable<WMProgramWhereUniqueInput>
    connect?: Enumerable<WMProgramWhereUniqueInput>
    update?: Enumerable<WMProgramUpdateWithWhereUniqueWithoutEquippingWMsInput>
    updateMany?: Enumerable<WMProgramUpdateManyWithWhereWithoutEquippingWMsInput>
    deleteMany?: Enumerable<WMProgramScalarWhereInput>
  }

  export type UsageRecordUpdateManyWithoutWashingMachineNestedInput = {
    create?: XOR<Enumerable<UsageRecordCreateWithoutWashingMachineInput>, Enumerable<UsageRecordUncheckedCreateWithoutWashingMachineInput>>
    connectOrCreate?: Enumerable<UsageRecordCreateOrConnectWithoutWashingMachineInput>
    upsert?: Enumerable<UsageRecordUpsertWithWhereUniqueWithoutWashingMachineInput>
    createMany?: UsageRecordCreateManyWashingMachineInputEnvelope
    set?: Enumerable<UsageRecordWhereUniqueInput>
    disconnect?: Enumerable<UsageRecordWhereUniqueInput>
    delete?: Enumerable<UsageRecordWhereUniqueInput>
    connect?: Enumerable<UsageRecordWhereUniqueInput>
    update?: Enumerable<UsageRecordUpdateWithWhereUniqueWithoutWashingMachineInput>
    updateMany?: Enumerable<UsageRecordUpdateManyWithWhereWithoutWashingMachineInput>
    deleteMany?: Enumerable<UsageRecordScalarWhereInput>
  }

  export type WMMaintenanceRecordUpdateManyWithoutMaintainedWMNestedInput = {
    create?: XOR<Enumerable<WMMaintenanceRecordCreateWithoutMaintainedWMInput>, Enumerable<WMMaintenanceRecordUncheckedCreateWithoutMaintainedWMInput>>
    connectOrCreate?: Enumerable<WMMaintenanceRecordCreateOrConnectWithoutMaintainedWMInput>
    upsert?: Enumerable<WMMaintenanceRecordUpsertWithWhereUniqueWithoutMaintainedWMInput>
    createMany?: WMMaintenanceRecordCreateManyMaintainedWMInputEnvelope
    set?: Enumerable<WMMaintenanceRecordWhereUniqueInput>
    disconnect?: Enumerable<WMMaintenanceRecordWhereUniqueInput>
    delete?: Enumerable<WMMaintenanceRecordWhereUniqueInput>
    connect?: Enumerable<WMMaintenanceRecordWhereUniqueInput>
    update?: Enumerable<WMMaintenanceRecordUpdateWithWhereUniqueWithoutMaintainedWMInput>
    updateMany?: Enumerable<WMMaintenanceRecordUpdateManyWithWhereWithoutMaintainedWMInput>
    deleteMany?: Enumerable<WMMaintenanceRecordScalarWhereInput>
  }

  export type WMProgramUncheckedUpdateManyWithoutEquippingWMsNestedInput = {
    create?: XOR<Enumerable<WMProgramCreateWithoutEquippingWMsInput>, Enumerable<WMProgramUncheckedCreateWithoutEquippingWMsInput>>
    connectOrCreate?: Enumerable<WMProgramCreateOrConnectWithoutEquippingWMsInput>
    upsert?: Enumerable<WMProgramUpsertWithWhereUniqueWithoutEquippingWMsInput>
    set?: Enumerable<WMProgramWhereUniqueInput>
    disconnect?: Enumerable<WMProgramWhereUniqueInput>
    delete?: Enumerable<WMProgramWhereUniqueInput>
    connect?: Enumerable<WMProgramWhereUniqueInput>
    update?: Enumerable<WMProgramUpdateWithWhereUniqueWithoutEquippingWMsInput>
    updateMany?: Enumerable<WMProgramUpdateManyWithWhereWithoutEquippingWMsInput>
    deleteMany?: Enumerable<WMProgramScalarWhereInput>
  }

  export type UsageRecordUncheckedUpdateManyWithoutWashingMachineNestedInput = {
    create?: XOR<Enumerable<UsageRecordCreateWithoutWashingMachineInput>, Enumerable<UsageRecordUncheckedCreateWithoutWashingMachineInput>>
    connectOrCreate?: Enumerable<UsageRecordCreateOrConnectWithoutWashingMachineInput>
    upsert?: Enumerable<UsageRecordUpsertWithWhereUniqueWithoutWashingMachineInput>
    createMany?: UsageRecordCreateManyWashingMachineInputEnvelope
    set?: Enumerable<UsageRecordWhereUniqueInput>
    disconnect?: Enumerable<UsageRecordWhereUniqueInput>
    delete?: Enumerable<UsageRecordWhereUniqueInput>
    connect?: Enumerable<UsageRecordWhereUniqueInput>
    update?: Enumerable<UsageRecordUpdateWithWhereUniqueWithoutWashingMachineInput>
    updateMany?: Enumerable<UsageRecordUpdateManyWithWhereWithoutWashingMachineInput>
    deleteMany?: Enumerable<UsageRecordScalarWhereInput>
  }

  export type WMMaintenanceRecordUncheckedUpdateManyWithoutMaintainedWMNestedInput = {
    create?: XOR<Enumerable<WMMaintenanceRecordCreateWithoutMaintainedWMInput>, Enumerable<WMMaintenanceRecordUncheckedCreateWithoutMaintainedWMInput>>
    connectOrCreate?: Enumerable<WMMaintenanceRecordCreateOrConnectWithoutMaintainedWMInput>
    upsert?: Enumerable<WMMaintenanceRecordUpsertWithWhereUniqueWithoutMaintainedWMInput>
    createMany?: WMMaintenanceRecordCreateManyMaintainedWMInputEnvelope
    set?: Enumerable<WMMaintenanceRecordWhereUniqueInput>
    disconnect?: Enumerable<WMMaintenanceRecordWhereUniqueInput>
    delete?: Enumerable<WMMaintenanceRecordWhereUniqueInput>
    connect?: Enumerable<WMMaintenanceRecordWhereUniqueInput>
    update?: Enumerable<WMMaintenanceRecordUpdateWithWhereUniqueWithoutMaintainedWMInput>
    updateMany?: Enumerable<WMMaintenanceRecordUpdateManyWithWhereWithoutMaintainedWMInput>
    deleteMany?: Enumerable<WMMaintenanceRecordScalarWhereInput>
  }

  export type WashingMachineCreateNestedManyWithoutEquippedProgramsInput = {
    create?: XOR<Enumerable<WashingMachineCreateWithoutEquippedProgramsInput>, Enumerable<WashingMachineUncheckedCreateWithoutEquippedProgramsInput>>
    connectOrCreate?: Enumerable<WashingMachineCreateOrConnectWithoutEquippedProgramsInput>
    connect?: Enumerable<WashingMachineWhereUniqueInput>
  }

  export type UsageRecordCreateNestedManyWithoutProgramInput = {
    create?: XOR<Enumerable<UsageRecordCreateWithoutProgramInput>, Enumerable<UsageRecordUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<UsageRecordCreateOrConnectWithoutProgramInput>
    createMany?: UsageRecordCreateManyProgramInputEnvelope
    connect?: Enumerable<UsageRecordWhereUniqueInput>
  }

  export type WashingMachineUncheckedCreateNestedManyWithoutEquippedProgramsInput = {
    create?: XOR<Enumerable<WashingMachineCreateWithoutEquippedProgramsInput>, Enumerable<WashingMachineUncheckedCreateWithoutEquippedProgramsInput>>
    connectOrCreate?: Enumerable<WashingMachineCreateOrConnectWithoutEquippedProgramsInput>
    connect?: Enumerable<WashingMachineWhereUniqueInput>
  }

  export type UsageRecordUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<Enumerable<UsageRecordCreateWithoutProgramInput>, Enumerable<UsageRecordUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<UsageRecordCreateOrConnectWithoutProgramInput>
    createMany?: UsageRecordCreateManyProgramInputEnvelope
    connect?: Enumerable<UsageRecordWhereUniqueInput>
  }

  export type WashingMachineUpdateManyWithoutEquippedProgramsNestedInput = {
    create?: XOR<Enumerable<WashingMachineCreateWithoutEquippedProgramsInput>, Enumerable<WashingMachineUncheckedCreateWithoutEquippedProgramsInput>>
    connectOrCreate?: Enumerable<WashingMachineCreateOrConnectWithoutEquippedProgramsInput>
    upsert?: Enumerable<WashingMachineUpsertWithWhereUniqueWithoutEquippedProgramsInput>
    set?: Enumerable<WashingMachineWhereUniqueInput>
    disconnect?: Enumerable<WashingMachineWhereUniqueInput>
    delete?: Enumerable<WashingMachineWhereUniqueInput>
    connect?: Enumerable<WashingMachineWhereUniqueInput>
    update?: Enumerable<WashingMachineUpdateWithWhereUniqueWithoutEquippedProgramsInput>
    updateMany?: Enumerable<WashingMachineUpdateManyWithWhereWithoutEquippedProgramsInput>
    deleteMany?: Enumerable<WashingMachineScalarWhereInput>
  }

  export type UsageRecordUpdateManyWithoutProgramNestedInput = {
    create?: XOR<Enumerable<UsageRecordCreateWithoutProgramInput>, Enumerable<UsageRecordUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<UsageRecordCreateOrConnectWithoutProgramInput>
    upsert?: Enumerable<UsageRecordUpsertWithWhereUniqueWithoutProgramInput>
    createMany?: UsageRecordCreateManyProgramInputEnvelope
    set?: Enumerable<UsageRecordWhereUniqueInput>
    disconnect?: Enumerable<UsageRecordWhereUniqueInput>
    delete?: Enumerable<UsageRecordWhereUniqueInput>
    connect?: Enumerable<UsageRecordWhereUniqueInput>
    update?: Enumerable<UsageRecordUpdateWithWhereUniqueWithoutProgramInput>
    updateMany?: Enumerable<UsageRecordUpdateManyWithWhereWithoutProgramInput>
    deleteMany?: Enumerable<UsageRecordScalarWhereInput>
  }

  export type WashingMachineUncheckedUpdateManyWithoutEquippedProgramsNestedInput = {
    create?: XOR<Enumerable<WashingMachineCreateWithoutEquippedProgramsInput>, Enumerable<WashingMachineUncheckedCreateWithoutEquippedProgramsInput>>
    connectOrCreate?: Enumerable<WashingMachineCreateOrConnectWithoutEquippedProgramsInput>
    upsert?: Enumerable<WashingMachineUpsertWithWhereUniqueWithoutEquippedProgramsInput>
    set?: Enumerable<WashingMachineWhereUniqueInput>
    disconnect?: Enumerable<WashingMachineWhereUniqueInput>
    delete?: Enumerable<WashingMachineWhereUniqueInput>
    connect?: Enumerable<WashingMachineWhereUniqueInput>
    update?: Enumerable<WashingMachineUpdateWithWhereUniqueWithoutEquippedProgramsInput>
    updateMany?: Enumerable<WashingMachineUpdateManyWithWhereWithoutEquippedProgramsInput>
    deleteMany?: Enumerable<WashingMachineScalarWhereInput>
  }

  export type UsageRecordUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<Enumerable<UsageRecordCreateWithoutProgramInput>, Enumerable<UsageRecordUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<UsageRecordCreateOrConnectWithoutProgramInput>
    upsert?: Enumerable<UsageRecordUpsertWithWhereUniqueWithoutProgramInput>
    createMany?: UsageRecordCreateManyProgramInputEnvelope
    set?: Enumerable<UsageRecordWhereUniqueInput>
    disconnect?: Enumerable<UsageRecordWhereUniqueInput>
    delete?: Enumerable<UsageRecordWhereUniqueInput>
    connect?: Enumerable<UsageRecordWhereUniqueInput>
    update?: Enumerable<UsageRecordUpdateWithWhereUniqueWithoutProgramInput>
    updateMany?: Enumerable<UsageRecordUpdateManyWithWhereWithoutProgramInput>
    deleteMany?: Enumerable<UsageRecordScalarWhereInput>
  }

  export type WashingMachineCreateNestedOneWithoutWMMaintenanceRecordsInput = {
    create?: XOR<WashingMachineCreateWithoutWMMaintenanceRecordsInput, WashingMachineUncheckedCreateWithoutWMMaintenanceRecordsInput>
    connectOrCreate?: WashingMachineCreateOrConnectWithoutWMMaintenanceRecordsInput
    connect?: WashingMachineWhereUniqueInput
  }

  export type BinWashUserCreateNestedOneWithoutWMMaintenanceRecordsInput = {
    create?: XOR<BinWashUserCreateWithoutWMMaintenanceRecordsInput, BinWashUserUncheckedCreateWithoutWMMaintenanceRecordsInput>
    connectOrCreate?: BinWashUserCreateOrConnectWithoutWMMaintenanceRecordsInput
    connect?: BinWashUserWhereUniqueInput
  }

  export type WashingMachineUpdateOneRequiredWithoutWMMaintenanceRecordsNestedInput = {
    create?: XOR<WashingMachineCreateWithoutWMMaintenanceRecordsInput, WashingMachineUncheckedCreateWithoutWMMaintenanceRecordsInput>
    connectOrCreate?: WashingMachineCreateOrConnectWithoutWMMaintenanceRecordsInput
    upsert?: WashingMachineUpsertWithoutWMMaintenanceRecordsInput
    connect?: WashingMachineWhereUniqueInput
    update?: XOR<WashingMachineUpdateWithoutWMMaintenanceRecordsInput, WashingMachineUncheckedUpdateWithoutWMMaintenanceRecordsInput>
  }

  export type BinWashUserUpdateOneRequiredWithoutWMMaintenanceRecordsNestedInput = {
    create?: XOR<BinWashUserCreateWithoutWMMaintenanceRecordsInput, BinWashUserUncheckedCreateWithoutWMMaintenanceRecordsInput>
    connectOrCreate?: BinWashUserCreateOrConnectWithoutWMMaintenanceRecordsInput
    upsert?: BinWashUserUpsertWithoutWMMaintenanceRecordsInput
    connect?: BinWashUserWhereUniqueInput
    update?: XOR<BinWashUserUpdateWithoutWMMaintenanceRecordsInput, BinWashUserUncheckedUpdateWithoutWMMaintenanceRecordsInput>
  }

  export type BinWashUserCreateNestedOneWithoutUsageRecordsInput = {
    create?: XOR<BinWashUserCreateWithoutUsageRecordsInput, BinWashUserUncheckedCreateWithoutUsageRecordsInput>
    connectOrCreate?: BinWashUserCreateOrConnectWithoutUsageRecordsInput
    connect?: BinWashUserWhereUniqueInput
  }

  export type WashingMachineCreateNestedOneWithoutUsageRecordsInput = {
    create?: XOR<WashingMachineCreateWithoutUsageRecordsInput, WashingMachineUncheckedCreateWithoutUsageRecordsInput>
    connectOrCreate?: WashingMachineCreateOrConnectWithoutUsageRecordsInput
    connect?: WashingMachineWhereUniqueInput
  }

  export type WMProgramCreateNestedOneWithoutUsageRecordsInput = {
    create?: XOR<WMProgramCreateWithoutUsageRecordsInput, WMProgramUncheckedCreateWithoutUsageRecordsInput>
    connectOrCreate?: WMProgramCreateOrConnectWithoutUsageRecordsInput
    connect?: WMProgramWhereUniqueInput
  }

  export type BinWashUserUpdateOneRequiredWithoutUsageRecordsNestedInput = {
    create?: XOR<BinWashUserCreateWithoutUsageRecordsInput, BinWashUserUncheckedCreateWithoutUsageRecordsInput>
    connectOrCreate?: BinWashUserCreateOrConnectWithoutUsageRecordsInput
    upsert?: BinWashUserUpsertWithoutUsageRecordsInput
    connect?: BinWashUserWhereUniqueInput
    update?: XOR<BinWashUserUpdateWithoutUsageRecordsInput, BinWashUserUncheckedUpdateWithoutUsageRecordsInput>
  }

  export type WashingMachineUpdateOneRequiredWithoutUsageRecordsNestedInput = {
    create?: XOR<WashingMachineCreateWithoutUsageRecordsInput, WashingMachineUncheckedCreateWithoutUsageRecordsInput>
    connectOrCreate?: WashingMachineCreateOrConnectWithoutUsageRecordsInput
    upsert?: WashingMachineUpsertWithoutUsageRecordsInput
    connect?: WashingMachineWhereUniqueInput
    update?: XOR<WashingMachineUpdateWithoutUsageRecordsInput, WashingMachineUncheckedUpdateWithoutUsageRecordsInput>
  }

  export type WMProgramUpdateOneRequiredWithoutUsageRecordsNestedInput = {
    create?: XOR<WMProgramCreateWithoutUsageRecordsInput, WMProgramUncheckedCreateWithoutUsageRecordsInput>
    connectOrCreate?: WMProgramCreateOrConnectWithoutUsageRecordsInput
    upsert?: WMProgramUpsertWithoutUsageRecordsInput
    connect?: WMProgramWhereUniqueInput
    update?: XOR<WMProgramUpdateWithoutUsageRecordsInput, WMProgramUncheckedUpdateWithoutUsageRecordsInput>
  }

  export type BinWashUserCreateNestedOneWithoutTopUpRecordsInput = {
    create?: XOR<BinWashUserCreateWithoutTopUpRecordsInput, BinWashUserUncheckedCreateWithoutTopUpRecordsInput>
    connectOrCreate?: BinWashUserCreateOrConnectWithoutTopUpRecordsInput
    connect?: BinWashUserWhereUniqueInput
  }

  export type BinWashUserUpdateOneRequiredWithoutTopUpRecordsNestedInput = {
    create?: XOR<BinWashUserCreateWithoutTopUpRecordsInput, BinWashUserUncheckedCreateWithoutTopUpRecordsInput>
    connectOrCreate?: BinWashUserCreateOrConnectWithoutTopUpRecordsInput
    upsert?: BinWashUserUpsertWithoutTopUpRecordsInput
    connect?: BinWashUserWhereUniqueInput
    update?: XOR<BinWashUserUpdateWithoutTopUpRecordsInput, BinWashUserUncheckedUpdateWithoutTopUpRecordsInput>
  }

  export type FacebookUserRelationCreateNestedManyWithoutFollowingUserInput = {
    create?: XOR<Enumerable<FacebookUserRelationCreateWithoutFollowingUserInput>, Enumerable<FacebookUserRelationUncheckedCreateWithoutFollowingUserInput>>
    connectOrCreate?: Enumerable<FacebookUserRelationCreateOrConnectWithoutFollowingUserInput>
    createMany?: FacebookUserRelationCreateManyFollowingUserInputEnvelope
    connect?: Enumerable<FacebookUserRelationWhereUniqueInput>
  }

  export type FacebookUserRelationCreateNestedManyWithoutFollowedUserInput = {
    create?: XOR<Enumerable<FacebookUserRelationCreateWithoutFollowedUserInput>, Enumerable<FacebookUserRelationUncheckedCreateWithoutFollowedUserInput>>
    connectOrCreate?: Enumerable<FacebookUserRelationCreateOrConnectWithoutFollowedUserInput>
    createMany?: FacebookUserRelationCreateManyFollowedUserInputEnvelope
    connect?: Enumerable<FacebookUserRelationWhereUniqueInput>
  }

  export type PostCreateNestedManyWithoutPostingUserInput = {
    create?: XOR<Enumerable<PostCreateWithoutPostingUserInput>, Enumerable<PostUncheckedCreateWithoutPostingUserInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutPostingUserInput>
    createMany?: PostCreateManyPostingUserInputEnvelope
    connect?: Enumerable<PostWhereUniqueInput>
  }

  export type CommentCreateNestedManyWithoutCommentingUserInput = {
    create?: XOR<Enumerable<CommentCreateWithoutCommentingUserInput>, Enumerable<CommentUncheckedCreateWithoutCommentingUserInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutCommentingUserInput>
    createMany?: CommentCreateManyCommentingUserInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type MessengerMessageCreateNestedManyWithoutFromUserInput = {
    create?: XOR<Enumerable<MessengerMessageCreateWithoutFromUserInput>, Enumerable<MessengerMessageUncheckedCreateWithoutFromUserInput>>
    connectOrCreate?: Enumerable<MessengerMessageCreateOrConnectWithoutFromUserInput>
    createMany?: MessengerMessageCreateManyFromUserInputEnvelope
    connect?: Enumerable<MessengerMessageWhereUniqueInput>
  }

  export type MessengerMessageCreateNestedManyWithoutToUserInput = {
    create?: XOR<Enumerable<MessengerMessageCreateWithoutToUserInput>, Enumerable<MessengerMessageUncheckedCreateWithoutToUserInput>>
    connectOrCreate?: Enumerable<MessengerMessageCreateOrConnectWithoutToUserInput>
    createMany?: MessengerMessageCreateManyToUserInputEnvelope
    connect?: Enumerable<MessengerMessageWhereUniqueInput>
  }

  export type FacebookUserRelationUncheckedCreateNestedManyWithoutFollowingUserInput = {
    create?: XOR<Enumerable<FacebookUserRelationCreateWithoutFollowingUserInput>, Enumerable<FacebookUserRelationUncheckedCreateWithoutFollowingUserInput>>
    connectOrCreate?: Enumerable<FacebookUserRelationCreateOrConnectWithoutFollowingUserInput>
    createMany?: FacebookUserRelationCreateManyFollowingUserInputEnvelope
    connect?: Enumerable<FacebookUserRelationWhereUniqueInput>
  }

  export type FacebookUserRelationUncheckedCreateNestedManyWithoutFollowedUserInput = {
    create?: XOR<Enumerable<FacebookUserRelationCreateWithoutFollowedUserInput>, Enumerable<FacebookUserRelationUncheckedCreateWithoutFollowedUserInput>>
    connectOrCreate?: Enumerable<FacebookUserRelationCreateOrConnectWithoutFollowedUserInput>
    createMany?: FacebookUserRelationCreateManyFollowedUserInputEnvelope
    connect?: Enumerable<FacebookUserRelationWhereUniqueInput>
  }

  export type PostUncheckedCreateNestedManyWithoutPostingUserInput = {
    create?: XOR<Enumerable<PostCreateWithoutPostingUserInput>, Enumerable<PostUncheckedCreateWithoutPostingUserInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutPostingUserInput>
    createMany?: PostCreateManyPostingUserInputEnvelope
    connect?: Enumerable<PostWhereUniqueInput>
  }

  export type CommentUncheckedCreateNestedManyWithoutCommentingUserInput = {
    create?: XOR<Enumerable<CommentCreateWithoutCommentingUserInput>, Enumerable<CommentUncheckedCreateWithoutCommentingUserInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutCommentingUserInput>
    createMany?: CommentCreateManyCommentingUserInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type MessengerMessageUncheckedCreateNestedManyWithoutFromUserInput = {
    create?: XOR<Enumerable<MessengerMessageCreateWithoutFromUserInput>, Enumerable<MessengerMessageUncheckedCreateWithoutFromUserInput>>
    connectOrCreate?: Enumerable<MessengerMessageCreateOrConnectWithoutFromUserInput>
    createMany?: MessengerMessageCreateManyFromUserInputEnvelope
    connect?: Enumerable<MessengerMessageWhereUniqueInput>
  }

  export type MessengerMessageUncheckedCreateNestedManyWithoutToUserInput = {
    create?: XOR<Enumerable<MessengerMessageCreateWithoutToUserInput>, Enumerable<MessengerMessageUncheckedCreateWithoutToUserInput>>
    connectOrCreate?: Enumerable<MessengerMessageCreateOrConnectWithoutToUserInput>
    createMany?: MessengerMessageCreateManyToUserInputEnvelope
    connect?: Enumerable<MessengerMessageWhereUniqueInput>
  }

  export type FacebookUserRelationUpdateManyWithoutFollowingUserNestedInput = {
    create?: XOR<Enumerable<FacebookUserRelationCreateWithoutFollowingUserInput>, Enumerable<FacebookUserRelationUncheckedCreateWithoutFollowingUserInput>>
    connectOrCreate?: Enumerable<FacebookUserRelationCreateOrConnectWithoutFollowingUserInput>
    upsert?: Enumerable<FacebookUserRelationUpsertWithWhereUniqueWithoutFollowingUserInput>
    createMany?: FacebookUserRelationCreateManyFollowingUserInputEnvelope
    set?: Enumerable<FacebookUserRelationWhereUniqueInput>
    disconnect?: Enumerable<FacebookUserRelationWhereUniqueInput>
    delete?: Enumerable<FacebookUserRelationWhereUniqueInput>
    connect?: Enumerable<FacebookUserRelationWhereUniqueInput>
    update?: Enumerable<FacebookUserRelationUpdateWithWhereUniqueWithoutFollowingUserInput>
    updateMany?: Enumerable<FacebookUserRelationUpdateManyWithWhereWithoutFollowingUserInput>
    deleteMany?: Enumerable<FacebookUserRelationScalarWhereInput>
  }

  export type FacebookUserRelationUpdateManyWithoutFollowedUserNestedInput = {
    create?: XOR<Enumerable<FacebookUserRelationCreateWithoutFollowedUserInput>, Enumerable<FacebookUserRelationUncheckedCreateWithoutFollowedUserInput>>
    connectOrCreate?: Enumerable<FacebookUserRelationCreateOrConnectWithoutFollowedUserInput>
    upsert?: Enumerable<FacebookUserRelationUpsertWithWhereUniqueWithoutFollowedUserInput>
    createMany?: FacebookUserRelationCreateManyFollowedUserInputEnvelope
    set?: Enumerable<FacebookUserRelationWhereUniqueInput>
    disconnect?: Enumerable<FacebookUserRelationWhereUniqueInput>
    delete?: Enumerable<FacebookUserRelationWhereUniqueInput>
    connect?: Enumerable<FacebookUserRelationWhereUniqueInput>
    update?: Enumerable<FacebookUserRelationUpdateWithWhereUniqueWithoutFollowedUserInput>
    updateMany?: Enumerable<FacebookUserRelationUpdateManyWithWhereWithoutFollowedUserInput>
    deleteMany?: Enumerable<FacebookUserRelationScalarWhereInput>
  }

  export type PostUpdateManyWithoutPostingUserNestedInput = {
    create?: XOR<Enumerable<PostCreateWithoutPostingUserInput>, Enumerable<PostUncheckedCreateWithoutPostingUserInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutPostingUserInput>
    upsert?: Enumerable<PostUpsertWithWhereUniqueWithoutPostingUserInput>
    createMany?: PostCreateManyPostingUserInputEnvelope
    set?: Enumerable<PostWhereUniqueInput>
    disconnect?: Enumerable<PostWhereUniqueInput>
    delete?: Enumerable<PostWhereUniqueInput>
    connect?: Enumerable<PostWhereUniqueInput>
    update?: Enumerable<PostUpdateWithWhereUniqueWithoutPostingUserInput>
    updateMany?: Enumerable<PostUpdateManyWithWhereWithoutPostingUserInput>
    deleteMany?: Enumerable<PostScalarWhereInput>
  }

  export type CommentUpdateManyWithoutCommentingUserNestedInput = {
    create?: XOR<Enumerable<CommentCreateWithoutCommentingUserInput>, Enumerable<CommentUncheckedCreateWithoutCommentingUserInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutCommentingUserInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutCommentingUserInput>
    createMany?: CommentCreateManyCommentingUserInputEnvelope
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    connect?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutCommentingUserInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutCommentingUserInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type MessengerMessageUpdateManyWithoutFromUserNestedInput = {
    create?: XOR<Enumerable<MessengerMessageCreateWithoutFromUserInput>, Enumerable<MessengerMessageUncheckedCreateWithoutFromUserInput>>
    connectOrCreate?: Enumerable<MessengerMessageCreateOrConnectWithoutFromUserInput>
    upsert?: Enumerable<MessengerMessageUpsertWithWhereUniqueWithoutFromUserInput>
    createMany?: MessengerMessageCreateManyFromUserInputEnvelope
    set?: Enumerable<MessengerMessageWhereUniqueInput>
    disconnect?: Enumerable<MessengerMessageWhereUniqueInput>
    delete?: Enumerable<MessengerMessageWhereUniqueInput>
    connect?: Enumerable<MessengerMessageWhereUniqueInput>
    update?: Enumerable<MessengerMessageUpdateWithWhereUniqueWithoutFromUserInput>
    updateMany?: Enumerable<MessengerMessageUpdateManyWithWhereWithoutFromUserInput>
    deleteMany?: Enumerable<MessengerMessageScalarWhereInput>
  }

  export type MessengerMessageUpdateManyWithoutToUserNestedInput = {
    create?: XOR<Enumerable<MessengerMessageCreateWithoutToUserInput>, Enumerable<MessengerMessageUncheckedCreateWithoutToUserInput>>
    connectOrCreate?: Enumerable<MessengerMessageCreateOrConnectWithoutToUserInput>
    upsert?: Enumerable<MessengerMessageUpsertWithWhereUniqueWithoutToUserInput>
    createMany?: MessengerMessageCreateManyToUserInputEnvelope
    set?: Enumerable<MessengerMessageWhereUniqueInput>
    disconnect?: Enumerable<MessengerMessageWhereUniqueInput>
    delete?: Enumerable<MessengerMessageWhereUniqueInput>
    connect?: Enumerable<MessengerMessageWhereUniqueInput>
    update?: Enumerable<MessengerMessageUpdateWithWhereUniqueWithoutToUserInput>
    updateMany?: Enumerable<MessengerMessageUpdateManyWithWhereWithoutToUserInput>
    deleteMany?: Enumerable<MessengerMessageScalarWhereInput>
  }

  export type FacebookUserRelationUncheckedUpdateManyWithoutFollowingUserNestedInput = {
    create?: XOR<Enumerable<FacebookUserRelationCreateWithoutFollowingUserInput>, Enumerable<FacebookUserRelationUncheckedCreateWithoutFollowingUserInput>>
    connectOrCreate?: Enumerable<FacebookUserRelationCreateOrConnectWithoutFollowingUserInput>
    upsert?: Enumerable<FacebookUserRelationUpsertWithWhereUniqueWithoutFollowingUserInput>
    createMany?: FacebookUserRelationCreateManyFollowingUserInputEnvelope
    set?: Enumerable<FacebookUserRelationWhereUniqueInput>
    disconnect?: Enumerable<FacebookUserRelationWhereUniqueInput>
    delete?: Enumerable<FacebookUserRelationWhereUniqueInput>
    connect?: Enumerable<FacebookUserRelationWhereUniqueInput>
    update?: Enumerable<FacebookUserRelationUpdateWithWhereUniqueWithoutFollowingUserInput>
    updateMany?: Enumerable<FacebookUserRelationUpdateManyWithWhereWithoutFollowingUserInput>
    deleteMany?: Enumerable<FacebookUserRelationScalarWhereInput>
  }

  export type FacebookUserRelationUncheckedUpdateManyWithoutFollowedUserNestedInput = {
    create?: XOR<Enumerable<FacebookUserRelationCreateWithoutFollowedUserInput>, Enumerable<FacebookUserRelationUncheckedCreateWithoutFollowedUserInput>>
    connectOrCreate?: Enumerable<FacebookUserRelationCreateOrConnectWithoutFollowedUserInput>
    upsert?: Enumerable<FacebookUserRelationUpsertWithWhereUniqueWithoutFollowedUserInput>
    createMany?: FacebookUserRelationCreateManyFollowedUserInputEnvelope
    set?: Enumerable<FacebookUserRelationWhereUniqueInput>
    disconnect?: Enumerable<FacebookUserRelationWhereUniqueInput>
    delete?: Enumerable<FacebookUserRelationWhereUniqueInput>
    connect?: Enumerable<FacebookUserRelationWhereUniqueInput>
    update?: Enumerable<FacebookUserRelationUpdateWithWhereUniqueWithoutFollowedUserInput>
    updateMany?: Enumerable<FacebookUserRelationUpdateManyWithWhereWithoutFollowedUserInput>
    deleteMany?: Enumerable<FacebookUserRelationScalarWhereInput>
  }

  export type PostUncheckedUpdateManyWithoutPostingUserNestedInput = {
    create?: XOR<Enumerable<PostCreateWithoutPostingUserInput>, Enumerable<PostUncheckedCreateWithoutPostingUserInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutPostingUserInput>
    upsert?: Enumerable<PostUpsertWithWhereUniqueWithoutPostingUserInput>
    createMany?: PostCreateManyPostingUserInputEnvelope
    set?: Enumerable<PostWhereUniqueInput>
    disconnect?: Enumerable<PostWhereUniqueInput>
    delete?: Enumerable<PostWhereUniqueInput>
    connect?: Enumerable<PostWhereUniqueInput>
    update?: Enumerable<PostUpdateWithWhereUniqueWithoutPostingUserInput>
    updateMany?: Enumerable<PostUpdateManyWithWhereWithoutPostingUserInput>
    deleteMany?: Enumerable<PostScalarWhereInput>
  }

  export type CommentUncheckedUpdateManyWithoutCommentingUserNestedInput = {
    create?: XOR<Enumerable<CommentCreateWithoutCommentingUserInput>, Enumerable<CommentUncheckedCreateWithoutCommentingUserInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutCommentingUserInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutCommentingUserInput>
    createMany?: CommentCreateManyCommentingUserInputEnvelope
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    connect?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutCommentingUserInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutCommentingUserInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type MessengerMessageUncheckedUpdateManyWithoutFromUserNestedInput = {
    create?: XOR<Enumerable<MessengerMessageCreateWithoutFromUserInput>, Enumerable<MessengerMessageUncheckedCreateWithoutFromUserInput>>
    connectOrCreate?: Enumerable<MessengerMessageCreateOrConnectWithoutFromUserInput>
    upsert?: Enumerable<MessengerMessageUpsertWithWhereUniqueWithoutFromUserInput>
    createMany?: MessengerMessageCreateManyFromUserInputEnvelope
    set?: Enumerable<MessengerMessageWhereUniqueInput>
    disconnect?: Enumerable<MessengerMessageWhereUniqueInput>
    delete?: Enumerable<MessengerMessageWhereUniqueInput>
    connect?: Enumerable<MessengerMessageWhereUniqueInput>
    update?: Enumerable<MessengerMessageUpdateWithWhereUniqueWithoutFromUserInput>
    updateMany?: Enumerable<MessengerMessageUpdateManyWithWhereWithoutFromUserInput>
    deleteMany?: Enumerable<MessengerMessageScalarWhereInput>
  }

  export type MessengerMessageUncheckedUpdateManyWithoutToUserNestedInput = {
    create?: XOR<Enumerable<MessengerMessageCreateWithoutToUserInput>, Enumerable<MessengerMessageUncheckedCreateWithoutToUserInput>>
    connectOrCreate?: Enumerable<MessengerMessageCreateOrConnectWithoutToUserInput>
    upsert?: Enumerable<MessengerMessageUpsertWithWhereUniqueWithoutToUserInput>
    createMany?: MessengerMessageCreateManyToUserInputEnvelope
    set?: Enumerable<MessengerMessageWhereUniqueInput>
    disconnect?: Enumerable<MessengerMessageWhereUniqueInput>
    delete?: Enumerable<MessengerMessageWhereUniqueInput>
    connect?: Enumerable<MessengerMessageWhereUniqueInput>
    update?: Enumerable<MessengerMessageUpdateWithWhereUniqueWithoutToUserInput>
    updateMany?: Enumerable<MessengerMessageUpdateManyWithWhereWithoutToUserInput>
    deleteMany?: Enumerable<MessengerMessageScalarWhereInput>
  }

  export type FacebookUserCreateNestedOneWithoutFollowingUserRelationsInput = {
    create?: XOR<FacebookUserCreateWithoutFollowingUserRelationsInput, FacebookUserUncheckedCreateWithoutFollowingUserRelationsInput>
    connectOrCreate?: FacebookUserCreateOrConnectWithoutFollowingUserRelationsInput
    connect?: FacebookUserWhereUniqueInput
  }

  export type FacebookUserCreateNestedOneWithoutFollowedUserRelationsInput = {
    create?: XOR<FacebookUserCreateWithoutFollowedUserRelationsInput, FacebookUserUncheckedCreateWithoutFollowedUserRelationsInput>
    connectOrCreate?: FacebookUserCreateOrConnectWithoutFollowedUserRelationsInput
    connect?: FacebookUserWhereUniqueInput
  }

  export type FacebookUserUpdateOneRequiredWithoutFollowingUserRelationsNestedInput = {
    create?: XOR<FacebookUserCreateWithoutFollowingUserRelationsInput, FacebookUserUncheckedCreateWithoutFollowingUserRelationsInput>
    connectOrCreate?: FacebookUserCreateOrConnectWithoutFollowingUserRelationsInput
    upsert?: FacebookUserUpsertWithoutFollowingUserRelationsInput
    connect?: FacebookUserWhereUniqueInput
    update?: XOR<FacebookUserUpdateWithoutFollowingUserRelationsInput, FacebookUserUncheckedUpdateWithoutFollowingUserRelationsInput>
  }

  export type FacebookUserUpdateOneRequiredWithoutFollowedUserRelationsNestedInput = {
    create?: XOR<FacebookUserCreateWithoutFollowedUserRelationsInput, FacebookUserUncheckedCreateWithoutFollowedUserRelationsInput>
    connectOrCreate?: FacebookUserCreateOrConnectWithoutFollowedUserRelationsInput
    upsert?: FacebookUserUpsertWithoutFollowedUserRelationsInput
    connect?: FacebookUserWhereUniqueInput
    update?: XOR<FacebookUserUpdateWithoutFollowedUserRelationsInput, FacebookUserUncheckedUpdateWithoutFollowedUserRelationsInput>
  }

  export type FacebookUserCreateNestedOneWithoutPostsInput = {
    create?: XOR<FacebookUserCreateWithoutPostsInput, FacebookUserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: FacebookUserCreateOrConnectWithoutPostsInput
    connect?: FacebookUserWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutParentPostInput = {
    create?: XOR<Enumerable<CommentCreateWithoutParentPostInput>, Enumerable<CommentUncheckedCreateWithoutParentPostInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutParentPostInput>
    createMany?: CommentCreateManyParentPostInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type FacebookHashTagCreateNestedManyWithoutIsInPostsInput = {
    create?: XOR<Enumerable<FacebookHashTagCreateWithoutIsInPostsInput>, Enumerable<FacebookHashTagUncheckedCreateWithoutIsInPostsInput>>
    connectOrCreate?: Enumerable<FacebookHashTagCreateOrConnectWithoutIsInPostsInput>
    connect?: Enumerable<FacebookHashTagWhereUniqueInput>
  }

  export type CommentUncheckedCreateNestedManyWithoutParentPostInput = {
    create?: XOR<Enumerable<CommentCreateWithoutParentPostInput>, Enumerable<CommentUncheckedCreateWithoutParentPostInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutParentPostInput>
    createMany?: CommentCreateManyParentPostInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type FacebookHashTagUncheckedCreateNestedManyWithoutIsInPostsInput = {
    create?: XOR<Enumerable<FacebookHashTagCreateWithoutIsInPostsInput>, Enumerable<FacebookHashTagUncheckedCreateWithoutIsInPostsInput>>
    connectOrCreate?: Enumerable<FacebookHashTagCreateOrConnectWithoutIsInPostsInput>
    connect?: Enumerable<FacebookHashTagWhereUniqueInput>
  }

  export type FacebookUserUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<FacebookUserCreateWithoutPostsInput, FacebookUserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: FacebookUserCreateOrConnectWithoutPostsInput
    upsert?: FacebookUserUpsertWithoutPostsInput
    connect?: FacebookUserWhereUniqueInput
    update?: XOR<FacebookUserUpdateWithoutPostsInput, FacebookUserUncheckedUpdateWithoutPostsInput>
  }

  export type CommentUpdateManyWithoutParentPostNestedInput = {
    create?: XOR<Enumerable<CommentCreateWithoutParentPostInput>, Enumerable<CommentUncheckedCreateWithoutParentPostInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutParentPostInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutParentPostInput>
    createMany?: CommentCreateManyParentPostInputEnvelope
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    connect?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutParentPostInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutParentPostInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type FacebookHashTagUpdateManyWithoutIsInPostsNestedInput = {
    create?: XOR<Enumerable<FacebookHashTagCreateWithoutIsInPostsInput>, Enumerable<FacebookHashTagUncheckedCreateWithoutIsInPostsInput>>
    connectOrCreate?: Enumerable<FacebookHashTagCreateOrConnectWithoutIsInPostsInput>
    upsert?: Enumerable<FacebookHashTagUpsertWithWhereUniqueWithoutIsInPostsInput>
    set?: Enumerable<FacebookHashTagWhereUniqueInput>
    disconnect?: Enumerable<FacebookHashTagWhereUniqueInput>
    delete?: Enumerable<FacebookHashTagWhereUniqueInput>
    connect?: Enumerable<FacebookHashTagWhereUniqueInput>
    update?: Enumerable<FacebookHashTagUpdateWithWhereUniqueWithoutIsInPostsInput>
    updateMany?: Enumerable<FacebookHashTagUpdateManyWithWhereWithoutIsInPostsInput>
    deleteMany?: Enumerable<FacebookHashTagScalarWhereInput>
  }

  export type CommentUncheckedUpdateManyWithoutParentPostNestedInput = {
    create?: XOR<Enumerable<CommentCreateWithoutParentPostInput>, Enumerable<CommentUncheckedCreateWithoutParentPostInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutParentPostInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutParentPostInput>
    createMany?: CommentCreateManyParentPostInputEnvelope
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    connect?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutParentPostInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutParentPostInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type FacebookHashTagUncheckedUpdateManyWithoutIsInPostsNestedInput = {
    create?: XOR<Enumerable<FacebookHashTagCreateWithoutIsInPostsInput>, Enumerable<FacebookHashTagUncheckedCreateWithoutIsInPostsInput>>
    connectOrCreate?: Enumerable<FacebookHashTagCreateOrConnectWithoutIsInPostsInput>
    upsert?: Enumerable<FacebookHashTagUpsertWithWhereUniqueWithoutIsInPostsInput>
    set?: Enumerable<FacebookHashTagWhereUniqueInput>
    disconnect?: Enumerable<FacebookHashTagWhereUniqueInput>
    delete?: Enumerable<FacebookHashTagWhereUniqueInput>
    connect?: Enumerable<FacebookHashTagWhereUniqueInput>
    update?: Enumerable<FacebookHashTagUpdateWithWhereUniqueWithoutIsInPostsInput>
    updateMany?: Enumerable<FacebookHashTagUpdateManyWithWhereWithoutIsInPostsInput>
    deleteMany?: Enumerable<FacebookHashTagScalarWhereInput>
  }

  export type FacebookUserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<FacebookUserCreateWithoutCommentsInput, FacebookUserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: FacebookUserCreateOrConnectWithoutCommentsInput
    connect?: FacebookUserWhereUniqueInput
  }

  export type PostCreateNestedOneWithoutCommentsInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    connect?: PostWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutChildCommentsInput = {
    create?: XOR<CommentCreateWithoutChildCommentsInput, CommentUncheckedCreateWithoutChildCommentsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutChildCommentsInput
    connect?: CommentWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutParentCommentInput = {
    create?: XOR<Enumerable<CommentCreateWithoutParentCommentInput>, Enumerable<CommentUncheckedCreateWithoutParentCommentInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutParentCommentInput>
    createMany?: CommentCreateManyParentCommentInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type CommentUncheckedCreateNestedManyWithoutParentCommentInput = {
    create?: XOR<Enumerable<CommentCreateWithoutParentCommentInput>, Enumerable<CommentUncheckedCreateWithoutParentCommentInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutParentCommentInput>
    createMany?: CommentCreateManyParentCommentInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type FacebookUserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<FacebookUserCreateWithoutCommentsInput, FacebookUserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: FacebookUserCreateOrConnectWithoutCommentsInput
    upsert?: FacebookUserUpsertWithoutCommentsInput
    connect?: FacebookUserWhereUniqueInput
    update?: XOR<FacebookUserUpdateWithoutCommentsInput, FacebookUserUncheckedUpdateWithoutCommentsInput>
  }

  export type PostUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    upsert?: PostUpsertWithoutCommentsInput
    connect?: PostWhereUniqueInput
    update?: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
  }

  export type CommentUpdateOneWithoutChildCommentsNestedInput = {
    create?: XOR<CommentCreateWithoutChildCommentsInput, CommentUncheckedCreateWithoutChildCommentsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutChildCommentsInput
    upsert?: CommentUpsertWithoutChildCommentsInput
    disconnect?: boolean
    delete?: boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<CommentUpdateWithoutChildCommentsInput, CommentUncheckedUpdateWithoutChildCommentsInput>
  }

  export type CommentUpdateManyWithoutParentCommentNestedInput = {
    create?: XOR<Enumerable<CommentCreateWithoutParentCommentInput>, Enumerable<CommentUncheckedCreateWithoutParentCommentInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutParentCommentInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutParentCommentInput>
    createMany?: CommentCreateManyParentCommentInputEnvelope
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    connect?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutParentCommentInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutParentCommentInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type CommentUncheckedUpdateManyWithoutParentCommentNestedInput = {
    create?: XOR<Enumerable<CommentCreateWithoutParentCommentInput>, Enumerable<CommentUncheckedCreateWithoutParentCommentInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutParentCommentInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutParentCommentInput>
    createMany?: CommentCreateManyParentCommentInputEnvelope
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    connect?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutParentCommentInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutParentCommentInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type PostCreateNestedManyWithoutHashTagsInput = {
    create?: XOR<Enumerable<PostCreateWithoutHashTagsInput>, Enumerable<PostUncheckedCreateWithoutHashTagsInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutHashTagsInput>
    connect?: Enumerable<PostWhereUniqueInput>
  }

  export type PostUncheckedCreateNestedManyWithoutHashTagsInput = {
    create?: XOR<Enumerable<PostCreateWithoutHashTagsInput>, Enumerable<PostUncheckedCreateWithoutHashTagsInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutHashTagsInput>
    connect?: Enumerable<PostWhereUniqueInput>
  }

  export type PostUpdateManyWithoutHashTagsNestedInput = {
    create?: XOR<Enumerable<PostCreateWithoutHashTagsInput>, Enumerable<PostUncheckedCreateWithoutHashTagsInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutHashTagsInput>
    upsert?: Enumerable<PostUpsertWithWhereUniqueWithoutHashTagsInput>
    set?: Enumerable<PostWhereUniqueInput>
    disconnect?: Enumerable<PostWhereUniqueInput>
    delete?: Enumerable<PostWhereUniqueInput>
    connect?: Enumerable<PostWhereUniqueInput>
    update?: Enumerable<PostUpdateWithWhereUniqueWithoutHashTagsInput>
    updateMany?: Enumerable<PostUpdateManyWithWhereWithoutHashTagsInput>
    deleteMany?: Enumerable<PostScalarWhereInput>
  }

  export type PostUncheckedUpdateManyWithoutHashTagsNestedInput = {
    create?: XOR<Enumerable<PostCreateWithoutHashTagsInput>, Enumerable<PostUncheckedCreateWithoutHashTagsInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutHashTagsInput>
    upsert?: Enumerable<PostUpsertWithWhereUniqueWithoutHashTagsInput>
    set?: Enumerable<PostWhereUniqueInput>
    disconnect?: Enumerable<PostWhereUniqueInput>
    delete?: Enumerable<PostWhereUniqueInput>
    connect?: Enumerable<PostWhereUniqueInput>
    update?: Enumerable<PostUpdateWithWhereUniqueWithoutHashTagsInput>
    updateMany?: Enumerable<PostUpdateManyWithWhereWithoutHashTagsInput>
    deleteMany?: Enumerable<PostScalarWhereInput>
  }

  export type FacebookUserCreateNestedOneWithoutMessengerMessagesFromInput = {
    create?: XOR<FacebookUserCreateWithoutMessengerMessagesFromInput, FacebookUserUncheckedCreateWithoutMessengerMessagesFromInput>
    connectOrCreate?: FacebookUserCreateOrConnectWithoutMessengerMessagesFromInput
    connect?: FacebookUserWhereUniqueInput
  }

  export type FacebookUserCreateNestedOneWithoutMessengerMessagesToInput = {
    create?: XOR<FacebookUserCreateWithoutMessengerMessagesToInput, FacebookUserUncheckedCreateWithoutMessengerMessagesToInput>
    connectOrCreate?: FacebookUserCreateOrConnectWithoutMessengerMessagesToInput
    connect?: FacebookUserWhereUniqueInput
  }

  export type FacebookUserUpdateOneRequiredWithoutMessengerMessagesFromNestedInput = {
    create?: XOR<FacebookUserCreateWithoutMessengerMessagesFromInput, FacebookUserUncheckedCreateWithoutMessengerMessagesFromInput>
    connectOrCreate?: FacebookUserCreateOrConnectWithoutMessengerMessagesFromInput
    upsert?: FacebookUserUpsertWithoutMessengerMessagesFromInput
    connect?: FacebookUserWhereUniqueInput
    update?: XOR<FacebookUserUpdateWithoutMessengerMessagesFromInput, FacebookUserUncheckedUpdateWithoutMessengerMessagesFromInput>
  }

  export type FacebookUserUpdateOneRequiredWithoutMessengerMessagesToNestedInput = {
    create?: XOR<FacebookUserCreateWithoutMessengerMessagesToInput, FacebookUserUncheckedCreateWithoutMessengerMessagesToInput>
    connectOrCreate?: FacebookUserCreateOrConnectWithoutMessengerMessagesToInput
    upsert?: FacebookUserUpsertWithoutMessengerMessagesToInput
    connect?: FacebookUserWhereUniqueInput
    update?: XOR<FacebookUserUpdateWithoutMessengerMessagesToInput, FacebookUserUncheckedUpdateWithoutMessengerMessagesToInput>
  }

  export type BookTitleCreateNestedManyWithoutAuthorsInput = {
    create?: XOR<Enumerable<BookTitleCreateWithoutAuthorsInput>, Enumerable<BookTitleUncheckedCreateWithoutAuthorsInput>>
    connectOrCreate?: Enumerable<BookTitleCreateOrConnectWithoutAuthorsInput>
    connect?: Enumerable<BookTitleWhereUniqueInput>
  }

  export type BookTitleUncheckedCreateNestedManyWithoutAuthorsInput = {
    create?: XOR<Enumerable<BookTitleCreateWithoutAuthorsInput>, Enumerable<BookTitleUncheckedCreateWithoutAuthorsInput>>
    connectOrCreate?: Enumerable<BookTitleCreateOrConnectWithoutAuthorsInput>
    connect?: Enumerable<BookTitleWhereUniqueInput>
  }

  export type BookTitleUpdateManyWithoutAuthorsNestedInput = {
    create?: XOR<Enumerable<BookTitleCreateWithoutAuthorsInput>, Enumerable<BookTitleUncheckedCreateWithoutAuthorsInput>>
    connectOrCreate?: Enumerable<BookTitleCreateOrConnectWithoutAuthorsInput>
    upsert?: Enumerable<BookTitleUpsertWithWhereUniqueWithoutAuthorsInput>
    set?: Enumerable<BookTitleWhereUniqueInput>
    disconnect?: Enumerable<BookTitleWhereUniqueInput>
    delete?: Enumerable<BookTitleWhereUniqueInput>
    connect?: Enumerable<BookTitleWhereUniqueInput>
    update?: Enumerable<BookTitleUpdateWithWhereUniqueWithoutAuthorsInput>
    updateMany?: Enumerable<BookTitleUpdateManyWithWhereWithoutAuthorsInput>
    deleteMany?: Enumerable<BookTitleScalarWhereInput>
  }

  export type BookTitleUncheckedUpdateManyWithoutAuthorsNestedInput = {
    create?: XOR<Enumerable<BookTitleCreateWithoutAuthorsInput>, Enumerable<BookTitleUncheckedCreateWithoutAuthorsInput>>
    connectOrCreate?: Enumerable<BookTitleCreateOrConnectWithoutAuthorsInput>
    upsert?: Enumerable<BookTitleUpsertWithWhereUniqueWithoutAuthorsInput>
    set?: Enumerable<BookTitleWhereUniqueInput>
    disconnect?: Enumerable<BookTitleWhereUniqueInput>
    delete?: Enumerable<BookTitleWhereUniqueInput>
    connect?: Enumerable<BookTitleWhereUniqueInput>
    update?: Enumerable<BookTitleUpdateWithWhereUniqueWithoutAuthorsInput>
    updateMany?: Enumerable<BookTitleUpdateManyWithWhereWithoutAuthorsInput>
    deleteMany?: Enumerable<BookTitleScalarWhereInput>
  }

  export type AuthorCreateNestedManyWithoutBookTitlesInput = {
    create?: XOR<Enumerable<AuthorCreateWithoutBookTitlesInput>, Enumerable<AuthorUncheckedCreateWithoutBookTitlesInput>>
    connectOrCreate?: Enumerable<AuthorCreateOrConnectWithoutBookTitlesInput>
    connect?: Enumerable<AuthorWhereUniqueInput>
  }

  export type BookCategoryCreateNestedManyWithoutBookTitlesInput = {
    create?: XOR<Enumerable<BookCategoryCreateWithoutBookTitlesInput>, Enumerable<BookCategoryUncheckedCreateWithoutBookTitlesInput>>
    connectOrCreate?: Enumerable<BookCategoryCreateOrConnectWithoutBookTitlesInput>
    connect?: Enumerable<BookCategoryWhereUniqueInput>
  }

  export type BookCreateNestedManyWithoutTitleInput = {
    create?: XOR<Enumerable<BookCreateWithoutTitleInput>, Enumerable<BookUncheckedCreateWithoutTitleInput>>
    connectOrCreate?: Enumerable<BookCreateOrConnectWithoutTitleInput>
    createMany?: BookCreateManyTitleInputEnvelope
    connect?: Enumerable<BookWhereUniqueInput>
  }

  export type RequestRecordCreateNestedManyWithoutRequestedBookTitleInput = {
    create?: XOR<Enumerable<RequestRecordCreateWithoutRequestedBookTitleInput>, Enumerable<RequestRecordUncheckedCreateWithoutRequestedBookTitleInput>>
    connectOrCreate?: Enumerable<RequestRecordCreateOrConnectWithoutRequestedBookTitleInput>
    createMany?: RequestRecordCreateManyRequestedBookTitleInputEnvelope
    connect?: Enumerable<RequestRecordWhereUniqueInput>
  }

  export type AuthorUncheckedCreateNestedManyWithoutBookTitlesInput = {
    create?: XOR<Enumerable<AuthorCreateWithoutBookTitlesInput>, Enumerable<AuthorUncheckedCreateWithoutBookTitlesInput>>
    connectOrCreate?: Enumerable<AuthorCreateOrConnectWithoutBookTitlesInput>
    connect?: Enumerable<AuthorWhereUniqueInput>
  }

  export type BookCategoryUncheckedCreateNestedManyWithoutBookTitlesInput = {
    create?: XOR<Enumerable<BookCategoryCreateWithoutBookTitlesInput>, Enumerable<BookCategoryUncheckedCreateWithoutBookTitlesInput>>
    connectOrCreate?: Enumerable<BookCategoryCreateOrConnectWithoutBookTitlesInput>
    connect?: Enumerable<BookCategoryWhereUniqueInput>
  }

  export type BookUncheckedCreateNestedManyWithoutTitleInput = {
    create?: XOR<Enumerable<BookCreateWithoutTitleInput>, Enumerable<BookUncheckedCreateWithoutTitleInput>>
    connectOrCreate?: Enumerable<BookCreateOrConnectWithoutTitleInput>
    createMany?: BookCreateManyTitleInputEnvelope
    connect?: Enumerable<BookWhereUniqueInput>
  }

  export type RequestRecordUncheckedCreateNestedManyWithoutRequestedBookTitleInput = {
    create?: XOR<Enumerable<RequestRecordCreateWithoutRequestedBookTitleInput>, Enumerable<RequestRecordUncheckedCreateWithoutRequestedBookTitleInput>>
    connectOrCreate?: Enumerable<RequestRecordCreateOrConnectWithoutRequestedBookTitleInput>
    createMany?: RequestRecordCreateManyRequestedBookTitleInputEnvelope
    connect?: Enumerable<RequestRecordWhereUniqueInput>
  }

  export type AuthorUpdateManyWithoutBookTitlesNestedInput = {
    create?: XOR<Enumerable<AuthorCreateWithoutBookTitlesInput>, Enumerable<AuthorUncheckedCreateWithoutBookTitlesInput>>
    connectOrCreate?: Enumerable<AuthorCreateOrConnectWithoutBookTitlesInput>
    upsert?: Enumerable<AuthorUpsertWithWhereUniqueWithoutBookTitlesInput>
    set?: Enumerable<AuthorWhereUniqueInput>
    disconnect?: Enumerable<AuthorWhereUniqueInput>
    delete?: Enumerable<AuthorWhereUniqueInput>
    connect?: Enumerable<AuthorWhereUniqueInput>
    update?: Enumerable<AuthorUpdateWithWhereUniqueWithoutBookTitlesInput>
    updateMany?: Enumerable<AuthorUpdateManyWithWhereWithoutBookTitlesInput>
    deleteMany?: Enumerable<AuthorScalarWhereInput>
  }

  export type BookCategoryUpdateManyWithoutBookTitlesNestedInput = {
    create?: XOR<Enumerable<BookCategoryCreateWithoutBookTitlesInput>, Enumerable<BookCategoryUncheckedCreateWithoutBookTitlesInput>>
    connectOrCreate?: Enumerable<BookCategoryCreateOrConnectWithoutBookTitlesInput>
    upsert?: Enumerable<BookCategoryUpsertWithWhereUniqueWithoutBookTitlesInput>
    set?: Enumerable<BookCategoryWhereUniqueInput>
    disconnect?: Enumerable<BookCategoryWhereUniqueInput>
    delete?: Enumerable<BookCategoryWhereUniqueInput>
    connect?: Enumerable<BookCategoryWhereUniqueInput>
    update?: Enumerable<BookCategoryUpdateWithWhereUniqueWithoutBookTitlesInput>
    updateMany?: Enumerable<BookCategoryUpdateManyWithWhereWithoutBookTitlesInput>
    deleteMany?: Enumerable<BookCategoryScalarWhereInput>
  }

  export type BookUpdateManyWithoutTitleNestedInput = {
    create?: XOR<Enumerable<BookCreateWithoutTitleInput>, Enumerable<BookUncheckedCreateWithoutTitleInput>>
    connectOrCreate?: Enumerable<BookCreateOrConnectWithoutTitleInput>
    upsert?: Enumerable<BookUpsertWithWhereUniqueWithoutTitleInput>
    createMany?: BookCreateManyTitleInputEnvelope
    set?: Enumerable<BookWhereUniqueInput>
    disconnect?: Enumerable<BookWhereUniqueInput>
    delete?: Enumerable<BookWhereUniqueInput>
    connect?: Enumerable<BookWhereUniqueInput>
    update?: Enumerable<BookUpdateWithWhereUniqueWithoutTitleInput>
    updateMany?: Enumerable<BookUpdateManyWithWhereWithoutTitleInput>
    deleteMany?: Enumerable<BookScalarWhereInput>
  }

  export type RequestRecordUpdateManyWithoutRequestedBookTitleNestedInput = {
    create?: XOR<Enumerable<RequestRecordCreateWithoutRequestedBookTitleInput>, Enumerable<RequestRecordUncheckedCreateWithoutRequestedBookTitleInput>>
    connectOrCreate?: Enumerable<RequestRecordCreateOrConnectWithoutRequestedBookTitleInput>
    upsert?: Enumerable<RequestRecordUpsertWithWhereUniqueWithoutRequestedBookTitleInput>
    createMany?: RequestRecordCreateManyRequestedBookTitleInputEnvelope
    set?: Enumerable<RequestRecordWhereUniqueInput>
    disconnect?: Enumerable<RequestRecordWhereUniqueInput>
    delete?: Enumerable<RequestRecordWhereUniqueInput>
    connect?: Enumerable<RequestRecordWhereUniqueInput>
    update?: Enumerable<RequestRecordUpdateWithWhereUniqueWithoutRequestedBookTitleInput>
    updateMany?: Enumerable<RequestRecordUpdateManyWithWhereWithoutRequestedBookTitleInput>
    deleteMany?: Enumerable<RequestRecordScalarWhereInput>
  }

  export type AuthorUncheckedUpdateManyWithoutBookTitlesNestedInput = {
    create?: XOR<Enumerable<AuthorCreateWithoutBookTitlesInput>, Enumerable<AuthorUncheckedCreateWithoutBookTitlesInput>>
    connectOrCreate?: Enumerable<AuthorCreateOrConnectWithoutBookTitlesInput>
    upsert?: Enumerable<AuthorUpsertWithWhereUniqueWithoutBookTitlesInput>
    set?: Enumerable<AuthorWhereUniqueInput>
    disconnect?: Enumerable<AuthorWhereUniqueInput>
    delete?: Enumerable<AuthorWhereUniqueInput>
    connect?: Enumerable<AuthorWhereUniqueInput>
    update?: Enumerable<AuthorUpdateWithWhereUniqueWithoutBookTitlesInput>
    updateMany?: Enumerable<AuthorUpdateManyWithWhereWithoutBookTitlesInput>
    deleteMany?: Enumerable<AuthorScalarWhereInput>
  }

  export type BookCategoryUncheckedUpdateManyWithoutBookTitlesNestedInput = {
    create?: XOR<Enumerable<BookCategoryCreateWithoutBookTitlesInput>, Enumerable<BookCategoryUncheckedCreateWithoutBookTitlesInput>>
    connectOrCreate?: Enumerable<BookCategoryCreateOrConnectWithoutBookTitlesInput>
    upsert?: Enumerable<BookCategoryUpsertWithWhereUniqueWithoutBookTitlesInput>
    set?: Enumerable<BookCategoryWhereUniqueInput>
    disconnect?: Enumerable<BookCategoryWhereUniqueInput>
    delete?: Enumerable<BookCategoryWhereUniqueInput>
    connect?: Enumerable<BookCategoryWhereUniqueInput>
    update?: Enumerable<BookCategoryUpdateWithWhereUniqueWithoutBookTitlesInput>
    updateMany?: Enumerable<BookCategoryUpdateManyWithWhereWithoutBookTitlesInput>
    deleteMany?: Enumerable<BookCategoryScalarWhereInput>
  }

  export type BookUncheckedUpdateManyWithoutTitleNestedInput = {
    create?: XOR<Enumerable<BookCreateWithoutTitleInput>, Enumerable<BookUncheckedCreateWithoutTitleInput>>
    connectOrCreate?: Enumerable<BookCreateOrConnectWithoutTitleInput>
    upsert?: Enumerable<BookUpsertWithWhereUniqueWithoutTitleInput>
    createMany?: BookCreateManyTitleInputEnvelope
    set?: Enumerable<BookWhereUniqueInput>
    disconnect?: Enumerable<BookWhereUniqueInput>
    delete?: Enumerable<BookWhereUniqueInput>
    connect?: Enumerable<BookWhereUniqueInput>
    update?: Enumerable<BookUpdateWithWhereUniqueWithoutTitleInput>
    updateMany?: Enumerable<BookUpdateManyWithWhereWithoutTitleInput>
    deleteMany?: Enumerable<BookScalarWhereInput>
  }

  export type RequestRecordUncheckedUpdateManyWithoutRequestedBookTitleNestedInput = {
    create?: XOR<Enumerable<RequestRecordCreateWithoutRequestedBookTitleInput>, Enumerable<RequestRecordUncheckedCreateWithoutRequestedBookTitleInput>>
    connectOrCreate?: Enumerable<RequestRecordCreateOrConnectWithoutRequestedBookTitleInput>
    upsert?: Enumerable<RequestRecordUpsertWithWhereUniqueWithoutRequestedBookTitleInput>
    createMany?: RequestRecordCreateManyRequestedBookTitleInputEnvelope
    set?: Enumerable<RequestRecordWhereUniqueInput>
    disconnect?: Enumerable<RequestRecordWhereUniqueInput>
    delete?: Enumerable<RequestRecordWhereUniqueInput>
    connect?: Enumerable<RequestRecordWhereUniqueInput>
    update?: Enumerable<RequestRecordUpdateWithWhereUniqueWithoutRequestedBookTitleInput>
    updateMany?: Enumerable<RequestRecordUpdateManyWithWhereWithoutRequestedBookTitleInput>
    deleteMany?: Enumerable<RequestRecordScalarWhereInput>
  }

  export type BookTitleCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<Enumerable<BookTitleCreateWithoutCategoriesInput>, Enumerable<BookTitleUncheckedCreateWithoutCategoriesInput>>
    connectOrCreate?: Enumerable<BookTitleCreateOrConnectWithoutCategoriesInput>
    connect?: Enumerable<BookTitleWhereUniqueInput>
  }

  export type BookTitleUncheckedCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<Enumerable<BookTitleCreateWithoutCategoriesInput>, Enumerable<BookTitleUncheckedCreateWithoutCategoriesInput>>
    connectOrCreate?: Enumerable<BookTitleCreateOrConnectWithoutCategoriesInput>
    connect?: Enumerable<BookTitleWhereUniqueInput>
  }

  export type BookTitleUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<Enumerable<BookTitleCreateWithoutCategoriesInput>, Enumerable<BookTitleUncheckedCreateWithoutCategoriesInput>>
    connectOrCreate?: Enumerable<BookTitleCreateOrConnectWithoutCategoriesInput>
    upsert?: Enumerable<BookTitleUpsertWithWhereUniqueWithoutCategoriesInput>
    set?: Enumerable<BookTitleWhereUniqueInput>
    disconnect?: Enumerable<BookTitleWhereUniqueInput>
    delete?: Enumerable<BookTitleWhereUniqueInput>
    connect?: Enumerable<BookTitleWhereUniqueInput>
    update?: Enumerable<BookTitleUpdateWithWhereUniqueWithoutCategoriesInput>
    updateMany?: Enumerable<BookTitleUpdateManyWithWhereWithoutCategoriesInput>
    deleteMany?: Enumerable<BookTitleScalarWhereInput>
  }

  export type BookTitleUncheckedUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<Enumerable<BookTitleCreateWithoutCategoriesInput>, Enumerable<BookTitleUncheckedCreateWithoutCategoriesInput>>
    connectOrCreate?: Enumerable<BookTitleCreateOrConnectWithoutCategoriesInput>
    upsert?: Enumerable<BookTitleUpsertWithWhereUniqueWithoutCategoriesInput>
    set?: Enumerable<BookTitleWhereUniqueInput>
    disconnect?: Enumerable<BookTitleWhereUniqueInput>
    delete?: Enumerable<BookTitleWhereUniqueInput>
    connect?: Enumerable<BookTitleWhereUniqueInput>
    update?: Enumerable<BookTitleUpdateWithWhereUniqueWithoutCategoriesInput>
    updateMany?: Enumerable<BookTitleUpdateManyWithWhereWithoutCategoriesInput>
    deleteMany?: Enumerable<BookTitleScalarWhereInput>
  }

  export type BookTitleCreateNestedOneWithoutBooksInput = {
    create?: XOR<BookTitleCreateWithoutBooksInput, BookTitleUncheckedCreateWithoutBooksInput>
    connectOrCreate?: BookTitleCreateOrConnectWithoutBooksInput
    connect?: BookTitleWhereUniqueInput
  }

  export type LibraryCreateNestedOneWithoutBooksInput = {
    create?: XOR<LibraryCreateWithoutBooksInput, LibraryUncheckedCreateWithoutBooksInput>
    connectOrCreate?: LibraryCreateOrConnectWithoutBooksInput
    connect?: LibraryWhereUniqueInput
  }

  export type BorrowingRecordCreateNestedManyWithoutBorrowedBookInput = {
    create?: XOR<Enumerable<BorrowingRecordCreateWithoutBorrowedBookInput>, Enumerable<BorrowingRecordUncheckedCreateWithoutBorrowedBookInput>>
    connectOrCreate?: Enumerable<BorrowingRecordCreateOrConnectWithoutBorrowedBookInput>
    createMany?: BorrowingRecordCreateManyBorrowedBookInputEnvelope
    connect?: Enumerable<BorrowingRecordWhereUniqueInput>
  }

  export type RequestRecordCreateNestedManyWithoutAcquiredBookInput = {
    create?: XOR<Enumerable<RequestRecordCreateWithoutAcquiredBookInput>, Enumerable<RequestRecordUncheckedCreateWithoutAcquiredBookInput>>
    connectOrCreate?: Enumerable<RequestRecordCreateOrConnectWithoutAcquiredBookInput>
    createMany?: RequestRecordCreateManyAcquiredBookInputEnvelope
    connect?: Enumerable<RequestRecordWhereUniqueInput>
  }

  export type BorrowingRecordUncheckedCreateNestedManyWithoutBorrowedBookInput = {
    create?: XOR<Enumerable<BorrowingRecordCreateWithoutBorrowedBookInput>, Enumerable<BorrowingRecordUncheckedCreateWithoutBorrowedBookInput>>
    connectOrCreate?: Enumerable<BorrowingRecordCreateOrConnectWithoutBorrowedBookInput>
    createMany?: BorrowingRecordCreateManyBorrowedBookInputEnvelope
    connect?: Enumerable<BorrowingRecordWhereUniqueInput>
  }

  export type RequestRecordUncheckedCreateNestedManyWithoutAcquiredBookInput = {
    create?: XOR<Enumerable<RequestRecordCreateWithoutAcquiredBookInput>, Enumerable<RequestRecordUncheckedCreateWithoutAcquiredBookInput>>
    connectOrCreate?: Enumerable<RequestRecordCreateOrConnectWithoutAcquiredBookInput>
    createMany?: RequestRecordCreateManyAcquiredBookInputEnvelope
    connect?: Enumerable<RequestRecordWhereUniqueInput>
  }

  export type BookTitleUpdateOneRequiredWithoutBooksNestedInput = {
    create?: XOR<BookTitleCreateWithoutBooksInput, BookTitleUncheckedCreateWithoutBooksInput>
    connectOrCreate?: BookTitleCreateOrConnectWithoutBooksInput
    upsert?: BookTitleUpsertWithoutBooksInput
    connect?: BookTitleWhereUniqueInput
    update?: XOR<BookTitleUpdateWithoutBooksInput, BookTitleUncheckedUpdateWithoutBooksInput>
  }

  export type LibraryUpdateOneRequiredWithoutBooksNestedInput = {
    create?: XOR<LibraryCreateWithoutBooksInput, LibraryUncheckedCreateWithoutBooksInput>
    connectOrCreate?: LibraryCreateOrConnectWithoutBooksInput
    upsert?: LibraryUpsertWithoutBooksInput
    connect?: LibraryWhereUniqueInput
    update?: XOR<LibraryUpdateWithoutBooksInput, LibraryUncheckedUpdateWithoutBooksInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type BorrowingRecordUpdateManyWithoutBorrowedBookNestedInput = {
    create?: XOR<Enumerable<BorrowingRecordCreateWithoutBorrowedBookInput>, Enumerable<BorrowingRecordUncheckedCreateWithoutBorrowedBookInput>>
    connectOrCreate?: Enumerable<BorrowingRecordCreateOrConnectWithoutBorrowedBookInput>
    upsert?: Enumerable<BorrowingRecordUpsertWithWhereUniqueWithoutBorrowedBookInput>
    createMany?: BorrowingRecordCreateManyBorrowedBookInputEnvelope
    set?: Enumerable<BorrowingRecordWhereUniqueInput>
    disconnect?: Enumerable<BorrowingRecordWhereUniqueInput>
    delete?: Enumerable<BorrowingRecordWhereUniqueInput>
    connect?: Enumerable<BorrowingRecordWhereUniqueInput>
    update?: Enumerable<BorrowingRecordUpdateWithWhereUniqueWithoutBorrowedBookInput>
    updateMany?: Enumerable<BorrowingRecordUpdateManyWithWhereWithoutBorrowedBookInput>
    deleteMany?: Enumerable<BorrowingRecordScalarWhereInput>
  }

  export type RequestRecordUpdateManyWithoutAcquiredBookNestedInput = {
    create?: XOR<Enumerable<RequestRecordCreateWithoutAcquiredBookInput>, Enumerable<RequestRecordUncheckedCreateWithoutAcquiredBookInput>>
    connectOrCreate?: Enumerable<RequestRecordCreateOrConnectWithoutAcquiredBookInput>
    upsert?: Enumerable<RequestRecordUpsertWithWhereUniqueWithoutAcquiredBookInput>
    createMany?: RequestRecordCreateManyAcquiredBookInputEnvelope
    set?: Enumerable<RequestRecordWhereUniqueInput>
    disconnect?: Enumerable<RequestRecordWhereUniqueInput>
    delete?: Enumerable<RequestRecordWhereUniqueInput>
    connect?: Enumerable<RequestRecordWhereUniqueInput>
    update?: Enumerable<RequestRecordUpdateWithWhereUniqueWithoutAcquiredBookInput>
    updateMany?: Enumerable<RequestRecordUpdateManyWithWhereWithoutAcquiredBookInput>
    deleteMany?: Enumerable<RequestRecordScalarWhereInput>
  }

  export type BorrowingRecordUncheckedUpdateManyWithoutBorrowedBookNestedInput = {
    create?: XOR<Enumerable<BorrowingRecordCreateWithoutBorrowedBookInput>, Enumerable<BorrowingRecordUncheckedCreateWithoutBorrowedBookInput>>
    connectOrCreate?: Enumerable<BorrowingRecordCreateOrConnectWithoutBorrowedBookInput>
    upsert?: Enumerable<BorrowingRecordUpsertWithWhereUniqueWithoutBorrowedBookInput>
    createMany?: BorrowingRecordCreateManyBorrowedBookInputEnvelope
    set?: Enumerable<BorrowingRecordWhereUniqueInput>
    disconnect?: Enumerable<BorrowingRecordWhereUniqueInput>
    delete?: Enumerable<BorrowingRecordWhereUniqueInput>
    connect?: Enumerable<BorrowingRecordWhereUniqueInput>
    update?: Enumerable<BorrowingRecordUpdateWithWhereUniqueWithoutBorrowedBookInput>
    updateMany?: Enumerable<BorrowingRecordUpdateManyWithWhereWithoutBorrowedBookInput>
    deleteMany?: Enumerable<BorrowingRecordScalarWhereInput>
  }

  export type RequestRecordUncheckedUpdateManyWithoutAcquiredBookNestedInput = {
    create?: XOR<Enumerable<RequestRecordCreateWithoutAcquiredBookInput>, Enumerable<RequestRecordUncheckedCreateWithoutAcquiredBookInput>>
    connectOrCreate?: Enumerable<RequestRecordCreateOrConnectWithoutAcquiredBookInput>
    upsert?: Enumerable<RequestRecordUpsertWithWhereUniqueWithoutAcquiredBookInput>
    createMany?: RequestRecordCreateManyAcquiredBookInputEnvelope
    set?: Enumerable<RequestRecordWhereUniqueInput>
    disconnect?: Enumerable<RequestRecordWhereUniqueInput>
    delete?: Enumerable<RequestRecordWhereUniqueInput>
    connect?: Enumerable<RequestRecordWhereUniqueInput>
    update?: Enumerable<RequestRecordUpdateWithWhereUniqueWithoutAcquiredBookInput>
    updateMany?: Enumerable<RequestRecordUpdateManyWithWhereWithoutAcquiredBookInput>
    deleteMany?: Enumerable<RequestRecordScalarWhereInput>
  }

  export type UniversityCreateNestedOneWithoutLibrariesInput = {
    create?: XOR<UniversityCreateWithoutLibrariesInput, UniversityUncheckedCreateWithoutLibrariesInput>
    connectOrCreate?: UniversityCreateOrConnectWithoutLibrariesInput
    connect?: UniversityWhereUniqueInput
  }

  export type BookCreateNestedManyWithoutBelongsToLibraryInput = {
    create?: XOR<Enumerable<BookCreateWithoutBelongsToLibraryInput>, Enumerable<BookUncheckedCreateWithoutBelongsToLibraryInput>>
    connectOrCreate?: Enumerable<BookCreateOrConnectWithoutBelongsToLibraryInput>
    createMany?: BookCreateManyBelongsToLibraryInputEnvelope
    connect?: Enumerable<BookWhereUniqueInput>
  }

  export type RequestRecordCreateNestedManyWithoutRequestingLibraryInput = {
    create?: XOR<Enumerable<RequestRecordCreateWithoutRequestingLibraryInput>, Enumerable<RequestRecordUncheckedCreateWithoutRequestingLibraryInput>>
    connectOrCreate?: Enumerable<RequestRecordCreateOrConnectWithoutRequestingLibraryInput>
    createMany?: RequestRecordCreateManyRequestingLibraryInputEnvelope
    connect?: Enumerable<RequestRecordWhereUniqueInput>
  }

  export type RequestRecordCreateNestedManyWithoutRequestedLibraryInput = {
    create?: XOR<Enumerable<RequestRecordCreateWithoutRequestedLibraryInput>, Enumerable<RequestRecordUncheckedCreateWithoutRequestedLibraryInput>>
    connectOrCreate?: Enumerable<RequestRecordCreateOrConnectWithoutRequestedLibraryInput>
    createMany?: RequestRecordCreateManyRequestedLibraryInputEnvelope
    connect?: Enumerable<RequestRecordWhereUniqueInput>
  }

  export type BookUncheckedCreateNestedManyWithoutBelongsToLibraryInput = {
    create?: XOR<Enumerable<BookCreateWithoutBelongsToLibraryInput>, Enumerable<BookUncheckedCreateWithoutBelongsToLibraryInput>>
    connectOrCreate?: Enumerable<BookCreateOrConnectWithoutBelongsToLibraryInput>
    createMany?: BookCreateManyBelongsToLibraryInputEnvelope
    connect?: Enumerable<BookWhereUniqueInput>
  }

  export type RequestRecordUncheckedCreateNestedManyWithoutRequestingLibraryInput = {
    create?: XOR<Enumerable<RequestRecordCreateWithoutRequestingLibraryInput>, Enumerable<RequestRecordUncheckedCreateWithoutRequestingLibraryInput>>
    connectOrCreate?: Enumerable<RequestRecordCreateOrConnectWithoutRequestingLibraryInput>
    createMany?: RequestRecordCreateManyRequestingLibraryInputEnvelope
    connect?: Enumerable<RequestRecordWhereUniqueInput>
  }

  export type RequestRecordUncheckedCreateNestedManyWithoutRequestedLibraryInput = {
    create?: XOR<Enumerable<RequestRecordCreateWithoutRequestedLibraryInput>, Enumerable<RequestRecordUncheckedCreateWithoutRequestedLibraryInput>>
    connectOrCreate?: Enumerable<RequestRecordCreateOrConnectWithoutRequestedLibraryInput>
    createMany?: RequestRecordCreateManyRequestedLibraryInputEnvelope
    connect?: Enumerable<RequestRecordWhereUniqueInput>
  }

  export type UniversityUpdateOneRequiredWithoutLibrariesNestedInput = {
    create?: XOR<UniversityCreateWithoutLibrariesInput, UniversityUncheckedCreateWithoutLibrariesInput>
    connectOrCreate?: UniversityCreateOrConnectWithoutLibrariesInput
    upsert?: UniversityUpsertWithoutLibrariesInput
    connect?: UniversityWhereUniqueInput
    update?: XOR<UniversityUpdateWithoutLibrariesInput, UniversityUncheckedUpdateWithoutLibrariesInput>
  }

  export type BookUpdateManyWithoutBelongsToLibraryNestedInput = {
    create?: XOR<Enumerable<BookCreateWithoutBelongsToLibraryInput>, Enumerable<BookUncheckedCreateWithoutBelongsToLibraryInput>>
    connectOrCreate?: Enumerable<BookCreateOrConnectWithoutBelongsToLibraryInput>
    upsert?: Enumerable<BookUpsertWithWhereUniqueWithoutBelongsToLibraryInput>
    createMany?: BookCreateManyBelongsToLibraryInputEnvelope
    set?: Enumerable<BookWhereUniqueInput>
    disconnect?: Enumerable<BookWhereUniqueInput>
    delete?: Enumerable<BookWhereUniqueInput>
    connect?: Enumerable<BookWhereUniqueInput>
    update?: Enumerable<BookUpdateWithWhereUniqueWithoutBelongsToLibraryInput>
    updateMany?: Enumerable<BookUpdateManyWithWhereWithoutBelongsToLibraryInput>
    deleteMany?: Enumerable<BookScalarWhereInput>
  }

  export type RequestRecordUpdateManyWithoutRequestingLibraryNestedInput = {
    create?: XOR<Enumerable<RequestRecordCreateWithoutRequestingLibraryInput>, Enumerable<RequestRecordUncheckedCreateWithoutRequestingLibraryInput>>
    connectOrCreate?: Enumerable<RequestRecordCreateOrConnectWithoutRequestingLibraryInput>
    upsert?: Enumerable<RequestRecordUpsertWithWhereUniqueWithoutRequestingLibraryInput>
    createMany?: RequestRecordCreateManyRequestingLibraryInputEnvelope
    set?: Enumerable<RequestRecordWhereUniqueInput>
    disconnect?: Enumerable<RequestRecordWhereUniqueInput>
    delete?: Enumerable<RequestRecordWhereUniqueInput>
    connect?: Enumerable<RequestRecordWhereUniqueInput>
    update?: Enumerable<RequestRecordUpdateWithWhereUniqueWithoutRequestingLibraryInput>
    updateMany?: Enumerable<RequestRecordUpdateManyWithWhereWithoutRequestingLibraryInput>
    deleteMany?: Enumerable<RequestRecordScalarWhereInput>
  }

  export type RequestRecordUpdateManyWithoutRequestedLibraryNestedInput = {
    create?: XOR<Enumerable<RequestRecordCreateWithoutRequestedLibraryInput>, Enumerable<RequestRecordUncheckedCreateWithoutRequestedLibraryInput>>
    connectOrCreate?: Enumerable<RequestRecordCreateOrConnectWithoutRequestedLibraryInput>
    upsert?: Enumerable<RequestRecordUpsertWithWhereUniqueWithoutRequestedLibraryInput>
    createMany?: RequestRecordCreateManyRequestedLibraryInputEnvelope
    set?: Enumerable<RequestRecordWhereUniqueInput>
    disconnect?: Enumerable<RequestRecordWhereUniqueInput>
    delete?: Enumerable<RequestRecordWhereUniqueInput>
    connect?: Enumerable<RequestRecordWhereUniqueInput>
    update?: Enumerable<RequestRecordUpdateWithWhereUniqueWithoutRequestedLibraryInput>
    updateMany?: Enumerable<RequestRecordUpdateManyWithWhereWithoutRequestedLibraryInput>
    deleteMany?: Enumerable<RequestRecordScalarWhereInput>
  }

  export type BookUncheckedUpdateManyWithoutBelongsToLibraryNestedInput = {
    create?: XOR<Enumerable<BookCreateWithoutBelongsToLibraryInput>, Enumerable<BookUncheckedCreateWithoutBelongsToLibraryInput>>
    connectOrCreate?: Enumerable<BookCreateOrConnectWithoutBelongsToLibraryInput>
    upsert?: Enumerable<BookUpsertWithWhereUniqueWithoutBelongsToLibraryInput>
    createMany?: BookCreateManyBelongsToLibraryInputEnvelope
    set?: Enumerable<BookWhereUniqueInput>
    disconnect?: Enumerable<BookWhereUniqueInput>
    delete?: Enumerable<BookWhereUniqueInput>
    connect?: Enumerable<BookWhereUniqueInput>
    update?: Enumerable<BookUpdateWithWhereUniqueWithoutBelongsToLibraryInput>
    updateMany?: Enumerable<BookUpdateManyWithWhereWithoutBelongsToLibraryInput>
    deleteMany?: Enumerable<BookScalarWhereInput>
  }

  export type RequestRecordUncheckedUpdateManyWithoutRequestingLibraryNestedInput = {
    create?: XOR<Enumerable<RequestRecordCreateWithoutRequestingLibraryInput>, Enumerable<RequestRecordUncheckedCreateWithoutRequestingLibraryInput>>
    connectOrCreate?: Enumerable<RequestRecordCreateOrConnectWithoutRequestingLibraryInput>
    upsert?: Enumerable<RequestRecordUpsertWithWhereUniqueWithoutRequestingLibraryInput>
    createMany?: RequestRecordCreateManyRequestingLibraryInputEnvelope
    set?: Enumerable<RequestRecordWhereUniqueInput>
    disconnect?: Enumerable<RequestRecordWhereUniqueInput>
    delete?: Enumerable<RequestRecordWhereUniqueInput>
    connect?: Enumerable<RequestRecordWhereUniqueInput>
    update?: Enumerable<RequestRecordUpdateWithWhereUniqueWithoutRequestingLibraryInput>
    updateMany?: Enumerable<RequestRecordUpdateManyWithWhereWithoutRequestingLibraryInput>
    deleteMany?: Enumerable<RequestRecordScalarWhereInput>
  }

  export type RequestRecordUncheckedUpdateManyWithoutRequestedLibraryNestedInput = {
    create?: XOR<Enumerable<RequestRecordCreateWithoutRequestedLibraryInput>, Enumerable<RequestRecordUncheckedCreateWithoutRequestedLibraryInput>>
    connectOrCreate?: Enumerable<RequestRecordCreateOrConnectWithoutRequestedLibraryInput>
    upsert?: Enumerable<RequestRecordUpsertWithWhereUniqueWithoutRequestedLibraryInput>
    createMany?: RequestRecordCreateManyRequestedLibraryInputEnvelope
    set?: Enumerable<RequestRecordWhereUniqueInput>
    disconnect?: Enumerable<RequestRecordWhereUniqueInput>
    delete?: Enumerable<RequestRecordWhereUniqueInput>
    connect?: Enumerable<RequestRecordWhereUniqueInput>
    update?: Enumerable<RequestRecordUpdateWithWhereUniqueWithoutRequestedLibraryInput>
    updateMany?: Enumerable<RequestRecordUpdateManyWithWhereWithoutRequestedLibraryInput>
    deleteMany?: Enumerable<RequestRecordScalarWhereInput>
  }

  export type LibraryCreateNestedManyWithoutBelongsToUniversityInput = {
    create?: XOR<Enumerable<LibraryCreateWithoutBelongsToUniversityInput>, Enumerable<LibraryUncheckedCreateWithoutBelongsToUniversityInput>>
    connectOrCreate?: Enumerable<LibraryCreateOrConnectWithoutBelongsToUniversityInput>
    createMany?: LibraryCreateManyBelongsToUniversityInputEnvelope
    connect?: Enumerable<LibraryWhereUniqueInput>
  }

  export type StudentCreateNestedManyWithoutBelongsToUniversityInput = {
    create?: XOR<Enumerable<StudentCreateWithoutBelongsToUniversityInput>, Enumerable<StudentUncheckedCreateWithoutBelongsToUniversityInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutBelongsToUniversityInput>
    createMany?: StudentCreateManyBelongsToUniversityInputEnvelope
    connect?: Enumerable<StudentWhereUniqueInput>
  }

  export type LibraryUncheckedCreateNestedManyWithoutBelongsToUniversityInput = {
    create?: XOR<Enumerable<LibraryCreateWithoutBelongsToUniversityInput>, Enumerable<LibraryUncheckedCreateWithoutBelongsToUniversityInput>>
    connectOrCreate?: Enumerable<LibraryCreateOrConnectWithoutBelongsToUniversityInput>
    createMany?: LibraryCreateManyBelongsToUniversityInputEnvelope
    connect?: Enumerable<LibraryWhereUniqueInput>
  }

  export type StudentUncheckedCreateNestedManyWithoutBelongsToUniversityInput = {
    create?: XOR<Enumerable<StudentCreateWithoutBelongsToUniversityInput>, Enumerable<StudentUncheckedCreateWithoutBelongsToUniversityInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutBelongsToUniversityInput>
    createMany?: StudentCreateManyBelongsToUniversityInputEnvelope
    connect?: Enumerable<StudentWhereUniqueInput>
  }

  export type LibraryUpdateManyWithoutBelongsToUniversityNestedInput = {
    create?: XOR<Enumerable<LibraryCreateWithoutBelongsToUniversityInput>, Enumerable<LibraryUncheckedCreateWithoutBelongsToUniversityInput>>
    connectOrCreate?: Enumerable<LibraryCreateOrConnectWithoutBelongsToUniversityInput>
    upsert?: Enumerable<LibraryUpsertWithWhereUniqueWithoutBelongsToUniversityInput>
    createMany?: LibraryCreateManyBelongsToUniversityInputEnvelope
    set?: Enumerable<LibraryWhereUniqueInput>
    disconnect?: Enumerable<LibraryWhereUniqueInput>
    delete?: Enumerable<LibraryWhereUniqueInput>
    connect?: Enumerable<LibraryWhereUniqueInput>
    update?: Enumerable<LibraryUpdateWithWhereUniqueWithoutBelongsToUniversityInput>
    updateMany?: Enumerable<LibraryUpdateManyWithWhereWithoutBelongsToUniversityInput>
    deleteMany?: Enumerable<LibraryScalarWhereInput>
  }

  export type StudentUpdateManyWithoutBelongsToUniversityNestedInput = {
    create?: XOR<Enumerable<StudentCreateWithoutBelongsToUniversityInput>, Enumerable<StudentUncheckedCreateWithoutBelongsToUniversityInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutBelongsToUniversityInput>
    upsert?: Enumerable<StudentUpsertWithWhereUniqueWithoutBelongsToUniversityInput>
    createMany?: StudentCreateManyBelongsToUniversityInputEnvelope
    set?: Enumerable<StudentWhereUniqueInput>
    disconnect?: Enumerable<StudentWhereUniqueInput>
    delete?: Enumerable<StudentWhereUniqueInput>
    connect?: Enumerable<StudentWhereUniqueInput>
    update?: Enumerable<StudentUpdateWithWhereUniqueWithoutBelongsToUniversityInput>
    updateMany?: Enumerable<StudentUpdateManyWithWhereWithoutBelongsToUniversityInput>
    deleteMany?: Enumerable<StudentScalarWhereInput>
  }

  export type LibraryUncheckedUpdateManyWithoutBelongsToUniversityNestedInput = {
    create?: XOR<Enumerable<LibraryCreateWithoutBelongsToUniversityInput>, Enumerable<LibraryUncheckedCreateWithoutBelongsToUniversityInput>>
    connectOrCreate?: Enumerable<LibraryCreateOrConnectWithoutBelongsToUniversityInput>
    upsert?: Enumerable<LibraryUpsertWithWhereUniqueWithoutBelongsToUniversityInput>
    createMany?: LibraryCreateManyBelongsToUniversityInputEnvelope
    set?: Enumerable<LibraryWhereUniqueInput>
    disconnect?: Enumerable<LibraryWhereUniqueInput>
    delete?: Enumerable<LibraryWhereUniqueInput>
    connect?: Enumerable<LibraryWhereUniqueInput>
    update?: Enumerable<LibraryUpdateWithWhereUniqueWithoutBelongsToUniversityInput>
    updateMany?: Enumerable<LibraryUpdateManyWithWhereWithoutBelongsToUniversityInput>
    deleteMany?: Enumerable<LibraryScalarWhereInput>
  }

  export type StudentUncheckedUpdateManyWithoutBelongsToUniversityNestedInput = {
    create?: XOR<Enumerable<StudentCreateWithoutBelongsToUniversityInput>, Enumerable<StudentUncheckedCreateWithoutBelongsToUniversityInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutBelongsToUniversityInput>
    upsert?: Enumerable<StudentUpsertWithWhereUniqueWithoutBelongsToUniversityInput>
    createMany?: StudentCreateManyBelongsToUniversityInputEnvelope
    set?: Enumerable<StudentWhereUniqueInput>
    disconnect?: Enumerable<StudentWhereUniqueInput>
    delete?: Enumerable<StudentWhereUniqueInput>
    connect?: Enumerable<StudentWhereUniqueInput>
    update?: Enumerable<StudentUpdateWithWhereUniqueWithoutBelongsToUniversityInput>
    updateMany?: Enumerable<StudentUpdateManyWithWhereWithoutBelongsToUniversityInput>
    deleteMany?: Enumerable<StudentScalarWhereInput>
  }

  export type UniversityCreateNestedOneWithoutStudentsInput = {
    create?: XOR<UniversityCreateWithoutStudentsInput, UniversityUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: UniversityCreateOrConnectWithoutStudentsInput
    connect?: UniversityWhereUniqueInput
  }

  export type BorrowingRecordCreateNestedManyWithoutBorrowingStudentInput = {
    create?: XOR<Enumerable<BorrowingRecordCreateWithoutBorrowingStudentInput>, Enumerable<BorrowingRecordUncheckedCreateWithoutBorrowingStudentInput>>
    connectOrCreate?: Enumerable<BorrowingRecordCreateOrConnectWithoutBorrowingStudentInput>
    createMany?: BorrowingRecordCreateManyBorrowingStudentInputEnvelope
    connect?: Enumerable<BorrowingRecordWhereUniqueInput>
  }

  export type RequestRecordCreateNestedManyWithoutRequestingStudentInput = {
    create?: XOR<Enumerable<RequestRecordCreateWithoutRequestingStudentInput>, Enumerable<RequestRecordUncheckedCreateWithoutRequestingStudentInput>>
    connectOrCreate?: Enumerable<RequestRecordCreateOrConnectWithoutRequestingStudentInput>
    createMany?: RequestRecordCreateManyRequestingStudentInputEnvelope
    connect?: Enumerable<RequestRecordWhereUniqueInput>
  }

  export type BorrowingRecordUncheckedCreateNestedManyWithoutBorrowingStudentInput = {
    create?: XOR<Enumerable<BorrowingRecordCreateWithoutBorrowingStudentInput>, Enumerable<BorrowingRecordUncheckedCreateWithoutBorrowingStudentInput>>
    connectOrCreate?: Enumerable<BorrowingRecordCreateOrConnectWithoutBorrowingStudentInput>
    createMany?: BorrowingRecordCreateManyBorrowingStudentInputEnvelope
    connect?: Enumerable<BorrowingRecordWhereUniqueInput>
  }

  export type RequestRecordUncheckedCreateNestedManyWithoutRequestingStudentInput = {
    create?: XOR<Enumerable<RequestRecordCreateWithoutRequestingStudentInput>, Enumerable<RequestRecordUncheckedCreateWithoutRequestingStudentInput>>
    connectOrCreate?: Enumerable<RequestRecordCreateOrConnectWithoutRequestingStudentInput>
    createMany?: RequestRecordCreateManyRequestingStudentInputEnvelope
    connect?: Enumerable<RequestRecordWhereUniqueInput>
  }

  export type UniversityUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<UniversityCreateWithoutStudentsInput, UniversityUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: UniversityCreateOrConnectWithoutStudentsInput
    upsert?: UniversityUpsertWithoutStudentsInput
    connect?: UniversityWhereUniqueInput
    update?: XOR<UniversityUpdateWithoutStudentsInput, UniversityUncheckedUpdateWithoutStudentsInput>
  }

  export type BorrowingRecordUpdateManyWithoutBorrowingStudentNestedInput = {
    create?: XOR<Enumerable<BorrowingRecordCreateWithoutBorrowingStudentInput>, Enumerable<BorrowingRecordUncheckedCreateWithoutBorrowingStudentInput>>
    connectOrCreate?: Enumerable<BorrowingRecordCreateOrConnectWithoutBorrowingStudentInput>
    upsert?: Enumerable<BorrowingRecordUpsertWithWhereUniqueWithoutBorrowingStudentInput>
    createMany?: BorrowingRecordCreateManyBorrowingStudentInputEnvelope
    set?: Enumerable<BorrowingRecordWhereUniqueInput>
    disconnect?: Enumerable<BorrowingRecordWhereUniqueInput>
    delete?: Enumerable<BorrowingRecordWhereUniqueInput>
    connect?: Enumerable<BorrowingRecordWhereUniqueInput>
    update?: Enumerable<BorrowingRecordUpdateWithWhereUniqueWithoutBorrowingStudentInput>
    updateMany?: Enumerable<BorrowingRecordUpdateManyWithWhereWithoutBorrowingStudentInput>
    deleteMany?: Enumerable<BorrowingRecordScalarWhereInput>
  }

  export type RequestRecordUpdateManyWithoutRequestingStudentNestedInput = {
    create?: XOR<Enumerable<RequestRecordCreateWithoutRequestingStudentInput>, Enumerable<RequestRecordUncheckedCreateWithoutRequestingStudentInput>>
    connectOrCreate?: Enumerable<RequestRecordCreateOrConnectWithoutRequestingStudentInput>
    upsert?: Enumerable<RequestRecordUpsertWithWhereUniqueWithoutRequestingStudentInput>
    createMany?: RequestRecordCreateManyRequestingStudentInputEnvelope
    set?: Enumerable<RequestRecordWhereUniqueInput>
    disconnect?: Enumerable<RequestRecordWhereUniqueInput>
    delete?: Enumerable<RequestRecordWhereUniqueInput>
    connect?: Enumerable<RequestRecordWhereUniqueInput>
    update?: Enumerable<RequestRecordUpdateWithWhereUniqueWithoutRequestingStudentInput>
    updateMany?: Enumerable<RequestRecordUpdateManyWithWhereWithoutRequestingStudentInput>
    deleteMany?: Enumerable<RequestRecordScalarWhereInput>
  }

  export type BorrowingRecordUncheckedUpdateManyWithoutBorrowingStudentNestedInput = {
    create?: XOR<Enumerable<BorrowingRecordCreateWithoutBorrowingStudentInput>, Enumerable<BorrowingRecordUncheckedCreateWithoutBorrowingStudentInput>>
    connectOrCreate?: Enumerable<BorrowingRecordCreateOrConnectWithoutBorrowingStudentInput>
    upsert?: Enumerable<BorrowingRecordUpsertWithWhereUniqueWithoutBorrowingStudentInput>
    createMany?: BorrowingRecordCreateManyBorrowingStudentInputEnvelope
    set?: Enumerable<BorrowingRecordWhereUniqueInput>
    disconnect?: Enumerable<BorrowingRecordWhereUniqueInput>
    delete?: Enumerable<BorrowingRecordWhereUniqueInput>
    connect?: Enumerable<BorrowingRecordWhereUniqueInput>
    update?: Enumerable<BorrowingRecordUpdateWithWhereUniqueWithoutBorrowingStudentInput>
    updateMany?: Enumerable<BorrowingRecordUpdateManyWithWhereWithoutBorrowingStudentInput>
    deleteMany?: Enumerable<BorrowingRecordScalarWhereInput>
  }

  export type RequestRecordUncheckedUpdateManyWithoutRequestingStudentNestedInput = {
    create?: XOR<Enumerable<RequestRecordCreateWithoutRequestingStudentInput>, Enumerable<RequestRecordUncheckedCreateWithoutRequestingStudentInput>>
    connectOrCreate?: Enumerable<RequestRecordCreateOrConnectWithoutRequestingStudentInput>
    upsert?: Enumerable<RequestRecordUpsertWithWhereUniqueWithoutRequestingStudentInput>
    createMany?: RequestRecordCreateManyRequestingStudentInputEnvelope
    set?: Enumerable<RequestRecordWhereUniqueInput>
    disconnect?: Enumerable<RequestRecordWhereUniqueInput>
    delete?: Enumerable<RequestRecordWhereUniqueInput>
    connect?: Enumerable<RequestRecordWhereUniqueInput>
    update?: Enumerable<RequestRecordUpdateWithWhereUniqueWithoutRequestingStudentInput>
    updateMany?: Enumerable<RequestRecordUpdateManyWithWhereWithoutRequestingStudentInput>
    deleteMany?: Enumerable<RequestRecordScalarWhereInput>
  }

  export type StudentCreateNestedOneWithoutBorrowingRecordsInput = {
    create?: XOR<StudentCreateWithoutBorrowingRecordsInput, StudentUncheckedCreateWithoutBorrowingRecordsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutBorrowingRecordsInput
    connect?: StudentWhereUniqueInput
  }

  export type BookCreateNestedOneWithoutBorrowingRecordsInput = {
    create?: XOR<BookCreateWithoutBorrowingRecordsInput, BookUncheckedCreateWithoutBorrowingRecordsInput>
    connectOrCreate?: BookCreateOrConnectWithoutBorrowingRecordsInput
    connect?: BookWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutBorrowingRecordsNestedInput = {
    create?: XOR<StudentCreateWithoutBorrowingRecordsInput, StudentUncheckedCreateWithoutBorrowingRecordsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutBorrowingRecordsInput
    upsert?: StudentUpsertWithoutBorrowingRecordsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<StudentUpdateWithoutBorrowingRecordsInput, StudentUncheckedUpdateWithoutBorrowingRecordsInput>
  }

  export type BookUpdateOneRequiredWithoutBorrowingRecordsNestedInput = {
    create?: XOR<BookCreateWithoutBorrowingRecordsInput, BookUncheckedCreateWithoutBorrowingRecordsInput>
    connectOrCreate?: BookCreateOrConnectWithoutBorrowingRecordsInput
    upsert?: BookUpsertWithoutBorrowingRecordsInput
    connect?: BookWhereUniqueInput
    update?: XOR<BookUpdateWithoutBorrowingRecordsInput, BookUncheckedUpdateWithoutBorrowingRecordsInput>
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type StudentCreateNestedOneWithoutRequestRecordsInput = {
    create?: XOR<StudentCreateWithoutRequestRecordsInput, StudentUncheckedCreateWithoutRequestRecordsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutRequestRecordsInput
    connect?: StudentWhereUniqueInput
  }

  export type BookTitleCreateNestedOneWithoutRequestRecordsInput = {
    create?: XOR<BookTitleCreateWithoutRequestRecordsInput, BookTitleUncheckedCreateWithoutRequestRecordsInput>
    connectOrCreate?: BookTitleCreateOrConnectWithoutRequestRecordsInput
    connect?: BookTitleWhereUniqueInput
  }

  export type LibraryCreateNestedOneWithoutRequestingRecordsInput = {
    create?: XOR<LibraryCreateWithoutRequestingRecordsInput, LibraryUncheckedCreateWithoutRequestingRecordsInput>
    connectOrCreate?: LibraryCreateOrConnectWithoutRequestingRecordsInput
    connect?: LibraryWhereUniqueInput
  }

  export type LibraryCreateNestedOneWithoutRequestedRecordsInput = {
    create?: XOR<LibraryCreateWithoutRequestedRecordsInput, LibraryUncheckedCreateWithoutRequestedRecordsInput>
    connectOrCreate?: LibraryCreateOrConnectWithoutRequestedRecordsInput
    connect?: LibraryWhereUniqueInput
  }

  export type BookCreateNestedOneWithoutRequestRecordsInput = {
    create?: XOR<BookCreateWithoutRequestRecordsInput, BookUncheckedCreateWithoutRequestRecordsInput>
    connectOrCreate?: BookCreateOrConnectWithoutRequestRecordsInput
    connect?: BookWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutRequestRecordsNestedInput = {
    create?: XOR<StudentCreateWithoutRequestRecordsInput, StudentUncheckedCreateWithoutRequestRecordsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutRequestRecordsInput
    upsert?: StudentUpsertWithoutRequestRecordsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<StudentUpdateWithoutRequestRecordsInput, StudentUncheckedUpdateWithoutRequestRecordsInput>
  }

  export type BookTitleUpdateOneRequiredWithoutRequestRecordsNestedInput = {
    create?: XOR<BookTitleCreateWithoutRequestRecordsInput, BookTitleUncheckedCreateWithoutRequestRecordsInput>
    connectOrCreate?: BookTitleCreateOrConnectWithoutRequestRecordsInput
    upsert?: BookTitleUpsertWithoutRequestRecordsInput
    connect?: BookTitleWhereUniqueInput
    update?: XOR<BookTitleUpdateWithoutRequestRecordsInput, BookTitleUncheckedUpdateWithoutRequestRecordsInput>
  }

  export type LibraryUpdateOneRequiredWithoutRequestingRecordsNestedInput = {
    create?: XOR<LibraryCreateWithoutRequestingRecordsInput, LibraryUncheckedCreateWithoutRequestingRecordsInput>
    connectOrCreate?: LibraryCreateOrConnectWithoutRequestingRecordsInput
    upsert?: LibraryUpsertWithoutRequestingRecordsInput
    connect?: LibraryWhereUniqueInput
    update?: XOR<LibraryUpdateWithoutRequestingRecordsInput, LibraryUncheckedUpdateWithoutRequestingRecordsInput>
  }

  export type LibraryUpdateOneRequiredWithoutRequestedRecordsNestedInput = {
    create?: XOR<LibraryCreateWithoutRequestedRecordsInput, LibraryUncheckedCreateWithoutRequestedRecordsInput>
    connectOrCreate?: LibraryCreateOrConnectWithoutRequestedRecordsInput
    upsert?: LibraryUpsertWithoutRequestedRecordsInput
    connect?: LibraryWhereUniqueInput
    update?: XOR<LibraryUpdateWithoutRequestedRecordsInput, LibraryUncheckedUpdateWithoutRequestedRecordsInput>
  }

  export type BookUpdateOneWithoutRequestRecordsNestedInput = {
    create?: XOR<BookCreateWithoutRequestRecordsInput, BookUncheckedCreateWithoutRequestRecordsInput>
    connectOrCreate?: BookCreateOrConnectWithoutRequestRecordsInput
    upsert?: BookUpsertWithoutRequestRecordsInput
    disconnect?: boolean
    delete?: boolean
    connect?: BookWhereUniqueInput
    update?: XOR<BookUpdateWithoutRequestRecordsInput, BookUncheckedUpdateWithoutRequestRecordsInput>
  }

  export type UserRelationCreateNestedManyWithoutFollowingUserInput = {
    create?: XOR<Enumerable<UserRelationCreateWithoutFollowingUserInput>, Enumerable<UserRelationUncheckedCreateWithoutFollowingUserInput>>
    connectOrCreate?: Enumerable<UserRelationCreateOrConnectWithoutFollowingUserInput>
    createMany?: UserRelationCreateManyFollowingUserInputEnvelope
    connect?: Enumerable<UserRelationWhereUniqueInput>
  }

  export type UserRelationCreateNestedManyWithoutFollowedUserInput = {
    create?: XOR<Enumerable<UserRelationCreateWithoutFollowedUserInput>, Enumerable<UserRelationUncheckedCreateWithoutFollowedUserInput>>
    connectOrCreate?: Enumerable<UserRelationCreateOrConnectWithoutFollowedUserInput>
    createMany?: UserRelationCreateManyFollowedUserInputEnvelope
    connect?: Enumerable<UserRelationWhereUniqueInput>
  }

  export type TweetCreateNestedManyWithoutTweetingUserInput = {
    create?: XOR<Enumerable<TweetCreateWithoutTweetingUserInput>, Enumerable<TweetUncheckedCreateWithoutTweetingUserInput>>
    connectOrCreate?: Enumerable<TweetCreateOrConnectWithoutTweetingUserInput>
    createMany?: TweetCreateManyTweetingUserInputEnvelope
    connect?: Enumerable<TweetWhereUniqueInput>
  }

  export type DirectMessageCreateNestedManyWithoutFromUserInput = {
    create?: XOR<Enumerable<DirectMessageCreateWithoutFromUserInput>, Enumerable<DirectMessageUncheckedCreateWithoutFromUserInput>>
    connectOrCreate?: Enumerable<DirectMessageCreateOrConnectWithoutFromUserInput>
    createMany?: DirectMessageCreateManyFromUserInputEnvelope
    connect?: Enumerable<DirectMessageWhereUniqueInput>
  }

  export type DirectMessageCreateNestedManyWithoutToUserInput = {
    create?: XOR<Enumerable<DirectMessageCreateWithoutToUserInput>, Enumerable<DirectMessageUncheckedCreateWithoutToUserInput>>
    connectOrCreate?: Enumerable<DirectMessageCreateOrConnectWithoutToUserInput>
    createMany?: DirectMessageCreateManyToUserInputEnvelope
    connect?: Enumerable<DirectMessageWhereUniqueInput>
  }

  export type UserRelationUncheckedCreateNestedManyWithoutFollowingUserInput = {
    create?: XOR<Enumerable<UserRelationCreateWithoutFollowingUserInput>, Enumerable<UserRelationUncheckedCreateWithoutFollowingUserInput>>
    connectOrCreate?: Enumerable<UserRelationCreateOrConnectWithoutFollowingUserInput>
    createMany?: UserRelationCreateManyFollowingUserInputEnvelope
    connect?: Enumerable<UserRelationWhereUniqueInput>
  }

  export type UserRelationUncheckedCreateNestedManyWithoutFollowedUserInput = {
    create?: XOR<Enumerable<UserRelationCreateWithoutFollowedUserInput>, Enumerable<UserRelationUncheckedCreateWithoutFollowedUserInput>>
    connectOrCreate?: Enumerable<UserRelationCreateOrConnectWithoutFollowedUserInput>
    createMany?: UserRelationCreateManyFollowedUserInputEnvelope
    connect?: Enumerable<UserRelationWhereUniqueInput>
  }

  export type TweetUncheckedCreateNestedManyWithoutTweetingUserInput = {
    create?: XOR<Enumerable<TweetCreateWithoutTweetingUserInput>, Enumerable<TweetUncheckedCreateWithoutTweetingUserInput>>
    connectOrCreate?: Enumerable<TweetCreateOrConnectWithoutTweetingUserInput>
    createMany?: TweetCreateManyTweetingUserInputEnvelope
    connect?: Enumerable<TweetWhereUniqueInput>
  }

  export type DirectMessageUncheckedCreateNestedManyWithoutFromUserInput = {
    create?: XOR<Enumerable<DirectMessageCreateWithoutFromUserInput>, Enumerable<DirectMessageUncheckedCreateWithoutFromUserInput>>
    connectOrCreate?: Enumerable<DirectMessageCreateOrConnectWithoutFromUserInput>
    createMany?: DirectMessageCreateManyFromUserInputEnvelope
    connect?: Enumerable<DirectMessageWhereUniqueInput>
  }

  export type DirectMessageUncheckedCreateNestedManyWithoutToUserInput = {
    create?: XOR<Enumerable<DirectMessageCreateWithoutToUserInput>, Enumerable<DirectMessageUncheckedCreateWithoutToUserInput>>
    connectOrCreate?: Enumerable<DirectMessageCreateOrConnectWithoutToUserInput>
    createMany?: DirectMessageCreateManyToUserInputEnvelope
    connect?: Enumerable<DirectMessageWhereUniqueInput>
  }

  export type UserRelationUpdateManyWithoutFollowingUserNestedInput = {
    create?: XOR<Enumerable<UserRelationCreateWithoutFollowingUserInput>, Enumerable<UserRelationUncheckedCreateWithoutFollowingUserInput>>
    connectOrCreate?: Enumerable<UserRelationCreateOrConnectWithoutFollowingUserInput>
    upsert?: Enumerable<UserRelationUpsertWithWhereUniqueWithoutFollowingUserInput>
    createMany?: UserRelationCreateManyFollowingUserInputEnvelope
    set?: Enumerable<UserRelationWhereUniqueInput>
    disconnect?: Enumerable<UserRelationWhereUniqueInput>
    delete?: Enumerable<UserRelationWhereUniqueInput>
    connect?: Enumerable<UserRelationWhereUniqueInput>
    update?: Enumerable<UserRelationUpdateWithWhereUniqueWithoutFollowingUserInput>
    updateMany?: Enumerable<UserRelationUpdateManyWithWhereWithoutFollowingUserInput>
    deleteMany?: Enumerable<UserRelationScalarWhereInput>
  }

  export type UserRelationUpdateManyWithoutFollowedUserNestedInput = {
    create?: XOR<Enumerable<UserRelationCreateWithoutFollowedUserInput>, Enumerable<UserRelationUncheckedCreateWithoutFollowedUserInput>>
    connectOrCreate?: Enumerable<UserRelationCreateOrConnectWithoutFollowedUserInput>
    upsert?: Enumerable<UserRelationUpsertWithWhereUniqueWithoutFollowedUserInput>
    createMany?: UserRelationCreateManyFollowedUserInputEnvelope
    set?: Enumerable<UserRelationWhereUniqueInput>
    disconnect?: Enumerable<UserRelationWhereUniqueInput>
    delete?: Enumerable<UserRelationWhereUniqueInput>
    connect?: Enumerable<UserRelationWhereUniqueInput>
    update?: Enumerable<UserRelationUpdateWithWhereUniqueWithoutFollowedUserInput>
    updateMany?: Enumerable<UserRelationUpdateManyWithWhereWithoutFollowedUserInput>
    deleteMany?: Enumerable<UserRelationScalarWhereInput>
  }

  export type TweetUpdateManyWithoutTweetingUserNestedInput = {
    create?: XOR<Enumerable<TweetCreateWithoutTweetingUserInput>, Enumerable<TweetUncheckedCreateWithoutTweetingUserInput>>
    connectOrCreate?: Enumerable<TweetCreateOrConnectWithoutTweetingUserInput>
    upsert?: Enumerable<TweetUpsertWithWhereUniqueWithoutTweetingUserInput>
    createMany?: TweetCreateManyTweetingUserInputEnvelope
    set?: Enumerable<TweetWhereUniqueInput>
    disconnect?: Enumerable<TweetWhereUniqueInput>
    delete?: Enumerable<TweetWhereUniqueInput>
    connect?: Enumerable<TweetWhereUniqueInput>
    update?: Enumerable<TweetUpdateWithWhereUniqueWithoutTweetingUserInput>
    updateMany?: Enumerable<TweetUpdateManyWithWhereWithoutTweetingUserInput>
    deleteMany?: Enumerable<TweetScalarWhereInput>
  }

  export type DirectMessageUpdateManyWithoutFromUserNestedInput = {
    create?: XOR<Enumerable<DirectMessageCreateWithoutFromUserInput>, Enumerable<DirectMessageUncheckedCreateWithoutFromUserInput>>
    connectOrCreate?: Enumerable<DirectMessageCreateOrConnectWithoutFromUserInput>
    upsert?: Enumerable<DirectMessageUpsertWithWhereUniqueWithoutFromUserInput>
    createMany?: DirectMessageCreateManyFromUserInputEnvelope
    set?: Enumerable<DirectMessageWhereUniqueInput>
    disconnect?: Enumerable<DirectMessageWhereUniqueInput>
    delete?: Enumerable<DirectMessageWhereUniqueInput>
    connect?: Enumerable<DirectMessageWhereUniqueInput>
    update?: Enumerable<DirectMessageUpdateWithWhereUniqueWithoutFromUserInput>
    updateMany?: Enumerable<DirectMessageUpdateManyWithWhereWithoutFromUserInput>
    deleteMany?: Enumerable<DirectMessageScalarWhereInput>
  }

  export type DirectMessageUpdateManyWithoutToUserNestedInput = {
    create?: XOR<Enumerable<DirectMessageCreateWithoutToUserInput>, Enumerable<DirectMessageUncheckedCreateWithoutToUserInput>>
    connectOrCreate?: Enumerable<DirectMessageCreateOrConnectWithoutToUserInput>
    upsert?: Enumerable<DirectMessageUpsertWithWhereUniqueWithoutToUserInput>
    createMany?: DirectMessageCreateManyToUserInputEnvelope
    set?: Enumerable<DirectMessageWhereUniqueInput>
    disconnect?: Enumerable<DirectMessageWhereUniqueInput>
    delete?: Enumerable<DirectMessageWhereUniqueInput>
    connect?: Enumerable<DirectMessageWhereUniqueInput>
    update?: Enumerable<DirectMessageUpdateWithWhereUniqueWithoutToUserInput>
    updateMany?: Enumerable<DirectMessageUpdateManyWithWhereWithoutToUserInput>
    deleteMany?: Enumerable<DirectMessageScalarWhereInput>
  }

  export type UserRelationUncheckedUpdateManyWithoutFollowingUserNestedInput = {
    create?: XOR<Enumerable<UserRelationCreateWithoutFollowingUserInput>, Enumerable<UserRelationUncheckedCreateWithoutFollowingUserInput>>
    connectOrCreate?: Enumerable<UserRelationCreateOrConnectWithoutFollowingUserInput>
    upsert?: Enumerable<UserRelationUpsertWithWhereUniqueWithoutFollowingUserInput>
    createMany?: UserRelationCreateManyFollowingUserInputEnvelope
    set?: Enumerable<UserRelationWhereUniqueInput>
    disconnect?: Enumerable<UserRelationWhereUniqueInput>
    delete?: Enumerable<UserRelationWhereUniqueInput>
    connect?: Enumerable<UserRelationWhereUniqueInput>
    update?: Enumerable<UserRelationUpdateWithWhereUniqueWithoutFollowingUserInput>
    updateMany?: Enumerable<UserRelationUpdateManyWithWhereWithoutFollowingUserInput>
    deleteMany?: Enumerable<UserRelationScalarWhereInput>
  }

  export type UserRelationUncheckedUpdateManyWithoutFollowedUserNestedInput = {
    create?: XOR<Enumerable<UserRelationCreateWithoutFollowedUserInput>, Enumerable<UserRelationUncheckedCreateWithoutFollowedUserInput>>
    connectOrCreate?: Enumerable<UserRelationCreateOrConnectWithoutFollowedUserInput>
    upsert?: Enumerable<UserRelationUpsertWithWhereUniqueWithoutFollowedUserInput>
    createMany?: UserRelationCreateManyFollowedUserInputEnvelope
    set?: Enumerable<UserRelationWhereUniqueInput>
    disconnect?: Enumerable<UserRelationWhereUniqueInput>
    delete?: Enumerable<UserRelationWhereUniqueInput>
    connect?: Enumerable<UserRelationWhereUniqueInput>
    update?: Enumerable<UserRelationUpdateWithWhereUniqueWithoutFollowedUserInput>
    updateMany?: Enumerable<UserRelationUpdateManyWithWhereWithoutFollowedUserInput>
    deleteMany?: Enumerable<UserRelationScalarWhereInput>
  }

  export type TweetUncheckedUpdateManyWithoutTweetingUserNestedInput = {
    create?: XOR<Enumerable<TweetCreateWithoutTweetingUserInput>, Enumerable<TweetUncheckedCreateWithoutTweetingUserInput>>
    connectOrCreate?: Enumerable<TweetCreateOrConnectWithoutTweetingUserInput>
    upsert?: Enumerable<TweetUpsertWithWhereUniqueWithoutTweetingUserInput>
    createMany?: TweetCreateManyTweetingUserInputEnvelope
    set?: Enumerable<TweetWhereUniqueInput>
    disconnect?: Enumerable<TweetWhereUniqueInput>
    delete?: Enumerable<TweetWhereUniqueInput>
    connect?: Enumerable<TweetWhereUniqueInput>
    update?: Enumerable<TweetUpdateWithWhereUniqueWithoutTweetingUserInput>
    updateMany?: Enumerable<TweetUpdateManyWithWhereWithoutTweetingUserInput>
    deleteMany?: Enumerable<TweetScalarWhereInput>
  }

  export type DirectMessageUncheckedUpdateManyWithoutFromUserNestedInput = {
    create?: XOR<Enumerable<DirectMessageCreateWithoutFromUserInput>, Enumerable<DirectMessageUncheckedCreateWithoutFromUserInput>>
    connectOrCreate?: Enumerable<DirectMessageCreateOrConnectWithoutFromUserInput>
    upsert?: Enumerable<DirectMessageUpsertWithWhereUniqueWithoutFromUserInput>
    createMany?: DirectMessageCreateManyFromUserInputEnvelope
    set?: Enumerable<DirectMessageWhereUniqueInput>
    disconnect?: Enumerable<DirectMessageWhereUniqueInput>
    delete?: Enumerable<DirectMessageWhereUniqueInput>
    connect?: Enumerable<DirectMessageWhereUniqueInput>
    update?: Enumerable<DirectMessageUpdateWithWhereUniqueWithoutFromUserInput>
    updateMany?: Enumerable<DirectMessageUpdateManyWithWhereWithoutFromUserInput>
    deleteMany?: Enumerable<DirectMessageScalarWhereInput>
  }

  export type DirectMessageUncheckedUpdateManyWithoutToUserNestedInput = {
    create?: XOR<Enumerable<DirectMessageCreateWithoutToUserInput>, Enumerable<DirectMessageUncheckedCreateWithoutToUserInput>>
    connectOrCreate?: Enumerable<DirectMessageCreateOrConnectWithoutToUserInput>
    upsert?: Enumerable<DirectMessageUpsertWithWhereUniqueWithoutToUserInput>
    createMany?: DirectMessageCreateManyToUserInputEnvelope
    set?: Enumerable<DirectMessageWhereUniqueInput>
    disconnect?: Enumerable<DirectMessageWhereUniqueInput>
    delete?: Enumerable<DirectMessageWhereUniqueInput>
    connect?: Enumerable<DirectMessageWhereUniqueInput>
    update?: Enumerable<DirectMessageUpdateWithWhereUniqueWithoutToUserInput>
    updateMany?: Enumerable<DirectMessageUpdateManyWithWhereWithoutToUserInput>
    deleteMany?: Enumerable<DirectMessageScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutFollowingUserRelationsInput = {
    create?: XOR<UserCreateWithoutFollowingUserRelationsInput, UserUncheckedCreateWithoutFollowingUserRelationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowingUserRelationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFollowedUserRelationsInput = {
    create?: XOR<UserCreateWithoutFollowedUserRelationsInput, UserUncheckedCreateWithoutFollowedUserRelationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowedUserRelationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFollowingUserRelationsNestedInput = {
    create?: XOR<UserCreateWithoutFollowingUserRelationsInput, UserUncheckedCreateWithoutFollowingUserRelationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowingUserRelationsInput
    upsert?: UserUpsertWithoutFollowingUserRelationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutFollowingUserRelationsInput, UserUncheckedUpdateWithoutFollowingUserRelationsInput>
  }

  export type UserUpdateOneRequiredWithoutFollowedUserRelationsNestedInput = {
    create?: XOR<UserCreateWithoutFollowedUserRelationsInput, UserUncheckedCreateWithoutFollowedUserRelationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowedUserRelationsInput
    upsert?: UserUpsertWithoutFollowedUserRelationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutFollowedUserRelationsInput, UserUncheckedUpdateWithoutFollowedUserRelationsInput>
  }

  export type UserCreateNestedOneWithoutTweetsInput = {
    create?: XOR<UserCreateWithoutTweetsInput, UserUncheckedCreateWithoutTweetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTweetsInput
    connect?: UserWhereUniqueInput
  }

  export type TweetCreateNestedOneWithoutChildTweetsInput = {
    create?: XOR<TweetCreateWithoutChildTweetsInput, TweetUncheckedCreateWithoutChildTweetsInput>
    connectOrCreate?: TweetCreateOrConnectWithoutChildTweetsInput
    connect?: TweetWhereUniqueInput
  }

  export type TweetCreateNestedManyWithoutParentTweetInput = {
    create?: XOR<Enumerable<TweetCreateWithoutParentTweetInput>, Enumerable<TweetUncheckedCreateWithoutParentTweetInput>>
    connectOrCreate?: Enumerable<TweetCreateOrConnectWithoutParentTweetInput>
    createMany?: TweetCreateManyParentTweetInputEnvelope
    connect?: Enumerable<TweetWhereUniqueInput>
  }

  export type HashTagCreateNestedManyWithoutIsInTweetsInput = {
    create?: XOR<Enumerable<HashTagCreateWithoutIsInTweetsInput>, Enumerable<HashTagUncheckedCreateWithoutIsInTweetsInput>>
    connectOrCreate?: Enumerable<HashTagCreateOrConnectWithoutIsInTweetsInput>
    connect?: Enumerable<HashTagWhereUniqueInput>
  }

  export type TweetUncheckedCreateNestedManyWithoutParentTweetInput = {
    create?: XOR<Enumerable<TweetCreateWithoutParentTweetInput>, Enumerable<TweetUncheckedCreateWithoutParentTweetInput>>
    connectOrCreate?: Enumerable<TweetCreateOrConnectWithoutParentTweetInput>
    createMany?: TweetCreateManyParentTweetInputEnvelope
    connect?: Enumerable<TweetWhereUniqueInput>
  }

  export type HashTagUncheckedCreateNestedManyWithoutIsInTweetsInput = {
    create?: XOR<Enumerable<HashTagCreateWithoutIsInTweetsInput>, Enumerable<HashTagUncheckedCreateWithoutIsInTweetsInput>>
    connectOrCreate?: Enumerable<HashTagCreateOrConnectWithoutIsInTweetsInput>
    connect?: Enumerable<HashTagWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutTweetsNestedInput = {
    create?: XOR<UserCreateWithoutTweetsInput, UserUncheckedCreateWithoutTweetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTweetsInput
    upsert?: UserUpsertWithoutTweetsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutTweetsInput, UserUncheckedUpdateWithoutTweetsInput>
  }

  export type TweetUpdateOneWithoutChildTweetsNestedInput = {
    create?: XOR<TweetCreateWithoutChildTweetsInput, TweetUncheckedCreateWithoutChildTweetsInput>
    connectOrCreate?: TweetCreateOrConnectWithoutChildTweetsInput
    upsert?: TweetUpsertWithoutChildTweetsInput
    disconnect?: boolean
    delete?: boolean
    connect?: TweetWhereUniqueInput
    update?: XOR<TweetUpdateWithoutChildTweetsInput, TweetUncheckedUpdateWithoutChildTweetsInput>
  }

  export type TweetUpdateManyWithoutParentTweetNestedInput = {
    create?: XOR<Enumerable<TweetCreateWithoutParentTweetInput>, Enumerable<TweetUncheckedCreateWithoutParentTweetInput>>
    connectOrCreate?: Enumerable<TweetCreateOrConnectWithoutParentTweetInput>
    upsert?: Enumerable<TweetUpsertWithWhereUniqueWithoutParentTweetInput>
    createMany?: TweetCreateManyParentTweetInputEnvelope
    set?: Enumerable<TweetWhereUniqueInput>
    disconnect?: Enumerable<TweetWhereUniqueInput>
    delete?: Enumerable<TweetWhereUniqueInput>
    connect?: Enumerable<TweetWhereUniqueInput>
    update?: Enumerable<TweetUpdateWithWhereUniqueWithoutParentTweetInput>
    updateMany?: Enumerable<TweetUpdateManyWithWhereWithoutParentTweetInput>
    deleteMany?: Enumerable<TweetScalarWhereInput>
  }

  export type HashTagUpdateManyWithoutIsInTweetsNestedInput = {
    create?: XOR<Enumerable<HashTagCreateWithoutIsInTweetsInput>, Enumerable<HashTagUncheckedCreateWithoutIsInTweetsInput>>
    connectOrCreate?: Enumerable<HashTagCreateOrConnectWithoutIsInTweetsInput>
    upsert?: Enumerable<HashTagUpsertWithWhereUniqueWithoutIsInTweetsInput>
    set?: Enumerable<HashTagWhereUniqueInput>
    disconnect?: Enumerable<HashTagWhereUniqueInput>
    delete?: Enumerable<HashTagWhereUniqueInput>
    connect?: Enumerable<HashTagWhereUniqueInput>
    update?: Enumerable<HashTagUpdateWithWhereUniqueWithoutIsInTweetsInput>
    updateMany?: Enumerable<HashTagUpdateManyWithWhereWithoutIsInTweetsInput>
    deleteMany?: Enumerable<HashTagScalarWhereInput>
  }

  export type TweetUncheckedUpdateManyWithoutParentTweetNestedInput = {
    create?: XOR<Enumerable<TweetCreateWithoutParentTweetInput>, Enumerable<TweetUncheckedCreateWithoutParentTweetInput>>
    connectOrCreate?: Enumerable<TweetCreateOrConnectWithoutParentTweetInput>
    upsert?: Enumerable<TweetUpsertWithWhereUniqueWithoutParentTweetInput>
    createMany?: TweetCreateManyParentTweetInputEnvelope
    set?: Enumerable<TweetWhereUniqueInput>
    disconnect?: Enumerable<TweetWhereUniqueInput>
    delete?: Enumerable<TweetWhereUniqueInput>
    connect?: Enumerable<TweetWhereUniqueInput>
    update?: Enumerable<TweetUpdateWithWhereUniqueWithoutParentTweetInput>
    updateMany?: Enumerable<TweetUpdateManyWithWhereWithoutParentTweetInput>
    deleteMany?: Enumerable<TweetScalarWhereInput>
  }

  export type HashTagUncheckedUpdateManyWithoutIsInTweetsNestedInput = {
    create?: XOR<Enumerable<HashTagCreateWithoutIsInTweetsInput>, Enumerable<HashTagUncheckedCreateWithoutIsInTweetsInput>>
    connectOrCreate?: Enumerable<HashTagCreateOrConnectWithoutIsInTweetsInput>
    upsert?: Enumerable<HashTagUpsertWithWhereUniqueWithoutIsInTweetsInput>
    set?: Enumerable<HashTagWhereUniqueInput>
    disconnect?: Enumerable<HashTagWhereUniqueInput>
    delete?: Enumerable<HashTagWhereUniqueInput>
    connect?: Enumerable<HashTagWhereUniqueInput>
    update?: Enumerable<HashTagUpdateWithWhereUniqueWithoutIsInTweetsInput>
    updateMany?: Enumerable<HashTagUpdateManyWithWhereWithoutIsInTweetsInput>
    deleteMany?: Enumerable<HashTagScalarWhereInput>
  }

  export type TweetCreateNestedManyWithoutHashTagsInput = {
    create?: XOR<Enumerable<TweetCreateWithoutHashTagsInput>, Enumerable<TweetUncheckedCreateWithoutHashTagsInput>>
    connectOrCreate?: Enumerable<TweetCreateOrConnectWithoutHashTagsInput>
    connect?: Enumerable<TweetWhereUniqueInput>
  }

  export type TweetUncheckedCreateNestedManyWithoutHashTagsInput = {
    create?: XOR<Enumerable<TweetCreateWithoutHashTagsInput>, Enumerable<TweetUncheckedCreateWithoutHashTagsInput>>
    connectOrCreate?: Enumerable<TweetCreateOrConnectWithoutHashTagsInput>
    connect?: Enumerable<TweetWhereUniqueInput>
  }

  export type TweetUpdateManyWithoutHashTagsNestedInput = {
    create?: XOR<Enumerable<TweetCreateWithoutHashTagsInput>, Enumerable<TweetUncheckedCreateWithoutHashTagsInput>>
    connectOrCreate?: Enumerable<TweetCreateOrConnectWithoutHashTagsInput>
    upsert?: Enumerable<TweetUpsertWithWhereUniqueWithoutHashTagsInput>
    set?: Enumerable<TweetWhereUniqueInput>
    disconnect?: Enumerable<TweetWhereUniqueInput>
    delete?: Enumerable<TweetWhereUniqueInput>
    connect?: Enumerable<TweetWhereUniqueInput>
    update?: Enumerable<TweetUpdateWithWhereUniqueWithoutHashTagsInput>
    updateMany?: Enumerable<TweetUpdateManyWithWhereWithoutHashTagsInput>
    deleteMany?: Enumerable<TweetScalarWhereInput>
  }

  export type TweetUncheckedUpdateManyWithoutHashTagsNestedInput = {
    create?: XOR<Enumerable<TweetCreateWithoutHashTagsInput>, Enumerable<TweetUncheckedCreateWithoutHashTagsInput>>
    connectOrCreate?: Enumerable<TweetCreateOrConnectWithoutHashTagsInput>
    upsert?: Enumerable<TweetUpsertWithWhereUniqueWithoutHashTagsInput>
    set?: Enumerable<TweetWhereUniqueInput>
    disconnect?: Enumerable<TweetWhereUniqueInput>
    delete?: Enumerable<TweetWhereUniqueInput>
    connect?: Enumerable<TweetWhereUniqueInput>
    update?: Enumerable<TweetUpdateWithWhereUniqueWithoutHashTagsInput>
    updateMany?: Enumerable<TweetUpdateManyWithWhereWithoutHashTagsInput>
    deleteMany?: Enumerable<TweetScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutDirectMessagesFromInput = {
    create?: XOR<UserCreateWithoutDirectMessagesFromInput, UserUncheckedCreateWithoutDirectMessagesFromInput>
    connectOrCreate?: UserCreateOrConnectWithoutDirectMessagesFromInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDirectMessagesToInput = {
    create?: XOR<UserCreateWithoutDirectMessagesToInput, UserUncheckedCreateWithoutDirectMessagesToInput>
    connectOrCreate?: UserCreateOrConnectWithoutDirectMessagesToInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDirectMessagesFromNestedInput = {
    create?: XOR<UserCreateWithoutDirectMessagesFromInput, UserUncheckedCreateWithoutDirectMessagesFromInput>
    connectOrCreate?: UserCreateOrConnectWithoutDirectMessagesFromInput
    upsert?: UserUpsertWithoutDirectMessagesFromInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutDirectMessagesFromInput, UserUncheckedUpdateWithoutDirectMessagesFromInput>
  }

  export type UserUpdateOneRequiredWithoutDirectMessagesToNestedInput = {
    create?: XOR<UserCreateWithoutDirectMessagesToInput, UserUncheckedCreateWithoutDirectMessagesToInput>
    connectOrCreate?: UserCreateOrConnectWithoutDirectMessagesToInput
    upsert?: UserUpsertWithoutDirectMessagesToInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutDirectMessagesToInput, UserUncheckedUpdateWithoutDirectMessagesToInput>
  }

  export type ChannelCreateNestedManyWithoutAdminUsersInput = {
    create?: XOR<Enumerable<ChannelCreateWithoutAdminUsersInput>, Enumerable<ChannelUncheckedCreateWithoutAdminUsersInput>>
    connectOrCreate?: Enumerable<ChannelCreateOrConnectWithoutAdminUsersInput>
    connect?: Enumerable<ChannelWhereUniqueInput>
  }

  export type UserToChannelwithRoleCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserToChannelwithRoleCreateWithoutUserInput>, Enumerable<UserToChannelwithRoleUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserToChannelwithRoleCreateOrConnectWithoutUserInput>
    createMany?: UserToChannelwithRoleCreateManyUserInputEnvelope
    connect?: Enumerable<UserToChannelwithRoleWhereUniqueInput>
  }

  export type ChannelCreateNestedManyWithoutSubscribedUsersInput = {
    create?: XOR<Enumerable<ChannelCreateWithoutSubscribedUsersInput>, Enumerable<ChannelUncheckedCreateWithoutSubscribedUsersInput>>
    connectOrCreate?: Enumerable<ChannelCreateOrConnectWithoutSubscribedUsersInput>
    connect?: Enumerable<ChannelWhereUniqueInput>
  }

  export type VideoCreateNestedManyWithoutReactedByYouTubeUsersInput = {
    create?: XOR<Enumerable<VideoCreateWithoutReactedByYouTubeUsersInput>, Enumerable<VideoUncheckedCreateWithoutReactedByYouTubeUsersInput>>
    connectOrCreate?: Enumerable<VideoCreateOrConnectWithoutReactedByYouTubeUsersInput>
    connect?: Enumerable<VideoWhereUniqueInput>
  }

  export type UserToVideoWithReactionCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserToVideoWithReactionCreateWithoutUserInput>, Enumerable<UserToVideoWithReactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserToVideoWithReactionCreateOrConnectWithoutUserInput>
    createMany?: UserToVideoWithReactionCreateManyUserInputEnvelope
    connect?: Enumerable<UserToVideoWithReactionWhereUniqueInput>
  }

  export type VideoCommentCreateNestedManyWithoutCommentingUserInput = {
    create?: XOR<Enumerable<VideoCommentCreateWithoutCommentingUserInput>, Enumerable<VideoCommentUncheckedCreateWithoutCommentingUserInput>>
    connectOrCreate?: Enumerable<VideoCommentCreateOrConnectWithoutCommentingUserInput>
    createMany?: VideoCommentCreateManyCommentingUserInputEnvelope
    connect?: Enumerable<VideoCommentWhereUniqueInput>
  }

  export type ChannelUncheckedCreateNestedManyWithoutAdminUsersInput = {
    create?: XOR<Enumerable<ChannelCreateWithoutAdminUsersInput>, Enumerable<ChannelUncheckedCreateWithoutAdminUsersInput>>
    connectOrCreate?: Enumerable<ChannelCreateOrConnectWithoutAdminUsersInput>
    connect?: Enumerable<ChannelWhereUniqueInput>
  }

  export type UserToChannelwithRoleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserToChannelwithRoleCreateWithoutUserInput>, Enumerable<UserToChannelwithRoleUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserToChannelwithRoleCreateOrConnectWithoutUserInput>
    createMany?: UserToChannelwithRoleCreateManyUserInputEnvelope
    connect?: Enumerable<UserToChannelwithRoleWhereUniqueInput>
  }

  export type ChannelUncheckedCreateNestedManyWithoutSubscribedUsersInput = {
    create?: XOR<Enumerable<ChannelCreateWithoutSubscribedUsersInput>, Enumerable<ChannelUncheckedCreateWithoutSubscribedUsersInput>>
    connectOrCreate?: Enumerable<ChannelCreateOrConnectWithoutSubscribedUsersInput>
    connect?: Enumerable<ChannelWhereUniqueInput>
  }

  export type VideoUncheckedCreateNestedManyWithoutReactedByYouTubeUsersInput = {
    create?: XOR<Enumerable<VideoCreateWithoutReactedByYouTubeUsersInput>, Enumerable<VideoUncheckedCreateWithoutReactedByYouTubeUsersInput>>
    connectOrCreate?: Enumerable<VideoCreateOrConnectWithoutReactedByYouTubeUsersInput>
    connect?: Enumerable<VideoWhereUniqueInput>
  }

  export type UserToVideoWithReactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserToVideoWithReactionCreateWithoutUserInput>, Enumerable<UserToVideoWithReactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserToVideoWithReactionCreateOrConnectWithoutUserInput>
    createMany?: UserToVideoWithReactionCreateManyUserInputEnvelope
    connect?: Enumerable<UserToVideoWithReactionWhereUniqueInput>
  }

  export type VideoCommentUncheckedCreateNestedManyWithoutCommentingUserInput = {
    create?: XOR<Enumerable<VideoCommentCreateWithoutCommentingUserInput>, Enumerable<VideoCommentUncheckedCreateWithoutCommentingUserInput>>
    connectOrCreate?: Enumerable<VideoCommentCreateOrConnectWithoutCommentingUserInput>
    createMany?: VideoCommentCreateManyCommentingUserInputEnvelope
    connect?: Enumerable<VideoCommentWhereUniqueInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type ChannelUpdateManyWithoutAdminUsersNestedInput = {
    create?: XOR<Enumerable<ChannelCreateWithoutAdminUsersInput>, Enumerable<ChannelUncheckedCreateWithoutAdminUsersInput>>
    connectOrCreate?: Enumerable<ChannelCreateOrConnectWithoutAdminUsersInput>
    upsert?: Enumerable<ChannelUpsertWithWhereUniqueWithoutAdminUsersInput>
    set?: Enumerable<ChannelWhereUniqueInput>
    disconnect?: Enumerable<ChannelWhereUniqueInput>
    delete?: Enumerable<ChannelWhereUniqueInput>
    connect?: Enumerable<ChannelWhereUniqueInput>
    update?: Enumerable<ChannelUpdateWithWhereUniqueWithoutAdminUsersInput>
    updateMany?: Enumerable<ChannelUpdateManyWithWhereWithoutAdminUsersInput>
    deleteMany?: Enumerable<ChannelScalarWhereInput>
  }

  export type UserToChannelwithRoleUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserToChannelwithRoleCreateWithoutUserInput>, Enumerable<UserToChannelwithRoleUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserToChannelwithRoleCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserToChannelwithRoleUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserToChannelwithRoleCreateManyUserInputEnvelope
    set?: Enumerable<UserToChannelwithRoleWhereUniqueInput>
    disconnect?: Enumerable<UserToChannelwithRoleWhereUniqueInput>
    delete?: Enumerable<UserToChannelwithRoleWhereUniqueInput>
    connect?: Enumerable<UserToChannelwithRoleWhereUniqueInput>
    update?: Enumerable<UserToChannelwithRoleUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserToChannelwithRoleUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserToChannelwithRoleScalarWhereInput>
  }

  export type ChannelUpdateManyWithoutSubscribedUsersNestedInput = {
    create?: XOR<Enumerable<ChannelCreateWithoutSubscribedUsersInput>, Enumerable<ChannelUncheckedCreateWithoutSubscribedUsersInput>>
    connectOrCreate?: Enumerable<ChannelCreateOrConnectWithoutSubscribedUsersInput>
    upsert?: Enumerable<ChannelUpsertWithWhereUniqueWithoutSubscribedUsersInput>
    set?: Enumerable<ChannelWhereUniqueInput>
    disconnect?: Enumerable<ChannelWhereUniqueInput>
    delete?: Enumerable<ChannelWhereUniqueInput>
    connect?: Enumerable<ChannelWhereUniqueInput>
    update?: Enumerable<ChannelUpdateWithWhereUniqueWithoutSubscribedUsersInput>
    updateMany?: Enumerable<ChannelUpdateManyWithWhereWithoutSubscribedUsersInput>
    deleteMany?: Enumerable<ChannelScalarWhereInput>
  }

  export type VideoUpdateManyWithoutReactedByYouTubeUsersNestedInput = {
    create?: XOR<Enumerable<VideoCreateWithoutReactedByYouTubeUsersInput>, Enumerable<VideoUncheckedCreateWithoutReactedByYouTubeUsersInput>>
    connectOrCreate?: Enumerable<VideoCreateOrConnectWithoutReactedByYouTubeUsersInput>
    upsert?: Enumerable<VideoUpsertWithWhereUniqueWithoutReactedByYouTubeUsersInput>
    set?: Enumerable<VideoWhereUniqueInput>
    disconnect?: Enumerable<VideoWhereUniqueInput>
    delete?: Enumerable<VideoWhereUniqueInput>
    connect?: Enumerable<VideoWhereUniqueInput>
    update?: Enumerable<VideoUpdateWithWhereUniqueWithoutReactedByYouTubeUsersInput>
    updateMany?: Enumerable<VideoUpdateManyWithWhereWithoutReactedByYouTubeUsersInput>
    deleteMany?: Enumerable<VideoScalarWhereInput>
  }

  export type UserToVideoWithReactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserToVideoWithReactionCreateWithoutUserInput>, Enumerable<UserToVideoWithReactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserToVideoWithReactionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserToVideoWithReactionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserToVideoWithReactionCreateManyUserInputEnvelope
    set?: Enumerable<UserToVideoWithReactionWhereUniqueInput>
    disconnect?: Enumerable<UserToVideoWithReactionWhereUniqueInput>
    delete?: Enumerable<UserToVideoWithReactionWhereUniqueInput>
    connect?: Enumerable<UserToVideoWithReactionWhereUniqueInput>
    update?: Enumerable<UserToVideoWithReactionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserToVideoWithReactionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserToVideoWithReactionScalarWhereInput>
  }

  export type VideoCommentUpdateManyWithoutCommentingUserNestedInput = {
    create?: XOR<Enumerable<VideoCommentCreateWithoutCommentingUserInput>, Enumerable<VideoCommentUncheckedCreateWithoutCommentingUserInput>>
    connectOrCreate?: Enumerable<VideoCommentCreateOrConnectWithoutCommentingUserInput>
    upsert?: Enumerable<VideoCommentUpsertWithWhereUniqueWithoutCommentingUserInput>
    createMany?: VideoCommentCreateManyCommentingUserInputEnvelope
    set?: Enumerable<VideoCommentWhereUniqueInput>
    disconnect?: Enumerable<VideoCommentWhereUniqueInput>
    delete?: Enumerable<VideoCommentWhereUniqueInput>
    connect?: Enumerable<VideoCommentWhereUniqueInput>
    update?: Enumerable<VideoCommentUpdateWithWhereUniqueWithoutCommentingUserInput>
    updateMany?: Enumerable<VideoCommentUpdateManyWithWhereWithoutCommentingUserInput>
    deleteMany?: Enumerable<VideoCommentScalarWhereInput>
  }

  export type ChannelUncheckedUpdateManyWithoutAdminUsersNestedInput = {
    create?: XOR<Enumerable<ChannelCreateWithoutAdminUsersInput>, Enumerable<ChannelUncheckedCreateWithoutAdminUsersInput>>
    connectOrCreate?: Enumerable<ChannelCreateOrConnectWithoutAdminUsersInput>
    upsert?: Enumerable<ChannelUpsertWithWhereUniqueWithoutAdminUsersInput>
    set?: Enumerable<ChannelWhereUniqueInput>
    disconnect?: Enumerable<ChannelWhereUniqueInput>
    delete?: Enumerable<ChannelWhereUniqueInput>
    connect?: Enumerable<ChannelWhereUniqueInput>
    update?: Enumerable<ChannelUpdateWithWhereUniqueWithoutAdminUsersInput>
    updateMany?: Enumerable<ChannelUpdateManyWithWhereWithoutAdminUsersInput>
    deleteMany?: Enumerable<ChannelScalarWhereInput>
  }

  export type UserToChannelwithRoleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserToChannelwithRoleCreateWithoutUserInput>, Enumerable<UserToChannelwithRoleUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserToChannelwithRoleCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserToChannelwithRoleUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserToChannelwithRoleCreateManyUserInputEnvelope
    set?: Enumerable<UserToChannelwithRoleWhereUniqueInput>
    disconnect?: Enumerable<UserToChannelwithRoleWhereUniqueInput>
    delete?: Enumerable<UserToChannelwithRoleWhereUniqueInput>
    connect?: Enumerable<UserToChannelwithRoleWhereUniqueInput>
    update?: Enumerable<UserToChannelwithRoleUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserToChannelwithRoleUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserToChannelwithRoleScalarWhereInput>
  }

  export type ChannelUncheckedUpdateManyWithoutSubscribedUsersNestedInput = {
    create?: XOR<Enumerable<ChannelCreateWithoutSubscribedUsersInput>, Enumerable<ChannelUncheckedCreateWithoutSubscribedUsersInput>>
    connectOrCreate?: Enumerable<ChannelCreateOrConnectWithoutSubscribedUsersInput>
    upsert?: Enumerable<ChannelUpsertWithWhereUniqueWithoutSubscribedUsersInput>
    set?: Enumerable<ChannelWhereUniqueInput>
    disconnect?: Enumerable<ChannelWhereUniqueInput>
    delete?: Enumerable<ChannelWhereUniqueInput>
    connect?: Enumerable<ChannelWhereUniqueInput>
    update?: Enumerable<ChannelUpdateWithWhereUniqueWithoutSubscribedUsersInput>
    updateMany?: Enumerable<ChannelUpdateManyWithWhereWithoutSubscribedUsersInput>
    deleteMany?: Enumerable<ChannelScalarWhereInput>
  }

  export type VideoUncheckedUpdateManyWithoutReactedByYouTubeUsersNestedInput = {
    create?: XOR<Enumerable<VideoCreateWithoutReactedByYouTubeUsersInput>, Enumerable<VideoUncheckedCreateWithoutReactedByYouTubeUsersInput>>
    connectOrCreate?: Enumerable<VideoCreateOrConnectWithoutReactedByYouTubeUsersInput>
    upsert?: Enumerable<VideoUpsertWithWhereUniqueWithoutReactedByYouTubeUsersInput>
    set?: Enumerable<VideoWhereUniqueInput>
    disconnect?: Enumerable<VideoWhereUniqueInput>
    delete?: Enumerable<VideoWhereUniqueInput>
    connect?: Enumerable<VideoWhereUniqueInput>
    update?: Enumerable<VideoUpdateWithWhereUniqueWithoutReactedByYouTubeUsersInput>
    updateMany?: Enumerable<VideoUpdateManyWithWhereWithoutReactedByYouTubeUsersInput>
    deleteMany?: Enumerable<VideoScalarWhereInput>
  }

  export type UserToVideoWithReactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserToVideoWithReactionCreateWithoutUserInput>, Enumerable<UserToVideoWithReactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserToVideoWithReactionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserToVideoWithReactionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserToVideoWithReactionCreateManyUserInputEnvelope
    set?: Enumerable<UserToVideoWithReactionWhereUniqueInput>
    disconnect?: Enumerable<UserToVideoWithReactionWhereUniqueInput>
    delete?: Enumerable<UserToVideoWithReactionWhereUniqueInput>
    connect?: Enumerable<UserToVideoWithReactionWhereUniqueInput>
    update?: Enumerable<UserToVideoWithReactionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserToVideoWithReactionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserToVideoWithReactionScalarWhereInput>
  }

  export type VideoCommentUncheckedUpdateManyWithoutCommentingUserNestedInput = {
    create?: XOR<Enumerable<VideoCommentCreateWithoutCommentingUserInput>, Enumerable<VideoCommentUncheckedCreateWithoutCommentingUserInput>>
    connectOrCreate?: Enumerable<VideoCommentCreateOrConnectWithoutCommentingUserInput>
    upsert?: Enumerable<VideoCommentUpsertWithWhereUniqueWithoutCommentingUserInput>
    createMany?: VideoCommentCreateManyCommentingUserInputEnvelope
    set?: Enumerable<VideoCommentWhereUniqueInput>
    disconnect?: Enumerable<VideoCommentWhereUniqueInput>
    delete?: Enumerable<VideoCommentWhereUniqueInput>
    connect?: Enumerable<VideoCommentWhereUniqueInput>
    update?: Enumerable<VideoCommentUpdateWithWhereUniqueWithoutCommentingUserInput>
    updateMany?: Enumerable<VideoCommentUpdateManyWithWhereWithoutCommentingUserInput>
    deleteMany?: Enumerable<VideoCommentScalarWhereInput>
  }

  export type YouTubeUserCreateNestedManyWithoutAdminOfChannelsInput = {
    create?: XOR<Enumerable<YouTubeUserCreateWithoutAdminOfChannelsInput>, Enumerable<YouTubeUserUncheckedCreateWithoutAdminOfChannelsInput>>
    connectOrCreate?: Enumerable<YouTubeUserCreateOrConnectWithoutAdminOfChannelsInput>
    connect?: Enumerable<YouTubeUserWhereUniqueInput>
  }

  export type YouTubeUserCreateNestedManyWithoutSubscribingToChannelsInput = {
    create?: XOR<Enumerable<YouTubeUserCreateWithoutSubscribingToChannelsInput>, Enumerable<YouTubeUserUncheckedCreateWithoutSubscribingToChannelsInput>>
    connectOrCreate?: Enumerable<YouTubeUserCreateOrConnectWithoutSubscribingToChannelsInput>
    connect?: Enumerable<YouTubeUserWhereUniqueInput>
  }

  export type UserToChannelwithRoleCreateNestedManyWithoutChannelInput = {
    create?: XOR<Enumerable<UserToChannelwithRoleCreateWithoutChannelInput>, Enumerable<UserToChannelwithRoleUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<UserToChannelwithRoleCreateOrConnectWithoutChannelInput>
    createMany?: UserToChannelwithRoleCreateManyChannelInputEnvelope
    connect?: Enumerable<UserToChannelwithRoleWhereUniqueInput>
  }

  export type VideoCreateNestedManyWithoutBelongsToChannelInput = {
    create?: XOR<Enumerable<VideoCreateWithoutBelongsToChannelInput>, Enumerable<VideoUncheckedCreateWithoutBelongsToChannelInput>>
    connectOrCreate?: Enumerable<VideoCreateOrConnectWithoutBelongsToChannelInput>
    createMany?: VideoCreateManyBelongsToChannelInputEnvelope
    connect?: Enumerable<VideoWhereUniqueInput>
  }

  export type YouTubeUserUncheckedCreateNestedManyWithoutAdminOfChannelsInput = {
    create?: XOR<Enumerable<YouTubeUserCreateWithoutAdminOfChannelsInput>, Enumerable<YouTubeUserUncheckedCreateWithoutAdminOfChannelsInput>>
    connectOrCreate?: Enumerable<YouTubeUserCreateOrConnectWithoutAdminOfChannelsInput>
    connect?: Enumerable<YouTubeUserWhereUniqueInput>
  }

  export type YouTubeUserUncheckedCreateNestedManyWithoutSubscribingToChannelsInput = {
    create?: XOR<Enumerable<YouTubeUserCreateWithoutSubscribingToChannelsInput>, Enumerable<YouTubeUserUncheckedCreateWithoutSubscribingToChannelsInput>>
    connectOrCreate?: Enumerable<YouTubeUserCreateOrConnectWithoutSubscribingToChannelsInput>
    connect?: Enumerable<YouTubeUserWhereUniqueInput>
  }

  export type UserToChannelwithRoleUncheckedCreateNestedManyWithoutChannelInput = {
    create?: XOR<Enumerable<UserToChannelwithRoleCreateWithoutChannelInput>, Enumerable<UserToChannelwithRoleUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<UserToChannelwithRoleCreateOrConnectWithoutChannelInput>
    createMany?: UserToChannelwithRoleCreateManyChannelInputEnvelope
    connect?: Enumerable<UserToChannelwithRoleWhereUniqueInput>
  }

  export type VideoUncheckedCreateNestedManyWithoutBelongsToChannelInput = {
    create?: XOR<Enumerable<VideoCreateWithoutBelongsToChannelInput>, Enumerable<VideoUncheckedCreateWithoutBelongsToChannelInput>>
    connectOrCreate?: Enumerable<VideoCreateOrConnectWithoutBelongsToChannelInput>
    createMany?: VideoCreateManyBelongsToChannelInputEnvelope
    connect?: Enumerable<VideoWhereUniqueInput>
  }

  export type YouTubeUserUpdateManyWithoutAdminOfChannelsNestedInput = {
    create?: XOR<Enumerable<YouTubeUserCreateWithoutAdminOfChannelsInput>, Enumerable<YouTubeUserUncheckedCreateWithoutAdminOfChannelsInput>>
    connectOrCreate?: Enumerable<YouTubeUserCreateOrConnectWithoutAdminOfChannelsInput>
    upsert?: Enumerable<YouTubeUserUpsertWithWhereUniqueWithoutAdminOfChannelsInput>
    set?: Enumerable<YouTubeUserWhereUniqueInput>
    disconnect?: Enumerable<YouTubeUserWhereUniqueInput>
    delete?: Enumerable<YouTubeUserWhereUniqueInput>
    connect?: Enumerable<YouTubeUserWhereUniqueInput>
    update?: Enumerable<YouTubeUserUpdateWithWhereUniqueWithoutAdminOfChannelsInput>
    updateMany?: Enumerable<YouTubeUserUpdateManyWithWhereWithoutAdminOfChannelsInput>
    deleteMany?: Enumerable<YouTubeUserScalarWhereInput>
  }

  export type YouTubeUserUpdateManyWithoutSubscribingToChannelsNestedInput = {
    create?: XOR<Enumerable<YouTubeUserCreateWithoutSubscribingToChannelsInput>, Enumerable<YouTubeUserUncheckedCreateWithoutSubscribingToChannelsInput>>
    connectOrCreate?: Enumerable<YouTubeUserCreateOrConnectWithoutSubscribingToChannelsInput>
    upsert?: Enumerable<YouTubeUserUpsertWithWhereUniqueWithoutSubscribingToChannelsInput>
    set?: Enumerable<YouTubeUserWhereUniqueInput>
    disconnect?: Enumerable<YouTubeUserWhereUniqueInput>
    delete?: Enumerable<YouTubeUserWhereUniqueInput>
    connect?: Enumerable<YouTubeUserWhereUniqueInput>
    update?: Enumerable<YouTubeUserUpdateWithWhereUniqueWithoutSubscribingToChannelsInput>
    updateMany?: Enumerable<YouTubeUserUpdateManyWithWhereWithoutSubscribingToChannelsInput>
    deleteMany?: Enumerable<YouTubeUserScalarWhereInput>
  }

  export type UserToChannelwithRoleUpdateManyWithoutChannelNestedInput = {
    create?: XOR<Enumerable<UserToChannelwithRoleCreateWithoutChannelInput>, Enumerable<UserToChannelwithRoleUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<UserToChannelwithRoleCreateOrConnectWithoutChannelInput>
    upsert?: Enumerable<UserToChannelwithRoleUpsertWithWhereUniqueWithoutChannelInput>
    createMany?: UserToChannelwithRoleCreateManyChannelInputEnvelope
    set?: Enumerable<UserToChannelwithRoleWhereUniqueInput>
    disconnect?: Enumerable<UserToChannelwithRoleWhereUniqueInput>
    delete?: Enumerable<UserToChannelwithRoleWhereUniqueInput>
    connect?: Enumerable<UserToChannelwithRoleWhereUniqueInput>
    update?: Enumerable<UserToChannelwithRoleUpdateWithWhereUniqueWithoutChannelInput>
    updateMany?: Enumerable<UserToChannelwithRoleUpdateManyWithWhereWithoutChannelInput>
    deleteMany?: Enumerable<UserToChannelwithRoleScalarWhereInput>
  }

  export type VideoUpdateManyWithoutBelongsToChannelNestedInput = {
    create?: XOR<Enumerable<VideoCreateWithoutBelongsToChannelInput>, Enumerable<VideoUncheckedCreateWithoutBelongsToChannelInput>>
    connectOrCreate?: Enumerable<VideoCreateOrConnectWithoutBelongsToChannelInput>
    upsert?: Enumerable<VideoUpsertWithWhereUniqueWithoutBelongsToChannelInput>
    createMany?: VideoCreateManyBelongsToChannelInputEnvelope
    set?: Enumerable<VideoWhereUniqueInput>
    disconnect?: Enumerable<VideoWhereUniqueInput>
    delete?: Enumerable<VideoWhereUniqueInput>
    connect?: Enumerable<VideoWhereUniqueInput>
    update?: Enumerable<VideoUpdateWithWhereUniqueWithoutBelongsToChannelInput>
    updateMany?: Enumerable<VideoUpdateManyWithWhereWithoutBelongsToChannelInput>
    deleteMany?: Enumerable<VideoScalarWhereInput>
  }

  export type YouTubeUserUncheckedUpdateManyWithoutAdminOfChannelsNestedInput = {
    create?: XOR<Enumerable<YouTubeUserCreateWithoutAdminOfChannelsInput>, Enumerable<YouTubeUserUncheckedCreateWithoutAdminOfChannelsInput>>
    connectOrCreate?: Enumerable<YouTubeUserCreateOrConnectWithoutAdminOfChannelsInput>
    upsert?: Enumerable<YouTubeUserUpsertWithWhereUniqueWithoutAdminOfChannelsInput>
    set?: Enumerable<YouTubeUserWhereUniqueInput>
    disconnect?: Enumerable<YouTubeUserWhereUniqueInput>
    delete?: Enumerable<YouTubeUserWhereUniqueInput>
    connect?: Enumerable<YouTubeUserWhereUniqueInput>
    update?: Enumerable<YouTubeUserUpdateWithWhereUniqueWithoutAdminOfChannelsInput>
    updateMany?: Enumerable<YouTubeUserUpdateManyWithWhereWithoutAdminOfChannelsInput>
    deleteMany?: Enumerable<YouTubeUserScalarWhereInput>
  }

  export type YouTubeUserUncheckedUpdateManyWithoutSubscribingToChannelsNestedInput = {
    create?: XOR<Enumerable<YouTubeUserCreateWithoutSubscribingToChannelsInput>, Enumerable<YouTubeUserUncheckedCreateWithoutSubscribingToChannelsInput>>
    connectOrCreate?: Enumerable<YouTubeUserCreateOrConnectWithoutSubscribingToChannelsInput>
    upsert?: Enumerable<YouTubeUserUpsertWithWhereUniqueWithoutSubscribingToChannelsInput>
    set?: Enumerable<YouTubeUserWhereUniqueInput>
    disconnect?: Enumerable<YouTubeUserWhereUniqueInput>
    delete?: Enumerable<YouTubeUserWhereUniqueInput>
    connect?: Enumerable<YouTubeUserWhereUniqueInput>
    update?: Enumerable<YouTubeUserUpdateWithWhereUniqueWithoutSubscribingToChannelsInput>
    updateMany?: Enumerable<YouTubeUserUpdateManyWithWhereWithoutSubscribingToChannelsInput>
    deleteMany?: Enumerable<YouTubeUserScalarWhereInput>
  }

  export type UserToChannelwithRoleUncheckedUpdateManyWithoutChannelNestedInput = {
    create?: XOR<Enumerable<UserToChannelwithRoleCreateWithoutChannelInput>, Enumerable<UserToChannelwithRoleUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<UserToChannelwithRoleCreateOrConnectWithoutChannelInput>
    upsert?: Enumerable<UserToChannelwithRoleUpsertWithWhereUniqueWithoutChannelInput>
    createMany?: UserToChannelwithRoleCreateManyChannelInputEnvelope
    set?: Enumerable<UserToChannelwithRoleWhereUniqueInput>
    disconnect?: Enumerable<UserToChannelwithRoleWhereUniqueInput>
    delete?: Enumerable<UserToChannelwithRoleWhereUniqueInput>
    connect?: Enumerable<UserToChannelwithRoleWhereUniqueInput>
    update?: Enumerable<UserToChannelwithRoleUpdateWithWhereUniqueWithoutChannelInput>
    updateMany?: Enumerable<UserToChannelwithRoleUpdateManyWithWhereWithoutChannelInput>
    deleteMany?: Enumerable<UserToChannelwithRoleScalarWhereInput>
  }

  export type VideoUncheckedUpdateManyWithoutBelongsToChannelNestedInput = {
    create?: XOR<Enumerable<VideoCreateWithoutBelongsToChannelInput>, Enumerable<VideoUncheckedCreateWithoutBelongsToChannelInput>>
    connectOrCreate?: Enumerable<VideoCreateOrConnectWithoutBelongsToChannelInput>
    upsert?: Enumerable<VideoUpsertWithWhereUniqueWithoutBelongsToChannelInput>
    createMany?: VideoCreateManyBelongsToChannelInputEnvelope
    set?: Enumerable<VideoWhereUniqueInput>
    disconnect?: Enumerable<VideoWhereUniqueInput>
    delete?: Enumerable<VideoWhereUniqueInput>
    connect?: Enumerable<VideoWhereUniqueInput>
    update?: Enumerable<VideoUpdateWithWhereUniqueWithoutBelongsToChannelInput>
    updateMany?: Enumerable<VideoUpdateManyWithWhereWithoutBelongsToChannelInput>
    deleteMany?: Enumerable<VideoScalarWhereInput>
  }

  export type YouTubeUserCreateNestedOneWithoutUsersToChannelswithRolesInput = {
    create?: XOR<YouTubeUserCreateWithoutUsersToChannelswithRolesInput, YouTubeUserUncheckedCreateWithoutUsersToChannelswithRolesInput>
    connectOrCreate?: YouTubeUserCreateOrConnectWithoutUsersToChannelswithRolesInput
    connect?: YouTubeUserWhereUniqueInput
  }

  export type ChannelCreateNestedOneWithoutUsersToChannelswithRolesInput = {
    create?: XOR<ChannelCreateWithoutUsersToChannelswithRolesInput, ChannelUncheckedCreateWithoutUsersToChannelswithRolesInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutUsersToChannelswithRolesInput
    connect?: ChannelWhereUniqueInput
  }

  export type YouTubeUserUpdateOneRequiredWithoutUsersToChannelswithRolesNestedInput = {
    create?: XOR<YouTubeUserCreateWithoutUsersToChannelswithRolesInput, YouTubeUserUncheckedCreateWithoutUsersToChannelswithRolesInput>
    connectOrCreate?: YouTubeUserCreateOrConnectWithoutUsersToChannelswithRolesInput
    upsert?: YouTubeUserUpsertWithoutUsersToChannelswithRolesInput
    connect?: YouTubeUserWhereUniqueInput
    update?: XOR<YouTubeUserUpdateWithoutUsersToChannelswithRolesInput, YouTubeUserUncheckedUpdateWithoutUsersToChannelswithRolesInput>
  }

  export type ChannelUpdateOneRequiredWithoutUsersToChannelswithRolesNestedInput = {
    create?: XOR<ChannelCreateWithoutUsersToChannelswithRolesInput, ChannelUncheckedCreateWithoutUsersToChannelswithRolesInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutUsersToChannelswithRolesInput
    upsert?: ChannelUpsertWithoutUsersToChannelswithRolesInput
    connect?: ChannelWhereUniqueInput
    update?: XOR<ChannelUpdateWithoutUsersToChannelswithRolesInput, ChannelUncheckedUpdateWithoutUsersToChannelswithRolesInput>
  }

  export type EnumRoleEnumFieldUpdateOperationsInput = {
    set?: RoleEnum
  }

  export type ChannelCreateNestedOneWithoutOwningVideosInput = {
    create?: XOR<ChannelCreateWithoutOwningVideosInput, ChannelUncheckedCreateWithoutOwningVideosInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutOwningVideosInput
    connect?: ChannelWhereUniqueInput
  }

  export type YouTubeUserCreateNestedManyWithoutReactedVideosInput = {
    create?: XOR<Enumerable<YouTubeUserCreateWithoutReactedVideosInput>, Enumerable<YouTubeUserUncheckedCreateWithoutReactedVideosInput>>
    connectOrCreate?: Enumerable<YouTubeUserCreateOrConnectWithoutReactedVideosInput>
    connect?: Enumerable<YouTubeUserWhereUniqueInput>
  }

  export type UserToVideoWithReactionCreateNestedManyWithoutVideoInput = {
    create?: XOR<Enumerable<UserToVideoWithReactionCreateWithoutVideoInput>, Enumerable<UserToVideoWithReactionUncheckedCreateWithoutVideoInput>>
    connectOrCreate?: Enumerable<UserToVideoWithReactionCreateOrConnectWithoutVideoInput>
    createMany?: UserToVideoWithReactionCreateManyVideoInputEnvelope
    connect?: Enumerable<UserToVideoWithReactionWhereUniqueInput>
  }

  export type VideoCommentCreateNestedManyWithoutParentVideoInput = {
    create?: XOR<Enumerable<VideoCommentCreateWithoutParentVideoInput>, Enumerable<VideoCommentUncheckedCreateWithoutParentVideoInput>>
    connectOrCreate?: Enumerable<VideoCommentCreateOrConnectWithoutParentVideoInput>
    createMany?: VideoCommentCreateManyParentVideoInputEnvelope
    connect?: Enumerable<VideoCommentWhereUniqueInput>
  }

  export type YouTubeUserUncheckedCreateNestedManyWithoutReactedVideosInput = {
    create?: XOR<Enumerable<YouTubeUserCreateWithoutReactedVideosInput>, Enumerable<YouTubeUserUncheckedCreateWithoutReactedVideosInput>>
    connectOrCreate?: Enumerable<YouTubeUserCreateOrConnectWithoutReactedVideosInput>
    connect?: Enumerable<YouTubeUserWhereUniqueInput>
  }

  export type UserToVideoWithReactionUncheckedCreateNestedManyWithoutVideoInput = {
    create?: XOR<Enumerable<UserToVideoWithReactionCreateWithoutVideoInput>, Enumerable<UserToVideoWithReactionUncheckedCreateWithoutVideoInput>>
    connectOrCreate?: Enumerable<UserToVideoWithReactionCreateOrConnectWithoutVideoInput>
    createMany?: UserToVideoWithReactionCreateManyVideoInputEnvelope
    connect?: Enumerable<UserToVideoWithReactionWhereUniqueInput>
  }

  export type VideoCommentUncheckedCreateNestedManyWithoutParentVideoInput = {
    create?: XOR<Enumerable<VideoCommentCreateWithoutParentVideoInput>, Enumerable<VideoCommentUncheckedCreateWithoutParentVideoInput>>
    connectOrCreate?: Enumerable<VideoCommentCreateOrConnectWithoutParentVideoInput>
    createMany?: VideoCommentCreateManyParentVideoInputEnvelope
    connect?: Enumerable<VideoCommentWhereUniqueInput>
  }

  export type ChannelUpdateOneRequiredWithoutOwningVideosNestedInput = {
    create?: XOR<ChannelCreateWithoutOwningVideosInput, ChannelUncheckedCreateWithoutOwningVideosInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutOwningVideosInput
    upsert?: ChannelUpsertWithoutOwningVideosInput
    connect?: ChannelWhereUniqueInput
    update?: XOR<ChannelUpdateWithoutOwningVideosInput, ChannelUncheckedUpdateWithoutOwningVideosInput>
  }

  export type YouTubeUserUpdateManyWithoutReactedVideosNestedInput = {
    create?: XOR<Enumerable<YouTubeUserCreateWithoutReactedVideosInput>, Enumerable<YouTubeUserUncheckedCreateWithoutReactedVideosInput>>
    connectOrCreate?: Enumerable<YouTubeUserCreateOrConnectWithoutReactedVideosInput>
    upsert?: Enumerable<YouTubeUserUpsertWithWhereUniqueWithoutReactedVideosInput>
    set?: Enumerable<YouTubeUserWhereUniqueInput>
    disconnect?: Enumerable<YouTubeUserWhereUniqueInput>
    delete?: Enumerable<YouTubeUserWhereUniqueInput>
    connect?: Enumerable<YouTubeUserWhereUniqueInput>
    update?: Enumerable<YouTubeUserUpdateWithWhereUniqueWithoutReactedVideosInput>
    updateMany?: Enumerable<YouTubeUserUpdateManyWithWhereWithoutReactedVideosInput>
    deleteMany?: Enumerable<YouTubeUserScalarWhereInput>
  }

  export type UserToVideoWithReactionUpdateManyWithoutVideoNestedInput = {
    create?: XOR<Enumerable<UserToVideoWithReactionCreateWithoutVideoInput>, Enumerable<UserToVideoWithReactionUncheckedCreateWithoutVideoInput>>
    connectOrCreate?: Enumerable<UserToVideoWithReactionCreateOrConnectWithoutVideoInput>
    upsert?: Enumerable<UserToVideoWithReactionUpsertWithWhereUniqueWithoutVideoInput>
    createMany?: UserToVideoWithReactionCreateManyVideoInputEnvelope
    set?: Enumerable<UserToVideoWithReactionWhereUniqueInput>
    disconnect?: Enumerable<UserToVideoWithReactionWhereUniqueInput>
    delete?: Enumerable<UserToVideoWithReactionWhereUniqueInput>
    connect?: Enumerable<UserToVideoWithReactionWhereUniqueInput>
    update?: Enumerable<UserToVideoWithReactionUpdateWithWhereUniqueWithoutVideoInput>
    updateMany?: Enumerable<UserToVideoWithReactionUpdateManyWithWhereWithoutVideoInput>
    deleteMany?: Enumerable<UserToVideoWithReactionScalarWhereInput>
  }

  export type VideoCommentUpdateManyWithoutParentVideoNestedInput = {
    create?: XOR<Enumerable<VideoCommentCreateWithoutParentVideoInput>, Enumerable<VideoCommentUncheckedCreateWithoutParentVideoInput>>
    connectOrCreate?: Enumerable<VideoCommentCreateOrConnectWithoutParentVideoInput>
    upsert?: Enumerable<VideoCommentUpsertWithWhereUniqueWithoutParentVideoInput>
    createMany?: VideoCommentCreateManyParentVideoInputEnvelope
    set?: Enumerable<VideoCommentWhereUniqueInput>
    disconnect?: Enumerable<VideoCommentWhereUniqueInput>
    delete?: Enumerable<VideoCommentWhereUniqueInput>
    connect?: Enumerable<VideoCommentWhereUniqueInput>
    update?: Enumerable<VideoCommentUpdateWithWhereUniqueWithoutParentVideoInput>
    updateMany?: Enumerable<VideoCommentUpdateManyWithWhereWithoutParentVideoInput>
    deleteMany?: Enumerable<VideoCommentScalarWhereInput>
  }

  export type YouTubeUserUncheckedUpdateManyWithoutReactedVideosNestedInput = {
    create?: XOR<Enumerable<YouTubeUserCreateWithoutReactedVideosInput>, Enumerable<YouTubeUserUncheckedCreateWithoutReactedVideosInput>>
    connectOrCreate?: Enumerable<YouTubeUserCreateOrConnectWithoutReactedVideosInput>
    upsert?: Enumerable<YouTubeUserUpsertWithWhereUniqueWithoutReactedVideosInput>
    set?: Enumerable<YouTubeUserWhereUniqueInput>
    disconnect?: Enumerable<YouTubeUserWhereUniqueInput>
    delete?: Enumerable<YouTubeUserWhereUniqueInput>
    connect?: Enumerable<YouTubeUserWhereUniqueInput>
    update?: Enumerable<YouTubeUserUpdateWithWhereUniqueWithoutReactedVideosInput>
    updateMany?: Enumerable<YouTubeUserUpdateManyWithWhereWithoutReactedVideosInput>
    deleteMany?: Enumerable<YouTubeUserScalarWhereInput>
  }

  export type UserToVideoWithReactionUncheckedUpdateManyWithoutVideoNestedInput = {
    create?: XOR<Enumerable<UserToVideoWithReactionCreateWithoutVideoInput>, Enumerable<UserToVideoWithReactionUncheckedCreateWithoutVideoInput>>
    connectOrCreate?: Enumerable<UserToVideoWithReactionCreateOrConnectWithoutVideoInput>
    upsert?: Enumerable<UserToVideoWithReactionUpsertWithWhereUniqueWithoutVideoInput>
    createMany?: UserToVideoWithReactionCreateManyVideoInputEnvelope
    set?: Enumerable<UserToVideoWithReactionWhereUniqueInput>
    disconnect?: Enumerable<UserToVideoWithReactionWhereUniqueInput>
    delete?: Enumerable<UserToVideoWithReactionWhereUniqueInput>
    connect?: Enumerable<UserToVideoWithReactionWhereUniqueInput>
    update?: Enumerable<UserToVideoWithReactionUpdateWithWhereUniqueWithoutVideoInput>
    updateMany?: Enumerable<UserToVideoWithReactionUpdateManyWithWhereWithoutVideoInput>
    deleteMany?: Enumerable<UserToVideoWithReactionScalarWhereInput>
  }

  export type VideoCommentUncheckedUpdateManyWithoutParentVideoNestedInput = {
    create?: XOR<Enumerable<VideoCommentCreateWithoutParentVideoInput>, Enumerable<VideoCommentUncheckedCreateWithoutParentVideoInput>>
    connectOrCreate?: Enumerable<VideoCommentCreateOrConnectWithoutParentVideoInput>
    upsert?: Enumerable<VideoCommentUpsertWithWhereUniqueWithoutParentVideoInput>
    createMany?: VideoCommentCreateManyParentVideoInputEnvelope
    set?: Enumerable<VideoCommentWhereUniqueInput>
    disconnect?: Enumerable<VideoCommentWhereUniqueInput>
    delete?: Enumerable<VideoCommentWhereUniqueInput>
    connect?: Enumerable<VideoCommentWhereUniqueInput>
    update?: Enumerable<VideoCommentUpdateWithWhereUniqueWithoutParentVideoInput>
    updateMany?: Enumerable<VideoCommentUpdateManyWithWhereWithoutParentVideoInput>
    deleteMany?: Enumerable<VideoCommentScalarWhereInput>
  }

  export type YouTubeUserCreateNestedOneWithoutUsersToVideosWithReactionsInput = {
    create?: XOR<YouTubeUserCreateWithoutUsersToVideosWithReactionsInput, YouTubeUserUncheckedCreateWithoutUsersToVideosWithReactionsInput>
    connectOrCreate?: YouTubeUserCreateOrConnectWithoutUsersToVideosWithReactionsInput
    connect?: YouTubeUserWhereUniqueInput
  }

  export type VideoCreateNestedOneWithoutUsersToVideosWithReactionsInput = {
    create?: XOR<VideoCreateWithoutUsersToVideosWithReactionsInput, VideoUncheckedCreateWithoutUsersToVideosWithReactionsInput>
    connectOrCreate?: VideoCreateOrConnectWithoutUsersToVideosWithReactionsInput
    connect?: VideoWhereUniqueInput
  }

  export type YouTubeUserUpdateOneRequiredWithoutUsersToVideosWithReactionsNestedInput = {
    create?: XOR<YouTubeUserCreateWithoutUsersToVideosWithReactionsInput, YouTubeUserUncheckedCreateWithoutUsersToVideosWithReactionsInput>
    connectOrCreate?: YouTubeUserCreateOrConnectWithoutUsersToVideosWithReactionsInput
    upsert?: YouTubeUserUpsertWithoutUsersToVideosWithReactionsInput
    connect?: YouTubeUserWhereUniqueInput
    update?: XOR<YouTubeUserUpdateWithoutUsersToVideosWithReactionsInput, YouTubeUserUncheckedUpdateWithoutUsersToVideosWithReactionsInput>
  }

  export type VideoUpdateOneRequiredWithoutUsersToVideosWithReactionsNestedInput = {
    create?: XOR<VideoCreateWithoutUsersToVideosWithReactionsInput, VideoUncheckedCreateWithoutUsersToVideosWithReactionsInput>
    connectOrCreate?: VideoCreateOrConnectWithoutUsersToVideosWithReactionsInput
    upsert?: VideoUpsertWithoutUsersToVideosWithReactionsInput
    connect?: VideoWhereUniqueInput
    update?: XOR<VideoUpdateWithoutUsersToVideosWithReactionsInput, VideoUncheckedUpdateWithoutUsersToVideosWithReactionsInput>
  }

  export type EnumReactionEnumFieldUpdateOperationsInput = {
    set?: ReactionEnum
  }

  export type YouTubeUserCreateNestedOneWithoutVideoCommentsInput = {
    create?: XOR<YouTubeUserCreateWithoutVideoCommentsInput, YouTubeUserUncheckedCreateWithoutVideoCommentsInput>
    connectOrCreate?: YouTubeUserCreateOrConnectWithoutVideoCommentsInput
    connect?: YouTubeUserWhereUniqueInput
  }

  export type VideoCreateNestedOneWithoutVideoCommentsInput = {
    create?: XOR<VideoCreateWithoutVideoCommentsInput, VideoUncheckedCreateWithoutVideoCommentsInput>
    connectOrCreate?: VideoCreateOrConnectWithoutVideoCommentsInput
    connect?: VideoWhereUniqueInput
  }

  export type VideoCommentCreateNestedOneWithoutChildVideoCommentsInput = {
    create?: XOR<VideoCommentCreateWithoutChildVideoCommentsInput, VideoCommentUncheckedCreateWithoutChildVideoCommentsInput>
    connectOrCreate?: VideoCommentCreateOrConnectWithoutChildVideoCommentsInput
    connect?: VideoCommentWhereUniqueInput
  }

  export type VideoCommentCreateNestedManyWithoutParentVideoCommentInput = {
    create?: XOR<Enumerable<VideoCommentCreateWithoutParentVideoCommentInput>, Enumerable<VideoCommentUncheckedCreateWithoutParentVideoCommentInput>>
    connectOrCreate?: Enumerable<VideoCommentCreateOrConnectWithoutParentVideoCommentInput>
    createMany?: VideoCommentCreateManyParentVideoCommentInputEnvelope
    connect?: Enumerable<VideoCommentWhereUniqueInput>
  }

  export type VideoCommentUncheckedCreateNestedManyWithoutParentVideoCommentInput = {
    create?: XOR<Enumerable<VideoCommentCreateWithoutParentVideoCommentInput>, Enumerable<VideoCommentUncheckedCreateWithoutParentVideoCommentInput>>
    connectOrCreate?: Enumerable<VideoCommentCreateOrConnectWithoutParentVideoCommentInput>
    createMany?: VideoCommentCreateManyParentVideoCommentInputEnvelope
    connect?: Enumerable<VideoCommentWhereUniqueInput>
  }

  export type YouTubeUserUpdateOneRequiredWithoutVideoCommentsNestedInput = {
    create?: XOR<YouTubeUserCreateWithoutVideoCommentsInput, YouTubeUserUncheckedCreateWithoutVideoCommentsInput>
    connectOrCreate?: YouTubeUserCreateOrConnectWithoutVideoCommentsInput
    upsert?: YouTubeUserUpsertWithoutVideoCommentsInput
    connect?: YouTubeUserWhereUniqueInput
    update?: XOR<YouTubeUserUpdateWithoutVideoCommentsInput, YouTubeUserUncheckedUpdateWithoutVideoCommentsInput>
  }

  export type VideoUpdateOneRequiredWithoutVideoCommentsNestedInput = {
    create?: XOR<VideoCreateWithoutVideoCommentsInput, VideoUncheckedCreateWithoutVideoCommentsInput>
    connectOrCreate?: VideoCreateOrConnectWithoutVideoCommentsInput
    upsert?: VideoUpsertWithoutVideoCommentsInput
    connect?: VideoWhereUniqueInput
    update?: XOR<VideoUpdateWithoutVideoCommentsInput, VideoUncheckedUpdateWithoutVideoCommentsInput>
  }

  export type VideoCommentUpdateOneWithoutChildVideoCommentsNestedInput = {
    create?: XOR<VideoCommentCreateWithoutChildVideoCommentsInput, VideoCommentUncheckedCreateWithoutChildVideoCommentsInput>
    connectOrCreate?: VideoCommentCreateOrConnectWithoutChildVideoCommentsInput
    upsert?: VideoCommentUpsertWithoutChildVideoCommentsInput
    disconnect?: boolean
    delete?: boolean
    connect?: VideoCommentWhereUniqueInput
    update?: XOR<VideoCommentUpdateWithoutChildVideoCommentsInput, VideoCommentUncheckedUpdateWithoutChildVideoCommentsInput>
  }

  export type VideoCommentUpdateManyWithoutParentVideoCommentNestedInput = {
    create?: XOR<Enumerable<VideoCommentCreateWithoutParentVideoCommentInput>, Enumerable<VideoCommentUncheckedCreateWithoutParentVideoCommentInput>>
    connectOrCreate?: Enumerable<VideoCommentCreateOrConnectWithoutParentVideoCommentInput>
    upsert?: Enumerable<VideoCommentUpsertWithWhereUniqueWithoutParentVideoCommentInput>
    createMany?: VideoCommentCreateManyParentVideoCommentInputEnvelope
    set?: Enumerable<VideoCommentWhereUniqueInput>
    disconnect?: Enumerable<VideoCommentWhereUniqueInput>
    delete?: Enumerable<VideoCommentWhereUniqueInput>
    connect?: Enumerable<VideoCommentWhereUniqueInput>
    update?: Enumerable<VideoCommentUpdateWithWhereUniqueWithoutParentVideoCommentInput>
    updateMany?: Enumerable<VideoCommentUpdateManyWithWhereWithoutParentVideoCommentInput>
    deleteMany?: Enumerable<VideoCommentScalarWhereInput>
  }

  export type VideoCommentUncheckedUpdateManyWithoutParentVideoCommentNestedInput = {
    create?: XOR<Enumerable<VideoCommentCreateWithoutParentVideoCommentInput>, Enumerable<VideoCommentUncheckedCreateWithoutParentVideoCommentInput>>
    connectOrCreate?: Enumerable<VideoCommentCreateOrConnectWithoutParentVideoCommentInput>
    upsert?: Enumerable<VideoCommentUpsertWithWhereUniqueWithoutParentVideoCommentInput>
    createMany?: VideoCommentCreateManyParentVideoCommentInputEnvelope
    set?: Enumerable<VideoCommentWhereUniqueInput>
    disconnect?: Enumerable<VideoCommentWhereUniqueInput>
    delete?: Enumerable<VideoCommentWhereUniqueInput>
    connect?: Enumerable<VideoCommentWhereUniqueInput>
    update?: Enumerable<VideoCommentUpdateWithWhereUniqueWithoutParentVideoCommentInput>
    updateMany?: Enumerable<VideoCommentUpdateManyWithWhereWithoutParentVideoCommentInput>
    deleteMany?: Enumerable<VideoCommentScalarWhereInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedEnumWMTypeEnumFilter = {
    equals?: WMTypeEnum
    in?: Enumerable<WMTypeEnum>
    notIn?: Enumerable<WMTypeEnum>
    not?: NestedEnumWMTypeEnumFilter | WMTypeEnum
  }

  export type NestedEnumWMTypeEnumWithAggregatesFilter = {
    equals?: WMTypeEnum
    in?: Enumerable<WMTypeEnum>
    notIn?: Enumerable<WMTypeEnum>
    not?: NestedEnumWMTypeEnumWithAggregatesFilter | WMTypeEnum
    _count?: NestedIntFilter
    _min?: NestedEnumWMTypeEnumFilter
    _max?: NestedEnumWMTypeEnumFilter
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedEnumRoleEnumFilter = {
    equals?: RoleEnum
    in?: Enumerable<RoleEnum>
    notIn?: Enumerable<RoleEnum>
    not?: NestedEnumRoleEnumFilter | RoleEnum
  }

  export type NestedEnumRoleEnumWithAggregatesFilter = {
    equals?: RoleEnum
    in?: Enumerable<RoleEnum>
    notIn?: Enumerable<RoleEnum>
    not?: NestedEnumRoleEnumWithAggregatesFilter | RoleEnum
    _count?: NestedIntFilter
    _min?: NestedEnumRoleEnumFilter
    _max?: NestedEnumRoleEnumFilter
  }

  export type NestedEnumReactionEnumFilter = {
    equals?: ReactionEnum
    in?: Enumerable<ReactionEnum>
    notIn?: Enumerable<ReactionEnum>
    not?: NestedEnumReactionEnumFilter | ReactionEnum
  }

  export type NestedEnumReactionEnumWithAggregatesFilter = {
    equals?: ReactionEnum
    in?: Enumerable<ReactionEnum>
    notIn?: Enumerable<ReactionEnum>
    not?: NestedEnumReactionEnumWithAggregatesFilter | ReactionEnum
    _count?: NestedIntFilter
    _min?: NestedEnumReactionEnumFilter
    _max?: NestedEnumReactionEnumFilter
  }

  export type MenuCreateWithoutCategoryInput = {
    name: string
    image: string
    price: number
    orderItems?: OrderItemCreateNestedManyWithoutMenuInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuUncheckedCreateWithoutCategoryInput = {
    id?: number
    name: string
    image: string
    price: number
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutMenuInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuCreateOrConnectWithoutCategoryInput = {
    where: MenuWhereUniqueInput
    create: XOR<MenuCreateWithoutCategoryInput, MenuUncheckedCreateWithoutCategoryInput>
  }

  export type MenuCreateManyCategoryInputEnvelope = {
    data: Enumerable<MenuCreateManyCategoryInput>
    skipDuplicates?: boolean
  }

  export type MenuUpsertWithWhereUniqueWithoutCategoryInput = {
    where: MenuWhereUniqueInput
    update: XOR<MenuUpdateWithoutCategoryInput, MenuUncheckedUpdateWithoutCategoryInput>
    create: XOR<MenuCreateWithoutCategoryInput, MenuUncheckedCreateWithoutCategoryInput>
  }

  export type MenuUpdateWithWhereUniqueWithoutCategoryInput = {
    where: MenuWhereUniqueInput
    data: XOR<MenuUpdateWithoutCategoryInput, MenuUncheckedUpdateWithoutCategoryInput>
  }

  export type MenuUpdateManyWithWhereWithoutCategoryInput = {
    where: MenuScalarWhereInput
    data: XOR<MenuUpdateManyMutationInput, MenuUncheckedUpdateManyWithoutMenuInput>
  }

  export type MenuScalarWhereInput = {
    AND?: Enumerable<MenuScalarWhereInput>
    OR?: Enumerable<MenuScalarWhereInput>
    NOT?: Enumerable<MenuScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    image?: StringFilter | string
    price?: FloatFilter | number
    categoryId?: IntNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type CategoryCreateWithoutMenuInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUncheckedCreateWithoutMenuInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryCreateOrConnectWithoutMenuInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutMenuInput, CategoryUncheckedCreateWithoutMenuInput>
  }

  export type OrderItemCreateWithoutMenuInput = {
    order?: OrderCreateNestedOneWithoutItemsInput
    quantity: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemUncheckedCreateWithoutMenuInput = {
    id?: number
    orderId?: number | null
    quantity: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemCreateOrConnectWithoutMenuInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutMenuInput, OrderItemUncheckedCreateWithoutMenuInput>
  }

  export type OrderItemCreateManyMenuInputEnvelope = {
    data: Enumerable<OrderItemCreateManyMenuInput>
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithoutMenuInput = {
    update: XOR<CategoryUpdateWithoutMenuInput, CategoryUncheckedUpdateWithoutMenuInput>
    create: XOR<CategoryCreateWithoutMenuInput, CategoryUncheckedCreateWithoutMenuInput>
  }

  export type CategoryUpdateWithoutMenuInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateWithoutMenuInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUpsertWithWhereUniqueWithoutMenuInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutMenuInput, OrderItemUncheckedUpdateWithoutMenuInput>
    create: XOR<OrderItemCreateWithoutMenuInput, OrderItemUncheckedCreateWithoutMenuInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutMenuInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutMenuInput, OrderItemUncheckedUpdateWithoutMenuInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutMenuInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderItemsInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: Enumerable<OrderItemScalarWhereInput>
    OR?: Enumerable<OrderItemScalarWhereInput>
    NOT?: Enumerable<OrderItemScalarWhereInput>
    id?: IntFilter | number
    menuId?: IntFilter | number
    orderId?: IntNullableFilter | number | null
    quantity?: IntFilter | number
    totalPrice?: FloatFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type OrderItemCreateWithoutOrderInput = {
    menu: MenuCreateNestedOneWithoutOrderItemsInput
    quantity: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: number
    menuId: number
    quantity: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: Enumerable<OrderItemCreateManyOrderInput>
    skipDuplicates?: boolean
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutItemsInput>
  }

  export type MenuCreateWithoutOrderItemsInput = {
    name: string
    image: string
    price: number
    category?: CategoryCreateNestedOneWithoutMenuInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuUncheckedCreateWithoutOrderItemsInput = {
    id?: number
    name: string
    image: string
    price: number
    categoryId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuCreateOrConnectWithoutOrderItemsInput = {
    where: MenuWhereUniqueInput
    create: XOR<MenuCreateWithoutOrderItemsInput, MenuUncheckedCreateWithoutOrderItemsInput>
  }

  export type OrderCreateWithoutItemsInput = {
    status?: string
    tableId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUncheckedCreateWithoutItemsInput = {
    id?: number
    status?: string
    tableId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateOrConnectWithoutItemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
  }

  export type MenuUpsertWithoutOrderItemsInput = {
    update: XOR<MenuUpdateWithoutOrderItemsInput, MenuUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<MenuCreateWithoutOrderItemsInput, MenuUncheckedCreateWithoutOrderItemsInput>
  }

  export type MenuUpdateWithoutOrderItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    category?: CategoryUpdateOneWithoutMenuNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuUncheckedUpdateWithoutOrderItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpsertWithoutItemsInput = {
    update: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
  }

  export type OrderUpdateWithoutItemsInput = {
    status?: StringFieldUpdateOperationsInput | string
    tableId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    tableId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizCreateWithoutCategoryInput = {
    questionText: string
    choices?: ChoiceCreateNestedManyWithoutQuizInput
    correctChoice: ChoiceCreateNestedOneWithoutCorrectQuizzesInput
    rounds?: RoundCreateNestedManyWithoutQuizzesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizUncheckedCreateWithoutCategoryInput = {
    id?: number
    questionText: string
    choices?: ChoiceUncheckedCreateNestedManyWithoutQuizInput
    correctChoiceId: number
    rounds?: RoundUncheckedCreateNestedManyWithoutQuizzesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizCreateOrConnectWithoutCategoryInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutCategoryInput, QuizUncheckedCreateWithoutCategoryInput>
  }

  export type QuizCreateManyCategoryInputEnvelope = {
    data: Enumerable<QuizCreateManyCategoryInput>
    skipDuplicates?: boolean
  }

  export type QuizUpsertWithWhereUniqueWithoutCategoryInput = {
    where: QuizWhereUniqueInput
    update: XOR<QuizUpdateWithoutCategoryInput, QuizUncheckedUpdateWithoutCategoryInput>
    create: XOR<QuizCreateWithoutCategoryInput, QuizUncheckedCreateWithoutCategoryInput>
  }

  export type QuizUpdateWithWhereUniqueWithoutCategoryInput = {
    where: QuizWhereUniqueInput
    data: XOR<QuizUpdateWithoutCategoryInput, QuizUncheckedUpdateWithoutCategoryInput>
  }

  export type QuizUpdateManyWithWhereWithoutCategoryInput = {
    where: QuizScalarWhereInput
    data: XOR<QuizUpdateManyMutationInput, QuizUncheckedUpdateManyWithoutQuizzesInput>
  }

  export type QuizScalarWhereInput = {
    AND?: Enumerable<QuizScalarWhereInput>
    OR?: Enumerable<QuizScalarWhereInput>
    NOT?: Enumerable<QuizScalarWhereInput>
    id?: IntFilter | number
    questionText?: StringFilter | string
    quizCategoryId?: IntFilter | number
    correctChoiceId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type QuizCreateWithoutChoicesInput = {
    questionText: string
    category: QuizCategoryCreateNestedOneWithoutQuizzesInput
    correctChoice: ChoiceCreateNestedOneWithoutCorrectQuizzesInput
    rounds?: RoundCreateNestedManyWithoutQuizzesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizUncheckedCreateWithoutChoicesInput = {
    id?: number
    questionText: string
    quizCategoryId: number
    correctChoiceId: number
    rounds?: RoundUncheckedCreateNestedManyWithoutQuizzesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizCreateOrConnectWithoutChoicesInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutChoicesInput, QuizUncheckedCreateWithoutChoicesInput>
  }

  export type QuizCreateWithoutCorrectChoiceInput = {
    questionText: string
    category: QuizCategoryCreateNestedOneWithoutQuizzesInput
    choices?: ChoiceCreateNestedManyWithoutQuizInput
    rounds?: RoundCreateNestedManyWithoutQuizzesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizUncheckedCreateWithoutCorrectChoiceInput = {
    id?: number
    questionText: string
    quizCategoryId: number
    choices?: ChoiceUncheckedCreateNestedManyWithoutQuizInput
    rounds?: RoundUncheckedCreateNestedManyWithoutQuizzesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizCreateOrConnectWithoutCorrectChoiceInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutCorrectChoiceInput, QuizUncheckedCreateWithoutCorrectChoiceInput>
  }

  export type QuizCreateManyCorrectChoiceInputEnvelope = {
    data: Enumerable<QuizCreateManyCorrectChoiceInput>
    skipDuplicates?: boolean
  }

  export type RoundCreateWithoutSelectedChoicesInput = {
    quizzes?: QuizCreateNestedManyWithoutRoundsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoundUncheckedCreateWithoutSelectedChoicesInput = {
    id?: number
    quizzes?: QuizUncheckedCreateNestedManyWithoutRoundsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoundCreateOrConnectWithoutSelectedChoicesInput = {
    where: RoundWhereUniqueInput
    create: XOR<RoundCreateWithoutSelectedChoicesInput, RoundUncheckedCreateWithoutSelectedChoicesInput>
  }

  export type QuizUpsertWithoutChoicesInput = {
    update: XOR<QuizUpdateWithoutChoicesInput, QuizUncheckedUpdateWithoutChoicesInput>
    create: XOR<QuizCreateWithoutChoicesInput, QuizUncheckedCreateWithoutChoicesInput>
  }

  export type QuizUpdateWithoutChoicesInput = {
    questionText?: StringFieldUpdateOperationsInput | string
    category?: QuizCategoryUpdateOneRequiredWithoutQuizzesNestedInput
    correctChoice?: ChoiceUpdateOneRequiredWithoutCorrectQuizzesNestedInput
    rounds?: RoundUpdateManyWithoutQuizzesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizUncheckedUpdateWithoutChoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionText?: StringFieldUpdateOperationsInput | string
    quizCategoryId?: IntFieldUpdateOperationsInput | number
    correctChoiceId?: IntFieldUpdateOperationsInput | number
    rounds?: RoundUncheckedUpdateManyWithoutQuizzesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizUpsertWithWhereUniqueWithoutCorrectChoiceInput = {
    where: QuizWhereUniqueInput
    update: XOR<QuizUpdateWithoutCorrectChoiceInput, QuizUncheckedUpdateWithoutCorrectChoiceInput>
    create: XOR<QuizCreateWithoutCorrectChoiceInput, QuizUncheckedCreateWithoutCorrectChoiceInput>
  }

  export type QuizUpdateWithWhereUniqueWithoutCorrectChoiceInput = {
    where: QuizWhereUniqueInput
    data: XOR<QuizUpdateWithoutCorrectChoiceInput, QuizUncheckedUpdateWithoutCorrectChoiceInput>
  }

  export type QuizUpdateManyWithWhereWithoutCorrectChoiceInput = {
    where: QuizScalarWhereInput
    data: XOR<QuizUpdateManyMutationInput, QuizUncheckedUpdateManyWithoutCorrectQuizzesInput>
  }

  export type RoundUpsertWithWhereUniqueWithoutSelectedChoicesInput = {
    where: RoundWhereUniqueInput
    update: XOR<RoundUpdateWithoutSelectedChoicesInput, RoundUncheckedUpdateWithoutSelectedChoicesInput>
    create: XOR<RoundCreateWithoutSelectedChoicesInput, RoundUncheckedCreateWithoutSelectedChoicesInput>
  }

  export type RoundUpdateWithWhereUniqueWithoutSelectedChoicesInput = {
    where: RoundWhereUniqueInput
    data: XOR<RoundUpdateWithoutSelectedChoicesInput, RoundUncheckedUpdateWithoutSelectedChoicesInput>
  }

  export type RoundUpdateManyWithWhereWithoutSelectedChoicesInput = {
    where: RoundScalarWhereInput
    data: XOR<RoundUpdateManyMutationInput, RoundUncheckedUpdateManyWithoutRoundsInput>
  }

  export type RoundScalarWhereInput = {
    AND?: Enumerable<RoundScalarWhereInput>
    OR?: Enumerable<RoundScalarWhereInput>
    NOT?: Enumerable<RoundScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type QuizCategoryCreateWithoutQuizzesInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizCategoryUncheckedCreateWithoutQuizzesInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizCategoryCreateOrConnectWithoutQuizzesInput = {
    where: QuizCategoryWhereUniqueInput
    create: XOR<QuizCategoryCreateWithoutQuizzesInput, QuizCategoryUncheckedCreateWithoutQuizzesInput>
  }

  export type ChoiceCreateWithoutQuizInput = {
    answerText: string
    correctQuizzes?: QuizCreateNestedManyWithoutCorrectChoiceInput
    rounds?: RoundCreateNestedManyWithoutSelectedChoicesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChoiceUncheckedCreateWithoutQuizInput = {
    id?: number
    answerText: string
    correctQuizzes?: QuizUncheckedCreateNestedManyWithoutCorrectChoiceInput
    rounds?: RoundUncheckedCreateNestedManyWithoutSelectedChoicesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChoiceCreateOrConnectWithoutQuizInput = {
    where: ChoiceWhereUniqueInput
    create: XOR<ChoiceCreateWithoutQuizInput, ChoiceUncheckedCreateWithoutQuizInput>
  }

  export type ChoiceCreateManyQuizInputEnvelope = {
    data: Enumerable<ChoiceCreateManyQuizInput>
    skipDuplicates?: boolean
  }

  export type ChoiceCreateWithoutCorrectQuizzesInput = {
    answerText: string
    quiz?: QuizCreateNestedOneWithoutChoicesInput
    rounds?: RoundCreateNestedManyWithoutSelectedChoicesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChoiceUncheckedCreateWithoutCorrectQuizzesInput = {
    id?: number
    answerText: string
    quizId?: number | null
    rounds?: RoundUncheckedCreateNestedManyWithoutSelectedChoicesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChoiceCreateOrConnectWithoutCorrectQuizzesInput = {
    where: ChoiceWhereUniqueInput
    create: XOR<ChoiceCreateWithoutCorrectQuizzesInput, ChoiceUncheckedCreateWithoutCorrectQuizzesInput>
  }

  export type RoundCreateWithoutQuizzesInput = {
    selectedChoices?: ChoiceCreateNestedManyWithoutRoundsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoundUncheckedCreateWithoutQuizzesInput = {
    id?: number
    selectedChoices?: ChoiceUncheckedCreateNestedManyWithoutRoundsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoundCreateOrConnectWithoutQuizzesInput = {
    where: RoundWhereUniqueInput
    create: XOR<RoundCreateWithoutQuizzesInput, RoundUncheckedCreateWithoutQuizzesInput>
  }

  export type QuizCategoryUpsertWithoutQuizzesInput = {
    update: XOR<QuizCategoryUpdateWithoutQuizzesInput, QuizCategoryUncheckedUpdateWithoutQuizzesInput>
    create: XOR<QuizCategoryCreateWithoutQuizzesInput, QuizCategoryUncheckedCreateWithoutQuizzesInput>
  }

  export type QuizCategoryUpdateWithoutQuizzesInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizCategoryUncheckedUpdateWithoutQuizzesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoiceUpsertWithWhereUniqueWithoutQuizInput = {
    where: ChoiceWhereUniqueInput
    update: XOR<ChoiceUpdateWithoutQuizInput, ChoiceUncheckedUpdateWithoutQuizInput>
    create: XOR<ChoiceCreateWithoutQuizInput, ChoiceUncheckedCreateWithoutQuizInput>
  }

  export type ChoiceUpdateWithWhereUniqueWithoutQuizInput = {
    where: ChoiceWhereUniqueInput
    data: XOR<ChoiceUpdateWithoutQuizInput, ChoiceUncheckedUpdateWithoutQuizInput>
  }

  export type ChoiceUpdateManyWithWhereWithoutQuizInput = {
    where: ChoiceScalarWhereInput
    data: XOR<ChoiceUpdateManyMutationInput, ChoiceUncheckedUpdateManyWithoutChoicesInput>
  }

  export type ChoiceScalarWhereInput = {
    AND?: Enumerable<ChoiceScalarWhereInput>
    OR?: Enumerable<ChoiceScalarWhereInput>
    NOT?: Enumerable<ChoiceScalarWhereInput>
    id?: IntFilter | number
    answerText?: StringFilter | string
    quizId?: IntNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ChoiceUpsertWithoutCorrectQuizzesInput = {
    update: XOR<ChoiceUpdateWithoutCorrectQuizzesInput, ChoiceUncheckedUpdateWithoutCorrectQuizzesInput>
    create: XOR<ChoiceCreateWithoutCorrectQuizzesInput, ChoiceUncheckedCreateWithoutCorrectQuizzesInput>
  }

  export type ChoiceUpdateWithoutCorrectQuizzesInput = {
    answerText?: StringFieldUpdateOperationsInput | string
    quiz?: QuizUpdateOneWithoutChoicesNestedInput
    rounds?: RoundUpdateManyWithoutSelectedChoicesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoiceUncheckedUpdateWithoutCorrectQuizzesInput = {
    id?: IntFieldUpdateOperationsInput | number
    answerText?: StringFieldUpdateOperationsInput | string
    quizId?: NullableIntFieldUpdateOperationsInput | number | null
    rounds?: RoundUncheckedUpdateManyWithoutSelectedChoicesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoundUpsertWithWhereUniqueWithoutQuizzesInput = {
    where: RoundWhereUniqueInput
    update: XOR<RoundUpdateWithoutQuizzesInput, RoundUncheckedUpdateWithoutQuizzesInput>
    create: XOR<RoundCreateWithoutQuizzesInput, RoundUncheckedCreateWithoutQuizzesInput>
  }

  export type RoundUpdateWithWhereUniqueWithoutQuizzesInput = {
    where: RoundWhereUniqueInput
    data: XOR<RoundUpdateWithoutQuizzesInput, RoundUncheckedUpdateWithoutQuizzesInput>
  }

  export type RoundUpdateManyWithWhereWithoutQuizzesInput = {
    where: RoundScalarWhereInput
    data: XOR<RoundUpdateManyMutationInput, RoundUncheckedUpdateManyWithoutRoundsInput>
  }

  export type QuizCreateWithoutRoundsInput = {
    questionText: string
    category: QuizCategoryCreateNestedOneWithoutQuizzesInput
    choices?: ChoiceCreateNestedManyWithoutQuizInput
    correctChoice: ChoiceCreateNestedOneWithoutCorrectQuizzesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizUncheckedCreateWithoutRoundsInput = {
    id?: number
    questionText: string
    quizCategoryId: number
    choices?: ChoiceUncheckedCreateNestedManyWithoutQuizInput
    correctChoiceId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizCreateOrConnectWithoutRoundsInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutRoundsInput, QuizUncheckedCreateWithoutRoundsInput>
  }

  export type ChoiceCreateWithoutRoundsInput = {
    answerText: string
    quiz?: QuizCreateNestedOneWithoutChoicesInput
    correctQuizzes?: QuizCreateNestedManyWithoutCorrectChoiceInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChoiceUncheckedCreateWithoutRoundsInput = {
    id?: number
    answerText: string
    quizId?: number | null
    correctQuizzes?: QuizUncheckedCreateNestedManyWithoutCorrectChoiceInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChoiceCreateOrConnectWithoutRoundsInput = {
    where: ChoiceWhereUniqueInput
    create: XOR<ChoiceCreateWithoutRoundsInput, ChoiceUncheckedCreateWithoutRoundsInput>
  }

  export type QuizUpsertWithWhereUniqueWithoutRoundsInput = {
    where: QuizWhereUniqueInput
    update: XOR<QuizUpdateWithoutRoundsInput, QuizUncheckedUpdateWithoutRoundsInput>
    create: XOR<QuizCreateWithoutRoundsInput, QuizUncheckedCreateWithoutRoundsInput>
  }

  export type QuizUpdateWithWhereUniqueWithoutRoundsInput = {
    where: QuizWhereUniqueInput
    data: XOR<QuizUpdateWithoutRoundsInput, QuizUncheckedUpdateWithoutRoundsInput>
  }

  export type QuizUpdateManyWithWhereWithoutRoundsInput = {
    where: QuizScalarWhereInput
    data: XOR<QuizUpdateManyMutationInput, QuizUncheckedUpdateManyWithoutQuizzesInput>
  }

  export type ChoiceUpsertWithWhereUniqueWithoutRoundsInput = {
    where: ChoiceWhereUniqueInput
    update: XOR<ChoiceUpdateWithoutRoundsInput, ChoiceUncheckedUpdateWithoutRoundsInput>
    create: XOR<ChoiceCreateWithoutRoundsInput, ChoiceUncheckedCreateWithoutRoundsInput>
  }

  export type ChoiceUpdateWithWhereUniqueWithoutRoundsInput = {
    where: ChoiceWhereUniqueInput
    data: XOR<ChoiceUpdateWithoutRoundsInput, ChoiceUncheckedUpdateWithoutRoundsInput>
  }

  export type ChoiceUpdateManyWithWhereWithoutRoundsInput = {
    where: ChoiceScalarWhereInput
    data: XOR<ChoiceUpdateManyMutationInput, ChoiceUncheckedUpdateManyWithoutSelectedChoicesInput>
  }

  export type BranchCreateWithoutBranchOwnerInput = {
    name: string
    location: string
    telephoneNo: string
    area: number
    washingMachines?: WashingMachineCreateNestedManyWithoutLocatedBranchInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BranchUncheckedCreateWithoutBranchOwnerInput = {
    id?: number
    name: string
    location: string
    telephoneNo: string
    area: number
    washingMachines?: WashingMachineUncheckedCreateNestedManyWithoutLocatedBranchInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BranchCreateOrConnectWithoutBranchOwnerInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutBranchOwnerInput, BranchUncheckedCreateWithoutBranchOwnerInput>
  }

  export type BranchCreateManyBranchOwnerInputEnvelope = {
    data: Enumerable<BranchCreateManyBranchOwnerInput>
    skipDuplicates?: boolean
  }

  export type WMMaintenanceRecordCreateWithoutMaintainerInput = {
    maintainedWM: WashingMachineCreateNestedOneWithoutWMMaintenanceRecordsInput
    maintenanceDateTime: Date | string
    level: number
    details: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WMMaintenanceRecordUncheckedCreateWithoutMaintainerInput = {
    id?: number
    washingMachineId: number
    maintenanceDateTime: Date | string
    level: number
    details: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WMMaintenanceRecordCreateOrConnectWithoutMaintainerInput = {
    where: WMMaintenanceRecordWhereUniqueInput
    create: XOR<WMMaintenanceRecordCreateWithoutMaintainerInput, WMMaintenanceRecordUncheckedCreateWithoutMaintainerInput>
  }

  export type WMMaintenanceRecordCreateManyMaintainerInputEnvelope = {
    data: Enumerable<WMMaintenanceRecordCreateManyMaintainerInput>
    skipDuplicates?: boolean
  }

  export type UsageRecordCreateWithoutUserInput = {
    dateTime: Date | string
    washingMachine: WashingMachineCreateNestedOneWithoutUsageRecordsInput
    program: WMProgramCreateNestedOneWithoutUsageRecordsInput
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsageRecordUncheckedCreateWithoutUserInput = {
    id?: number
    dateTime: Date | string
    washingMachineId: number
    wMProgramId: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsageRecordCreateOrConnectWithoutUserInput = {
    where: UsageRecordWhereUniqueInput
    create: XOR<UsageRecordCreateWithoutUserInput, UsageRecordUncheckedCreateWithoutUserInput>
  }

  export type UsageRecordCreateManyUserInputEnvelope = {
    data: Enumerable<UsageRecordCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type TopUpRecordCreateWithoutUserInput = {
    dateTime: Date | string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TopUpRecordUncheckedCreateWithoutUserInput = {
    id?: number
    dateTime: Date | string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TopUpRecordCreateOrConnectWithoutUserInput = {
    where: TopUpRecordWhereUniqueInput
    create: XOR<TopUpRecordCreateWithoutUserInput, TopUpRecordUncheckedCreateWithoutUserInput>
  }

  export type TopUpRecordCreateManyUserInputEnvelope = {
    data: Enumerable<TopUpRecordCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithWhereUniqueWithoutBranchOwnerInput = {
    where: BranchWhereUniqueInput
    update: XOR<BranchUpdateWithoutBranchOwnerInput, BranchUncheckedUpdateWithoutBranchOwnerInput>
    create: XOR<BranchCreateWithoutBranchOwnerInput, BranchUncheckedCreateWithoutBranchOwnerInput>
  }

  export type BranchUpdateWithWhereUniqueWithoutBranchOwnerInput = {
    where: BranchWhereUniqueInput
    data: XOR<BranchUpdateWithoutBranchOwnerInput, BranchUncheckedUpdateWithoutBranchOwnerInput>
  }

  export type BranchUpdateManyWithWhereWithoutBranchOwnerInput = {
    where: BranchScalarWhereInput
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyWithoutOwningBranchesInput>
  }

  export type BranchScalarWhereInput = {
    AND?: Enumerable<BranchScalarWhereInput>
    OR?: Enumerable<BranchScalarWhereInput>
    NOT?: Enumerable<BranchScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    location?: StringFilter | string
    telephoneNo?: StringFilter | string
    area?: FloatFilter | number
    binWashUserId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type WMMaintenanceRecordUpsertWithWhereUniqueWithoutMaintainerInput = {
    where: WMMaintenanceRecordWhereUniqueInput
    update: XOR<WMMaintenanceRecordUpdateWithoutMaintainerInput, WMMaintenanceRecordUncheckedUpdateWithoutMaintainerInput>
    create: XOR<WMMaintenanceRecordCreateWithoutMaintainerInput, WMMaintenanceRecordUncheckedCreateWithoutMaintainerInput>
  }

  export type WMMaintenanceRecordUpdateWithWhereUniqueWithoutMaintainerInput = {
    where: WMMaintenanceRecordWhereUniqueInput
    data: XOR<WMMaintenanceRecordUpdateWithoutMaintainerInput, WMMaintenanceRecordUncheckedUpdateWithoutMaintainerInput>
  }

  export type WMMaintenanceRecordUpdateManyWithWhereWithoutMaintainerInput = {
    where: WMMaintenanceRecordScalarWhereInput
    data: XOR<WMMaintenanceRecordUpdateManyMutationInput, WMMaintenanceRecordUncheckedUpdateManyWithoutWMMaintenanceRecordsInput>
  }

  export type WMMaintenanceRecordScalarWhereInput = {
    AND?: Enumerable<WMMaintenanceRecordScalarWhereInput>
    OR?: Enumerable<WMMaintenanceRecordScalarWhereInput>
    NOT?: Enumerable<WMMaintenanceRecordScalarWhereInput>
    id?: IntFilter | number
    washingMachineId?: IntFilter | number
    maintenanceDateTime?: DateTimeFilter | Date | string
    level?: IntFilter | number
    details?: StringFilter | string
    binWashUserId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type UsageRecordUpsertWithWhereUniqueWithoutUserInput = {
    where: UsageRecordWhereUniqueInput
    update: XOR<UsageRecordUpdateWithoutUserInput, UsageRecordUncheckedUpdateWithoutUserInput>
    create: XOR<UsageRecordCreateWithoutUserInput, UsageRecordUncheckedCreateWithoutUserInput>
  }

  export type UsageRecordUpdateWithWhereUniqueWithoutUserInput = {
    where: UsageRecordWhereUniqueInput
    data: XOR<UsageRecordUpdateWithoutUserInput, UsageRecordUncheckedUpdateWithoutUserInput>
  }

  export type UsageRecordUpdateManyWithWhereWithoutUserInput = {
    where: UsageRecordScalarWhereInput
    data: XOR<UsageRecordUpdateManyMutationInput, UsageRecordUncheckedUpdateManyWithoutUsageRecordsInput>
  }

  export type UsageRecordScalarWhereInput = {
    AND?: Enumerable<UsageRecordScalarWhereInput>
    OR?: Enumerable<UsageRecordScalarWhereInput>
    NOT?: Enumerable<UsageRecordScalarWhereInput>
    id?: IntFilter | number
    dateTime?: DateTimeFilter | Date | string
    binWashUserId?: IntFilter | number
    washingMachineId?: IntFilter | number
    wMProgramId?: IntFilter | number
    price?: FloatFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TopUpRecordUpsertWithWhereUniqueWithoutUserInput = {
    where: TopUpRecordWhereUniqueInput
    update: XOR<TopUpRecordUpdateWithoutUserInput, TopUpRecordUncheckedUpdateWithoutUserInput>
    create: XOR<TopUpRecordCreateWithoutUserInput, TopUpRecordUncheckedCreateWithoutUserInput>
  }

  export type TopUpRecordUpdateWithWhereUniqueWithoutUserInput = {
    where: TopUpRecordWhereUniqueInput
    data: XOR<TopUpRecordUpdateWithoutUserInput, TopUpRecordUncheckedUpdateWithoutUserInput>
  }

  export type TopUpRecordUpdateManyWithWhereWithoutUserInput = {
    where: TopUpRecordScalarWhereInput
    data: XOR<TopUpRecordUpdateManyMutationInput, TopUpRecordUncheckedUpdateManyWithoutTopUpRecordsInput>
  }

  export type TopUpRecordScalarWhereInput = {
    AND?: Enumerable<TopUpRecordScalarWhereInput>
    OR?: Enumerable<TopUpRecordScalarWhereInput>
    NOT?: Enumerable<TopUpRecordScalarWhereInput>
    id?: IntFilter | number
    dateTime?: DateTimeFilter | Date | string
    binWashUserId?: IntFilter | number
    price?: FloatFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type BinWashUserCreateWithoutOwningBranchesInput = {
    name: string
    balance: number
    wMMaintenanceRecords?: WMMaintenanceRecordCreateNestedManyWithoutMaintainerInput
    usageRecords?: UsageRecordCreateNestedManyWithoutUserInput
    topUpRecords?: TopUpRecordCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinWashUserUncheckedCreateWithoutOwningBranchesInput = {
    id?: number
    name: string
    balance: number
    wMMaintenanceRecords?: WMMaintenanceRecordUncheckedCreateNestedManyWithoutMaintainerInput
    usageRecords?: UsageRecordUncheckedCreateNestedManyWithoutUserInput
    topUpRecords?: TopUpRecordUncheckedCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinWashUserCreateOrConnectWithoutOwningBranchesInput = {
    where: BinWashUserWhereUniqueInput
    create: XOR<BinWashUserCreateWithoutOwningBranchesInput, BinWashUserUncheckedCreateWithoutOwningBranchesInput>
  }

  export type WashingMachineCreateWithoutLocatedBranchInput = {
    brand: string
    model: string
    type: WMTypeEnum
    capacity: number
    manufacturedYear: Date | string
    warrantyEndDate: Date | string
    equippedPrograms?: WMProgramCreateNestedManyWithoutEquippingWMsInput
    usageRecords?: UsageRecordCreateNestedManyWithoutWashingMachineInput
    wMMaintenanceRecords?: WMMaintenanceRecordCreateNestedManyWithoutMaintainedWMInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WashingMachineUncheckedCreateWithoutLocatedBranchInput = {
    id?: number
    brand: string
    model: string
    type: WMTypeEnum
    capacity: number
    manufacturedYear: Date | string
    warrantyEndDate: Date | string
    equippedPrograms?: WMProgramUncheckedCreateNestedManyWithoutEquippingWMsInput
    usageRecords?: UsageRecordUncheckedCreateNestedManyWithoutWashingMachineInput
    wMMaintenanceRecords?: WMMaintenanceRecordUncheckedCreateNestedManyWithoutMaintainedWMInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WashingMachineCreateOrConnectWithoutLocatedBranchInput = {
    where: WashingMachineWhereUniqueInput
    create: XOR<WashingMachineCreateWithoutLocatedBranchInput, WashingMachineUncheckedCreateWithoutLocatedBranchInput>
  }

  export type WashingMachineCreateManyLocatedBranchInputEnvelope = {
    data: Enumerable<WashingMachineCreateManyLocatedBranchInput>
    skipDuplicates?: boolean
  }

  export type BinWashUserUpsertWithoutOwningBranchesInput = {
    update: XOR<BinWashUserUpdateWithoutOwningBranchesInput, BinWashUserUncheckedUpdateWithoutOwningBranchesInput>
    create: XOR<BinWashUserCreateWithoutOwningBranchesInput, BinWashUserUncheckedCreateWithoutOwningBranchesInput>
  }

  export type BinWashUserUpdateWithoutOwningBranchesInput = {
    name?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    wMMaintenanceRecords?: WMMaintenanceRecordUpdateManyWithoutMaintainerNestedInput
    usageRecords?: UsageRecordUpdateManyWithoutUserNestedInput
    topUpRecords?: TopUpRecordUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinWashUserUncheckedUpdateWithoutOwningBranchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    wMMaintenanceRecords?: WMMaintenanceRecordUncheckedUpdateManyWithoutMaintainerNestedInput
    usageRecords?: UsageRecordUncheckedUpdateManyWithoutUserNestedInput
    topUpRecords?: TopUpRecordUncheckedUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WashingMachineUpsertWithWhereUniqueWithoutLocatedBranchInput = {
    where: WashingMachineWhereUniqueInput
    update: XOR<WashingMachineUpdateWithoutLocatedBranchInput, WashingMachineUncheckedUpdateWithoutLocatedBranchInput>
    create: XOR<WashingMachineCreateWithoutLocatedBranchInput, WashingMachineUncheckedCreateWithoutLocatedBranchInput>
  }

  export type WashingMachineUpdateWithWhereUniqueWithoutLocatedBranchInput = {
    where: WashingMachineWhereUniqueInput
    data: XOR<WashingMachineUpdateWithoutLocatedBranchInput, WashingMachineUncheckedUpdateWithoutLocatedBranchInput>
  }

  export type WashingMachineUpdateManyWithWhereWithoutLocatedBranchInput = {
    where: WashingMachineScalarWhereInput
    data: XOR<WashingMachineUpdateManyMutationInput, WashingMachineUncheckedUpdateManyWithoutWashingMachinesInput>
  }

  export type WashingMachineScalarWhereInput = {
    AND?: Enumerable<WashingMachineScalarWhereInput>
    OR?: Enumerable<WashingMachineScalarWhereInput>
    NOT?: Enumerable<WashingMachineScalarWhereInput>
    id?: IntFilter | number
    brand?: StringFilter | string
    model?: StringFilter | string
    type?: EnumWMTypeEnumFilter | WMTypeEnum
    capacity?: FloatFilter | number
    manufacturedYear?: DateTimeFilter | Date | string
    warrantyEndDate?: DateTimeFilter | Date | string
    branchId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type BranchCreateWithoutWashingMachinesInput = {
    name: string
    location: string
    telephoneNo: string
    area: number
    branchOwner: BinWashUserCreateNestedOneWithoutOwningBranchesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BranchUncheckedCreateWithoutWashingMachinesInput = {
    id?: number
    name: string
    location: string
    telephoneNo: string
    area: number
    binWashUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BranchCreateOrConnectWithoutWashingMachinesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutWashingMachinesInput, BranchUncheckedCreateWithoutWashingMachinesInput>
  }

  export type WMProgramCreateWithoutEquippingWMsInput = {
    name: string
    maxCapacity: number
    duration: number
    price: number
    usageRecords?: UsageRecordCreateNestedManyWithoutProgramInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WMProgramUncheckedCreateWithoutEquippingWMsInput = {
    id?: number
    name: string
    maxCapacity: number
    duration: number
    price: number
    usageRecords?: UsageRecordUncheckedCreateNestedManyWithoutProgramInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WMProgramCreateOrConnectWithoutEquippingWMsInput = {
    where: WMProgramWhereUniqueInput
    create: XOR<WMProgramCreateWithoutEquippingWMsInput, WMProgramUncheckedCreateWithoutEquippingWMsInput>
  }

  export type UsageRecordCreateWithoutWashingMachineInput = {
    dateTime: Date | string
    user: BinWashUserCreateNestedOneWithoutUsageRecordsInput
    program: WMProgramCreateNestedOneWithoutUsageRecordsInput
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsageRecordUncheckedCreateWithoutWashingMachineInput = {
    id?: number
    dateTime: Date | string
    binWashUserId: number
    wMProgramId: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsageRecordCreateOrConnectWithoutWashingMachineInput = {
    where: UsageRecordWhereUniqueInput
    create: XOR<UsageRecordCreateWithoutWashingMachineInput, UsageRecordUncheckedCreateWithoutWashingMachineInput>
  }

  export type UsageRecordCreateManyWashingMachineInputEnvelope = {
    data: Enumerable<UsageRecordCreateManyWashingMachineInput>
    skipDuplicates?: boolean
  }

  export type WMMaintenanceRecordCreateWithoutMaintainedWMInput = {
    maintenanceDateTime: Date | string
    level: number
    details: string
    maintainer: BinWashUserCreateNestedOneWithoutWMMaintenanceRecordsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WMMaintenanceRecordUncheckedCreateWithoutMaintainedWMInput = {
    id?: number
    maintenanceDateTime: Date | string
    level: number
    details: string
    binWashUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WMMaintenanceRecordCreateOrConnectWithoutMaintainedWMInput = {
    where: WMMaintenanceRecordWhereUniqueInput
    create: XOR<WMMaintenanceRecordCreateWithoutMaintainedWMInput, WMMaintenanceRecordUncheckedCreateWithoutMaintainedWMInput>
  }

  export type WMMaintenanceRecordCreateManyMaintainedWMInputEnvelope = {
    data: Enumerable<WMMaintenanceRecordCreateManyMaintainedWMInput>
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutWashingMachinesInput = {
    update: XOR<BranchUpdateWithoutWashingMachinesInput, BranchUncheckedUpdateWithoutWashingMachinesInput>
    create: XOR<BranchCreateWithoutWashingMachinesInput, BranchUncheckedCreateWithoutWashingMachinesInput>
  }

  export type BranchUpdateWithoutWashingMachinesInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    telephoneNo?: StringFieldUpdateOperationsInput | string
    area?: FloatFieldUpdateOperationsInput | number
    branchOwner?: BinWashUserUpdateOneRequiredWithoutOwningBranchesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchUncheckedUpdateWithoutWashingMachinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    telephoneNo?: StringFieldUpdateOperationsInput | string
    area?: FloatFieldUpdateOperationsInput | number
    binWashUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WMProgramUpsertWithWhereUniqueWithoutEquippingWMsInput = {
    where: WMProgramWhereUniqueInput
    update: XOR<WMProgramUpdateWithoutEquippingWMsInput, WMProgramUncheckedUpdateWithoutEquippingWMsInput>
    create: XOR<WMProgramCreateWithoutEquippingWMsInput, WMProgramUncheckedCreateWithoutEquippingWMsInput>
  }

  export type WMProgramUpdateWithWhereUniqueWithoutEquippingWMsInput = {
    where: WMProgramWhereUniqueInput
    data: XOR<WMProgramUpdateWithoutEquippingWMsInput, WMProgramUncheckedUpdateWithoutEquippingWMsInput>
  }

  export type WMProgramUpdateManyWithWhereWithoutEquippingWMsInput = {
    where: WMProgramScalarWhereInput
    data: XOR<WMProgramUpdateManyMutationInput, WMProgramUncheckedUpdateManyWithoutEquippedProgramsInput>
  }

  export type WMProgramScalarWhereInput = {
    AND?: Enumerable<WMProgramScalarWhereInput>
    OR?: Enumerable<WMProgramScalarWhereInput>
    NOT?: Enumerable<WMProgramScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    maxCapacity?: FloatFilter | number
    duration?: IntFilter | number
    price?: FloatFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type UsageRecordUpsertWithWhereUniqueWithoutWashingMachineInput = {
    where: UsageRecordWhereUniqueInput
    update: XOR<UsageRecordUpdateWithoutWashingMachineInput, UsageRecordUncheckedUpdateWithoutWashingMachineInput>
    create: XOR<UsageRecordCreateWithoutWashingMachineInput, UsageRecordUncheckedCreateWithoutWashingMachineInput>
  }

  export type UsageRecordUpdateWithWhereUniqueWithoutWashingMachineInput = {
    where: UsageRecordWhereUniqueInput
    data: XOR<UsageRecordUpdateWithoutWashingMachineInput, UsageRecordUncheckedUpdateWithoutWashingMachineInput>
  }

  export type UsageRecordUpdateManyWithWhereWithoutWashingMachineInput = {
    where: UsageRecordScalarWhereInput
    data: XOR<UsageRecordUpdateManyMutationInput, UsageRecordUncheckedUpdateManyWithoutUsageRecordsInput>
  }

  export type WMMaintenanceRecordUpsertWithWhereUniqueWithoutMaintainedWMInput = {
    where: WMMaintenanceRecordWhereUniqueInput
    update: XOR<WMMaintenanceRecordUpdateWithoutMaintainedWMInput, WMMaintenanceRecordUncheckedUpdateWithoutMaintainedWMInput>
    create: XOR<WMMaintenanceRecordCreateWithoutMaintainedWMInput, WMMaintenanceRecordUncheckedCreateWithoutMaintainedWMInput>
  }

  export type WMMaintenanceRecordUpdateWithWhereUniqueWithoutMaintainedWMInput = {
    where: WMMaintenanceRecordWhereUniqueInput
    data: XOR<WMMaintenanceRecordUpdateWithoutMaintainedWMInput, WMMaintenanceRecordUncheckedUpdateWithoutMaintainedWMInput>
  }

  export type WMMaintenanceRecordUpdateManyWithWhereWithoutMaintainedWMInput = {
    where: WMMaintenanceRecordScalarWhereInput
    data: XOR<WMMaintenanceRecordUpdateManyMutationInput, WMMaintenanceRecordUncheckedUpdateManyWithoutWMMaintenanceRecordsInput>
  }

  export type WashingMachineCreateWithoutEquippedProgramsInput = {
    brand: string
    model: string
    type: WMTypeEnum
    capacity: number
    manufacturedYear: Date | string
    warrantyEndDate: Date | string
    locatedBranch: BranchCreateNestedOneWithoutWashingMachinesInput
    usageRecords?: UsageRecordCreateNestedManyWithoutWashingMachineInput
    wMMaintenanceRecords?: WMMaintenanceRecordCreateNestedManyWithoutMaintainedWMInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WashingMachineUncheckedCreateWithoutEquippedProgramsInput = {
    id?: number
    brand: string
    model: string
    type: WMTypeEnum
    capacity: number
    manufacturedYear: Date | string
    warrantyEndDate: Date | string
    branchId: number
    usageRecords?: UsageRecordUncheckedCreateNestedManyWithoutWashingMachineInput
    wMMaintenanceRecords?: WMMaintenanceRecordUncheckedCreateNestedManyWithoutMaintainedWMInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WashingMachineCreateOrConnectWithoutEquippedProgramsInput = {
    where: WashingMachineWhereUniqueInput
    create: XOR<WashingMachineCreateWithoutEquippedProgramsInput, WashingMachineUncheckedCreateWithoutEquippedProgramsInput>
  }

  export type UsageRecordCreateWithoutProgramInput = {
    dateTime: Date | string
    user: BinWashUserCreateNestedOneWithoutUsageRecordsInput
    washingMachine: WashingMachineCreateNestedOneWithoutUsageRecordsInput
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsageRecordUncheckedCreateWithoutProgramInput = {
    id?: number
    dateTime: Date | string
    binWashUserId: number
    washingMachineId: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsageRecordCreateOrConnectWithoutProgramInput = {
    where: UsageRecordWhereUniqueInput
    create: XOR<UsageRecordCreateWithoutProgramInput, UsageRecordUncheckedCreateWithoutProgramInput>
  }

  export type UsageRecordCreateManyProgramInputEnvelope = {
    data: Enumerable<UsageRecordCreateManyProgramInput>
    skipDuplicates?: boolean
  }

  export type WashingMachineUpsertWithWhereUniqueWithoutEquippedProgramsInput = {
    where: WashingMachineWhereUniqueInput
    update: XOR<WashingMachineUpdateWithoutEquippedProgramsInput, WashingMachineUncheckedUpdateWithoutEquippedProgramsInput>
    create: XOR<WashingMachineCreateWithoutEquippedProgramsInput, WashingMachineUncheckedCreateWithoutEquippedProgramsInput>
  }

  export type WashingMachineUpdateWithWhereUniqueWithoutEquippedProgramsInput = {
    where: WashingMachineWhereUniqueInput
    data: XOR<WashingMachineUpdateWithoutEquippedProgramsInput, WashingMachineUncheckedUpdateWithoutEquippedProgramsInput>
  }

  export type WashingMachineUpdateManyWithWhereWithoutEquippedProgramsInput = {
    where: WashingMachineScalarWhereInput
    data: XOR<WashingMachineUpdateManyMutationInput, WashingMachineUncheckedUpdateManyWithoutEquippingWMsInput>
  }

  export type UsageRecordUpsertWithWhereUniqueWithoutProgramInput = {
    where: UsageRecordWhereUniqueInput
    update: XOR<UsageRecordUpdateWithoutProgramInput, UsageRecordUncheckedUpdateWithoutProgramInput>
    create: XOR<UsageRecordCreateWithoutProgramInput, UsageRecordUncheckedCreateWithoutProgramInput>
  }

  export type UsageRecordUpdateWithWhereUniqueWithoutProgramInput = {
    where: UsageRecordWhereUniqueInput
    data: XOR<UsageRecordUpdateWithoutProgramInput, UsageRecordUncheckedUpdateWithoutProgramInput>
  }

  export type UsageRecordUpdateManyWithWhereWithoutProgramInput = {
    where: UsageRecordScalarWhereInput
    data: XOR<UsageRecordUpdateManyMutationInput, UsageRecordUncheckedUpdateManyWithoutUsageRecordsInput>
  }

  export type WashingMachineCreateWithoutWMMaintenanceRecordsInput = {
    brand: string
    model: string
    type: WMTypeEnum
    capacity: number
    manufacturedYear: Date | string
    warrantyEndDate: Date | string
    locatedBranch: BranchCreateNestedOneWithoutWashingMachinesInput
    equippedPrograms?: WMProgramCreateNestedManyWithoutEquippingWMsInput
    usageRecords?: UsageRecordCreateNestedManyWithoutWashingMachineInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WashingMachineUncheckedCreateWithoutWMMaintenanceRecordsInput = {
    id?: number
    brand: string
    model: string
    type: WMTypeEnum
    capacity: number
    manufacturedYear: Date | string
    warrantyEndDate: Date | string
    branchId: number
    equippedPrograms?: WMProgramUncheckedCreateNestedManyWithoutEquippingWMsInput
    usageRecords?: UsageRecordUncheckedCreateNestedManyWithoutWashingMachineInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WashingMachineCreateOrConnectWithoutWMMaintenanceRecordsInput = {
    where: WashingMachineWhereUniqueInput
    create: XOR<WashingMachineCreateWithoutWMMaintenanceRecordsInput, WashingMachineUncheckedCreateWithoutWMMaintenanceRecordsInput>
  }

  export type BinWashUserCreateWithoutWMMaintenanceRecordsInput = {
    name: string
    balance: number
    owningBranches?: BranchCreateNestedManyWithoutBranchOwnerInput
    usageRecords?: UsageRecordCreateNestedManyWithoutUserInput
    topUpRecords?: TopUpRecordCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinWashUserUncheckedCreateWithoutWMMaintenanceRecordsInput = {
    id?: number
    name: string
    balance: number
    owningBranches?: BranchUncheckedCreateNestedManyWithoutBranchOwnerInput
    usageRecords?: UsageRecordUncheckedCreateNestedManyWithoutUserInput
    topUpRecords?: TopUpRecordUncheckedCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinWashUserCreateOrConnectWithoutWMMaintenanceRecordsInput = {
    where: BinWashUserWhereUniqueInput
    create: XOR<BinWashUserCreateWithoutWMMaintenanceRecordsInput, BinWashUserUncheckedCreateWithoutWMMaintenanceRecordsInput>
  }

  export type WashingMachineUpsertWithoutWMMaintenanceRecordsInput = {
    update: XOR<WashingMachineUpdateWithoutWMMaintenanceRecordsInput, WashingMachineUncheckedUpdateWithoutWMMaintenanceRecordsInput>
    create: XOR<WashingMachineCreateWithoutWMMaintenanceRecordsInput, WashingMachineUncheckedCreateWithoutWMMaintenanceRecordsInput>
  }

  export type WashingMachineUpdateWithoutWMMaintenanceRecordsInput = {
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    type?: EnumWMTypeEnumFieldUpdateOperationsInput | WMTypeEnum
    capacity?: FloatFieldUpdateOperationsInput | number
    manufacturedYear?: DateTimeFieldUpdateOperationsInput | Date | string
    warrantyEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    locatedBranch?: BranchUpdateOneRequiredWithoutWashingMachinesNestedInput
    equippedPrograms?: WMProgramUpdateManyWithoutEquippingWMsNestedInput
    usageRecords?: UsageRecordUpdateManyWithoutWashingMachineNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WashingMachineUncheckedUpdateWithoutWMMaintenanceRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    type?: EnumWMTypeEnumFieldUpdateOperationsInput | WMTypeEnum
    capacity?: FloatFieldUpdateOperationsInput | number
    manufacturedYear?: DateTimeFieldUpdateOperationsInput | Date | string
    warrantyEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: IntFieldUpdateOperationsInput | number
    equippedPrograms?: WMProgramUncheckedUpdateManyWithoutEquippingWMsNestedInput
    usageRecords?: UsageRecordUncheckedUpdateManyWithoutWashingMachineNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinWashUserUpsertWithoutWMMaintenanceRecordsInput = {
    update: XOR<BinWashUserUpdateWithoutWMMaintenanceRecordsInput, BinWashUserUncheckedUpdateWithoutWMMaintenanceRecordsInput>
    create: XOR<BinWashUserCreateWithoutWMMaintenanceRecordsInput, BinWashUserUncheckedCreateWithoutWMMaintenanceRecordsInput>
  }

  export type BinWashUserUpdateWithoutWMMaintenanceRecordsInput = {
    name?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    owningBranches?: BranchUpdateManyWithoutBranchOwnerNestedInput
    usageRecords?: UsageRecordUpdateManyWithoutUserNestedInput
    topUpRecords?: TopUpRecordUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinWashUserUncheckedUpdateWithoutWMMaintenanceRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    owningBranches?: BranchUncheckedUpdateManyWithoutBranchOwnerNestedInput
    usageRecords?: UsageRecordUncheckedUpdateManyWithoutUserNestedInput
    topUpRecords?: TopUpRecordUncheckedUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinWashUserCreateWithoutUsageRecordsInput = {
    name: string
    balance: number
    owningBranches?: BranchCreateNestedManyWithoutBranchOwnerInput
    wMMaintenanceRecords?: WMMaintenanceRecordCreateNestedManyWithoutMaintainerInput
    topUpRecords?: TopUpRecordCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinWashUserUncheckedCreateWithoutUsageRecordsInput = {
    id?: number
    name: string
    balance: number
    owningBranches?: BranchUncheckedCreateNestedManyWithoutBranchOwnerInput
    wMMaintenanceRecords?: WMMaintenanceRecordUncheckedCreateNestedManyWithoutMaintainerInput
    topUpRecords?: TopUpRecordUncheckedCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinWashUserCreateOrConnectWithoutUsageRecordsInput = {
    where: BinWashUserWhereUniqueInput
    create: XOR<BinWashUserCreateWithoutUsageRecordsInput, BinWashUserUncheckedCreateWithoutUsageRecordsInput>
  }

  export type WashingMachineCreateWithoutUsageRecordsInput = {
    brand: string
    model: string
    type: WMTypeEnum
    capacity: number
    manufacturedYear: Date | string
    warrantyEndDate: Date | string
    locatedBranch: BranchCreateNestedOneWithoutWashingMachinesInput
    equippedPrograms?: WMProgramCreateNestedManyWithoutEquippingWMsInput
    wMMaintenanceRecords?: WMMaintenanceRecordCreateNestedManyWithoutMaintainedWMInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WashingMachineUncheckedCreateWithoutUsageRecordsInput = {
    id?: number
    brand: string
    model: string
    type: WMTypeEnum
    capacity: number
    manufacturedYear: Date | string
    warrantyEndDate: Date | string
    branchId: number
    equippedPrograms?: WMProgramUncheckedCreateNestedManyWithoutEquippingWMsInput
    wMMaintenanceRecords?: WMMaintenanceRecordUncheckedCreateNestedManyWithoutMaintainedWMInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WashingMachineCreateOrConnectWithoutUsageRecordsInput = {
    where: WashingMachineWhereUniqueInput
    create: XOR<WashingMachineCreateWithoutUsageRecordsInput, WashingMachineUncheckedCreateWithoutUsageRecordsInput>
  }

  export type WMProgramCreateWithoutUsageRecordsInput = {
    name: string
    maxCapacity: number
    duration: number
    price: number
    equippingWMs?: WashingMachineCreateNestedManyWithoutEquippedProgramsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WMProgramUncheckedCreateWithoutUsageRecordsInput = {
    id?: number
    name: string
    maxCapacity: number
    duration: number
    price: number
    equippingWMs?: WashingMachineUncheckedCreateNestedManyWithoutEquippedProgramsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WMProgramCreateOrConnectWithoutUsageRecordsInput = {
    where: WMProgramWhereUniqueInput
    create: XOR<WMProgramCreateWithoutUsageRecordsInput, WMProgramUncheckedCreateWithoutUsageRecordsInput>
  }

  export type BinWashUserUpsertWithoutUsageRecordsInput = {
    update: XOR<BinWashUserUpdateWithoutUsageRecordsInput, BinWashUserUncheckedUpdateWithoutUsageRecordsInput>
    create: XOR<BinWashUserCreateWithoutUsageRecordsInput, BinWashUserUncheckedCreateWithoutUsageRecordsInput>
  }

  export type BinWashUserUpdateWithoutUsageRecordsInput = {
    name?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    owningBranches?: BranchUpdateManyWithoutBranchOwnerNestedInput
    wMMaintenanceRecords?: WMMaintenanceRecordUpdateManyWithoutMaintainerNestedInput
    topUpRecords?: TopUpRecordUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinWashUserUncheckedUpdateWithoutUsageRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    owningBranches?: BranchUncheckedUpdateManyWithoutBranchOwnerNestedInput
    wMMaintenanceRecords?: WMMaintenanceRecordUncheckedUpdateManyWithoutMaintainerNestedInput
    topUpRecords?: TopUpRecordUncheckedUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WashingMachineUpsertWithoutUsageRecordsInput = {
    update: XOR<WashingMachineUpdateWithoutUsageRecordsInput, WashingMachineUncheckedUpdateWithoutUsageRecordsInput>
    create: XOR<WashingMachineCreateWithoutUsageRecordsInput, WashingMachineUncheckedCreateWithoutUsageRecordsInput>
  }

  export type WashingMachineUpdateWithoutUsageRecordsInput = {
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    type?: EnumWMTypeEnumFieldUpdateOperationsInput | WMTypeEnum
    capacity?: FloatFieldUpdateOperationsInput | number
    manufacturedYear?: DateTimeFieldUpdateOperationsInput | Date | string
    warrantyEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    locatedBranch?: BranchUpdateOneRequiredWithoutWashingMachinesNestedInput
    equippedPrograms?: WMProgramUpdateManyWithoutEquippingWMsNestedInput
    wMMaintenanceRecords?: WMMaintenanceRecordUpdateManyWithoutMaintainedWMNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WashingMachineUncheckedUpdateWithoutUsageRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    type?: EnumWMTypeEnumFieldUpdateOperationsInput | WMTypeEnum
    capacity?: FloatFieldUpdateOperationsInput | number
    manufacturedYear?: DateTimeFieldUpdateOperationsInput | Date | string
    warrantyEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: IntFieldUpdateOperationsInput | number
    equippedPrograms?: WMProgramUncheckedUpdateManyWithoutEquippingWMsNestedInput
    wMMaintenanceRecords?: WMMaintenanceRecordUncheckedUpdateManyWithoutMaintainedWMNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WMProgramUpsertWithoutUsageRecordsInput = {
    update: XOR<WMProgramUpdateWithoutUsageRecordsInput, WMProgramUncheckedUpdateWithoutUsageRecordsInput>
    create: XOR<WMProgramCreateWithoutUsageRecordsInput, WMProgramUncheckedCreateWithoutUsageRecordsInput>
  }

  export type WMProgramUpdateWithoutUsageRecordsInput = {
    name?: StringFieldUpdateOperationsInput | string
    maxCapacity?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    equippingWMs?: WashingMachineUpdateManyWithoutEquippedProgramsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WMProgramUncheckedUpdateWithoutUsageRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    maxCapacity?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    equippingWMs?: WashingMachineUncheckedUpdateManyWithoutEquippedProgramsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinWashUserCreateWithoutTopUpRecordsInput = {
    name: string
    balance: number
    owningBranches?: BranchCreateNestedManyWithoutBranchOwnerInput
    wMMaintenanceRecords?: WMMaintenanceRecordCreateNestedManyWithoutMaintainerInput
    usageRecords?: UsageRecordCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinWashUserUncheckedCreateWithoutTopUpRecordsInput = {
    id?: number
    name: string
    balance: number
    owningBranches?: BranchUncheckedCreateNestedManyWithoutBranchOwnerInput
    wMMaintenanceRecords?: WMMaintenanceRecordUncheckedCreateNestedManyWithoutMaintainerInput
    usageRecords?: UsageRecordUncheckedCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinWashUserCreateOrConnectWithoutTopUpRecordsInput = {
    where: BinWashUserWhereUniqueInput
    create: XOR<BinWashUserCreateWithoutTopUpRecordsInput, BinWashUserUncheckedCreateWithoutTopUpRecordsInput>
  }

  export type BinWashUserUpsertWithoutTopUpRecordsInput = {
    update: XOR<BinWashUserUpdateWithoutTopUpRecordsInput, BinWashUserUncheckedUpdateWithoutTopUpRecordsInput>
    create: XOR<BinWashUserCreateWithoutTopUpRecordsInput, BinWashUserUncheckedCreateWithoutTopUpRecordsInput>
  }

  export type BinWashUserUpdateWithoutTopUpRecordsInput = {
    name?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    owningBranches?: BranchUpdateManyWithoutBranchOwnerNestedInput
    wMMaintenanceRecords?: WMMaintenanceRecordUpdateManyWithoutMaintainerNestedInput
    usageRecords?: UsageRecordUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinWashUserUncheckedUpdateWithoutTopUpRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    owningBranches?: BranchUncheckedUpdateManyWithoutBranchOwnerNestedInput
    wMMaintenanceRecords?: WMMaintenanceRecordUncheckedUpdateManyWithoutMaintainerNestedInput
    usageRecords?: UsageRecordUncheckedUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserRelationCreateWithoutFollowingUserInput = {
    followedUser: FacebookUserCreateNestedOneWithoutFollowedUserRelationsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserRelationUncheckedCreateWithoutFollowingUserInput = {
    id?: number
    followedUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserRelationCreateOrConnectWithoutFollowingUserInput = {
    where: FacebookUserRelationWhereUniqueInput
    create: XOR<FacebookUserRelationCreateWithoutFollowingUserInput, FacebookUserRelationUncheckedCreateWithoutFollowingUserInput>
  }

  export type FacebookUserRelationCreateManyFollowingUserInputEnvelope = {
    data: Enumerable<FacebookUserRelationCreateManyFollowingUserInput>
    skipDuplicates?: boolean
  }

  export type FacebookUserRelationCreateWithoutFollowedUserInput = {
    followingUser: FacebookUserCreateNestedOneWithoutFollowingUserRelationsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserRelationUncheckedCreateWithoutFollowedUserInput = {
    id?: number
    followingUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserRelationCreateOrConnectWithoutFollowedUserInput = {
    where: FacebookUserRelationWhereUniqueInput
    create: XOR<FacebookUserRelationCreateWithoutFollowedUserInput, FacebookUserRelationUncheckedCreateWithoutFollowedUserInput>
  }

  export type FacebookUserRelationCreateManyFollowedUserInputEnvelope = {
    data: Enumerable<FacebookUserRelationCreateManyFollowedUserInput>
    skipDuplicates?: boolean
  }

  export type PostCreateWithoutPostingUserInput = {
    postText: string
    comments?: CommentCreateNestedManyWithoutParentPostInput
    hashTags?: FacebookHashTagCreateNestedManyWithoutIsInPostsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostUncheckedCreateWithoutPostingUserInput = {
    id?: number
    postText: string
    comments?: CommentUncheckedCreateNestedManyWithoutParentPostInput
    hashTags?: FacebookHashTagUncheckedCreateNestedManyWithoutIsInPostsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostCreateOrConnectWithoutPostingUserInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutPostingUserInput, PostUncheckedCreateWithoutPostingUserInput>
  }

  export type PostCreateManyPostingUserInputEnvelope = {
    data: Enumerable<PostCreateManyPostingUserInput>
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutCommentingUserInput = {
    commentText: string
    parentPost: PostCreateNestedOneWithoutCommentsInput
    parentComment?: CommentCreateNestedOneWithoutChildCommentsInput
    childComments?: CommentCreateNestedManyWithoutParentCommentInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUncheckedCreateWithoutCommentingUserInput = {
    id?: number
    commentText: string
    postId: number
    parentCommentId?: number | null
    childComments?: CommentUncheckedCreateNestedManyWithoutParentCommentInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutCommentingUserInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutCommentingUserInput, CommentUncheckedCreateWithoutCommentingUserInput>
  }

  export type CommentCreateManyCommentingUserInputEnvelope = {
    data: Enumerable<CommentCreateManyCommentingUserInput>
    skipDuplicates?: boolean
  }

  export type MessengerMessageCreateWithoutFromUserInput = {
    messengerText: string
    toUser: FacebookUserCreateNestedOneWithoutMessengerMessagesToInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessengerMessageUncheckedCreateWithoutFromUserInput = {
    id?: number
    messengerText: string
    toUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessengerMessageCreateOrConnectWithoutFromUserInput = {
    where: MessengerMessageWhereUniqueInput
    create: XOR<MessengerMessageCreateWithoutFromUserInput, MessengerMessageUncheckedCreateWithoutFromUserInput>
  }

  export type MessengerMessageCreateManyFromUserInputEnvelope = {
    data: Enumerable<MessengerMessageCreateManyFromUserInput>
    skipDuplicates?: boolean
  }

  export type MessengerMessageCreateWithoutToUserInput = {
    messengerText: string
    fromUser: FacebookUserCreateNestedOneWithoutMessengerMessagesFromInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessengerMessageUncheckedCreateWithoutToUserInput = {
    id?: number
    messengerText: string
    fromUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessengerMessageCreateOrConnectWithoutToUserInput = {
    where: MessengerMessageWhereUniqueInput
    create: XOR<MessengerMessageCreateWithoutToUserInput, MessengerMessageUncheckedCreateWithoutToUserInput>
  }

  export type MessengerMessageCreateManyToUserInputEnvelope = {
    data: Enumerable<MessengerMessageCreateManyToUserInput>
    skipDuplicates?: boolean
  }

  export type FacebookUserRelationUpsertWithWhereUniqueWithoutFollowingUserInput = {
    where: FacebookUserRelationWhereUniqueInput
    update: XOR<FacebookUserRelationUpdateWithoutFollowingUserInput, FacebookUserRelationUncheckedUpdateWithoutFollowingUserInput>
    create: XOR<FacebookUserRelationCreateWithoutFollowingUserInput, FacebookUserRelationUncheckedCreateWithoutFollowingUserInput>
  }

  export type FacebookUserRelationUpdateWithWhereUniqueWithoutFollowingUserInput = {
    where: FacebookUserRelationWhereUniqueInput
    data: XOR<FacebookUserRelationUpdateWithoutFollowingUserInput, FacebookUserRelationUncheckedUpdateWithoutFollowingUserInput>
  }

  export type FacebookUserRelationUpdateManyWithWhereWithoutFollowingUserInput = {
    where: FacebookUserRelationScalarWhereInput
    data: XOR<FacebookUserRelationUpdateManyMutationInput, FacebookUserRelationUncheckedUpdateManyWithoutFollowingUserRelationsInput>
  }

  export type FacebookUserRelationScalarWhereInput = {
    AND?: Enumerable<FacebookUserRelationScalarWhereInput>
    OR?: Enumerable<FacebookUserRelationScalarWhereInput>
    NOT?: Enumerable<FacebookUserRelationScalarWhereInput>
    id?: IntFilter | number
    followingUserId?: IntFilter | number
    followedUserId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type FacebookUserRelationUpsertWithWhereUniqueWithoutFollowedUserInput = {
    where: FacebookUserRelationWhereUniqueInput
    update: XOR<FacebookUserRelationUpdateWithoutFollowedUserInput, FacebookUserRelationUncheckedUpdateWithoutFollowedUserInput>
    create: XOR<FacebookUserRelationCreateWithoutFollowedUserInput, FacebookUserRelationUncheckedCreateWithoutFollowedUserInput>
  }

  export type FacebookUserRelationUpdateWithWhereUniqueWithoutFollowedUserInput = {
    where: FacebookUserRelationWhereUniqueInput
    data: XOR<FacebookUserRelationUpdateWithoutFollowedUserInput, FacebookUserRelationUncheckedUpdateWithoutFollowedUserInput>
  }

  export type FacebookUserRelationUpdateManyWithWhereWithoutFollowedUserInput = {
    where: FacebookUserRelationScalarWhereInput
    data: XOR<FacebookUserRelationUpdateManyMutationInput, FacebookUserRelationUncheckedUpdateManyWithoutFollowedUserRelationsInput>
  }

  export type PostUpsertWithWhereUniqueWithoutPostingUserInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutPostingUserInput, PostUncheckedUpdateWithoutPostingUserInput>
    create: XOR<PostCreateWithoutPostingUserInput, PostUncheckedCreateWithoutPostingUserInput>
  }

  export type PostUpdateWithWhereUniqueWithoutPostingUserInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutPostingUserInput, PostUncheckedUpdateWithoutPostingUserInput>
  }

  export type PostUpdateManyWithWhereWithoutPostingUserInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutPostsInput>
  }

  export type PostScalarWhereInput = {
    AND?: Enumerable<PostScalarWhereInput>
    OR?: Enumerable<PostScalarWhereInput>
    NOT?: Enumerable<PostScalarWhereInput>
    id?: IntFilter | number
    postText?: StringFilter | string
    userId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutCommentingUserInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutCommentingUserInput, CommentUncheckedUpdateWithoutCommentingUserInput>
    create: XOR<CommentCreateWithoutCommentingUserInput, CommentUncheckedCreateWithoutCommentingUserInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutCommentingUserInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutCommentingUserInput, CommentUncheckedUpdateWithoutCommentingUserInput>
  }

  export type CommentUpdateManyWithWhereWithoutCommentingUserInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutCommentsInput>
  }

  export type CommentScalarWhereInput = {
    AND?: Enumerable<CommentScalarWhereInput>
    OR?: Enumerable<CommentScalarWhereInput>
    NOT?: Enumerable<CommentScalarWhereInput>
    id?: IntFilter | number
    commentText?: StringFilter | string
    userId?: IntFilter | number
    postId?: IntFilter | number
    parentCommentId?: IntNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type MessengerMessageUpsertWithWhereUniqueWithoutFromUserInput = {
    where: MessengerMessageWhereUniqueInput
    update: XOR<MessengerMessageUpdateWithoutFromUserInput, MessengerMessageUncheckedUpdateWithoutFromUserInput>
    create: XOR<MessengerMessageCreateWithoutFromUserInput, MessengerMessageUncheckedCreateWithoutFromUserInput>
  }

  export type MessengerMessageUpdateWithWhereUniqueWithoutFromUserInput = {
    where: MessengerMessageWhereUniqueInput
    data: XOR<MessengerMessageUpdateWithoutFromUserInput, MessengerMessageUncheckedUpdateWithoutFromUserInput>
  }

  export type MessengerMessageUpdateManyWithWhereWithoutFromUserInput = {
    where: MessengerMessageScalarWhereInput
    data: XOR<MessengerMessageUpdateManyMutationInput, MessengerMessageUncheckedUpdateManyWithoutMessengerMessagesFromInput>
  }

  export type MessengerMessageScalarWhereInput = {
    AND?: Enumerable<MessengerMessageScalarWhereInput>
    OR?: Enumerable<MessengerMessageScalarWhereInput>
    NOT?: Enumerable<MessengerMessageScalarWhereInput>
    id?: IntFilter | number
    messengerText?: StringFilter | string
    fromUserId?: IntFilter | number
    toUserId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type MessengerMessageUpsertWithWhereUniqueWithoutToUserInput = {
    where: MessengerMessageWhereUniqueInput
    update: XOR<MessengerMessageUpdateWithoutToUserInput, MessengerMessageUncheckedUpdateWithoutToUserInput>
    create: XOR<MessengerMessageCreateWithoutToUserInput, MessengerMessageUncheckedCreateWithoutToUserInput>
  }

  export type MessengerMessageUpdateWithWhereUniqueWithoutToUserInput = {
    where: MessengerMessageWhereUniqueInput
    data: XOR<MessengerMessageUpdateWithoutToUserInput, MessengerMessageUncheckedUpdateWithoutToUserInput>
  }

  export type MessengerMessageUpdateManyWithWhereWithoutToUserInput = {
    where: MessengerMessageScalarWhereInput
    data: XOR<MessengerMessageUpdateManyMutationInput, MessengerMessageUncheckedUpdateManyWithoutMessengerMessagesToInput>
  }

  export type FacebookUserCreateWithoutFollowingUserRelationsInput = {
    name: string
    imageUrl: string
    bio: string
    followedUserRelations?: FacebookUserRelationCreateNestedManyWithoutFollowedUserInput
    posts?: PostCreateNestedManyWithoutPostingUserInput
    comments?: CommentCreateNestedManyWithoutCommentingUserInput
    messengerMessagesFrom?: MessengerMessageCreateNestedManyWithoutFromUserInput
    messengerMessagesTo?: MessengerMessageCreateNestedManyWithoutToUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserUncheckedCreateWithoutFollowingUserRelationsInput = {
    id?: number
    name: string
    imageUrl: string
    bio: string
    followedUserRelations?: FacebookUserRelationUncheckedCreateNestedManyWithoutFollowedUserInput
    posts?: PostUncheckedCreateNestedManyWithoutPostingUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutCommentingUserInput
    messengerMessagesFrom?: MessengerMessageUncheckedCreateNestedManyWithoutFromUserInput
    messengerMessagesTo?: MessengerMessageUncheckedCreateNestedManyWithoutToUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserCreateOrConnectWithoutFollowingUserRelationsInput = {
    where: FacebookUserWhereUniqueInput
    create: XOR<FacebookUserCreateWithoutFollowingUserRelationsInput, FacebookUserUncheckedCreateWithoutFollowingUserRelationsInput>
  }

  export type FacebookUserCreateWithoutFollowedUserRelationsInput = {
    name: string
    imageUrl: string
    bio: string
    followingUserRelations?: FacebookUserRelationCreateNestedManyWithoutFollowingUserInput
    posts?: PostCreateNestedManyWithoutPostingUserInput
    comments?: CommentCreateNestedManyWithoutCommentingUserInput
    messengerMessagesFrom?: MessengerMessageCreateNestedManyWithoutFromUserInput
    messengerMessagesTo?: MessengerMessageCreateNestedManyWithoutToUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserUncheckedCreateWithoutFollowedUserRelationsInput = {
    id?: number
    name: string
    imageUrl: string
    bio: string
    followingUserRelations?: FacebookUserRelationUncheckedCreateNestedManyWithoutFollowingUserInput
    posts?: PostUncheckedCreateNestedManyWithoutPostingUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutCommentingUserInput
    messengerMessagesFrom?: MessengerMessageUncheckedCreateNestedManyWithoutFromUserInput
    messengerMessagesTo?: MessengerMessageUncheckedCreateNestedManyWithoutToUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserCreateOrConnectWithoutFollowedUserRelationsInput = {
    where: FacebookUserWhereUniqueInput
    create: XOR<FacebookUserCreateWithoutFollowedUserRelationsInput, FacebookUserUncheckedCreateWithoutFollowedUserRelationsInput>
  }

  export type FacebookUserUpsertWithoutFollowingUserRelationsInput = {
    update: XOR<FacebookUserUpdateWithoutFollowingUserRelationsInput, FacebookUserUncheckedUpdateWithoutFollowingUserRelationsInput>
    create: XOR<FacebookUserCreateWithoutFollowingUserRelationsInput, FacebookUserUncheckedCreateWithoutFollowingUserRelationsInput>
  }

  export type FacebookUserUpdateWithoutFollowingUserRelationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followedUserRelations?: FacebookUserRelationUpdateManyWithoutFollowedUserNestedInput
    posts?: PostUpdateManyWithoutPostingUserNestedInput
    comments?: CommentUpdateManyWithoutCommentingUserNestedInput
    messengerMessagesFrom?: MessengerMessageUpdateManyWithoutFromUserNestedInput
    messengerMessagesTo?: MessengerMessageUpdateManyWithoutToUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserUncheckedUpdateWithoutFollowingUserRelationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followedUserRelations?: FacebookUserRelationUncheckedUpdateManyWithoutFollowedUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutPostingUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCommentingUserNestedInput
    messengerMessagesFrom?: MessengerMessageUncheckedUpdateManyWithoutFromUserNestedInput
    messengerMessagesTo?: MessengerMessageUncheckedUpdateManyWithoutToUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserUpsertWithoutFollowedUserRelationsInput = {
    update: XOR<FacebookUserUpdateWithoutFollowedUserRelationsInput, FacebookUserUncheckedUpdateWithoutFollowedUserRelationsInput>
    create: XOR<FacebookUserCreateWithoutFollowedUserRelationsInput, FacebookUserUncheckedCreateWithoutFollowedUserRelationsInput>
  }

  export type FacebookUserUpdateWithoutFollowedUserRelationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followingUserRelations?: FacebookUserRelationUpdateManyWithoutFollowingUserNestedInput
    posts?: PostUpdateManyWithoutPostingUserNestedInput
    comments?: CommentUpdateManyWithoutCommentingUserNestedInput
    messengerMessagesFrom?: MessengerMessageUpdateManyWithoutFromUserNestedInput
    messengerMessagesTo?: MessengerMessageUpdateManyWithoutToUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserUncheckedUpdateWithoutFollowedUserRelationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followingUserRelations?: FacebookUserRelationUncheckedUpdateManyWithoutFollowingUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutPostingUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCommentingUserNestedInput
    messengerMessagesFrom?: MessengerMessageUncheckedUpdateManyWithoutFromUserNestedInput
    messengerMessagesTo?: MessengerMessageUncheckedUpdateManyWithoutToUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserCreateWithoutPostsInput = {
    name: string
    imageUrl: string
    bio: string
    followingUserRelations?: FacebookUserRelationCreateNestedManyWithoutFollowingUserInput
    followedUserRelations?: FacebookUserRelationCreateNestedManyWithoutFollowedUserInput
    comments?: CommentCreateNestedManyWithoutCommentingUserInput
    messengerMessagesFrom?: MessengerMessageCreateNestedManyWithoutFromUserInput
    messengerMessagesTo?: MessengerMessageCreateNestedManyWithoutToUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserUncheckedCreateWithoutPostsInput = {
    id?: number
    name: string
    imageUrl: string
    bio: string
    followingUserRelations?: FacebookUserRelationUncheckedCreateNestedManyWithoutFollowingUserInput
    followedUserRelations?: FacebookUserRelationUncheckedCreateNestedManyWithoutFollowedUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutCommentingUserInput
    messengerMessagesFrom?: MessengerMessageUncheckedCreateNestedManyWithoutFromUserInput
    messengerMessagesTo?: MessengerMessageUncheckedCreateNestedManyWithoutToUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserCreateOrConnectWithoutPostsInput = {
    where: FacebookUserWhereUniqueInput
    create: XOR<FacebookUserCreateWithoutPostsInput, FacebookUserUncheckedCreateWithoutPostsInput>
  }

  export type CommentCreateWithoutParentPostInput = {
    commentText: string
    commentingUser: FacebookUserCreateNestedOneWithoutCommentsInput
    parentComment?: CommentCreateNestedOneWithoutChildCommentsInput
    childComments?: CommentCreateNestedManyWithoutParentCommentInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUncheckedCreateWithoutParentPostInput = {
    id?: number
    commentText: string
    userId: number
    parentCommentId?: number | null
    childComments?: CommentUncheckedCreateNestedManyWithoutParentCommentInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutParentPostInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutParentPostInput, CommentUncheckedCreateWithoutParentPostInput>
  }

  export type CommentCreateManyParentPostInputEnvelope = {
    data: Enumerable<CommentCreateManyParentPostInput>
    skipDuplicates?: boolean
  }

  export type FacebookHashTagCreateWithoutIsInPostsInput = {
    hashTagText: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookHashTagUncheckedCreateWithoutIsInPostsInput = {
    id?: number
    hashTagText: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookHashTagCreateOrConnectWithoutIsInPostsInput = {
    where: FacebookHashTagWhereUniqueInput
    create: XOR<FacebookHashTagCreateWithoutIsInPostsInput, FacebookHashTagUncheckedCreateWithoutIsInPostsInput>
  }

  export type FacebookUserUpsertWithoutPostsInput = {
    update: XOR<FacebookUserUpdateWithoutPostsInput, FacebookUserUncheckedUpdateWithoutPostsInput>
    create: XOR<FacebookUserCreateWithoutPostsInput, FacebookUserUncheckedCreateWithoutPostsInput>
  }

  export type FacebookUserUpdateWithoutPostsInput = {
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followingUserRelations?: FacebookUserRelationUpdateManyWithoutFollowingUserNestedInput
    followedUserRelations?: FacebookUserRelationUpdateManyWithoutFollowedUserNestedInput
    comments?: CommentUpdateManyWithoutCommentingUserNestedInput
    messengerMessagesFrom?: MessengerMessageUpdateManyWithoutFromUserNestedInput
    messengerMessagesTo?: MessengerMessageUpdateManyWithoutToUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserUncheckedUpdateWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followingUserRelations?: FacebookUserRelationUncheckedUpdateManyWithoutFollowingUserNestedInput
    followedUserRelations?: FacebookUserRelationUncheckedUpdateManyWithoutFollowedUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCommentingUserNestedInput
    messengerMessagesFrom?: MessengerMessageUncheckedUpdateManyWithoutFromUserNestedInput
    messengerMessagesTo?: MessengerMessageUncheckedUpdateManyWithoutToUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutParentPostInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutParentPostInput, CommentUncheckedUpdateWithoutParentPostInput>
    create: XOR<CommentCreateWithoutParentPostInput, CommentUncheckedCreateWithoutParentPostInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutParentPostInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutParentPostInput, CommentUncheckedUpdateWithoutParentPostInput>
  }

  export type CommentUpdateManyWithWhereWithoutParentPostInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutCommentsInput>
  }

  export type FacebookHashTagUpsertWithWhereUniqueWithoutIsInPostsInput = {
    where: FacebookHashTagWhereUniqueInput
    update: XOR<FacebookHashTagUpdateWithoutIsInPostsInput, FacebookHashTagUncheckedUpdateWithoutIsInPostsInput>
    create: XOR<FacebookHashTagCreateWithoutIsInPostsInput, FacebookHashTagUncheckedCreateWithoutIsInPostsInput>
  }

  export type FacebookHashTagUpdateWithWhereUniqueWithoutIsInPostsInput = {
    where: FacebookHashTagWhereUniqueInput
    data: XOR<FacebookHashTagUpdateWithoutIsInPostsInput, FacebookHashTagUncheckedUpdateWithoutIsInPostsInput>
  }

  export type FacebookHashTagUpdateManyWithWhereWithoutIsInPostsInput = {
    where: FacebookHashTagScalarWhereInput
    data: XOR<FacebookHashTagUpdateManyMutationInput, FacebookHashTagUncheckedUpdateManyWithoutHashTagsInput>
  }

  export type FacebookHashTagScalarWhereInput = {
    AND?: Enumerable<FacebookHashTagScalarWhereInput>
    OR?: Enumerable<FacebookHashTagScalarWhereInput>
    NOT?: Enumerable<FacebookHashTagScalarWhereInput>
    id?: IntFilter | number
    hashTagText?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type FacebookUserCreateWithoutCommentsInput = {
    name: string
    imageUrl: string
    bio: string
    followingUserRelations?: FacebookUserRelationCreateNestedManyWithoutFollowingUserInput
    followedUserRelations?: FacebookUserRelationCreateNestedManyWithoutFollowedUserInput
    posts?: PostCreateNestedManyWithoutPostingUserInput
    messengerMessagesFrom?: MessengerMessageCreateNestedManyWithoutFromUserInput
    messengerMessagesTo?: MessengerMessageCreateNestedManyWithoutToUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserUncheckedCreateWithoutCommentsInput = {
    id?: number
    name: string
    imageUrl: string
    bio: string
    followingUserRelations?: FacebookUserRelationUncheckedCreateNestedManyWithoutFollowingUserInput
    followedUserRelations?: FacebookUserRelationUncheckedCreateNestedManyWithoutFollowedUserInput
    posts?: PostUncheckedCreateNestedManyWithoutPostingUserInput
    messengerMessagesFrom?: MessengerMessageUncheckedCreateNestedManyWithoutFromUserInput
    messengerMessagesTo?: MessengerMessageUncheckedCreateNestedManyWithoutToUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserCreateOrConnectWithoutCommentsInput = {
    where: FacebookUserWhereUniqueInput
    create: XOR<FacebookUserCreateWithoutCommentsInput, FacebookUserUncheckedCreateWithoutCommentsInput>
  }

  export type PostCreateWithoutCommentsInput = {
    postText: string
    postingUser: FacebookUserCreateNestedOneWithoutPostsInput
    hashTags?: FacebookHashTagCreateNestedManyWithoutIsInPostsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostUncheckedCreateWithoutCommentsInput = {
    id?: number
    postText: string
    userId: number
    hashTags?: FacebookHashTagUncheckedCreateNestedManyWithoutIsInPostsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostCreateOrConnectWithoutCommentsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
  }

  export type CommentCreateWithoutChildCommentsInput = {
    commentText: string
    commentingUser: FacebookUserCreateNestedOneWithoutCommentsInput
    parentPost: PostCreateNestedOneWithoutCommentsInput
    parentComment?: CommentCreateNestedOneWithoutChildCommentsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUncheckedCreateWithoutChildCommentsInput = {
    id?: number
    commentText: string
    userId: number
    postId: number
    parentCommentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutChildCommentsInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutChildCommentsInput, CommentUncheckedCreateWithoutChildCommentsInput>
  }

  export type CommentCreateWithoutParentCommentInput = {
    commentText: string
    commentingUser: FacebookUserCreateNestedOneWithoutCommentsInput
    parentPost: PostCreateNestedOneWithoutCommentsInput
    childComments?: CommentCreateNestedManyWithoutParentCommentInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUncheckedCreateWithoutParentCommentInput = {
    id?: number
    commentText: string
    userId: number
    postId: number
    childComments?: CommentUncheckedCreateNestedManyWithoutParentCommentInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutParentCommentInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutParentCommentInput, CommentUncheckedCreateWithoutParentCommentInput>
  }

  export type CommentCreateManyParentCommentInputEnvelope = {
    data: Enumerable<CommentCreateManyParentCommentInput>
    skipDuplicates?: boolean
  }

  export type FacebookUserUpsertWithoutCommentsInput = {
    update: XOR<FacebookUserUpdateWithoutCommentsInput, FacebookUserUncheckedUpdateWithoutCommentsInput>
    create: XOR<FacebookUserCreateWithoutCommentsInput, FacebookUserUncheckedCreateWithoutCommentsInput>
  }

  export type FacebookUserUpdateWithoutCommentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followingUserRelations?: FacebookUserRelationUpdateManyWithoutFollowingUserNestedInput
    followedUserRelations?: FacebookUserRelationUpdateManyWithoutFollowedUserNestedInput
    posts?: PostUpdateManyWithoutPostingUserNestedInput
    messengerMessagesFrom?: MessengerMessageUpdateManyWithoutFromUserNestedInput
    messengerMessagesTo?: MessengerMessageUpdateManyWithoutToUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followingUserRelations?: FacebookUserRelationUncheckedUpdateManyWithoutFollowingUserNestedInput
    followedUserRelations?: FacebookUserRelationUncheckedUpdateManyWithoutFollowedUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutPostingUserNestedInput
    messengerMessagesFrom?: MessengerMessageUncheckedUpdateManyWithoutFromUserNestedInput
    messengerMessagesTo?: MessengerMessageUncheckedUpdateManyWithoutToUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUpsertWithoutCommentsInput = {
    update: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
  }

  export type PostUpdateWithoutCommentsInput = {
    postText?: StringFieldUpdateOperationsInput | string
    postingUser?: FacebookUserUpdateOneRequiredWithoutPostsNestedInput
    hashTags?: FacebookHashTagUpdateManyWithoutIsInPostsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    postText?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    hashTags?: FacebookHashTagUncheckedUpdateManyWithoutIsInPostsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpsertWithoutChildCommentsInput = {
    update: XOR<CommentUpdateWithoutChildCommentsInput, CommentUncheckedUpdateWithoutChildCommentsInput>
    create: XOR<CommentCreateWithoutChildCommentsInput, CommentUncheckedCreateWithoutChildCommentsInput>
  }

  export type CommentUpdateWithoutChildCommentsInput = {
    commentText?: StringFieldUpdateOperationsInput | string
    commentingUser?: FacebookUserUpdateOneRequiredWithoutCommentsNestedInput
    parentPost?: PostUpdateOneRequiredWithoutCommentsNestedInput
    parentComment?: CommentUpdateOneWithoutChildCommentsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateWithoutChildCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentText?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    parentCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutParentCommentInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutParentCommentInput, CommentUncheckedUpdateWithoutParentCommentInput>
    create: XOR<CommentCreateWithoutParentCommentInput, CommentUncheckedCreateWithoutParentCommentInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutParentCommentInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutParentCommentInput, CommentUncheckedUpdateWithoutParentCommentInput>
  }

  export type CommentUpdateManyWithWhereWithoutParentCommentInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutChildCommentsInput>
  }

  export type PostCreateWithoutHashTagsInput = {
    postText: string
    postingUser: FacebookUserCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutParentPostInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostUncheckedCreateWithoutHashTagsInput = {
    id?: number
    postText: string
    userId: number
    comments?: CommentUncheckedCreateNestedManyWithoutParentPostInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostCreateOrConnectWithoutHashTagsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutHashTagsInput, PostUncheckedCreateWithoutHashTagsInput>
  }

  export type PostUpsertWithWhereUniqueWithoutHashTagsInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutHashTagsInput, PostUncheckedUpdateWithoutHashTagsInput>
    create: XOR<PostCreateWithoutHashTagsInput, PostUncheckedCreateWithoutHashTagsInput>
  }

  export type PostUpdateWithWhereUniqueWithoutHashTagsInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutHashTagsInput, PostUncheckedUpdateWithoutHashTagsInput>
  }

  export type PostUpdateManyWithWhereWithoutHashTagsInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutIsInPostsInput>
  }

  export type FacebookUserCreateWithoutMessengerMessagesFromInput = {
    name: string
    imageUrl: string
    bio: string
    followingUserRelations?: FacebookUserRelationCreateNestedManyWithoutFollowingUserInput
    followedUserRelations?: FacebookUserRelationCreateNestedManyWithoutFollowedUserInput
    posts?: PostCreateNestedManyWithoutPostingUserInput
    comments?: CommentCreateNestedManyWithoutCommentingUserInput
    messengerMessagesTo?: MessengerMessageCreateNestedManyWithoutToUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserUncheckedCreateWithoutMessengerMessagesFromInput = {
    id?: number
    name: string
    imageUrl: string
    bio: string
    followingUserRelations?: FacebookUserRelationUncheckedCreateNestedManyWithoutFollowingUserInput
    followedUserRelations?: FacebookUserRelationUncheckedCreateNestedManyWithoutFollowedUserInput
    posts?: PostUncheckedCreateNestedManyWithoutPostingUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutCommentingUserInput
    messengerMessagesTo?: MessengerMessageUncheckedCreateNestedManyWithoutToUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserCreateOrConnectWithoutMessengerMessagesFromInput = {
    where: FacebookUserWhereUniqueInput
    create: XOR<FacebookUserCreateWithoutMessengerMessagesFromInput, FacebookUserUncheckedCreateWithoutMessengerMessagesFromInput>
  }

  export type FacebookUserCreateWithoutMessengerMessagesToInput = {
    name: string
    imageUrl: string
    bio: string
    followingUserRelations?: FacebookUserRelationCreateNestedManyWithoutFollowingUserInput
    followedUserRelations?: FacebookUserRelationCreateNestedManyWithoutFollowedUserInput
    posts?: PostCreateNestedManyWithoutPostingUserInput
    comments?: CommentCreateNestedManyWithoutCommentingUserInput
    messengerMessagesFrom?: MessengerMessageCreateNestedManyWithoutFromUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserUncheckedCreateWithoutMessengerMessagesToInput = {
    id?: number
    name: string
    imageUrl: string
    bio: string
    followingUserRelations?: FacebookUserRelationUncheckedCreateNestedManyWithoutFollowingUserInput
    followedUserRelations?: FacebookUserRelationUncheckedCreateNestedManyWithoutFollowedUserInput
    posts?: PostUncheckedCreateNestedManyWithoutPostingUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutCommentingUserInput
    messengerMessagesFrom?: MessengerMessageUncheckedCreateNestedManyWithoutFromUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserCreateOrConnectWithoutMessengerMessagesToInput = {
    where: FacebookUserWhereUniqueInput
    create: XOR<FacebookUserCreateWithoutMessengerMessagesToInput, FacebookUserUncheckedCreateWithoutMessengerMessagesToInput>
  }

  export type FacebookUserUpsertWithoutMessengerMessagesFromInput = {
    update: XOR<FacebookUserUpdateWithoutMessengerMessagesFromInput, FacebookUserUncheckedUpdateWithoutMessengerMessagesFromInput>
    create: XOR<FacebookUserCreateWithoutMessengerMessagesFromInput, FacebookUserUncheckedCreateWithoutMessengerMessagesFromInput>
  }

  export type FacebookUserUpdateWithoutMessengerMessagesFromInput = {
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followingUserRelations?: FacebookUserRelationUpdateManyWithoutFollowingUserNestedInput
    followedUserRelations?: FacebookUserRelationUpdateManyWithoutFollowedUserNestedInput
    posts?: PostUpdateManyWithoutPostingUserNestedInput
    comments?: CommentUpdateManyWithoutCommentingUserNestedInput
    messengerMessagesTo?: MessengerMessageUpdateManyWithoutToUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserUncheckedUpdateWithoutMessengerMessagesFromInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followingUserRelations?: FacebookUserRelationUncheckedUpdateManyWithoutFollowingUserNestedInput
    followedUserRelations?: FacebookUserRelationUncheckedUpdateManyWithoutFollowedUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutPostingUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCommentingUserNestedInput
    messengerMessagesTo?: MessengerMessageUncheckedUpdateManyWithoutToUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserUpsertWithoutMessengerMessagesToInput = {
    update: XOR<FacebookUserUpdateWithoutMessengerMessagesToInput, FacebookUserUncheckedUpdateWithoutMessengerMessagesToInput>
    create: XOR<FacebookUserCreateWithoutMessengerMessagesToInput, FacebookUserUncheckedCreateWithoutMessengerMessagesToInput>
  }

  export type FacebookUserUpdateWithoutMessengerMessagesToInput = {
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followingUserRelations?: FacebookUserRelationUpdateManyWithoutFollowingUserNestedInput
    followedUserRelations?: FacebookUserRelationUpdateManyWithoutFollowedUserNestedInput
    posts?: PostUpdateManyWithoutPostingUserNestedInput
    comments?: CommentUpdateManyWithoutCommentingUserNestedInput
    messengerMessagesFrom?: MessengerMessageUpdateManyWithoutFromUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserUncheckedUpdateWithoutMessengerMessagesToInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followingUserRelations?: FacebookUserRelationUncheckedUpdateManyWithoutFollowingUserNestedInput
    followedUserRelations?: FacebookUserRelationUncheckedUpdateManyWithoutFollowedUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutPostingUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCommentingUserNestedInput
    messengerMessagesFrom?: MessengerMessageUncheckedUpdateManyWithoutFromUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookTitleCreateWithoutAuthorsInput = {
    title: string
    isbn: string
    categories?: BookCategoryCreateNestedManyWithoutBookTitlesInput
    books?: BookCreateNestedManyWithoutTitleInput
    requestRecords?: RequestRecordCreateNestedManyWithoutRequestedBookTitleInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookTitleUncheckedCreateWithoutAuthorsInput = {
    id?: number
    title: string
    isbn: string
    categories?: BookCategoryUncheckedCreateNestedManyWithoutBookTitlesInput
    books?: BookUncheckedCreateNestedManyWithoutTitleInput
    requestRecords?: RequestRecordUncheckedCreateNestedManyWithoutRequestedBookTitleInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookTitleCreateOrConnectWithoutAuthorsInput = {
    where: BookTitleWhereUniqueInput
    create: XOR<BookTitleCreateWithoutAuthorsInput, BookTitleUncheckedCreateWithoutAuthorsInput>
  }

  export type BookTitleUpsertWithWhereUniqueWithoutAuthorsInput = {
    where: BookTitleWhereUniqueInput
    update: XOR<BookTitleUpdateWithoutAuthorsInput, BookTitleUncheckedUpdateWithoutAuthorsInput>
    create: XOR<BookTitleCreateWithoutAuthorsInput, BookTitleUncheckedCreateWithoutAuthorsInput>
  }

  export type BookTitleUpdateWithWhereUniqueWithoutAuthorsInput = {
    where: BookTitleWhereUniqueInput
    data: XOR<BookTitleUpdateWithoutAuthorsInput, BookTitleUncheckedUpdateWithoutAuthorsInput>
  }

  export type BookTitleUpdateManyWithWhereWithoutAuthorsInput = {
    where: BookTitleScalarWhereInput
    data: XOR<BookTitleUpdateManyMutationInput, BookTitleUncheckedUpdateManyWithoutBookTitlesInput>
  }

  export type BookTitleScalarWhereInput = {
    AND?: Enumerable<BookTitleScalarWhereInput>
    OR?: Enumerable<BookTitleScalarWhereInput>
    NOT?: Enumerable<BookTitleScalarWhereInput>
    id?: IntFilter | number
    title?: StringFilter | string
    isbn?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type AuthorCreateWithoutBookTitlesInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuthorUncheckedCreateWithoutBookTitlesInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuthorCreateOrConnectWithoutBookTitlesInput = {
    where: AuthorWhereUniqueInput
    create: XOR<AuthorCreateWithoutBookTitlesInput, AuthorUncheckedCreateWithoutBookTitlesInput>
  }

  export type BookCategoryCreateWithoutBookTitlesInput = {
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookCategoryUncheckedCreateWithoutBookTitlesInput = {
    id?: number
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookCategoryCreateOrConnectWithoutBookTitlesInput = {
    where: BookCategoryWhereUniqueInput
    create: XOR<BookCategoryCreateWithoutBookTitlesInput, BookCategoryUncheckedCreateWithoutBookTitlesInput>
  }

  export type BookCreateWithoutTitleInput = {
    belongsToLibrary: LibraryCreateNestedOneWithoutBooksInput
    isAvailable: boolean
    borrowingRecords?: BorrowingRecordCreateNestedManyWithoutBorrowedBookInput
    requestRecords?: RequestRecordCreateNestedManyWithoutAcquiredBookInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookUncheckedCreateWithoutTitleInput = {
    id?: number
    libraryId: number
    isAvailable: boolean
    borrowingRecords?: BorrowingRecordUncheckedCreateNestedManyWithoutBorrowedBookInput
    requestRecords?: RequestRecordUncheckedCreateNestedManyWithoutAcquiredBookInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookCreateOrConnectWithoutTitleInput = {
    where: BookWhereUniqueInput
    create: XOR<BookCreateWithoutTitleInput, BookUncheckedCreateWithoutTitleInput>
  }

  export type BookCreateManyTitleInputEnvelope = {
    data: Enumerable<BookCreateManyTitleInput>
    skipDuplicates?: boolean
  }

  export type RequestRecordCreateWithoutRequestedBookTitleInput = {
    requestingStudent: StudentCreateNestedOneWithoutRequestRecordsInput
    requestingLibrary: LibraryCreateNestedOneWithoutRequestingRecordsInput
    requestedLibrary: LibraryCreateNestedOneWithoutRequestedRecordsInput
    requestDate: Date | string
    acquiredDate?: Date | string | null
    returnDate?: Date | string | null
    acquiredBook?: BookCreateNestedOneWithoutRequestRecordsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestRecordUncheckedCreateWithoutRequestedBookTitleInput = {
    id?: number
    studentId: number
    requestingLibraryId: number
    requestedLibraryId: number
    requestDate: Date | string
    acquiredDate?: Date | string | null
    returnDate?: Date | string | null
    bookId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestRecordCreateOrConnectWithoutRequestedBookTitleInput = {
    where: RequestRecordWhereUniqueInput
    create: XOR<RequestRecordCreateWithoutRequestedBookTitleInput, RequestRecordUncheckedCreateWithoutRequestedBookTitleInput>
  }

  export type RequestRecordCreateManyRequestedBookTitleInputEnvelope = {
    data: Enumerable<RequestRecordCreateManyRequestedBookTitleInput>
    skipDuplicates?: boolean
  }

  export type AuthorUpsertWithWhereUniqueWithoutBookTitlesInput = {
    where: AuthorWhereUniqueInput
    update: XOR<AuthorUpdateWithoutBookTitlesInput, AuthorUncheckedUpdateWithoutBookTitlesInput>
    create: XOR<AuthorCreateWithoutBookTitlesInput, AuthorUncheckedCreateWithoutBookTitlesInput>
  }

  export type AuthorUpdateWithWhereUniqueWithoutBookTitlesInput = {
    where: AuthorWhereUniqueInput
    data: XOR<AuthorUpdateWithoutBookTitlesInput, AuthorUncheckedUpdateWithoutBookTitlesInput>
  }

  export type AuthorUpdateManyWithWhereWithoutBookTitlesInput = {
    where: AuthorScalarWhereInput
    data: XOR<AuthorUpdateManyMutationInput, AuthorUncheckedUpdateManyWithoutAuthorsInput>
  }

  export type AuthorScalarWhereInput = {
    AND?: Enumerable<AuthorScalarWhereInput>
    OR?: Enumerable<AuthorScalarWhereInput>
    NOT?: Enumerable<AuthorScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type BookCategoryUpsertWithWhereUniqueWithoutBookTitlesInput = {
    where: BookCategoryWhereUniqueInput
    update: XOR<BookCategoryUpdateWithoutBookTitlesInput, BookCategoryUncheckedUpdateWithoutBookTitlesInput>
    create: XOR<BookCategoryCreateWithoutBookTitlesInput, BookCategoryUncheckedCreateWithoutBookTitlesInput>
  }

  export type BookCategoryUpdateWithWhereUniqueWithoutBookTitlesInput = {
    where: BookCategoryWhereUniqueInput
    data: XOR<BookCategoryUpdateWithoutBookTitlesInput, BookCategoryUncheckedUpdateWithoutBookTitlesInput>
  }

  export type BookCategoryUpdateManyWithWhereWithoutBookTitlesInput = {
    where: BookCategoryScalarWhereInput
    data: XOR<BookCategoryUpdateManyMutationInput, BookCategoryUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type BookCategoryScalarWhereInput = {
    AND?: Enumerable<BookCategoryScalarWhereInput>
    OR?: Enumerable<BookCategoryScalarWhereInput>
    NOT?: Enumerable<BookCategoryScalarWhereInput>
    id?: IntFilter | number
    category?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type BookUpsertWithWhereUniqueWithoutTitleInput = {
    where: BookWhereUniqueInput
    update: XOR<BookUpdateWithoutTitleInput, BookUncheckedUpdateWithoutTitleInput>
    create: XOR<BookCreateWithoutTitleInput, BookUncheckedCreateWithoutTitleInput>
  }

  export type BookUpdateWithWhereUniqueWithoutTitleInput = {
    where: BookWhereUniqueInput
    data: XOR<BookUpdateWithoutTitleInput, BookUncheckedUpdateWithoutTitleInput>
  }

  export type BookUpdateManyWithWhereWithoutTitleInput = {
    where: BookScalarWhereInput
    data: XOR<BookUpdateManyMutationInput, BookUncheckedUpdateManyWithoutBooksInput>
  }

  export type BookScalarWhereInput = {
    AND?: Enumerable<BookScalarWhereInput>
    OR?: Enumerable<BookScalarWhereInput>
    NOT?: Enumerable<BookScalarWhereInput>
    id?: IntFilter | number
    bookTitleId?: IntFilter | number
    libraryId?: IntFilter | number
    isAvailable?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type RequestRecordUpsertWithWhereUniqueWithoutRequestedBookTitleInput = {
    where: RequestRecordWhereUniqueInput
    update: XOR<RequestRecordUpdateWithoutRequestedBookTitleInput, RequestRecordUncheckedUpdateWithoutRequestedBookTitleInput>
    create: XOR<RequestRecordCreateWithoutRequestedBookTitleInput, RequestRecordUncheckedCreateWithoutRequestedBookTitleInput>
  }

  export type RequestRecordUpdateWithWhereUniqueWithoutRequestedBookTitleInput = {
    where: RequestRecordWhereUniqueInput
    data: XOR<RequestRecordUpdateWithoutRequestedBookTitleInput, RequestRecordUncheckedUpdateWithoutRequestedBookTitleInput>
  }

  export type RequestRecordUpdateManyWithWhereWithoutRequestedBookTitleInput = {
    where: RequestRecordScalarWhereInput
    data: XOR<RequestRecordUpdateManyMutationInput, RequestRecordUncheckedUpdateManyWithoutRequestRecordsInput>
  }

  export type RequestRecordScalarWhereInput = {
    AND?: Enumerable<RequestRecordScalarWhereInput>
    OR?: Enumerable<RequestRecordScalarWhereInput>
    NOT?: Enumerable<RequestRecordScalarWhereInput>
    id?: IntFilter | number
    studentId?: IntFilter | number
    bookTitleId?: IntFilter | number
    requestingLibraryId?: IntFilter | number
    requestedLibraryId?: IntFilter | number
    requestDate?: DateTimeFilter | Date | string
    acquiredDate?: DateTimeNullableFilter | Date | string | null
    returnDate?: DateTimeNullableFilter | Date | string | null
    bookId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type BookTitleCreateWithoutCategoriesInput = {
    title: string
    isbn: string
    authors?: AuthorCreateNestedManyWithoutBookTitlesInput
    books?: BookCreateNestedManyWithoutTitleInput
    requestRecords?: RequestRecordCreateNestedManyWithoutRequestedBookTitleInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookTitleUncheckedCreateWithoutCategoriesInput = {
    id?: number
    title: string
    isbn: string
    authors?: AuthorUncheckedCreateNestedManyWithoutBookTitlesInput
    books?: BookUncheckedCreateNestedManyWithoutTitleInput
    requestRecords?: RequestRecordUncheckedCreateNestedManyWithoutRequestedBookTitleInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookTitleCreateOrConnectWithoutCategoriesInput = {
    where: BookTitleWhereUniqueInput
    create: XOR<BookTitleCreateWithoutCategoriesInput, BookTitleUncheckedCreateWithoutCategoriesInput>
  }

  export type BookTitleUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: BookTitleWhereUniqueInput
    update: XOR<BookTitleUpdateWithoutCategoriesInput, BookTitleUncheckedUpdateWithoutCategoriesInput>
    create: XOR<BookTitleCreateWithoutCategoriesInput, BookTitleUncheckedCreateWithoutCategoriesInput>
  }

  export type BookTitleUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: BookTitleWhereUniqueInput
    data: XOR<BookTitleUpdateWithoutCategoriesInput, BookTitleUncheckedUpdateWithoutCategoriesInput>
  }

  export type BookTitleUpdateManyWithWhereWithoutCategoriesInput = {
    where: BookTitleScalarWhereInput
    data: XOR<BookTitleUpdateManyMutationInput, BookTitleUncheckedUpdateManyWithoutBookTitlesInput>
  }

  export type BookTitleCreateWithoutBooksInput = {
    title: string
    isbn: string
    authors?: AuthorCreateNestedManyWithoutBookTitlesInput
    categories?: BookCategoryCreateNestedManyWithoutBookTitlesInput
    requestRecords?: RequestRecordCreateNestedManyWithoutRequestedBookTitleInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookTitleUncheckedCreateWithoutBooksInput = {
    id?: number
    title: string
    isbn: string
    authors?: AuthorUncheckedCreateNestedManyWithoutBookTitlesInput
    categories?: BookCategoryUncheckedCreateNestedManyWithoutBookTitlesInput
    requestRecords?: RequestRecordUncheckedCreateNestedManyWithoutRequestedBookTitleInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookTitleCreateOrConnectWithoutBooksInput = {
    where: BookTitleWhereUniqueInput
    create: XOR<BookTitleCreateWithoutBooksInput, BookTitleUncheckedCreateWithoutBooksInput>
  }

  export type LibraryCreateWithoutBooksInput = {
    name: string
    location: string
    belongsToUniversity: UniversityCreateNestedOneWithoutLibrariesInput
    requestingRecords?: RequestRecordCreateNestedManyWithoutRequestingLibraryInput
    requestedRecords?: RequestRecordCreateNestedManyWithoutRequestedLibraryInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryUncheckedCreateWithoutBooksInput = {
    id?: number
    name: string
    location: string
    universityId: number
    requestingRecords?: RequestRecordUncheckedCreateNestedManyWithoutRequestingLibraryInput
    requestedRecords?: RequestRecordUncheckedCreateNestedManyWithoutRequestedLibraryInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryCreateOrConnectWithoutBooksInput = {
    where: LibraryWhereUniqueInput
    create: XOR<LibraryCreateWithoutBooksInput, LibraryUncheckedCreateWithoutBooksInput>
  }

  export type BorrowingRecordCreateWithoutBorrowedBookInput = {
    borrowingStudent: StudentCreateNestedOneWithoutBorrowingRecordsInput
    startDate: Date | string
    endDate?: Date | string | null
    actualEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BorrowingRecordUncheckedCreateWithoutBorrowedBookInput = {
    id?: number
    studentId: number
    startDate: Date | string
    endDate?: Date | string | null
    actualEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BorrowingRecordCreateOrConnectWithoutBorrowedBookInput = {
    where: BorrowingRecordWhereUniqueInput
    create: XOR<BorrowingRecordCreateWithoutBorrowedBookInput, BorrowingRecordUncheckedCreateWithoutBorrowedBookInput>
  }

  export type BorrowingRecordCreateManyBorrowedBookInputEnvelope = {
    data: Enumerable<BorrowingRecordCreateManyBorrowedBookInput>
    skipDuplicates?: boolean
  }

  export type RequestRecordCreateWithoutAcquiredBookInput = {
    requestingStudent: StudentCreateNestedOneWithoutRequestRecordsInput
    requestedBookTitle: BookTitleCreateNestedOneWithoutRequestRecordsInput
    requestingLibrary: LibraryCreateNestedOneWithoutRequestingRecordsInput
    requestedLibrary: LibraryCreateNestedOneWithoutRequestedRecordsInput
    requestDate: Date | string
    acquiredDate?: Date | string | null
    returnDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestRecordUncheckedCreateWithoutAcquiredBookInput = {
    id?: number
    studentId: number
    bookTitleId: number
    requestingLibraryId: number
    requestedLibraryId: number
    requestDate: Date | string
    acquiredDate?: Date | string | null
    returnDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestRecordCreateOrConnectWithoutAcquiredBookInput = {
    where: RequestRecordWhereUniqueInput
    create: XOR<RequestRecordCreateWithoutAcquiredBookInput, RequestRecordUncheckedCreateWithoutAcquiredBookInput>
  }

  export type RequestRecordCreateManyAcquiredBookInputEnvelope = {
    data: Enumerable<RequestRecordCreateManyAcquiredBookInput>
    skipDuplicates?: boolean
  }

  export type BookTitleUpsertWithoutBooksInput = {
    update: XOR<BookTitleUpdateWithoutBooksInput, BookTitleUncheckedUpdateWithoutBooksInput>
    create: XOR<BookTitleCreateWithoutBooksInput, BookTitleUncheckedCreateWithoutBooksInput>
  }

  export type BookTitleUpdateWithoutBooksInput = {
    title?: StringFieldUpdateOperationsInput | string
    isbn?: StringFieldUpdateOperationsInput | string
    authors?: AuthorUpdateManyWithoutBookTitlesNestedInput
    categories?: BookCategoryUpdateManyWithoutBookTitlesNestedInput
    requestRecords?: RequestRecordUpdateManyWithoutRequestedBookTitleNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookTitleUncheckedUpdateWithoutBooksInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    isbn?: StringFieldUpdateOperationsInput | string
    authors?: AuthorUncheckedUpdateManyWithoutBookTitlesNestedInput
    categories?: BookCategoryUncheckedUpdateManyWithoutBookTitlesNestedInput
    requestRecords?: RequestRecordUncheckedUpdateManyWithoutRequestedBookTitleNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryUpsertWithoutBooksInput = {
    update: XOR<LibraryUpdateWithoutBooksInput, LibraryUncheckedUpdateWithoutBooksInput>
    create: XOR<LibraryCreateWithoutBooksInput, LibraryUncheckedCreateWithoutBooksInput>
  }

  export type LibraryUpdateWithoutBooksInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    belongsToUniversity?: UniversityUpdateOneRequiredWithoutLibrariesNestedInput
    requestingRecords?: RequestRecordUpdateManyWithoutRequestingLibraryNestedInput
    requestedRecords?: RequestRecordUpdateManyWithoutRequestedLibraryNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryUncheckedUpdateWithoutBooksInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    universityId?: IntFieldUpdateOperationsInput | number
    requestingRecords?: RequestRecordUncheckedUpdateManyWithoutRequestingLibraryNestedInput
    requestedRecords?: RequestRecordUncheckedUpdateManyWithoutRequestedLibraryNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BorrowingRecordUpsertWithWhereUniqueWithoutBorrowedBookInput = {
    where: BorrowingRecordWhereUniqueInput
    update: XOR<BorrowingRecordUpdateWithoutBorrowedBookInput, BorrowingRecordUncheckedUpdateWithoutBorrowedBookInput>
    create: XOR<BorrowingRecordCreateWithoutBorrowedBookInput, BorrowingRecordUncheckedCreateWithoutBorrowedBookInput>
  }

  export type BorrowingRecordUpdateWithWhereUniqueWithoutBorrowedBookInput = {
    where: BorrowingRecordWhereUniqueInput
    data: XOR<BorrowingRecordUpdateWithoutBorrowedBookInput, BorrowingRecordUncheckedUpdateWithoutBorrowedBookInput>
  }

  export type BorrowingRecordUpdateManyWithWhereWithoutBorrowedBookInput = {
    where: BorrowingRecordScalarWhereInput
    data: XOR<BorrowingRecordUpdateManyMutationInput, BorrowingRecordUncheckedUpdateManyWithoutBorrowingRecordsInput>
  }

  export type BorrowingRecordScalarWhereInput = {
    AND?: Enumerable<BorrowingRecordScalarWhereInput>
    OR?: Enumerable<BorrowingRecordScalarWhereInput>
    NOT?: Enumerable<BorrowingRecordScalarWhereInput>
    id?: IntFilter | number
    studentId?: IntFilter | number
    bookId?: IntFilter | number
    startDate?: DateTimeFilter | Date | string
    endDate?: DateTimeNullableFilter | Date | string | null
    actualEndDate?: DateTimeNullableFilter | Date | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type RequestRecordUpsertWithWhereUniqueWithoutAcquiredBookInput = {
    where: RequestRecordWhereUniqueInput
    update: XOR<RequestRecordUpdateWithoutAcquiredBookInput, RequestRecordUncheckedUpdateWithoutAcquiredBookInput>
    create: XOR<RequestRecordCreateWithoutAcquiredBookInput, RequestRecordUncheckedCreateWithoutAcquiredBookInput>
  }

  export type RequestRecordUpdateWithWhereUniqueWithoutAcquiredBookInput = {
    where: RequestRecordWhereUniqueInput
    data: XOR<RequestRecordUpdateWithoutAcquiredBookInput, RequestRecordUncheckedUpdateWithoutAcquiredBookInput>
  }

  export type RequestRecordUpdateManyWithWhereWithoutAcquiredBookInput = {
    where: RequestRecordScalarWhereInput
    data: XOR<RequestRecordUpdateManyMutationInput, RequestRecordUncheckedUpdateManyWithoutRequestRecordsInput>
  }

  export type UniversityCreateWithoutLibrariesInput = {
    name: string
    location: string
    students?: StudentCreateNestedManyWithoutBelongsToUniversityInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UniversityUncheckedCreateWithoutLibrariesInput = {
    id?: number
    name: string
    location: string
    students?: StudentUncheckedCreateNestedManyWithoutBelongsToUniversityInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UniversityCreateOrConnectWithoutLibrariesInput = {
    where: UniversityWhereUniqueInput
    create: XOR<UniversityCreateWithoutLibrariesInput, UniversityUncheckedCreateWithoutLibrariesInput>
  }

  export type BookCreateWithoutBelongsToLibraryInput = {
    title: BookTitleCreateNestedOneWithoutBooksInput
    isAvailable: boolean
    borrowingRecords?: BorrowingRecordCreateNestedManyWithoutBorrowedBookInput
    requestRecords?: RequestRecordCreateNestedManyWithoutAcquiredBookInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookUncheckedCreateWithoutBelongsToLibraryInput = {
    id?: number
    bookTitleId: number
    isAvailable: boolean
    borrowingRecords?: BorrowingRecordUncheckedCreateNestedManyWithoutBorrowedBookInput
    requestRecords?: RequestRecordUncheckedCreateNestedManyWithoutAcquiredBookInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookCreateOrConnectWithoutBelongsToLibraryInput = {
    where: BookWhereUniqueInput
    create: XOR<BookCreateWithoutBelongsToLibraryInput, BookUncheckedCreateWithoutBelongsToLibraryInput>
  }

  export type BookCreateManyBelongsToLibraryInputEnvelope = {
    data: Enumerable<BookCreateManyBelongsToLibraryInput>
    skipDuplicates?: boolean
  }

  export type RequestRecordCreateWithoutRequestingLibraryInput = {
    requestingStudent: StudentCreateNestedOneWithoutRequestRecordsInput
    requestedBookTitle: BookTitleCreateNestedOneWithoutRequestRecordsInput
    requestedLibrary: LibraryCreateNestedOneWithoutRequestedRecordsInput
    requestDate: Date | string
    acquiredDate?: Date | string | null
    returnDate?: Date | string | null
    acquiredBook?: BookCreateNestedOneWithoutRequestRecordsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestRecordUncheckedCreateWithoutRequestingLibraryInput = {
    id?: number
    studentId: number
    bookTitleId: number
    requestedLibraryId: number
    requestDate: Date | string
    acquiredDate?: Date | string | null
    returnDate?: Date | string | null
    bookId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestRecordCreateOrConnectWithoutRequestingLibraryInput = {
    where: RequestRecordWhereUniqueInput
    create: XOR<RequestRecordCreateWithoutRequestingLibraryInput, RequestRecordUncheckedCreateWithoutRequestingLibraryInput>
  }

  export type RequestRecordCreateManyRequestingLibraryInputEnvelope = {
    data: Enumerable<RequestRecordCreateManyRequestingLibraryInput>
    skipDuplicates?: boolean
  }

  export type RequestRecordCreateWithoutRequestedLibraryInput = {
    requestingStudent: StudentCreateNestedOneWithoutRequestRecordsInput
    requestedBookTitle: BookTitleCreateNestedOneWithoutRequestRecordsInput
    requestingLibrary: LibraryCreateNestedOneWithoutRequestingRecordsInput
    requestDate: Date | string
    acquiredDate?: Date | string | null
    returnDate?: Date | string | null
    acquiredBook?: BookCreateNestedOneWithoutRequestRecordsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestRecordUncheckedCreateWithoutRequestedLibraryInput = {
    id?: number
    studentId: number
    bookTitleId: number
    requestingLibraryId: number
    requestDate: Date | string
    acquiredDate?: Date | string | null
    returnDate?: Date | string | null
    bookId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestRecordCreateOrConnectWithoutRequestedLibraryInput = {
    where: RequestRecordWhereUniqueInput
    create: XOR<RequestRecordCreateWithoutRequestedLibraryInput, RequestRecordUncheckedCreateWithoutRequestedLibraryInput>
  }

  export type RequestRecordCreateManyRequestedLibraryInputEnvelope = {
    data: Enumerable<RequestRecordCreateManyRequestedLibraryInput>
    skipDuplicates?: boolean
  }

  export type UniversityUpsertWithoutLibrariesInput = {
    update: XOR<UniversityUpdateWithoutLibrariesInput, UniversityUncheckedUpdateWithoutLibrariesInput>
    create: XOR<UniversityCreateWithoutLibrariesInput, UniversityUncheckedCreateWithoutLibrariesInput>
  }

  export type UniversityUpdateWithoutLibrariesInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    students?: StudentUpdateManyWithoutBelongsToUniversityNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UniversityUncheckedUpdateWithoutLibrariesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    students?: StudentUncheckedUpdateManyWithoutBelongsToUniversityNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookUpsertWithWhereUniqueWithoutBelongsToLibraryInput = {
    where: BookWhereUniqueInput
    update: XOR<BookUpdateWithoutBelongsToLibraryInput, BookUncheckedUpdateWithoutBelongsToLibraryInput>
    create: XOR<BookCreateWithoutBelongsToLibraryInput, BookUncheckedCreateWithoutBelongsToLibraryInput>
  }

  export type BookUpdateWithWhereUniqueWithoutBelongsToLibraryInput = {
    where: BookWhereUniqueInput
    data: XOR<BookUpdateWithoutBelongsToLibraryInput, BookUncheckedUpdateWithoutBelongsToLibraryInput>
  }

  export type BookUpdateManyWithWhereWithoutBelongsToLibraryInput = {
    where: BookScalarWhereInput
    data: XOR<BookUpdateManyMutationInput, BookUncheckedUpdateManyWithoutBooksInput>
  }

  export type RequestRecordUpsertWithWhereUniqueWithoutRequestingLibraryInput = {
    where: RequestRecordWhereUniqueInput
    update: XOR<RequestRecordUpdateWithoutRequestingLibraryInput, RequestRecordUncheckedUpdateWithoutRequestingLibraryInput>
    create: XOR<RequestRecordCreateWithoutRequestingLibraryInput, RequestRecordUncheckedCreateWithoutRequestingLibraryInput>
  }

  export type RequestRecordUpdateWithWhereUniqueWithoutRequestingLibraryInput = {
    where: RequestRecordWhereUniqueInput
    data: XOR<RequestRecordUpdateWithoutRequestingLibraryInput, RequestRecordUncheckedUpdateWithoutRequestingLibraryInput>
  }

  export type RequestRecordUpdateManyWithWhereWithoutRequestingLibraryInput = {
    where: RequestRecordScalarWhereInput
    data: XOR<RequestRecordUpdateManyMutationInput, RequestRecordUncheckedUpdateManyWithoutRequestingRecordsInput>
  }

  export type RequestRecordUpsertWithWhereUniqueWithoutRequestedLibraryInput = {
    where: RequestRecordWhereUniqueInput
    update: XOR<RequestRecordUpdateWithoutRequestedLibraryInput, RequestRecordUncheckedUpdateWithoutRequestedLibraryInput>
    create: XOR<RequestRecordCreateWithoutRequestedLibraryInput, RequestRecordUncheckedCreateWithoutRequestedLibraryInput>
  }

  export type RequestRecordUpdateWithWhereUniqueWithoutRequestedLibraryInput = {
    where: RequestRecordWhereUniqueInput
    data: XOR<RequestRecordUpdateWithoutRequestedLibraryInput, RequestRecordUncheckedUpdateWithoutRequestedLibraryInput>
  }

  export type RequestRecordUpdateManyWithWhereWithoutRequestedLibraryInput = {
    where: RequestRecordScalarWhereInput
    data: XOR<RequestRecordUpdateManyMutationInput, RequestRecordUncheckedUpdateManyWithoutRequestedRecordsInput>
  }

  export type LibraryCreateWithoutBelongsToUniversityInput = {
    name: string
    location: string
    books?: BookCreateNestedManyWithoutBelongsToLibraryInput
    requestingRecords?: RequestRecordCreateNestedManyWithoutRequestingLibraryInput
    requestedRecords?: RequestRecordCreateNestedManyWithoutRequestedLibraryInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryUncheckedCreateWithoutBelongsToUniversityInput = {
    id?: number
    name: string
    location: string
    books?: BookUncheckedCreateNestedManyWithoutBelongsToLibraryInput
    requestingRecords?: RequestRecordUncheckedCreateNestedManyWithoutRequestingLibraryInput
    requestedRecords?: RequestRecordUncheckedCreateNestedManyWithoutRequestedLibraryInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryCreateOrConnectWithoutBelongsToUniversityInput = {
    where: LibraryWhereUniqueInput
    create: XOR<LibraryCreateWithoutBelongsToUniversityInput, LibraryUncheckedCreateWithoutBelongsToUniversityInput>
  }

  export type LibraryCreateManyBelongsToUniversityInputEnvelope = {
    data: Enumerable<LibraryCreateManyBelongsToUniversityInput>
    skipDuplicates?: boolean
  }

  export type StudentCreateWithoutBelongsToUniversityInput = {
    Name: string
    borrowingRecords?: BorrowingRecordCreateNestedManyWithoutBorrowingStudentInput
    requestRecords?: RequestRecordCreateNestedManyWithoutRequestingStudentInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentUncheckedCreateWithoutBelongsToUniversityInput = {
    id?: number
    Name: string
    borrowingRecords?: BorrowingRecordUncheckedCreateNestedManyWithoutBorrowingStudentInput
    requestRecords?: RequestRecordUncheckedCreateNestedManyWithoutRequestingStudentInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentCreateOrConnectWithoutBelongsToUniversityInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutBelongsToUniversityInput, StudentUncheckedCreateWithoutBelongsToUniversityInput>
  }

  export type StudentCreateManyBelongsToUniversityInputEnvelope = {
    data: Enumerable<StudentCreateManyBelongsToUniversityInput>
    skipDuplicates?: boolean
  }

  export type LibraryUpsertWithWhereUniqueWithoutBelongsToUniversityInput = {
    where: LibraryWhereUniqueInput
    update: XOR<LibraryUpdateWithoutBelongsToUniversityInput, LibraryUncheckedUpdateWithoutBelongsToUniversityInput>
    create: XOR<LibraryCreateWithoutBelongsToUniversityInput, LibraryUncheckedCreateWithoutBelongsToUniversityInput>
  }

  export type LibraryUpdateWithWhereUniqueWithoutBelongsToUniversityInput = {
    where: LibraryWhereUniqueInput
    data: XOR<LibraryUpdateWithoutBelongsToUniversityInput, LibraryUncheckedUpdateWithoutBelongsToUniversityInput>
  }

  export type LibraryUpdateManyWithWhereWithoutBelongsToUniversityInput = {
    where: LibraryScalarWhereInput
    data: XOR<LibraryUpdateManyMutationInput, LibraryUncheckedUpdateManyWithoutLibrariesInput>
  }

  export type LibraryScalarWhereInput = {
    AND?: Enumerable<LibraryScalarWhereInput>
    OR?: Enumerable<LibraryScalarWhereInput>
    NOT?: Enumerable<LibraryScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    location?: StringFilter | string
    universityId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type StudentUpsertWithWhereUniqueWithoutBelongsToUniversityInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutBelongsToUniversityInput, StudentUncheckedUpdateWithoutBelongsToUniversityInput>
    create: XOR<StudentCreateWithoutBelongsToUniversityInput, StudentUncheckedCreateWithoutBelongsToUniversityInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutBelongsToUniversityInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutBelongsToUniversityInput, StudentUncheckedUpdateWithoutBelongsToUniversityInput>
  }

  export type StudentUpdateManyWithWhereWithoutBelongsToUniversityInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutStudentsInput>
  }

  export type StudentScalarWhereInput = {
    AND?: Enumerable<StudentScalarWhereInput>
    OR?: Enumerable<StudentScalarWhereInput>
    NOT?: Enumerable<StudentScalarWhereInput>
    id?: IntFilter | number
    Name?: StringFilter | string
    universityId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type UniversityCreateWithoutStudentsInput = {
    name: string
    location: string
    libraries?: LibraryCreateNestedManyWithoutBelongsToUniversityInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UniversityUncheckedCreateWithoutStudentsInput = {
    id?: number
    name: string
    location: string
    libraries?: LibraryUncheckedCreateNestedManyWithoutBelongsToUniversityInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UniversityCreateOrConnectWithoutStudentsInput = {
    where: UniversityWhereUniqueInput
    create: XOR<UniversityCreateWithoutStudentsInput, UniversityUncheckedCreateWithoutStudentsInput>
  }

  export type BorrowingRecordCreateWithoutBorrowingStudentInput = {
    borrowedBook: BookCreateNestedOneWithoutBorrowingRecordsInput
    startDate: Date | string
    endDate?: Date | string | null
    actualEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BorrowingRecordUncheckedCreateWithoutBorrowingStudentInput = {
    id?: number
    bookId: number
    startDate: Date | string
    endDate?: Date | string | null
    actualEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BorrowingRecordCreateOrConnectWithoutBorrowingStudentInput = {
    where: BorrowingRecordWhereUniqueInput
    create: XOR<BorrowingRecordCreateWithoutBorrowingStudentInput, BorrowingRecordUncheckedCreateWithoutBorrowingStudentInput>
  }

  export type BorrowingRecordCreateManyBorrowingStudentInputEnvelope = {
    data: Enumerable<BorrowingRecordCreateManyBorrowingStudentInput>
    skipDuplicates?: boolean
  }

  export type RequestRecordCreateWithoutRequestingStudentInput = {
    requestedBookTitle: BookTitleCreateNestedOneWithoutRequestRecordsInput
    requestingLibrary: LibraryCreateNestedOneWithoutRequestingRecordsInput
    requestedLibrary: LibraryCreateNestedOneWithoutRequestedRecordsInput
    requestDate: Date | string
    acquiredDate?: Date | string | null
    returnDate?: Date | string | null
    acquiredBook?: BookCreateNestedOneWithoutRequestRecordsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestRecordUncheckedCreateWithoutRequestingStudentInput = {
    id?: number
    bookTitleId: number
    requestingLibraryId: number
    requestedLibraryId: number
    requestDate: Date | string
    acquiredDate?: Date | string | null
    returnDate?: Date | string | null
    bookId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestRecordCreateOrConnectWithoutRequestingStudentInput = {
    where: RequestRecordWhereUniqueInput
    create: XOR<RequestRecordCreateWithoutRequestingStudentInput, RequestRecordUncheckedCreateWithoutRequestingStudentInput>
  }

  export type RequestRecordCreateManyRequestingStudentInputEnvelope = {
    data: Enumerable<RequestRecordCreateManyRequestingStudentInput>
    skipDuplicates?: boolean
  }

  export type UniversityUpsertWithoutStudentsInput = {
    update: XOR<UniversityUpdateWithoutStudentsInput, UniversityUncheckedUpdateWithoutStudentsInput>
    create: XOR<UniversityCreateWithoutStudentsInput, UniversityUncheckedCreateWithoutStudentsInput>
  }

  export type UniversityUpdateWithoutStudentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    libraries?: LibraryUpdateManyWithoutBelongsToUniversityNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UniversityUncheckedUpdateWithoutStudentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    libraries?: LibraryUncheckedUpdateManyWithoutBelongsToUniversityNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BorrowingRecordUpsertWithWhereUniqueWithoutBorrowingStudentInput = {
    where: BorrowingRecordWhereUniqueInput
    update: XOR<BorrowingRecordUpdateWithoutBorrowingStudentInput, BorrowingRecordUncheckedUpdateWithoutBorrowingStudentInput>
    create: XOR<BorrowingRecordCreateWithoutBorrowingStudentInput, BorrowingRecordUncheckedCreateWithoutBorrowingStudentInput>
  }

  export type BorrowingRecordUpdateWithWhereUniqueWithoutBorrowingStudentInput = {
    where: BorrowingRecordWhereUniqueInput
    data: XOR<BorrowingRecordUpdateWithoutBorrowingStudentInput, BorrowingRecordUncheckedUpdateWithoutBorrowingStudentInput>
  }

  export type BorrowingRecordUpdateManyWithWhereWithoutBorrowingStudentInput = {
    where: BorrowingRecordScalarWhereInput
    data: XOR<BorrowingRecordUpdateManyMutationInput, BorrowingRecordUncheckedUpdateManyWithoutBorrowingRecordsInput>
  }

  export type RequestRecordUpsertWithWhereUniqueWithoutRequestingStudentInput = {
    where: RequestRecordWhereUniqueInput
    update: XOR<RequestRecordUpdateWithoutRequestingStudentInput, RequestRecordUncheckedUpdateWithoutRequestingStudentInput>
    create: XOR<RequestRecordCreateWithoutRequestingStudentInput, RequestRecordUncheckedCreateWithoutRequestingStudentInput>
  }

  export type RequestRecordUpdateWithWhereUniqueWithoutRequestingStudentInput = {
    where: RequestRecordWhereUniqueInput
    data: XOR<RequestRecordUpdateWithoutRequestingStudentInput, RequestRecordUncheckedUpdateWithoutRequestingStudentInput>
  }

  export type RequestRecordUpdateManyWithWhereWithoutRequestingStudentInput = {
    where: RequestRecordScalarWhereInput
    data: XOR<RequestRecordUpdateManyMutationInput, RequestRecordUncheckedUpdateManyWithoutRequestRecordsInput>
  }

  export type StudentCreateWithoutBorrowingRecordsInput = {
    Name: string
    belongsToUniversity: UniversityCreateNestedOneWithoutStudentsInput
    requestRecords?: RequestRecordCreateNestedManyWithoutRequestingStudentInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentUncheckedCreateWithoutBorrowingRecordsInput = {
    id?: number
    Name: string
    universityId: number
    requestRecords?: RequestRecordUncheckedCreateNestedManyWithoutRequestingStudentInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentCreateOrConnectWithoutBorrowingRecordsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutBorrowingRecordsInput, StudentUncheckedCreateWithoutBorrowingRecordsInput>
  }

  export type BookCreateWithoutBorrowingRecordsInput = {
    title: BookTitleCreateNestedOneWithoutBooksInput
    belongsToLibrary: LibraryCreateNestedOneWithoutBooksInput
    isAvailable: boolean
    requestRecords?: RequestRecordCreateNestedManyWithoutAcquiredBookInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookUncheckedCreateWithoutBorrowingRecordsInput = {
    id?: number
    bookTitleId: number
    libraryId: number
    isAvailable: boolean
    requestRecords?: RequestRecordUncheckedCreateNestedManyWithoutAcquiredBookInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookCreateOrConnectWithoutBorrowingRecordsInput = {
    where: BookWhereUniqueInput
    create: XOR<BookCreateWithoutBorrowingRecordsInput, BookUncheckedCreateWithoutBorrowingRecordsInput>
  }

  export type StudentUpsertWithoutBorrowingRecordsInput = {
    update: XOR<StudentUpdateWithoutBorrowingRecordsInput, StudentUncheckedUpdateWithoutBorrowingRecordsInput>
    create: XOR<StudentCreateWithoutBorrowingRecordsInput, StudentUncheckedCreateWithoutBorrowingRecordsInput>
  }

  export type StudentUpdateWithoutBorrowingRecordsInput = {
    Name?: StringFieldUpdateOperationsInput | string
    belongsToUniversity?: UniversityUpdateOneRequiredWithoutStudentsNestedInput
    requestRecords?: RequestRecordUpdateManyWithoutRequestingStudentNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUncheckedUpdateWithoutBorrowingRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    universityId?: IntFieldUpdateOperationsInput | number
    requestRecords?: RequestRecordUncheckedUpdateManyWithoutRequestingStudentNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookUpsertWithoutBorrowingRecordsInput = {
    update: XOR<BookUpdateWithoutBorrowingRecordsInput, BookUncheckedUpdateWithoutBorrowingRecordsInput>
    create: XOR<BookCreateWithoutBorrowingRecordsInput, BookUncheckedCreateWithoutBorrowingRecordsInput>
  }

  export type BookUpdateWithoutBorrowingRecordsInput = {
    title?: BookTitleUpdateOneRequiredWithoutBooksNestedInput
    belongsToLibrary?: LibraryUpdateOneRequiredWithoutBooksNestedInput
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    requestRecords?: RequestRecordUpdateManyWithoutAcquiredBookNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookUncheckedUpdateWithoutBorrowingRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookTitleId?: IntFieldUpdateOperationsInput | number
    libraryId?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    requestRecords?: RequestRecordUncheckedUpdateManyWithoutAcquiredBookNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCreateWithoutRequestRecordsInput = {
    Name: string
    belongsToUniversity: UniversityCreateNestedOneWithoutStudentsInput
    borrowingRecords?: BorrowingRecordCreateNestedManyWithoutBorrowingStudentInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentUncheckedCreateWithoutRequestRecordsInput = {
    id?: number
    Name: string
    universityId: number
    borrowingRecords?: BorrowingRecordUncheckedCreateNestedManyWithoutBorrowingStudentInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentCreateOrConnectWithoutRequestRecordsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutRequestRecordsInput, StudentUncheckedCreateWithoutRequestRecordsInput>
  }

  export type BookTitleCreateWithoutRequestRecordsInput = {
    title: string
    isbn: string
    authors?: AuthorCreateNestedManyWithoutBookTitlesInput
    categories?: BookCategoryCreateNestedManyWithoutBookTitlesInput
    books?: BookCreateNestedManyWithoutTitleInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookTitleUncheckedCreateWithoutRequestRecordsInput = {
    id?: number
    title: string
    isbn: string
    authors?: AuthorUncheckedCreateNestedManyWithoutBookTitlesInput
    categories?: BookCategoryUncheckedCreateNestedManyWithoutBookTitlesInput
    books?: BookUncheckedCreateNestedManyWithoutTitleInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookTitleCreateOrConnectWithoutRequestRecordsInput = {
    where: BookTitleWhereUniqueInput
    create: XOR<BookTitleCreateWithoutRequestRecordsInput, BookTitleUncheckedCreateWithoutRequestRecordsInput>
  }

  export type LibraryCreateWithoutRequestingRecordsInput = {
    name: string
    location: string
    belongsToUniversity: UniversityCreateNestedOneWithoutLibrariesInput
    books?: BookCreateNestedManyWithoutBelongsToLibraryInput
    requestedRecords?: RequestRecordCreateNestedManyWithoutRequestedLibraryInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryUncheckedCreateWithoutRequestingRecordsInput = {
    id?: number
    name: string
    location: string
    universityId: number
    books?: BookUncheckedCreateNestedManyWithoutBelongsToLibraryInput
    requestedRecords?: RequestRecordUncheckedCreateNestedManyWithoutRequestedLibraryInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryCreateOrConnectWithoutRequestingRecordsInput = {
    where: LibraryWhereUniqueInput
    create: XOR<LibraryCreateWithoutRequestingRecordsInput, LibraryUncheckedCreateWithoutRequestingRecordsInput>
  }

  export type LibraryCreateWithoutRequestedRecordsInput = {
    name: string
    location: string
    belongsToUniversity: UniversityCreateNestedOneWithoutLibrariesInput
    books?: BookCreateNestedManyWithoutBelongsToLibraryInput
    requestingRecords?: RequestRecordCreateNestedManyWithoutRequestingLibraryInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryUncheckedCreateWithoutRequestedRecordsInput = {
    id?: number
    name: string
    location: string
    universityId: number
    books?: BookUncheckedCreateNestedManyWithoutBelongsToLibraryInput
    requestingRecords?: RequestRecordUncheckedCreateNestedManyWithoutRequestingLibraryInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryCreateOrConnectWithoutRequestedRecordsInput = {
    where: LibraryWhereUniqueInput
    create: XOR<LibraryCreateWithoutRequestedRecordsInput, LibraryUncheckedCreateWithoutRequestedRecordsInput>
  }

  export type BookCreateWithoutRequestRecordsInput = {
    title: BookTitleCreateNestedOneWithoutBooksInput
    belongsToLibrary: LibraryCreateNestedOneWithoutBooksInput
    isAvailable: boolean
    borrowingRecords?: BorrowingRecordCreateNestedManyWithoutBorrowedBookInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookUncheckedCreateWithoutRequestRecordsInput = {
    id?: number
    bookTitleId: number
    libraryId: number
    isAvailable: boolean
    borrowingRecords?: BorrowingRecordUncheckedCreateNestedManyWithoutBorrowedBookInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookCreateOrConnectWithoutRequestRecordsInput = {
    where: BookWhereUniqueInput
    create: XOR<BookCreateWithoutRequestRecordsInput, BookUncheckedCreateWithoutRequestRecordsInput>
  }

  export type StudentUpsertWithoutRequestRecordsInput = {
    update: XOR<StudentUpdateWithoutRequestRecordsInput, StudentUncheckedUpdateWithoutRequestRecordsInput>
    create: XOR<StudentCreateWithoutRequestRecordsInput, StudentUncheckedCreateWithoutRequestRecordsInput>
  }

  export type StudentUpdateWithoutRequestRecordsInput = {
    Name?: StringFieldUpdateOperationsInput | string
    belongsToUniversity?: UniversityUpdateOneRequiredWithoutStudentsNestedInput
    borrowingRecords?: BorrowingRecordUpdateManyWithoutBorrowingStudentNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUncheckedUpdateWithoutRequestRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    universityId?: IntFieldUpdateOperationsInput | number
    borrowingRecords?: BorrowingRecordUncheckedUpdateManyWithoutBorrowingStudentNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookTitleUpsertWithoutRequestRecordsInput = {
    update: XOR<BookTitleUpdateWithoutRequestRecordsInput, BookTitleUncheckedUpdateWithoutRequestRecordsInput>
    create: XOR<BookTitleCreateWithoutRequestRecordsInput, BookTitleUncheckedCreateWithoutRequestRecordsInput>
  }

  export type BookTitleUpdateWithoutRequestRecordsInput = {
    title?: StringFieldUpdateOperationsInput | string
    isbn?: StringFieldUpdateOperationsInput | string
    authors?: AuthorUpdateManyWithoutBookTitlesNestedInput
    categories?: BookCategoryUpdateManyWithoutBookTitlesNestedInput
    books?: BookUpdateManyWithoutTitleNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookTitleUncheckedUpdateWithoutRequestRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    isbn?: StringFieldUpdateOperationsInput | string
    authors?: AuthorUncheckedUpdateManyWithoutBookTitlesNestedInput
    categories?: BookCategoryUncheckedUpdateManyWithoutBookTitlesNestedInput
    books?: BookUncheckedUpdateManyWithoutTitleNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryUpsertWithoutRequestingRecordsInput = {
    update: XOR<LibraryUpdateWithoutRequestingRecordsInput, LibraryUncheckedUpdateWithoutRequestingRecordsInput>
    create: XOR<LibraryCreateWithoutRequestingRecordsInput, LibraryUncheckedCreateWithoutRequestingRecordsInput>
  }

  export type LibraryUpdateWithoutRequestingRecordsInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    belongsToUniversity?: UniversityUpdateOneRequiredWithoutLibrariesNestedInput
    books?: BookUpdateManyWithoutBelongsToLibraryNestedInput
    requestedRecords?: RequestRecordUpdateManyWithoutRequestedLibraryNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryUncheckedUpdateWithoutRequestingRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    universityId?: IntFieldUpdateOperationsInput | number
    books?: BookUncheckedUpdateManyWithoutBelongsToLibraryNestedInput
    requestedRecords?: RequestRecordUncheckedUpdateManyWithoutRequestedLibraryNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryUpsertWithoutRequestedRecordsInput = {
    update: XOR<LibraryUpdateWithoutRequestedRecordsInput, LibraryUncheckedUpdateWithoutRequestedRecordsInput>
    create: XOR<LibraryCreateWithoutRequestedRecordsInput, LibraryUncheckedCreateWithoutRequestedRecordsInput>
  }

  export type LibraryUpdateWithoutRequestedRecordsInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    belongsToUniversity?: UniversityUpdateOneRequiredWithoutLibrariesNestedInput
    books?: BookUpdateManyWithoutBelongsToLibraryNestedInput
    requestingRecords?: RequestRecordUpdateManyWithoutRequestingLibraryNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryUncheckedUpdateWithoutRequestedRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    universityId?: IntFieldUpdateOperationsInput | number
    books?: BookUncheckedUpdateManyWithoutBelongsToLibraryNestedInput
    requestingRecords?: RequestRecordUncheckedUpdateManyWithoutRequestingLibraryNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookUpsertWithoutRequestRecordsInput = {
    update: XOR<BookUpdateWithoutRequestRecordsInput, BookUncheckedUpdateWithoutRequestRecordsInput>
    create: XOR<BookCreateWithoutRequestRecordsInput, BookUncheckedCreateWithoutRequestRecordsInput>
  }

  export type BookUpdateWithoutRequestRecordsInput = {
    title?: BookTitleUpdateOneRequiredWithoutBooksNestedInput
    belongsToLibrary?: LibraryUpdateOneRequiredWithoutBooksNestedInput
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    borrowingRecords?: BorrowingRecordUpdateManyWithoutBorrowedBookNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookUncheckedUpdateWithoutRequestRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookTitleId?: IntFieldUpdateOperationsInput | number
    libraryId?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    borrowingRecords?: BorrowingRecordUncheckedUpdateManyWithoutBorrowedBookNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRelationCreateWithoutFollowingUserInput = {
    followedUser: UserCreateNestedOneWithoutFollowedUserRelationsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserRelationUncheckedCreateWithoutFollowingUserInput = {
    id?: number
    followedUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserRelationCreateOrConnectWithoutFollowingUserInput = {
    where: UserRelationWhereUniqueInput
    create: XOR<UserRelationCreateWithoutFollowingUserInput, UserRelationUncheckedCreateWithoutFollowingUserInput>
  }

  export type UserRelationCreateManyFollowingUserInputEnvelope = {
    data: Enumerable<UserRelationCreateManyFollowingUserInput>
    skipDuplicates?: boolean
  }

  export type UserRelationCreateWithoutFollowedUserInput = {
    followingUser: UserCreateNestedOneWithoutFollowingUserRelationsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserRelationUncheckedCreateWithoutFollowedUserInput = {
    id?: number
    followingUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserRelationCreateOrConnectWithoutFollowedUserInput = {
    where: UserRelationWhereUniqueInput
    create: XOR<UserRelationCreateWithoutFollowedUserInput, UserRelationUncheckedCreateWithoutFollowedUserInput>
  }

  export type UserRelationCreateManyFollowedUserInputEnvelope = {
    data: Enumerable<UserRelationCreateManyFollowedUserInput>
    skipDuplicates?: boolean
  }

  export type TweetCreateWithoutTweetingUserInput = {
    tweetText: string
    parentTweet?: TweetCreateNestedOneWithoutChildTweetsInput
    childTweets?: TweetCreateNestedManyWithoutParentTweetInput
    hashTags?: HashTagCreateNestedManyWithoutIsInTweetsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TweetUncheckedCreateWithoutTweetingUserInput = {
    id?: number
    tweetText: string
    parentTweetId?: number | null
    childTweets?: TweetUncheckedCreateNestedManyWithoutParentTweetInput
    hashTags?: HashTagUncheckedCreateNestedManyWithoutIsInTweetsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TweetCreateOrConnectWithoutTweetingUserInput = {
    where: TweetWhereUniqueInput
    create: XOR<TweetCreateWithoutTweetingUserInput, TweetUncheckedCreateWithoutTweetingUserInput>
  }

  export type TweetCreateManyTweetingUserInputEnvelope = {
    data: Enumerable<TweetCreateManyTweetingUserInput>
    skipDuplicates?: boolean
  }

  export type DirectMessageCreateWithoutFromUserInput = {
    dmText: string
    toUser: UserCreateNestedOneWithoutDirectMessagesToInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DirectMessageUncheckedCreateWithoutFromUserInput = {
    id?: number
    dmText: string
    toUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DirectMessageCreateOrConnectWithoutFromUserInput = {
    where: DirectMessageWhereUniqueInput
    create: XOR<DirectMessageCreateWithoutFromUserInput, DirectMessageUncheckedCreateWithoutFromUserInput>
  }

  export type DirectMessageCreateManyFromUserInputEnvelope = {
    data: Enumerable<DirectMessageCreateManyFromUserInput>
    skipDuplicates?: boolean
  }

  export type DirectMessageCreateWithoutToUserInput = {
    dmText: string
    fromUser: UserCreateNestedOneWithoutDirectMessagesFromInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DirectMessageUncheckedCreateWithoutToUserInput = {
    id?: number
    dmText: string
    fromUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DirectMessageCreateOrConnectWithoutToUserInput = {
    where: DirectMessageWhereUniqueInput
    create: XOR<DirectMessageCreateWithoutToUserInput, DirectMessageUncheckedCreateWithoutToUserInput>
  }

  export type DirectMessageCreateManyToUserInputEnvelope = {
    data: Enumerable<DirectMessageCreateManyToUserInput>
    skipDuplicates?: boolean
  }

  export type UserRelationUpsertWithWhereUniqueWithoutFollowingUserInput = {
    where: UserRelationWhereUniqueInput
    update: XOR<UserRelationUpdateWithoutFollowingUserInput, UserRelationUncheckedUpdateWithoutFollowingUserInput>
    create: XOR<UserRelationCreateWithoutFollowingUserInput, UserRelationUncheckedCreateWithoutFollowingUserInput>
  }

  export type UserRelationUpdateWithWhereUniqueWithoutFollowingUserInput = {
    where: UserRelationWhereUniqueInput
    data: XOR<UserRelationUpdateWithoutFollowingUserInput, UserRelationUncheckedUpdateWithoutFollowingUserInput>
  }

  export type UserRelationUpdateManyWithWhereWithoutFollowingUserInput = {
    where: UserRelationScalarWhereInput
    data: XOR<UserRelationUpdateManyMutationInput, UserRelationUncheckedUpdateManyWithoutFollowingUserRelationsInput>
  }

  export type UserRelationScalarWhereInput = {
    AND?: Enumerable<UserRelationScalarWhereInput>
    OR?: Enumerable<UserRelationScalarWhereInput>
    NOT?: Enumerable<UserRelationScalarWhereInput>
    id?: IntFilter | number
    followingUserId?: IntFilter | number
    followedUserId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type UserRelationUpsertWithWhereUniqueWithoutFollowedUserInput = {
    where: UserRelationWhereUniqueInput
    update: XOR<UserRelationUpdateWithoutFollowedUserInput, UserRelationUncheckedUpdateWithoutFollowedUserInput>
    create: XOR<UserRelationCreateWithoutFollowedUserInput, UserRelationUncheckedCreateWithoutFollowedUserInput>
  }

  export type UserRelationUpdateWithWhereUniqueWithoutFollowedUserInput = {
    where: UserRelationWhereUniqueInput
    data: XOR<UserRelationUpdateWithoutFollowedUserInput, UserRelationUncheckedUpdateWithoutFollowedUserInput>
  }

  export type UserRelationUpdateManyWithWhereWithoutFollowedUserInput = {
    where: UserRelationScalarWhereInput
    data: XOR<UserRelationUpdateManyMutationInput, UserRelationUncheckedUpdateManyWithoutFollowedUserRelationsInput>
  }

  export type TweetUpsertWithWhereUniqueWithoutTweetingUserInput = {
    where: TweetWhereUniqueInput
    update: XOR<TweetUpdateWithoutTweetingUserInput, TweetUncheckedUpdateWithoutTweetingUserInput>
    create: XOR<TweetCreateWithoutTweetingUserInput, TweetUncheckedCreateWithoutTweetingUserInput>
  }

  export type TweetUpdateWithWhereUniqueWithoutTweetingUserInput = {
    where: TweetWhereUniqueInput
    data: XOR<TweetUpdateWithoutTweetingUserInput, TweetUncheckedUpdateWithoutTweetingUserInput>
  }

  export type TweetUpdateManyWithWhereWithoutTweetingUserInput = {
    where: TweetScalarWhereInput
    data: XOR<TweetUpdateManyMutationInput, TweetUncheckedUpdateManyWithoutTweetsInput>
  }

  export type TweetScalarWhereInput = {
    AND?: Enumerable<TweetScalarWhereInput>
    OR?: Enumerable<TweetScalarWhereInput>
    NOT?: Enumerable<TweetScalarWhereInput>
    id?: IntFilter | number
    tweetText?: StringFilter | string
    parentTweetId?: IntNullableFilter | number | null
    userId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type DirectMessageUpsertWithWhereUniqueWithoutFromUserInput = {
    where: DirectMessageWhereUniqueInput
    update: XOR<DirectMessageUpdateWithoutFromUserInput, DirectMessageUncheckedUpdateWithoutFromUserInput>
    create: XOR<DirectMessageCreateWithoutFromUserInput, DirectMessageUncheckedCreateWithoutFromUserInput>
  }

  export type DirectMessageUpdateWithWhereUniqueWithoutFromUserInput = {
    where: DirectMessageWhereUniqueInput
    data: XOR<DirectMessageUpdateWithoutFromUserInput, DirectMessageUncheckedUpdateWithoutFromUserInput>
  }

  export type DirectMessageUpdateManyWithWhereWithoutFromUserInput = {
    where: DirectMessageScalarWhereInput
    data: XOR<DirectMessageUpdateManyMutationInput, DirectMessageUncheckedUpdateManyWithoutDirectMessagesFromInput>
  }

  export type DirectMessageScalarWhereInput = {
    AND?: Enumerable<DirectMessageScalarWhereInput>
    OR?: Enumerable<DirectMessageScalarWhereInput>
    NOT?: Enumerable<DirectMessageScalarWhereInput>
    id?: IntFilter | number
    dmText?: StringFilter | string
    fromUserId?: IntFilter | number
    toUserId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type DirectMessageUpsertWithWhereUniqueWithoutToUserInput = {
    where: DirectMessageWhereUniqueInput
    update: XOR<DirectMessageUpdateWithoutToUserInput, DirectMessageUncheckedUpdateWithoutToUserInput>
    create: XOR<DirectMessageCreateWithoutToUserInput, DirectMessageUncheckedCreateWithoutToUserInput>
  }

  export type DirectMessageUpdateWithWhereUniqueWithoutToUserInput = {
    where: DirectMessageWhereUniqueInput
    data: XOR<DirectMessageUpdateWithoutToUserInput, DirectMessageUncheckedUpdateWithoutToUserInput>
  }

  export type DirectMessageUpdateManyWithWhereWithoutToUserInput = {
    where: DirectMessageScalarWhereInput
    data: XOR<DirectMessageUpdateManyMutationInput, DirectMessageUncheckedUpdateManyWithoutDirectMessagesToInput>
  }

  export type UserCreateWithoutFollowingUserRelationsInput = {
    name: string
    imageUrl: string
    bio: string
    followedUserRelations?: UserRelationCreateNestedManyWithoutFollowedUserInput
    tweets?: TweetCreateNestedManyWithoutTweetingUserInput
    directMessagesFrom?: DirectMessageCreateNestedManyWithoutFromUserInput
    directMessagesTo?: DirectMessageCreateNestedManyWithoutToUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateWithoutFollowingUserRelationsInput = {
    id?: number
    name: string
    imageUrl: string
    bio: string
    followedUserRelations?: UserRelationUncheckedCreateNestedManyWithoutFollowedUserInput
    tweets?: TweetUncheckedCreateNestedManyWithoutTweetingUserInput
    directMessagesFrom?: DirectMessageUncheckedCreateNestedManyWithoutFromUserInput
    directMessagesTo?: DirectMessageUncheckedCreateNestedManyWithoutToUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateOrConnectWithoutFollowingUserRelationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFollowingUserRelationsInput, UserUncheckedCreateWithoutFollowingUserRelationsInput>
  }

  export type UserCreateWithoutFollowedUserRelationsInput = {
    name: string
    imageUrl: string
    bio: string
    followingUserRelations?: UserRelationCreateNestedManyWithoutFollowingUserInput
    tweets?: TweetCreateNestedManyWithoutTweetingUserInput
    directMessagesFrom?: DirectMessageCreateNestedManyWithoutFromUserInput
    directMessagesTo?: DirectMessageCreateNestedManyWithoutToUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateWithoutFollowedUserRelationsInput = {
    id?: number
    name: string
    imageUrl: string
    bio: string
    followingUserRelations?: UserRelationUncheckedCreateNestedManyWithoutFollowingUserInput
    tweets?: TweetUncheckedCreateNestedManyWithoutTweetingUserInput
    directMessagesFrom?: DirectMessageUncheckedCreateNestedManyWithoutFromUserInput
    directMessagesTo?: DirectMessageUncheckedCreateNestedManyWithoutToUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateOrConnectWithoutFollowedUserRelationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFollowedUserRelationsInput, UserUncheckedCreateWithoutFollowedUserRelationsInput>
  }

  export type UserUpsertWithoutFollowingUserRelationsInput = {
    update: XOR<UserUpdateWithoutFollowingUserRelationsInput, UserUncheckedUpdateWithoutFollowingUserRelationsInput>
    create: XOR<UserCreateWithoutFollowingUserRelationsInput, UserUncheckedCreateWithoutFollowingUserRelationsInput>
  }

  export type UserUpdateWithoutFollowingUserRelationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followedUserRelations?: UserRelationUpdateManyWithoutFollowedUserNestedInput
    tweets?: TweetUpdateManyWithoutTweetingUserNestedInput
    directMessagesFrom?: DirectMessageUpdateManyWithoutFromUserNestedInput
    directMessagesTo?: DirectMessageUpdateManyWithoutToUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutFollowingUserRelationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followedUserRelations?: UserRelationUncheckedUpdateManyWithoutFollowedUserNestedInput
    tweets?: TweetUncheckedUpdateManyWithoutTweetingUserNestedInput
    directMessagesFrom?: DirectMessageUncheckedUpdateManyWithoutFromUserNestedInput
    directMessagesTo?: DirectMessageUncheckedUpdateManyWithoutToUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutFollowedUserRelationsInput = {
    update: XOR<UserUpdateWithoutFollowedUserRelationsInput, UserUncheckedUpdateWithoutFollowedUserRelationsInput>
    create: XOR<UserCreateWithoutFollowedUserRelationsInput, UserUncheckedCreateWithoutFollowedUserRelationsInput>
  }

  export type UserUpdateWithoutFollowedUserRelationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followingUserRelations?: UserRelationUpdateManyWithoutFollowingUserNestedInput
    tweets?: TweetUpdateManyWithoutTweetingUserNestedInput
    directMessagesFrom?: DirectMessageUpdateManyWithoutFromUserNestedInput
    directMessagesTo?: DirectMessageUpdateManyWithoutToUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutFollowedUserRelationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followingUserRelations?: UserRelationUncheckedUpdateManyWithoutFollowingUserNestedInput
    tweets?: TweetUncheckedUpdateManyWithoutTweetingUserNestedInput
    directMessagesFrom?: DirectMessageUncheckedUpdateManyWithoutFromUserNestedInput
    directMessagesTo?: DirectMessageUncheckedUpdateManyWithoutToUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutTweetsInput = {
    name: string
    imageUrl: string
    bio: string
    followingUserRelations?: UserRelationCreateNestedManyWithoutFollowingUserInput
    followedUserRelations?: UserRelationCreateNestedManyWithoutFollowedUserInput
    directMessagesFrom?: DirectMessageCreateNestedManyWithoutFromUserInput
    directMessagesTo?: DirectMessageCreateNestedManyWithoutToUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateWithoutTweetsInput = {
    id?: number
    name: string
    imageUrl: string
    bio: string
    followingUserRelations?: UserRelationUncheckedCreateNestedManyWithoutFollowingUserInput
    followedUserRelations?: UserRelationUncheckedCreateNestedManyWithoutFollowedUserInput
    directMessagesFrom?: DirectMessageUncheckedCreateNestedManyWithoutFromUserInput
    directMessagesTo?: DirectMessageUncheckedCreateNestedManyWithoutToUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateOrConnectWithoutTweetsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTweetsInput, UserUncheckedCreateWithoutTweetsInput>
  }

  export type TweetCreateWithoutChildTweetsInput = {
    tweetText: string
    tweetingUser: UserCreateNestedOneWithoutTweetsInput
    parentTweet?: TweetCreateNestedOneWithoutChildTweetsInput
    hashTags?: HashTagCreateNestedManyWithoutIsInTweetsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TweetUncheckedCreateWithoutChildTweetsInput = {
    id?: number
    tweetText: string
    parentTweetId?: number | null
    userId: number
    hashTags?: HashTagUncheckedCreateNestedManyWithoutIsInTweetsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TweetCreateOrConnectWithoutChildTweetsInput = {
    where: TweetWhereUniqueInput
    create: XOR<TweetCreateWithoutChildTweetsInput, TweetUncheckedCreateWithoutChildTweetsInput>
  }

  export type TweetCreateWithoutParentTweetInput = {
    tweetText: string
    tweetingUser: UserCreateNestedOneWithoutTweetsInput
    childTweets?: TweetCreateNestedManyWithoutParentTweetInput
    hashTags?: HashTagCreateNestedManyWithoutIsInTweetsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TweetUncheckedCreateWithoutParentTweetInput = {
    id?: number
    tweetText: string
    childTweets?: TweetUncheckedCreateNestedManyWithoutParentTweetInput
    userId: number
    hashTags?: HashTagUncheckedCreateNestedManyWithoutIsInTweetsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TweetCreateOrConnectWithoutParentTweetInput = {
    where: TweetWhereUniqueInput
    create: XOR<TweetCreateWithoutParentTweetInput, TweetUncheckedCreateWithoutParentTweetInput>
  }

  export type TweetCreateManyParentTweetInputEnvelope = {
    data: Enumerable<TweetCreateManyParentTweetInput>
    skipDuplicates?: boolean
  }

  export type HashTagCreateWithoutIsInTweetsInput = {
    hashTagText: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HashTagUncheckedCreateWithoutIsInTweetsInput = {
    id?: number
    hashTagText: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HashTagCreateOrConnectWithoutIsInTweetsInput = {
    where: HashTagWhereUniqueInput
    create: XOR<HashTagCreateWithoutIsInTweetsInput, HashTagUncheckedCreateWithoutIsInTweetsInput>
  }

  export type UserUpsertWithoutTweetsInput = {
    update: XOR<UserUpdateWithoutTweetsInput, UserUncheckedUpdateWithoutTweetsInput>
    create: XOR<UserCreateWithoutTweetsInput, UserUncheckedCreateWithoutTweetsInput>
  }

  export type UserUpdateWithoutTweetsInput = {
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followingUserRelations?: UserRelationUpdateManyWithoutFollowingUserNestedInput
    followedUserRelations?: UserRelationUpdateManyWithoutFollowedUserNestedInput
    directMessagesFrom?: DirectMessageUpdateManyWithoutFromUserNestedInput
    directMessagesTo?: DirectMessageUpdateManyWithoutToUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutTweetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followingUserRelations?: UserRelationUncheckedUpdateManyWithoutFollowingUserNestedInput
    followedUserRelations?: UserRelationUncheckedUpdateManyWithoutFollowedUserNestedInput
    directMessagesFrom?: DirectMessageUncheckedUpdateManyWithoutFromUserNestedInput
    directMessagesTo?: DirectMessageUncheckedUpdateManyWithoutToUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TweetUpsertWithoutChildTweetsInput = {
    update: XOR<TweetUpdateWithoutChildTweetsInput, TweetUncheckedUpdateWithoutChildTweetsInput>
    create: XOR<TweetCreateWithoutChildTweetsInput, TweetUncheckedCreateWithoutChildTweetsInput>
  }

  export type TweetUpdateWithoutChildTweetsInput = {
    tweetText?: StringFieldUpdateOperationsInput | string
    tweetingUser?: UserUpdateOneRequiredWithoutTweetsNestedInput
    parentTweet?: TweetUpdateOneWithoutChildTweetsNestedInput
    hashTags?: HashTagUpdateManyWithoutIsInTweetsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TweetUncheckedUpdateWithoutChildTweetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tweetText?: StringFieldUpdateOperationsInput | string
    parentTweetId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    hashTags?: HashTagUncheckedUpdateManyWithoutIsInTweetsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TweetUpsertWithWhereUniqueWithoutParentTweetInput = {
    where: TweetWhereUniqueInput
    update: XOR<TweetUpdateWithoutParentTweetInput, TweetUncheckedUpdateWithoutParentTweetInput>
    create: XOR<TweetCreateWithoutParentTweetInput, TweetUncheckedCreateWithoutParentTweetInput>
  }

  export type TweetUpdateWithWhereUniqueWithoutParentTweetInput = {
    where: TweetWhereUniqueInput
    data: XOR<TweetUpdateWithoutParentTweetInput, TweetUncheckedUpdateWithoutParentTweetInput>
  }

  export type TweetUpdateManyWithWhereWithoutParentTweetInput = {
    where: TweetScalarWhereInput
    data: XOR<TweetUpdateManyMutationInput, TweetUncheckedUpdateManyWithoutChildTweetsInput>
  }

  export type HashTagUpsertWithWhereUniqueWithoutIsInTweetsInput = {
    where: HashTagWhereUniqueInput
    update: XOR<HashTagUpdateWithoutIsInTweetsInput, HashTagUncheckedUpdateWithoutIsInTweetsInput>
    create: XOR<HashTagCreateWithoutIsInTweetsInput, HashTagUncheckedCreateWithoutIsInTweetsInput>
  }

  export type HashTagUpdateWithWhereUniqueWithoutIsInTweetsInput = {
    where: HashTagWhereUniqueInput
    data: XOR<HashTagUpdateWithoutIsInTweetsInput, HashTagUncheckedUpdateWithoutIsInTweetsInput>
  }

  export type HashTagUpdateManyWithWhereWithoutIsInTweetsInput = {
    where: HashTagScalarWhereInput
    data: XOR<HashTagUpdateManyMutationInput, HashTagUncheckedUpdateManyWithoutHashTagsInput>
  }

  export type HashTagScalarWhereInput = {
    AND?: Enumerable<HashTagScalarWhereInput>
    OR?: Enumerable<HashTagScalarWhereInput>
    NOT?: Enumerable<HashTagScalarWhereInput>
    id?: IntFilter | number
    hashTagText?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TweetCreateWithoutHashTagsInput = {
    tweetText: string
    tweetingUser: UserCreateNestedOneWithoutTweetsInput
    parentTweet?: TweetCreateNestedOneWithoutChildTweetsInput
    childTweets?: TweetCreateNestedManyWithoutParentTweetInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TweetUncheckedCreateWithoutHashTagsInput = {
    id?: number
    tweetText: string
    parentTweetId?: number | null
    childTweets?: TweetUncheckedCreateNestedManyWithoutParentTweetInput
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TweetCreateOrConnectWithoutHashTagsInput = {
    where: TweetWhereUniqueInput
    create: XOR<TweetCreateWithoutHashTagsInput, TweetUncheckedCreateWithoutHashTagsInput>
  }

  export type TweetUpsertWithWhereUniqueWithoutHashTagsInput = {
    where: TweetWhereUniqueInput
    update: XOR<TweetUpdateWithoutHashTagsInput, TweetUncheckedUpdateWithoutHashTagsInput>
    create: XOR<TweetCreateWithoutHashTagsInput, TweetUncheckedCreateWithoutHashTagsInput>
  }

  export type TweetUpdateWithWhereUniqueWithoutHashTagsInput = {
    where: TweetWhereUniqueInput
    data: XOR<TweetUpdateWithoutHashTagsInput, TweetUncheckedUpdateWithoutHashTagsInput>
  }

  export type TweetUpdateManyWithWhereWithoutHashTagsInput = {
    where: TweetScalarWhereInput
    data: XOR<TweetUpdateManyMutationInput, TweetUncheckedUpdateManyWithoutIsInTweetsInput>
  }

  export type UserCreateWithoutDirectMessagesFromInput = {
    name: string
    imageUrl: string
    bio: string
    followingUserRelations?: UserRelationCreateNestedManyWithoutFollowingUserInput
    followedUserRelations?: UserRelationCreateNestedManyWithoutFollowedUserInput
    tweets?: TweetCreateNestedManyWithoutTweetingUserInput
    directMessagesTo?: DirectMessageCreateNestedManyWithoutToUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateWithoutDirectMessagesFromInput = {
    id?: number
    name: string
    imageUrl: string
    bio: string
    followingUserRelations?: UserRelationUncheckedCreateNestedManyWithoutFollowingUserInput
    followedUserRelations?: UserRelationUncheckedCreateNestedManyWithoutFollowedUserInput
    tweets?: TweetUncheckedCreateNestedManyWithoutTweetingUserInput
    directMessagesTo?: DirectMessageUncheckedCreateNestedManyWithoutToUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateOrConnectWithoutDirectMessagesFromInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDirectMessagesFromInput, UserUncheckedCreateWithoutDirectMessagesFromInput>
  }

  export type UserCreateWithoutDirectMessagesToInput = {
    name: string
    imageUrl: string
    bio: string
    followingUserRelations?: UserRelationCreateNestedManyWithoutFollowingUserInput
    followedUserRelations?: UserRelationCreateNestedManyWithoutFollowedUserInput
    tweets?: TweetCreateNestedManyWithoutTweetingUserInput
    directMessagesFrom?: DirectMessageCreateNestedManyWithoutFromUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateWithoutDirectMessagesToInput = {
    id?: number
    name: string
    imageUrl: string
    bio: string
    followingUserRelations?: UserRelationUncheckedCreateNestedManyWithoutFollowingUserInput
    followedUserRelations?: UserRelationUncheckedCreateNestedManyWithoutFollowedUserInput
    tweets?: TweetUncheckedCreateNestedManyWithoutTweetingUserInput
    directMessagesFrom?: DirectMessageUncheckedCreateNestedManyWithoutFromUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateOrConnectWithoutDirectMessagesToInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDirectMessagesToInput, UserUncheckedCreateWithoutDirectMessagesToInput>
  }

  export type UserUpsertWithoutDirectMessagesFromInput = {
    update: XOR<UserUpdateWithoutDirectMessagesFromInput, UserUncheckedUpdateWithoutDirectMessagesFromInput>
    create: XOR<UserCreateWithoutDirectMessagesFromInput, UserUncheckedCreateWithoutDirectMessagesFromInput>
  }

  export type UserUpdateWithoutDirectMessagesFromInput = {
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followingUserRelations?: UserRelationUpdateManyWithoutFollowingUserNestedInput
    followedUserRelations?: UserRelationUpdateManyWithoutFollowedUserNestedInput
    tweets?: TweetUpdateManyWithoutTweetingUserNestedInput
    directMessagesTo?: DirectMessageUpdateManyWithoutToUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutDirectMessagesFromInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followingUserRelations?: UserRelationUncheckedUpdateManyWithoutFollowingUserNestedInput
    followedUserRelations?: UserRelationUncheckedUpdateManyWithoutFollowedUserNestedInput
    tweets?: TweetUncheckedUpdateManyWithoutTweetingUserNestedInput
    directMessagesTo?: DirectMessageUncheckedUpdateManyWithoutToUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutDirectMessagesToInput = {
    update: XOR<UserUpdateWithoutDirectMessagesToInput, UserUncheckedUpdateWithoutDirectMessagesToInput>
    create: XOR<UserCreateWithoutDirectMessagesToInput, UserUncheckedCreateWithoutDirectMessagesToInput>
  }

  export type UserUpdateWithoutDirectMessagesToInput = {
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followingUserRelations?: UserRelationUpdateManyWithoutFollowingUserNestedInput
    followedUserRelations?: UserRelationUpdateManyWithoutFollowedUserNestedInput
    tweets?: TweetUpdateManyWithoutTweetingUserNestedInput
    directMessagesFrom?: DirectMessageUpdateManyWithoutFromUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutDirectMessagesToInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    followingUserRelations?: UserRelationUncheckedUpdateManyWithoutFollowingUserNestedInput
    followedUserRelations?: UserRelationUncheckedUpdateManyWithoutFollowedUserNestedInput
    tweets?: TweetUncheckedUpdateManyWithoutTweetingUserNestedInput
    directMessagesFrom?: DirectMessageUncheckedUpdateManyWithoutFromUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelCreateWithoutAdminUsersInput = {
    name: string
    profileImageUrl?: string | null
    description?: string | null
    subscribedUsers?: YouTubeUserCreateNestedManyWithoutSubscribingToChannelsInput
    usersToChannelswithRoles?: UserToChannelwithRoleCreateNestedManyWithoutChannelInput
    owningVideos?: VideoCreateNestedManyWithoutBelongsToChannelInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChannelUncheckedCreateWithoutAdminUsersInput = {
    id?: number
    name: string
    profileImageUrl?: string | null
    description?: string | null
    subscribedUsers?: YouTubeUserUncheckedCreateNestedManyWithoutSubscribingToChannelsInput
    usersToChannelswithRoles?: UserToChannelwithRoleUncheckedCreateNestedManyWithoutChannelInput
    owningVideos?: VideoUncheckedCreateNestedManyWithoutBelongsToChannelInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChannelCreateOrConnectWithoutAdminUsersInput = {
    where: ChannelWhereUniqueInput
    create: XOR<ChannelCreateWithoutAdminUsersInput, ChannelUncheckedCreateWithoutAdminUsersInput>
  }

  export type UserToChannelwithRoleCreateWithoutUserInput = {
    channel: ChannelCreateNestedOneWithoutUsersToChannelswithRolesInput
    role: RoleEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToChannelwithRoleUncheckedCreateWithoutUserInput = {
    id?: number
    channelId: number
    role: RoleEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToChannelwithRoleCreateOrConnectWithoutUserInput = {
    where: UserToChannelwithRoleWhereUniqueInput
    create: XOR<UserToChannelwithRoleCreateWithoutUserInput, UserToChannelwithRoleUncheckedCreateWithoutUserInput>
  }

  export type UserToChannelwithRoleCreateManyUserInputEnvelope = {
    data: Enumerable<UserToChannelwithRoleCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ChannelCreateWithoutSubscribedUsersInput = {
    name: string
    profileImageUrl?: string | null
    description?: string | null
    adminUsers?: YouTubeUserCreateNestedManyWithoutAdminOfChannelsInput
    usersToChannelswithRoles?: UserToChannelwithRoleCreateNestedManyWithoutChannelInput
    owningVideos?: VideoCreateNestedManyWithoutBelongsToChannelInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChannelUncheckedCreateWithoutSubscribedUsersInput = {
    id?: number
    name: string
    profileImageUrl?: string | null
    description?: string | null
    adminUsers?: YouTubeUserUncheckedCreateNestedManyWithoutAdminOfChannelsInput
    usersToChannelswithRoles?: UserToChannelwithRoleUncheckedCreateNestedManyWithoutChannelInput
    owningVideos?: VideoUncheckedCreateNestedManyWithoutBelongsToChannelInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChannelCreateOrConnectWithoutSubscribedUsersInput = {
    where: ChannelWhereUniqueInput
    create: XOR<ChannelCreateWithoutSubscribedUsersInput, ChannelUncheckedCreateWithoutSubscribedUsersInput>
  }

  export type VideoCreateWithoutReactedByYouTubeUsersInput = {
    title: string
    videoUrl: string
    thumbnailImageUrl?: string | null
    description?: string | null
    belongsToChannel: ChannelCreateNestedOneWithoutOwningVideosInput
    usersToVideosWithReactions?: UserToVideoWithReactionCreateNestedManyWithoutVideoInput
    videoComments?: VideoCommentCreateNestedManyWithoutParentVideoInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoUncheckedCreateWithoutReactedByYouTubeUsersInput = {
    id?: number
    title: string
    videoUrl: string
    thumbnailImageUrl?: string | null
    description?: string | null
    channelId: number
    usersToVideosWithReactions?: UserToVideoWithReactionUncheckedCreateNestedManyWithoutVideoInput
    videoComments?: VideoCommentUncheckedCreateNestedManyWithoutParentVideoInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCreateOrConnectWithoutReactedByYouTubeUsersInput = {
    where: VideoWhereUniqueInput
    create: XOR<VideoCreateWithoutReactedByYouTubeUsersInput, VideoUncheckedCreateWithoutReactedByYouTubeUsersInput>
  }

  export type UserToVideoWithReactionCreateWithoutUserInput = {
    video: VideoCreateNestedOneWithoutUsersToVideosWithReactionsInput
    reaction: ReactionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToVideoWithReactionUncheckedCreateWithoutUserInput = {
    id?: number
    videoId: number
    reaction: ReactionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToVideoWithReactionCreateOrConnectWithoutUserInput = {
    where: UserToVideoWithReactionWhereUniqueInput
    create: XOR<UserToVideoWithReactionCreateWithoutUserInput, UserToVideoWithReactionUncheckedCreateWithoutUserInput>
  }

  export type UserToVideoWithReactionCreateManyUserInputEnvelope = {
    data: Enumerable<UserToVideoWithReactionCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type VideoCommentCreateWithoutCommentingUserInput = {
    commentText: string
    parentVideo: VideoCreateNestedOneWithoutVideoCommentsInput
    parentVideoComment?: VideoCommentCreateNestedOneWithoutChildVideoCommentsInput
    childVideoComments?: VideoCommentCreateNestedManyWithoutParentVideoCommentInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCommentUncheckedCreateWithoutCommentingUserInput = {
    id?: number
    commentText: string
    videoId: number
    parentVideoCommentId?: number | null
    childVideoComments?: VideoCommentUncheckedCreateNestedManyWithoutParentVideoCommentInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCommentCreateOrConnectWithoutCommentingUserInput = {
    where: VideoCommentWhereUniqueInput
    create: XOR<VideoCommentCreateWithoutCommentingUserInput, VideoCommentUncheckedCreateWithoutCommentingUserInput>
  }

  export type VideoCommentCreateManyCommentingUserInputEnvelope = {
    data: Enumerable<VideoCommentCreateManyCommentingUserInput>
    skipDuplicates?: boolean
  }

  export type ChannelUpsertWithWhereUniqueWithoutAdminUsersInput = {
    where: ChannelWhereUniqueInput
    update: XOR<ChannelUpdateWithoutAdminUsersInput, ChannelUncheckedUpdateWithoutAdminUsersInput>
    create: XOR<ChannelCreateWithoutAdminUsersInput, ChannelUncheckedCreateWithoutAdminUsersInput>
  }

  export type ChannelUpdateWithWhereUniqueWithoutAdminUsersInput = {
    where: ChannelWhereUniqueInput
    data: XOR<ChannelUpdateWithoutAdminUsersInput, ChannelUncheckedUpdateWithoutAdminUsersInput>
  }

  export type ChannelUpdateManyWithWhereWithoutAdminUsersInput = {
    where: ChannelScalarWhereInput
    data: XOR<ChannelUpdateManyMutationInput, ChannelUncheckedUpdateManyWithoutAdminOfChannelsInput>
  }

  export type ChannelScalarWhereInput = {
    AND?: Enumerable<ChannelScalarWhereInput>
    OR?: Enumerable<ChannelScalarWhereInput>
    NOT?: Enumerable<ChannelScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    profileImageUrl?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type UserToChannelwithRoleUpsertWithWhereUniqueWithoutUserInput = {
    where: UserToChannelwithRoleWhereUniqueInput
    update: XOR<UserToChannelwithRoleUpdateWithoutUserInput, UserToChannelwithRoleUncheckedUpdateWithoutUserInput>
    create: XOR<UserToChannelwithRoleCreateWithoutUserInput, UserToChannelwithRoleUncheckedCreateWithoutUserInput>
  }

  export type UserToChannelwithRoleUpdateWithWhereUniqueWithoutUserInput = {
    where: UserToChannelwithRoleWhereUniqueInput
    data: XOR<UserToChannelwithRoleUpdateWithoutUserInput, UserToChannelwithRoleUncheckedUpdateWithoutUserInput>
  }

  export type UserToChannelwithRoleUpdateManyWithWhereWithoutUserInput = {
    where: UserToChannelwithRoleScalarWhereInput
    data: XOR<UserToChannelwithRoleUpdateManyMutationInput, UserToChannelwithRoleUncheckedUpdateManyWithoutUsersToChannelswithRolesInput>
  }

  export type UserToChannelwithRoleScalarWhereInput = {
    AND?: Enumerable<UserToChannelwithRoleScalarWhereInput>
    OR?: Enumerable<UserToChannelwithRoleScalarWhereInput>
    NOT?: Enumerable<UserToChannelwithRoleScalarWhereInput>
    id?: IntFilter | number
    youTubeUserId?: IntFilter | number
    channelId?: IntFilter | number
    role?: EnumRoleEnumFilter | RoleEnum
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ChannelUpsertWithWhereUniqueWithoutSubscribedUsersInput = {
    where: ChannelWhereUniqueInput
    update: XOR<ChannelUpdateWithoutSubscribedUsersInput, ChannelUncheckedUpdateWithoutSubscribedUsersInput>
    create: XOR<ChannelCreateWithoutSubscribedUsersInput, ChannelUncheckedCreateWithoutSubscribedUsersInput>
  }

  export type ChannelUpdateWithWhereUniqueWithoutSubscribedUsersInput = {
    where: ChannelWhereUniqueInput
    data: XOR<ChannelUpdateWithoutSubscribedUsersInput, ChannelUncheckedUpdateWithoutSubscribedUsersInput>
  }

  export type ChannelUpdateManyWithWhereWithoutSubscribedUsersInput = {
    where: ChannelScalarWhereInput
    data: XOR<ChannelUpdateManyMutationInput, ChannelUncheckedUpdateManyWithoutSubscribingToChannelsInput>
  }

  export type VideoUpsertWithWhereUniqueWithoutReactedByYouTubeUsersInput = {
    where: VideoWhereUniqueInput
    update: XOR<VideoUpdateWithoutReactedByYouTubeUsersInput, VideoUncheckedUpdateWithoutReactedByYouTubeUsersInput>
    create: XOR<VideoCreateWithoutReactedByYouTubeUsersInput, VideoUncheckedCreateWithoutReactedByYouTubeUsersInput>
  }

  export type VideoUpdateWithWhereUniqueWithoutReactedByYouTubeUsersInput = {
    where: VideoWhereUniqueInput
    data: XOR<VideoUpdateWithoutReactedByYouTubeUsersInput, VideoUncheckedUpdateWithoutReactedByYouTubeUsersInput>
  }

  export type VideoUpdateManyWithWhereWithoutReactedByYouTubeUsersInput = {
    where: VideoScalarWhereInput
    data: XOR<VideoUpdateManyMutationInput, VideoUncheckedUpdateManyWithoutReactedVideosInput>
  }

  export type VideoScalarWhereInput = {
    AND?: Enumerable<VideoScalarWhereInput>
    OR?: Enumerable<VideoScalarWhereInput>
    NOT?: Enumerable<VideoScalarWhereInput>
    id?: IntFilter | number
    title?: StringFilter | string
    videoUrl?: StringFilter | string
    thumbnailImageUrl?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    channelId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type UserToVideoWithReactionUpsertWithWhereUniqueWithoutUserInput = {
    where: UserToVideoWithReactionWhereUniqueInput
    update: XOR<UserToVideoWithReactionUpdateWithoutUserInput, UserToVideoWithReactionUncheckedUpdateWithoutUserInput>
    create: XOR<UserToVideoWithReactionCreateWithoutUserInput, UserToVideoWithReactionUncheckedCreateWithoutUserInput>
  }

  export type UserToVideoWithReactionUpdateWithWhereUniqueWithoutUserInput = {
    where: UserToVideoWithReactionWhereUniqueInput
    data: XOR<UserToVideoWithReactionUpdateWithoutUserInput, UserToVideoWithReactionUncheckedUpdateWithoutUserInput>
  }

  export type UserToVideoWithReactionUpdateManyWithWhereWithoutUserInput = {
    where: UserToVideoWithReactionScalarWhereInput
    data: XOR<UserToVideoWithReactionUpdateManyMutationInput, UserToVideoWithReactionUncheckedUpdateManyWithoutUsersToVideosWithReactionsInput>
  }

  export type UserToVideoWithReactionScalarWhereInput = {
    AND?: Enumerable<UserToVideoWithReactionScalarWhereInput>
    OR?: Enumerable<UserToVideoWithReactionScalarWhereInput>
    NOT?: Enumerable<UserToVideoWithReactionScalarWhereInput>
    id?: IntFilter | number
    youTubeUserId?: IntFilter | number
    videoId?: IntFilter | number
    reaction?: EnumReactionEnumFilter | ReactionEnum
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type VideoCommentUpsertWithWhereUniqueWithoutCommentingUserInput = {
    where: VideoCommentWhereUniqueInput
    update: XOR<VideoCommentUpdateWithoutCommentingUserInput, VideoCommentUncheckedUpdateWithoutCommentingUserInput>
    create: XOR<VideoCommentCreateWithoutCommentingUserInput, VideoCommentUncheckedCreateWithoutCommentingUserInput>
  }

  export type VideoCommentUpdateWithWhereUniqueWithoutCommentingUserInput = {
    where: VideoCommentWhereUniqueInput
    data: XOR<VideoCommentUpdateWithoutCommentingUserInput, VideoCommentUncheckedUpdateWithoutCommentingUserInput>
  }

  export type VideoCommentUpdateManyWithWhereWithoutCommentingUserInput = {
    where: VideoCommentScalarWhereInput
    data: XOR<VideoCommentUpdateManyMutationInput, VideoCommentUncheckedUpdateManyWithoutVideoCommentsInput>
  }

  export type VideoCommentScalarWhereInput = {
    AND?: Enumerable<VideoCommentScalarWhereInput>
    OR?: Enumerable<VideoCommentScalarWhereInput>
    NOT?: Enumerable<VideoCommentScalarWhereInput>
    id?: IntFilter | number
    commentText?: StringFilter | string
    youTubeUserId?: IntFilter | number
    videoId?: IntFilter | number
    parentVideoCommentId?: IntNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type YouTubeUserCreateWithoutAdminOfChannelsInput = {
    name: string
    profileImageUrl?: string | null
    bio?: string | null
    usersToChannelswithRoles?: UserToChannelwithRoleCreateNestedManyWithoutUserInput
    subscribingToChannels?: ChannelCreateNestedManyWithoutSubscribedUsersInput
    reactedVideos?: VideoCreateNestedManyWithoutReactedByYouTubeUsersInput
    usersToVideosWithReactions?: UserToVideoWithReactionCreateNestedManyWithoutUserInput
    videoComments?: VideoCommentCreateNestedManyWithoutCommentingUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YouTubeUserUncheckedCreateWithoutAdminOfChannelsInput = {
    id?: number
    name: string
    profileImageUrl?: string | null
    bio?: string | null
    usersToChannelswithRoles?: UserToChannelwithRoleUncheckedCreateNestedManyWithoutUserInput
    subscribingToChannels?: ChannelUncheckedCreateNestedManyWithoutSubscribedUsersInput
    reactedVideos?: VideoUncheckedCreateNestedManyWithoutReactedByYouTubeUsersInput
    usersToVideosWithReactions?: UserToVideoWithReactionUncheckedCreateNestedManyWithoutUserInput
    videoComments?: VideoCommentUncheckedCreateNestedManyWithoutCommentingUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YouTubeUserCreateOrConnectWithoutAdminOfChannelsInput = {
    where: YouTubeUserWhereUniqueInput
    create: XOR<YouTubeUserCreateWithoutAdminOfChannelsInput, YouTubeUserUncheckedCreateWithoutAdminOfChannelsInput>
  }

  export type YouTubeUserCreateWithoutSubscribingToChannelsInput = {
    name: string
    profileImageUrl?: string | null
    bio?: string | null
    adminOfChannels?: ChannelCreateNestedManyWithoutAdminUsersInput
    usersToChannelswithRoles?: UserToChannelwithRoleCreateNestedManyWithoutUserInput
    reactedVideos?: VideoCreateNestedManyWithoutReactedByYouTubeUsersInput
    usersToVideosWithReactions?: UserToVideoWithReactionCreateNestedManyWithoutUserInput
    videoComments?: VideoCommentCreateNestedManyWithoutCommentingUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YouTubeUserUncheckedCreateWithoutSubscribingToChannelsInput = {
    id?: number
    name: string
    profileImageUrl?: string | null
    bio?: string | null
    adminOfChannels?: ChannelUncheckedCreateNestedManyWithoutAdminUsersInput
    usersToChannelswithRoles?: UserToChannelwithRoleUncheckedCreateNestedManyWithoutUserInput
    reactedVideos?: VideoUncheckedCreateNestedManyWithoutReactedByYouTubeUsersInput
    usersToVideosWithReactions?: UserToVideoWithReactionUncheckedCreateNestedManyWithoutUserInput
    videoComments?: VideoCommentUncheckedCreateNestedManyWithoutCommentingUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YouTubeUserCreateOrConnectWithoutSubscribingToChannelsInput = {
    where: YouTubeUserWhereUniqueInput
    create: XOR<YouTubeUserCreateWithoutSubscribingToChannelsInput, YouTubeUserUncheckedCreateWithoutSubscribingToChannelsInput>
  }

  export type UserToChannelwithRoleCreateWithoutChannelInput = {
    user: YouTubeUserCreateNestedOneWithoutUsersToChannelswithRolesInput
    role: RoleEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToChannelwithRoleUncheckedCreateWithoutChannelInput = {
    id?: number
    youTubeUserId: number
    role: RoleEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToChannelwithRoleCreateOrConnectWithoutChannelInput = {
    where: UserToChannelwithRoleWhereUniqueInput
    create: XOR<UserToChannelwithRoleCreateWithoutChannelInput, UserToChannelwithRoleUncheckedCreateWithoutChannelInput>
  }

  export type UserToChannelwithRoleCreateManyChannelInputEnvelope = {
    data: Enumerable<UserToChannelwithRoleCreateManyChannelInput>
    skipDuplicates?: boolean
  }

  export type VideoCreateWithoutBelongsToChannelInput = {
    title: string
    videoUrl: string
    thumbnailImageUrl?: string | null
    description?: string | null
    reactedByYouTubeUsers?: YouTubeUserCreateNestedManyWithoutReactedVideosInput
    usersToVideosWithReactions?: UserToVideoWithReactionCreateNestedManyWithoutVideoInput
    videoComments?: VideoCommentCreateNestedManyWithoutParentVideoInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoUncheckedCreateWithoutBelongsToChannelInput = {
    id?: number
    title: string
    videoUrl: string
    thumbnailImageUrl?: string | null
    description?: string | null
    reactedByYouTubeUsers?: YouTubeUserUncheckedCreateNestedManyWithoutReactedVideosInput
    usersToVideosWithReactions?: UserToVideoWithReactionUncheckedCreateNestedManyWithoutVideoInput
    videoComments?: VideoCommentUncheckedCreateNestedManyWithoutParentVideoInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCreateOrConnectWithoutBelongsToChannelInput = {
    where: VideoWhereUniqueInput
    create: XOR<VideoCreateWithoutBelongsToChannelInput, VideoUncheckedCreateWithoutBelongsToChannelInput>
  }

  export type VideoCreateManyBelongsToChannelInputEnvelope = {
    data: Enumerable<VideoCreateManyBelongsToChannelInput>
    skipDuplicates?: boolean
  }

  export type YouTubeUserUpsertWithWhereUniqueWithoutAdminOfChannelsInput = {
    where: YouTubeUserWhereUniqueInput
    update: XOR<YouTubeUserUpdateWithoutAdminOfChannelsInput, YouTubeUserUncheckedUpdateWithoutAdminOfChannelsInput>
    create: XOR<YouTubeUserCreateWithoutAdminOfChannelsInput, YouTubeUserUncheckedCreateWithoutAdminOfChannelsInput>
  }

  export type YouTubeUserUpdateWithWhereUniqueWithoutAdminOfChannelsInput = {
    where: YouTubeUserWhereUniqueInput
    data: XOR<YouTubeUserUpdateWithoutAdminOfChannelsInput, YouTubeUserUncheckedUpdateWithoutAdminOfChannelsInput>
  }

  export type YouTubeUserUpdateManyWithWhereWithoutAdminOfChannelsInput = {
    where: YouTubeUserScalarWhereInput
    data: XOR<YouTubeUserUpdateManyMutationInput, YouTubeUserUncheckedUpdateManyWithoutAdminUsersInput>
  }

  export type YouTubeUserScalarWhereInput = {
    AND?: Enumerable<YouTubeUserScalarWhereInput>
    OR?: Enumerable<YouTubeUserScalarWhereInput>
    NOT?: Enumerable<YouTubeUserScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    profileImageUrl?: StringNullableFilter | string | null
    bio?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type YouTubeUserUpsertWithWhereUniqueWithoutSubscribingToChannelsInput = {
    where: YouTubeUserWhereUniqueInput
    update: XOR<YouTubeUserUpdateWithoutSubscribingToChannelsInput, YouTubeUserUncheckedUpdateWithoutSubscribingToChannelsInput>
    create: XOR<YouTubeUserCreateWithoutSubscribingToChannelsInput, YouTubeUserUncheckedCreateWithoutSubscribingToChannelsInput>
  }

  export type YouTubeUserUpdateWithWhereUniqueWithoutSubscribingToChannelsInput = {
    where: YouTubeUserWhereUniqueInput
    data: XOR<YouTubeUserUpdateWithoutSubscribingToChannelsInput, YouTubeUserUncheckedUpdateWithoutSubscribingToChannelsInput>
  }

  export type YouTubeUserUpdateManyWithWhereWithoutSubscribingToChannelsInput = {
    where: YouTubeUserScalarWhereInput
    data: XOR<YouTubeUserUpdateManyMutationInput, YouTubeUserUncheckedUpdateManyWithoutSubscribedUsersInput>
  }

  export type UserToChannelwithRoleUpsertWithWhereUniqueWithoutChannelInput = {
    where: UserToChannelwithRoleWhereUniqueInput
    update: XOR<UserToChannelwithRoleUpdateWithoutChannelInput, UserToChannelwithRoleUncheckedUpdateWithoutChannelInput>
    create: XOR<UserToChannelwithRoleCreateWithoutChannelInput, UserToChannelwithRoleUncheckedCreateWithoutChannelInput>
  }

  export type UserToChannelwithRoleUpdateWithWhereUniqueWithoutChannelInput = {
    where: UserToChannelwithRoleWhereUniqueInput
    data: XOR<UserToChannelwithRoleUpdateWithoutChannelInput, UserToChannelwithRoleUncheckedUpdateWithoutChannelInput>
  }

  export type UserToChannelwithRoleUpdateManyWithWhereWithoutChannelInput = {
    where: UserToChannelwithRoleScalarWhereInput
    data: XOR<UserToChannelwithRoleUpdateManyMutationInput, UserToChannelwithRoleUncheckedUpdateManyWithoutUsersToChannelswithRolesInput>
  }

  export type VideoUpsertWithWhereUniqueWithoutBelongsToChannelInput = {
    where: VideoWhereUniqueInput
    update: XOR<VideoUpdateWithoutBelongsToChannelInput, VideoUncheckedUpdateWithoutBelongsToChannelInput>
    create: XOR<VideoCreateWithoutBelongsToChannelInput, VideoUncheckedCreateWithoutBelongsToChannelInput>
  }

  export type VideoUpdateWithWhereUniqueWithoutBelongsToChannelInput = {
    where: VideoWhereUniqueInput
    data: XOR<VideoUpdateWithoutBelongsToChannelInput, VideoUncheckedUpdateWithoutBelongsToChannelInput>
  }

  export type VideoUpdateManyWithWhereWithoutBelongsToChannelInput = {
    where: VideoScalarWhereInput
    data: XOR<VideoUpdateManyMutationInput, VideoUncheckedUpdateManyWithoutOwningVideosInput>
  }

  export type YouTubeUserCreateWithoutUsersToChannelswithRolesInput = {
    name: string
    profileImageUrl?: string | null
    bio?: string | null
    adminOfChannels?: ChannelCreateNestedManyWithoutAdminUsersInput
    subscribingToChannels?: ChannelCreateNestedManyWithoutSubscribedUsersInput
    reactedVideos?: VideoCreateNestedManyWithoutReactedByYouTubeUsersInput
    usersToVideosWithReactions?: UserToVideoWithReactionCreateNestedManyWithoutUserInput
    videoComments?: VideoCommentCreateNestedManyWithoutCommentingUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YouTubeUserUncheckedCreateWithoutUsersToChannelswithRolesInput = {
    id?: number
    name: string
    profileImageUrl?: string | null
    bio?: string | null
    adminOfChannels?: ChannelUncheckedCreateNestedManyWithoutAdminUsersInput
    subscribingToChannels?: ChannelUncheckedCreateNestedManyWithoutSubscribedUsersInput
    reactedVideos?: VideoUncheckedCreateNestedManyWithoutReactedByYouTubeUsersInput
    usersToVideosWithReactions?: UserToVideoWithReactionUncheckedCreateNestedManyWithoutUserInput
    videoComments?: VideoCommentUncheckedCreateNestedManyWithoutCommentingUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YouTubeUserCreateOrConnectWithoutUsersToChannelswithRolesInput = {
    where: YouTubeUserWhereUniqueInput
    create: XOR<YouTubeUserCreateWithoutUsersToChannelswithRolesInput, YouTubeUserUncheckedCreateWithoutUsersToChannelswithRolesInput>
  }

  export type ChannelCreateWithoutUsersToChannelswithRolesInput = {
    name: string
    profileImageUrl?: string | null
    description?: string | null
    adminUsers?: YouTubeUserCreateNestedManyWithoutAdminOfChannelsInput
    subscribedUsers?: YouTubeUserCreateNestedManyWithoutSubscribingToChannelsInput
    owningVideos?: VideoCreateNestedManyWithoutBelongsToChannelInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChannelUncheckedCreateWithoutUsersToChannelswithRolesInput = {
    id?: number
    name: string
    profileImageUrl?: string | null
    description?: string | null
    adminUsers?: YouTubeUserUncheckedCreateNestedManyWithoutAdminOfChannelsInput
    subscribedUsers?: YouTubeUserUncheckedCreateNestedManyWithoutSubscribingToChannelsInput
    owningVideos?: VideoUncheckedCreateNestedManyWithoutBelongsToChannelInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChannelCreateOrConnectWithoutUsersToChannelswithRolesInput = {
    where: ChannelWhereUniqueInput
    create: XOR<ChannelCreateWithoutUsersToChannelswithRolesInput, ChannelUncheckedCreateWithoutUsersToChannelswithRolesInput>
  }

  export type YouTubeUserUpsertWithoutUsersToChannelswithRolesInput = {
    update: XOR<YouTubeUserUpdateWithoutUsersToChannelswithRolesInput, YouTubeUserUncheckedUpdateWithoutUsersToChannelswithRolesInput>
    create: XOR<YouTubeUserCreateWithoutUsersToChannelswithRolesInput, YouTubeUserUncheckedCreateWithoutUsersToChannelswithRolesInput>
  }

  export type YouTubeUserUpdateWithoutUsersToChannelswithRolesInput = {
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    adminOfChannels?: ChannelUpdateManyWithoutAdminUsersNestedInput
    subscribingToChannels?: ChannelUpdateManyWithoutSubscribedUsersNestedInput
    reactedVideos?: VideoUpdateManyWithoutReactedByYouTubeUsersNestedInput
    usersToVideosWithReactions?: UserToVideoWithReactionUpdateManyWithoutUserNestedInput
    videoComments?: VideoCommentUpdateManyWithoutCommentingUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YouTubeUserUncheckedUpdateWithoutUsersToChannelswithRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    adminOfChannels?: ChannelUncheckedUpdateManyWithoutAdminUsersNestedInput
    subscribingToChannels?: ChannelUncheckedUpdateManyWithoutSubscribedUsersNestedInput
    reactedVideos?: VideoUncheckedUpdateManyWithoutReactedByYouTubeUsersNestedInput
    usersToVideosWithReactions?: UserToVideoWithReactionUncheckedUpdateManyWithoutUserNestedInput
    videoComments?: VideoCommentUncheckedUpdateManyWithoutCommentingUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelUpsertWithoutUsersToChannelswithRolesInput = {
    update: XOR<ChannelUpdateWithoutUsersToChannelswithRolesInput, ChannelUncheckedUpdateWithoutUsersToChannelswithRolesInput>
    create: XOR<ChannelCreateWithoutUsersToChannelswithRolesInput, ChannelUncheckedCreateWithoutUsersToChannelswithRolesInput>
  }

  export type ChannelUpdateWithoutUsersToChannelswithRolesInput = {
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adminUsers?: YouTubeUserUpdateManyWithoutAdminOfChannelsNestedInput
    subscribedUsers?: YouTubeUserUpdateManyWithoutSubscribingToChannelsNestedInput
    owningVideos?: VideoUpdateManyWithoutBelongsToChannelNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelUncheckedUpdateWithoutUsersToChannelswithRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adminUsers?: YouTubeUserUncheckedUpdateManyWithoutAdminOfChannelsNestedInput
    subscribedUsers?: YouTubeUserUncheckedUpdateManyWithoutSubscribingToChannelsNestedInput
    owningVideos?: VideoUncheckedUpdateManyWithoutBelongsToChannelNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelCreateWithoutOwningVideosInput = {
    name: string
    profileImageUrl?: string | null
    description?: string | null
    adminUsers?: YouTubeUserCreateNestedManyWithoutAdminOfChannelsInput
    subscribedUsers?: YouTubeUserCreateNestedManyWithoutSubscribingToChannelsInput
    usersToChannelswithRoles?: UserToChannelwithRoleCreateNestedManyWithoutChannelInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChannelUncheckedCreateWithoutOwningVideosInput = {
    id?: number
    name: string
    profileImageUrl?: string | null
    description?: string | null
    adminUsers?: YouTubeUserUncheckedCreateNestedManyWithoutAdminOfChannelsInput
    subscribedUsers?: YouTubeUserUncheckedCreateNestedManyWithoutSubscribingToChannelsInput
    usersToChannelswithRoles?: UserToChannelwithRoleUncheckedCreateNestedManyWithoutChannelInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChannelCreateOrConnectWithoutOwningVideosInput = {
    where: ChannelWhereUniqueInput
    create: XOR<ChannelCreateWithoutOwningVideosInput, ChannelUncheckedCreateWithoutOwningVideosInput>
  }

  export type YouTubeUserCreateWithoutReactedVideosInput = {
    name: string
    profileImageUrl?: string | null
    bio?: string | null
    adminOfChannels?: ChannelCreateNestedManyWithoutAdminUsersInput
    usersToChannelswithRoles?: UserToChannelwithRoleCreateNestedManyWithoutUserInput
    subscribingToChannels?: ChannelCreateNestedManyWithoutSubscribedUsersInput
    usersToVideosWithReactions?: UserToVideoWithReactionCreateNestedManyWithoutUserInput
    videoComments?: VideoCommentCreateNestedManyWithoutCommentingUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YouTubeUserUncheckedCreateWithoutReactedVideosInput = {
    id?: number
    name: string
    profileImageUrl?: string | null
    bio?: string | null
    adminOfChannels?: ChannelUncheckedCreateNestedManyWithoutAdminUsersInput
    usersToChannelswithRoles?: UserToChannelwithRoleUncheckedCreateNestedManyWithoutUserInput
    subscribingToChannels?: ChannelUncheckedCreateNestedManyWithoutSubscribedUsersInput
    usersToVideosWithReactions?: UserToVideoWithReactionUncheckedCreateNestedManyWithoutUserInput
    videoComments?: VideoCommentUncheckedCreateNestedManyWithoutCommentingUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YouTubeUserCreateOrConnectWithoutReactedVideosInput = {
    where: YouTubeUserWhereUniqueInput
    create: XOR<YouTubeUserCreateWithoutReactedVideosInput, YouTubeUserUncheckedCreateWithoutReactedVideosInput>
  }

  export type UserToVideoWithReactionCreateWithoutVideoInput = {
    user: YouTubeUserCreateNestedOneWithoutUsersToVideosWithReactionsInput
    reaction: ReactionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToVideoWithReactionUncheckedCreateWithoutVideoInput = {
    id?: number
    youTubeUserId: number
    reaction: ReactionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToVideoWithReactionCreateOrConnectWithoutVideoInput = {
    where: UserToVideoWithReactionWhereUniqueInput
    create: XOR<UserToVideoWithReactionCreateWithoutVideoInput, UserToVideoWithReactionUncheckedCreateWithoutVideoInput>
  }

  export type UserToVideoWithReactionCreateManyVideoInputEnvelope = {
    data: Enumerable<UserToVideoWithReactionCreateManyVideoInput>
    skipDuplicates?: boolean
  }

  export type VideoCommentCreateWithoutParentVideoInput = {
    commentText: string
    commentingUser: YouTubeUserCreateNestedOneWithoutVideoCommentsInput
    parentVideoComment?: VideoCommentCreateNestedOneWithoutChildVideoCommentsInput
    childVideoComments?: VideoCommentCreateNestedManyWithoutParentVideoCommentInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCommentUncheckedCreateWithoutParentVideoInput = {
    id?: number
    commentText: string
    youTubeUserId: number
    parentVideoCommentId?: number | null
    childVideoComments?: VideoCommentUncheckedCreateNestedManyWithoutParentVideoCommentInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCommentCreateOrConnectWithoutParentVideoInput = {
    where: VideoCommentWhereUniqueInput
    create: XOR<VideoCommentCreateWithoutParentVideoInput, VideoCommentUncheckedCreateWithoutParentVideoInput>
  }

  export type VideoCommentCreateManyParentVideoInputEnvelope = {
    data: Enumerable<VideoCommentCreateManyParentVideoInput>
    skipDuplicates?: boolean
  }

  export type ChannelUpsertWithoutOwningVideosInput = {
    update: XOR<ChannelUpdateWithoutOwningVideosInput, ChannelUncheckedUpdateWithoutOwningVideosInput>
    create: XOR<ChannelCreateWithoutOwningVideosInput, ChannelUncheckedCreateWithoutOwningVideosInput>
  }

  export type ChannelUpdateWithoutOwningVideosInput = {
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adminUsers?: YouTubeUserUpdateManyWithoutAdminOfChannelsNestedInput
    subscribedUsers?: YouTubeUserUpdateManyWithoutSubscribingToChannelsNestedInput
    usersToChannelswithRoles?: UserToChannelwithRoleUpdateManyWithoutChannelNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelUncheckedUpdateWithoutOwningVideosInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adminUsers?: YouTubeUserUncheckedUpdateManyWithoutAdminOfChannelsNestedInput
    subscribedUsers?: YouTubeUserUncheckedUpdateManyWithoutSubscribingToChannelsNestedInput
    usersToChannelswithRoles?: UserToChannelwithRoleUncheckedUpdateManyWithoutChannelNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YouTubeUserUpsertWithWhereUniqueWithoutReactedVideosInput = {
    where: YouTubeUserWhereUniqueInput
    update: XOR<YouTubeUserUpdateWithoutReactedVideosInput, YouTubeUserUncheckedUpdateWithoutReactedVideosInput>
    create: XOR<YouTubeUserCreateWithoutReactedVideosInput, YouTubeUserUncheckedCreateWithoutReactedVideosInput>
  }

  export type YouTubeUserUpdateWithWhereUniqueWithoutReactedVideosInput = {
    where: YouTubeUserWhereUniqueInput
    data: XOR<YouTubeUserUpdateWithoutReactedVideosInput, YouTubeUserUncheckedUpdateWithoutReactedVideosInput>
  }

  export type YouTubeUserUpdateManyWithWhereWithoutReactedVideosInput = {
    where: YouTubeUserScalarWhereInput
    data: XOR<YouTubeUserUpdateManyMutationInput, YouTubeUserUncheckedUpdateManyWithoutReactedByYouTubeUsersInput>
  }

  export type UserToVideoWithReactionUpsertWithWhereUniqueWithoutVideoInput = {
    where: UserToVideoWithReactionWhereUniqueInput
    update: XOR<UserToVideoWithReactionUpdateWithoutVideoInput, UserToVideoWithReactionUncheckedUpdateWithoutVideoInput>
    create: XOR<UserToVideoWithReactionCreateWithoutVideoInput, UserToVideoWithReactionUncheckedCreateWithoutVideoInput>
  }

  export type UserToVideoWithReactionUpdateWithWhereUniqueWithoutVideoInput = {
    where: UserToVideoWithReactionWhereUniqueInput
    data: XOR<UserToVideoWithReactionUpdateWithoutVideoInput, UserToVideoWithReactionUncheckedUpdateWithoutVideoInput>
  }

  export type UserToVideoWithReactionUpdateManyWithWhereWithoutVideoInput = {
    where: UserToVideoWithReactionScalarWhereInput
    data: XOR<UserToVideoWithReactionUpdateManyMutationInput, UserToVideoWithReactionUncheckedUpdateManyWithoutUsersToVideosWithReactionsInput>
  }

  export type VideoCommentUpsertWithWhereUniqueWithoutParentVideoInput = {
    where: VideoCommentWhereUniqueInput
    update: XOR<VideoCommentUpdateWithoutParentVideoInput, VideoCommentUncheckedUpdateWithoutParentVideoInput>
    create: XOR<VideoCommentCreateWithoutParentVideoInput, VideoCommentUncheckedCreateWithoutParentVideoInput>
  }

  export type VideoCommentUpdateWithWhereUniqueWithoutParentVideoInput = {
    where: VideoCommentWhereUniqueInput
    data: XOR<VideoCommentUpdateWithoutParentVideoInput, VideoCommentUncheckedUpdateWithoutParentVideoInput>
  }

  export type VideoCommentUpdateManyWithWhereWithoutParentVideoInput = {
    where: VideoCommentScalarWhereInput
    data: XOR<VideoCommentUpdateManyMutationInput, VideoCommentUncheckedUpdateManyWithoutVideoCommentsInput>
  }

  export type YouTubeUserCreateWithoutUsersToVideosWithReactionsInput = {
    name: string
    profileImageUrl?: string | null
    bio?: string | null
    adminOfChannels?: ChannelCreateNestedManyWithoutAdminUsersInput
    usersToChannelswithRoles?: UserToChannelwithRoleCreateNestedManyWithoutUserInput
    subscribingToChannels?: ChannelCreateNestedManyWithoutSubscribedUsersInput
    reactedVideos?: VideoCreateNestedManyWithoutReactedByYouTubeUsersInput
    videoComments?: VideoCommentCreateNestedManyWithoutCommentingUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YouTubeUserUncheckedCreateWithoutUsersToVideosWithReactionsInput = {
    id?: number
    name: string
    profileImageUrl?: string | null
    bio?: string | null
    adminOfChannels?: ChannelUncheckedCreateNestedManyWithoutAdminUsersInput
    usersToChannelswithRoles?: UserToChannelwithRoleUncheckedCreateNestedManyWithoutUserInput
    subscribingToChannels?: ChannelUncheckedCreateNestedManyWithoutSubscribedUsersInput
    reactedVideos?: VideoUncheckedCreateNestedManyWithoutReactedByYouTubeUsersInput
    videoComments?: VideoCommentUncheckedCreateNestedManyWithoutCommentingUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YouTubeUserCreateOrConnectWithoutUsersToVideosWithReactionsInput = {
    where: YouTubeUserWhereUniqueInput
    create: XOR<YouTubeUserCreateWithoutUsersToVideosWithReactionsInput, YouTubeUserUncheckedCreateWithoutUsersToVideosWithReactionsInput>
  }

  export type VideoCreateWithoutUsersToVideosWithReactionsInput = {
    title: string
    videoUrl: string
    thumbnailImageUrl?: string | null
    description?: string | null
    belongsToChannel: ChannelCreateNestedOneWithoutOwningVideosInput
    reactedByYouTubeUsers?: YouTubeUserCreateNestedManyWithoutReactedVideosInput
    videoComments?: VideoCommentCreateNestedManyWithoutParentVideoInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoUncheckedCreateWithoutUsersToVideosWithReactionsInput = {
    id?: number
    title: string
    videoUrl: string
    thumbnailImageUrl?: string | null
    description?: string | null
    channelId: number
    reactedByYouTubeUsers?: YouTubeUserUncheckedCreateNestedManyWithoutReactedVideosInput
    videoComments?: VideoCommentUncheckedCreateNestedManyWithoutParentVideoInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCreateOrConnectWithoutUsersToVideosWithReactionsInput = {
    where: VideoWhereUniqueInput
    create: XOR<VideoCreateWithoutUsersToVideosWithReactionsInput, VideoUncheckedCreateWithoutUsersToVideosWithReactionsInput>
  }

  export type YouTubeUserUpsertWithoutUsersToVideosWithReactionsInput = {
    update: XOR<YouTubeUserUpdateWithoutUsersToVideosWithReactionsInput, YouTubeUserUncheckedUpdateWithoutUsersToVideosWithReactionsInput>
    create: XOR<YouTubeUserCreateWithoutUsersToVideosWithReactionsInput, YouTubeUserUncheckedCreateWithoutUsersToVideosWithReactionsInput>
  }

  export type YouTubeUserUpdateWithoutUsersToVideosWithReactionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    adminOfChannels?: ChannelUpdateManyWithoutAdminUsersNestedInput
    usersToChannelswithRoles?: UserToChannelwithRoleUpdateManyWithoutUserNestedInput
    subscribingToChannels?: ChannelUpdateManyWithoutSubscribedUsersNestedInput
    reactedVideos?: VideoUpdateManyWithoutReactedByYouTubeUsersNestedInput
    videoComments?: VideoCommentUpdateManyWithoutCommentingUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YouTubeUserUncheckedUpdateWithoutUsersToVideosWithReactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    adminOfChannels?: ChannelUncheckedUpdateManyWithoutAdminUsersNestedInput
    usersToChannelswithRoles?: UserToChannelwithRoleUncheckedUpdateManyWithoutUserNestedInput
    subscribingToChannels?: ChannelUncheckedUpdateManyWithoutSubscribedUsersNestedInput
    reactedVideos?: VideoUncheckedUpdateManyWithoutReactedByYouTubeUsersNestedInput
    videoComments?: VideoCommentUncheckedUpdateManyWithoutCommentingUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUpsertWithoutUsersToVideosWithReactionsInput = {
    update: XOR<VideoUpdateWithoutUsersToVideosWithReactionsInput, VideoUncheckedUpdateWithoutUsersToVideosWithReactionsInput>
    create: XOR<VideoCreateWithoutUsersToVideosWithReactionsInput, VideoUncheckedCreateWithoutUsersToVideosWithReactionsInput>
  }

  export type VideoUpdateWithoutUsersToVideosWithReactionsInput = {
    title?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    belongsToChannel?: ChannelUpdateOneRequiredWithoutOwningVideosNestedInput
    reactedByYouTubeUsers?: YouTubeUserUpdateManyWithoutReactedVideosNestedInput
    videoComments?: VideoCommentUpdateManyWithoutParentVideoNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUncheckedUpdateWithoutUsersToVideosWithReactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: IntFieldUpdateOperationsInput | number
    reactedByYouTubeUsers?: YouTubeUserUncheckedUpdateManyWithoutReactedVideosNestedInput
    videoComments?: VideoCommentUncheckedUpdateManyWithoutParentVideoNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YouTubeUserCreateWithoutVideoCommentsInput = {
    name: string
    profileImageUrl?: string | null
    bio?: string | null
    adminOfChannels?: ChannelCreateNestedManyWithoutAdminUsersInput
    usersToChannelswithRoles?: UserToChannelwithRoleCreateNestedManyWithoutUserInput
    subscribingToChannels?: ChannelCreateNestedManyWithoutSubscribedUsersInput
    reactedVideos?: VideoCreateNestedManyWithoutReactedByYouTubeUsersInput
    usersToVideosWithReactions?: UserToVideoWithReactionCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YouTubeUserUncheckedCreateWithoutVideoCommentsInput = {
    id?: number
    name: string
    profileImageUrl?: string | null
    bio?: string | null
    adminOfChannels?: ChannelUncheckedCreateNestedManyWithoutAdminUsersInput
    usersToChannelswithRoles?: UserToChannelwithRoleUncheckedCreateNestedManyWithoutUserInput
    subscribingToChannels?: ChannelUncheckedCreateNestedManyWithoutSubscribedUsersInput
    reactedVideos?: VideoUncheckedCreateNestedManyWithoutReactedByYouTubeUsersInput
    usersToVideosWithReactions?: UserToVideoWithReactionUncheckedCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YouTubeUserCreateOrConnectWithoutVideoCommentsInput = {
    where: YouTubeUserWhereUniqueInput
    create: XOR<YouTubeUserCreateWithoutVideoCommentsInput, YouTubeUserUncheckedCreateWithoutVideoCommentsInput>
  }

  export type VideoCreateWithoutVideoCommentsInput = {
    title: string
    videoUrl: string
    thumbnailImageUrl?: string | null
    description?: string | null
    belongsToChannel: ChannelCreateNestedOneWithoutOwningVideosInput
    reactedByYouTubeUsers?: YouTubeUserCreateNestedManyWithoutReactedVideosInput
    usersToVideosWithReactions?: UserToVideoWithReactionCreateNestedManyWithoutVideoInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoUncheckedCreateWithoutVideoCommentsInput = {
    id?: number
    title: string
    videoUrl: string
    thumbnailImageUrl?: string | null
    description?: string | null
    channelId: number
    reactedByYouTubeUsers?: YouTubeUserUncheckedCreateNestedManyWithoutReactedVideosInput
    usersToVideosWithReactions?: UserToVideoWithReactionUncheckedCreateNestedManyWithoutVideoInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCreateOrConnectWithoutVideoCommentsInput = {
    where: VideoWhereUniqueInput
    create: XOR<VideoCreateWithoutVideoCommentsInput, VideoUncheckedCreateWithoutVideoCommentsInput>
  }

  export type VideoCommentCreateWithoutChildVideoCommentsInput = {
    commentText: string
    commentingUser: YouTubeUserCreateNestedOneWithoutVideoCommentsInput
    parentVideo: VideoCreateNestedOneWithoutVideoCommentsInput
    parentVideoComment?: VideoCommentCreateNestedOneWithoutChildVideoCommentsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCommentUncheckedCreateWithoutChildVideoCommentsInput = {
    id?: number
    commentText: string
    youTubeUserId: number
    videoId: number
    parentVideoCommentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCommentCreateOrConnectWithoutChildVideoCommentsInput = {
    where: VideoCommentWhereUniqueInput
    create: XOR<VideoCommentCreateWithoutChildVideoCommentsInput, VideoCommentUncheckedCreateWithoutChildVideoCommentsInput>
  }

  export type VideoCommentCreateWithoutParentVideoCommentInput = {
    commentText: string
    commentingUser: YouTubeUserCreateNestedOneWithoutVideoCommentsInput
    parentVideo: VideoCreateNestedOneWithoutVideoCommentsInput
    childVideoComments?: VideoCommentCreateNestedManyWithoutParentVideoCommentInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCommentUncheckedCreateWithoutParentVideoCommentInput = {
    id?: number
    commentText: string
    youTubeUserId: number
    videoId: number
    childVideoComments?: VideoCommentUncheckedCreateNestedManyWithoutParentVideoCommentInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCommentCreateOrConnectWithoutParentVideoCommentInput = {
    where: VideoCommentWhereUniqueInput
    create: XOR<VideoCommentCreateWithoutParentVideoCommentInput, VideoCommentUncheckedCreateWithoutParentVideoCommentInput>
  }

  export type VideoCommentCreateManyParentVideoCommentInputEnvelope = {
    data: Enumerable<VideoCommentCreateManyParentVideoCommentInput>
    skipDuplicates?: boolean
  }

  export type YouTubeUserUpsertWithoutVideoCommentsInput = {
    update: XOR<YouTubeUserUpdateWithoutVideoCommentsInput, YouTubeUserUncheckedUpdateWithoutVideoCommentsInput>
    create: XOR<YouTubeUserCreateWithoutVideoCommentsInput, YouTubeUserUncheckedCreateWithoutVideoCommentsInput>
  }

  export type YouTubeUserUpdateWithoutVideoCommentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    adminOfChannels?: ChannelUpdateManyWithoutAdminUsersNestedInput
    usersToChannelswithRoles?: UserToChannelwithRoleUpdateManyWithoutUserNestedInput
    subscribingToChannels?: ChannelUpdateManyWithoutSubscribedUsersNestedInput
    reactedVideos?: VideoUpdateManyWithoutReactedByYouTubeUsersNestedInput
    usersToVideosWithReactions?: UserToVideoWithReactionUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YouTubeUserUncheckedUpdateWithoutVideoCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    adminOfChannels?: ChannelUncheckedUpdateManyWithoutAdminUsersNestedInput
    usersToChannelswithRoles?: UserToChannelwithRoleUncheckedUpdateManyWithoutUserNestedInput
    subscribingToChannels?: ChannelUncheckedUpdateManyWithoutSubscribedUsersNestedInput
    reactedVideos?: VideoUncheckedUpdateManyWithoutReactedByYouTubeUsersNestedInput
    usersToVideosWithReactions?: UserToVideoWithReactionUncheckedUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUpsertWithoutVideoCommentsInput = {
    update: XOR<VideoUpdateWithoutVideoCommentsInput, VideoUncheckedUpdateWithoutVideoCommentsInput>
    create: XOR<VideoCreateWithoutVideoCommentsInput, VideoUncheckedCreateWithoutVideoCommentsInput>
  }

  export type VideoUpdateWithoutVideoCommentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    belongsToChannel?: ChannelUpdateOneRequiredWithoutOwningVideosNestedInput
    reactedByYouTubeUsers?: YouTubeUserUpdateManyWithoutReactedVideosNestedInput
    usersToVideosWithReactions?: UserToVideoWithReactionUpdateManyWithoutVideoNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUncheckedUpdateWithoutVideoCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: IntFieldUpdateOperationsInput | number
    reactedByYouTubeUsers?: YouTubeUserUncheckedUpdateManyWithoutReactedVideosNestedInput
    usersToVideosWithReactions?: UserToVideoWithReactionUncheckedUpdateManyWithoutVideoNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCommentUpsertWithoutChildVideoCommentsInput = {
    update: XOR<VideoCommentUpdateWithoutChildVideoCommentsInput, VideoCommentUncheckedUpdateWithoutChildVideoCommentsInput>
    create: XOR<VideoCommentCreateWithoutChildVideoCommentsInput, VideoCommentUncheckedCreateWithoutChildVideoCommentsInput>
  }

  export type VideoCommentUpdateWithoutChildVideoCommentsInput = {
    commentText?: StringFieldUpdateOperationsInput | string
    commentingUser?: YouTubeUserUpdateOneRequiredWithoutVideoCommentsNestedInput
    parentVideo?: VideoUpdateOneRequiredWithoutVideoCommentsNestedInput
    parentVideoComment?: VideoCommentUpdateOneWithoutChildVideoCommentsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCommentUncheckedUpdateWithoutChildVideoCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentText?: StringFieldUpdateOperationsInput | string
    youTubeUserId?: IntFieldUpdateOperationsInput | number
    videoId?: IntFieldUpdateOperationsInput | number
    parentVideoCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCommentUpsertWithWhereUniqueWithoutParentVideoCommentInput = {
    where: VideoCommentWhereUniqueInput
    update: XOR<VideoCommentUpdateWithoutParentVideoCommentInput, VideoCommentUncheckedUpdateWithoutParentVideoCommentInput>
    create: XOR<VideoCommentCreateWithoutParentVideoCommentInput, VideoCommentUncheckedCreateWithoutParentVideoCommentInput>
  }

  export type VideoCommentUpdateWithWhereUniqueWithoutParentVideoCommentInput = {
    where: VideoCommentWhereUniqueInput
    data: XOR<VideoCommentUpdateWithoutParentVideoCommentInput, VideoCommentUncheckedUpdateWithoutParentVideoCommentInput>
  }

  export type VideoCommentUpdateManyWithWhereWithoutParentVideoCommentInput = {
    where: VideoCommentScalarWhereInput
    data: XOR<VideoCommentUpdateManyMutationInput, VideoCommentUncheckedUpdateManyWithoutChildVideoCommentsInput>
  }

  export type MenuCreateManyCategoryInput = {
    id?: number
    name: string
    image: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    orderItems?: OrderItemUpdateManyWithoutMenuNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    orderItems?: OrderItemUncheckedUpdateManyWithoutMenuNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuUncheckedUpdateManyWithoutMenuInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManyMenuInput = {
    id?: number
    orderId?: number | null
    quantity: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemUpdateWithoutMenuInput = {
    order?: OrderUpdateOneWithoutItemsNestedInput
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateWithoutMenuInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManyOrderInput = {
    id?: number
    menuId: number
    quantity: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemUpdateWithoutOrderInput = {
    menu?: MenuUpdateOneRequiredWithoutOrderItemsNestedInput
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateManyWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizCreateManyCategoryInput = {
    id?: number
    questionText: string
    correctChoiceId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizUpdateWithoutCategoryInput = {
    questionText?: StringFieldUpdateOperationsInput | string
    choices?: ChoiceUpdateManyWithoutQuizNestedInput
    correctChoice?: ChoiceUpdateOneRequiredWithoutCorrectQuizzesNestedInput
    rounds?: RoundUpdateManyWithoutQuizzesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionText?: StringFieldUpdateOperationsInput | string
    choices?: ChoiceUncheckedUpdateManyWithoutQuizNestedInput
    correctChoiceId?: IntFieldUpdateOperationsInput | number
    rounds?: RoundUncheckedUpdateManyWithoutQuizzesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizUncheckedUpdateManyWithoutQuizzesInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionText?: StringFieldUpdateOperationsInput | string
    correctChoiceId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizCreateManyCorrectChoiceInput = {
    id?: number
    questionText: string
    quizCategoryId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizUpdateWithoutCorrectChoiceInput = {
    questionText?: StringFieldUpdateOperationsInput | string
    category?: QuizCategoryUpdateOneRequiredWithoutQuizzesNestedInput
    choices?: ChoiceUpdateManyWithoutQuizNestedInput
    rounds?: RoundUpdateManyWithoutQuizzesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizUncheckedUpdateWithoutCorrectChoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionText?: StringFieldUpdateOperationsInput | string
    quizCategoryId?: IntFieldUpdateOperationsInput | number
    choices?: ChoiceUncheckedUpdateManyWithoutQuizNestedInput
    rounds?: RoundUncheckedUpdateManyWithoutQuizzesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizUncheckedUpdateManyWithoutCorrectQuizzesInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionText?: StringFieldUpdateOperationsInput | string
    quizCategoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoundUpdateWithoutSelectedChoicesInput = {
    quizzes?: QuizUpdateManyWithoutRoundsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoundUncheckedUpdateWithoutSelectedChoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizzes?: QuizUncheckedUpdateManyWithoutRoundsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoundUncheckedUpdateManyWithoutRoundsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoiceCreateManyQuizInput = {
    id?: number
    answerText: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChoiceUpdateWithoutQuizInput = {
    answerText?: StringFieldUpdateOperationsInput | string
    correctQuizzes?: QuizUpdateManyWithoutCorrectChoiceNestedInput
    rounds?: RoundUpdateManyWithoutSelectedChoicesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoiceUncheckedUpdateWithoutQuizInput = {
    id?: IntFieldUpdateOperationsInput | number
    answerText?: StringFieldUpdateOperationsInput | string
    correctQuizzes?: QuizUncheckedUpdateManyWithoutCorrectChoiceNestedInput
    rounds?: RoundUncheckedUpdateManyWithoutSelectedChoicesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoiceUncheckedUpdateManyWithoutChoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    answerText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoundUpdateWithoutQuizzesInput = {
    selectedChoices?: ChoiceUpdateManyWithoutRoundsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoundUncheckedUpdateWithoutQuizzesInput = {
    id?: IntFieldUpdateOperationsInput | number
    selectedChoices?: ChoiceUncheckedUpdateManyWithoutRoundsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizUpdateWithoutRoundsInput = {
    questionText?: StringFieldUpdateOperationsInput | string
    category?: QuizCategoryUpdateOneRequiredWithoutQuizzesNestedInput
    choices?: ChoiceUpdateManyWithoutQuizNestedInput
    correctChoice?: ChoiceUpdateOneRequiredWithoutCorrectQuizzesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizUncheckedUpdateWithoutRoundsInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionText?: StringFieldUpdateOperationsInput | string
    quizCategoryId?: IntFieldUpdateOperationsInput | number
    choices?: ChoiceUncheckedUpdateManyWithoutQuizNestedInput
    correctChoiceId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoiceUpdateWithoutRoundsInput = {
    answerText?: StringFieldUpdateOperationsInput | string
    quiz?: QuizUpdateOneWithoutChoicesNestedInput
    correctQuizzes?: QuizUpdateManyWithoutCorrectChoiceNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoiceUncheckedUpdateWithoutRoundsInput = {
    id?: IntFieldUpdateOperationsInput | number
    answerText?: StringFieldUpdateOperationsInput | string
    quizId?: NullableIntFieldUpdateOperationsInput | number | null
    correctQuizzes?: QuizUncheckedUpdateManyWithoutCorrectChoiceNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoiceUncheckedUpdateManyWithoutSelectedChoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    answerText?: StringFieldUpdateOperationsInput | string
    quizId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchCreateManyBranchOwnerInput = {
    id?: number
    name: string
    location: string
    telephoneNo: string
    area: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WMMaintenanceRecordCreateManyMaintainerInput = {
    id?: number
    washingMachineId: number
    maintenanceDateTime: Date | string
    level: number
    details: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsageRecordCreateManyUserInput = {
    id?: number
    dateTime: Date | string
    washingMachineId: number
    wMProgramId: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TopUpRecordCreateManyUserInput = {
    id?: number
    dateTime: Date | string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BranchUpdateWithoutBranchOwnerInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    telephoneNo?: StringFieldUpdateOperationsInput | string
    area?: FloatFieldUpdateOperationsInput | number
    washingMachines?: WashingMachineUpdateManyWithoutLocatedBranchNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchUncheckedUpdateWithoutBranchOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    telephoneNo?: StringFieldUpdateOperationsInput | string
    area?: FloatFieldUpdateOperationsInput | number
    washingMachines?: WashingMachineUncheckedUpdateManyWithoutLocatedBranchNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchUncheckedUpdateManyWithoutOwningBranchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    telephoneNo?: StringFieldUpdateOperationsInput | string
    area?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WMMaintenanceRecordUpdateWithoutMaintainerInput = {
    maintainedWM?: WashingMachineUpdateOneRequiredWithoutWMMaintenanceRecordsNestedInput
    maintenanceDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: IntFieldUpdateOperationsInput | number
    details?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WMMaintenanceRecordUncheckedUpdateWithoutMaintainerInput = {
    id?: IntFieldUpdateOperationsInput | number
    washingMachineId?: IntFieldUpdateOperationsInput | number
    maintenanceDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: IntFieldUpdateOperationsInput | number
    details?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WMMaintenanceRecordUncheckedUpdateManyWithoutWMMaintenanceRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    washingMachineId?: IntFieldUpdateOperationsInput | number
    maintenanceDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: IntFieldUpdateOperationsInput | number
    details?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageRecordUpdateWithoutUserInput = {
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    washingMachine?: WashingMachineUpdateOneRequiredWithoutUsageRecordsNestedInput
    program?: WMProgramUpdateOneRequiredWithoutUsageRecordsNestedInput
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageRecordUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    washingMachineId?: IntFieldUpdateOperationsInput | number
    wMProgramId?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageRecordUncheckedUpdateManyWithoutUsageRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    washingMachineId?: IntFieldUpdateOperationsInput | number
    wMProgramId?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopUpRecordUpdateWithoutUserInput = {
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopUpRecordUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopUpRecordUncheckedUpdateManyWithoutTopUpRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WashingMachineCreateManyLocatedBranchInput = {
    id?: number
    brand: string
    model: string
    type: WMTypeEnum
    capacity: number
    manufacturedYear: Date | string
    warrantyEndDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WashingMachineUpdateWithoutLocatedBranchInput = {
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    type?: EnumWMTypeEnumFieldUpdateOperationsInput | WMTypeEnum
    capacity?: FloatFieldUpdateOperationsInput | number
    manufacturedYear?: DateTimeFieldUpdateOperationsInput | Date | string
    warrantyEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    equippedPrograms?: WMProgramUpdateManyWithoutEquippingWMsNestedInput
    usageRecords?: UsageRecordUpdateManyWithoutWashingMachineNestedInput
    wMMaintenanceRecords?: WMMaintenanceRecordUpdateManyWithoutMaintainedWMNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WashingMachineUncheckedUpdateWithoutLocatedBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    type?: EnumWMTypeEnumFieldUpdateOperationsInput | WMTypeEnum
    capacity?: FloatFieldUpdateOperationsInput | number
    manufacturedYear?: DateTimeFieldUpdateOperationsInput | Date | string
    warrantyEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    equippedPrograms?: WMProgramUncheckedUpdateManyWithoutEquippingWMsNestedInput
    usageRecords?: UsageRecordUncheckedUpdateManyWithoutWashingMachineNestedInput
    wMMaintenanceRecords?: WMMaintenanceRecordUncheckedUpdateManyWithoutMaintainedWMNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WashingMachineUncheckedUpdateManyWithoutWashingMachinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    type?: EnumWMTypeEnumFieldUpdateOperationsInput | WMTypeEnum
    capacity?: FloatFieldUpdateOperationsInput | number
    manufacturedYear?: DateTimeFieldUpdateOperationsInput | Date | string
    warrantyEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageRecordCreateManyWashingMachineInput = {
    id?: number
    dateTime: Date | string
    binWashUserId: number
    wMProgramId: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WMMaintenanceRecordCreateManyMaintainedWMInput = {
    id?: number
    maintenanceDateTime: Date | string
    level: number
    details: string
    binWashUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WMProgramUpdateWithoutEquippingWMsInput = {
    name?: StringFieldUpdateOperationsInput | string
    maxCapacity?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    usageRecords?: UsageRecordUpdateManyWithoutProgramNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WMProgramUncheckedUpdateWithoutEquippingWMsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    maxCapacity?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    usageRecords?: UsageRecordUncheckedUpdateManyWithoutProgramNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WMProgramUncheckedUpdateManyWithoutEquippedProgramsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    maxCapacity?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageRecordUpdateWithoutWashingMachineInput = {
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: BinWashUserUpdateOneRequiredWithoutUsageRecordsNestedInput
    program?: WMProgramUpdateOneRequiredWithoutUsageRecordsNestedInput
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageRecordUncheckedUpdateWithoutWashingMachineInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    binWashUserId?: IntFieldUpdateOperationsInput | number
    wMProgramId?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WMMaintenanceRecordUpdateWithoutMaintainedWMInput = {
    maintenanceDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: IntFieldUpdateOperationsInput | number
    details?: StringFieldUpdateOperationsInput | string
    maintainer?: BinWashUserUpdateOneRequiredWithoutWMMaintenanceRecordsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WMMaintenanceRecordUncheckedUpdateWithoutMaintainedWMInput = {
    id?: IntFieldUpdateOperationsInput | number
    maintenanceDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: IntFieldUpdateOperationsInput | number
    details?: StringFieldUpdateOperationsInput | string
    binWashUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageRecordCreateManyProgramInput = {
    id?: number
    dateTime: Date | string
    binWashUserId: number
    washingMachineId: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WashingMachineUpdateWithoutEquippedProgramsInput = {
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    type?: EnumWMTypeEnumFieldUpdateOperationsInput | WMTypeEnum
    capacity?: FloatFieldUpdateOperationsInput | number
    manufacturedYear?: DateTimeFieldUpdateOperationsInput | Date | string
    warrantyEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    locatedBranch?: BranchUpdateOneRequiredWithoutWashingMachinesNestedInput
    usageRecords?: UsageRecordUpdateManyWithoutWashingMachineNestedInput
    wMMaintenanceRecords?: WMMaintenanceRecordUpdateManyWithoutMaintainedWMNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WashingMachineUncheckedUpdateWithoutEquippedProgramsInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    type?: EnumWMTypeEnumFieldUpdateOperationsInput | WMTypeEnum
    capacity?: FloatFieldUpdateOperationsInput | number
    manufacturedYear?: DateTimeFieldUpdateOperationsInput | Date | string
    warrantyEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: IntFieldUpdateOperationsInput | number
    usageRecords?: UsageRecordUncheckedUpdateManyWithoutWashingMachineNestedInput
    wMMaintenanceRecords?: WMMaintenanceRecordUncheckedUpdateManyWithoutMaintainedWMNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WashingMachineUncheckedUpdateManyWithoutEquippingWMsInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    type?: EnumWMTypeEnumFieldUpdateOperationsInput | WMTypeEnum
    capacity?: FloatFieldUpdateOperationsInput | number
    manufacturedYear?: DateTimeFieldUpdateOperationsInput | Date | string
    warrantyEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageRecordUpdateWithoutProgramInput = {
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: BinWashUserUpdateOneRequiredWithoutUsageRecordsNestedInput
    washingMachine?: WashingMachineUpdateOneRequiredWithoutUsageRecordsNestedInput
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageRecordUncheckedUpdateWithoutProgramInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    binWashUserId?: IntFieldUpdateOperationsInput | number
    washingMachineId?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserRelationCreateManyFollowingUserInput = {
    id?: number
    followedUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserRelationCreateManyFollowedUserInput = {
    id?: number
    followingUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostCreateManyPostingUserInput = {
    id?: number
    postText: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateManyCommentingUserInput = {
    id?: number
    commentText: string
    postId: number
    parentCommentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessengerMessageCreateManyFromUserInput = {
    id?: number
    messengerText: string
    toUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessengerMessageCreateManyToUserInput = {
    id?: number
    messengerText: string
    fromUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserRelationUpdateWithoutFollowingUserInput = {
    followedUser?: FacebookUserUpdateOneRequiredWithoutFollowedUserRelationsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserRelationUncheckedUpdateWithoutFollowingUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    followedUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserRelationUncheckedUpdateManyWithoutFollowingUserRelationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    followedUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserRelationUpdateWithoutFollowedUserInput = {
    followingUser?: FacebookUserUpdateOneRequiredWithoutFollowingUserRelationsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserRelationUncheckedUpdateWithoutFollowedUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    followingUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserRelationUncheckedUpdateManyWithoutFollowedUserRelationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    followingUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUpdateWithoutPostingUserInput = {
    postText?: StringFieldUpdateOperationsInput | string
    comments?: CommentUpdateManyWithoutParentPostNestedInput
    hashTags?: FacebookHashTagUpdateManyWithoutIsInPostsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateWithoutPostingUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    postText?: StringFieldUpdateOperationsInput | string
    comments?: CommentUncheckedUpdateManyWithoutParentPostNestedInput
    hashTags?: FacebookHashTagUncheckedUpdateManyWithoutIsInPostsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateManyWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    postText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutCommentingUserInput = {
    commentText?: StringFieldUpdateOperationsInput | string
    parentPost?: PostUpdateOneRequiredWithoutCommentsNestedInput
    parentComment?: CommentUpdateOneWithoutChildCommentsNestedInput
    childComments?: CommentUpdateManyWithoutParentCommentNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateWithoutCommentingUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentText?: StringFieldUpdateOperationsInput | string
    postId?: IntFieldUpdateOperationsInput | number
    parentCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    childComments?: CommentUncheckedUpdateManyWithoutParentCommentNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentText?: StringFieldUpdateOperationsInput | string
    postId?: IntFieldUpdateOperationsInput | number
    parentCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessengerMessageUpdateWithoutFromUserInput = {
    messengerText?: StringFieldUpdateOperationsInput | string
    toUser?: FacebookUserUpdateOneRequiredWithoutMessengerMessagesToNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessengerMessageUncheckedUpdateWithoutFromUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    messengerText?: StringFieldUpdateOperationsInput | string
    toUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessengerMessageUncheckedUpdateManyWithoutMessengerMessagesFromInput = {
    id?: IntFieldUpdateOperationsInput | number
    messengerText?: StringFieldUpdateOperationsInput | string
    toUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessengerMessageUpdateWithoutToUserInput = {
    messengerText?: StringFieldUpdateOperationsInput | string
    fromUser?: FacebookUserUpdateOneRequiredWithoutMessengerMessagesFromNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessengerMessageUncheckedUpdateWithoutToUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    messengerText?: StringFieldUpdateOperationsInput | string
    fromUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessengerMessageUncheckedUpdateManyWithoutMessengerMessagesToInput = {
    id?: IntFieldUpdateOperationsInput | number
    messengerText?: StringFieldUpdateOperationsInput | string
    fromUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyParentPostInput = {
    id?: number
    commentText: string
    userId: number
    parentCommentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateWithoutParentPostInput = {
    commentText?: StringFieldUpdateOperationsInput | string
    commentingUser?: FacebookUserUpdateOneRequiredWithoutCommentsNestedInput
    parentComment?: CommentUpdateOneWithoutChildCommentsNestedInput
    childComments?: CommentUpdateManyWithoutParentCommentNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateWithoutParentPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentText?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    parentCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    childComments?: CommentUncheckedUpdateManyWithoutParentCommentNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookHashTagUpdateWithoutIsInPostsInput = {
    hashTagText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookHashTagUncheckedUpdateWithoutIsInPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    hashTagText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookHashTagUncheckedUpdateManyWithoutHashTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    hashTagText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyParentCommentInput = {
    id?: number
    commentText: string
    userId: number
    postId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateWithoutParentCommentInput = {
    commentText?: StringFieldUpdateOperationsInput | string
    commentingUser?: FacebookUserUpdateOneRequiredWithoutCommentsNestedInput
    parentPost?: PostUpdateOneRequiredWithoutCommentsNestedInput
    childComments?: CommentUpdateManyWithoutParentCommentNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateWithoutParentCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentText?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    childComments?: CommentUncheckedUpdateManyWithoutParentCommentNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutChildCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentText?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUpdateWithoutHashTagsInput = {
    postText?: StringFieldUpdateOperationsInput | string
    postingUser?: FacebookUserUpdateOneRequiredWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutParentPostNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateWithoutHashTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    postText?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    comments?: CommentUncheckedUpdateManyWithoutParentPostNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateManyWithoutIsInPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    postText?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookTitleUpdateWithoutAuthorsInput = {
    title?: StringFieldUpdateOperationsInput | string
    isbn?: StringFieldUpdateOperationsInput | string
    categories?: BookCategoryUpdateManyWithoutBookTitlesNestedInput
    books?: BookUpdateManyWithoutTitleNestedInput
    requestRecords?: RequestRecordUpdateManyWithoutRequestedBookTitleNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookTitleUncheckedUpdateWithoutAuthorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    isbn?: StringFieldUpdateOperationsInput | string
    categories?: BookCategoryUncheckedUpdateManyWithoutBookTitlesNestedInput
    books?: BookUncheckedUpdateManyWithoutTitleNestedInput
    requestRecords?: RequestRecordUncheckedUpdateManyWithoutRequestedBookTitleNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookTitleUncheckedUpdateManyWithoutBookTitlesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    isbn?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookCreateManyTitleInput = {
    id?: number
    libraryId: number
    isAvailable: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestRecordCreateManyRequestedBookTitleInput = {
    id?: number
    studentId: number
    requestingLibraryId: number
    requestedLibraryId: number
    requestDate: Date | string
    acquiredDate?: Date | string | null
    returnDate?: Date | string | null
    bookId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuthorUpdateWithoutBookTitlesInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthorUncheckedUpdateWithoutBookTitlesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthorUncheckedUpdateManyWithoutAuthorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookCategoryUpdateWithoutBookTitlesInput = {
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookCategoryUncheckedUpdateWithoutBookTitlesInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookCategoryUncheckedUpdateManyWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookUpdateWithoutTitleInput = {
    belongsToLibrary?: LibraryUpdateOneRequiredWithoutBooksNestedInput
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    borrowingRecords?: BorrowingRecordUpdateManyWithoutBorrowedBookNestedInput
    requestRecords?: RequestRecordUpdateManyWithoutAcquiredBookNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookUncheckedUpdateWithoutTitleInput = {
    id?: IntFieldUpdateOperationsInput | number
    libraryId?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    borrowingRecords?: BorrowingRecordUncheckedUpdateManyWithoutBorrowedBookNestedInput
    requestRecords?: RequestRecordUncheckedUpdateManyWithoutAcquiredBookNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookUncheckedUpdateManyWithoutBooksInput = {
    id?: IntFieldUpdateOperationsInput | number
    libraryId?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestRecordUpdateWithoutRequestedBookTitleInput = {
    requestingStudent?: StudentUpdateOneRequiredWithoutRequestRecordsNestedInput
    requestingLibrary?: LibraryUpdateOneRequiredWithoutRequestingRecordsNestedInput
    requestedLibrary?: LibraryUpdateOneRequiredWithoutRequestedRecordsNestedInput
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acquiredBook?: BookUpdateOneWithoutRequestRecordsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestRecordUncheckedUpdateWithoutRequestedBookTitleInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    requestingLibraryId?: IntFieldUpdateOperationsInput | number
    requestedLibraryId?: IntFieldUpdateOperationsInput | number
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestRecordUncheckedUpdateManyWithoutRequestRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    requestingLibraryId?: IntFieldUpdateOperationsInput | number
    requestedLibraryId?: IntFieldUpdateOperationsInput | number
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookTitleUpdateWithoutCategoriesInput = {
    title?: StringFieldUpdateOperationsInput | string
    isbn?: StringFieldUpdateOperationsInput | string
    authors?: AuthorUpdateManyWithoutBookTitlesNestedInput
    books?: BookUpdateManyWithoutTitleNestedInput
    requestRecords?: RequestRecordUpdateManyWithoutRequestedBookTitleNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookTitleUncheckedUpdateWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    isbn?: StringFieldUpdateOperationsInput | string
    authors?: AuthorUncheckedUpdateManyWithoutBookTitlesNestedInput
    books?: BookUncheckedUpdateManyWithoutTitleNestedInput
    requestRecords?: RequestRecordUncheckedUpdateManyWithoutRequestedBookTitleNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BorrowingRecordCreateManyBorrowedBookInput = {
    id?: number
    studentId: number
    startDate: Date | string
    endDate?: Date | string | null
    actualEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestRecordCreateManyAcquiredBookInput = {
    id?: number
    studentId: number
    bookTitleId: number
    requestingLibraryId: number
    requestedLibraryId: number
    requestDate: Date | string
    acquiredDate?: Date | string | null
    returnDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BorrowingRecordUpdateWithoutBorrowedBookInput = {
    borrowingStudent?: StudentUpdateOneRequiredWithoutBorrowingRecordsNestedInput
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BorrowingRecordUncheckedUpdateWithoutBorrowedBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BorrowingRecordUncheckedUpdateManyWithoutBorrowingRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestRecordUpdateWithoutAcquiredBookInput = {
    requestingStudent?: StudentUpdateOneRequiredWithoutRequestRecordsNestedInput
    requestedBookTitle?: BookTitleUpdateOneRequiredWithoutRequestRecordsNestedInput
    requestingLibrary?: LibraryUpdateOneRequiredWithoutRequestingRecordsNestedInput
    requestedLibrary?: LibraryUpdateOneRequiredWithoutRequestedRecordsNestedInput
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestRecordUncheckedUpdateWithoutAcquiredBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    bookTitleId?: IntFieldUpdateOperationsInput | number
    requestingLibraryId?: IntFieldUpdateOperationsInput | number
    requestedLibraryId?: IntFieldUpdateOperationsInput | number
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookCreateManyBelongsToLibraryInput = {
    id?: number
    bookTitleId: number
    isAvailable: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestRecordCreateManyRequestingLibraryInput = {
    id?: number
    studentId: number
    bookTitleId: number
    requestedLibraryId: number
    requestDate: Date | string
    acquiredDate?: Date | string | null
    returnDate?: Date | string | null
    bookId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestRecordCreateManyRequestedLibraryInput = {
    id?: number
    studentId: number
    bookTitleId: number
    requestingLibraryId: number
    requestDate: Date | string
    acquiredDate?: Date | string | null
    returnDate?: Date | string | null
    bookId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookUpdateWithoutBelongsToLibraryInput = {
    title?: BookTitleUpdateOneRequiredWithoutBooksNestedInput
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    borrowingRecords?: BorrowingRecordUpdateManyWithoutBorrowedBookNestedInput
    requestRecords?: RequestRecordUpdateManyWithoutAcquiredBookNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookUncheckedUpdateWithoutBelongsToLibraryInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookTitleId?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    borrowingRecords?: BorrowingRecordUncheckedUpdateManyWithoutBorrowedBookNestedInput
    requestRecords?: RequestRecordUncheckedUpdateManyWithoutAcquiredBookNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestRecordUpdateWithoutRequestingLibraryInput = {
    requestingStudent?: StudentUpdateOneRequiredWithoutRequestRecordsNestedInput
    requestedBookTitle?: BookTitleUpdateOneRequiredWithoutRequestRecordsNestedInput
    requestedLibrary?: LibraryUpdateOneRequiredWithoutRequestedRecordsNestedInput
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acquiredBook?: BookUpdateOneWithoutRequestRecordsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestRecordUncheckedUpdateWithoutRequestingLibraryInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    bookTitleId?: IntFieldUpdateOperationsInput | number
    requestedLibraryId?: IntFieldUpdateOperationsInput | number
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestRecordUncheckedUpdateManyWithoutRequestingRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    bookTitleId?: IntFieldUpdateOperationsInput | number
    requestedLibraryId?: IntFieldUpdateOperationsInput | number
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestRecordUpdateWithoutRequestedLibraryInput = {
    requestingStudent?: StudentUpdateOneRequiredWithoutRequestRecordsNestedInput
    requestedBookTitle?: BookTitleUpdateOneRequiredWithoutRequestRecordsNestedInput
    requestingLibrary?: LibraryUpdateOneRequiredWithoutRequestingRecordsNestedInput
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acquiredBook?: BookUpdateOneWithoutRequestRecordsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestRecordUncheckedUpdateWithoutRequestedLibraryInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    bookTitleId?: IntFieldUpdateOperationsInput | number
    requestingLibraryId?: IntFieldUpdateOperationsInput | number
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestRecordUncheckedUpdateManyWithoutRequestedRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    bookTitleId?: IntFieldUpdateOperationsInput | number
    requestingLibraryId?: IntFieldUpdateOperationsInput | number
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryCreateManyBelongsToUniversityInput = {
    id?: number
    name: string
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentCreateManyBelongsToUniversityInput = {
    id?: number
    Name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryUpdateWithoutBelongsToUniversityInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    books?: BookUpdateManyWithoutBelongsToLibraryNestedInput
    requestingRecords?: RequestRecordUpdateManyWithoutRequestingLibraryNestedInput
    requestedRecords?: RequestRecordUpdateManyWithoutRequestedLibraryNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryUncheckedUpdateWithoutBelongsToUniversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    books?: BookUncheckedUpdateManyWithoutBelongsToLibraryNestedInput
    requestingRecords?: RequestRecordUncheckedUpdateManyWithoutRequestingLibraryNestedInput
    requestedRecords?: RequestRecordUncheckedUpdateManyWithoutRequestedLibraryNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryUncheckedUpdateManyWithoutLibrariesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUpdateWithoutBelongsToUniversityInput = {
    Name?: StringFieldUpdateOperationsInput | string
    borrowingRecords?: BorrowingRecordUpdateManyWithoutBorrowingStudentNestedInput
    requestRecords?: RequestRecordUpdateManyWithoutRequestingStudentNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUncheckedUpdateWithoutBelongsToUniversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    borrowingRecords?: BorrowingRecordUncheckedUpdateManyWithoutBorrowingStudentNestedInput
    requestRecords?: RequestRecordUncheckedUpdateManyWithoutRequestingStudentNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUncheckedUpdateManyWithoutStudentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BorrowingRecordCreateManyBorrowingStudentInput = {
    id?: number
    bookId: number
    startDate: Date | string
    endDate?: Date | string | null
    actualEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestRecordCreateManyRequestingStudentInput = {
    id?: number
    bookTitleId: number
    requestingLibraryId: number
    requestedLibraryId: number
    requestDate: Date | string
    acquiredDate?: Date | string | null
    returnDate?: Date | string | null
    bookId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BorrowingRecordUpdateWithoutBorrowingStudentInput = {
    borrowedBook?: BookUpdateOneRequiredWithoutBorrowingRecordsNestedInput
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BorrowingRecordUncheckedUpdateWithoutBorrowingStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestRecordUpdateWithoutRequestingStudentInput = {
    requestedBookTitle?: BookTitleUpdateOneRequiredWithoutRequestRecordsNestedInput
    requestingLibrary?: LibraryUpdateOneRequiredWithoutRequestingRecordsNestedInput
    requestedLibrary?: LibraryUpdateOneRequiredWithoutRequestedRecordsNestedInput
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acquiredBook?: BookUpdateOneWithoutRequestRecordsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestRecordUncheckedUpdateWithoutRequestingStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookTitleId?: IntFieldUpdateOperationsInput | number
    requestingLibraryId?: IntFieldUpdateOperationsInput | number
    requestedLibraryId?: IntFieldUpdateOperationsInput | number
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRelationCreateManyFollowingUserInput = {
    id?: number
    followedUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserRelationCreateManyFollowedUserInput = {
    id?: number
    followingUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TweetCreateManyTweetingUserInput = {
    id?: number
    tweetText: string
    parentTweetId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DirectMessageCreateManyFromUserInput = {
    id?: number
    dmText: string
    toUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DirectMessageCreateManyToUserInput = {
    id?: number
    dmText: string
    fromUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserRelationUpdateWithoutFollowingUserInput = {
    followedUser?: UserUpdateOneRequiredWithoutFollowedUserRelationsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRelationUncheckedUpdateWithoutFollowingUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    followedUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRelationUncheckedUpdateManyWithoutFollowingUserRelationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    followedUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRelationUpdateWithoutFollowedUserInput = {
    followingUser?: UserUpdateOneRequiredWithoutFollowingUserRelationsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRelationUncheckedUpdateWithoutFollowedUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    followingUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRelationUncheckedUpdateManyWithoutFollowedUserRelationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    followingUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TweetUpdateWithoutTweetingUserInput = {
    tweetText?: StringFieldUpdateOperationsInput | string
    parentTweet?: TweetUpdateOneWithoutChildTweetsNestedInput
    childTweets?: TweetUpdateManyWithoutParentTweetNestedInput
    hashTags?: HashTagUpdateManyWithoutIsInTweetsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TweetUncheckedUpdateWithoutTweetingUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    tweetText?: StringFieldUpdateOperationsInput | string
    parentTweetId?: NullableIntFieldUpdateOperationsInput | number | null
    childTweets?: TweetUncheckedUpdateManyWithoutParentTweetNestedInput
    hashTags?: HashTagUncheckedUpdateManyWithoutIsInTweetsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TweetUncheckedUpdateManyWithoutTweetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tweetText?: StringFieldUpdateOperationsInput | string
    parentTweetId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageUpdateWithoutFromUserInput = {
    dmText?: StringFieldUpdateOperationsInput | string
    toUser?: UserUpdateOneRequiredWithoutDirectMessagesToNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageUncheckedUpdateWithoutFromUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    dmText?: StringFieldUpdateOperationsInput | string
    toUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageUncheckedUpdateManyWithoutDirectMessagesFromInput = {
    id?: IntFieldUpdateOperationsInput | number
    dmText?: StringFieldUpdateOperationsInput | string
    toUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageUpdateWithoutToUserInput = {
    dmText?: StringFieldUpdateOperationsInput | string
    fromUser?: UserUpdateOneRequiredWithoutDirectMessagesFromNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageUncheckedUpdateWithoutToUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    dmText?: StringFieldUpdateOperationsInput | string
    fromUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageUncheckedUpdateManyWithoutDirectMessagesToInput = {
    id?: IntFieldUpdateOperationsInput | number
    dmText?: StringFieldUpdateOperationsInput | string
    fromUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TweetCreateManyParentTweetInput = {
    id?: number
    tweetText: string
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TweetUpdateWithoutParentTweetInput = {
    tweetText?: StringFieldUpdateOperationsInput | string
    tweetingUser?: UserUpdateOneRequiredWithoutTweetsNestedInput
    childTweets?: TweetUpdateManyWithoutParentTweetNestedInput
    hashTags?: HashTagUpdateManyWithoutIsInTweetsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TweetUncheckedUpdateWithoutParentTweetInput = {
    id?: IntFieldUpdateOperationsInput | number
    tweetText?: StringFieldUpdateOperationsInput | string
    childTweets?: TweetUncheckedUpdateManyWithoutParentTweetNestedInput
    userId?: IntFieldUpdateOperationsInput | number
    hashTags?: HashTagUncheckedUpdateManyWithoutIsInTweetsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TweetUncheckedUpdateManyWithoutChildTweetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tweetText?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HashTagUpdateWithoutIsInTweetsInput = {
    hashTagText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HashTagUncheckedUpdateWithoutIsInTweetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    hashTagText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HashTagUncheckedUpdateManyWithoutHashTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    hashTagText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TweetUpdateWithoutHashTagsInput = {
    tweetText?: StringFieldUpdateOperationsInput | string
    tweetingUser?: UserUpdateOneRequiredWithoutTweetsNestedInput
    parentTweet?: TweetUpdateOneWithoutChildTweetsNestedInput
    childTweets?: TweetUpdateManyWithoutParentTweetNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TweetUncheckedUpdateWithoutHashTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tweetText?: StringFieldUpdateOperationsInput | string
    parentTweetId?: NullableIntFieldUpdateOperationsInput | number | null
    childTweets?: TweetUncheckedUpdateManyWithoutParentTweetNestedInput
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TweetUncheckedUpdateManyWithoutIsInTweetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tweetText?: StringFieldUpdateOperationsInput | string
    parentTweetId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToChannelwithRoleCreateManyUserInput = {
    id?: number
    channelId: number
    role: RoleEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToVideoWithReactionCreateManyUserInput = {
    id?: number
    videoId: number
    reaction: ReactionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCommentCreateManyCommentingUserInput = {
    id?: number
    commentText: string
    videoId: number
    parentVideoCommentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChannelUpdateWithoutAdminUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subscribedUsers?: YouTubeUserUpdateManyWithoutSubscribingToChannelsNestedInput
    usersToChannelswithRoles?: UserToChannelwithRoleUpdateManyWithoutChannelNestedInput
    owningVideos?: VideoUpdateManyWithoutBelongsToChannelNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelUncheckedUpdateWithoutAdminUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subscribedUsers?: YouTubeUserUncheckedUpdateManyWithoutSubscribingToChannelsNestedInput
    usersToChannelswithRoles?: UserToChannelwithRoleUncheckedUpdateManyWithoutChannelNestedInput
    owningVideos?: VideoUncheckedUpdateManyWithoutBelongsToChannelNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelUncheckedUpdateManyWithoutAdminOfChannelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToChannelwithRoleUpdateWithoutUserInput = {
    channel?: ChannelUpdateOneRequiredWithoutUsersToChannelswithRolesNestedInput
    role?: EnumRoleEnumFieldUpdateOperationsInput | RoleEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToChannelwithRoleUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    channelId?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleEnumFieldUpdateOperationsInput | RoleEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToChannelwithRoleUncheckedUpdateManyWithoutUsersToChannelswithRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    channelId?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleEnumFieldUpdateOperationsInput | RoleEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelUpdateWithoutSubscribedUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adminUsers?: YouTubeUserUpdateManyWithoutAdminOfChannelsNestedInput
    usersToChannelswithRoles?: UserToChannelwithRoleUpdateManyWithoutChannelNestedInput
    owningVideos?: VideoUpdateManyWithoutBelongsToChannelNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelUncheckedUpdateWithoutSubscribedUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adminUsers?: YouTubeUserUncheckedUpdateManyWithoutAdminOfChannelsNestedInput
    usersToChannelswithRoles?: UserToChannelwithRoleUncheckedUpdateManyWithoutChannelNestedInput
    owningVideos?: VideoUncheckedUpdateManyWithoutBelongsToChannelNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelUncheckedUpdateManyWithoutSubscribingToChannelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUpdateWithoutReactedByYouTubeUsersInput = {
    title?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    belongsToChannel?: ChannelUpdateOneRequiredWithoutOwningVideosNestedInput
    usersToVideosWithReactions?: UserToVideoWithReactionUpdateManyWithoutVideoNestedInput
    videoComments?: VideoCommentUpdateManyWithoutParentVideoNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUncheckedUpdateWithoutReactedByYouTubeUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: IntFieldUpdateOperationsInput | number
    usersToVideosWithReactions?: UserToVideoWithReactionUncheckedUpdateManyWithoutVideoNestedInput
    videoComments?: VideoCommentUncheckedUpdateManyWithoutParentVideoNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUncheckedUpdateManyWithoutReactedVideosInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToVideoWithReactionUpdateWithoutUserInput = {
    video?: VideoUpdateOneRequiredWithoutUsersToVideosWithReactionsNestedInput
    reaction?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToVideoWithReactionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    videoId?: IntFieldUpdateOperationsInput | number
    reaction?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToVideoWithReactionUncheckedUpdateManyWithoutUsersToVideosWithReactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    videoId?: IntFieldUpdateOperationsInput | number
    reaction?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCommentUpdateWithoutCommentingUserInput = {
    commentText?: StringFieldUpdateOperationsInput | string
    parentVideo?: VideoUpdateOneRequiredWithoutVideoCommentsNestedInput
    parentVideoComment?: VideoCommentUpdateOneWithoutChildVideoCommentsNestedInput
    childVideoComments?: VideoCommentUpdateManyWithoutParentVideoCommentNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCommentUncheckedUpdateWithoutCommentingUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentText?: StringFieldUpdateOperationsInput | string
    videoId?: IntFieldUpdateOperationsInput | number
    parentVideoCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    childVideoComments?: VideoCommentUncheckedUpdateManyWithoutParentVideoCommentNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCommentUncheckedUpdateManyWithoutVideoCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentText?: StringFieldUpdateOperationsInput | string
    videoId?: IntFieldUpdateOperationsInput | number
    parentVideoCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToChannelwithRoleCreateManyChannelInput = {
    id?: number
    youTubeUserId: number
    role: RoleEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCreateManyBelongsToChannelInput = {
    id?: number
    title: string
    videoUrl: string
    thumbnailImageUrl?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YouTubeUserUpdateWithoutAdminOfChannelsInput = {
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    usersToChannelswithRoles?: UserToChannelwithRoleUpdateManyWithoutUserNestedInput
    subscribingToChannels?: ChannelUpdateManyWithoutSubscribedUsersNestedInput
    reactedVideos?: VideoUpdateManyWithoutReactedByYouTubeUsersNestedInput
    usersToVideosWithReactions?: UserToVideoWithReactionUpdateManyWithoutUserNestedInput
    videoComments?: VideoCommentUpdateManyWithoutCommentingUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YouTubeUserUncheckedUpdateWithoutAdminOfChannelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    usersToChannelswithRoles?: UserToChannelwithRoleUncheckedUpdateManyWithoutUserNestedInput
    subscribingToChannels?: ChannelUncheckedUpdateManyWithoutSubscribedUsersNestedInput
    reactedVideos?: VideoUncheckedUpdateManyWithoutReactedByYouTubeUsersNestedInput
    usersToVideosWithReactions?: UserToVideoWithReactionUncheckedUpdateManyWithoutUserNestedInput
    videoComments?: VideoCommentUncheckedUpdateManyWithoutCommentingUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YouTubeUserUncheckedUpdateManyWithoutAdminUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YouTubeUserUpdateWithoutSubscribingToChannelsInput = {
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    adminOfChannels?: ChannelUpdateManyWithoutAdminUsersNestedInput
    usersToChannelswithRoles?: UserToChannelwithRoleUpdateManyWithoutUserNestedInput
    reactedVideos?: VideoUpdateManyWithoutReactedByYouTubeUsersNestedInput
    usersToVideosWithReactions?: UserToVideoWithReactionUpdateManyWithoutUserNestedInput
    videoComments?: VideoCommentUpdateManyWithoutCommentingUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YouTubeUserUncheckedUpdateWithoutSubscribingToChannelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    adminOfChannels?: ChannelUncheckedUpdateManyWithoutAdminUsersNestedInput
    usersToChannelswithRoles?: UserToChannelwithRoleUncheckedUpdateManyWithoutUserNestedInput
    reactedVideos?: VideoUncheckedUpdateManyWithoutReactedByYouTubeUsersNestedInput
    usersToVideosWithReactions?: UserToVideoWithReactionUncheckedUpdateManyWithoutUserNestedInput
    videoComments?: VideoCommentUncheckedUpdateManyWithoutCommentingUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YouTubeUserUncheckedUpdateManyWithoutSubscribedUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToChannelwithRoleUpdateWithoutChannelInput = {
    user?: YouTubeUserUpdateOneRequiredWithoutUsersToChannelswithRolesNestedInput
    role?: EnumRoleEnumFieldUpdateOperationsInput | RoleEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToChannelwithRoleUncheckedUpdateWithoutChannelInput = {
    id?: IntFieldUpdateOperationsInput | number
    youTubeUserId?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleEnumFieldUpdateOperationsInput | RoleEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUpdateWithoutBelongsToChannelInput = {
    title?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reactedByYouTubeUsers?: YouTubeUserUpdateManyWithoutReactedVideosNestedInput
    usersToVideosWithReactions?: UserToVideoWithReactionUpdateManyWithoutVideoNestedInput
    videoComments?: VideoCommentUpdateManyWithoutParentVideoNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUncheckedUpdateWithoutBelongsToChannelInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reactedByYouTubeUsers?: YouTubeUserUncheckedUpdateManyWithoutReactedVideosNestedInput
    usersToVideosWithReactions?: UserToVideoWithReactionUncheckedUpdateManyWithoutVideoNestedInput
    videoComments?: VideoCommentUncheckedUpdateManyWithoutParentVideoNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUncheckedUpdateManyWithoutOwningVideosInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToVideoWithReactionCreateManyVideoInput = {
    id?: number
    youTubeUserId: number
    reaction: ReactionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCommentCreateManyParentVideoInput = {
    id?: number
    commentText: string
    youTubeUserId: number
    parentVideoCommentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YouTubeUserUpdateWithoutReactedVideosInput = {
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    adminOfChannels?: ChannelUpdateManyWithoutAdminUsersNestedInput
    usersToChannelswithRoles?: UserToChannelwithRoleUpdateManyWithoutUserNestedInput
    subscribingToChannels?: ChannelUpdateManyWithoutSubscribedUsersNestedInput
    usersToVideosWithReactions?: UserToVideoWithReactionUpdateManyWithoutUserNestedInput
    videoComments?: VideoCommentUpdateManyWithoutCommentingUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YouTubeUserUncheckedUpdateWithoutReactedVideosInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    adminOfChannels?: ChannelUncheckedUpdateManyWithoutAdminUsersNestedInput
    usersToChannelswithRoles?: UserToChannelwithRoleUncheckedUpdateManyWithoutUserNestedInput
    subscribingToChannels?: ChannelUncheckedUpdateManyWithoutSubscribedUsersNestedInput
    usersToVideosWithReactions?: UserToVideoWithReactionUncheckedUpdateManyWithoutUserNestedInput
    videoComments?: VideoCommentUncheckedUpdateManyWithoutCommentingUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YouTubeUserUncheckedUpdateManyWithoutReactedByYouTubeUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToVideoWithReactionUpdateWithoutVideoInput = {
    user?: YouTubeUserUpdateOneRequiredWithoutUsersToVideosWithReactionsNestedInput
    reaction?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToVideoWithReactionUncheckedUpdateWithoutVideoInput = {
    id?: IntFieldUpdateOperationsInput | number
    youTubeUserId?: IntFieldUpdateOperationsInput | number
    reaction?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCommentUpdateWithoutParentVideoInput = {
    commentText?: StringFieldUpdateOperationsInput | string
    commentingUser?: YouTubeUserUpdateOneRequiredWithoutVideoCommentsNestedInput
    parentVideoComment?: VideoCommentUpdateOneWithoutChildVideoCommentsNestedInput
    childVideoComments?: VideoCommentUpdateManyWithoutParentVideoCommentNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCommentUncheckedUpdateWithoutParentVideoInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentText?: StringFieldUpdateOperationsInput | string
    youTubeUserId?: IntFieldUpdateOperationsInput | number
    parentVideoCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    childVideoComments?: VideoCommentUncheckedUpdateManyWithoutParentVideoCommentNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCommentCreateManyParentVideoCommentInput = {
    id?: number
    commentText: string
    youTubeUserId: number
    videoId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoCommentUpdateWithoutParentVideoCommentInput = {
    commentText?: StringFieldUpdateOperationsInput | string
    commentingUser?: YouTubeUserUpdateOneRequiredWithoutVideoCommentsNestedInput
    parentVideo?: VideoUpdateOneRequiredWithoutVideoCommentsNestedInput
    childVideoComments?: VideoCommentUpdateManyWithoutParentVideoCommentNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCommentUncheckedUpdateWithoutParentVideoCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentText?: StringFieldUpdateOperationsInput | string
    youTubeUserId?: IntFieldUpdateOperationsInput | number
    videoId?: IntFieldUpdateOperationsInput | number
    childVideoComments?: VideoCommentUncheckedUpdateManyWithoutParentVideoCommentNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCommentUncheckedUpdateManyWithoutChildVideoCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentText?: StringFieldUpdateOperationsInput | string
    youTubeUserId?: IntFieldUpdateOperationsInput | number
    videoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}