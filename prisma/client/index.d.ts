
/**
 * Client
**/

import * as runtime from './runtime/library';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model BinKitchenCategory
 * 
 */
export type BinKitchenCategory = {
  id: number
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model BinKitchenMenu
 * 
 */
export type BinKitchenMenu = {
  id: number
  name: string
  image: string
  price: number
  categoryName: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model BinKitchenOrder
 * 
 */
export type BinKitchenOrder = {
  id: number
  tableId: number
  status: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model BinKitchenOrderItem
 * 
 */
export type BinKitchenOrderItem = {
  id: number
  quantity: number
  totalPrice: number
  createdAt: Date
  updatedAt: Date
  menuId: number
  orderId: number
}

/**
 * Model LaundryBranch
 * 
 */
export type LaundryBranch = {
  id: number
  name: string
  machineAmount: number
  owner: string
  tel: number
  location: string
  areaSize: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model LaundryWashingMachine
 * 
 */
export type LaundryWashingMachine = {
  id: number
  brand: string
  variant: string
  size: number
  machineType: string
  yearManufactured: number
  insuranceExpiryYear: number
  createdAt: Date
  updatedAt: Date
  laundryBranchId: number
}

/**
 * Model LaundryProgram
 * 
 */
export type LaundryProgram = {
  id: number
  name: string
  price: number
  duration: number
  weight: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model LaundryWashingMachineToProgram
 * 
 */
export type LaundryWashingMachineToProgram = {
  id: number
  createdAt: Date
  updatedAt: Date
  laundryWashingMachineId: number
  laundryProgramId: number
}

/**
 * Model LaundryMaintainance
 * 
 */
export type LaundryMaintainance = {
  id: number
  round: number
  date: number
  damageLevel: number
  description: string
  technicianName: string
  createdAt: Date
  updatedAt: Date
  laundryWashingMachineId: number
}

/**
 * Model LaundryUser
 * 
 */
export type LaundryUser = {
  id: number
  name: string
  tel: number
  balance: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model LaundryUserHistory
 * 
 */
export type LaundryUserHistory = {
  id: number
  washNumber: number
  date: number
  duration: number
  price: number
  createdAt: Date
  updatedAt: Date
  laundryUserId: number
  laundryWashingMachineId: number
  laundryProgramId: number
}

/**
 * Model LaundryBalanceTopup
 * 
 */
export type LaundryBalanceTopup = {
  id: number
  topUpRound: number
  topUpAmount: number
  createdAt: Date
  updatedAt: Date
  laundryUserId: number
}

/**
 * Model LibraryBookCategory
 * 
 */
export type LibraryBookCategory = {
  id: number
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model LibraryBook
 * 
 */
export type LibraryBook = {
  id: number
  name: string
  ISBN: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model LibraryCategoryToBook
 * 
 */
export type LibraryCategoryToBook = {
  id: number
  createdAt: Date
  updatedAt: Date
  libraryBookCategoryId: number
  libraryBookId: number
}

/**
 * Model LibraryBookAuthor
 * 
 */
export type LibraryBookAuthor = {
  id: number
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model LibraryBookToAuthor
 * 
 */
export type LibraryBookToAuthor = {
  id: number
  createdAt: Date
  updatedAt: Date
  libraryBookId: number
  libraryBookAuthorId: number
}

/**
 * Model LibraryUniversity
 * 
 */
export type LibraryUniversity = {
  id: number
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model LibraryStudent
 * 
 */
export type LibraryStudent = {
  id: number
  studentId: number
  name: string
  createdAt: Date
  updatedAt: Date
  libraryUniversityId: number
}

/**
 * Model LibraryBookCopy
 * 
 */
export type LibraryBookCopy = {
  id: number
  status: string
  createdAt: Date
  updatedAt: Date
  libraryBookId: number
  libraryUniversityId: number
  libraryStudentId: number
}

/**
 * Model LibraryBorrowingHistory
 * 
 */
export type LibraryBorrowingHistory = {
  id: number
  borrowDate: number
  returnDate: number
  actualReturnDate: number
  createdAt: Date
  updatedAt: Date
  libraryStudentId: number
  libraryBookCopyId: number
  libraryUniversityId: number
}

/**
 * Model LibraryRequest
 * 
 */
export type LibraryRequest = {
  id: number
  createdAt: Date
  updatedAt: Date
  libraryStudentId: number
  libraryBookCopyId: number
  fromLibraryUniversityId: number
  toLibraryUniversityId: number
}

/**
 * Model QuizCategory
 * 
 */
export type QuizCategory = {
  id: number
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model QuizQuestion
 * 
 */
export type QuizQuestion = {
  id: number
  name: string
  answerId: number
  quizCategoryId: number | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model QuizChoice
 * 
 */
export type QuizChoice = {
  id: number
  name: string
  quizQuestionId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model QuizRound
 * 
 */
export type QuizRound = {
  id: number
  name: string
  totalScore: string
  quizCategoryId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model QuizRecord
 * 
 */
export type QuizRecord = {
  id: number
  quizRoundId: number
  quizChoiceId: number
  quizQuestionId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model TodoList
 * 
 */
export type TodoList = {
  id: number
  task: string
  note: string | null
  status: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model TwitterUser
 * 
 */
export type TwitterUser = {
  id: number
  name: string
  image: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model TwitterPost
 * 
 */
export type TwitterPost = {
  id: number
  post: string
  createdAt: Date
  updatedAt: Date
  twitterUserId: number
}

/**
 * Model TwitterHashtag
 * 
 */
export type TwitterHashtag = {
  id: number
  hashtag: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model TwitterPostToHashtag
 * 
 */
export type TwitterPostToHashtag = {
  id: number
  createdAt: Date
  updatedAt: Date
  twitterPostId: number
  twitterHashtagId: number
}

/**
 * Model TwitterDirectMessage
 * 
 */
export type TwitterDirectMessage = {
  id: number
  message: string
  createdAt: Date
  updatedAt: Date
  followingUserId: number
  followerUserId: number
}

/**
 * Model TwitterUserRelation
 * 
 */
export type TwitterUserRelation = {
  id: number
  createdAt: Date
  updatedAt: Date
  fromUserId: number
  toUserId: number
}

/**
 * Model TwitterComment
 * 
 */
export type TwitterComment = {
  id: number
  createdAt: Date
  updatedAt: Date
  twitterPostId: number
  twitterUserId: number
}

/**
 * Model YoutubeUser
 * 
 */
export type YoutubeUser = {
  id: number
  name: string
  email: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model YoutubeChannel
 * 
 */
export type YoutubeChannel = {
  id: number
  name: string
  description: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model YoutubeSubscription
 * 
 */
export type YoutubeSubscription = {
  id: number
  membership: boolean
  createdAt: Date
  updatedAt: Date
  youtubeUserId: number
  youtubeChannelId: number
}

/**
 * Model YoutubeUserToChannel
 * 
 */
export type YoutubeUserToChannel = {
  id: number
  description: string
  role: RoleEnum
  createdAt: Date
  updatedAt: Date
  youtubeUserId: number
  youtubeChannelId: number
}

/**
 * Model YoutubeVideo
 * 
 */
export type YoutubeVideo = {
  id: number
  name: string
  videoUrl: string
  description: string
  createdAt: Date
  updatedAt: Date
  youtubeChannelId: number
}

/**
 * Model YoutubeReaction
 * 
 */
export type YoutubeReaction = {
  id: number
  reaction: ReactionEnum
  createdAt: Date
  updatedAt: Date
  youtubeUserId: number
  youtubeChannelId: number
  youtubeVideoId: number
  youtubeCommentId: number
}

/**
 * Model YoutubeComment
 * 
 */
export type YoutubeComment = {
  id: number
  comment: string
  createdAt: Date
  updatedAt: Date
  youtubeVideoId: number
  youtubeUserId: number
}

/**
 * Model YoutubeCommentReaction
 * 
 */
export type YoutubeCommentReaction = {
  id: number
  reaction: ReactionEnum
  createdAt: Date
  updatedAt: Date
  youtubeUserId: number
  youtubeChannelId: number
  youtubeVideoId: number
  youtubeCommentId: number
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const ReactionEnum: {
  LIKE: 'LIKE',
  DISLIKE: 'DISLIKE'
};

export type ReactionEnum = (typeof ReactionEnum)[keyof typeof ReactionEnum]


export const RoleEnum: {
  ADMIN: 'ADMIN',
  EDITOR: 'EDITOR',
  CREATOR: 'CREATOR'
};

export type RoleEnum = (typeof RoleEnum)[keyof typeof RoleEnum]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more BinKitchenCategories
 * const binKitchenCategories = await prisma.binKitchenCategory.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more BinKitchenCategories
   * const binKitchenCategories = await prisma.binKitchenCategory.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.binKitchenCategory`: Exposes CRUD operations for the **BinKitchenCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BinKitchenCategories
    * const binKitchenCategories = await prisma.binKitchenCategory.findMany()
    * ```
    */
  get binKitchenCategory(): Prisma.BinKitchenCategoryDelegate<GlobalReject>;

  /**
   * `prisma.binKitchenMenu`: Exposes CRUD operations for the **BinKitchenMenu** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BinKitchenMenus
    * const binKitchenMenus = await prisma.binKitchenMenu.findMany()
    * ```
    */
  get binKitchenMenu(): Prisma.BinKitchenMenuDelegate<GlobalReject>;

  /**
   * `prisma.binKitchenOrder`: Exposes CRUD operations for the **BinKitchenOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BinKitchenOrders
    * const binKitchenOrders = await prisma.binKitchenOrder.findMany()
    * ```
    */
  get binKitchenOrder(): Prisma.BinKitchenOrderDelegate<GlobalReject>;

  /**
   * `prisma.binKitchenOrderItem`: Exposes CRUD operations for the **BinKitchenOrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BinKitchenOrderItems
    * const binKitchenOrderItems = await prisma.binKitchenOrderItem.findMany()
    * ```
    */
  get binKitchenOrderItem(): Prisma.BinKitchenOrderItemDelegate<GlobalReject>;

  /**
   * `prisma.laundryBranch`: Exposes CRUD operations for the **LaundryBranch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LaundryBranches
    * const laundryBranches = await prisma.laundryBranch.findMany()
    * ```
    */
  get laundryBranch(): Prisma.LaundryBranchDelegate<GlobalReject>;

  /**
   * `prisma.laundryWashingMachine`: Exposes CRUD operations for the **LaundryWashingMachine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LaundryWashingMachines
    * const laundryWashingMachines = await prisma.laundryWashingMachine.findMany()
    * ```
    */
  get laundryWashingMachine(): Prisma.LaundryWashingMachineDelegate<GlobalReject>;

  /**
   * `prisma.laundryProgram`: Exposes CRUD operations for the **LaundryProgram** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LaundryPrograms
    * const laundryPrograms = await prisma.laundryProgram.findMany()
    * ```
    */
  get laundryProgram(): Prisma.LaundryProgramDelegate<GlobalReject>;

  /**
   * `prisma.laundryWashingMachineToProgram`: Exposes CRUD operations for the **LaundryWashingMachineToProgram** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LaundryWashingMachineToPrograms
    * const laundryWashingMachineToPrograms = await prisma.laundryWashingMachineToProgram.findMany()
    * ```
    */
  get laundryWashingMachineToProgram(): Prisma.LaundryWashingMachineToProgramDelegate<GlobalReject>;

  /**
   * `prisma.laundryMaintainance`: Exposes CRUD operations for the **LaundryMaintainance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LaundryMaintainances
    * const laundryMaintainances = await prisma.laundryMaintainance.findMany()
    * ```
    */
  get laundryMaintainance(): Prisma.LaundryMaintainanceDelegate<GlobalReject>;

  /**
   * `prisma.laundryUser`: Exposes CRUD operations for the **LaundryUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LaundryUsers
    * const laundryUsers = await prisma.laundryUser.findMany()
    * ```
    */
  get laundryUser(): Prisma.LaundryUserDelegate<GlobalReject>;

  /**
   * `prisma.laundryUserHistory`: Exposes CRUD operations for the **LaundryUserHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LaundryUserHistories
    * const laundryUserHistories = await prisma.laundryUserHistory.findMany()
    * ```
    */
  get laundryUserHistory(): Prisma.LaundryUserHistoryDelegate<GlobalReject>;

  /**
   * `prisma.laundryBalanceTopup`: Exposes CRUD operations for the **LaundryBalanceTopup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LaundryBalanceTopups
    * const laundryBalanceTopups = await prisma.laundryBalanceTopup.findMany()
    * ```
    */
  get laundryBalanceTopup(): Prisma.LaundryBalanceTopupDelegate<GlobalReject>;

  /**
   * `prisma.libraryBookCategory`: Exposes CRUD operations for the **LibraryBookCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LibraryBookCategories
    * const libraryBookCategories = await prisma.libraryBookCategory.findMany()
    * ```
    */
  get libraryBookCategory(): Prisma.LibraryBookCategoryDelegate<GlobalReject>;

  /**
   * `prisma.libraryBook`: Exposes CRUD operations for the **LibraryBook** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LibraryBooks
    * const libraryBooks = await prisma.libraryBook.findMany()
    * ```
    */
  get libraryBook(): Prisma.LibraryBookDelegate<GlobalReject>;

  /**
   * `prisma.libraryCategoryToBook`: Exposes CRUD operations for the **LibraryCategoryToBook** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LibraryCategoryToBooks
    * const libraryCategoryToBooks = await prisma.libraryCategoryToBook.findMany()
    * ```
    */
  get libraryCategoryToBook(): Prisma.LibraryCategoryToBookDelegate<GlobalReject>;

  /**
   * `prisma.libraryBookAuthor`: Exposes CRUD operations for the **LibraryBookAuthor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LibraryBookAuthors
    * const libraryBookAuthors = await prisma.libraryBookAuthor.findMany()
    * ```
    */
  get libraryBookAuthor(): Prisma.LibraryBookAuthorDelegate<GlobalReject>;

  /**
   * `prisma.libraryBookToAuthor`: Exposes CRUD operations for the **LibraryBookToAuthor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LibraryBookToAuthors
    * const libraryBookToAuthors = await prisma.libraryBookToAuthor.findMany()
    * ```
    */
  get libraryBookToAuthor(): Prisma.LibraryBookToAuthorDelegate<GlobalReject>;

  /**
   * `prisma.libraryUniversity`: Exposes CRUD operations for the **LibraryUniversity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LibraryUniversities
    * const libraryUniversities = await prisma.libraryUniversity.findMany()
    * ```
    */
  get libraryUniversity(): Prisma.LibraryUniversityDelegate<GlobalReject>;

  /**
   * `prisma.libraryStudent`: Exposes CRUD operations for the **LibraryStudent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LibraryStudents
    * const libraryStudents = await prisma.libraryStudent.findMany()
    * ```
    */
  get libraryStudent(): Prisma.LibraryStudentDelegate<GlobalReject>;

  /**
   * `prisma.libraryBookCopy`: Exposes CRUD operations for the **LibraryBookCopy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LibraryBookCopies
    * const libraryBookCopies = await prisma.libraryBookCopy.findMany()
    * ```
    */
  get libraryBookCopy(): Prisma.LibraryBookCopyDelegate<GlobalReject>;

  /**
   * `prisma.libraryBorrowingHistory`: Exposes CRUD operations for the **LibraryBorrowingHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LibraryBorrowingHistories
    * const libraryBorrowingHistories = await prisma.libraryBorrowingHistory.findMany()
    * ```
    */
  get libraryBorrowingHistory(): Prisma.LibraryBorrowingHistoryDelegate<GlobalReject>;

  /**
   * `prisma.libraryRequest`: Exposes CRUD operations for the **LibraryRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LibraryRequests
    * const libraryRequests = await prisma.libraryRequest.findMany()
    * ```
    */
  get libraryRequest(): Prisma.LibraryRequestDelegate<GlobalReject>;

  /**
   * `prisma.quizCategory`: Exposes CRUD operations for the **QuizCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizCategories
    * const quizCategories = await prisma.quizCategory.findMany()
    * ```
    */
  get quizCategory(): Prisma.QuizCategoryDelegate<GlobalReject>;

  /**
   * `prisma.quizQuestion`: Exposes CRUD operations for the **QuizQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizQuestions
    * const quizQuestions = await prisma.quizQuestion.findMany()
    * ```
    */
  get quizQuestion(): Prisma.QuizQuestionDelegate<GlobalReject>;

  /**
   * `prisma.quizChoice`: Exposes CRUD operations for the **QuizChoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizChoices
    * const quizChoices = await prisma.quizChoice.findMany()
    * ```
    */
  get quizChoice(): Prisma.QuizChoiceDelegate<GlobalReject>;

  /**
   * `prisma.quizRound`: Exposes CRUD operations for the **QuizRound** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizRounds
    * const quizRounds = await prisma.quizRound.findMany()
    * ```
    */
  get quizRound(): Prisma.QuizRoundDelegate<GlobalReject>;

  /**
   * `prisma.quizRecord`: Exposes CRUD operations for the **QuizRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizRecords
    * const quizRecords = await prisma.quizRecord.findMany()
    * ```
    */
  get quizRecord(): Prisma.QuizRecordDelegate<GlobalReject>;

  /**
   * `prisma.todoList`: Exposes CRUD operations for the **TodoList** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TodoLists
    * const todoLists = await prisma.todoList.findMany()
    * ```
    */
  get todoList(): Prisma.TodoListDelegate<GlobalReject>;

  /**
   * `prisma.twitterUser`: Exposes CRUD operations for the **TwitterUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TwitterUsers
    * const twitterUsers = await prisma.twitterUser.findMany()
    * ```
    */
  get twitterUser(): Prisma.TwitterUserDelegate<GlobalReject>;

  /**
   * `prisma.twitterPost`: Exposes CRUD operations for the **TwitterPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TwitterPosts
    * const twitterPosts = await prisma.twitterPost.findMany()
    * ```
    */
  get twitterPost(): Prisma.TwitterPostDelegate<GlobalReject>;

  /**
   * `prisma.twitterHashtag`: Exposes CRUD operations for the **TwitterHashtag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TwitterHashtags
    * const twitterHashtags = await prisma.twitterHashtag.findMany()
    * ```
    */
  get twitterHashtag(): Prisma.TwitterHashtagDelegate<GlobalReject>;

  /**
   * `prisma.twitterPostToHashtag`: Exposes CRUD operations for the **TwitterPostToHashtag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TwitterPostToHashtags
    * const twitterPostToHashtags = await prisma.twitterPostToHashtag.findMany()
    * ```
    */
  get twitterPostToHashtag(): Prisma.TwitterPostToHashtagDelegate<GlobalReject>;

  /**
   * `prisma.twitterDirectMessage`: Exposes CRUD operations for the **TwitterDirectMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TwitterDirectMessages
    * const twitterDirectMessages = await prisma.twitterDirectMessage.findMany()
    * ```
    */
  get twitterDirectMessage(): Prisma.TwitterDirectMessageDelegate<GlobalReject>;

  /**
   * `prisma.twitterUserRelation`: Exposes CRUD operations for the **TwitterUserRelation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TwitterUserRelations
    * const twitterUserRelations = await prisma.twitterUserRelation.findMany()
    * ```
    */
  get twitterUserRelation(): Prisma.TwitterUserRelationDelegate<GlobalReject>;

  /**
   * `prisma.twitterComment`: Exposes CRUD operations for the **TwitterComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TwitterComments
    * const twitterComments = await prisma.twitterComment.findMany()
    * ```
    */
  get twitterComment(): Prisma.TwitterCommentDelegate<GlobalReject>;

  /**
   * `prisma.youtubeUser`: Exposes CRUD operations for the **YoutubeUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YoutubeUsers
    * const youtubeUsers = await prisma.youtubeUser.findMany()
    * ```
    */
  get youtubeUser(): Prisma.YoutubeUserDelegate<GlobalReject>;

  /**
   * `prisma.youtubeChannel`: Exposes CRUD operations for the **YoutubeChannel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YoutubeChannels
    * const youtubeChannels = await prisma.youtubeChannel.findMany()
    * ```
    */
  get youtubeChannel(): Prisma.YoutubeChannelDelegate<GlobalReject>;

  /**
   * `prisma.youtubeSubscription`: Exposes CRUD operations for the **YoutubeSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YoutubeSubscriptions
    * const youtubeSubscriptions = await prisma.youtubeSubscription.findMany()
    * ```
    */
  get youtubeSubscription(): Prisma.YoutubeSubscriptionDelegate<GlobalReject>;

  /**
   * `prisma.youtubeUserToChannel`: Exposes CRUD operations for the **YoutubeUserToChannel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YoutubeUserToChannels
    * const youtubeUserToChannels = await prisma.youtubeUserToChannel.findMany()
    * ```
    */
  get youtubeUserToChannel(): Prisma.YoutubeUserToChannelDelegate<GlobalReject>;

  /**
   * `prisma.youtubeVideo`: Exposes CRUD operations for the **YoutubeVideo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YoutubeVideos
    * const youtubeVideos = await prisma.youtubeVideo.findMany()
    * ```
    */
  get youtubeVideo(): Prisma.YoutubeVideoDelegate<GlobalReject>;

  /**
   * `prisma.youtubeReaction`: Exposes CRUD operations for the **YoutubeReaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YoutubeReactions
    * const youtubeReactions = await prisma.youtubeReaction.findMany()
    * ```
    */
  get youtubeReaction(): Prisma.YoutubeReactionDelegate<GlobalReject>;

  /**
   * `prisma.youtubeComment`: Exposes CRUD operations for the **YoutubeComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YoutubeComments
    * const youtubeComments = await prisma.youtubeComment.findMany()
    * ```
    */
  get youtubeComment(): Prisma.YoutubeCommentDelegate<GlobalReject>;

  /**
   * `prisma.youtubeCommentReaction`: Exposes CRUD operations for the **YoutubeCommentReaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YoutubeCommentReactions
    * const youtubeCommentReactions = await prisma.youtubeCommentReaction.findMany()
    * ```
    */
  get youtubeCommentReaction(): Prisma.YoutubeCommentReactionDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.10.1
   * Query Engine version: aead147aa326ccb985dcfed5b065b4fdabd44b19
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    BinKitchenCategory: 'BinKitchenCategory',
    BinKitchenMenu: 'BinKitchenMenu',
    BinKitchenOrder: 'BinKitchenOrder',
    BinKitchenOrderItem: 'BinKitchenOrderItem',
    LaundryBranch: 'LaundryBranch',
    LaundryWashingMachine: 'LaundryWashingMachine',
    LaundryProgram: 'LaundryProgram',
    LaundryWashingMachineToProgram: 'LaundryWashingMachineToProgram',
    LaundryMaintainance: 'LaundryMaintainance',
    LaundryUser: 'LaundryUser',
    LaundryUserHistory: 'LaundryUserHistory',
    LaundryBalanceTopup: 'LaundryBalanceTopup',
    LibraryBookCategory: 'LibraryBookCategory',
    LibraryBook: 'LibraryBook',
    LibraryCategoryToBook: 'LibraryCategoryToBook',
    LibraryBookAuthor: 'LibraryBookAuthor',
    LibraryBookToAuthor: 'LibraryBookToAuthor',
    LibraryUniversity: 'LibraryUniversity',
    LibraryStudent: 'LibraryStudent',
    LibraryBookCopy: 'LibraryBookCopy',
    LibraryBorrowingHistory: 'LibraryBorrowingHistory',
    LibraryRequest: 'LibraryRequest',
    QuizCategory: 'QuizCategory',
    QuizQuestion: 'QuizQuestion',
    QuizChoice: 'QuizChoice',
    QuizRound: 'QuizRound',
    QuizRecord: 'QuizRecord',
    TodoList: 'TodoList',
    TwitterUser: 'TwitterUser',
    TwitterPost: 'TwitterPost',
    TwitterHashtag: 'TwitterHashtag',
    TwitterPostToHashtag: 'TwitterPostToHashtag',
    TwitterDirectMessage: 'TwitterDirectMessage',
    TwitterUserRelation: 'TwitterUserRelation',
    TwitterComment: 'TwitterComment',
    YoutubeUser: 'YoutubeUser',
    YoutubeChannel: 'YoutubeChannel',
    YoutubeSubscription: 'YoutubeSubscription',
    YoutubeUserToChannel: 'YoutubeUserToChannel',
    YoutubeVideo: 'YoutubeVideo',
    YoutubeReaction: 'YoutubeReaction',
    YoutubeComment: 'YoutubeComment',
    YoutubeCommentReaction: 'YoutubeCommentReaction'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BinKitchenCategoryCountOutputType
   */


  export type BinKitchenCategoryCountOutputType = {
    menus: number
  }

  export type BinKitchenCategoryCountOutputTypeSelect = {
    menus?: boolean
  }

  export type BinKitchenCategoryCountOutputTypeGetPayload<S extends boolean | null | undefined | BinKitchenCategoryCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BinKitchenCategoryCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (BinKitchenCategoryCountOutputTypeArgs)
    ? BinKitchenCategoryCountOutputType 
    : S extends { select: any } & (BinKitchenCategoryCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof BinKitchenCategoryCountOutputType ? BinKitchenCategoryCountOutputType[P] : never
  } 
      : BinKitchenCategoryCountOutputType




  // Custom InputTypes

  /**
   * BinKitchenCategoryCountOutputType without action
   */
  export type BinKitchenCategoryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenCategoryCountOutputType
     */
    select?: BinKitchenCategoryCountOutputTypeSelect | null
  }



  /**
   * Count Type BinKitchenMenuCountOutputType
   */


  export type BinKitchenMenuCountOutputType = {
    items: number
  }

  export type BinKitchenMenuCountOutputTypeSelect = {
    items?: boolean
  }

  export type BinKitchenMenuCountOutputTypeGetPayload<S extends boolean | null | undefined | BinKitchenMenuCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BinKitchenMenuCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (BinKitchenMenuCountOutputTypeArgs)
    ? BinKitchenMenuCountOutputType 
    : S extends { select: any } & (BinKitchenMenuCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof BinKitchenMenuCountOutputType ? BinKitchenMenuCountOutputType[P] : never
  } 
      : BinKitchenMenuCountOutputType




  // Custom InputTypes

  /**
   * BinKitchenMenuCountOutputType without action
   */
  export type BinKitchenMenuCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenMenuCountOutputType
     */
    select?: BinKitchenMenuCountOutputTypeSelect | null
  }



  /**
   * Count Type BinKitchenOrderCountOutputType
   */


  export type BinKitchenOrderCountOutputType = {
    items: number
  }

  export type BinKitchenOrderCountOutputTypeSelect = {
    items?: boolean
  }

  export type BinKitchenOrderCountOutputTypeGetPayload<S extends boolean | null | undefined | BinKitchenOrderCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BinKitchenOrderCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (BinKitchenOrderCountOutputTypeArgs)
    ? BinKitchenOrderCountOutputType 
    : S extends { select: any } & (BinKitchenOrderCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof BinKitchenOrderCountOutputType ? BinKitchenOrderCountOutputType[P] : never
  } 
      : BinKitchenOrderCountOutputType




  // Custom InputTypes

  /**
   * BinKitchenOrderCountOutputType without action
   */
  export type BinKitchenOrderCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenOrderCountOutputType
     */
    select?: BinKitchenOrderCountOutputTypeSelect | null
  }



  /**
   * Count Type LaundryBranchCountOutputType
   */


  export type LaundryBranchCountOutputType = {
    laundryWashingMachines: number
  }

  export type LaundryBranchCountOutputTypeSelect = {
    laundryWashingMachines?: boolean
  }

  export type LaundryBranchCountOutputTypeGetPayload<S extends boolean | null | undefined | LaundryBranchCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LaundryBranchCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (LaundryBranchCountOutputTypeArgs)
    ? LaundryBranchCountOutputType 
    : S extends { select: any } & (LaundryBranchCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof LaundryBranchCountOutputType ? LaundryBranchCountOutputType[P] : never
  } 
      : LaundryBranchCountOutputType




  // Custom InputTypes

  /**
   * LaundryBranchCountOutputType without action
   */
  export type LaundryBranchCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the LaundryBranchCountOutputType
     */
    select?: LaundryBranchCountOutputTypeSelect | null
  }



  /**
   * Count Type LaundryWashingMachineCountOutputType
   */


  export type LaundryWashingMachineCountOutputType = {
    laundryWashingMachinesToPrograms: number
    laundryMaintainances: number
    laundryUserHistories: number
  }

  export type LaundryWashingMachineCountOutputTypeSelect = {
    laundryWashingMachinesToPrograms?: boolean
    laundryMaintainances?: boolean
    laundryUserHistories?: boolean
  }

  export type LaundryWashingMachineCountOutputTypeGetPayload<S extends boolean | null | undefined | LaundryWashingMachineCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LaundryWashingMachineCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (LaundryWashingMachineCountOutputTypeArgs)
    ? LaundryWashingMachineCountOutputType 
    : S extends { select: any } & (LaundryWashingMachineCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof LaundryWashingMachineCountOutputType ? LaundryWashingMachineCountOutputType[P] : never
  } 
      : LaundryWashingMachineCountOutputType




  // Custom InputTypes

  /**
   * LaundryWashingMachineCountOutputType without action
   */
  export type LaundryWashingMachineCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the LaundryWashingMachineCountOutputType
     */
    select?: LaundryWashingMachineCountOutputTypeSelect | null
  }



  /**
   * Count Type LaundryProgramCountOutputType
   */


  export type LaundryProgramCountOutputType = {
    laundryWashingMachinesToPrograms: number
    laundryUserHistories: number
  }

  export type LaundryProgramCountOutputTypeSelect = {
    laundryWashingMachinesToPrograms?: boolean
    laundryUserHistories?: boolean
  }

  export type LaundryProgramCountOutputTypeGetPayload<S extends boolean | null | undefined | LaundryProgramCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LaundryProgramCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (LaundryProgramCountOutputTypeArgs)
    ? LaundryProgramCountOutputType 
    : S extends { select: any } & (LaundryProgramCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof LaundryProgramCountOutputType ? LaundryProgramCountOutputType[P] : never
  } 
      : LaundryProgramCountOutputType




  // Custom InputTypes

  /**
   * LaundryProgramCountOutputType without action
   */
  export type LaundryProgramCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the LaundryProgramCountOutputType
     */
    select?: LaundryProgramCountOutputTypeSelect | null
  }



  /**
   * Count Type LaundryUserCountOutputType
   */


  export type LaundryUserCountOutputType = {
    laundryUserHistories: number
    laundryBalanceTopups: number
  }

  export type LaundryUserCountOutputTypeSelect = {
    laundryUserHistories?: boolean
    laundryBalanceTopups?: boolean
  }

  export type LaundryUserCountOutputTypeGetPayload<S extends boolean | null | undefined | LaundryUserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LaundryUserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (LaundryUserCountOutputTypeArgs)
    ? LaundryUserCountOutputType 
    : S extends { select: any } & (LaundryUserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof LaundryUserCountOutputType ? LaundryUserCountOutputType[P] : never
  } 
      : LaundryUserCountOutputType




  // Custom InputTypes

  /**
   * LaundryUserCountOutputType without action
   */
  export type LaundryUserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the LaundryUserCountOutputType
     */
    select?: LaundryUserCountOutputTypeSelect | null
  }



  /**
   * Count Type LibraryBookCategoryCountOutputType
   */


  export type LibraryBookCategoryCountOutputType = {
    libraryCategoriesToBooks: number
  }

  export type LibraryBookCategoryCountOutputTypeSelect = {
    libraryCategoriesToBooks?: boolean
  }

  export type LibraryBookCategoryCountOutputTypeGetPayload<S extends boolean | null | undefined | LibraryBookCategoryCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LibraryBookCategoryCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (LibraryBookCategoryCountOutputTypeArgs)
    ? LibraryBookCategoryCountOutputType 
    : S extends { select: any } & (LibraryBookCategoryCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof LibraryBookCategoryCountOutputType ? LibraryBookCategoryCountOutputType[P] : never
  } 
      : LibraryBookCategoryCountOutputType




  // Custom InputTypes

  /**
   * LibraryBookCategoryCountOutputType without action
   */
  export type LibraryBookCategoryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookCategoryCountOutputType
     */
    select?: LibraryBookCategoryCountOutputTypeSelect | null
  }



  /**
   * Count Type LibraryBookCountOutputType
   */


  export type LibraryBookCountOutputType = {
    libraryCategoriesToBooks: number
    libraryBooksToAuthors: number
    libraryBookCopies: number
  }

  export type LibraryBookCountOutputTypeSelect = {
    libraryCategoriesToBooks?: boolean
    libraryBooksToAuthors?: boolean
    libraryBookCopies?: boolean
  }

  export type LibraryBookCountOutputTypeGetPayload<S extends boolean | null | undefined | LibraryBookCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LibraryBookCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (LibraryBookCountOutputTypeArgs)
    ? LibraryBookCountOutputType 
    : S extends { select: any } & (LibraryBookCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof LibraryBookCountOutputType ? LibraryBookCountOutputType[P] : never
  } 
      : LibraryBookCountOutputType




  // Custom InputTypes

  /**
   * LibraryBookCountOutputType without action
   */
  export type LibraryBookCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookCountOutputType
     */
    select?: LibraryBookCountOutputTypeSelect | null
  }



  /**
   * Count Type LibraryBookAuthorCountOutputType
   */


  export type LibraryBookAuthorCountOutputType = {
    libraryBooksToAuthors: number
  }

  export type LibraryBookAuthorCountOutputTypeSelect = {
    libraryBooksToAuthors?: boolean
  }

  export type LibraryBookAuthorCountOutputTypeGetPayload<S extends boolean | null | undefined | LibraryBookAuthorCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LibraryBookAuthorCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (LibraryBookAuthorCountOutputTypeArgs)
    ? LibraryBookAuthorCountOutputType 
    : S extends { select: any } & (LibraryBookAuthorCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof LibraryBookAuthorCountOutputType ? LibraryBookAuthorCountOutputType[P] : never
  } 
      : LibraryBookAuthorCountOutputType




  // Custom InputTypes

  /**
   * LibraryBookAuthorCountOutputType without action
   */
  export type LibraryBookAuthorCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookAuthorCountOutputType
     */
    select?: LibraryBookAuthorCountOutputTypeSelect | null
  }



  /**
   * Count Type LibraryUniversityCountOutputType
   */


  export type LibraryUniversityCountOutputType = {
    libraryStudenta: number
    libraryBookCopies: number
    libraryBorrowingHistories: number
    fromLibraryRequests: number
    toLibraryRequests: number
  }

  export type LibraryUniversityCountOutputTypeSelect = {
    libraryStudenta?: boolean
    libraryBookCopies?: boolean
    libraryBorrowingHistories?: boolean
    fromLibraryRequests?: boolean
    toLibraryRequests?: boolean
  }

  export type LibraryUniversityCountOutputTypeGetPayload<S extends boolean | null | undefined | LibraryUniversityCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LibraryUniversityCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (LibraryUniversityCountOutputTypeArgs)
    ? LibraryUniversityCountOutputType 
    : S extends { select: any } & (LibraryUniversityCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof LibraryUniversityCountOutputType ? LibraryUniversityCountOutputType[P] : never
  } 
      : LibraryUniversityCountOutputType




  // Custom InputTypes

  /**
   * LibraryUniversityCountOutputType without action
   */
  export type LibraryUniversityCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the LibraryUniversityCountOutputType
     */
    select?: LibraryUniversityCountOutputTypeSelect | null
  }



  /**
   * Count Type LibraryStudentCountOutputType
   */


  export type LibraryStudentCountOutputType = {
    libraryBookCopies: number
    libraryBorrowingHistories: number
    libraryRequests: number
  }

  export type LibraryStudentCountOutputTypeSelect = {
    libraryBookCopies?: boolean
    libraryBorrowingHistories?: boolean
    libraryRequests?: boolean
  }

  export type LibraryStudentCountOutputTypeGetPayload<S extends boolean | null | undefined | LibraryStudentCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LibraryStudentCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (LibraryStudentCountOutputTypeArgs)
    ? LibraryStudentCountOutputType 
    : S extends { select: any } & (LibraryStudentCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof LibraryStudentCountOutputType ? LibraryStudentCountOutputType[P] : never
  } 
      : LibraryStudentCountOutputType




  // Custom InputTypes

  /**
   * LibraryStudentCountOutputType without action
   */
  export type LibraryStudentCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the LibraryStudentCountOutputType
     */
    select?: LibraryStudentCountOutputTypeSelect | null
  }



  /**
   * Count Type LibraryBookCopyCountOutputType
   */


  export type LibraryBookCopyCountOutputType = {
    libraryBorrowingHistories: number
    libraryRequests: number
  }

  export type LibraryBookCopyCountOutputTypeSelect = {
    libraryBorrowingHistories?: boolean
    libraryRequests?: boolean
  }

  export type LibraryBookCopyCountOutputTypeGetPayload<S extends boolean | null | undefined | LibraryBookCopyCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LibraryBookCopyCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (LibraryBookCopyCountOutputTypeArgs)
    ? LibraryBookCopyCountOutputType 
    : S extends { select: any } & (LibraryBookCopyCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof LibraryBookCopyCountOutputType ? LibraryBookCopyCountOutputType[P] : never
  } 
      : LibraryBookCopyCountOutputType




  // Custom InputTypes

  /**
   * LibraryBookCopyCountOutputType without action
   */
  export type LibraryBookCopyCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookCopyCountOutputType
     */
    select?: LibraryBookCopyCountOutputTypeSelect | null
  }



  /**
   * Count Type QuizCategoryCountOutputType
   */


  export type QuizCategoryCountOutputType = {
    QuizQuestion: number
    QuizRound: number
  }

  export type QuizCategoryCountOutputTypeSelect = {
    QuizQuestion?: boolean
    QuizRound?: boolean
  }

  export type QuizCategoryCountOutputTypeGetPayload<S extends boolean | null | undefined | QuizCategoryCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? QuizCategoryCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (QuizCategoryCountOutputTypeArgs)
    ? QuizCategoryCountOutputType 
    : S extends { select: any } & (QuizCategoryCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof QuizCategoryCountOutputType ? QuizCategoryCountOutputType[P] : never
  } 
      : QuizCategoryCountOutputType




  // Custom InputTypes

  /**
   * QuizCategoryCountOutputType without action
   */
  export type QuizCategoryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the QuizCategoryCountOutputType
     */
    select?: QuizCategoryCountOutputTypeSelect | null
  }



  /**
   * Count Type QuizQuestionCountOutputType
   */


  export type QuizQuestionCountOutputType = {
    quizChoices: number
    quizRecords: number
  }

  export type QuizQuestionCountOutputTypeSelect = {
    quizChoices?: boolean
    quizRecords?: boolean
  }

  export type QuizQuestionCountOutputTypeGetPayload<S extends boolean | null | undefined | QuizQuestionCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? QuizQuestionCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (QuizQuestionCountOutputTypeArgs)
    ? QuizQuestionCountOutputType 
    : S extends { select: any } & (QuizQuestionCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof QuizQuestionCountOutputType ? QuizQuestionCountOutputType[P] : never
  } 
      : QuizQuestionCountOutputType




  // Custom InputTypes

  /**
   * QuizQuestionCountOutputType without action
   */
  export type QuizQuestionCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the QuizQuestionCountOutputType
     */
    select?: QuizQuestionCountOutputTypeSelect | null
  }



  /**
   * Count Type QuizChoiceCountOutputType
   */


  export type QuizChoiceCountOutputType = {
    quizRecords: number
  }

  export type QuizChoiceCountOutputTypeSelect = {
    quizRecords?: boolean
  }

  export type QuizChoiceCountOutputTypeGetPayload<S extends boolean | null | undefined | QuizChoiceCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? QuizChoiceCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (QuizChoiceCountOutputTypeArgs)
    ? QuizChoiceCountOutputType 
    : S extends { select: any } & (QuizChoiceCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof QuizChoiceCountOutputType ? QuizChoiceCountOutputType[P] : never
  } 
      : QuizChoiceCountOutputType




  // Custom InputTypes

  /**
   * QuizChoiceCountOutputType without action
   */
  export type QuizChoiceCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the QuizChoiceCountOutputType
     */
    select?: QuizChoiceCountOutputTypeSelect | null
  }



  /**
   * Count Type QuizRoundCountOutputType
   */


  export type QuizRoundCountOutputType = {
    quizRecords: number
  }

  export type QuizRoundCountOutputTypeSelect = {
    quizRecords?: boolean
  }

  export type QuizRoundCountOutputTypeGetPayload<S extends boolean | null | undefined | QuizRoundCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? QuizRoundCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (QuizRoundCountOutputTypeArgs)
    ? QuizRoundCountOutputType 
    : S extends { select: any } & (QuizRoundCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof QuizRoundCountOutputType ? QuizRoundCountOutputType[P] : never
  } 
      : QuizRoundCountOutputType




  // Custom InputTypes

  /**
   * QuizRoundCountOutputType without action
   */
  export type QuizRoundCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the QuizRoundCountOutputType
     */
    select?: QuizRoundCountOutputTypeSelect | null
  }



  /**
   * Count Type TwitterUserCountOutputType
   */


  export type TwitterUserCountOutputType = {
    posts: number
    fromDirectMessages: number
    comments: number
    toDirectMessages: number
    followingUserRelations: number
    followerUserRelations: number
  }

  export type TwitterUserCountOutputTypeSelect = {
    posts?: boolean
    fromDirectMessages?: boolean
    comments?: boolean
    toDirectMessages?: boolean
    followingUserRelations?: boolean
    followerUserRelations?: boolean
  }

  export type TwitterUserCountOutputTypeGetPayload<S extends boolean | null | undefined | TwitterUserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TwitterUserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TwitterUserCountOutputTypeArgs)
    ? TwitterUserCountOutputType 
    : S extends { select: any } & (TwitterUserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TwitterUserCountOutputType ? TwitterUserCountOutputType[P] : never
  } 
      : TwitterUserCountOutputType




  // Custom InputTypes

  /**
   * TwitterUserCountOutputType without action
   */
  export type TwitterUserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TwitterUserCountOutputType
     */
    select?: TwitterUserCountOutputTypeSelect | null
  }



  /**
   * Count Type TwitterPostCountOutputType
   */


  export type TwitterPostCountOutputType = {
    postToHashtags: number
    comments: number
  }

  export type TwitterPostCountOutputTypeSelect = {
    postToHashtags?: boolean
    comments?: boolean
  }

  export type TwitterPostCountOutputTypeGetPayload<S extends boolean | null | undefined | TwitterPostCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TwitterPostCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TwitterPostCountOutputTypeArgs)
    ? TwitterPostCountOutputType 
    : S extends { select: any } & (TwitterPostCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TwitterPostCountOutputType ? TwitterPostCountOutputType[P] : never
  } 
      : TwitterPostCountOutputType




  // Custom InputTypes

  /**
   * TwitterPostCountOutputType without action
   */
  export type TwitterPostCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TwitterPostCountOutputType
     */
    select?: TwitterPostCountOutputTypeSelect | null
  }



  /**
   * Count Type TwitterHashtagCountOutputType
   */


  export type TwitterHashtagCountOutputType = {
    postsToHashtags: number
  }

  export type TwitterHashtagCountOutputTypeSelect = {
    postsToHashtags?: boolean
  }

  export type TwitterHashtagCountOutputTypeGetPayload<S extends boolean | null | undefined | TwitterHashtagCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TwitterHashtagCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TwitterHashtagCountOutputTypeArgs)
    ? TwitterHashtagCountOutputType 
    : S extends { select: any } & (TwitterHashtagCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TwitterHashtagCountOutputType ? TwitterHashtagCountOutputType[P] : never
  } 
      : TwitterHashtagCountOutputType




  // Custom InputTypes

  /**
   * TwitterHashtagCountOutputType without action
   */
  export type TwitterHashtagCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TwitterHashtagCountOutputType
     */
    select?: TwitterHashtagCountOutputTypeSelect | null
  }



  /**
   * Count Type YoutubeUserCountOutputType
   */


  export type YoutubeUserCountOutputType = {
    youtubeUsersToChannels: number
    youtubeSubscriptions: number
    YoutubeReaction: number
    YoutubeComment: number
    YoutubeCommentReaction: number
  }

  export type YoutubeUserCountOutputTypeSelect = {
    youtubeUsersToChannels?: boolean
    youtubeSubscriptions?: boolean
    YoutubeReaction?: boolean
    YoutubeComment?: boolean
    YoutubeCommentReaction?: boolean
  }

  export type YoutubeUserCountOutputTypeGetPayload<S extends boolean | null | undefined | YoutubeUserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YoutubeUserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (YoutubeUserCountOutputTypeArgs)
    ? YoutubeUserCountOutputType 
    : S extends { select: any } & (YoutubeUserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof YoutubeUserCountOutputType ? YoutubeUserCountOutputType[P] : never
  } 
      : YoutubeUserCountOutputType




  // Custom InputTypes

  /**
   * YoutubeUserCountOutputType without action
   */
  export type YoutubeUserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUserCountOutputType
     */
    select?: YoutubeUserCountOutputTypeSelect | null
  }



  /**
   * Count Type YoutubeChannelCountOutputType
   */


  export type YoutubeChannelCountOutputType = {
    youtubeUsersToChannels: number
    youtubeVideos: number
    youtubeSubscriptions: number
  }

  export type YoutubeChannelCountOutputTypeSelect = {
    youtubeUsersToChannels?: boolean
    youtubeVideos?: boolean
    youtubeSubscriptions?: boolean
  }

  export type YoutubeChannelCountOutputTypeGetPayload<S extends boolean | null | undefined | YoutubeChannelCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YoutubeChannelCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (YoutubeChannelCountOutputTypeArgs)
    ? YoutubeChannelCountOutputType 
    : S extends { select: any } & (YoutubeChannelCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof YoutubeChannelCountOutputType ? YoutubeChannelCountOutputType[P] : never
  } 
      : YoutubeChannelCountOutputType




  // Custom InputTypes

  /**
   * YoutubeChannelCountOutputType without action
   */
  export type YoutubeChannelCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the YoutubeChannelCountOutputType
     */
    select?: YoutubeChannelCountOutputTypeSelect | null
  }



  /**
   * Count Type YoutubeVideoCountOutputType
   */


  export type YoutubeVideoCountOutputType = {
    youtubeComments: number
    youtubeReactions: number
  }

  export type YoutubeVideoCountOutputTypeSelect = {
    youtubeComments?: boolean
    youtubeReactions?: boolean
  }

  export type YoutubeVideoCountOutputTypeGetPayload<S extends boolean | null | undefined | YoutubeVideoCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YoutubeVideoCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (YoutubeVideoCountOutputTypeArgs)
    ? YoutubeVideoCountOutputType 
    : S extends { select: any } & (YoutubeVideoCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof YoutubeVideoCountOutputType ? YoutubeVideoCountOutputType[P] : never
  } 
      : YoutubeVideoCountOutputType




  // Custom InputTypes

  /**
   * YoutubeVideoCountOutputType without action
   */
  export type YoutubeVideoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the YoutubeVideoCountOutputType
     */
    select?: YoutubeVideoCountOutputTypeSelect | null
  }



  /**
   * Count Type YoutubeCommentCountOutputType
   */


  export type YoutubeCommentCountOutputType = {
    youtubeCommentReactions: number
  }

  export type YoutubeCommentCountOutputTypeSelect = {
    youtubeCommentReactions?: boolean
  }

  export type YoutubeCommentCountOutputTypeGetPayload<S extends boolean | null | undefined | YoutubeCommentCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YoutubeCommentCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (YoutubeCommentCountOutputTypeArgs)
    ? YoutubeCommentCountOutputType 
    : S extends { select: any } & (YoutubeCommentCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof YoutubeCommentCountOutputType ? YoutubeCommentCountOutputType[P] : never
  } 
      : YoutubeCommentCountOutputType




  // Custom InputTypes

  /**
   * YoutubeCommentCountOutputType without action
   */
  export type YoutubeCommentCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the YoutubeCommentCountOutputType
     */
    select?: YoutubeCommentCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model BinKitchenCategory
   */


  export type AggregateBinKitchenCategory = {
    _count: BinKitchenCategoryCountAggregateOutputType | null
    _avg: BinKitchenCategoryAvgAggregateOutputType | null
    _sum: BinKitchenCategorySumAggregateOutputType | null
    _min: BinKitchenCategoryMinAggregateOutputType | null
    _max: BinKitchenCategoryMaxAggregateOutputType | null
  }

  export type BinKitchenCategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type BinKitchenCategorySumAggregateOutputType = {
    id: number | null
  }

  export type BinKitchenCategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BinKitchenCategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BinKitchenCategoryCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BinKitchenCategoryAvgAggregateInputType = {
    id?: true
  }

  export type BinKitchenCategorySumAggregateInputType = {
    id?: true
  }

  export type BinKitchenCategoryMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BinKitchenCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BinKitchenCategoryCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BinKitchenCategoryAggregateArgs = {
    /**
     * Filter which BinKitchenCategory to aggregate.
     */
    where?: BinKitchenCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BinKitchenCategories to fetch.
     */
    orderBy?: Enumerable<BinKitchenCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BinKitchenCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BinKitchenCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BinKitchenCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BinKitchenCategories
    **/
    _count?: true | BinKitchenCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BinKitchenCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BinKitchenCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BinKitchenCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BinKitchenCategoryMaxAggregateInputType
  }

  export type GetBinKitchenCategoryAggregateType<T extends BinKitchenCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateBinKitchenCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBinKitchenCategory[P]>
      : GetScalarType<T[P], AggregateBinKitchenCategory[P]>
  }




  export type BinKitchenCategoryGroupByArgs = {
    where?: BinKitchenCategoryWhereInput
    orderBy?: Enumerable<BinKitchenCategoryOrderByWithAggregationInput>
    by: BinKitchenCategoryScalarFieldEnum[]
    having?: BinKitchenCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BinKitchenCategoryCountAggregateInputType | true
    _avg?: BinKitchenCategoryAvgAggregateInputType
    _sum?: BinKitchenCategorySumAggregateInputType
    _min?: BinKitchenCategoryMinAggregateInputType
    _max?: BinKitchenCategoryMaxAggregateInputType
  }


  export type BinKitchenCategoryGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: BinKitchenCategoryCountAggregateOutputType | null
    _avg: BinKitchenCategoryAvgAggregateOutputType | null
    _sum: BinKitchenCategorySumAggregateOutputType | null
    _min: BinKitchenCategoryMinAggregateOutputType | null
    _max: BinKitchenCategoryMaxAggregateOutputType | null
  }

  type GetBinKitchenCategoryGroupByPayload<T extends BinKitchenCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BinKitchenCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BinKitchenCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BinKitchenCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], BinKitchenCategoryGroupByOutputType[P]>
        }
      >
    >


  export type BinKitchenCategorySelect = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    menus?: boolean | BinKitchenCategory$menusArgs
    _count?: boolean | BinKitchenCategoryCountOutputTypeArgs
  }


  export type BinKitchenCategoryInclude = {
    menus?: boolean | BinKitchenCategory$menusArgs
    _count?: boolean | BinKitchenCategoryCountOutputTypeArgs
  }

  export type BinKitchenCategoryGetPayload<S extends boolean | null | undefined | BinKitchenCategoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BinKitchenCategory :
    S extends undefined ? never :
    S extends { include: any } & (BinKitchenCategoryArgs | BinKitchenCategoryFindManyArgs)
    ? BinKitchenCategory  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'menus' ? Array < BinKitchenMenuGetPayload<S['include'][P]>>  :
        P extends '_count' ? BinKitchenCategoryCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BinKitchenCategoryArgs | BinKitchenCategoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'menus' ? Array < BinKitchenMenuGetPayload<S['select'][P]>>  :
        P extends '_count' ? BinKitchenCategoryCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof BinKitchenCategory ? BinKitchenCategory[P] : never
  } 
      : BinKitchenCategory


  type BinKitchenCategoryCountArgs = 
    Omit<BinKitchenCategoryFindManyArgs, 'select' | 'include'> & {
      select?: BinKitchenCategoryCountAggregateInputType | true
    }

  export interface BinKitchenCategoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one BinKitchenCategory that matches the filter.
     * @param {BinKitchenCategoryFindUniqueArgs} args - Arguments to find a BinKitchenCategory
     * @example
     * // Get one BinKitchenCategory
     * const binKitchenCategory = await prisma.binKitchenCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BinKitchenCategoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BinKitchenCategoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BinKitchenCategory'> extends True ? Prisma__BinKitchenCategoryClient<BinKitchenCategoryGetPayload<T>> : Prisma__BinKitchenCategoryClient<BinKitchenCategoryGetPayload<T> | null, null>

    /**
     * Find one BinKitchenCategory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BinKitchenCategoryFindUniqueOrThrowArgs} args - Arguments to find a BinKitchenCategory
     * @example
     * // Get one BinKitchenCategory
     * const binKitchenCategory = await prisma.binKitchenCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BinKitchenCategoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BinKitchenCategoryFindUniqueOrThrowArgs>
    ): Prisma__BinKitchenCategoryClient<BinKitchenCategoryGetPayload<T>>

    /**
     * Find the first BinKitchenCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenCategoryFindFirstArgs} args - Arguments to find a BinKitchenCategory
     * @example
     * // Get one BinKitchenCategory
     * const binKitchenCategory = await prisma.binKitchenCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BinKitchenCategoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BinKitchenCategoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BinKitchenCategory'> extends True ? Prisma__BinKitchenCategoryClient<BinKitchenCategoryGetPayload<T>> : Prisma__BinKitchenCategoryClient<BinKitchenCategoryGetPayload<T> | null, null>

    /**
     * Find the first BinKitchenCategory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenCategoryFindFirstOrThrowArgs} args - Arguments to find a BinKitchenCategory
     * @example
     * // Get one BinKitchenCategory
     * const binKitchenCategory = await prisma.binKitchenCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BinKitchenCategoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BinKitchenCategoryFindFirstOrThrowArgs>
    ): Prisma__BinKitchenCategoryClient<BinKitchenCategoryGetPayload<T>>

    /**
     * Find zero or more BinKitchenCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenCategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BinKitchenCategories
     * const binKitchenCategories = await prisma.binKitchenCategory.findMany()
     * 
     * // Get first 10 BinKitchenCategories
     * const binKitchenCategories = await prisma.binKitchenCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const binKitchenCategoryWithIdOnly = await prisma.binKitchenCategory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BinKitchenCategoryFindManyArgs>(
      args?: SelectSubset<T, BinKitchenCategoryFindManyArgs>
    ): Prisma.PrismaPromise<Array<BinKitchenCategoryGetPayload<T>>>

    /**
     * Create a BinKitchenCategory.
     * @param {BinKitchenCategoryCreateArgs} args - Arguments to create a BinKitchenCategory.
     * @example
     * // Create one BinKitchenCategory
     * const BinKitchenCategory = await prisma.binKitchenCategory.create({
     *   data: {
     *     // ... data to create a BinKitchenCategory
     *   }
     * })
     * 
    **/
    create<T extends BinKitchenCategoryCreateArgs>(
      args: SelectSubset<T, BinKitchenCategoryCreateArgs>
    ): Prisma__BinKitchenCategoryClient<BinKitchenCategoryGetPayload<T>>

    /**
     * Create many BinKitchenCategories.
     *     @param {BinKitchenCategoryCreateManyArgs} args - Arguments to create many BinKitchenCategories.
     *     @example
     *     // Create many BinKitchenCategories
     *     const binKitchenCategory = await prisma.binKitchenCategory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BinKitchenCategoryCreateManyArgs>(
      args?: SelectSubset<T, BinKitchenCategoryCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BinKitchenCategory.
     * @param {BinKitchenCategoryDeleteArgs} args - Arguments to delete one BinKitchenCategory.
     * @example
     * // Delete one BinKitchenCategory
     * const BinKitchenCategory = await prisma.binKitchenCategory.delete({
     *   where: {
     *     // ... filter to delete one BinKitchenCategory
     *   }
     * })
     * 
    **/
    delete<T extends BinKitchenCategoryDeleteArgs>(
      args: SelectSubset<T, BinKitchenCategoryDeleteArgs>
    ): Prisma__BinKitchenCategoryClient<BinKitchenCategoryGetPayload<T>>

    /**
     * Update one BinKitchenCategory.
     * @param {BinKitchenCategoryUpdateArgs} args - Arguments to update one BinKitchenCategory.
     * @example
     * // Update one BinKitchenCategory
     * const binKitchenCategory = await prisma.binKitchenCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BinKitchenCategoryUpdateArgs>(
      args: SelectSubset<T, BinKitchenCategoryUpdateArgs>
    ): Prisma__BinKitchenCategoryClient<BinKitchenCategoryGetPayload<T>>

    /**
     * Delete zero or more BinKitchenCategories.
     * @param {BinKitchenCategoryDeleteManyArgs} args - Arguments to filter BinKitchenCategories to delete.
     * @example
     * // Delete a few BinKitchenCategories
     * const { count } = await prisma.binKitchenCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BinKitchenCategoryDeleteManyArgs>(
      args?: SelectSubset<T, BinKitchenCategoryDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BinKitchenCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BinKitchenCategories
     * const binKitchenCategory = await prisma.binKitchenCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BinKitchenCategoryUpdateManyArgs>(
      args: SelectSubset<T, BinKitchenCategoryUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BinKitchenCategory.
     * @param {BinKitchenCategoryUpsertArgs} args - Arguments to update or create a BinKitchenCategory.
     * @example
     * // Update or create a BinKitchenCategory
     * const binKitchenCategory = await prisma.binKitchenCategory.upsert({
     *   create: {
     *     // ... data to create a BinKitchenCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BinKitchenCategory we want to update
     *   }
     * })
    **/
    upsert<T extends BinKitchenCategoryUpsertArgs>(
      args: SelectSubset<T, BinKitchenCategoryUpsertArgs>
    ): Prisma__BinKitchenCategoryClient<BinKitchenCategoryGetPayload<T>>

    /**
     * Count the number of BinKitchenCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenCategoryCountArgs} args - Arguments to filter BinKitchenCategories to count.
     * @example
     * // Count the number of BinKitchenCategories
     * const count = await prisma.binKitchenCategory.count({
     *   where: {
     *     // ... the filter for the BinKitchenCategories we want to count
     *   }
     * })
    **/
    count<T extends BinKitchenCategoryCountArgs>(
      args?: Subset<T, BinKitchenCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BinKitchenCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BinKitchenCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BinKitchenCategoryAggregateArgs>(args: Subset<T, BinKitchenCategoryAggregateArgs>): Prisma.PrismaPromise<GetBinKitchenCategoryAggregateType<T>>

    /**
     * Group by BinKitchenCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BinKitchenCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BinKitchenCategoryGroupByArgs['orderBy'] }
        : { orderBy?: BinKitchenCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BinKitchenCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBinKitchenCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BinKitchenCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BinKitchenCategoryClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    menus<T extends BinKitchenCategory$menusArgs= {}>(args?: Subset<T, BinKitchenCategory$menusArgs>): Prisma.PrismaPromise<Array<BinKitchenMenuGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BinKitchenCategory base type for findUnique actions
   */
  export type BinKitchenCategoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BinKitchenCategory
     */
    select?: BinKitchenCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenCategoryInclude | null
    /**
     * Filter, which BinKitchenCategory to fetch.
     */
    where: BinKitchenCategoryWhereUniqueInput
  }

  /**
   * BinKitchenCategory findUnique
   */
  export interface BinKitchenCategoryFindUniqueArgs extends BinKitchenCategoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BinKitchenCategory findUniqueOrThrow
   */
  export type BinKitchenCategoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenCategory
     */
    select?: BinKitchenCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenCategoryInclude | null
    /**
     * Filter, which BinKitchenCategory to fetch.
     */
    where: BinKitchenCategoryWhereUniqueInput
  }


  /**
   * BinKitchenCategory base type for findFirst actions
   */
  export type BinKitchenCategoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BinKitchenCategory
     */
    select?: BinKitchenCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenCategoryInclude | null
    /**
     * Filter, which BinKitchenCategory to fetch.
     */
    where?: BinKitchenCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BinKitchenCategories to fetch.
     */
    orderBy?: Enumerable<BinKitchenCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BinKitchenCategories.
     */
    cursor?: BinKitchenCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BinKitchenCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BinKitchenCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BinKitchenCategories.
     */
    distinct?: Enumerable<BinKitchenCategoryScalarFieldEnum>
  }

  /**
   * BinKitchenCategory findFirst
   */
  export interface BinKitchenCategoryFindFirstArgs extends BinKitchenCategoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BinKitchenCategory findFirstOrThrow
   */
  export type BinKitchenCategoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenCategory
     */
    select?: BinKitchenCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenCategoryInclude | null
    /**
     * Filter, which BinKitchenCategory to fetch.
     */
    where?: BinKitchenCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BinKitchenCategories to fetch.
     */
    orderBy?: Enumerable<BinKitchenCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BinKitchenCategories.
     */
    cursor?: BinKitchenCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BinKitchenCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BinKitchenCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BinKitchenCategories.
     */
    distinct?: Enumerable<BinKitchenCategoryScalarFieldEnum>
  }


  /**
   * BinKitchenCategory findMany
   */
  export type BinKitchenCategoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenCategory
     */
    select?: BinKitchenCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenCategoryInclude | null
    /**
     * Filter, which BinKitchenCategories to fetch.
     */
    where?: BinKitchenCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BinKitchenCategories to fetch.
     */
    orderBy?: Enumerable<BinKitchenCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BinKitchenCategories.
     */
    cursor?: BinKitchenCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BinKitchenCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BinKitchenCategories.
     */
    skip?: number
    distinct?: Enumerable<BinKitchenCategoryScalarFieldEnum>
  }


  /**
   * BinKitchenCategory create
   */
  export type BinKitchenCategoryCreateArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenCategory
     */
    select?: BinKitchenCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenCategoryInclude | null
    /**
     * The data needed to create a BinKitchenCategory.
     */
    data: XOR<BinKitchenCategoryCreateInput, BinKitchenCategoryUncheckedCreateInput>
  }


  /**
   * BinKitchenCategory createMany
   */
  export type BinKitchenCategoryCreateManyArgs = {
    /**
     * The data used to create many BinKitchenCategories.
     */
    data: Enumerable<BinKitchenCategoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BinKitchenCategory update
   */
  export type BinKitchenCategoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenCategory
     */
    select?: BinKitchenCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenCategoryInclude | null
    /**
     * The data needed to update a BinKitchenCategory.
     */
    data: XOR<BinKitchenCategoryUpdateInput, BinKitchenCategoryUncheckedUpdateInput>
    /**
     * Choose, which BinKitchenCategory to update.
     */
    where: BinKitchenCategoryWhereUniqueInput
  }


  /**
   * BinKitchenCategory updateMany
   */
  export type BinKitchenCategoryUpdateManyArgs = {
    /**
     * The data used to update BinKitchenCategories.
     */
    data: XOR<BinKitchenCategoryUpdateManyMutationInput, BinKitchenCategoryUncheckedUpdateManyInput>
    /**
     * Filter which BinKitchenCategories to update
     */
    where?: BinKitchenCategoryWhereInput
  }


  /**
   * BinKitchenCategory upsert
   */
  export type BinKitchenCategoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenCategory
     */
    select?: BinKitchenCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenCategoryInclude | null
    /**
     * The filter to search for the BinKitchenCategory to update in case it exists.
     */
    where: BinKitchenCategoryWhereUniqueInput
    /**
     * In case the BinKitchenCategory found by the `where` argument doesn't exist, create a new BinKitchenCategory with this data.
     */
    create: XOR<BinKitchenCategoryCreateInput, BinKitchenCategoryUncheckedCreateInput>
    /**
     * In case the BinKitchenCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BinKitchenCategoryUpdateInput, BinKitchenCategoryUncheckedUpdateInput>
  }


  /**
   * BinKitchenCategory delete
   */
  export type BinKitchenCategoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenCategory
     */
    select?: BinKitchenCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenCategoryInclude | null
    /**
     * Filter which BinKitchenCategory to delete.
     */
    where: BinKitchenCategoryWhereUniqueInput
  }


  /**
   * BinKitchenCategory deleteMany
   */
  export type BinKitchenCategoryDeleteManyArgs = {
    /**
     * Filter which BinKitchenCategories to delete
     */
    where?: BinKitchenCategoryWhereInput
  }


  /**
   * BinKitchenCategory.menus
   */
  export type BinKitchenCategory$menusArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenMenu
     */
    select?: BinKitchenMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenMenuInclude | null
    where?: BinKitchenMenuWhereInput
    orderBy?: Enumerable<BinKitchenMenuOrderByWithRelationInput>
    cursor?: BinKitchenMenuWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BinKitchenMenuScalarFieldEnum>
  }


  /**
   * BinKitchenCategory without action
   */
  export type BinKitchenCategoryArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenCategory
     */
    select?: BinKitchenCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenCategoryInclude | null
  }



  /**
   * Model BinKitchenMenu
   */


  export type AggregateBinKitchenMenu = {
    _count: BinKitchenMenuCountAggregateOutputType | null
    _avg: BinKitchenMenuAvgAggregateOutputType | null
    _sum: BinKitchenMenuSumAggregateOutputType | null
    _min: BinKitchenMenuMinAggregateOutputType | null
    _max: BinKitchenMenuMaxAggregateOutputType | null
  }

  export type BinKitchenMenuAvgAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type BinKitchenMenuSumAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type BinKitchenMenuMinAggregateOutputType = {
    id: number | null
    name: string | null
    image: string | null
    price: number | null
    categoryName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BinKitchenMenuMaxAggregateOutputType = {
    id: number | null
    name: string | null
    image: string | null
    price: number | null
    categoryName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BinKitchenMenuCountAggregateOutputType = {
    id: number
    name: number
    image: number
    price: number
    categoryName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BinKitchenMenuAvgAggregateInputType = {
    id?: true
    price?: true
  }

  export type BinKitchenMenuSumAggregateInputType = {
    id?: true
    price?: true
  }

  export type BinKitchenMenuMinAggregateInputType = {
    id?: true
    name?: true
    image?: true
    price?: true
    categoryName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BinKitchenMenuMaxAggregateInputType = {
    id?: true
    name?: true
    image?: true
    price?: true
    categoryName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BinKitchenMenuCountAggregateInputType = {
    id?: true
    name?: true
    image?: true
    price?: true
    categoryName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BinKitchenMenuAggregateArgs = {
    /**
     * Filter which BinKitchenMenu to aggregate.
     */
    where?: BinKitchenMenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BinKitchenMenus to fetch.
     */
    orderBy?: Enumerable<BinKitchenMenuOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BinKitchenMenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BinKitchenMenus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BinKitchenMenus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BinKitchenMenus
    **/
    _count?: true | BinKitchenMenuCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BinKitchenMenuAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BinKitchenMenuSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BinKitchenMenuMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BinKitchenMenuMaxAggregateInputType
  }

  export type GetBinKitchenMenuAggregateType<T extends BinKitchenMenuAggregateArgs> = {
        [P in keyof T & keyof AggregateBinKitchenMenu]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBinKitchenMenu[P]>
      : GetScalarType<T[P], AggregateBinKitchenMenu[P]>
  }




  export type BinKitchenMenuGroupByArgs = {
    where?: BinKitchenMenuWhereInput
    orderBy?: Enumerable<BinKitchenMenuOrderByWithAggregationInput>
    by: BinKitchenMenuScalarFieldEnum[]
    having?: BinKitchenMenuScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BinKitchenMenuCountAggregateInputType | true
    _avg?: BinKitchenMenuAvgAggregateInputType
    _sum?: BinKitchenMenuSumAggregateInputType
    _min?: BinKitchenMenuMinAggregateInputType
    _max?: BinKitchenMenuMaxAggregateInputType
  }


  export type BinKitchenMenuGroupByOutputType = {
    id: number
    name: string
    image: string
    price: number
    categoryName: string | null
    createdAt: Date
    updatedAt: Date
    _count: BinKitchenMenuCountAggregateOutputType | null
    _avg: BinKitchenMenuAvgAggregateOutputType | null
    _sum: BinKitchenMenuSumAggregateOutputType | null
    _min: BinKitchenMenuMinAggregateOutputType | null
    _max: BinKitchenMenuMaxAggregateOutputType | null
  }

  type GetBinKitchenMenuGroupByPayload<T extends BinKitchenMenuGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BinKitchenMenuGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BinKitchenMenuGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BinKitchenMenuGroupByOutputType[P]>
            : GetScalarType<T[P], BinKitchenMenuGroupByOutputType[P]>
        }
      >
    >


  export type BinKitchenMenuSelect = {
    id?: boolean
    name?: boolean
    image?: boolean
    price?: boolean
    category?: boolean | BinKitchenCategoryArgs
    categoryName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    items?: boolean | BinKitchenMenu$itemsArgs
    _count?: boolean | BinKitchenMenuCountOutputTypeArgs
  }


  export type BinKitchenMenuInclude = {
    category?: boolean | BinKitchenCategoryArgs
    items?: boolean | BinKitchenMenu$itemsArgs
    _count?: boolean | BinKitchenMenuCountOutputTypeArgs
  }

  export type BinKitchenMenuGetPayload<S extends boolean | null | undefined | BinKitchenMenuArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BinKitchenMenu :
    S extends undefined ? never :
    S extends { include: any } & (BinKitchenMenuArgs | BinKitchenMenuFindManyArgs)
    ? BinKitchenMenu  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'category' ? BinKitchenCategoryGetPayload<S['include'][P]> | null :
        P extends 'items' ? Array < BinKitchenOrderItemGetPayload<S['include'][P]>>  :
        P extends '_count' ? BinKitchenMenuCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BinKitchenMenuArgs | BinKitchenMenuFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'category' ? BinKitchenCategoryGetPayload<S['select'][P]> | null :
        P extends 'items' ? Array < BinKitchenOrderItemGetPayload<S['select'][P]>>  :
        P extends '_count' ? BinKitchenMenuCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof BinKitchenMenu ? BinKitchenMenu[P] : never
  } 
      : BinKitchenMenu


  type BinKitchenMenuCountArgs = 
    Omit<BinKitchenMenuFindManyArgs, 'select' | 'include'> & {
      select?: BinKitchenMenuCountAggregateInputType | true
    }

  export interface BinKitchenMenuDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one BinKitchenMenu that matches the filter.
     * @param {BinKitchenMenuFindUniqueArgs} args - Arguments to find a BinKitchenMenu
     * @example
     * // Get one BinKitchenMenu
     * const binKitchenMenu = await prisma.binKitchenMenu.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BinKitchenMenuFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BinKitchenMenuFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BinKitchenMenu'> extends True ? Prisma__BinKitchenMenuClient<BinKitchenMenuGetPayload<T>> : Prisma__BinKitchenMenuClient<BinKitchenMenuGetPayload<T> | null, null>

    /**
     * Find one BinKitchenMenu that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BinKitchenMenuFindUniqueOrThrowArgs} args - Arguments to find a BinKitchenMenu
     * @example
     * // Get one BinKitchenMenu
     * const binKitchenMenu = await prisma.binKitchenMenu.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BinKitchenMenuFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BinKitchenMenuFindUniqueOrThrowArgs>
    ): Prisma__BinKitchenMenuClient<BinKitchenMenuGetPayload<T>>

    /**
     * Find the first BinKitchenMenu that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenMenuFindFirstArgs} args - Arguments to find a BinKitchenMenu
     * @example
     * // Get one BinKitchenMenu
     * const binKitchenMenu = await prisma.binKitchenMenu.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BinKitchenMenuFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BinKitchenMenuFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BinKitchenMenu'> extends True ? Prisma__BinKitchenMenuClient<BinKitchenMenuGetPayload<T>> : Prisma__BinKitchenMenuClient<BinKitchenMenuGetPayload<T> | null, null>

    /**
     * Find the first BinKitchenMenu that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenMenuFindFirstOrThrowArgs} args - Arguments to find a BinKitchenMenu
     * @example
     * // Get one BinKitchenMenu
     * const binKitchenMenu = await prisma.binKitchenMenu.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BinKitchenMenuFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BinKitchenMenuFindFirstOrThrowArgs>
    ): Prisma__BinKitchenMenuClient<BinKitchenMenuGetPayload<T>>

    /**
     * Find zero or more BinKitchenMenus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenMenuFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BinKitchenMenus
     * const binKitchenMenus = await prisma.binKitchenMenu.findMany()
     * 
     * // Get first 10 BinKitchenMenus
     * const binKitchenMenus = await prisma.binKitchenMenu.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const binKitchenMenuWithIdOnly = await prisma.binKitchenMenu.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BinKitchenMenuFindManyArgs>(
      args?: SelectSubset<T, BinKitchenMenuFindManyArgs>
    ): Prisma.PrismaPromise<Array<BinKitchenMenuGetPayload<T>>>

    /**
     * Create a BinKitchenMenu.
     * @param {BinKitchenMenuCreateArgs} args - Arguments to create a BinKitchenMenu.
     * @example
     * // Create one BinKitchenMenu
     * const BinKitchenMenu = await prisma.binKitchenMenu.create({
     *   data: {
     *     // ... data to create a BinKitchenMenu
     *   }
     * })
     * 
    **/
    create<T extends BinKitchenMenuCreateArgs>(
      args: SelectSubset<T, BinKitchenMenuCreateArgs>
    ): Prisma__BinKitchenMenuClient<BinKitchenMenuGetPayload<T>>

    /**
     * Create many BinKitchenMenus.
     *     @param {BinKitchenMenuCreateManyArgs} args - Arguments to create many BinKitchenMenus.
     *     @example
     *     // Create many BinKitchenMenus
     *     const binKitchenMenu = await prisma.binKitchenMenu.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BinKitchenMenuCreateManyArgs>(
      args?: SelectSubset<T, BinKitchenMenuCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BinKitchenMenu.
     * @param {BinKitchenMenuDeleteArgs} args - Arguments to delete one BinKitchenMenu.
     * @example
     * // Delete one BinKitchenMenu
     * const BinKitchenMenu = await prisma.binKitchenMenu.delete({
     *   where: {
     *     // ... filter to delete one BinKitchenMenu
     *   }
     * })
     * 
    **/
    delete<T extends BinKitchenMenuDeleteArgs>(
      args: SelectSubset<T, BinKitchenMenuDeleteArgs>
    ): Prisma__BinKitchenMenuClient<BinKitchenMenuGetPayload<T>>

    /**
     * Update one BinKitchenMenu.
     * @param {BinKitchenMenuUpdateArgs} args - Arguments to update one BinKitchenMenu.
     * @example
     * // Update one BinKitchenMenu
     * const binKitchenMenu = await prisma.binKitchenMenu.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BinKitchenMenuUpdateArgs>(
      args: SelectSubset<T, BinKitchenMenuUpdateArgs>
    ): Prisma__BinKitchenMenuClient<BinKitchenMenuGetPayload<T>>

    /**
     * Delete zero or more BinKitchenMenus.
     * @param {BinKitchenMenuDeleteManyArgs} args - Arguments to filter BinKitchenMenus to delete.
     * @example
     * // Delete a few BinKitchenMenus
     * const { count } = await prisma.binKitchenMenu.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BinKitchenMenuDeleteManyArgs>(
      args?: SelectSubset<T, BinKitchenMenuDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BinKitchenMenus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenMenuUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BinKitchenMenus
     * const binKitchenMenu = await prisma.binKitchenMenu.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BinKitchenMenuUpdateManyArgs>(
      args: SelectSubset<T, BinKitchenMenuUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BinKitchenMenu.
     * @param {BinKitchenMenuUpsertArgs} args - Arguments to update or create a BinKitchenMenu.
     * @example
     * // Update or create a BinKitchenMenu
     * const binKitchenMenu = await prisma.binKitchenMenu.upsert({
     *   create: {
     *     // ... data to create a BinKitchenMenu
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BinKitchenMenu we want to update
     *   }
     * })
    **/
    upsert<T extends BinKitchenMenuUpsertArgs>(
      args: SelectSubset<T, BinKitchenMenuUpsertArgs>
    ): Prisma__BinKitchenMenuClient<BinKitchenMenuGetPayload<T>>

    /**
     * Count the number of BinKitchenMenus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenMenuCountArgs} args - Arguments to filter BinKitchenMenus to count.
     * @example
     * // Count the number of BinKitchenMenus
     * const count = await prisma.binKitchenMenu.count({
     *   where: {
     *     // ... the filter for the BinKitchenMenus we want to count
     *   }
     * })
    **/
    count<T extends BinKitchenMenuCountArgs>(
      args?: Subset<T, BinKitchenMenuCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BinKitchenMenuCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BinKitchenMenu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenMenuAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BinKitchenMenuAggregateArgs>(args: Subset<T, BinKitchenMenuAggregateArgs>): Prisma.PrismaPromise<GetBinKitchenMenuAggregateType<T>>

    /**
     * Group by BinKitchenMenu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenMenuGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BinKitchenMenuGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BinKitchenMenuGroupByArgs['orderBy'] }
        : { orderBy?: BinKitchenMenuGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BinKitchenMenuGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBinKitchenMenuGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BinKitchenMenu.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BinKitchenMenuClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    category<T extends BinKitchenCategoryArgs= {}>(args?: Subset<T, BinKitchenCategoryArgs>): Prisma__BinKitchenCategoryClient<BinKitchenCategoryGetPayload<T> | Null>;

    items<T extends BinKitchenMenu$itemsArgs= {}>(args?: Subset<T, BinKitchenMenu$itemsArgs>): Prisma.PrismaPromise<Array<BinKitchenOrderItemGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BinKitchenMenu base type for findUnique actions
   */
  export type BinKitchenMenuFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BinKitchenMenu
     */
    select?: BinKitchenMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenMenuInclude | null
    /**
     * Filter, which BinKitchenMenu to fetch.
     */
    where: BinKitchenMenuWhereUniqueInput
  }

  /**
   * BinKitchenMenu findUnique
   */
  export interface BinKitchenMenuFindUniqueArgs extends BinKitchenMenuFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BinKitchenMenu findUniqueOrThrow
   */
  export type BinKitchenMenuFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenMenu
     */
    select?: BinKitchenMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenMenuInclude | null
    /**
     * Filter, which BinKitchenMenu to fetch.
     */
    where: BinKitchenMenuWhereUniqueInput
  }


  /**
   * BinKitchenMenu base type for findFirst actions
   */
  export type BinKitchenMenuFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BinKitchenMenu
     */
    select?: BinKitchenMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenMenuInclude | null
    /**
     * Filter, which BinKitchenMenu to fetch.
     */
    where?: BinKitchenMenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BinKitchenMenus to fetch.
     */
    orderBy?: Enumerable<BinKitchenMenuOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BinKitchenMenus.
     */
    cursor?: BinKitchenMenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BinKitchenMenus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BinKitchenMenus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BinKitchenMenus.
     */
    distinct?: Enumerable<BinKitchenMenuScalarFieldEnum>
  }

  /**
   * BinKitchenMenu findFirst
   */
  export interface BinKitchenMenuFindFirstArgs extends BinKitchenMenuFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BinKitchenMenu findFirstOrThrow
   */
  export type BinKitchenMenuFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenMenu
     */
    select?: BinKitchenMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenMenuInclude | null
    /**
     * Filter, which BinKitchenMenu to fetch.
     */
    where?: BinKitchenMenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BinKitchenMenus to fetch.
     */
    orderBy?: Enumerable<BinKitchenMenuOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BinKitchenMenus.
     */
    cursor?: BinKitchenMenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BinKitchenMenus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BinKitchenMenus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BinKitchenMenus.
     */
    distinct?: Enumerable<BinKitchenMenuScalarFieldEnum>
  }


  /**
   * BinKitchenMenu findMany
   */
  export type BinKitchenMenuFindManyArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenMenu
     */
    select?: BinKitchenMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenMenuInclude | null
    /**
     * Filter, which BinKitchenMenus to fetch.
     */
    where?: BinKitchenMenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BinKitchenMenus to fetch.
     */
    orderBy?: Enumerable<BinKitchenMenuOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BinKitchenMenus.
     */
    cursor?: BinKitchenMenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BinKitchenMenus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BinKitchenMenus.
     */
    skip?: number
    distinct?: Enumerable<BinKitchenMenuScalarFieldEnum>
  }


  /**
   * BinKitchenMenu create
   */
  export type BinKitchenMenuCreateArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenMenu
     */
    select?: BinKitchenMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenMenuInclude | null
    /**
     * The data needed to create a BinKitchenMenu.
     */
    data: XOR<BinKitchenMenuCreateInput, BinKitchenMenuUncheckedCreateInput>
  }


  /**
   * BinKitchenMenu createMany
   */
  export type BinKitchenMenuCreateManyArgs = {
    /**
     * The data used to create many BinKitchenMenus.
     */
    data: Enumerable<BinKitchenMenuCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BinKitchenMenu update
   */
  export type BinKitchenMenuUpdateArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenMenu
     */
    select?: BinKitchenMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenMenuInclude | null
    /**
     * The data needed to update a BinKitchenMenu.
     */
    data: XOR<BinKitchenMenuUpdateInput, BinKitchenMenuUncheckedUpdateInput>
    /**
     * Choose, which BinKitchenMenu to update.
     */
    where: BinKitchenMenuWhereUniqueInput
  }


  /**
   * BinKitchenMenu updateMany
   */
  export type BinKitchenMenuUpdateManyArgs = {
    /**
     * The data used to update BinKitchenMenus.
     */
    data: XOR<BinKitchenMenuUpdateManyMutationInput, BinKitchenMenuUncheckedUpdateManyInput>
    /**
     * Filter which BinKitchenMenus to update
     */
    where?: BinKitchenMenuWhereInput
  }


  /**
   * BinKitchenMenu upsert
   */
  export type BinKitchenMenuUpsertArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenMenu
     */
    select?: BinKitchenMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenMenuInclude | null
    /**
     * The filter to search for the BinKitchenMenu to update in case it exists.
     */
    where: BinKitchenMenuWhereUniqueInput
    /**
     * In case the BinKitchenMenu found by the `where` argument doesn't exist, create a new BinKitchenMenu with this data.
     */
    create: XOR<BinKitchenMenuCreateInput, BinKitchenMenuUncheckedCreateInput>
    /**
     * In case the BinKitchenMenu was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BinKitchenMenuUpdateInput, BinKitchenMenuUncheckedUpdateInput>
  }


  /**
   * BinKitchenMenu delete
   */
  export type BinKitchenMenuDeleteArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenMenu
     */
    select?: BinKitchenMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenMenuInclude | null
    /**
     * Filter which BinKitchenMenu to delete.
     */
    where: BinKitchenMenuWhereUniqueInput
  }


  /**
   * BinKitchenMenu deleteMany
   */
  export type BinKitchenMenuDeleteManyArgs = {
    /**
     * Filter which BinKitchenMenus to delete
     */
    where?: BinKitchenMenuWhereInput
  }


  /**
   * BinKitchenMenu.items
   */
  export type BinKitchenMenu$itemsArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenOrderItem
     */
    select?: BinKitchenOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenOrderItemInclude | null
    where?: BinKitchenOrderItemWhereInput
    orderBy?: Enumerable<BinKitchenOrderItemOrderByWithRelationInput>
    cursor?: BinKitchenOrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BinKitchenOrderItemScalarFieldEnum>
  }


  /**
   * BinKitchenMenu without action
   */
  export type BinKitchenMenuArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenMenu
     */
    select?: BinKitchenMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenMenuInclude | null
  }



  /**
   * Model BinKitchenOrder
   */


  export type AggregateBinKitchenOrder = {
    _count: BinKitchenOrderCountAggregateOutputType | null
    _avg: BinKitchenOrderAvgAggregateOutputType | null
    _sum: BinKitchenOrderSumAggregateOutputType | null
    _min: BinKitchenOrderMinAggregateOutputType | null
    _max: BinKitchenOrderMaxAggregateOutputType | null
  }

  export type BinKitchenOrderAvgAggregateOutputType = {
    id: number | null
    tableId: number | null
  }

  export type BinKitchenOrderSumAggregateOutputType = {
    id: number | null
    tableId: number | null
  }

  export type BinKitchenOrderMinAggregateOutputType = {
    id: number | null
    tableId: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BinKitchenOrderMaxAggregateOutputType = {
    id: number | null
    tableId: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BinKitchenOrderCountAggregateOutputType = {
    id: number
    tableId: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BinKitchenOrderAvgAggregateInputType = {
    id?: true
    tableId?: true
  }

  export type BinKitchenOrderSumAggregateInputType = {
    id?: true
    tableId?: true
  }

  export type BinKitchenOrderMinAggregateInputType = {
    id?: true
    tableId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BinKitchenOrderMaxAggregateInputType = {
    id?: true
    tableId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BinKitchenOrderCountAggregateInputType = {
    id?: true
    tableId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BinKitchenOrderAggregateArgs = {
    /**
     * Filter which BinKitchenOrder to aggregate.
     */
    where?: BinKitchenOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BinKitchenOrders to fetch.
     */
    orderBy?: Enumerable<BinKitchenOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BinKitchenOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BinKitchenOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BinKitchenOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BinKitchenOrders
    **/
    _count?: true | BinKitchenOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BinKitchenOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BinKitchenOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BinKitchenOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BinKitchenOrderMaxAggregateInputType
  }

  export type GetBinKitchenOrderAggregateType<T extends BinKitchenOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateBinKitchenOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBinKitchenOrder[P]>
      : GetScalarType<T[P], AggregateBinKitchenOrder[P]>
  }




  export type BinKitchenOrderGroupByArgs = {
    where?: BinKitchenOrderWhereInput
    orderBy?: Enumerable<BinKitchenOrderOrderByWithAggregationInput>
    by: BinKitchenOrderScalarFieldEnum[]
    having?: BinKitchenOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BinKitchenOrderCountAggregateInputType | true
    _avg?: BinKitchenOrderAvgAggregateInputType
    _sum?: BinKitchenOrderSumAggregateInputType
    _min?: BinKitchenOrderMinAggregateInputType
    _max?: BinKitchenOrderMaxAggregateInputType
  }


  export type BinKitchenOrderGroupByOutputType = {
    id: number
    tableId: number
    status: string
    createdAt: Date
    updatedAt: Date
    _count: BinKitchenOrderCountAggregateOutputType | null
    _avg: BinKitchenOrderAvgAggregateOutputType | null
    _sum: BinKitchenOrderSumAggregateOutputType | null
    _min: BinKitchenOrderMinAggregateOutputType | null
    _max: BinKitchenOrderMaxAggregateOutputType | null
  }

  type GetBinKitchenOrderGroupByPayload<T extends BinKitchenOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BinKitchenOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BinKitchenOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BinKitchenOrderGroupByOutputType[P]>
            : GetScalarType<T[P], BinKitchenOrderGroupByOutputType[P]>
        }
      >
    >


  export type BinKitchenOrderSelect = {
    id?: boolean
    tableId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    items?: boolean | BinKitchenOrder$itemsArgs
    _count?: boolean | BinKitchenOrderCountOutputTypeArgs
  }


  export type BinKitchenOrderInclude = {
    items?: boolean | BinKitchenOrder$itemsArgs
    _count?: boolean | BinKitchenOrderCountOutputTypeArgs
  }

  export type BinKitchenOrderGetPayload<S extends boolean | null | undefined | BinKitchenOrderArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BinKitchenOrder :
    S extends undefined ? never :
    S extends { include: any } & (BinKitchenOrderArgs | BinKitchenOrderFindManyArgs)
    ? BinKitchenOrder  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'items' ? Array < BinKitchenOrderItemGetPayload<S['include'][P]>>  :
        P extends '_count' ? BinKitchenOrderCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BinKitchenOrderArgs | BinKitchenOrderFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'items' ? Array < BinKitchenOrderItemGetPayload<S['select'][P]>>  :
        P extends '_count' ? BinKitchenOrderCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof BinKitchenOrder ? BinKitchenOrder[P] : never
  } 
      : BinKitchenOrder


  type BinKitchenOrderCountArgs = 
    Omit<BinKitchenOrderFindManyArgs, 'select' | 'include'> & {
      select?: BinKitchenOrderCountAggregateInputType | true
    }

  export interface BinKitchenOrderDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one BinKitchenOrder that matches the filter.
     * @param {BinKitchenOrderFindUniqueArgs} args - Arguments to find a BinKitchenOrder
     * @example
     * // Get one BinKitchenOrder
     * const binKitchenOrder = await prisma.binKitchenOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BinKitchenOrderFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BinKitchenOrderFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BinKitchenOrder'> extends True ? Prisma__BinKitchenOrderClient<BinKitchenOrderGetPayload<T>> : Prisma__BinKitchenOrderClient<BinKitchenOrderGetPayload<T> | null, null>

    /**
     * Find one BinKitchenOrder that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BinKitchenOrderFindUniqueOrThrowArgs} args - Arguments to find a BinKitchenOrder
     * @example
     * // Get one BinKitchenOrder
     * const binKitchenOrder = await prisma.binKitchenOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BinKitchenOrderFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BinKitchenOrderFindUniqueOrThrowArgs>
    ): Prisma__BinKitchenOrderClient<BinKitchenOrderGetPayload<T>>

    /**
     * Find the first BinKitchenOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenOrderFindFirstArgs} args - Arguments to find a BinKitchenOrder
     * @example
     * // Get one BinKitchenOrder
     * const binKitchenOrder = await prisma.binKitchenOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BinKitchenOrderFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BinKitchenOrderFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BinKitchenOrder'> extends True ? Prisma__BinKitchenOrderClient<BinKitchenOrderGetPayload<T>> : Prisma__BinKitchenOrderClient<BinKitchenOrderGetPayload<T> | null, null>

    /**
     * Find the first BinKitchenOrder that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenOrderFindFirstOrThrowArgs} args - Arguments to find a BinKitchenOrder
     * @example
     * // Get one BinKitchenOrder
     * const binKitchenOrder = await prisma.binKitchenOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BinKitchenOrderFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BinKitchenOrderFindFirstOrThrowArgs>
    ): Prisma__BinKitchenOrderClient<BinKitchenOrderGetPayload<T>>

    /**
     * Find zero or more BinKitchenOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenOrderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BinKitchenOrders
     * const binKitchenOrders = await prisma.binKitchenOrder.findMany()
     * 
     * // Get first 10 BinKitchenOrders
     * const binKitchenOrders = await prisma.binKitchenOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const binKitchenOrderWithIdOnly = await prisma.binKitchenOrder.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BinKitchenOrderFindManyArgs>(
      args?: SelectSubset<T, BinKitchenOrderFindManyArgs>
    ): Prisma.PrismaPromise<Array<BinKitchenOrderGetPayload<T>>>

    /**
     * Create a BinKitchenOrder.
     * @param {BinKitchenOrderCreateArgs} args - Arguments to create a BinKitchenOrder.
     * @example
     * // Create one BinKitchenOrder
     * const BinKitchenOrder = await prisma.binKitchenOrder.create({
     *   data: {
     *     // ... data to create a BinKitchenOrder
     *   }
     * })
     * 
    **/
    create<T extends BinKitchenOrderCreateArgs>(
      args: SelectSubset<T, BinKitchenOrderCreateArgs>
    ): Prisma__BinKitchenOrderClient<BinKitchenOrderGetPayload<T>>

    /**
     * Create many BinKitchenOrders.
     *     @param {BinKitchenOrderCreateManyArgs} args - Arguments to create many BinKitchenOrders.
     *     @example
     *     // Create many BinKitchenOrders
     *     const binKitchenOrder = await prisma.binKitchenOrder.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BinKitchenOrderCreateManyArgs>(
      args?: SelectSubset<T, BinKitchenOrderCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BinKitchenOrder.
     * @param {BinKitchenOrderDeleteArgs} args - Arguments to delete one BinKitchenOrder.
     * @example
     * // Delete one BinKitchenOrder
     * const BinKitchenOrder = await prisma.binKitchenOrder.delete({
     *   where: {
     *     // ... filter to delete one BinKitchenOrder
     *   }
     * })
     * 
    **/
    delete<T extends BinKitchenOrderDeleteArgs>(
      args: SelectSubset<T, BinKitchenOrderDeleteArgs>
    ): Prisma__BinKitchenOrderClient<BinKitchenOrderGetPayload<T>>

    /**
     * Update one BinKitchenOrder.
     * @param {BinKitchenOrderUpdateArgs} args - Arguments to update one BinKitchenOrder.
     * @example
     * // Update one BinKitchenOrder
     * const binKitchenOrder = await prisma.binKitchenOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BinKitchenOrderUpdateArgs>(
      args: SelectSubset<T, BinKitchenOrderUpdateArgs>
    ): Prisma__BinKitchenOrderClient<BinKitchenOrderGetPayload<T>>

    /**
     * Delete zero or more BinKitchenOrders.
     * @param {BinKitchenOrderDeleteManyArgs} args - Arguments to filter BinKitchenOrders to delete.
     * @example
     * // Delete a few BinKitchenOrders
     * const { count } = await prisma.binKitchenOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BinKitchenOrderDeleteManyArgs>(
      args?: SelectSubset<T, BinKitchenOrderDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BinKitchenOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BinKitchenOrders
     * const binKitchenOrder = await prisma.binKitchenOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BinKitchenOrderUpdateManyArgs>(
      args: SelectSubset<T, BinKitchenOrderUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BinKitchenOrder.
     * @param {BinKitchenOrderUpsertArgs} args - Arguments to update or create a BinKitchenOrder.
     * @example
     * // Update or create a BinKitchenOrder
     * const binKitchenOrder = await prisma.binKitchenOrder.upsert({
     *   create: {
     *     // ... data to create a BinKitchenOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BinKitchenOrder we want to update
     *   }
     * })
    **/
    upsert<T extends BinKitchenOrderUpsertArgs>(
      args: SelectSubset<T, BinKitchenOrderUpsertArgs>
    ): Prisma__BinKitchenOrderClient<BinKitchenOrderGetPayload<T>>

    /**
     * Count the number of BinKitchenOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenOrderCountArgs} args - Arguments to filter BinKitchenOrders to count.
     * @example
     * // Count the number of BinKitchenOrders
     * const count = await prisma.binKitchenOrder.count({
     *   where: {
     *     // ... the filter for the BinKitchenOrders we want to count
     *   }
     * })
    **/
    count<T extends BinKitchenOrderCountArgs>(
      args?: Subset<T, BinKitchenOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BinKitchenOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BinKitchenOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BinKitchenOrderAggregateArgs>(args: Subset<T, BinKitchenOrderAggregateArgs>): Prisma.PrismaPromise<GetBinKitchenOrderAggregateType<T>>

    /**
     * Group by BinKitchenOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BinKitchenOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BinKitchenOrderGroupByArgs['orderBy'] }
        : { orderBy?: BinKitchenOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BinKitchenOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBinKitchenOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BinKitchenOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BinKitchenOrderClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    items<T extends BinKitchenOrder$itemsArgs= {}>(args?: Subset<T, BinKitchenOrder$itemsArgs>): Prisma.PrismaPromise<Array<BinKitchenOrderItemGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BinKitchenOrder base type for findUnique actions
   */
  export type BinKitchenOrderFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BinKitchenOrder
     */
    select?: BinKitchenOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenOrderInclude | null
    /**
     * Filter, which BinKitchenOrder to fetch.
     */
    where: BinKitchenOrderWhereUniqueInput
  }

  /**
   * BinKitchenOrder findUnique
   */
  export interface BinKitchenOrderFindUniqueArgs extends BinKitchenOrderFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BinKitchenOrder findUniqueOrThrow
   */
  export type BinKitchenOrderFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenOrder
     */
    select?: BinKitchenOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenOrderInclude | null
    /**
     * Filter, which BinKitchenOrder to fetch.
     */
    where: BinKitchenOrderWhereUniqueInput
  }


  /**
   * BinKitchenOrder base type for findFirst actions
   */
  export type BinKitchenOrderFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BinKitchenOrder
     */
    select?: BinKitchenOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenOrderInclude | null
    /**
     * Filter, which BinKitchenOrder to fetch.
     */
    where?: BinKitchenOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BinKitchenOrders to fetch.
     */
    orderBy?: Enumerable<BinKitchenOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BinKitchenOrders.
     */
    cursor?: BinKitchenOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BinKitchenOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BinKitchenOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BinKitchenOrders.
     */
    distinct?: Enumerable<BinKitchenOrderScalarFieldEnum>
  }

  /**
   * BinKitchenOrder findFirst
   */
  export interface BinKitchenOrderFindFirstArgs extends BinKitchenOrderFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BinKitchenOrder findFirstOrThrow
   */
  export type BinKitchenOrderFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenOrder
     */
    select?: BinKitchenOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenOrderInclude | null
    /**
     * Filter, which BinKitchenOrder to fetch.
     */
    where?: BinKitchenOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BinKitchenOrders to fetch.
     */
    orderBy?: Enumerable<BinKitchenOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BinKitchenOrders.
     */
    cursor?: BinKitchenOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BinKitchenOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BinKitchenOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BinKitchenOrders.
     */
    distinct?: Enumerable<BinKitchenOrderScalarFieldEnum>
  }


  /**
   * BinKitchenOrder findMany
   */
  export type BinKitchenOrderFindManyArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenOrder
     */
    select?: BinKitchenOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenOrderInclude | null
    /**
     * Filter, which BinKitchenOrders to fetch.
     */
    where?: BinKitchenOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BinKitchenOrders to fetch.
     */
    orderBy?: Enumerable<BinKitchenOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BinKitchenOrders.
     */
    cursor?: BinKitchenOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BinKitchenOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BinKitchenOrders.
     */
    skip?: number
    distinct?: Enumerable<BinKitchenOrderScalarFieldEnum>
  }


  /**
   * BinKitchenOrder create
   */
  export type BinKitchenOrderCreateArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenOrder
     */
    select?: BinKitchenOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenOrderInclude | null
    /**
     * The data needed to create a BinKitchenOrder.
     */
    data: XOR<BinKitchenOrderCreateInput, BinKitchenOrderUncheckedCreateInput>
  }


  /**
   * BinKitchenOrder createMany
   */
  export type BinKitchenOrderCreateManyArgs = {
    /**
     * The data used to create many BinKitchenOrders.
     */
    data: Enumerable<BinKitchenOrderCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BinKitchenOrder update
   */
  export type BinKitchenOrderUpdateArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenOrder
     */
    select?: BinKitchenOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenOrderInclude | null
    /**
     * The data needed to update a BinKitchenOrder.
     */
    data: XOR<BinKitchenOrderUpdateInput, BinKitchenOrderUncheckedUpdateInput>
    /**
     * Choose, which BinKitchenOrder to update.
     */
    where: BinKitchenOrderWhereUniqueInput
  }


  /**
   * BinKitchenOrder updateMany
   */
  export type BinKitchenOrderUpdateManyArgs = {
    /**
     * The data used to update BinKitchenOrders.
     */
    data: XOR<BinKitchenOrderUpdateManyMutationInput, BinKitchenOrderUncheckedUpdateManyInput>
    /**
     * Filter which BinKitchenOrders to update
     */
    where?: BinKitchenOrderWhereInput
  }


  /**
   * BinKitchenOrder upsert
   */
  export type BinKitchenOrderUpsertArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenOrder
     */
    select?: BinKitchenOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenOrderInclude | null
    /**
     * The filter to search for the BinKitchenOrder to update in case it exists.
     */
    where: BinKitchenOrderWhereUniqueInput
    /**
     * In case the BinKitchenOrder found by the `where` argument doesn't exist, create a new BinKitchenOrder with this data.
     */
    create: XOR<BinKitchenOrderCreateInput, BinKitchenOrderUncheckedCreateInput>
    /**
     * In case the BinKitchenOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BinKitchenOrderUpdateInput, BinKitchenOrderUncheckedUpdateInput>
  }


  /**
   * BinKitchenOrder delete
   */
  export type BinKitchenOrderDeleteArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenOrder
     */
    select?: BinKitchenOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenOrderInclude | null
    /**
     * Filter which BinKitchenOrder to delete.
     */
    where: BinKitchenOrderWhereUniqueInput
  }


  /**
   * BinKitchenOrder deleteMany
   */
  export type BinKitchenOrderDeleteManyArgs = {
    /**
     * Filter which BinKitchenOrders to delete
     */
    where?: BinKitchenOrderWhereInput
  }


  /**
   * BinKitchenOrder.items
   */
  export type BinKitchenOrder$itemsArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenOrderItem
     */
    select?: BinKitchenOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenOrderItemInclude | null
    where?: BinKitchenOrderItemWhereInput
    orderBy?: Enumerable<BinKitchenOrderItemOrderByWithRelationInput>
    cursor?: BinKitchenOrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BinKitchenOrderItemScalarFieldEnum>
  }


  /**
   * BinKitchenOrder without action
   */
  export type BinKitchenOrderArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenOrder
     */
    select?: BinKitchenOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenOrderInclude | null
  }



  /**
   * Model BinKitchenOrderItem
   */


  export type AggregateBinKitchenOrderItem = {
    _count: BinKitchenOrderItemCountAggregateOutputType | null
    _avg: BinKitchenOrderItemAvgAggregateOutputType | null
    _sum: BinKitchenOrderItemSumAggregateOutputType | null
    _min: BinKitchenOrderItemMinAggregateOutputType | null
    _max: BinKitchenOrderItemMaxAggregateOutputType | null
  }

  export type BinKitchenOrderItemAvgAggregateOutputType = {
    id: number | null
    quantity: number | null
    totalPrice: number | null
    menuId: number | null
    orderId: number | null
  }

  export type BinKitchenOrderItemSumAggregateOutputType = {
    id: number | null
    quantity: number | null
    totalPrice: number | null
    menuId: number | null
    orderId: number | null
  }

  export type BinKitchenOrderItemMinAggregateOutputType = {
    id: number | null
    quantity: number | null
    totalPrice: number | null
    createdAt: Date | null
    updatedAt: Date | null
    menuId: number | null
    orderId: number | null
  }

  export type BinKitchenOrderItemMaxAggregateOutputType = {
    id: number | null
    quantity: number | null
    totalPrice: number | null
    createdAt: Date | null
    updatedAt: Date | null
    menuId: number | null
    orderId: number | null
  }

  export type BinKitchenOrderItemCountAggregateOutputType = {
    id: number
    quantity: number
    totalPrice: number
    createdAt: number
    updatedAt: number
    menuId: number
    orderId: number
    _all: number
  }


  export type BinKitchenOrderItemAvgAggregateInputType = {
    id?: true
    quantity?: true
    totalPrice?: true
    menuId?: true
    orderId?: true
  }

  export type BinKitchenOrderItemSumAggregateInputType = {
    id?: true
    quantity?: true
    totalPrice?: true
    menuId?: true
    orderId?: true
  }

  export type BinKitchenOrderItemMinAggregateInputType = {
    id?: true
    quantity?: true
    totalPrice?: true
    createdAt?: true
    updatedAt?: true
    menuId?: true
    orderId?: true
  }

  export type BinKitchenOrderItemMaxAggregateInputType = {
    id?: true
    quantity?: true
    totalPrice?: true
    createdAt?: true
    updatedAt?: true
    menuId?: true
    orderId?: true
  }

  export type BinKitchenOrderItemCountAggregateInputType = {
    id?: true
    quantity?: true
    totalPrice?: true
    createdAt?: true
    updatedAt?: true
    menuId?: true
    orderId?: true
    _all?: true
  }

  export type BinKitchenOrderItemAggregateArgs = {
    /**
     * Filter which BinKitchenOrderItem to aggregate.
     */
    where?: BinKitchenOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BinKitchenOrderItems to fetch.
     */
    orderBy?: Enumerable<BinKitchenOrderItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BinKitchenOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BinKitchenOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BinKitchenOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BinKitchenOrderItems
    **/
    _count?: true | BinKitchenOrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BinKitchenOrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BinKitchenOrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BinKitchenOrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BinKitchenOrderItemMaxAggregateInputType
  }

  export type GetBinKitchenOrderItemAggregateType<T extends BinKitchenOrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateBinKitchenOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBinKitchenOrderItem[P]>
      : GetScalarType<T[P], AggregateBinKitchenOrderItem[P]>
  }




  export type BinKitchenOrderItemGroupByArgs = {
    where?: BinKitchenOrderItemWhereInput
    orderBy?: Enumerable<BinKitchenOrderItemOrderByWithAggregationInput>
    by: BinKitchenOrderItemScalarFieldEnum[]
    having?: BinKitchenOrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BinKitchenOrderItemCountAggregateInputType | true
    _avg?: BinKitchenOrderItemAvgAggregateInputType
    _sum?: BinKitchenOrderItemSumAggregateInputType
    _min?: BinKitchenOrderItemMinAggregateInputType
    _max?: BinKitchenOrderItemMaxAggregateInputType
  }


  export type BinKitchenOrderItemGroupByOutputType = {
    id: number
    quantity: number
    totalPrice: number
    createdAt: Date
    updatedAt: Date
    menuId: number
    orderId: number
    _count: BinKitchenOrderItemCountAggregateOutputType | null
    _avg: BinKitchenOrderItemAvgAggregateOutputType | null
    _sum: BinKitchenOrderItemSumAggregateOutputType | null
    _min: BinKitchenOrderItemMinAggregateOutputType | null
    _max: BinKitchenOrderItemMaxAggregateOutputType | null
  }

  type GetBinKitchenOrderItemGroupByPayload<T extends BinKitchenOrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BinKitchenOrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BinKitchenOrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BinKitchenOrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], BinKitchenOrderItemGroupByOutputType[P]>
        }
      >
    >


  export type BinKitchenOrderItemSelect = {
    id?: boolean
    menu?: boolean | BinKitchenMenuArgs
    order?: boolean | BinKitchenOrderArgs
    quantity?: boolean
    totalPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    menuId?: boolean
    orderId?: boolean
  }


  export type BinKitchenOrderItemInclude = {
    menu?: boolean | BinKitchenMenuArgs
    order?: boolean | BinKitchenOrderArgs
  }

  export type BinKitchenOrderItemGetPayload<S extends boolean | null | undefined | BinKitchenOrderItemArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BinKitchenOrderItem :
    S extends undefined ? never :
    S extends { include: any } & (BinKitchenOrderItemArgs | BinKitchenOrderItemFindManyArgs)
    ? BinKitchenOrderItem  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'menu' ? BinKitchenMenuGetPayload<S['include'][P]> :
        P extends 'order' ? BinKitchenOrderGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BinKitchenOrderItemArgs | BinKitchenOrderItemFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'menu' ? BinKitchenMenuGetPayload<S['select'][P]> :
        P extends 'order' ? BinKitchenOrderGetPayload<S['select'][P]> :  P extends keyof BinKitchenOrderItem ? BinKitchenOrderItem[P] : never
  } 
      : BinKitchenOrderItem


  type BinKitchenOrderItemCountArgs = 
    Omit<BinKitchenOrderItemFindManyArgs, 'select' | 'include'> & {
      select?: BinKitchenOrderItemCountAggregateInputType | true
    }

  export interface BinKitchenOrderItemDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one BinKitchenOrderItem that matches the filter.
     * @param {BinKitchenOrderItemFindUniqueArgs} args - Arguments to find a BinKitchenOrderItem
     * @example
     * // Get one BinKitchenOrderItem
     * const binKitchenOrderItem = await prisma.binKitchenOrderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BinKitchenOrderItemFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BinKitchenOrderItemFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BinKitchenOrderItem'> extends True ? Prisma__BinKitchenOrderItemClient<BinKitchenOrderItemGetPayload<T>> : Prisma__BinKitchenOrderItemClient<BinKitchenOrderItemGetPayload<T> | null, null>

    /**
     * Find one BinKitchenOrderItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BinKitchenOrderItemFindUniqueOrThrowArgs} args - Arguments to find a BinKitchenOrderItem
     * @example
     * // Get one BinKitchenOrderItem
     * const binKitchenOrderItem = await prisma.binKitchenOrderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BinKitchenOrderItemFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BinKitchenOrderItemFindUniqueOrThrowArgs>
    ): Prisma__BinKitchenOrderItemClient<BinKitchenOrderItemGetPayload<T>>

    /**
     * Find the first BinKitchenOrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenOrderItemFindFirstArgs} args - Arguments to find a BinKitchenOrderItem
     * @example
     * // Get one BinKitchenOrderItem
     * const binKitchenOrderItem = await prisma.binKitchenOrderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BinKitchenOrderItemFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BinKitchenOrderItemFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BinKitchenOrderItem'> extends True ? Prisma__BinKitchenOrderItemClient<BinKitchenOrderItemGetPayload<T>> : Prisma__BinKitchenOrderItemClient<BinKitchenOrderItemGetPayload<T> | null, null>

    /**
     * Find the first BinKitchenOrderItem that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenOrderItemFindFirstOrThrowArgs} args - Arguments to find a BinKitchenOrderItem
     * @example
     * // Get one BinKitchenOrderItem
     * const binKitchenOrderItem = await prisma.binKitchenOrderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BinKitchenOrderItemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BinKitchenOrderItemFindFirstOrThrowArgs>
    ): Prisma__BinKitchenOrderItemClient<BinKitchenOrderItemGetPayload<T>>

    /**
     * Find zero or more BinKitchenOrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenOrderItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BinKitchenOrderItems
     * const binKitchenOrderItems = await prisma.binKitchenOrderItem.findMany()
     * 
     * // Get first 10 BinKitchenOrderItems
     * const binKitchenOrderItems = await prisma.binKitchenOrderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const binKitchenOrderItemWithIdOnly = await prisma.binKitchenOrderItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BinKitchenOrderItemFindManyArgs>(
      args?: SelectSubset<T, BinKitchenOrderItemFindManyArgs>
    ): Prisma.PrismaPromise<Array<BinKitchenOrderItemGetPayload<T>>>

    /**
     * Create a BinKitchenOrderItem.
     * @param {BinKitchenOrderItemCreateArgs} args - Arguments to create a BinKitchenOrderItem.
     * @example
     * // Create one BinKitchenOrderItem
     * const BinKitchenOrderItem = await prisma.binKitchenOrderItem.create({
     *   data: {
     *     // ... data to create a BinKitchenOrderItem
     *   }
     * })
     * 
    **/
    create<T extends BinKitchenOrderItemCreateArgs>(
      args: SelectSubset<T, BinKitchenOrderItemCreateArgs>
    ): Prisma__BinKitchenOrderItemClient<BinKitchenOrderItemGetPayload<T>>

    /**
     * Create many BinKitchenOrderItems.
     *     @param {BinKitchenOrderItemCreateManyArgs} args - Arguments to create many BinKitchenOrderItems.
     *     @example
     *     // Create many BinKitchenOrderItems
     *     const binKitchenOrderItem = await prisma.binKitchenOrderItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BinKitchenOrderItemCreateManyArgs>(
      args?: SelectSubset<T, BinKitchenOrderItemCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BinKitchenOrderItem.
     * @param {BinKitchenOrderItemDeleteArgs} args - Arguments to delete one BinKitchenOrderItem.
     * @example
     * // Delete one BinKitchenOrderItem
     * const BinKitchenOrderItem = await prisma.binKitchenOrderItem.delete({
     *   where: {
     *     // ... filter to delete one BinKitchenOrderItem
     *   }
     * })
     * 
    **/
    delete<T extends BinKitchenOrderItemDeleteArgs>(
      args: SelectSubset<T, BinKitchenOrderItemDeleteArgs>
    ): Prisma__BinKitchenOrderItemClient<BinKitchenOrderItemGetPayload<T>>

    /**
     * Update one BinKitchenOrderItem.
     * @param {BinKitchenOrderItemUpdateArgs} args - Arguments to update one BinKitchenOrderItem.
     * @example
     * // Update one BinKitchenOrderItem
     * const binKitchenOrderItem = await prisma.binKitchenOrderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BinKitchenOrderItemUpdateArgs>(
      args: SelectSubset<T, BinKitchenOrderItemUpdateArgs>
    ): Prisma__BinKitchenOrderItemClient<BinKitchenOrderItemGetPayload<T>>

    /**
     * Delete zero or more BinKitchenOrderItems.
     * @param {BinKitchenOrderItemDeleteManyArgs} args - Arguments to filter BinKitchenOrderItems to delete.
     * @example
     * // Delete a few BinKitchenOrderItems
     * const { count } = await prisma.binKitchenOrderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BinKitchenOrderItemDeleteManyArgs>(
      args?: SelectSubset<T, BinKitchenOrderItemDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BinKitchenOrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenOrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BinKitchenOrderItems
     * const binKitchenOrderItem = await prisma.binKitchenOrderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BinKitchenOrderItemUpdateManyArgs>(
      args: SelectSubset<T, BinKitchenOrderItemUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BinKitchenOrderItem.
     * @param {BinKitchenOrderItemUpsertArgs} args - Arguments to update or create a BinKitchenOrderItem.
     * @example
     * // Update or create a BinKitchenOrderItem
     * const binKitchenOrderItem = await prisma.binKitchenOrderItem.upsert({
     *   create: {
     *     // ... data to create a BinKitchenOrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BinKitchenOrderItem we want to update
     *   }
     * })
    **/
    upsert<T extends BinKitchenOrderItemUpsertArgs>(
      args: SelectSubset<T, BinKitchenOrderItemUpsertArgs>
    ): Prisma__BinKitchenOrderItemClient<BinKitchenOrderItemGetPayload<T>>

    /**
     * Count the number of BinKitchenOrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenOrderItemCountArgs} args - Arguments to filter BinKitchenOrderItems to count.
     * @example
     * // Count the number of BinKitchenOrderItems
     * const count = await prisma.binKitchenOrderItem.count({
     *   where: {
     *     // ... the filter for the BinKitchenOrderItems we want to count
     *   }
     * })
    **/
    count<T extends BinKitchenOrderItemCountArgs>(
      args?: Subset<T, BinKitchenOrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BinKitchenOrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BinKitchenOrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenOrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BinKitchenOrderItemAggregateArgs>(args: Subset<T, BinKitchenOrderItemAggregateArgs>): Prisma.PrismaPromise<GetBinKitchenOrderItemAggregateType<T>>

    /**
     * Group by BinKitchenOrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenOrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BinKitchenOrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BinKitchenOrderItemGroupByArgs['orderBy'] }
        : { orderBy?: BinKitchenOrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BinKitchenOrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBinKitchenOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BinKitchenOrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BinKitchenOrderItemClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    menu<T extends BinKitchenMenuArgs= {}>(args?: Subset<T, BinKitchenMenuArgs>): Prisma__BinKitchenMenuClient<BinKitchenMenuGetPayload<T> | Null>;

    order<T extends BinKitchenOrderArgs= {}>(args?: Subset<T, BinKitchenOrderArgs>): Prisma__BinKitchenOrderClient<BinKitchenOrderGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BinKitchenOrderItem base type for findUnique actions
   */
  export type BinKitchenOrderItemFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BinKitchenOrderItem
     */
    select?: BinKitchenOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenOrderItemInclude | null
    /**
     * Filter, which BinKitchenOrderItem to fetch.
     */
    where: BinKitchenOrderItemWhereUniqueInput
  }

  /**
   * BinKitchenOrderItem findUnique
   */
  export interface BinKitchenOrderItemFindUniqueArgs extends BinKitchenOrderItemFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BinKitchenOrderItem findUniqueOrThrow
   */
  export type BinKitchenOrderItemFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenOrderItem
     */
    select?: BinKitchenOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenOrderItemInclude | null
    /**
     * Filter, which BinKitchenOrderItem to fetch.
     */
    where: BinKitchenOrderItemWhereUniqueInput
  }


  /**
   * BinKitchenOrderItem base type for findFirst actions
   */
  export type BinKitchenOrderItemFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BinKitchenOrderItem
     */
    select?: BinKitchenOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenOrderItemInclude | null
    /**
     * Filter, which BinKitchenOrderItem to fetch.
     */
    where?: BinKitchenOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BinKitchenOrderItems to fetch.
     */
    orderBy?: Enumerable<BinKitchenOrderItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BinKitchenOrderItems.
     */
    cursor?: BinKitchenOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BinKitchenOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BinKitchenOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BinKitchenOrderItems.
     */
    distinct?: Enumerable<BinKitchenOrderItemScalarFieldEnum>
  }

  /**
   * BinKitchenOrderItem findFirst
   */
  export interface BinKitchenOrderItemFindFirstArgs extends BinKitchenOrderItemFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BinKitchenOrderItem findFirstOrThrow
   */
  export type BinKitchenOrderItemFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenOrderItem
     */
    select?: BinKitchenOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenOrderItemInclude | null
    /**
     * Filter, which BinKitchenOrderItem to fetch.
     */
    where?: BinKitchenOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BinKitchenOrderItems to fetch.
     */
    orderBy?: Enumerable<BinKitchenOrderItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BinKitchenOrderItems.
     */
    cursor?: BinKitchenOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BinKitchenOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BinKitchenOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BinKitchenOrderItems.
     */
    distinct?: Enumerable<BinKitchenOrderItemScalarFieldEnum>
  }


  /**
   * BinKitchenOrderItem findMany
   */
  export type BinKitchenOrderItemFindManyArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenOrderItem
     */
    select?: BinKitchenOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenOrderItemInclude | null
    /**
     * Filter, which BinKitchenOrderItems to fetch.
     */
    where?: BinKitchenOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BinKitchenOrderItems to fetch.
     */
    orderBy?: Enumerable<BinKitchenOrderItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BinKitchenOrderItems.
     */
    cursor?: BinKitchenOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BinKitchenOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BinKitchenOrderItems.
     */
    skip?: number
    distinct?: Enumerable<BinKitchenOrderItemScalarFieldEnum>
  }


  /**
   * BinKitchenOrderItem create
   */
  export type BinKitchenOrderItemCreateArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenOrderItem
     */
    select?: BinKitchenOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenOrderItemInclude | null
    /**
     * The data needed to create a BinKitchenOrderItem.
     */
    data: XOR<BinKitchenOrderItemCreateInput, BinKitchenOrderItemUncheckedCreateInput>
  }


  /**
   * BinKitchenOrderItem createMany
   */
  export type BinKitchenOrderItemCreateManyArgs = {
    /**
     * The data used to create many BinKitchenOrderItems.
     */
    data: Enumerable<BinKitchenOrderItemCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BinKitchenOrderItem update
   */
  export type BinKitchenOrderItemUpdateArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenOrderItem
     */
    select?: BinKitchenOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenOrderItemInclude | null
    /**
     * The data needed to update a BinKitchenOrderItem.
     */
    data: XOR<BinKitchenOrderItemUpdateInput, BinKitchenOrderItemUncheckedUpdateInput>
    /**
     * Choose, which BinKitchenOrderItem to update.
     */
    where: BinKitchenOrderItemWhereUniqueInput
  }


  /**
   * BinKitchenOrderItem updateMany
   */
  export type BinKitchenOrderItemUpdateManyArgs = {
    /**
     * The data used to update BinKitchenOrderItems.
     */
    data: XOR<BinKitchenOrderItemUpdateManyMutationInput, BinKitchenOrderItemUncheckedUpdateManyInput>
    /**
     * Filter which BinKitchenOrderItems to update
     */
    where?: BinKitchenOrderItemWhereInput
  }


  /**
   * BinKitchenOrderItem upsert
   */
  export type BinKitchenOrderItemUpsertArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenOrderItem
     */
    select?: BinKitchenOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenOrderItemInclude | null
    /**
     * The filter to search for the BinKitchenOrderItem to update in case it exists.
     */
    where: BinKitchenOrderItemWhereUniqueInput
    /**
     * In case the BinKitchenOrderItem found by the `where` argument doesn't exist, create a new BinKitchenOrderItem with this data.
     */
    create: XOR<BinKitchenOrderItemCreateInput, BinKitchenOrderItemUncheckedCreateInput>
    /**
     * In case the BinKitchenOrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BinKitchenOrderItemUpdateInput, BinKitchenOrderItemUncheckedUpdateInput>
  }


  /**
   * BinKitchenOrderItem delete
   */
  export type BinKitchenOrderItemDeleteArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenOrderItem
     */
    select?: BinKitchenOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenOrderItemInclude | null
    /**
     * Filter which BinKitchenOrderItem to delete.
     */
    where: BinKitchenOrderItemWhereUniqueInput
  }


  /**
   * BinKitchenOrderItem deleteMany
   */
  export type BinKitchenOrderItemDeleteManyArgs = {
    /**
     * Filter which BinKitchenOrderItems to delete
     */
    where?: BinKitchenOrderItemWhereInput
  }


  /**
   * BinKitchenOrderItem without action
   */
  export type BinKitchenOrderItemArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenOrderItem
     */
    select?: BinKitchenOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenOrderItemInclude | null
  }



  /**
   * Model LaundryBranch
   */


  export type AggregateLaundryBranch = {
    _count: LaundryBranchCountAggregateOutputType | null
    _avg: LaundryBranchAvgAggregateOutputType | null
    _sum: LaundryBranchSumAggregateOutputType | null
    _min: LaundryBranchMinAggregateOutputType | null
    _max: LaundryBranchMaxAggregateOutputType | null
  }

  export type LaundryBranchAvgAggregateOutputType = {
    id: number | null
    machineAmount: number | null
    tel: number | null
    areaSize: number | null
  }

  export type LaundryBranchSumAggregateOutputType = {
    id: number | null
    machineAmount: number | null
    tel: number | null
    areaSize: number | null
  }

  export type LaundryBranchMinAggregateOutputType = {
    id: number | null
    name: string | null
    machineAmount: number | null
    owner: string | null
    tel: number | null
    location: string | null
    areaSize: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LaundryBranchMaxAggregateOutputType = {
    id: number | null
    name: string | null
    machineAmount: number | null
    owner: string | null
    tel: number | null
    location: string | null
    areaSize: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LaundryBranchCountAggregateOutputType = {
    id: number
    name: number
    machineAmount: number
    owner: number
    tel: number
    location: number
    areaSize: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LaundryBranchAvgAggregateInputType = {
    id?: true
    machineAmount?: true
    tel?: true
    areaSize?: true
  }

  export type LaundryBranchSumAggregateInputType = {
    id?: true
    machineAmount?: true
    tel?: true
    areaSize?: true
  }

  export type LaundryBranchMinAggregateInputType = {
    id?: true
    name?: true
    machineAmount?: true
    owner?: true
    tel?: true
    location?: true
    areaSize?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LaundryBranchMaxAggregateInputType = {
    id?: true
    name?: true
    machineAmount?: true
    owner?: true
    tel?: true
    location?: true
    areaSize?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LaundryBranchCountAggregateInputType = {
    id?: true
    name?: true
    machineAmount?: true
    owner?: true
    tel?: true
    location?: true
    areaSize?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LaundryBranchAggregateArgs = {
    /**
     * Filter which LaundryBranch to aggregate.
     */
    where?: LaundryBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryBranches to fetch.
     */
    orderBy?: Enumerable<LaundryBranchOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LaundryBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LaundryBranches
    **/
    _count?: true | LaundryBranchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LaundryBranchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LaundryBranchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LaundryBranchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LaundryBranchMaxAggregateInputType
  }

  export type GetLaundryBranchAggregateType<T extends LaundryBranchAggregateArgs> = {
        [P in keyof T & keyof AggregateLaundryBranch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLaundryBranch[P]>
      : GetScalarType<T[P], AggregateLaundryBranch[P]>
  }




  export type LaundryBranchGroupByArgs = {
    where?: LaundryBranchWhereInput
    orderBy?: Enumerable<LaundryBranchOrderByWithAggregationInput>
    by: LaundryBranchScalarFieldEnum[]
    having?: LaundryBranchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LaundryBranchCountAggregateInputType | true
    _avg?: LaundryBranchAvgAggregateInputType
    _sum?: LaundryBranchSumAggregateInputType
    _min?: LaundryBranchMinAggregateInputType
    _max?: LaundryBranchMaxAggregateInputType
  }


  export type LaundryBranchGroupByOutputType = {
    id: number
    name: string
    machineAmount: number
    owner: string
    tel: number
    location: string
    areaSize: number
    createdAt: Date
    updatedAt: Date
    _count: LaundryBranchCountAggregateOutputType | null
    _avg: LaundryBranchAvgAggregateOutputType | null
    _sum: LaundryBranchSumAggregateOutputType | null
    _min: LaundryBranchMinAggregateOutputType | null
    _max: LaundryBranchMaxAggregateOutputType | null
  }

  type GetLaundryBranchGroupByPayload<T extends LaundryBranchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LaundryBranchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LaundryBranchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LaundryBranchGroupByOutputType[P]>
            : GetScalarType<T[P], LaundryBranchGroupByOutputType[P]>
        }
      >
    >


  export type LaundryBranchSelect = {
    id?: boolean
    name?: boolean
    machineAmount?: boolean
    owner?: boolean
    tel?: boolean
    location?: boolean
    areaSize?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    laundryWashingMachines?: boolean | LaundryBranch$laundryWashingMachinesArgs
    _count?: boolean | LaundryBranchCountOutputTypeArgs
  }


  export type LaundryBranchInclude = {
    laundryWashingMachines?: boolean | LaundryBranch$laundryWashingMachinesArgs
    _count?: boolean | LaundryBranchCountOutputTypeArgs
  }

  export type LaundryBranchGetPayload<S extends boolean | null | undefined | LaundryBranchArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LaundryBranch :
    S extends undefined ? never :
    S extends { include: any } & (LaundryBranchArgs | LaundryBranchFindManyArgs)
    ? LaundryBranch  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'laundryWashingMachines' ? Array < LaundryWashingMachineGetPayload<S['include'][P]>>  :
        P extends '_count' ? LaundryBranchCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (LaundryBranchArgs | LaundryBranchFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'laundryWashingMachines' ? Array < LaundryWashingMachineGetPayload<S['select'][P]>>  :
        P extends '_count' ? LaundryBranchCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof LaundryBranch ? LaundryBranch[P] : never
  } 
      : LaundryBranch


  type LaundryBranchCountArgs = 
    Omit<LaundryBranchFindManyArgs, 'select' | 'include'> & {
      select?: LaundryBranchCountAggregateInputType | true
    }

  export interface LaundryBranchDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one LaundryBranch that matches the filter.
     * @param {LaundryBranchFindUniqueArgs} args - Arguments to find a LaundryBranch
     * @example
     * // Get one LaundryBranch
     * const laundryBranch = await prisma.laundryBranch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LaundryBranchFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LaundryBranchFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LaundryBranch'> extends True ? Prisma__LaundryBranchClient<LaundryBranchGetPayload<T>> : Prisma__LaundryBranchClient<LaundryBranchGetPayload<T> | null, null>

    /**
     * Find one LaundryBranch that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LaundryBranchFindUniqueOrThrowArgs} args - Arguments to find a LaundryBranch
     * @example
     * // Get one LaundryBranch
     * const laundryBranch = await prisma.laundryBranch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LaundryBranchFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LaundryBranchFindUniqueOrThrowArgs>
    ): Prisma__LaundryBranchClient<LaundryBranchGetPayload<T>>

    /**
     * Find the first LaundryBranch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryBranchFindFirstArgs} args - Arguments to find a LaundryBranch
     * @example
     * // Get one LaundryBranch
     * const laundryBranch = await prisma.laundryBranch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LaundryBranchFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LaundryBranchFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LaundryBranch'> extends True ? Prisma__LaundryBranchClient<LaundryBranchGetPayload<T>> : Prisma__LaundryBranchClient<LaundryBranchGetPayload<T> | null, null>

    /**
     * Find the first LaundryBranch that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryBranchFindFirstOrThrowArgs} args - Arguments to find a LaundryBranch
     * @example
     * // Get one LaundryBranch
     * const laundryBranch = await prisma.laundryBranch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LaundryBranchFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LaundryBranchFindFirstOrThrowArgs>
    ): Prisma__LaundryBranchClient<LaundryBranchGetPayload<T>>

    /**
     * Find zero or more LaundryBranches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryBranchFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LaundryBranches
     * const laundryBranches = await prisma.laundryBranch.findMany()
     * 
     * // Get first 10 LaundryBranches
     * const laundryBranches = await prisma.laundryBranch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const laundryBranchWithIdOnly = await prisma.laundryBranch.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LaundryBranchFindManyArgs>(
      args?: SelectSubset<T, LaundryBranchFindManyArgs>
    ): Prisma.PrismaPromise<Array<LaundryBranchGetPayload<T>>>

    /**
     * Create a LaundryBranch.
     * @param {LaundryBranchCreateArgs} args - Arguments to create a LaundryBranch.
     * @example
     * // Create one LaundryBranch
     * const LaundryBranch = await prisma.laundryBranch.create({
     *   data: {
     *     // ... data to create a LaundryBranch
     *   }
     * })
     * 
    **/
    create<T extends LaundryBranchCreateArgs>(
      args: SelectSubset<T, LaundryBranchCreateArgs>
    ): Prisma__LaundryBranchClient<LaundryBranchGetPayload<T>>

    /**
     * Create many LaundryBranches.
     *     @param {LaundryBranchCreateManyArgs} args - Arguments to create many LaundryBranches.
     *     @example
     *     // Create many LaundryBranches
     *     const laundryBranch = await prisma.laundryBranch.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LaundryBranchCreateManyArgs>(
      args?: SelectSubset<T, LaundryBranchCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LaundryBranch.
     * @param {LaundryBranchDeleteArgs} args - Arguments to delete one LaundryBranch.
     * @example
     * // Delete one LaundryBranch
     * const LaundryBranch = await prisma.laundryBranch.delete({
     *   where: {
     *     // ... filter to delete one LaundryBranch
     *   }
     * })
     * 
    **/
    delete<T extends LaundryBranchDeleteArgs>(
      args: SelectSubset<T, LaundryBranchDeleteArgs>
    ): Prisma__LaundryBranchClient<LaundryBranchGetPayload<T>>

    /**
     * Update one LaundryBranch.
     * @param {LaundryBranchUpdateArgs} args - Arguments to update one LaundryBranch.
     * @example
     * // Update one LaundryBranch
     * const laundryBranch = await prisma.laundryBranch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LaundryBranchUpdateArgs>(
      args: SelectSubset<T, LaundryBranchUpdateArgs>
    ): Prisma__LaundryBranchClient<LaundryBranchGetPayload<T>>

    /**
     * Delete zero or more LaundryBranches.
     * @param {LaundryBranchDeleteManyArgs} args - Arguments to filter LaundryBranches to delete.
     * @example
     * // Delete a few LaundryBranches
     * const { count } = await prisma.laundryBranch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LaundryBranchDeleteManyArgs>(
      args?: SelectSubset<T, LaundryBranchDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LaundryBranches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryBranchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LaundryBranches
     * const laundryBranch = await prisma.laundryBranch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LaundryBranchUpdateManyArgs>(
      args: SelectSubset<T, LaundryBranchUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LaundryBranch.
     * @param {LaundryBranchUpsertArgs} args - Arguments to update or create a LaundryBranch.
     * @example
     * // Update or create a LaundryBranch
     * const laundryBranch = await prisma.laundryBranch.upsert({
     *   create: {
     *     // ... data to create a LaundryBranch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LaundryBranch we want to update
     *   }
     * })
    **/
    upsert<T extends LaundryBranchUpsertArgs>(
      args: SelectSubset<T, LaundryBranchUpsertArgs>
    ): Prisma__LaundryBranchClient<LaundryBranchGetPayload<T>>

    /**
     * Count the number of LaundryBranches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryBranchCountArgs} args - Arguments to filter LaundryBranches to count.
     * @example
     * // Count the number of LaundryBranches
     * const count = await prisma.laundryBranch.count({
     *   where: {
     *     // ... the filter for the LaundryBranches we want to count
     *   }
     * })
    **/
    count<T extends LaundryBranchCountArgs>(
      args?: Subset<T, LaundryBranchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LaundryBranchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LaundryBranch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryBranchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LaundryBranchAggregateArgs>(args: Subset<T, LaundryBranchAggregateArgs>): Prisma.PrismaPromise<GetLaundryBranchAggregateType<T>>

    /**
     * Group by LaundryBranch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryBranchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LaundryBranchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LaundryBranchGroupByArgs['orderBy'] }
        : { orderBy?: LaundryBranchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LaundryBranchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLaundryBranchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LaundryBranch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LaundryBranchClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    laundryWashingMachines<T extends LaundryBranch$laundryWashingMachinesArgs= {}>(args?: Subset<T, LaundryBranch$laundryWashingMachinesArgs>): Prisma.PrismaPromise<Array<LaundryWashingMachineGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LaundryBranch base type for findUnique actions
   */
  export type LaundryBranchFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the LaundryBranch
     */
    select?: LaundryBranchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryBranchInclude | null
    /**
     * Filter, which LaundryBranch to fetch.
     */
    where: LaundryBranchWhereUniqueInput
  }

  /**
   * LaundryBranch findUnique
   */
  export interface LaundryBranchFindUniqueArgs extends LaundryBranchFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LaundryBranch findUniqueOrThrow
   */
  export type LaundryBranchFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LaundryBranch
     */
    select?: LaundryBranchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryBranchInclude | null
    /**
     * Filter, which LaundryBranch to fetch.
     */
    where: LaundryBranchWhereUniqueInput
  }


  /**
   * LaundryBranch base type for findFirst actions
   */
  export type LaundryBranchFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the LaundryBranch
     */
    select?: LaundryBranchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryBranchInclude | null
    /**
     * Filter, which LaundryBranch to fetch.
     */
    where?: LaundryBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryBranches to fetch.
     */
    orderBy?: Enumerable<LaundryBranchOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaundryBranches.
     */
    cursor?: LaundryBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaundryBranches.
     */
    distinct?: Enumerable<LaundryBranchScalarFieldEnum>
  }

  /**
   * LaundryBranch findFirst
   */
  export interface LaundryBranchFindFirstArgs extends LaundryBranchFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LaundryBranch findFirstOrThrow
   */
  export type LaundryBranchFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LaundryBranch
     */
    select?: LaundryBranchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryBranchInclude | null
    /**
     * Filter, which LaundryBranch to fetch.
     */
    where?: LaundryBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryBranches to fetch.
     */
    orderBy?: Enumerable<LaundryBranchOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaundryBranches.
     */
    cursor?: LaundryBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaundryBranches.
     */
    distinct?: Enumerable<LaundryBranchScalarFieldEnum>
  }


  /**
   * LaundryBranch findMany
   */
  export type LaundryBranchFindManyArgs = {
    /**
     * Select specific fields to fetch from the LaundryBranch
     */
    select?: LaundryBranchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryBranchInclude | null
    /**
     * Filter, which LaundryBranches to fetch.
     */
    where?: LaundryBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryBranches to fetch.
     */
    orderBy?: Enumerable<LaundryBranchOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LaundryBranches.
     */
    cursor?: LaundryBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryBranches.
     */
    skip?: number
    distinct?: Enumerable<LaundryBranchScalarFieldEnum>
  }


  /**
   * LaundryBranch create
   */
  export type LaundryBranchCreateArgs = {
    /**
     * Select specific fields to fetch from the LaundryBranch
     */
    select?: LaundryBranchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryBranchInclude | null
    /**
     * The data needed to create a LaundryBranch.
     */
    data: XOR<LaundryBranchCreateInput, LaundryBranchUncheckedCreateInput>
  }


  /**
   * LaundryBranch createMany
   */
  export type LaundryBranchCreateManyArgs = {
    /**
     * The data used to create many LaundryBranches.
     */
    data: Enumerable<LaundryBranchCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LaundryBranch update
   */
  export type LaundryBranchUpdateArgs = {
    /**
     * Select specific fields to fetch from the LaundryBranch
     */
    select?: LaundryBranchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryBranchInclude | null
    /**
     * The data needed to update a LaundryBranch.
     */
    data: XOR<LaundryBranchUpdateInput, LaundryBranchUncheckedUpdateInput>
    /**
     * Choose, which LaundryBranch to update.
     */
    where: LaundryBranchWhereUniqueInput
  }


  /**
   * LaundryBranch updateMany
   */
  export type LaundryBranchUpdateManyArgs = {
    /**
     * The data used to update LaundryBranches.
     */
    data: XOR<LaundryBranchUpdateManyMutationInput, LaundryBranchUncheckedUpdateManyInput>
    /**
     * Filter which LaundryBranches to update
     */
    where?: LaundryBranchWhereInput
  }


  /**
   * LaundryBranch upsert
   */
  export type LaundryBranchUpsertArgs = {
    /**
     * Select specific fields to fetch from the LaundryBranch
     */
    select?: LaundryBranchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryBranchInclude | null
    /**
     * The filter to search for the LaundryBranch to update in case it exists.
     */
    where: LaundryBranchWhereUniqueInput
    /**
     * In case the LaundryBranch found by the `where` argument doesn't exist, create a new LaundryBranch with this data.
     */
    create: XOR<LaundryBranchCreateInput, LaundryBranchUncheckedCreateInput>
    /**
     * In case the LaundryBranch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LaundryBranchUpdateInput, LaundryBranchUncheckedUpdateInput>
  }


  /**
   * LaundryBranch delete
   */
  export type LaundryBranchDeleteArgs = {
    /**
     * Select specific fields to fetch from the LaundryBranch
     */
    select?: LaundryBranchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryBranchInclude | null
    /**
     * Filter which LaundryBranch to delete.
     */
    where: LaundryBranchWhereUniqueInput
  }


  /**
   * LaundryBranch deleteMany
   */
  export type LaundryBranchDeleteManyArgs = {
    /**
     * Filter which LaundryBranches to delete
     */
    where?: LaundryBranchWhereInput
  }


  /**
   * LaundryBranch.laundryWashingMachines
   */
  export type LaundryBranch$laundryWashingMachinesArgs = {
    /**
     * Select specific fields to fetch from the LaundryWashingMachine
     */
    select?: LaundryWashingMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryWashingMachineInclude | null
    where?: LaundryWashingMachineWhereInput
    orderBy?: Enumerable<LaundryWashingMachineOrderByWithRelationInput>
    cursor?: LaundryWashingMachineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LaundryWashingMachineScalarFieldEnum>
  }


  /**
   * LaundryBranch without action
   */
  export type LaundryBranchArgs = {
    /**
     * Select specific fields to fetch from the LaundryBranch
     */
    select?: LaundryBranchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryBranchInclude | null
  }



  /**
   * Model LaundryWashingMachine
   */


  export type AggregateLaundryWashingMachine = {
    _count: LaundryWashingMachineCountAggregateOutputType | null
    _avg: LaundryWashingMachineAvgAggregateOutputType | null
    _sum: LaundryWashingMachineSumAggregateOutputType | null
    _min: LaundryWashingMachineMinAggregateOutputType | null
    _max: LaundryWashingMachineMaxAggregateOutputType | null
  }

  export type LaundryWashingMachineAvgAggregateOutputType = {
    id: number | null
    size: number | null
    yearManufactured: number | null
    insuranceExpiryYear: number | null
    laundryBranchId: number | null
  }

  export type LaundryWashingMachineSumAggregateOutputType = {
    id: number | null
    size: number | null
    yearManufactured: number | null
    insuranceExpiryYear: number | null
    laundryBranchId: number | null
  }

  export type LaundryWashingMachineMinAggregateOutputType = {
    id: number | null
    brand: string | null
    variant: string | null
    size: number | null
    machineType: string | null
    yearManufactured: number | null
    insuranceExpiryYear: number | null
    createdAt: Date | null
    updatedAt: Date | null
    laundryBranchId: number | null
  }

  export type LaundryWashingMachineMaxAggregateOutputType = {
    id: number | null
    brand: string | null
    variant: string | null
    size: number | null
    machineType: string | null
    yearManufactured: number | null
    insuranceExpiryYear: number | null
    createdAt: Date | null
    updatedAt: Date | null
    laundryBranchId: number | null
  }

  export type LaundryWashingMachineCountAggregateOutputType = {
    id: number
    brand: number
    variant: number
    size: number
    machineType: number
    yearManufactured: number
    insuranceExpiryYear: number
    createdAt: number
    updatedAt: number
    laundryBranchId: number
    _all: number
  }


  export type LaundryWashingMachineAvgAggregateInputType = {
    id?: true
    size?: true
    yearManufactured?: true
    insuranceExpiryYear?: true
    laundryBranchId?: true
  }

  export type LaundryWashingMachineSumAggregateInputType = {
    id?: true
    size?: true
    yearManufactured?: true
    insuranceExpiryYear?: true
    laundryBranchId?: true
  }

  export type LaundryWashingMachineMinAggregateInputType = {
    id?: true
    brand?: true
    variant?: true
    size?: true
    machineType?: true
    yearManufactured?: true
    insuranceExpiryYear?: true
    createdAt?: true
    updatedAt?: true
    laundryBranchId?: true
  }

  export type LaundryWashingMachineMaxAggregateInputType = {
    id?: true
    brand?: true
    variant?: true
    size?: true
    machineType?: true
    yearManufactured?: true
    insuranceExpiryYear?: true
    createdAt?: true
    updatedAt?: true
    laundryBranchId?: true
  }

  export type LaundryWashingMachineCountAggregateInputType = {
    id?: true
    brand?: true
    variant?: true
    size?: true
    machineType?: true
    yearManufactured?: true
    insuranceExpiryYear?: true
    createdAt?: true
    updatedAt?: true
    laundryBranchId?: true
    _all?: true
  }

  export type LaundryWashingMachineAggregateArgs = {
    /**
     * Filter which LaundryWashingMachine to aggregate.
     */
    where?: LaundryWashingMachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryWashingMachines to fetch.
     */
    orderBy?: Enumerable<LaundryWashingMachineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LaundryWashingMachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryWashingMachines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryWashingMachines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LaundryWashingMachines
    **/
    _count?: true | LaundryWashingMachineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LaundryWashingMachineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LaundryWashingMachineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LaundryWashingMachineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LaundryWashingMachineMaxAggregateInputType
  }

  export type GetLaundryWashingMachineAggregateType<T extends LaundryWashingMachineAggregateArgs> = {
        [P in keyof T & keyof AggregateLaundryWashingMachine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLaundryWashingMachine[P]>
      : GetScalarType<T[P], AggregateLaundryWashingMachine[P]>
  }




  export type LaundryWashingMachineGroupByArgs = {
    where?: LaundryWashingMachineWhereInput
    orderBy?: Enumerable<LaundryWashingMachineOrderByWithAggregationInput>
    by: LaundryWashingMachineScalarFieldEnum[]
    having?: LaundryWashingMachineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LaundryWashingMachineCountAggregateInputType | true
    _avg?: LaundryWashingMachineAvgAggregateInputType
    _sum?: LaundryWashingMachineSumAggregateInputType
    _min?: LaundryWashingMachineMinAggregateInputType
    _max?: LaundryWashingMachineMaxAggregateInputType
  }


  export type LaundryWashingMachineGroupByOutputType = {
    id: number
    brand: string
    variant: string
    size: number
    machineType: string
    yearManufactured: number
    insuranceExpiryYear: number
    createdAt: Date
    updatedAt: Date
    laundryBranchId: number
    _count: LaundryWashingMachineCountAggregateOutputType | null
    _avg: LaundryWashingMachineAvgAggregateOutputType | null
    _sum: LaundryWashingMachineSumAggregateOutputType | null
    _min: LaundryWashingMachineMinAggregateOutputType | null
    _max: LaundryWashingMachineMaxAggregateOutputType | null
  }

  type GetLaundryWashingMachineGroupByPayload<T extends LaundryWashingMachineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LaundryWashingMachineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LaundryWashingMachineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LaundryWashingMachineGroupByOutputType[P]>
            : GetScalarType<T[P], LaundryWashingMachineGroupByOutputType[P]>
        }
      >
    >


  export type LaundryWashingMachineSelect = {
    id?: boolean
    branch?: boolean | LaundryBranchArgs
    brand?: boolean
    variant?: boolean
    size?: boolean
    machineType?: boolean
    yearManufactured?: boolean
    insuranceExpiryYear?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    laundryBranchId?: boolean
    laundryWashingMachinesToPrograms?: boolean | LaundryWashingMachine$laundryWashingMachinesToProgramsArgs
    laundryMaintainances?: boolean | LaundryWashingMachine$laundryMaintainancesArgs
    laundryUserHistories?: boolean | LaundryWashingMachine$laundryUserHistoriesArgs
    _count?: boolean | LaundryWashingMachineCountOutputTypeArgs
  }


  export type LaundryWashingMachineInclude = {
    branch?: boolean | LaundryBranchArgs
    laundryWashingMachinesToPrograms?: boolean | LaundryWashingMachine$laundryWashingMachinesToProgramsArgs
    laundryMaintainances?: boolean | LaundryWashingMachine$laundryMaintainancesArgs
    laundryUserHistories?: boolean | LaundryWashingMachine$laundryUserHistoriesArgs
    _count?: boolean | LaundryWashingMachineCountOutputTypeArgs
  }

  export type LaundryWashingMachineGetPayload<S extends boolean | null | undefined | LaundryWashingMachineArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LaundryWashingMachine :
    S extends undefined ? never :
    S extends { include: any } & (LaundryWashingMachineArgs | LaundryWashingMachineFindManyArgs)
    ? LaundryWashingMachine  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'branch' ? LaundryBranchGetPayload<S['include'][P]> :
        P extends 'laundryWashingMachinesToPrograms' ? Array < LaundryWashingMachineToProgramGetPayload<S['include'][P]>>  :
        P extends 'laundryMaintainances' ? Array < LaundryMaintainanceGetPayload<S['include'][P]>>  :
        P extends 'laundryUserHistories' ? Array < LaundryUserHistoryGetPayload<S['include'][P]>>  :
        P extends '_count' ? LaundryWashingMachineCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (LaundryWashingMachineArgs | LaundryWashingMachineFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'branch' ? LaundryBranchGetPayload<S['select'][P]> :
        P extends 'laundryWashingMachinesToPrograms' ? Array < LaundryWashingMachineToProgramGetPayload<S['select'][P]>>  :
        P extends 'laundryMaintainances' ? Array < LaundryMaintainanceGetPayload<S['select'][P]>>  :
        P extends 'laundryUserHistories' ? Array < LaundryUserHistoryGetPayload<S['select'][P]>>  :
        P extends '_count' ? LaundryWashingMachineCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof LaundryWashingMachine ? LaundryWashingMachine[P] : never
  } 
      : LaundryWashingMachine


  type LaundryWashingMachineCountArgs = 
    Omit<LaundryWashingMachineFindManyArgs, 'select' | 'include'> & {
      select?: LaundryWashingMachineCountAggregateInputType | true
    }

  export interface LaundryWashingMachineDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one LaundryWashingMachine that matches the filter.
     * @param {LaundryWashingMachineFindUniqueArgs} args - Arguments to find a LaundryWashingMachine
     * @example
     * // Get one LaundryWashingMachine
     * const laundryWashingMachine = await prisma.laundryWashingMachine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LaundryWashingMachineFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LaundryWashingMachineFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LaundryWashingMachine'> extends True ? Prisma__LaundryWashingMachineClient<LaundryWashingMachineGetPayload<T>> : Prisma__LaundryWashingMachineClient<LaundryWashingMachineGetPayload<T> | null, null>

    /**
     * Find one LaundryWashingMachine that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LaundryWashingMachineFindUniqueOrThrowArgs} args - Arguments to find a LaundryWashingMachine
     * @example
     * // Get one LaundryWashingMachine
     * const laundryWashingMachine = await prisma.laundryWashingMachine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LaundryWashingMachineFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LaundryWashingMachineFindUniqueOrThrowArgs>
    ): Prisma__LaundryWashingMachineClient<LaundryWashingMachineGetPayload<T>>

    /**
     * Find the first LaundryWashingMachine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryWashingMachineFindFirstArgs} args - Arguments to find a LaundryWashingMachine
     * @example
     * // Get one LaundryWashingMachine
     * const laundryWashingMachine = await prisma.laundryWashingMachine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LaundryWashingMachineFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LaundryWashingMachineFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LaundryWashingMachine'> extends True ? Prisma__LaundryWashingMachineClient<LaundryWashingMachineGetPayload<T>> : Prisma__LaundryWashingMachineClient<LaundryWashingMachineGetPayload<T> | null, null>

    /**
     * Find the first LaundryWashingMachine that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryWashingMachineFindFirstOrThrowArgs} args - Arguments to find a LaundryWashingMachine
     * @example
     * // Get one LaundryWashingMachine
     * const laundryWashingMachine = await prisma.laundryWashingMachine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LaundryWashingMachineFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LaundryWashingMachineFindFirstOrThrowArgs>
    ): Prisma__LaundryWashingMachineClient<LaundryWashingMachineGetPayload<T>>

    /**
     * Find zero or more LaundryWashingMachines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryWashingMachineFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LaundryWashingMachines
     * const laundryWashingMachines = await prisma.laundryWashingMachine.findMany()
     * 
     * // Get first 10 LaundryWashingMachines
     * const laundryWashingMachines = await prisma.laundryWashingMachine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const laundryWashingMachineWithIdOnly = await prisma.laundryWashingMachine.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LaundryWashingMachineFindManyArgs>(
      args?: SelectSubset<T, LaundryWashingMachineFindManyArgs>
    ): Prisma.PrismaPromise<Array<LaundryWashingMachineGetPayload<T>>>

    /**
     * Create a LaundryWashingMachine.
     * @param {LaundryWashingMachineCreateArgs} args - Arguments to create a LaundryWashingMachine.
     * @example
     * // Create one LaundryWashingMachine
     * const LaundryWashingMachine = await prisma.laundryWashingMachine.create({
     *   data: {
     *     // ... data to create a LaundryWashingMachine
     *   }
     * })
     * 
    **/
    create<T extends LaundryWashingMachineCreateArgs>(
      args: SelectSubset<T, LaundryWashingMachineCreateArgs>
    ): Prisma__LaundryWashingMachineClient<LaundryWashingMachineGetPayload<T>>

    /**
     * Create many LaundryWashingMachines.
     *     @param {LaundryWashingMachineCreateManyArgs} args - Arguments to create many LaundryWashingMachines.
     *     @example
     *     // Create many LaundryWashingMachines
     *     const laundryWashingMachine = await prisma.laundryWashingMachine.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LaundryWashingMachineCreateManyArgs>(
      args?: SelectSubset<T, LaundryWashingMachineCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LaundryWashingMachine.
     * @param {LaundryWashingMachineDeleteArgs} args - Arguments to delete one LaundryWashingMachine.
     * @example
     * // Delete one LaundryWashingMachine
     * const LaundryWashingMachine = await prisma.laundryWashingMachine.delete({
     *   where: {
     *     // ... filter to delete one LaundryWashingMachine
     *   }
     * })
     * 
    **/
    delete<T extends LaundryWashingMachineDeleteArgs>(
      args: SelectSubset<T, LaundryWashingMachineDeleteArgs>
    ): Prisma__LaundryWashingMachineClient<LaundryWashingMachineGetPayload<T>>

    /**
     * Update one LaundryWashingMachine.
     * @param {LaundryWashingMachineUpdateArgs} args - Arguments to update one LaundryWashingMachine.
     * @example
     * // Update one LaundryWashingMachine
     * const laundryWashingMachine = await prisma.laundryWashingMachine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LaundryWashingMachineUpdateArgs>(
      args: SelectSubset<T, LaundryWashingMachineUpdateArgs>
    ): Prisma__LaundryWashingMachineClient<LaundryWashingMachineGetPayload<T>>

    /**
     * Delete zero or more LaundryWashingMachines.
     * @param {LaundryWashingMachineDeleteManyArgs} args - Arguments to filter LaundryWashingMachines to delete.
     * @example
     * // Delete a few LaundryWashingMachines
     * const { count } = await prisma.laundryWashingMachine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LaundryWashingMachineDeleteManyArgs>(
      args?: SelectSubset<T, LaundryWashingMachineDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LaundryWashingMachines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryWashingMachineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LaundryWashingMachines
     * const laundryWashingMachine = await prisma.laundryWashingMachine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LaundryWashingMachineUpdateManyArgs>(
      args: SelectSubset<T, LaundryWashingMachineUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LaundryWashingMachine.
     * @param {LaundryWashingMachineUpsertArgs} args - Arguments to update or create a LaundryWashingMachine.
     * @example
     * // Update or create a LaundryWashingMachine
     * const laundryWashingMachine = await prisma.laundryWashingMachine.upsert({
     *   create: {
     *     // ... data to create a LaundryWashingMachine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LaundryWashingMachine we want to update
     *   }
     * })
    **/
    upsert<T extends LaundryWashingMachineUpsertArgs>(
      args: SelectSubset<T, LaundryWashingMachineUpsertArgs>
    ): Prisma__LaundryWashingMachineClient<LaundryWashingMachineGetPayload<T>>

    /**
     * Count the number of LaundryWashingMachines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryWashingMachineCountArgs} args - Arguments to filter LaundryWashingMachines to count.
     * @example
     * // Count the number of LaundryWashingMachines
     * const count = await prisma.laundryWashingMachine.count({
     *   where: {
     *     // ... the filter for the LaundryWashingMachines we want to count
     *   }
     * })
    **/
    count<T extends LaundryWashingMachineCountArgs>(
      args?: Subset<T, LaundryWashingMachineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LaundryWashingMachineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LaundryWashingMachine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryWashingMachineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LaundryWashingMachineAggregateArgs>(args: Subset<T, LaundryWashingMachineAggregateArgs>): Prisma.PrismaPromise<GetLaundryWashingMachineAggregateType<T>>

    /**
     * Group by LaundryWashingMachine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryWashingMachineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LaundryWashingMachineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LaundryWashingMachineGroupByArgs['orderBy'] }
        : { orderBy?: LaundryWashingMachineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LaundryWashingMachineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLaundryWashingMachineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LaundryWashingMachine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LaundryWashingMachineClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    branch<T extends LaundryBranchArgs= {}>(args?: Subset<T, LaundryBranchArgs>): Prisma__LaundryBranchClient<LaundryBranchGetPayload<T> | Null>;

    laundryWashingMachinesToPrograms<T extends LaundryWashingMachine$laundryWashingMachinesToProgramsArgs= {}>(args?: Subset<T, LaundryWashingMachine$laundryWashingMachinesToProgramsArgs>): Prisma.PrismaPromise<Array<LaundryWashingMachineToProgramGetPayload<T>>| Null>;

    laundryMaintainances<T extends LaundryWashingMachine$laundryMaintainancesArgs= {}>(args?: Subset<T, LaundryWashingMachine$laundryMaintainancesArgs>): Prisma.PrismaPromise<Array<LaundryMaintainanceGetPayload<T>>| Null>;

    laundryUserHistories<T extends LaundryWashingMachine$laundryUserHistoriesArgs= {}>(args?: Subset<T, LaundryWashingMachine$laundryUserHistoriesArgs>): Prisma.PrismaPromise<Array<LaundryUserHistoryGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LaundryWashingMachine base type for findUnique actions
   */
  export type LaundryWashingMachineFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the LaundryWashingMachine
     */
    select?: LaundryWashingMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryWashingMachineInclude | null
    /**
     * Filter, which LaundryWashingMachine to fetch.
     */
    where: LaundryWashingMachineWhereUniqueInput
  }

  /**
   * LaundryWashingMachine findUnique
   */
  export interface LaundryWashingMachineFindUniqueArgs extends LaundryWashingMachineFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LaundryWashingMachine findUniqueOrThrow
   */
  export type LaundryWashingMachineFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LaundryWashingMachine
     */
    select?: LaundryWashingMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryWashingMachineInclude | null
    /**
     * Filter, which LaundryWashingMachine to fetch.
     */
    where: LaundryWashingMachineWhereUniqueInput
  }


  /**
   * LaundryWashingMachine base type for findFirst actions
   */
  export type LaundryWashingMachineFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the LaundryWashingMachine
     */
    select?: LaundryWashingMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryWashingMachineInclude | null
    /**
     * Filter, which LaundryWashingMachine to fetch.
     */
    where?: LaundryWashingMachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryWashingMachines to fetch.
     */
    orderBy?: Enumerable<LaundryWashingMachineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaundryWashingMachines.
     */
    cursor?: LaundryWashingMachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryWashingMachines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryWashingMachines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaundryWashingMachines.
     */
    distinct?: Enumerable<LaundryWashingMachineScalarFieldEnum>
  }

  /**
   * LaundryWashingMachine findFirst
   */
  export interface LaundryWashingMachineFindFirstArgs extends LaundryWashingMachineFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LaundryWashingMachine findFirstOrThrow
   */
  export type LaundryWashingMachineFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LaundryWashingMachine
     */
    select?: LaundryWashingMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryWashingMachineInclude | null
    /**
     * Filter, which LaundryWashingMachine to fetch.
     */
    where?: LaundryWashingMachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryWashingMachines to fetch.
     */
    orderBy?: Enumerable<LaundryWashingMachineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaundryWashingMachines.
     */
    cursor?: LaundryWashingMachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryWashingMachines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryWashingMachines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaundryWashingMachines.
     */
    distinct?: Enumerable<LaundryWashingMachineScalarFieldEnum>
  }


  /**
   * LaundryWashingMachine findMany
   */
  export type LaundryWashingMachineFindManyArgs = {
    /**
     * Select specific fields to fetch from the LaundryWashingMachine
     */
    select?: LaundryWashingMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryWashingMachineInclude | null
    /**
     * Filter, which LaundryWashingMachines to fetch.
     */
    where?: LaundryWashingMachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryWashingMachines to fetch.
     */
    orderBy?: Enumerable<LaundryWashingMachineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LaundryWashingMachines.
     */
    cursor?: LaundryWashingMachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryWashingMachines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryWashingMachines.
     */
    skip?: number
    distinct?: Enumerable<LaundryWashingMachineScalarFieldEnum>
  }


  /**
   * LaundryWashingMachine create
   */
  export type LaundryWashingMachineCreateArgs = {
    /**
     * Select specific fields to fetch from the LaundryWashingMachine
     */
    select?: LaundryWashingMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryWashingMachineInclude | null
    /**
     * The data needed to create a LaundryWashingMachine.
     */
    data: XOR<LaundryWashingMachineCreateInput, LaundryWashingMachineUncheckedCreateInput>
  }


  /**
   * LaundryWashingMachine createMany
   */
  export type LaundryWashingMachineCreateManyArgs = {
    /**
     * The data used to create many LaundryWashingMachines.
     */
    data: Enumerable<LaundryWashingMachineCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LaundryWashingMachine update
   */
  export type LaundryWashingMachineUpdateArgs = {
    /**
     * Select specific fields to fetch from the LaundryWashingMachine
     */
    select?: LaundryWashingMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryWashingMachineInclude | null
    /**
     * The data needed to update a LaundryWashingMachine.
     */
    data: XOR<LaundryWashingMachineUpdateInput, LaundryWashingMachineUncheckedUpdateInput>
    /**
     * Choose, which LaundryWashingMachine to update.
     */
    where: LaundryWashingMachineWhereUniqueInput
  }


  /**
   * LaundryWashingMachine updateMany
   */
  export type LaundryWashingMachineUpdateManyArgs = {
    /**
     * The data used to update LaundryWashingMachines.
     */
    data: XOR<LaundryWashingMachineUpdateManyMutationInput, LaundryWashingMachineUncheckedUpdateManyInput>
    /**
     * Filter which LaundryWashingMachines to update
     */
    where?: LaundryWashingMachineWhereInput
  }


  /**
   * LaundryWashingMachine upsert
   */
  export type LaundryWashingMachineUpsertArgs = {
    /**
     * Select specific fields to fetch from the LaundryWashingMachine
     */
    select?: LaundryWashingMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryWashingMachineInclude | null
    /**
     * The filter to search for the LaundryWashingMachine to update in case it exists.
     */
    where: LaundryWashingMachineWhereUniqueInput
    /**
     * In case the LaundryWashingMachine found by the `where` argument doesn't exist, create a new LaundryWashingMachine with this data.
     */
    create: XOR<LaundryWashingMachineCreateInput, LaundryWashingMachineUncheckedCreateInput>
    /**
     * In case the LaundryWashingMachine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LaundryWashingMachineUpdateInput, LaundryWashingMachineUncheckedUpdateInput>
  }


  /**
   * LaundryWashingMachine delete
   */
  export type LaundryWashingMachineDeleteArgs = {
    /**
     * Select specific fields to fetch from the LaundryWashingMachine
     */
    select?: LaundryWashingMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryWashingMachineInclude | null
    /**
     * Filter which LaundryWashingMachine to delete.
     */
    where: LaundryWashingMachineWhereUniqueInput
  }


  /**
   * LaundryWashingMachine deleteMany
   */
  export type LaundryWashingMachineDeleteManyArgs = {
    /**
     * Filter which LaundryWashingMachines to delete
     */
    where?: LaundryWashingMachineWhereInput
  }


  /**
   * LaundryWashingMachine.laundryWashingMachinesToPrograms
   */
  export type LaundryWashingMachine$laundryWashingMachinesToProgramsArgs = {
    /**
     * Select specific fields to fetch from the LaundryWashingMachineToProgram
     */
    select?: LaundryWashingMachineToProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryWashingMachineToProgramInclude | null
    where?: LaundryWashingMachineToProgramWhereInput
    orderBy?: Enumerable<LaundryWashingMachineToProgramOrderByWithRelationInput>
    cursor?: LaundryWashingMachineToProgramWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LaundryWashingMachineToProgramScalarFieldEnum>
  }


  /**
   * LaundryWashingMachine.laundryMaintainances
   */
  export type LaundryWashingMachine$laundryMaintainancesArgs = {
    /**
     * Select specific fields to fetch from the LaundryMaintainance
     */
    select?: LaundryMaintainanceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryMaintainanceInclude | null
    where?: LaundryMaintainanceWhereInput
    orderBy?: Enumerable<LaundryMaintainanceOrderByWithRelationInput>
    cursor?: LaundryMaintainanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LaundryMaintainanceScalarFieldEnum>
  }


  /**
   * LaundryWashingMachine.laundryUserHistories
   */
  export type LaundryWashingMachine$laundryUserHistoriesArgs = {
    /**
     * Select specific fields to fetch from the LaundryUserHistory
     */
    select?: LaundryUserHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryUserHistoryInclude | null
    where?: LaundryUserHistoryWhereInput
    orderBy?: Enumerable<LaundryUserHistoryOrderByWithRelationInput>
    cursor?: LaundryUserHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LaundryUserHistoryScalarFieldEnum>
  }


  /**
   * LaundryWashingMachine without action
   */
  export type LaundryWashingMachineArgs = {
    /**
     * Select specific fields to fetch from the LaundryWashingMachine
     */
    select?: LaundryWashingMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryWashingMachineInclude | null
  }



  /**
   * Model LaundryProgram
   */


  export type AggregateLaundryProgram = {
    _count: LaundryProgramCountAggregateOutputType | null
    _avg: LaundryProgramAvgAggregateOutputType | null
    _sum: LaundryProgramSumAggregateOutputType | null
    _min: LaundryProgramMinAggregateOutputType | null
    _max: LaundryProgramMaxAggregateOutputType | null
  }

  export type LaundryProgramAvgAggregateOutputType = {
    id: number | null
    price: number | null
    duration: number | null
    weight: number | null
  }

  export type LaundryProgramSumAggregateOutputType = {
    id: number | null
    price: number | null
    duration: number | null
    weight: number | null
  }

  export type LaundryProgramMinAggregateOutputType = {
    id: number | null
    name: string | null
    price: number | null
    duration: number | null
    weight: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LaundryProgramMaxAggregateOutputType = {
    id: number | null
    name: string | null
    price: number | null
    duration: number | null
    weight: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LaundryProgramCountAggregateOutputType = {
    id: number
    name: number
    price: number
    duration: number
    weight: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LaundryProgramAvgAggregateInputType = {
    id?: true
    price?: true
    duration?: true
    weight?: true
  }

  export type LaundryProgramSumAggregateInputType = {
    id?: true
    price?: true
    duration?: true
    weight?: true
  }

  export type LaundryProgramMinAggregateInputType = {
    id?: true
    name?: true
    price?: true
    duration?: true
    weight?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LaundryProgramMaxAggregateInputType = {
    id?: true
    name?: true
    price?: true
    duration?: true
    weight?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LaundryProgramCountAggregateInputType = {
    id?: true
    name?: true
    price?: true
    duration?: true
    weight?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LaundryProgramAggregateArgs = {
    /**
     * Filter which LaundryProgram to aggregate.
     */
    where?: LaundryProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryPrograms to fetch.
     */
    orderBy?: Enumerable<LaundryProgramOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LaundryProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LaundryPrograms
    **/
    _count?: true | LaundryProgramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LaundryProgramAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LaundryProgramSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LaundryProgramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LaundryProgramMaxAggregateInputType
  }

  export type GetLaundryProgramAggregateType<T extends LaundryProgramAggregateArgs> = {
        [P in keyof T & keyof AggregateLaundryProgram]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLaundryProgram[P]>
      : GetScalarType<T[P], AggregateLaundryProgram[P]>
  }




  export type LaundryProgramGroupByArgs = {
    where?: LaundryProgramWhereInput
    orderBy?: Enumerable<LaundryProgramOrderByWithAggregationInput>
    by: LaundryProgramScalarFieldEnum[]
    having?: LaundryProgramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LaundryProgramCountAggregateInputType | true
    _avg?: LaundryProgramAvgAggregateInputType
    _sum?: LaundryProgramSumAggregateInputType
    _min?: LaundryProgramMinAggregateInputType
    _max?: LaundryProgramMaxAggregateInputType
  }


  export type LaundryProgramGroupByOutputType = {
    id: number
    name: string
    price: number
    duration: number
    weight: number
    createdAt: Date
    updatedAt: Date
    _count: LaundryProgramCountAggregateOutputType | null
    _avg: LaundryProgramAvgAggregateOutputType | null
    _sum: LaundryProgramSumAggregateOutputType | null
    _min: LaundryProgramMinAggregateOutputType | null
    _max: LaundryProgramMaxAggregateOutputType | null
  }

  type GetLaundryProgramGroupByPayload<T extends LaundryProgramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LaundryProgramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LaundryProgramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LaundryProgramGroupByOutputType[P]>
            : GetScalarType<T[P], LaundryProgramGroupByOutputType[P]>
        }
      >
    >


  export type LaundryProgramSelect = {
    id?: boolean
    name?: boolean
    price?: boolean
    duration?: boolean
    weight?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    laundryWashingMachinesToPrograms?: boolean | LaundryProgram$laundryWashingMachinesToProgramsArgs
    laundryUserHistories?: boolean | LaundryProgram$laundryUserHistoriesArgs
    _count?: boolean | LaundryProgramCountOutputTypeArgs
  }


  export type LaundryProgramInclude = {
    laundryWashingMachinesToPrograms?: boolean | LaundryProgram$laundryWashingMachinesToProgramsArgs
    laundryUserHistories?: boolean | LaundryProgram$laundryUserHistoriesArgs
    _count?: boolean | LaundryProgramCountOutputTypeArgs
  }

  export type LaundryProgramGetPayload<S extends boolean | null | undefined | LaundryProgramArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LaundryProgram :
    S extends undefined ? never :
    S extends { include: any } & (LaundryProgramArgs | LaundryProgramFindManyArgs)
    ? LaundryProgram  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'laundryWashingMachinesToPrograms' ? Array < LaundryWashingMachineToProgramGetPayload<S['include'][P]>>  :
        P extends 'laundryUserHistories' ? Array < LaundryUserHistoryGetPayload<S['include'][P]>>  :
        P extends '_count' ? LaundryProgramCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (LaundryProgramArgs | LaundryProgramFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'laundryWashingMachinesToPrograms' ? Array < LaundryWashingMachineToProgramGetPayload<S['select'][P]>>  :
        P extends 'laundryUserHistories' ? Array < LaundryUserHistoryGetPayload<S['select'][P]>>  :
        P extends '_count' ? LaundryProgramCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof LaundryProgram ? LaundryProgram[P] : never
  } 
      : LaundryProgram


  type LaundryProgramCountArgs = 
    Omit<LaundryProgramFindManyArgs, 'select' | 'include'> & {
      select?: LaundryProgramCountAggregateInputType | true
    }

  export interface LaundryProgramDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one LaundryProgram that matches the filter.
     * @param {LaundryProgramFindUniqueArgs} args - Arguments to find a LaundryProgram
     * @example
     * // Get one LaundryProgram
     * const laundryProgram = await prisma.laundryProgram.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LaundryProgramFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LaundryProgramFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LaundryProgram'> extends True ? Prisma__LaundryProgramClient<LaundryProgramGetPayload<T>> : Prisma__LaundryProgramClient<LaundryProgramGetPayload<T> | null, null>

    /**
     * Find one LaundryProgram that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LaundryProgramFindUniqueOrThrowArgs} args - Arguments to find a LaundryProgram
     * @example
     * // Get one LaundryProgram
     * const laundryProgram = await prisma.laundryProgram.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LaundryProgramFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LaundryProgramFindUniqueOrThrowArgs>
    ): Prisma__LaundryProgramClient<LaundryProgramGetPayload<T>>

    /**
     * Find the first LaundryProgram that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryProgramFindFirstArgs} args - Arguments to find a LaundryProgram
     * @example
     * // Get one LaundryProgram
     * const laundryProgram = await prisma.laundryProgram.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LaundryProgramFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LaundryProgramFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LaundryProgram'> extends True ? Prisma__LaundryProgramClient<LaundryProgramGetPayload<T>> : Prisma__LaundryProgramClient<LaundryProgramGetPayload<T> | null, null>

    /**
     * Find the first LaundryProgram that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryProgramFindFirstOrThrowArgs} args - Arguments to find a LaundryProgram
     * @example
     * // Get one LaundryProgram
     * const laundryProgram = await prisma.laundryProgram.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LaundryProgramFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LaundryProgramFindFirstOrThrowArgs>
    ): Prisma__LaundryProgramClient<LaundryProgramGetPayload<T>>

    /**
     * Find zero or more LaundryPrograms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryProgramFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LaundryPrograms
     * const laundryPrograms = await prisma.laundryProgram.findMany()
     * 
     * // Get first 10 LaundryPrograms
     * const laundryPrograms = await prisma.laundryProgram.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const laundryProgramWithIdOnly = await prisma.laundryProgram.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LaundryProgramFindManyArgs>(
      args?: SelectSubset<T, LaundryProgramFindManyArgs>
    ): Prisma.PrismaPromise<Array<LaundryProgramGetPayload<T>>>

    /**
     * Create a LaundryProgram.
     * @param {LaundryProgramCreateArgs} args - Arguments to create a LaundryProgram.
     * @example
     * // Create one LaundryProgram
     * const LaundryProgram = await prisma.laundryProgram.create({
     *   data: {
     *     // ... data to create a LaundryProgram
     *   }
     * })
     * 
    **/
    create<T extends LaundryProgramCreateArgs>(
      args: SelectSubset<T, LaundryProgramCreateArgs>
    ): Prisma__LaundryProgramClient<LaundryProgramGetPayload<T>>

    /**
     * Create many LaundryPrograms.
     *     @param {LaundryProgramCreateManyArgs} args - Arguments to create many LaundryPrograms.
     *     @example
     *     // Create many LaundryPrograms
     *     const laundryProgram = await prisma.laundryProgram.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LaundryProgramCreateManyArgs>(
      args?: SelectSubset<T, LaundryProgramCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LaundryProgram.
     * @param {LaundryProgramDeleteArgs} args - Arguments to delete one LaundryProgram.
     * @example
     * // Delete one LaundryProgram
     * const LaundryProgram = await prisma.laundryProgram.delete({
     *   where: {
     *     // ... filter to delete one LaundryProgram
     *   }
     * })
     * 
    **/
    delete<T extends LaundryProgramDeleteArgs>(
      args: SelectSubset<T, LaundryProgramDeleteArgs>
    ): Prisma__LaundryProgramClient<LaundryProgramGetPayload<T>>

    /**
     * Update one LaundryProgram.
     * @param {LaundryProgramUpdateArgs} args - Arguments to update one LaundryProgram.
     * @example
     * // Update one LaundryProgram
     * const laundryProgram = await prisma.laundryProgram.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LaundryProgramUpdateArgs>(
      args: SelectSubset<T, LaundryProgramUpdateArgs>
    ): Prisma__LaundryProgramClient<LaundryProgramGetPayload<T>>

    /**
     * Delete zero or more LaundryPrograms.
     * @param {LaundryProgramDeleteManyArgs} args - Arguments to filter LaundryPrograms to delete.
     * @example
     * // Delete a few LaundryPrograms
     * const { count } = await prisma.laundryProgram.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LaundryProgramDeleteManyArgs>(
      args?: SelectSubset<T, LaundryProgramDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LaundryPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryProgramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LaundryPrograms
     * const laundryProgram = await prisma.laundryProgram.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LaundryProgramUpdateManyArgs>(
      args: SelectSubset<T, LaundryProgramUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LaundryProgram.
     * @param {LaundryProgramUpsertArgs} args - Arguments to update or create a LaundryProgram.
     * @example
     * // Update or create a LaundryProgram
     * const laundryProgram = await prisma.laundryProgram.upsert({
     *   create: {
     *     // ... data to create a LaundryProgram
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LaundryProgram we want to update
     *   }
     * })
    **/
    upsert<T extends LaundryProgramUpsertArgs>(
      args: SelectSubset<T, LaundryProgramUpsertArgs>
    ): Prisma__LaundryProgramClient<LaundryProgramGetPayload<T>>

    /**
     * Count the number of LaundryPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryProgramCountArgs} args - Arguments to filter LaundryPrograms to count.
     * @example
     * // Count the number of LaundryPrograms
     * const count = await prisma.laundryProgram.count({
     *   where: {
     *     // ... the filter for the LaundryPrograms we want to count
     *   }
     * })
    **/
    count<T extends LaundryProgramCountArgs>(
      args?: Subset<T, LaundryProgramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LaundryProgramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LaundryProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryProgramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LaundryProgramAggregateArgs>(args: Subset<T, LaundryProgramAggregateArgs>): Prisma.PrismaPromise<GetLaundryProgramAggregateType<T>>

    /**
     * Group by LaundryProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryProgramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LaundryProgramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LaundryProgramGroupByArgs['orderBy'] }
        : { orderBy?: LaundryProgramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LaundryProgramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLaundryProgramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LaundryProgram.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LaundryProgramClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    laundryWashingMachinesToPrograms<T extends LaundryProgram$laundryWashingMachinesToProgramsArgs= {}>(args?: Subset<T, LaundryProgram$laundryWashingMachinesToProgramsArgs>): Prisma.PrismaPromise<Array<LaundryWashingMachineToProgramGetPayload<T>>| Null>;

    laundryUserHistories<T extends LaundryProgram$laundryUserHistoriesArgs= {}>(args?: Subset<T, LaundryProgram$laundryUserHistoriesArgs>): Prisma.PrismaPromise<Array<LaundryUserHistoryGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LaundryProgram base type for findUnique actions
   */
  export type LaundryProgramFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the LaundryProgram
     */
    select?: LaundryProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryProgramInclude | null
    /**
     * Filter, which LaundryProgram to fetch.
     */
    where: LaundryProgramWhereUniqueInput
  }

  /**
   * LaundryProgram findUnique
   */
  export interface LaundryProgramFindUniqueArgs extends LaundryProgramFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LaundryProgram findUniqueOrThrow
   */
  export type LaundryProgramFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LaundryProgram
     */
    select?: LaundryProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryProgramInclude | null
    /**
     * Filter, which LaundryProgram to fetch.
     */
    where: LaundryProgramWhereUniqueInput
  }


  /**
   * LaundryProgram base type for findFirst actions
   */
  export type LaundryProgramFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the LaundryProgram
     */
    select?: LaundryProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryProgramInclude | null
    /**
     * Filter, which LaundryProgram to fetch.
     */
    where?: LaundryProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryPrograms to fetch.
     */
    orderBy?: Enumerable<LaundryProgramOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaundryPrograms.
     */
    cursor?: LaundryProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaundryPrograms.
     */
    distinct?: Enumerable<LaundryProgramScalarFieldEnum>
  }

  /**
   * LaundryProgram findFirst
   */
  export interface LaundryProgramFindFirstArgs extends LaundryProgramFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LaundryProgram findFirstOrThrow
   */
  export type LaundryProgramFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LaundryProgram
     */
    select?: LaundryProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryProgramInclude | null
    /**
     * Filter, which LaundryProgram to fetch.
     */
    where?: LaundryProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryPrograms to fetch.
     */
    orderBy?: Enumerable<LaundryProgramOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaundryPrograms.
     */
    cursor?: LaundryProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaundryPrograms.
     */
    distinct?: Enumerable<LaundryProgramScalarFieldEnum>
  }


  /**
   * LaundryProgram findMany
   */
  export type LaundryProgramFindManyArgs = {
    /**
     * Select specific fields to fetch from the LaundryProgram
     */
    select?: LaundryProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryProgramInclude | null
    /**
     * Filter, which LaundryPrograms to fetch.
     */
    where?: LaundryProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryPrograms to fetch.
     */
    orderBy?: Enumerable<LaundryProgramOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LaundryPrograms.
     */
    cursor?: LaundryProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryPrograms.
     */
    skip?: number
    distinct?: Enumerable<LaundryProgramScalarFieldEnum>
  }


  /**
   * LaundryProgram create
   */
  export type LaundryProgramCreateArgs = {
    /**
     * Select specific fields to fetch from the LaundryProgram
     */
    select?: LaundryProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryProgramInclude | null
    /**
     * The data needed to create a LaundryProgram.
     */
    data: XOR<LaundryProgramCreateInput, LaundryProgramUncheckedCreateInput>
  }


  /**
   * LaundryProgram createMany
   */
  export type LaundryProgramCreateManyArgs = {
    /**
     * The data used to create many LaundryPrograms.
     */
    data: Enumerable<LaundryProgramCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LaundryProgram update
   */
  export type LaundryProgramUpdateArgs = {
    /**
     * Select specific fields to fetch from the LaundryProgram
     */
    select?: LaundryProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryProgramInclude | null
    /**
     * The data needed to update a LaundryProgram.
     */
    data: XOR<LaundryProgramUpdateInput, LaundryProgramUncheckedUpdateInput>
    /**
     * Choose, which LaundryProgram to update.
     */
    where: LaundryProgramWhereUniqueInput
  }


  /**
   * LaundryProgram updateMany
   */
  export type LaundryProgramUpdateManyArgs = {
    /**
     * The data used to update LaundryPrograms.
     */
    data: XOR<LaundryProgramUpdateManyMutationInput, LaundryProgramUncheckedUpdateManyInput>
    /**
     * Filter which LaundryPrograms to update
     */
    where?: LaundryProgramWhereInput
  }


  /**
   * LaundryProgram upsert
   */
  export type LaundryProgramUpsertArgs = {
    /**
     * Select specific fields to fetch from the LaundryProgram
     */
    select?: LaundryProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryProgramInclude | null
    /**
     * The filter to search for the LaundryProgram to update in case it exists.
     */
    where: LaundryProgramWhereUniqueInput
    /**
     * In case the LaundryProgram found by the `where` argument doesn't exist, create a new LaundryProgram with this data.
     */
    create: XOR<LaundryProgramCreateInput, LaundryProgramUncheckedCreateInput>
    /**
     * In case the LaundryProgram was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LaundryProgramUpdateInput, LaundryProgramUncheckedUpdateInput>
  }


  /**
   * LaundryProgram delete
   */
  export type LaundryProgramDeleteArgs = {
    /**
     * Select specific fields to fetch from the LaundryProgram
     */
    select?: LaundryProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryProgramInclude | null
    /**
     * Filter which LaundryProgram to delete.
     */
    where: LaundryProgramWhereUniqueInput
  }


  /**
   * LaundryProgram deleteMany
   */
  export type LaundryProgramDeleteManyArgs = {
    /**
     * Filter which LaundryPrograms to delete
     */
    where?: LaundryProgramWhereInput
  }


  /**
   * LaundryProgram.laundryWashingMachinesToPrograms
   */
  export type LaundryProgram$laundryWashingMachinesToProgramsArgs = {
    /**
     * Select specific fields to fetch from the LaundryWashingMachineToProgram
     */
    select?: LaundryWashingMachineToProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryWashingMachineToProgramInclude | null
    where?: LaundryWashingMachineToProgramWhereInput
    orderBy?: Enumerable<LaundryWashingMachineToProgramOrderByWithRelationInput>
    cursor?: LaundryWashingMachineToProgramWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LaundryWashingMachineToProgramScalarFieldEnum>
  }


  /**
   * LaundryProgram.laundryUserHistories
   */
  export type LaundryProgram$laundryUserHistoriesArgs = {
    /**
     * Select specific fields to fetch from the LaundryUserHistory
     */
    select?: LaundryUserHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryUserHistoryInclude | null
    where?: LaundryUserHistoryWhereInput
    orderBy?: Enumerable<LaundryUserHistoryOrderByWithRelationInput>
    cursor?: LaundryUserHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LaundryUserHistoryScalarFieldEnum>
  }


  /**
   * LaundryProgram without action
   */
  export type LaundryProgramArgs = {
    /**
     * Select specific fields to fetch from the LaundryProgram
     */
    select?: LaundryProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryProgramInclude | null
  }



  /**
   * Model LaundryWashingMachineToProgram
   */


  export type AggregateLaundryWashingMachineToProgram = {
    _count: LaundryWashingMachineToProgramCountAggregateOutputType | null
    _avg: LaundryWashingMachineToProgramAvgAggregateOutputType | null
    _sum: LaundryWashingMachineToProgramSumAggregateOutputType | null
    _min: LaundryWashingMachineToProgramMinAggregateOutputType | null
    _max: LaundryWashingMachineToProgramMaxAggregateOutputType | null
  }

  export type LaundryWashingMachineToProgramAvgAggregateOutputType = {
    id: number | null
    laundryWashingMachineId: number | null
    laundryProgramId: number | null
  }

  export type LaundryWashingMachineToProgramSumAggregateOutputType = {
    id: number | null
    laundryWashingMachineId: number | null
    laundryProgramId: number | null
  }

  export type LaundryWashingMachineToProgramMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    laundryWashingMachineId: number | null
    laundryProgramId: number | null
  }

  export type LaundryWashingMachineToProgramMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    laundryWashingMachineId: number | null
    laundryProgramId: number | null
  }

  export type LaundryWashingMachineToProgramCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    laundryWashingMachineId: number
    laundryProgramId: number
    _all: number
  }


  export type LaundryWashingMachineToProgramAvgAggregateInputType = {
    id?: true
    laundryWashingMachineId?: true
    laundryProgramId?: true
  }

  export type LaundryWashingMachineToProgramSumAggregateInputType = {
    id?: true
    laundryWashingMachineId?: true
    laundryProgramId?: true
  }

  export type LaundryWashingMachineToProgramMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    laundryWashingMachineId?: true
    laundryProgramId?: true
  }

  export type LaundryWashingMachineToProgramMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    laundryWashingMachineId?: true
    laundryProgramId?: true
  }

  export type LaundryWashingMachineToProgramCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    laundryWashingMachineId?: true
    laundryProgramId?: true
    _all?: true
  }

  export type LaundryWashingMachineToProgramAggregateArgs = {
    /**
     * Filter which LaundryWashingMachineToProgram to aggregate.
     */
    where?: LaundryWashingMachineToProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryWashingMachineToPrograms to fetch.
     */
    orderBy?: Enumerable<LaundryWashingMachineToProgramOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LaundryWashingMachineToProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryWashingMachineToPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryWashingMachineToPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LaundryWashingMachineToPrograms
    **/
    _count?: true | LaundryWashingMachineToProgramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LaundryWashingMachineToProgramAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LaundryWashingMachineToProgramSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LaundryWashingMachineToProgramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LaundryWashingMachineToProgramMaxAggregateInputType
  }

  export type GetLaundryWashingMachineToProgramAggregateType<T extends LaundryWashingMachineToProgramAggregateArgs> = {
        [P in keyof T & keyof AggregateLaundryWashingMachineToProgram]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLaundryWashingMachineToProgram[P]>
      : GetScalarType<T[P], AggregateLaundryWashingMachineToProgram[P]>
  }




  export type LaundryWashingMachineToProgramGroupByArgs = {
    where?: LaundryWashingMachineToProgramWhereInput
    orderBy?: Enumerable<LaundryWashingMachineToProgramOrderByWithAggregationInput>
    by: LaundryWashingMachineToProgramScalarFieldEnum[]
    having?: LaundryWashingMachineToProgramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LaundryWashingMachineToProgramCountAggregateInputType | true
    _avg?: LaundryWashingMachineToProgramAvgAggregateInputType
    _sum?: LaundryWashingMachineToProgramSumAggregateInputType
    _min?: LaundryWashingMachineToProgramMinAggregateInputType
    _max?: LaundryWashingMachineToProgramMaxAggregateInputType
  }


  export type LaundryWashingMachineToProgramGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    laundryWashingMachineId: number
    laundryProgramId: number
    _count: LaundryWashingMachineToProgramCountAggregateOutputType | null
    _avg: LaundryWashingMachineToProgramAvgAggregateOutputType | null
    _sum: LaundryWashingMachineToProgramSumAggregateOutputType | null
    _min: LaundryWashingMachineToProgramMinAggregateOutputType | null
    _max: LaundryWashingMachineToProgramMaxAggregateOutputType | null
  }

  type GetLaundryWashingMachineToProgramGroupByPayload<T extends LaundryWashingMachineToProgramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LaundryWashingMachineToProgramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LaundryWashingMachineToProgramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LaundryWashingMachineToProgramGroupByOutputType[P]>
            : GetScalarType<T[P], LaundryWashingMachineToProgramGroupByOutputType[P]>
        }
      >
    >


  export type LaundryWashingMachineToProgramSelect = {
    id?: boolean
    machine?: boolean | LaundryWashingMachineArgs
    program?: boolean | LaundryProgramArgs
    createdAt?: boolean
    updatedAt?: boolean
    laundryWashingMachineId?: boolean
    laundryProgramId?: boolean
  }


  export type LaundryWashingMachineToProgramInclude = {
    machine?: boolean | LaundryWashingMachineArgs
    program?: boolean | LaundryProgramArgs
  }

  export type LaundryWashingMachineToProgramGetPayload<S extends boolean | null | undefined | LaundryWashingMachineToProgramArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LaundryWashingMachineToProgram :
    S extends undefined ? never :
    S extends { include: any } & (LaundryWashingMachineToProgramArgs | LaundryWashingMachineToProgramFindManyArgs)
    ? LaundryWashingMachineToProgram  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'machine' ? LaundryWashingMachineGetPayload<S['include'][P]> :
        P extends 'program' ? LaundryProgramGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (LaundryWashingMachineToProgramArgs | LaundryWashingMachineToProgramFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'machine' ? LaundryWashingMachineGetPayload<S['select'][P]> :
        P extends 'program' ? LaundryProgramGetPayload<S['select'][P]> :  P extends keyof LaundryWashingMachineToProgram ? LaundryWashingMachineToProgram[P] : never
  } 
      : LaundryWashingMachineToProgram


  type LaundryWashingMachineToProgramCountArgs = 
    Omit<LaundryWashingMachineToProgramFindManyArgs, 'select' | 'include'> & {
      select?: LaundryWashingMachineToProgramCountAggregateInputType | true
    }

  export interface LaundryWashingMachineToProgramDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one LaundryWashingMachineToProgram that matches the filter.
     * @param {LaundryWashingMachineToProgramFindUniqueArgs} args - Arguments to find a LaundryWashingMachineToProgram
     * @example
     * // Get one LaundryWashingMachineToProgram
     * const laundryWashingMachineToProgram = await prisma.laundryWashingMachineToProgram.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LaundryWashingMachineToProgramFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LaundryWashingMachineToProgramFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LaundryWashingMachineToProgram'> extends True ? Prisma__LaundryWashingMachineToProgramClient<LaundryWashingMachineToProgramGetPayload<T>> : Prisma__LaundryWashingMachineToProgramClient<LaundryWashingMachineToProgramGetPayload<T> | null, null>

    /**
     * Find one LaundryWashingMachineToProgram that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LaundryWashingMachineToProgramFindUniqueOrThrowArgs} args - Arguments to find a LaundryWashingMachineToProgram
     * @example
     * // Get one LaundryWashingMachineToProgram
     * const laundryWashingMachineToProgram = await prisma.laundryWashingMachineToProgram.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LaundryWashingMachineToProgramFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LaundryWashingMachineToProgramFindUniqueOrThrowArgs>
    ): Prisma__LaundryWashingMachineToProgramClient<LaundryWashingMachineToProgramGetPayload<T>>

    /**
     * Find the first LaundryWashingMachineToProgram that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryWashingMachineToProgramFindFirstArgs} args - Arguments to find a LaundryWashingMachineToProgram
     * @example
     * // Get one LaundryWashingMachineToProgram
     * const laundryWashingMachineToProgram = await prisma.laundryWashingMachineToProgram.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LaundryWashingMachineToProgramFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LaundryWashingMachineToProgramFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LaundryWashingMachineToProgram'> extends True ? Prisma__LaundryWashingMachineToProgramClient<LaundryWashingMachineToProgramGetPayload<T>> : Prisma__LaundryWashingMachineToProgramClient<LaundryWashingMachineToProgramGetPayload<T> | null, null>

    /**
     * Find the first LaundryWashingMachineToProgram that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryWashingMachineToProgramFindFirstOrThrowArgs} args - Arguments to find a LaundryWashingMachineToProgram
     * @example
     * // Get one LaundryWashingMachineToProgram
     * const laundryWashingMachineToProgram = await prisma.laundryWashingMachineToProgram.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LaundryWashingMachineToProgramFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LaundryWashingMachineToProgramFindFirstOrThrowArgs>
    ): Prisma__LaundryWashingMachineToProgramClient<LaundryWashingMachineToProgramGetPayload<T>>

    /**
     * Find zero or more LaundryWashingMachineToPrograms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryWashingMachineToProgramFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LaundryWashingMachineToPrograms
     * const laundryWashingMachineToPrograms = await prisma.laundryWashingMachineToProgram.findMany()
     * 
     * // Get first 10 LaundryWashingMachineToPrograms
     * const laundryWashingMachineToPrograms = await prisma.laundryWashingMachineToProgram.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const laundryWashingMachineToProgramWithIdOnly = await prisma.laundryWashingMachineToProgram.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LaundryWashingMachineToProgramFindManyArgs>(
      args?: SelectSubset<T, LaundryWashingMachineToProgramFindManyArgs>
    ): Prisma.PrismaPromise<Array<LaundryWashingMachineToProgramGetPayload<T>>>

    /**
     * Create a LaundryWashingMachineToProgram.
     * @param {LaundryWashingMachineToProgramCreateArgs} args - Arguments to create a LaundryWashingMachineToProgram.
     * @example
     * // Create one LaundryWashingMachineToProgram
     * const LaundryWashingMachineToProgram = await prisma.laundryWashingMachineToProgram.create({
     *   data: {
     *     // ... data to create a LaundryWashingMachineToProgram
     *   }
     * })
     * 
    **/
    create<T extends LaundryWashingMachineToProgramCreateArgs>(
      args: SelectSubset<T, LaundryWashingMachineToProgramCreateArgs>
    ): Prisma__LaundryWashingMachineToProgramClient<LaundryWashingMachineToProgramGetPayload<T>>

    /**
     * Create many LaundryWashingMachineToPrograms.
     *     @param {LaundryWashingMachineToProgramCreateManyArgs} args - Arguments to create many LaundryWashingMachineToPrograms.
     *     @example
     *     // Create many LaundryWashingMachineToPrograms
     *     const laundryWashingMachineToProgram = await prisma.laundryWashingMachineToProgram.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LaundryWashingMachineToProgramCreateManyArgs>(
      args?: SelectSubset<T, LaundryWashingMachineToProgramCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LaundryWashingMachineToProgram.
     * @param {LaundryWashingMachineToProgramDeleteArgs} args - Arguments to delete one LaundryWashingMachineToProgram.
     * @example
     * // Delete one LaundryWashingMachineToProgram
     * const LaundryWashingMachineToProgram = await prisma.laundryWashingMachineToProgram.delete({
     *   where: {
     *     // ... filter to delete one LaundryWashingMachineToProgram
     *   }
     * })
     * 
    **/
    delete<T extends LaundryWashingMachineToProgramDeleteArgs>(
      args: SelectSubset<T, LaundryWashingMachineToProgramDeleteArgs>
    ): Prisma__LaundryWashingMachineToProgramClient<LaundryWashingMachineToProgramGetPayload<T>>

    /**
     * Update one LaundryWashingMachineToProgram.
     * @param {LaundryWashingMachineToProgramUpdateArgs} args - Arguments to update one LaundryWashingMachineToProgram.
     * @example
     * // Update one LaundryWashingMachineToProgram
     * const laundryWashingMachineToProgram = await prisma.laundryWashingMachineToProgram.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LaundryWashingMachineToProgramUpdateArgs>(
      args: SelectSubset<T, LaundryWashingMachineToProgramUpdateArgs>
    ): Prisma__LaundryWashingMachineToProgramClient<LaundryWashingMachineToProgramGetPayload<T>>

    /**
     * Delete zero or more LaundryWashingMachineToPrograms.
     * @param {LaundryWashingMachineToProgramDeleteManyArgs} args - Arguments to filter LaundryWashingMachineToPrograms to delete.
     * @example
     * // Delete a few LaundryWashingMachineToPrograms
     * const { count } = await prisma.laundryWashingMachineToProgram.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LaundryWashingMachineToProgramDeleteManyArgs>(
      args?: SelectSubset<T, LaundryWashingMachineToProgramDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LaundryWashingMachineToPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryWashingMachineToProgramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LaundryWashingMachineToPrograms
     * const laundryWashingMachineToProgram = await prisma.laundryWashingMachineToProgram.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LaundryWashingMachineToProgramUpdateManyArgs>(
      args: SelectSubset<T, LaundryWashingMachineToProgramUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LaundryWashingMachineToProgram.
     * @param {LaundryWashingMachineToProgramUpsertArgs} args - Arguments to update or create a LaundryWashingMachineToProgram.
     * @example
     * // Update or create a LaundryWashingMachineToProgram
     * const laundryWashingMachineToProgram = await prisma.laundryWashingMachineToProgram.upsert({
     *   create: {
     *     // ... data to create a LaundryWashingMachineToProgram
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LaundryWashingMachineToProgram we want to update
     *   }
     * })
    **/
    upsert<T extends LaundryWashingMachineToProgramUpsertArgs>(
      args: SelectSubset<T, LaundryWashingMachineToProgramUpsertArgs>
    ): Prisma__LaundryWashingMachineToProgramClient<LaundryWashingMachineToProgramGetPayload<T>>

    /**
     * Count the number of LaundryWashingMachineToPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryWashingMachineToProgramCountArgs} args - Arguments to filter LaundryWashingMachineToPrograms to count.
     * @example
     * // Count the number of LaundryWashingMachineToPrograms
     * const count = await prisma.laundryWashingMachineToProgram.count({
     *   where: {
     *     // ... the filter for the LaundryWashingMachineToPrograms we want to count
     *   }
     * })
    **/
    count<T extends LaundryWashingMachineToProgramCountArgs>(
      args?: Subset<T, LaundryWashingMachineToProgramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LaundryWashingMachineToProgramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LaundryWashingMachineToProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryWashingMachineToProgramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LaundryWashingMachineToProgramAggregateArgs>(args: Subset<T, LaundryWashingMachineToProgramAggregateArgs>): Prisma.PrismaPromise<GetLaundryWashingMachineToProgramAggregateType<T>>

    /**
     * Group by LaundryWashingMachineToProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryWashingMachineToProgramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LaundryWashingMachineToProgramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LaundryWashingMachineToProgramGroupByArgs['orderBy'] }
        : { orderBy?: LaundryWashingMachineToProgramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LaundryWashingMachineToProgramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLaundryWashingMachineToProgramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LaundryWashingMachineToProgram.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LaundryWashingMachineToProgramClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    machine<T extends LaundryWashingMachineArgs= {}>(args?: Subset<T, LaundryWashingMachineArgs>): Prisma__LaundryWashingMachineClient<LaundryWashingMachineGetPayload<T> | Null>;

    program<T extends LaundryProgramArgs= {}>(args?: Subset<T, LaundryProgramArgs>): Prisma__LaundryProgramClient<LaundryProgramGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LaundryWashingMachineToProgram base type for findUnique actions
   */
  export type LaundryWashingMachineToProgramFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the LaundryWashingMachineToProgram
     */
    select?: LaundryWashingMachineToProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryWashingMachineToProgramInclude | null
    /**
     * Filter, which LaundryWashingMachineToProgram to fetch.
     */
    where: LaundryWashingMachineToProgramWhereUniqueInput
  }

  /**
   * LaundryWashingMachineToProgram findUnique
   */
  export interface LaundryWashingMachineToProgramFindUniqueArgs extends LaundryWashingMachineToProgramFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LaundryWashingMachineToProgram findUniqueOrThrow
   */
  export type LaundryWashingMachineToProgramFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LaundryWashingMachineToProgram
     */
    select?: LaundryWashingMachineToProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryWashingMachineToProgramInclude | null
    /**
     * Filter, which LaundryWashingMachineToProgram to fetch.
     */
    where: LaundryWashingMachineToProgramWhereUniqueInput
  }


  /**
   * LaundryWashingMachineToProgram base type for findFirst actions
   */
  export type LaundryWashingMachineToProgramFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the LaundryWashingMachineToProgram
     */
    select?: LaundryWashingMachineToProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryWashingMachineToProgramInclude | null
    /**
     * Filter, which LaundryWashingMachineToProgram to fetch.
     */
    where?: LaundryWashingMachineToProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryWashingMachineToPrograms to fetch.
     */
    orderBy?: Enumerable<LaundryWashingMachineToProgramOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaundryWashingMachineToPrograms.
     */
    cursor?: LaundryWashingMachineToProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryWashingMachineToPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryWashingMachineToPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaundryWashingMachineToPrograms.
     */
    distinct?: Enumerable<LaundryWashingMachineToProgramScalarFieldEnum>
  }

  /**
   * LaundryWashingMachineToProgram findFirst
   */
  export interface LaundryWashingMachineToProgramFindFirstArgs extends LaundryWashingMachineToProgramFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LaundryWashingMachineToProgram findFirstOrThrow
   */
  export type LaundryWashingMachineToProgramFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LaundryWashingMachineToProgram
     */
    select?: LaundryWashingMachineToProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryWashingMachineToProgramInclude | null
    /**
     * Filter, which LaundryWashingMachineToProgram to fetch.
     */
    where?: LaundryWashingMachineToProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryWashingMachineToPrograms to fetch.
     */
    orderBy?: Enumerable<LaundryWashingMachineToProgramOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaundryWashingMachineToPrograms.
     */
    cursor?: LaundryWashingMachineToProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryWashingMachineToPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryWashingMachineToPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaundryWashingMachineToPrograms.
     */
    distinct?: Enumerable<LaundryWashingMachineToProgramScalarFieldEnum>
  }


  /**
   * LaundryWashingMachineToProgram findMany
   */
  export type LaundryWashingMachineToProgramFindManyArgs = {
    /**
     * Select specific fields to fetch from the LaundryWashingMachineToProgram
     */
    select?: LaundryWashingMachineToProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryWashingMachineToProgramInclude | null
    /**
     * Filter, which LaundryWashingMachineToPrograms to fetch.
     */
    where?: LaundryWashingMachineToProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryWashingMachineToPrograms to fetch.
     */
    orderBy?: Enumerable<LaundryWashingMachineToProgramOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LaundryWashingMachineToPrograms.
     */
    cursor?: LaundryWashingMachineToProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryWashingMachineToPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryWashingMachineToPrograms.
     */
    skip?: number
    distinct?: Enumerable<LaundryWashingMachineToProgramScalarFieldEnum>
  }


  /**
   * LaundryWashingMachineToProgram create
   */
  export type LaundryWashingMachineToProgramCreateArgs = {
    /**
     * Select specific fields to fetch from the LaundryWashingMachineToProgram
     */
    select?: LaundryWashingMachineToProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryWashingMachineToProgramInclude | null
    /**
     * The data needed to create a LaundryWashingMachineToProgram.
     */
    data: XOR<LaundryWashingMachineToProgramCreateInput, LaundryWashingMachineToProgramUncheckedCreateInput>
  }


  /**
   * LaundryWashingMachineToProgram createMany
   */
  export type LaundryWashingMachineToProgramCreateManyArgs = {
    /**
     * The data used to create many LaundryWashingMachineToPrograms.
     */
    data: Enumerable<LaundryWashingMachineToProgramCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LaundryWashingMachineToProgram update
   */
  export type LaundryWashingMachineToProgramUpdateArgs = {
    /**
     * Select specific fields to fetch from the LaundryWashingMachineToProgram
     */
    select?: LaundryWashingMachineToProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryWashingMachineToProgramInclude | null
    /**
     * The data needed to update a LaundryWashingMachineToProgram.
     */
    data: XOR<LaundryWashingMachineToProgramUpdateInput, LaundryWashingMachineToProgramUncheckedUpdateInput>
    /**
     * Choose, which LaundryWashingMachineToProgram to update.
     */
    where: LaundryWashingMachineToProgramWhereUniqueInput
  }


  /**
   * LaundryWashingMachineToProgram updateMany
   */
  export type LaundryWashingMachineToProgramUpdateManyArgs = {
    /**
     * The data used to update LaundryWashingMachineToPrograms.
     */
    data: XOR<LaundryWashingMachineToProgramUpdateManyMutationInput, LaundryWashingMachineToProgramUncheckedUpdateManyInput>
    /**
     * Filter which LaundryWashingMachineToPrograms to update
     */
    where?: LaundryWashingMachineToProgramWhereInput
  }


  /**
   * LaundryWashingMachineToProgram upsert
   */
  export type LaundryWashingMachineToProgramUpsertArgs = {
    /**
     * Select specific fields to fetch from the LaundryWashingMachineToProgram
     */
    select?: LaundryWashingMachineToProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryWashingMachineToProgramInclude | null
    /**
     * The filter to search for the LaundryWashingMachineToProgram to update in case it exists.
     */
    where: LaundryWashingMachineToProgramWhereUniqueInput
    /**
     * In case the LaundryWashingMachineToProgram found by the `where` argument doesn't exist, create a new LaundryWashingMachineToProgram with this data.
     */
    create: XOR<LaundryWashingMachineToProgramCreateInput, LaundryWashingMachineToProgramUncheckedCreateInput>
    /**
     * In case the LaundryWashingMachineToProgram was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LaundryWashingMachineToProgramUpdateInput, LaundryWashingMachineToProgramUncheckedUpdateInput>
  }


  /**
   * LaundryWashingMachineToProgram delete
   */
  export type LaundryWashingMachineToProgramDeleteArgs = {
    /**
     * Select specific fields to fetch from the LaundryWashingMachineToProgram
     */
    select?: LaundryWashingMachineToProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryWashingMachineToProgramInclude | null
    /**
     * Filter which LaundryWashingMachineToProgram to delete.
     */
    where: LaundryWashingMachineToProgramWhereUniqueInput
  }


  /**
   * LaundryWashingMachineToProgram deleteMany
   */
  export type LaundryWashingMachineToProgramDeleteManyArgs = {
    /**
     * Filter which LaundryWashingMachineToPrograms to delete
     */
    where?: LaundryWashingMachineToProgramWhereInput
  }


  /**
   * LaundryWashingMachineToProgram without action
   */
  export type LaundryWashingMachineToProgramArgs = {
    /**
     * Select specific fields to fetch from the LaundryWashingMachineToProgram
     */
    select?: LaundryWashingMachineToProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryWashingMachineToProgramInclude | null
  }



  /**
   * Model LaundryMaintainance
   */


  export type AggregateLaundryMaintainance = {
    _count: LaundryMaintainanceCountAggregateOutputType | null
    _avg: LaundryMaintainanceAvgAggregateOutputType | null
    _sum: LaundryMaintainanceSumAggregateOutputType | null
    _min: LaundryMaintainanceMinAggregateOutputType | null
    _max: LaundryMaintainanceMaxAggregateOutputType | null
  }

  export type LaundryMaintainanceAvgAggregateOutputType = {
    id: number | null
    round: number | null
    date: number | null
    damageLevel: number | null
    laundryWashingMachineId: number | null
  }

  export type LaundryMaintainanceSumAggregateOutputType = {
    id: number | null
    round: number | null
    date: number | null
    damageLevel: number | null
    laundryWashingMachineId: number | null
  }

  export type LaundryMaintainanceMinAggregateOutputType = {
    id: number | null
    round: number | null
    date: number | null
    damageLevel: number | null
    description: string | null
    technicianName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    laundryWashingMachineId: number | null
  }

  export type LaundryMaintainanceMaxAggregateOutputType = {
    id: number | null
    round: number | null
    date: number | null
    damageLevel: number | null
    description: string | null
    technicianName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    laundryWashingMachineId: number | null
  }

  export type LaundryMaintainanceCountAggregateOutputType = {
    id: number
    round: number
    date: number
    damageLevel: number
    description: number
    technicianName: number
    createdAt: number
    updatedAt: number
    laundryWashingMachineId: number
    _all: number
  }


  export type LaundryMaintainanceAvgAggregateInputType = {
    id?: true
    round?: true
    date?: true
    damageLevel?: true
    laundryWashingMachineId?: true
  }

  export type LaundryMaintainanceSumAggregateInputType = {
    id?: true
    round?: true
    date?: true
    damageLevel?: true
    laundryWashingMachineId?: true
  }

  export type LaundryMaintainanceMinAggregateInputType = {
    id?: true
    round?: true
    date?: true
    damageLevel?: true
    description?: true
    technicianName?: true
    createdAt?: true
    updatedAt?: true
    laundryWashingMachineId?: true
  }

  export type LaundryMaintainanceMaxAggregateInputType = {
    id?: true
    round?: true
    date?: true
    damageLevel?: true
    description?: true
    technicianName?: true
    createdAt?: true
    updatedAt?: true
    laundryWashingMachineId?: true
  }

  export type LaundryMaintainanceCountAggregateInputType = {
    id?: true
    round?: true
    date?: true
    damageLevel?: true
    description?: true
    technicianName?: true
    createdAt?: true
    updatedAt?: true
    laundryWashingMachineId?: true
    _all?: true
  }

  export type LaundryMaintainanceAggregateArgs = {
    /**
     * Filter which LaundryMaintainance to aggregate.
     */
    where?: LaundryMaintainanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryMaintainances to fetch.
     */
    orderBy?: Enumerable<LaundryMaintainanceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LaundryMaintainanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryMaintainances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryMaintainances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LaundryMaintainances
    **/
    _count?: true | LaundryMaintainanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LaundryMaintainanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LaundryMaintainanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LaundryMaintainanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LaundryMaintainanceMaxAggregateInputType
  }

  export type GetLaundryMaintainanceAggregateType<T extends LaundryMaintainanceAggregateArgs> = {
        [P in keyof T & keyof AggregateLaundryMaintainance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLaundryMaintainance[P]>
      : GetScalarType<T[P], AggregateLaundryMaintainance[P]>
  }




  export type LaundryMaintainanceGroupByArgs = {
    where?: LaundryMaintainanceWhereInput
    orderBy?: Enumerable<LaundryMaintainanceOrderByWithAggregationInput>
    by: LaundryMaintainanceScalarFieldEnum[]
    having?: LaundryMaintainanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LaundryMaintainanceCountAggregateInputType | true
    _avg?: LaundryMaintainanceAvgAggregateInputType
    _sum?: LaundryMaintainanceSumAggregateInputType
    _min?: LaundryMaintainanceMinAggregateInputType
    _max?: LaundryMaintainanceMaxAggregateInputType
  }


  export type LaundryMaintainanceGroupByOutputType = {
    id: number
    round: number
    date: number
    damageLevel: number
    description: string
    technicianName: string
    createdAt: Date
    updatedAt: Date
    laundryWashingMachineId: number
    _count: LaundryMaintainanceCountAggregateOutputType | null
    _avg: LaundryMaintainanceAvgAggregateOutputType | null
    _sum: LaundryMaintainanceSumAggregateOutputType | null
    _min: LaundryMaintainanceMinAggregateOutputType | null
    _max: LaundryMaintainanceMaxAggregateOutputType | null
  }

  type GetLaundryMaintainanceGroupByPayload<T extends LaundryMaintainanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LaundryMaintainanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LaundryMaintainanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LaundryMaintainanceGroupByOutputType[P]>
            : GetScalarType<T[P], LaundryMaintainanceGroupByOutputType[P]>
        }
      >
    >


  export type LaundryMaintainanceSelect = {
    id?: boolean
    round?: boolean
    machine?: boolean | LaundryWashingMachineArgs
    date?: boolean
    damageLevel?: boolean
    description?: boolean
    technicianName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    laundryWashingMachineId?: boolean
  }


  export type LaundryMaintainanceInclude = {
    machine?: boolean | LaundryWashingMachineArgs
  }

  export type LaundryMaintainanceGetPayload<S extends boolean | null | undefined | LaundryMaintainanceArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LaundryMaintainance :
    S extends undefined ? never :
    S extends { include: any } & (LaundryMaintainanceArgs | LaundryMaintainanceFindManyArgs)
    ? LaundryMaintainance  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'machine' ? LaundryWashingMachineGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (LaundryMaintainanceArgs | LaundryMaintainanceFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'machine' ? LaundryWashingMachineGetPayload<S['select'][P]> :  P extends keyof LaundryMaintainance ? LaundryMaintainance[P] : never
  } 
      : LaundryMaintainance


  type LaundryMaintainanceCountArgs = 
    Omit<LaundryMaintainanceFindManyArgs, 'select' | 'include'> & {
      select?: LaundryMaintainanceCountAggregateInputType | true
    }

  export interface LaundryMaintainanceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one LaundryMaintainance that matches the filter.
     * @param {LaundryMaintainanceFindUniqueArgs} args - Arguments to find a LaundryMaintainance
     * @example
     * // Get one LaundryMaintainance
     * const laundryMaintainance = await prisma.laundryMaintainance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LaundryMaintainanceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LaundryMaintainanceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LaundryMaintainance'> extends True ? Prisma__LaundryMaintainanceClient<LaundryMaintainanceGetPayload<T>> : Prisma__LaundryMaintainanceClient<LaundryMaintainanceGetPayload<T> | null, null>

    /**
     * Find one LaundryMaintainance that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LaundryMaintainanceFindUniqueOrThrowArgs} args - Arguments to find a LaundryMaintainance
     * @example
     * // Get one LaundryMaintainance
     * const laundryMaintainance = await prisma.laundryMaintainance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LaundryMaintainanceFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LaundryMaintainanceFindUniqueOrThrowArgs>
    ): Prisma__LaundryMaintainanceClient<LaundryMaintainanceGetPayload<T>>

    /**
     * Find the first LaundryMaintainance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryMaintainanceFindFirstArgs} args - Arguments to find a LaundryMaintainance
     * @example
     * // Get one LaundryMaintainance
     * const laundryMaintainance = await prisma.laundryMaintainance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LaundryMaintainanceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LaundryMaintainanceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LaundryMaintainance'> extends True ? Prisma__LaundryMaintainanceClient<LaundryMaintainanceGetPayload<T>> : Prisma__LaundryMaintainanceClient<LaundryMaintainanceGetPayload<T> | null, null>

    /**
     * Find the first LaundryMaintainance that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryMaintainanceFindFirstOrThrowArgs} args - Arguments to find a LaundryMaintainance
     * @example
     * // Get one LaundryMaintainance
     * const laundryMaintainance = await prisma.laundryMaintainance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LaundryMaintainanceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LaundryMaintainanceFindFirstOrThrowArgs>
    ): Prisma__LaundryMaintainanceClient<LaundryMaintainanceGetPayload<T>>

    /**
     * Find zero or more LaundryMaintainances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryMaintainanceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LaundryMaintainances
     * const laundryMaintainances = await prisma.laundryMaintainance.findMany()
     * 
     * // Get first 10 LaundryMaintainances
     * const laundryMaintainances = await prisma.laundryMaintainance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const laundryMaintainanceWithIdOnly = await prisma.laundryMaintainance.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LaundryMaintainanceFindManyArgs>(
      args?: SelectSubset<T, LaundryMaintainanceFindManyArgs>
    ): Prisma.PrismaPromise<Array<LaundryMaintainanceGetPayload<T>>>

    /**
     * Create a LaundryMaintainance.
     * @param {LaundryMaintainanceCreateArgs} args - Arguments to create a LaundryMaintainance.
     * @example
     * // Create one LaundryMaintainance
     * const LaundryMaintainance = await prisma.laundryMaintainance.create({
     *   data: {
     *     // ... data to create a LaundryMaintainance
     *   }
     * })
     * 
    **/
    create<T extends LaundryMaintainanceCreateArgs>(
      args: SelectSubset<T, LaundryMaintainanceCreateArgs>
    ): Prisma__LaundryMaintainanceClient<LaundryMaintainanceGetPayload<T>>

    /**
     * Create many LaundryMaintainances.
     *     @param {LaundryMaintainanceCreateManyArgs} args - Arguments to create many LaundryMaintainances.
     *     @example
     *     // Create many LaundryMaintainances
     *     const laundryMaintainance = await prisma.laundryMaintainance.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LaundryMaintainanceCreateManyArgs>(
      args?: SelectSubset<T, LaundryMaintainanceCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LaundryMaintainance.
     * @param {LaundryMaintainanceDeleteArgs} args - Arguments to delete one LaundryMaintainance.
     * @example
     * // Delete one LaundryMaintainance
     * const LaundryMaintainance = await prisma.laundryMaintainance.delete({
     *   where: {
     *     // ... filter to delete one LaundryMaintainance
     *   }
     * })
     * 
    **/
    delete<T extends LaundryMaintainanceDeleteArgs>(
      args: SelectSubset<T, LaundryMaintainanceDeleteArgs>
    ): Prisma__LaundryMaintainanceClient<LaundryMaintainanceGetPayload<T>>

    /**
     * Update one LaundryMaintainance.
     * @param {LaundryMaintainanceUpdateArgs} args - Arguments to update one LaundryMaintainance.
     * @example
     * // Update one LaundryMaintainance
     * const laundryMaintainance = await prisma.laundryMaintainance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LaundryMaintainanceUpdateArgs>(
      args: SelectSubset<T, LaundryMaintainanceUpdateArgs>
    ): Prisma__LaundryMaintainanceClient<LaundryMaintainanceGetPayload<T>>

    /**
     * Delete zero or more LaundryMaintainances.
     * @param {LaundryMaintainanceDeleteManyArgs} args - Arguments to filter LaundryMaintainances to delete.
     * @example
     * // Delete a few LaundryMaintainances
     * const { count } = await prisma.laundryMaintainance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LaundryMaintainanceDeleteManyArgs>(
      args?: SelectSubset<T, LaundryMaintainanceDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LaundryMaintainances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryMaintainanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LaundryMaintainances
     * const laundryMaintainance = await prisma.laundryMaintainance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LaundryMaintainanceUpdateManyArgs>(
      args: SelectSubset<T, LaundryMaintainanceUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LaundryMaintainance.
     * @param {LaundryMaintainanceUpsertArgs} args - Arguments to update or create a LaundryMaintainance.
     * @example
     * // Update or create a LaundryMaintainance
     * const laundryMaintainance = await prisma.laundryMaintainance.upsert({
     *   create: {
     *     // ... data to create a LaundryMaintainance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LaundryMaintainance we want to update
     *   }
     * })
    **/
    upsert<T extends LaundryMaintainanceUpsertArgs>(
      args: SelectSubset<T, LaundryMaintainanceUpsertArgs>
    ): Prisma__LaundryMaintainanceClient<LaundryMaintainanceGetPayload<T>>

    /**
     * Count the number of LaundryMaintainances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryMaintainanceCountArgs} args - Arguments to filter LaundryMaintainances to count.
     * @example
     * // Count the number of LaundryMaintainances
     * const count = await prisma.laundryMaintainance.count({
     *   where: {
     *     // ... the filter for the LaundryMaintainances we want to count
     *   }
     * })
    **/
    count<T extends LaundryMaintainanceCountArgs>(
      args?: Subset<T, LaundryMaintainanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LaundryMaintainanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LaundryMaintainance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryMaintainanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LaundryMaintainanceAggregateArgs>(args: Subset<T, LaundryMaintainanceAggregateArgs>): Prisma.PrismaPromise<GetLaundryMaintainanceAggregateType<T>>

    /**
     * Group by LaundryMaintainance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryMaintainanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LaundryMaintainanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LaundryMaintainanceGroupByArgs['orderBy'] }
        : { orderBy?: LaundryMaintainanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LaundryMaintainanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLaundryMaintainanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LaundryMaintainance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LaundryMaintainanceClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    machine<T extends LaundryWashingMachineArgs= {}>(args?: Subset<T, LaundryWashingMachineArgs>): Prisma__LaundryWashingMachineClient<LaundryWashingMachineGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LaundryMaintainance base type for findUnique actions
   */
  export type LaundryMaintainanceFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the LaundryMaintainance
     */
    select?: LaundryMaintainanceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryMaintainanceInclude | null
    /**
     * Filter, which LaundryMaintainance to fetch.
     */
    where: LaundryMaintainanceWhereUniqueInput
  }

  /**
   * LaundryMaintainance findUnique
   */
  export interface LaundryMaintainanceFindUniqueArgs extends LaundryMaintainanceFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LaundryMaintainance findUniqueOrThrow
   */
  export type LaundryMaintainanceFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LaundryMaintainance
     */
    select?: LaundryMaintainanceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryMaintainanceInclude | null
    /**
     * Filter, which LaundryMaintainance to fetch.
     */
    where: LaundryMaintainanceWhereUniqueInput
  }


  /**
   * LaundryMaintainance base type for findFirst actions
   */
  export type LaundryMaintainanceFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the LaundryMaintainance
     */
    select?: LaundryMaintainanceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryMaintainanceInclude | null
    /**
     * Filter, which LaundryMaintainance to fetch.
     */
    where?: LaundryMaintainanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryMaintainances to fetch.
     */
    orderBy?: Enumerable<LaundryMaintainanceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaundryMaintainances.
     */
    cursor?: LaundryMaintainanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryMaintainances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryMaintainances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaundryMaintainances.
     */
    distinct?: Enumerable<LaundryMaintainanceScalarFieldEnum>
  }

  /**
   * LaundryMaintainance findFirst
   */
  export interface LaundryMaintainanceFindFirstArgs extends LaundryMaintainanceFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LaundryMaintainance findFirstOrThrow
   */
  export type LaundryMaintainanceFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LaundryMaintainance
     */
    select?: LaundryMaintainanceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryMaintainanceInclude | null
    /**
     * Filter, which LaundryMaintainance to fetch.
     */
    where?: LaundryMaintainanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryMaintainances to fetch.
     */
    orderBy?: Enumerable<LaundryMaintainanceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaundryMaintainances.
     */
    cursor?: LaundryMaintainanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryMaintainances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryMaintainances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaundryMaintainances.
     */
    distinct?: Enumerable<LaundryMaintainanceScalarFieldEnum>
  }


  /**
   * LaundryMaintainance findMany
   */
  export type LaundryMaintainanceFindManyArgs = {
    /**
     * Select specific fields to fetch from the LaundryMaintainance
     */
    select?: LaundryMaintainanceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryMaintainanceInclude | null
    /**
     * Filter, which LaundryMaintainances to fetch.
     */
    where?: LaundryMaintainanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryMaintainances to fetch.
     */
    orderBy?: Enumerable<LaundryMaintainanceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LaundryMaintainances.
     */
    cursor?: LaundryMaintainanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryMaintainances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryMaintainances.
     */
    skip?: number
    distinct?: Enumerable<LaundryMaintainanceScalarFieldEnum>
  }


  /**
   * LaundryMaintainance create
   */
  export type LaundryMaintainanceCreateArgs = {
    /**
     * Select specific fields to fetch from the LaundryMaintainance
     */
    select?: LaundryMaintainanceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryMaintainanceInclude | null
    /**
     * The data needed to create a LaundryMaintainance.
     */
    data: XOR<LaundryMaintainanceCreateInput, LaundryMaintainanceUncheckedCreateInput>
  }


  /**
   * LaundryMaintainance createMany
   */
  export type LaundryMaintainanceCreateManyArgs = {
    /**
     * The data used to create many LaundryMaintainances.
     */
    data: Enumerable<LaundryMaintainanceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LaundryMaintainance update
   */
  export type LaundryMaintainanceUpdateArgs = {
    /**
     * Select specific fields to fetch from the LaundryMaintainance
     */
    select?: LaundryMaintainanceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryMaintainanceInclude | null
    /**
     * The data needed to update a LaundryMaintainance.
     */
    data: XOR<LaundryMaintainanceUpdateInput, LaundryMaintainanceUncheckedUpdateInput>
    /**
     * Choose, which LaundryMaintainance to update.
     */
    where: LaundryMaintainanceWhereUniqueInput
  }


  /**
   * LaundryMaintainance updateMany
   */
  export type LaundryMaintainanceUpdateManyArgs = {
    /**
     * The data used to update LaundryMaintainances.
     */
    data: XOR<LaundryMaintainanceUpdateManyMutationInput, LaundryMaintainanceUncheckedUpdateManyInput>
    /**
     * Filter which LaundryMaintainances to update
     */
    where?: LaundryMaintainanceWhereInput
  }


  /**
   * LaundryMaintainance upsert
   */
  export type LaundryMaintainanceUpsertArgs = {
    /**
     * Select specific fields to fetch from the LaundryMaintainance
     */
    select?: LaundryMaintainanceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryMaintainanceInclude | null
    /**
     * The filter to search for the LaundryMaintainance to update in case it exists.
     */
    where: LaundryMaintainanceWhereUniqueInput
    /**
     * In case the LaundryMaintainance found by the `where` argument doesn't exist, create a new LaundryMaintainance with this data.
     */
    create: XOR<LaundryMaintainanceCreateInput, LaundryMaintainanceUncheckedCreateInput>
    /**
     * In case the LaundryMaintainance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LaundryMaintainanceUpdateInput, LaundryMaintainanceUncheckedUpdateInput>
  }


  /**
   * LaundryMaintainance delete
   */
  export type LaundryMaintainanceDeleteArgs = {
    /**
     * Select specific fields to fetch from the LaundryMaintainance
     */
    select?: LaundryMaintainanceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryMaintainanceInclude | null
    /**
     * Filter which LaundryMaintainance to delete.
     */
    where: LaundryMaintainanceWhereUniqueInput
  }


  /**
   * LaundryMaintainance deleteMany
   */
  export type LaundryMaintainanceDeleteManyArgs = {
    /**
     * Filter which LaundryMaintainances to delete
     */
    where?: LaundryMaintainanceWhereInput
  }


  /**
   * LaundryMaintainance without action
   */
  export type LaundryMaintainanceArgs = {
    /**
     * Select specific fields to fetch from the LaundryMaintainance
     */
    select?: LaundryMaintainanceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryMaintainanceInclude | null
  }



  /**
   * Model LaundryUser
   */


  export type AggregateLaundryUser = {
    _count: LaundryUserCountAggregateOutputType | null
    _avg: LaundryUserAvgAggregateOutputType | null
    _sum: LaundryUserSumAggregateOutputType | null
    _min: LaundryUserMinAggregateOutputType | null
    _max: LaundryUserMaxAggregateOutputType | null
  }

  export type LaundryUserAvgAggregateOutputType = {
    id: number | null
    tel: number | null
    balance: number | null
  }

  export type LaundryUserSumAggregateOutputType = {
    id: number | null
    tel: number | null
    balance: number | null
  }

  export type LaundryUserMinAggregateOutputType = {
    id: number | null
    name: string | null
    tel: number | null
    balance: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LaundryUserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    tel: number | null
    balance: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LaundryUserCountAggregateOutputType = {
    id: number
    name: number
    tel: number
    balance: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LaundryUserAvgAggregateInputType = {
    id?: true
    tel?: true
    balance?: true
  }

  export type LaundryUserSumAggregateInputType = {
    id?: true
    tel?: true
    balance?: true
  }

  export type LaundryUserMinAggregateInputType = {
    id?: true
    name?: true
    tel?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LaundryUserMaxAggregateInputType = {
    id?: true
    name?: true
    tel?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LaundryUserCountAggregateInputType = {
    id?: true
    name?: true
    tel?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LaundryUserAggregateArgs = {
    /**
     * Filter which LaundryUser to aggregate.
     */
    where?: LaundryUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryUsers to fetch.
     */
    orderBy?: Enumerable<LaundryUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LaundryUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LaundryUsers
    **/
    _count?: true | LaundryUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LaundryUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LaundryUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LaundryUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LaundryUserMaxAggregateInputType
  }

  export type GetLaundryUserAggregateType<T extends LaundryUserAggregateArgs> = {
        [P in keyof T & keyof AggregateLaundryUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLaundryUser[P]>
      : GetScalarType<T[P], AggregateLaundryUser[P]>
  }




  export type LaundryUserGroupByArgs = {
    where?: LaundryUserWhereInput
    orderBy?: Enumerable<LaundryUserOrderByWithAggregationInput>
    by: LaundryUserScalarFieldEnum[]
    having?: LaundryUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LaundryUserCountAggregateInputType | true
    _avg?: LaundryUserAvgAggregateInputType
    _sum?: LaundryUserSumAggregateInputType
    _min?: LaundryUserMinAggregateInputType
    _max?: LaundryUserMaxAggregateInputType
  }


  export type LaundryUserGroupByOutputType = {
    id: number
    name: string
    tel: number
    balance: number
    createdAt: Date
    updatedAt: Date
    _count: LaundryUserCountAggregateOutputType | null
    _avg: LaundryUserAvgAggregateOutputType | null
    _sum: LaundryUserSumAggregateOutputType | null
    _min: LaundryUserMinAggregateOutputType | null
    _max: LaundryUserMaxAggregateOutputType | null
  }

  type GetLaundryUserGroupByPayload<T extends LaundryUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LaundryUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LaundryUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LaundryUserGroupByOutputType[P]>
            : GetScalarType<T[P], LaundryUserGroupByOutputType[P]>
        }
      >
    >


  export type LaundryUserSelect = {
    id?: boolean
    name?: boolean
    tel?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    laundryUserHistories?: boolean | LaundryUser$laundryUserHistoriesArgs
    laundryBalanceTopups?: boolean | LaundryUser$laundryBalanceTopupsArgs
    _count?: boolean | LaundryUserCountOutputTypeArgs
  }


  export type LaundryUserInclude = {
    laundryUserHistories?: boolean | LaundryUser$laundryUserHistoriesArgs
    laundryBalanceTopups?: boolean | LaundryUser$laundryBalanceTopupsArgs
    _count?: boolean | LaundryUserCountOutputTypeArgs
  }

  export type LaundryUserGetPayload<S extends boolean | null | undefined | LaundryUserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LaundryUser :
    S extends undefined ? never :
    S extends { include: any } & (LaundryUserArgs | LaundryUserFindManyArgs)
    ? LaundryUser  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'laundryUserHistories' ? Array < LaundryUserHistoryGetPayload<S['include'][P]>>  :
        P extends 'laundryBalanceTopups' ? Array < LaundryBalanceTopupGetPayload<S['include'][P]>>  :
        P extends '_count' ? LaundryUserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (LaundryUserArgs | LaundryUserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'laundryUserHistories' ? Array < LaundryUserHistoryGetPayload<S['select'][P]>>  :
        P extends 'laundryBalanceTopups' ? Array < LaundryBalanceTopupGetPayload<S['select'][P]>>  :
        P extends '_count' ? LaundryUserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof LaundryUser ? LaundryUser[P] : never
  } 
      : LaundryUser


  type LaundryUserCountArgs = 
    Omit<LaundryUserFindManyArgs, 'select' | 'include'> & {
      select?: LaundryUserCountAggregateInputType | true
    }

  export interface LaundryUserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one LaundryUser that matches the filter.
     * @param {LaundryUserFindUniqueArgs} args - Arguments to find a LaundryUser
     * @example
     * // Get one LaundryUser
     * const laundryUser = await prisma.laundryUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LaundryUserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LaundryUserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LaundryUser'> extends True ? Prisma__LaundryUserClient<LaundryUserGetPayload<T>> : Prisma__LaundryUserClient<LaundryUserGetPayload<T> | null, null>

    /**
     * Find one LaundryUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LaundryUserFindUniqueOrThrowArgs} args - Arguments to find a LaundryUser
     * @example
     * // Get one LaundryUser
     * const laundryUser = await prisma.laundryUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LaundryUserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LaundryUserFindUniqueOrThrowArgs>
    ): Prisma__LaundryUserClient<LaundryUserGetPayload<T>>

    /**
     * Find the first LaundryUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryUserFindFirstArgs} args - Arguments to find a LaundryUser
     * @example
     * // Get one LaundryUser
     * const laundryUser = await prisma.laundryUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LaundryUserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LaundryUserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LaundryUser'> extends True ? Prisma__LaundryUserClient<LaundryUserGetPayload<T>> : Prisma__LaundryUserClient<LaundryUserGetPayload<T> | null, null>

    /**
     * Find the first LaundryUser that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryUserFindFirstOrThrowArgs} args - Arguments to find a LaundryUser
     * @example
     * // Get one LaundryUser
     * const laundryUser = await prisma.laundryUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LaundryUserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LaundryUserFindFirstOrThrowArgs>
    ): Prisma__LaundryUserClient<LaundryUserGetPayload<T>>

    /**
     * Find zero or more LaundryUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LaundryUsers
     * const laundryUsers = await prisma.laundryUser.findMany()
     * 
     * // Get first 10 LaundryUsers
     * const laundryUsers = await prisma.laundryUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const laundryUserWithIdOnly = await prisma.laundryUser.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LaundryUserFindManyArgs>(
      args?: SelectSubset<T, LaundryUserFindManyArgs>
    ): Prisma.PrismaPromise<Array<LaundryUserGetPayload<T>>>

    /**
     * Create a LaundryUser.
     * @param {LaundryUserCreateArgs} args - Arguments to create a LaundryUser.
     * @example
     * // Create one LaundryUser
     * const LaundryUser = await prisma.laundryUser.create({
     *   data: {
     *     // ... data to create a LaundryUser
     *   }
     * })
     * 
    **/
    create<T extends LaundryUserCreateArgs>(
      args: SelectSubset<T, LaundryUserCreateArgs>
    ): Prisma__LaundryUserClient<LaundryUserGetPayload<T>>

    /**
     * Create many LaundryUsers.
     *     @param {LaundryUserCreateManyArgs} args - Arguments to create many LaundryUsers.
     *     @example
     *     // Create many LaundryUsers
     *     const laundryUser = await prisma.laundryUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LaundryUserCreateManyArgs>(
      args?: SelectSubset<T, LaundryUserCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LaundryUser.
     * @param {LaundryUserDeleteArgs} args - Arguments to delete one LaundryUser.
     * @example
     * // Delete one LaundryUser
     * const LaundryUser = await prisma.laundryUser.delete({
     *   where: {
     *     // ... filter to delete one LaundryUser
     *   }
     * })
     * 
    **/
    delete<T extends LaundryUserDeleteArgs>(
      args: SelectSubset<T, LaundryUserDeleteArgs>
    ): Prisma__LaundryUserClient<LaundryUserGetPayload<T>>

    /**
     * Update one LaundryUser.
     * @param {LaundryUserUpdateArgs} args - Arguments to update one LaundryUser.
     * @example
     * // Update one LaundryUser
     * const laundryUser = await prisma.laundryUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LaundryUserUpdateArgs>(
      args: SelectSubset<T, LaundryUserUpdateArgs>
    ): Prisma__LaundryUserClient<LaundryUserGetPayload<T>>

    /**
     * Delete zero or more LaundryUsers.
     * @param {LaundryUserDeleteManyArgs} args - Arguments to filter LaundryUsers to delete.
     * @example
     * // Delete a few LaundryUsers
     * const { count } = await prisma.laundryUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LaundryUserDeleteManyArgs>(
      args?: SelectSubset<T, LaundryUserDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LaundryUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LaundryUsers
     * const laundryUser = await prisma.laundryUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LaundryUserUpdateManyArgs>(
      args: SelectSubset<T, LaundryUserUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LaundryUser.
     * @param {LaundryUserUpsertArgs} args - Arguments to update or create a LaundryUser.
     * @example
     * // Update or create a LaundryUser
     * const laundryUser = await prisma.laundryUser.upsert({
     *   create: {
     *     // ... data to create a LaundryUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LaundryUser we want to update
     *   }
     * })
    **/
    upsert<T extends LaundryUserUpsertArgs>(
      args: SelectSubset<T, LaundryUserUpsertArgs>
    ): Prisma__LaundryUserClient<LaundryUserGetPayload<T>>

    /**
     * Count the number of LaundryUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryUserCountArgs} args - Arguments to filter LaundryUsers to count.
     * @example
     * // Count the number of LaundryUsers
     * const count = await prisma.laundryUser.count({
     *   where: {
     *     // ... the filter for the LaundryUsers we want to count
     *   }
     * })
    **/
    count<T extends LaundryUserCountArgs>(
      args?: Subset<T, LaundryUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LaundryUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LaundryUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LaundryUserAggregateArgs>(args: Subset<T, LaundryUserAggregateArgs>): Prisma.PrismaPromise<GetLaundryUserAggregateType<T>>

    /**
     * Group by LaundryUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LaundryUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LaundryUserGroupByArgs['orderBy'] }
        : { orderBy?: LaundryUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LaundryUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLaundryUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LaundryUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LaundryUserClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    laundryUserHistories<T extends LaundryUser$laundryUserHistoriesArgs= {}>(args?: Subset<T, LaundryUser$laundryUserHistoriesArgs>): Prisma.PrismaPromise<Array<LaundryUserHistoryGetPayload<T>>| Null>;

    laundryBalanceTopups<T extends LaundryUser$laundryBalanceTopupsArgs= {}>(args?: Subset<T, LaundryUser$laundryBalanceTopupsArgs>): Prisma.PrismaPromise<Array<LaundryBalanceTopupGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LaundryUser base type for findUnique actions
   */
  export type LaundryUserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the LaundryUser
     */
    select?: LaundryUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryUserInclude | null
    /**
     * Filter, which LaundryUser to fetch.
     */
    where: LaundryUserWhereUniqueInput
  }

  /**
   * LaundryUser findUnique
   */
  export interface LaundryUserFindUniqueArgs extends LaundryUserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LaundryUser findUniqueOrThrow
   */
  export type LaundryUserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LaundryUser
     */
    select?: LaundryUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryUserInclude | null
    /**
     * Filter, which LaundryUser to fetch.
     */
    where: LaundryUserWhereUniqueInput
  }


  /**
   * LaundryUser base type for findFirst actions
   */
  export type LaundryUserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the LaundryUser
     */
    select?: LaundryUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryUserInclude | null
    /**
     * Filter, which LaundryUser to fetch.
     */
    where?: LaundryUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryUsers to fetch.
     */
    orderBy?: Enumerable<LaundryUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaundryUsers.
     */
    cursor?: LaundryUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaundryUsers.
     */
    distinct?: Enumerable<LaundryUserScalarFieldEnum>
  }

  /**
   * LaundryUser findFirst
   */
  export interface LaundryUserFindFirstArgs extends LaundryUserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LaundryUser findFirstOrThrow
   */
  export type LaundryUserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LaundryUser
     */
    select?: LaundryUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryUserInclude | null
    /**
     * Filter, which LaundryUser to fetch.
     */
    where?: LaundryUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryUsers to fetch.
     */
    orderBy?: Enumerable<LaundryUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaundryUsers.
     */
    cursor?: LaundryUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaundryUsers.
     */
    distinct?: Enumerable<LaundryUserScalarFieldEnum>
  }


  /**
   * LaundryUser findMany
   */
  export type LaundryUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the LaundryUser
     */
    select?: LaundryUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryUserInclude | null
    /**
     * Filter, which LaundryUsers to fetch.
     */
    where?: LaundryUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryUsers to fetch.
     */
    orderBy?: Enumerable<LaundryUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LaundryUsers.
     */
    cursor?: LaundryUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryUsers.
     */
    skip?: number
    distinct?: Enumerable<LaundryUserScalarFieldEnum>
  }


  /**
   * LaundryUser create
   */
  export type LaundryUserCreateArgs = {
    /**
     * Select specific fields to fetch from the LaundryUser
     */
    select?: LaundryUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryUserInclude | null
    /**
     * The data needed to create a LaundryUser.
     */
    data: XOR<LaundryUserCreateInput, LaundryUserUncheckedCreateInput>
  }


  /**
   * LaundryUser createMany
   */
  export type LaundryUserCreateManyArgs = {
    /**
     * The data used to create many LaundryUsers.
     */
    data: Enumerable<LaundryUserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LaundryUser update
   */
  export type LaundryUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the LaundryUser
     */
    select?: LaundryUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryUserInclude | null
    /**
     * The data needed to update a LaundryUser.
     */
    data: XOR<LaundryUserUpdateInput, LaundryUserUncheckedUpdateInput>
    /**
     * Choose, which LaundryUser to update.
     */
    where: LaundryUserWhereUniqueInput
  }


  /**
   * LaundryUser updateMany
   */
  export type LaundryUserUpdateManyArgs = {
    /**
     * The data used to update LaundryUsers.
     */
    data: XOR<LaundryUserUpdateManyMutationInput, LaundryUserUncheckedUpdateManyInput>
    /**
     * Filter which LaundryUsers to update
     */
    where?: LaundryUserWhereInput
  }


  /**
   * LaundryUser upsert
   */
  export type LaundryUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the LaundryUser
     */
    select?: LaundryUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryUserInclude | null
    /**
     * The filter to search for the LaundryUser to update in case it exists.
     */
    where: LaundryUserWhereUniqueInput
    /**
     * In case the LaundryUser found by the `where` argument doesn't exist, create a new LaundryUser with this data.
     */
    create: XOR<LaundryUserCreateInput, LaundryUserUncheckedCreateInput>
    /**
     * In case the LaundryUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LaundryUserUpdateInput, LaundryUserUncheckedUpdateInput>
  }


  /**
   * LaundryUser delete
   */
  export type LaundryUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the LaundryUser
     */
    select?: LaundryUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryUserInclude | null
    /**
     * Filter which LaundryUser to delete.
     */
    where: LaundryUserWhereUniqueInput
  }


  /**
   * LaundryUser deleteMany
   */
  export type LaundryUserDeleteManyArgs = {
    /**
     * Filter which LaundryUsers to delete
     */
    where?: LaundryUserWhereInput
  }


  /**
   * LaundryUser.laundryUserHistories
   */
  export type LaundryUser$laundryUserHistoriesArgs = {
    /**
     * Select specific fields to fetch from the LaundryUserHistory
     */
    select?: LaundryUserHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryUserHistoryInclude | null
    where?: LaundryUserHistoryWhereInput
    orderBy?: Enumerable<LaundryUserHistoryOrderByWithRelationInput>
    cursor?: LaundryUserHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LaundryUserHistoryScalarFieldEnum>
  }


  /**
   * LaundryUser.laundryBalanceTopups
   */
  export type LaundryUser$laundryBalanceTopupsArgs = {
    /**
     * Select specific fields to fetch from the LaundryBalanceTopup
     */
    select?: LaundryBalanceTopupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryBalanceTopupInclude | null
    where?: LaundryBalanceTopupWhereInput
    orderBy?: Enumerable<LaundryBalanceTopupOrderByWithRelationInput>
    cursor?: LaundryBalanceTopupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LaundryBalanceTopupScalarFieldEnum>
  }


  /**
   * LaundryUser without action
   */
  export type LaundryUserArgs = {
    /**
     * Select specific fields to fetch from the LaundryUser
     */
    select?: LaundryUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryUserInclude | null
  }



  /**
   * Model LaundryUserHistory
   */


  export type AggregateLaundryUserHistory = {
    _count: LaundryUserHistoryCountAggregateOutputType | null
    _avg: LaundryUserHistoryAvgAggregateOutputType | null
    _sum: LaundryUserHistorySumAggregateOutputType | null
    _min: LaundryUserHistoryMinAggregateOutputType | null
    _max: LaundryUserHistoryMaxAggregateOutputType | null
  }

  export type LaundryUserHistoryAvgAggregateOutputType = {
    id: number | null
    washNumber: number | null
    date: number | null
    duration: number | null
    price: number | null
    laundryUserId: number | null
    laundryWashingMachineId: number | null
    laundryProgramId: number | null
  }

  export type LaundryUserHistorySumAggregateOutputType = {
    id: number | null
    washNumber: number | null
    date: number | null
    duration: number | null
    price: number | null
    laundryUserId: number | null
    laundryWashingMachineId: number | null
    laundryProgramId: number | null
  }

  export type LaundryUserHistoryMinAggregateOutputType = {
    id: number | null
    washNumber: number | null
    date: number | null
    duration: number | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
    laundryUserId: number | null
    laundryWashingMachineId: number | null
    laundryProgramId: number | null
  }

  export type LaundryUserHistoryMaxAggregateOutputType = {
    id: number | null
    washNumber: number | null
    date: number | null
    duration: number | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
    laundryUserId: number | null
    laundryWashingMachineId: number | null
    laundryProgramId: number | null
  }

  export type LaundryUserHistoryCountAggregateOutputType = {
    id: number
    washNumber: number
    date: number
    duration: number
    price: number
    createdAt: number
    updatedAt: number
    laundryUserId: number
    laundryWashingMachineId: number
    laundryProgramId: number
    _all: number
  }


  export type LaundryUserHistoryAvgAggregateInputType = {
    id?: true
    washNumber?: true
    date?: true
    duration?: true
    price?: true
    laundryUserId?: true
    laundryWashingMachineId?: true
    laundryProgramId?: true
  }

  export type LaundryUserHistorySumAggregateInputType = {
    id?: true
    washNumber?: true
    date?: true
    duration?: true
    price?: true
    laundryUserId?: true
    laundryWashingMachineId?: true
    laundryProgramId?: true
  }

  export type LaundryUserHistoryMinAggregateInputType = {
    id?: true
    washNumber?: true
    date?: true
    duration?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    laundryUserId?: true
    laundryWashingMachineId?: true
    laundryProgramId?: true
  }

  export type LaundryUserHistoryMaxAggregateInputType = {
    id?: true
    washNumber?: true
    date?: true
    duration?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    laundryUserId?: true
    laundryWashingMachineId?: true
    laundryProgramId?: true
  }

  export type LaundryUserHistoryCountAggregateInputType = {
    id?: true
    washNumber?: true
    date?: true
    duration?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    laundryUserId?: true
    laundryWashingMachineId?: true
    laundryProgramId?: true
    _all?: true
  }

  export type LaundryUserHistoryAggregateArgs = {
    /**
     * Filter which LaundryUserHistory to aggregate.
     */
    where?: LaundryUserHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryUserHistories to fetch.
     */
    orderBy?: Enumerable<LaundryUserHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LaundryUserHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryUserHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryUserHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LaundryUserHistories
    **/
    _count?: true | LaundryUserHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LaundryUserHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LaundryUserHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LaundryUserHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LaundryUserHistoryMaxAggregateInputType
  }

  export type GetLaundryUserHistoryAggregateType<T extends LaundryUserHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateLaundryUserHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLaundryUserHistory[P]>
      : GetScalarType<T[P], AggregateLaundryUserHistory[P]>
  }




  export type LaundryUserHistoryGroupByArgs = {
    where?: LaundryUserHistoryWhereInput
    orderBy?: Enumerable<LaundryUserHistoryOrderByWithAggregationInput>
    by: LaundryUserHistoryScalarFieldEnum[]
    having?: LaundryUserHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LaundryUserHistoryCountAggregateInputType | true
    _avg?: LaundryUserHistoryAvgAggregateInputType
    _sum?: LaundryUserHistorySumAggregateInputType
    _min?: LaundryUserHistoryMinAggregateInputType
    _max?: LaundryUserHistoryMaxAggregateInputType
  }


  export type LaundryUserHistoryGroupByOutputType = {
    id: number
    washNumber: number
    date: number
    duration: number
    price: number
    createdAt: Date
    updatedAt: Date
    laundryUserId: number
    laundryWashingMachineId: number
    laundryProgramId: number
    _count: LaundryUserHistoryCountAggregateOutputType | null
    _avg: LaundryUserHistoryAvgAggregateOutputType | null
    _sum: LaundryUserHistorySumAggregateOutputType | null
    _min: LaundryUserHistoryMinAggregateOutputType | null
    _max: LaundryUserHistoryMaxAggregateOutputType | null
  }

  type GetLaundryUserHistoryGroupByPayload<T extends LaundryUserHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LaundryUserHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LaundryUserHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LaundryUserHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], LaundryUserHistoryGroupByOutputType[P]>
        }
      >
    >


  export type LaundryUserHistorySelect = {
    id?: boolean
    user?: boolean | LaundryUserArgs
    washNumber?: boolean
    machine?: boolean | LaundryWashingMachineArgs
    program?: boolean | LaundryProgramArgs
    date?: boolean
    duration?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    laundryUserId?: boolean
    laundryWashingMachineId?: boolean
    laundryProgramId?: boolean
  }


  export type LaundryUserHistoryInclude = {
    user?: boolean | LaundryUserArgs
    machine?: boolean | LaundryWashingMachineArgs
    program?: boolean | LaundryProgramArgs
  }

  export type LaundryUserHistoryGetPayload<S extends boolean | null | undefined | LaundryUserHistoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LaundryUserHistory :
    S extends undefined ? never :
    S extends { include: any } & (LaundryUserHistoryArgs | LaundryUserHistoryFindManyArgs)
    ? LaundryUserHistory  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? LaundryUserGetPayload<S['include'][P]> :
        P extends 'machine' ? LaundryWashingMachineGetPayload<S['include'][P]> :
        P extends 'program' ? LaundryProgramGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (LaundryUserHistoryArgs | LaundryUserHistoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? LaundryUserGetPayload<S['select'][P]> :
        P extends 'machine' ? LaundryWashingMachineGetPayload<S['select'][P]> :
        P extends 'program' ? LaundryProgramGetPayload<S['select'][P]> :  P extends keyof LaundryUserHistory ? LaundryUserHistory[P] : never
  } 
      : LaundryUserHistory


  type LaundryUserHistoryCountArgs = 
    Omit<LaundryUserHistoryFindManyArgs, 'select' | 'include'> & {
      select?: LaundryUserHistoryCountAggregateInputType | true
    }

  export interface LaundryUserHistoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one LaundryUserHistory that matches the filter.
     * @param {LaundryUserHistoryFindUniqueArgs} args - Arguments to find a LaundryUserHistory
     * @example
     * // Get one LaundryUserHistory
     * const laundryUserHistory = await prisma.laundryUserHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LaundryUserHistoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LaundryUserHistoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LaundryUserHistory'> extends True ? Prisma__LaundryUserHistoryClient<LaundryUserHistoryGetPayload<T>> : Prisma__LaundryUserHistoryClient<LaundryUserHistoryGetPayload<T> | null, null>

    /**
     * Find one LaundryUserHistory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LaundryUserHistoryFindUniqueOrThrowArgs} args - Arguments to find a LaundryUserHistory
     * @example
     * // Get one LaundryUserHistory
     * const laundryUserHistory = await prisma.laundryUserHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LaundryUserHistoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LaundryUserHistoryFindUniqueOrThrowArgs>
    ): Prisma__LaundryUserHistoryClient<LaundryUserHistoryGetPayload<T>>

    /**
     * Find the first LaundryUserHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryUserHistoryFindFirstArgs} args - Arguments to find a LaundryUserHistory
     * @example
     * // Get one LaundryUserHistory
     * const laundryUserHistory = await prisma.laundryUserHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LaundryUserHistoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LaundryUserHistoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LaundryUserHistory'> extends True ? Prisma__LaundryUserHistoryClient<LaundryUserHistoryGetPayload<T>> : Prisma__LaundryUserHistoryClient<LaundryUserHistoryGetPayload<T> | null, null>

    /**
     * Find the first LaundryUserHistory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryUserHistoryFindFirstOrThrowArgs} args - Arguments to find a LaundryUserHistory
     * @example
     * // Get one LaundryUserHistory
     * const laundryUserHistory = await prisma.laundryUserHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LaundryUserHistoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LaundryUserHistoryFindFirstOrThrowArgs>
    ): Prisma__LaundryUserHistoryClient<LaundryUserHistoryGetPayload<T>>

    /**
     * Find zero or more LaundryUserHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryUserHistoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LaundryUserHistories
     * const laundryUserHistories = await prisma.laundryUserHistory.findMany()
     * 
     * // Get first 10 LaundryUserHistories
     * const laundryUserHistories = await prisma.laundryUserHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const laundryUserHistoryWithIdOnly = await prisma.laundryUserHistory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LaundryUserHistoryFindManyArgs>(
      args?: SelectSubset<T, LaundryUserHistoryFindManyArgs>
    ): Prisma.PrismaPromise<Array<LaundryUserHistoryGetPayload<T>>>

    /**
     * Create a LaundryUserHistory.
     * @param {LaundryUserHistoryCreateArgs} args - Arguments to create a LaundryUserHistory.
     * @example
     * // Create one LaundryUserHistory
     * const LaundryUserHistory = await prisma.laundryUserHistory.create({
     *   data: {
     *     // ... data to create a LaundryUserHistory
     *   }
     * })
     * 
    **/
    create<T extends LaundryUserHistoryCreateArgs>(
      args: SelectSubset<T, LaundryUserHistoryCreateArgs>
    ): Prisma__LaundryUserHistoryClient<LaundryUserHistoryGetPayload<T>>

    /**
     * Create many LaundryUserHistories.
     *     @param {LaundryUserHistoryCreateManyArgs} args - Arguments to create many LaundryUserHistories.
     *     @example
     *     // Create many LaundryUserHistories
     *     const laundryUserHistory = await prisma.laundryUserHistory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LaundryUserHistoryCreateManyArgs>(
      args?: SelectSubset<T, LaundryUserHistoryCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LaundryUserHistory.
     * @param {LaundryUserHistoryDeleteArgs} args - Arguments to delete one LaundryUserHistory.
     * @example
     * // Delete one LaundryUserHistory
     * const LaundryUserHistory = await prisma.laundryUserHistory.delete({
     *   where: {
     *     // ... filter to delete one LaundryUserHistory
     *   }
     * })
     * 
    **/
    delete<T extends LaundryUserHistoryDeleteArgs>(
      args: SelectSubset<T, LaundryUserHistoryDeleteArgs>
    ): Prisma__LaundryUserHistoryClient<LaundryUserHistoryGetPayload<T>>

    /**
     * Update one LaundryUserHistory.
     * @param {LaundryUserHistoryUpdateArgs} args - Arguments to update one LaundryUserHistory.
     * @example
     * // Update one LaundryUserHistory
     * const laundryUserHistory = await prisma.laundryUserHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LaundryUserHistoryUpdateArgs>(
      args: SelectSubset<T, LaundryUserHistoryUpdateArgs>
    ): Prisma__LaundryUserHistoryClient<LaundryUserHistoryGetPayload<T>>

    /**
     * Delete zero or more LaundryUserHistories.
     * @param {LaundryUserHistoryDeleteManyArgs} args - Arguments to filter LaundryUserHistories to delete.
     * @example
     * // Delete a few LaundryUserHistories
     * const { count } = await prisma.laundryUserHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LaundryUserHistoryDeleteManyArgs>(
      args?: SelectSubset<T, LaundryUserHistoryDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LaundryUserHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryUserHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LaundryUserHistories
     * const laundryUserHistory = await prisma.laundryUserHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LaundryUserHistoryUpdateManyArgs>(
      args: SelectSubset<T, LaundryUserHistoryUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LaundryUserHistory.
     * @param {LaundryUserHistoryUpsertArgs} args - Arguments to update or create a LaundryUserHistory.
     * @example
     * // Update or create a LaundryUserHistory
     * const laundryUserHistory = await prisma.laundryUserHistory.upsert({
     *   create: {
     *     // ... data to create a LaundryUserHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LaundryUserHistory we want to update
     *   }
     * })
    **/
    upsert<T extends LaundryUserHistoryUpsertArgs>(
      args: SelectSubset<T, LaundryUserHistoryUpsertArgs>
    ): Prisma__LaundryUserHistoryClient<LaundryUserHistoryGetPayload<T>>

    /**
     * Count the number of LaundryUserHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryUserHistoryCountArgs} args - Arguments to filter LaundryUserHistories to count.
     * @example
     * // Count the number of LaundryUserHistories
     * const count = await prisma.laundryUserHistory.count({
     *   where: {
     *     // ... the filter for the LaundryUserHistories we want to count
     *   }
     * })
    **/
    count<T extends LaundryUserHistoryCountArgs>(
      args?: Subset<T, LaundryUserHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LaundryUserHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LaundryUserHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryUserHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LaundryUserHistoryAggregateArgs>(args: Subset<T, LaundryUserHistoryAggregateArgs>): Prisma.PrismaPromise<GetLaundryUserHistoryAggregateType<T>>

    /**
     * Group by LaundryUserHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryUserHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LaundryUserHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LaundryUserHistoryGroupByArgs['orderBy'] }
        : { orderBy?: LaundryUserHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LaundryUserHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLaundryUserHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LaundryUserHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LaundryUserHistoryClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends LaundryUserArgs= {}>(args?: Subset<T, LaundryUserArgs>): Prisma__LaundryUserClient<LaundryUserGetPayload<T> | Null>;

    machine<T extends LaundryWashingMachineArgs= {}>(args?: Subset<T, LaundryWashingMachineArgs>): Prisma__LaundryWashingMachineClient<LaundryWashingMachineGetPayload<T> | Null>;

    program<T extends LaundryProgramArgs= {}>(args?: Subset<T, LaundryProgramArgs>): Prisma__LaundryProgramClient<LaundryProgramGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LaundryUserHistory base type for findUnique actions
   */
  export type LaundryUserHistoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the LaundryUserHistory
     */
    select?: LaundryUserHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryUserHistoryInclude | null
    /**
     * Filter, which LaundryUserHistory to fetch.
     */
    where: LaundryUserHistoryWhereUniqueInput
  }

  /**
   * LaundryUserHistory findUnique
   */
  export interface LaundryUserHistoryFindUniqueArgs extends LaundryUserHistoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LaundryUserHistory findUniqueOrThrow
   */
  export type LaundryUserHistoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LaundryUserHistory
     */
    select?: LaundryUserHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryUserHistoryInclude | null
    /**
     * Filter, which LaundryUserHistory to fetch.
     */
    where: LaundryUserHistoryWhereUniqueInput
  }


  /**
   * LaundryUserHistory base type for findFirst actions
   */
  export type LaundryUserHistoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the LaundryUserHistory
     */
    select?: LaundryUserHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryUserHistoryInclude | null
    /**
     * Filter, which LaundryUserHistory to fetch.
     */
    where?: LaundryUserHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryUserHistories to fetch.
     */
    orderBy?: Enumerable<LaundryUserHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaundryUserHistories.
     */
    cursor?: LaundryUserHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryUserHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryUserHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaundryUserHistories.
     */
    distinct?: Enumerable<LaundryUserHistoryScalarFieldEnum>
  }

  /**
   * LaundryUserHistory findFirst
   */
  export interface LaundryUserHistoryFindFirstArgs extends LaundryUserHistoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LaundryUserHistory findFirstOrThrow
   */
  export type LaundryUserHistoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LaundryUserHistory
     */
    select?: LaundryUserHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryUserHistoryInclude | null
    /**
     * Filter, which LaundryUserHistory to fetch.
     */
    where?: LaundryUserHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryUserHistories to fetch.
     */
    orderBy?: Enumerable<LaundryUserHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaundryUserHistories.
     */
    cursor?: LaundryUserHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryUserHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryUserHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaundryUserHistories.
     */
    distinct?: Enumerable<LaundryUserHistoryScalarFieldEnum>
  }


  /**
   * LaundryUserHistory findMany
   */
  export type LaundryUserHistoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the LaundryUserHistory
     */
    select?: LaundryUserHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryUserHistoryInclude | null
    /**
     * Filter, which LaundryUserHistories to fetch.
     */
    where?: LaundryUserHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryUserHistories to fetch.
     */
    orderBy?: Enumerable<LaundryUserHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LaundryUserHistories.
     */
    cursor?: LaundryUserHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryUserHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryUserHistories.
     */
    skip?: number
    distinct?: Enumerable<LaundryUserHistoryScalarFieldEnum>
  }


  /**
   * LaundryUserHistory create
   */
  export type LaundryUserHistoryCreateArgs = {
    /**
     * Select specific fields to fetch from the LaundryUserHistory
     */
    select?: LaundryUserHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryUserHistoryInclude | null
    /**
     * The data needed to create a LaundryUserHistory.
     */
    data: XOR<LaundryUserHistoryCreateInput, LaundryUserHistoryUncheckedCreateInput>
  }


  /**
   * LaundryUserHistory createMany
   */
  export type LaundryUserHistoryCreateManyArgs = {
    /**
     * The data used to create many LaundryUserHistories.
     */
    data: Enumerable<LaundryUserHistoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LaundryUserHistory update
   */
  export type LaundryUserHistoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the LaundryUserHistory
     */
    select?: LaundryUserHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryUserHistoryInclude | null
    /**
     * The data needed to update a LaundryUserHistory.
     */
    data: XOR<LaundryUserHistoryUpdateInput, LaundryUserHistoryUncheckedUpdateInput>
    /**
     * Choose, which LaundryUserHistory to update.
     */
    where: LaundryUserHistoryWhereUniqueInput
  }


  /**
   * LaundryUserHistory updateMany
   */
  export type LaundryUserHistoryUpdateManyArgs = {
    /**
     * The data used to update LaundryUserHistories.
     */
    data: XOR<LaundryUserHistoryUpdateManyMutationInput, LaundryUserHistoryUncheckedUpdateManyInput>
    /**
     * Filter which LaundryUserHistories to update
     */
    where?: LaundryUserHistoryWhereInput
  }


  /**
   * LaundryUserHistory upsert
   */
  export type LaundryUserHistoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the LaundryUserHistory
     */
    select?: LaundryUserHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryUserHistoryInclude | null
    /**
     * The filter to search for the LaundryUserHistory to update in case it exists.
     */
    where: LaundryUserHistoryWhereUniqueInput
    /**
     * In case the LaundryUserHistory found by the `where` argument doesn't exist, create a new LaundryUserHistory with this data.
     */
    create: XOR<LaundryUserHistoryCreateInput, LaundryUserHistoryUncheckedCreateInput>
    /**
     * In case the LaundryUserHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LaundryUserHistoryUpdateInput, LaundryUserHistoryUncheckedUpdateInput>
  }


  /**
   * LaundryUserHistory delete
   */
  export type LaundryUserHistoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the LaundryUserHistory
     */
    select?: LaundryUserHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryUserHistoryInclude | null
    /**
     * Filter which LaundryUserHistory to delete.
     */
    where: LaundryUserHistoryWhereUniqueInput
  }


  /**
   * LaundryUserHistory deleteMany
   */
  export type LaundryUserHistoryDeleteManyArgs = {
    /**
     * Filter which LaundryUserHistories to delete
     */
    where?: LaundryUserHistoryWhereInput
  }


  /**
   * LaundryUserHistory without action
   */
  export type LaundryUserHistoryArgs = {
    /**
     * Select specific fields to fetch from the LaundryUserHistory
     */
    select?: LaundryUserHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryUserHistoryInclude | null
  }



  /**
   * Model LaundryBalanceTopup
   */


  export type AggregateLaundryBalanceTopup = {
    _count: LaundryBalanceTopupCountAggregateOutputType | null
    _avg: LaundryBalanceTopupAvgAggregateOutputType | null
    _sum: LaundryBalanceTopupSumAggregateOutputType | null
    _min: LaundryBalanceTopupMinAggregateOutputType | null
    _max: LaundryBalanceTopupMaxAggregateOutputType | null
  }

  export type LaundryBalanceTopupAvgAggregateOutputType = {
    id: number | null
    topUpRound: number | null
    topUpAmount: number | null
    laundryUserId: number | null
  }

  export type LaundryBalanceTopupSumAggregateOutputType = {
    id: number | null
    topUpRound: number | null
    topUpAmount: number | null
    laundryUserId: number | null
  }

  export type LaundryBalanceTopupMinAggregateOutputType = {
    id: number | null
    topUpRound: number | null
    topUpAmount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    laundryUserId: number | null
  }

  export type LaundryBalanceTopupMaxAggregateOutputType = {
    id: number | null
    topUpRound: number | null
    topUpAmount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    laundryUserId: number | null
  }

  export type LaundryBalanceTopupCountAggregateOutputType = {
    id: number
    topUpRound: number
    topUpAmount: number
    createdAt: number
    updatedAt: number
    laundryUserId: number
    _all: number
  }


  export type LaundryBalanceTopupAvgAggregateInputType = {
    id?: true
    topUpRound?: true
    topUpAmount?: true
    laundryUserId?: true
  }

  export type LaundryBalanceTopupSumAggregateInputType = {
    id?: true
    topUpRound?: true
    topUpAmount?: true
    laundryUserId?: true
  }

  export type LaundryBalanceTopupMinAggregateInputType = {
    id?: true
    topUpRound?: true
    topUpAmount?: true
    createdAt?: true
    updatedAt?: true
    laundryUserId?: true
  }

  export type LaundryBalanceTopupMaxAggregateInputType = {
    id?: true
    topUpRound?: true
    topUpAmount?: true
    createdAt?: true
    updatedAt?: true
    laundryUserId?: true
  }

  export type LaundryBalanceTopupCountAggregateInputType = {
    id?: true
    topUpRound?: true
    topUpAmount?: true
    createdAt?: true
    updatedAt?: true
    laundryUserId?: true
    _all?: true
  }

  export type LaundryBalanceTopupAggregateArgs = {
    /**
     * Filter which LaundryBalanceTopup to aggregate.
     */
    where?: LaundryBalanceTopupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryBalanceTopups to fetch.
     */
    orderBy?: Enumerable<LaundryBalanceTopupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LaundryBalanceTopupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryBalanceTopups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryBalanceTopups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LaundryBalanceTopups
    **/
    _count?: true | LaundryBalanceTopupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LaundryBalanceTopupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LaundryBalanceTopupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LaundryBalanceTopupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LaundryBalanceTopupMaxAggregateInputType
  }

  export type GetLaundryBalanceTopupAggregateType<T extends LaundryBalanceTopupAggregateArgs> = {
        [P in keyof T & keyof AggregateLaundryBalanceTopup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLaundryBalanceTopup[P]>
      : GetScalarType<T[P], AggregateLaundryBalanceTopup[P]>
  }




  export type LaundryBalanceTopupGroupByArgs = {
    where?: LaundryBalanceTopupWhereInput
    orderBy?: Enumerable<LaundryBalanceTopupOrderByWithAggregationInput>
    by: LaundryBalanceTopupScalarFieldEnum[]
    having?: LaundryBalanceTopupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LaundryBalanceTopupCountAggregateInputType | true
    _avg?: LaundryBalanceTopupAvgAggregateInputType
    _sum?: LaundryBalanceTopupSumAggregateInputType
    _min?: LaundryBalanceTopupMinAggregateInputType
    _max?: LaundryBalanceTopupMaxAggregateInputType
  }


  export type LaundryBalanceTopupGroupByOutputType = {
    id: number
    topUpRound: number
    topUpAmount: number
    createdAt: Date
    updatedAt: Date
    laundryUserId: number
    _count: LaundryBalanceTopupCountAggregateOutputType | null
    _avg: LaundryBalanceTopupAvgAggregateOutputType | null
    _sum: LaundryBalanceTopupSumAggregateOutputType | null
    _min: LaundryBalanceTopupMinAggregateOutputType | null
    _max: LaundryBalanceTopupMaxAggregateOutputType | null
  }

  type GetLaundryBalanceTopupGroupByPayload<T extends LaundryBalanceTopupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LaundryBalanceTopupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LaundryBalanceTopupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LaundryBalanceTopupGroupByOutputType[P]>
            : GetScalarType<T[P], LaundryBalanceTopupGroupByOutputType[P]>
        }
      >
    >


  export type LaundryBalanceTopupSelect = {
    id?: boolean
    user?: boolean | LaundryUserArgs
    topUpRound?: boolean
    topUpAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    laundryUserId?: boolean
  }


  export type LaundryBalanceTopupInclude = {
    user?: boolean | LaundryUserArgs
  }

  export type LaundryBalanceTopupGetPayload<S extends boolean | null | undefined | LaundryBalanceTopupArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LaundryBalanceTopup :
    S extends undefined ? never :
    S extends { include: any } & (LaundryBalanceTopupArgs | LaundryBalanceTopupFindManyArgs)
    ? LaundryBalanceTopup  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? LaundryUserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (LaundryBalanceTopupArgs | LaundryBalanceTopupFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? LaundryUserGetPayload<S['select'][P]> :  P extends keyof LaundryBalanceTopup ? LaundryBalanceTopup[P] : never
  } 
      : LaundryBalanceTopup


  type LaundryBalanceTopupCountArgs = 
    Omit<LaundryBalanceTopupFindManyArgs, 'select' | 'include'> & {
      select?: LaundryBalanceTopupCountAggregateInputType | true
    }

  export interface LaundryBalanceTopupDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one LaundryBalanceTopup that matches the filter.
     * @param {LaundryBalanceTopupFindUniqueArgs} args - Arguments to find a LaundryBalanceTopup
     * @example
     * // Get one LaundryBalanceTopup
     * const laundryBalanceTopup = await prisma.laundryBalanceTopup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LaundryBalanceTopupFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LaundryBalanceTopupFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LaundryBalanceTopup'> extends True ? Prisma__LaundryBalanceTopupClient<LaundryBalanceTopupGetPayload<T>> : Prisma__LaundryBalanceTopupClient<LaundryBalanceTopupGetPayload<T> | null, null>

    /**
     * Find one LaundryBalanceTopup that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LaundryBalanceTopupFindUniqueOrThrowArgs} args - Arguments to find a LaundryBalanceTopup
     * @example
     * // Get one LaundryBalanceTopup
     * const laundryBalanceTopup = await prisma.laundryBalanceTopup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LaundryBalanceTopupFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LaundryBalanceTopupFindUniqueOrThrowArgs>
    ): Prisma__LaundryBalanceTopupClient<LaundryBalanceTopupGetPayload<T>>

    /**
     * Find the first LaundryBalanceTopup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryBalanceTopupFindFirstArgs} args - Arguments to find a LaundryBalanceTopup
     * @example
     * // Get one LaundryBalanceTopup
     * const laundryBalanceTopup = await prisma.laundryBalanceTopup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LaundryBalanceTopupFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LaundryBalanceTopupFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LaundryBalanceTopup'> extends True ? Prisma__LaundryBalanceTopupClient<LaundryBalanceTopupGetPayload<T>> : Prisma__LaundryBalanceTopupClient<LaundryBalanceTopupGetPayload<T> | null, null>

    /**
     * Find the first LaundryBalanceTopup that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryBalanceTopupFindFirstOrThrowArgs} args - Arguments to find a LaundryBalanceTopup
     * @example
     * // Get one LaundryBalanceTopup
     * const laundryBalanceTopup = await prisma.laundryBalanceTopup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LaundryBalanceTopupFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LaundryBalanceTopupFindFirstOrThrowArgs>
    ): Prisma__LaundryBalanceTopupClient<LaundryBalanceTopupGetPayload<T>>

    /**
     * Find zero or more LaundryBalanceTopups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryBalanceTopupFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LaundryBalanceTopups
     * const laundryBalanceTopups = await prisma.laundryBalanceTopup.findMany()
     * 
     * // Get first 10 LaundryBalanceTopups
     * const laundryBalanceTopups = await prisma.laundryBalanceTopup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const laundryBalanceTopupWithIdOnly = await prisma.laundryBalanceTopup.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LaundryBalanceTopupFindManyArgs>(
      args?: SelectSubset<T, LaundryBalanceTopupFindManyArgs>
    ): Prisma.PrismaPromise<Array<LaundryBalanceTopupGetPayload<T>>>

    /**
     * Create a LaundryBalanceTopup.
     * @param {LaundryBalanceTopupCreateArgs} args - Arguments to create a LaundryBalanceTopup.
     * @example
     * // Create one LaundryBalanceTopup
     * const LaundryBalanceTopup = await prisma.laundryBalanceTopup.create({
     *   data: {
     *     // ... data to create a LaundryBalanceTopup
     *   }
     * })
     * 
    **/
    create<T extends LaundryBalanceTopupCreateArgs>(
      args: SelectSubset<T, LaundryBalanceTopupCreateArgs>
    ): Prisma__LaundryBalanceTopupClient<LaundryBalanceTopupGetPayload<T>>

    /**
     * Create many LaundryBalanceTopups.
     *     @param {LaundryBalanceTopupCreateManyArgs} args - Arguments to create many LaundryBalanceTopups.
     *     @example
     *     // Create many LaundryBalanceTopups
     *     const laundryBalanceTopup = await prisma.laundryBalanceTopup.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LaundryBalanceTopupCreateManyArgs>(
      args?: SelectSubset<T, LaundryBalanceTopupCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LaundryBalanceTopup.
     * @param {LaundryBalanceTopupDeleteArgs} args - Arguments to delete one LaundryBalanceTopup.
     * @example
     * // Delete one LaundryBalanceTopup
     * const LaundryBalanceTopup = await prisma.laundryBalanceTopup.delete({
     *   where: {
     *     // ... filter to delete one LaundryBalanceTopup
     *   }
     * })
     * 
    **/
    delete<T extends LaundryBalanceTopupDeleteArgs>(
      args: SelectSubset<T, LaundryBalanceTopupDeleteArgs>
    ): Prisma__LaundryBalanceTopupClient<LaundryBalanceTopupGetPayload<T>>

    /**
     * Update one LaundryBalanceTopup.
     * @param {LaundryBalanceTopupUpdateArgs} args - Arguments to update one LaundryBalanceTopup.
     * @example
     * // Update one LaundryBalanceTopup
     * const laundryBalanceTopup = await prisma.laundryBalanceTopup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LaundryBalanceTopupUpdateArgs>(
      args: SelectSubset<T, LaundryBalanceTopupUpdateArgs>
    ): Prisma__LaundryBalanceTopupClient<LaundryBalanceTopupGetPayload<T>>

    /**
     * Delete zero or more LaundryBalanceTopups.
     * @param {LaundryBalanceTopupDeleteManyArgs} args - Arguments to filter LaundryBalanceTopups to delete.
     * @example
     * // Delete a few LaundryBalanceTopups
     * const { count } = await prisma.laundryBalanceTopup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LaundryBalanceTopupDeleteManyArgs>(
      args?: SelectSubset<T, LaundryBalanceTopupDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LaundryBalanceTopups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryBalanceTopupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LaundryBalanceTopups
     * const laundryBalanceTopup = await prisma.laundryBalanceTopup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LaundryBalanceTopupUpdateManyArgs>(
      args: SelectSubset<T, LaundryBalanceTopupUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LaundryBalanceTopup.
     * @param {LaundryBalanceTopupUpsertArgs} args - Arguments to update or create a LaundryBalanceTopup.
     * @example
     * // Update or create a LaundryBalanceTopup
     * const laundryBalanceTopup = await prisma.laundryBalanceTopup.upsert({
     *   create: {
     *     // ... data to create a LaundryBalanceTopup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LaundryBalanceTopup we want to update
     *   }
     * })
    **/
    upsert<T extends LaundryBalanceTopupUpsertArgs>(
      args: SelectSubset<T, LaundryBalanceTopupUpsertArgs>
    ): Prisma__LaundryBalanceTopupClient<LaundryBalanceTopupGetPayload<T>>

    /**
     * Count the number of LaundryBalanceTopups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryBalanceTopupCountArgs} args - Arguments to filter LaundryBalanceTopups to count.
     * @example
     * // Count the number of LaundryBalanceTopups
     * const count = await prisma.laundryBalanceTopup.count({
     *   where: {
     *     // ... the filter for the LaundryBalanceTopups we want to count
     *   }
     * })
    **/
    count<T extends LaundryBalanceTopupCountArgs>(
      args?: Subset<T, LaundryBalanceTopupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LaundryBalanceTopupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LaundryBalanceTopup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryBalanceTopupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LaundryBalanceTopupAggregateArgs>(args: Subset<T, LaundryBalanceTopupAggregateArgs>): Prisma.PrismaPromise<GetLaundryBalanceTopupAggregateType<T>>

    /**
     * Group by LaundryBalanceTopup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryBalanceTopupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LaundryBalanceTopupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LaundryBalanceTopupGroupByArgs['orderBy'] }
        : { orderBy?: LaundryBalanceTopupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LaundryBalanceTopupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLaundryBalanceTopupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LaundryBalanceTopup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LaundryBalanceTopupClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends LaundryUserArgs= {}>(args?: Subset<T, LaundryUserArgs>): Prisma__LaundryUserClient<LaundryUserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LaundryBalanceTopup base type for findUnique actions
   */
  export type LaundryBalanceTopupFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the LaundryBalanceTopup
     */
    select?: LaundryBalanceTopupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryBalanceTopupInclude | null
    /**
     * Filter, which LaundryBalanceTopup to fetch.
     */
    where: LaundryBalanceTopupWhereUniqueInput
  }

  /**
   * LaundryBalanceTopup findUnique
   */
  export interface LaundryBalanceTopupFindUniqueArgs extends LaundryBalanceTopupFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LaundryBalanceTopup findUniqueOrThrow
   */
  export type LaundryBalanceTopupFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LaundryBalanceTopup
     */
    select?: LaundryBalanceTopupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryBalanceTopupInclude | null
    /**
     * Filter, which LaundryBalanceTopup to fetch.
     */
    where: LaundryBalanceTopupWhereUniqueInput
  }


  /**
   * LaundryBalanceTopup base type for findFirst actions
   */
  export type LaundryBalanceTopupFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the LaundryBalanceTopup
     */
    select?: LaundryBalanceTopupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryBalanceTopupInclude | null
    /**
     * Filter, which LaundryBalanceTopup to fetch.
     */
    where?: LaundryBalanceTopupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryBalanceTopups to fetch.
     */
    orderBy?: Enumerable<LaundryBalanceTopupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaundryBalanceTopups.
     */
    cursor?: LaundryBalanceTopupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryBalanceTopups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryBalanceTopups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaundryBalanceTopups.
     */
    distinct?: Enumerable<LaundryBalanceTopupScalarFieldEnum>
  }

  /**
   * LaundryBalanceTopup findFirst
   */
  export interface LaundryBalanceTopupFindFirstArgs extends LaundryBalanceTopupFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LaundryBalanceTopup findFirstOrThrow
   */
  export type LaundryBalanceTopupFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LaundryBalanceTopup
     */
    select?: LaundryBalanceTopupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryBalanceTopupInclude | null
    /**
     * Filter, which LaundryBalanceTopup to fetch.
     */
    where?: LaundryBalanceTopupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryBalanceTopups to fetch.
     */
    orderBy?: Enumerable<LaundryBalanceTopupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaundryBalanceTopups.
     */
    cursor?: LaundryBalanceTopupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryBalanceTopups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryBalanceTopups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaundryBalanceTopups.
     */
    distinct?: Enumerable<LaundryBalanceTopupScalarFieldEnum>
  }


  /**
   * LaundryBalanceTopup findMany
   */
  export type LaundryBalanceTopupFindManyArgs = {
    /**
     * Select specific fields to fetch from the LaundryBalanceTopup
     */
    select?: LaundryBalanceTopupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryBalanceTopupInclude | null
    /**
     * Filter, which LaundryBalanceTopups to fetch.
     */
    where?: LaundryBalanceTopupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryBalanceTopups to fetch.
     */
    orderBy?: Enumerable<LaundryBalanceTopupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LaundryBalanceTopups.
     */
    cursor?: LaundryBalanceTopupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryBalanceTopups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryBalanceTopups.
     */
    skip?: number
    distinct?: Enumerable<LaundryBalanceTopupScalarFieldEnum>
  }


  /**
   * LaundryBalanceTopup create
   */
  export type LaundryBalanceTopupCreateArgs = {
    /**
     * Select specific fields to fetch from the LaundryBalanceTopup
     */
    select?: LaundryBalanceTopupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryBalanceTopupInclude | null
    /**
     * The data needed to create a LaundryBalanceTopup.
     */
    data: XOR<LaundryBalanceTopupCreateInput, LaundryBalanceTopupUncheckedCreateInput>
  }


  /**
   * LaundryBalanceTopup createMany
   */
  export type LaundryBalanceTopupCreateManyArgs = {
    /**
     * The data used to create many LaundryBalanceTopups.
     */
    data: Enumerable<LaundryBalanceTopupCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LaundryBalanceTopup update
   */
  export type LaundryBalanceTopupUpdateArgs = {
    /**
     * Select specific fields to fetch from the LaundryBalanceTopup
     */
    select?: LaundryBalanceTopupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryBalanceTopupInclude | null
    /**
     * The data needed to update a LaundryBalanceTopup.
     */
    data: XOR<LaundryBalanceTopupUpdateInput, LaundryBalanceTopupUncheckedUpdateInput>
    /**
     * Choose, which LaundryBalanceTopup to update.
     */
    where: LaundryBalanceTopupWhereUniqueInput
  }


  /**
   * LaundryBalanceTopup updateMany
   */
  export type LaundryBalanceTopupUpdateManyArgs = {
    /**
     * The data used to update LaundryBalanceTopups.
     */
    data: XOR<LaundryBalanceTopupUpdateManyMutationInput, LaundryBalanceTopupUncheckedUpdateManyInput>
    /**
     * Filter which LaundryBalanceTopups to update
     */
    where?: LaundryBalanceTopupWhereInput
  }


  /**
   * LaundryBalanceTopup upsert
   */
  export type LaundryBalanceTopupUpsertArgs = {
    /**
     * Select specific fields to fetch from the LaundryBalanceTopup
     */
    select?: LaundryBalanceTopupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryBalanceTopupInclude | null
    /**
     * The filter to search for the LaundryBalanceTopup to update in case it exists.
     */
    where: LaundryBalanceTopupWhereUniqueInput
    /**
     * In case the LaundryBalanceTopup found by the `where` argument doesn't exist, create a new LaundryBalanceTopup with this data.
     */
    create: XOR<LaundryBalanceTopupCreateInput, LaundryBalanceTopupUncheckedCreateInput>
    /**
     * In case the LaundryBalanceTopup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LaundryBalanceTopupUpdateInput, LaundryBalanceTopupUncheckedUpdateInput>
  }


  /**
   * LaundryBalanceTopup delete
   */
  export type LaundryBalanceTopupDeleteArgs = {
    /**
     * Select specific fields to fetch from the LaundryBalanceTopup
     */
    select?: LaundryBalanceTopupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryBalanceTopupInclude | null
    /**
     * Filter which LaundryBalanceTopup to delete.
     */
    where: LaundryBalanceTopupWhereUniqueInput
  }


  /**
   * LaundryBalanceTopup deleteMany
   */
  export type LaundryBalanceTopupDeleteManyArgs = {
    /**
     * Filter which LaundryBalanceTopups to delete
     */
    where?: LaundryBalanceTopupWhereInput
  }


  /**
   * LaundryBalanceTopup without action
   */
  export type LaundryBalanceTopupArgs = {
    /**
     * Select specific fields to fetch from the LaundryBalanceTopup
     */
    select?: LaundryBalanceTopupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryBalanceTopupInclude | null
  }



  /**
   * Model LibraryBookCategory
   */


  export type AggregateLibraryBookCategory = {
    _count: LibraryBookCategoryCountAggregateOutputType | null
    _avg: LibraryBookCategoryAvgAggregateOutputType | null
    _sum: LibraryBookCategorySumAggregateOutputType | null
    _min: LibraryBookCategoryMinAggregateOutputType | null
    _max: LibraryBookCategoryMaxAggregateOutputType | null
  }

  export type LibraryBookCategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type LibraryBookCategorySumAggregateOutputType = {
    id: number | null
  }

  export type LibraryBookCategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LibraryBookCategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LibraryBookCategoryCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LibraryBookCategoryAvgAggregateInputType = {
    id?: true
  }

  export type LibraryBookCategorySumAggregateInputType = {
    id?: true
  }

  export type LibraryBookCategoryMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LibraryBookCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LibraryBookCategoryCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LibraryBookCategoryAggregateArgs = {
    /**
     * Filter which LibraryBookCategory to aggregate.
     */
    where?: LibraryBookCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBookCategories to fetch.
     */
    orderBy?: Enumerable<LibraryBookCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LibraryBookCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBookCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBookCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LibraryBookCategories
    **/
    _count?: true | LibraryBookCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LibraryBookCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LibraryBookCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LibraryBookCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LibraryBookCategoryMaxAggregateInputType
  }

  export type GetLibraryBookCategoryAggregateType<T extends LibraryBookCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateLibraryBookCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLibraryBookCategory[P]>
      : GetScalarType<T[P], AggregateLibraryBookCategory[P]>
  }




  export type LibraryBookCategoryGroupByArgs = {
    where?: LibraryBookCategoryWhereInput
    orderBy?: Enumerable<LibraryBookCategoryOrderByWithAggregationInput>
    by: LibraryBookCategoryScalarFieldEnum[]
    having?: LibraryBookCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LibraryBookCategoryCountAggregateInputType | true
    _avg?: LibraryBookCategoryAvgAggregateInputType
    _sum?: LibraryBookCategorySumAggregateInputType
    _min?: LibraryBookCategoryMinAggregateInputType
    _max?: LibraryBookCategoryMaxAggregateInputType
  }


  export type LibraryBookCategoryGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: LibraryBookCategoryCountAggregateOutputType | null
    _avg: LibraryBookCategoryAvgAggregateOutputType | null
    _sum: LibraryBookCategorySumAggregateOutputType | null
    _min: LibraryBookCategoryMinAggregateOutputType | null
    _max: LibraryBookCategoryMaxAggregateOutputType | null
  }

  type GetLibraryBookCategoryGroupByPayload<T extends LibraryBookCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LibraryBookCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LibraryBookCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LibraryBookCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], LibraryBookCategoryGroupByOutputType[P]>
        }
      >
    >


  export type LibraryBookCategorySelect = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    libraryCategoriesToBooks?: boolean | LibraryBookCategory$libraryCategoriesToBooksArgs
    _count?: boolean | LibraryBookCategoryCountOutputTypeArgs
  }


  export type LibraryBookCategoryInclude = {
    libraryCategoriesToBooks?: boolean | LibraryBookCategory$libraryCategoriesToBooksArgs
    _count?: boolean | LibraryBookCategoryCountOutputTypeArgs
  }

  export type LibraryBookCategoryGetPayload<S extends boolean | null | undefined | LibraryBookCategoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LibraryBookCategory :
    S extends undefined ? never :
    S extends { include: any } & (LibraryBookCategoryArgs | LibraryBookCategoryFindManyArgs)
    ? LibraryBookCategory  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'libraryCategoriesToBooks' ? Array < LibraryCategoryToBookGetPayload<S['include'][P]>>  :
        P extends '_count' ? LibraryBookCategoryCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (LibraryBookCategoryArgs | LibraryBookCategoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'libraryCategoriesToBooks' ? Array < LibraryCategoryToBookGetPayload<S['select'][P]>>  :
        P extends '_count' ? LibraryBookCategoryCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof LibraryBookCategory ? LibraryBookCategory[P] : never
  } 
      : LibraryBookCategory


  type LibraryBookCategoryCountArgs = 
    Omit<LibraryBookCategoryFindManyArgs, 'select' | 'include'> & {
      select?: LibraryBookCategoryCountAggregateInputType | true
    }

  export interface LibraryBookCategoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one LibraryBookCategory that matches the filter.
     * @param {LibraryBookCategoryFindUniqueArgs} args - Arguments to find a LibraryBookCategory
     * @example
     * // Get one LibraryBookCategory
     * const libraryBookCategory = await prisma.libraryBookCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LibraryBookCategoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LibraryBookCategoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LibraryBookCategory'> extends True ? Prisma__LibraryBookCategoryClient<LibraryBookCategoryGetPayload<T>> : Prisma__LibraryBookCategoryClient<LibraryBookCategoryGetPayload<T> | null, null>

    /**
     * Find one LibraryBookCategory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LibraryBookCategoryFindUniqueOrThrowArgs} args - Arguments to find a LibraryBookCategory
     * @example
     * // Get one LibraryBookCategory
     * const libraryBookCategory = await prisma.libraryBookCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LibraryBookCategoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LibraryBookCategoryFindUniqueOrThrowArgs>
    ): Prisma__LibraryBookCategoryClient<LibraryBookCategoryGetPayload<T>>

    /**
     * Find the first LibraryBookCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookCategoryFindFirstArgs} args - Arguments to find a LibraryBookCategory
     * @example
     * // Get one LibraryBookCategory
     * const libraryBookCategory = await prisma.libraryBookCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LibraryBookCategoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LibraryBookCategoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LibraryBookCategory'> extends True ? Prisma__LibraryBookCategoryClient<LibraryBookCategoryGetPayload<T>> : Prisma__LibraryBookCategoryClient<LibraryBookCategoryGetPayload<T> | null, null>

    /**
     * Find the first LibraryBookCategory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookCategoryFindFirstOrThrowArgs} args - Arguments to find a LibraryBookCategory
     * @example
     * // Get one LibraryBookCategory
     * const libraryBookCategory = await prisma.libraryBookCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LibraryBookCategoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LibraryBookCategoryFindFirstOrThrowArgs>
    ): Prisma__LibraryBookCategoryClient<LibraryBookCategoryGetPayload<T>>

    /**
     * Find zero or more LibraryBookCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookCategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LibraryBookCategories
     * const libraryBookCategories = await prisma.libraryBookCategory.findMany()
     * 
     * // Get first 10 LibraryBookCategories
     * const libraryBookCategories = await prisma.libraryBookCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const libraryBookCategoryWithIdOnly = await prisma.libraryBookCategory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LibraryBookCategoryFindManyArgs>(
      args?: SelectSubset<T, LibraryBookCategoryFindManyArgs>
    ): Prisma.PrismaPromise<Array<LibraryBookCategoryGetPayload<T>>>

    /**
     * Create a LibraryBookCategory.
     * @param {LibraryBookCategoryCreateArgs} args - Arguments to create a LibraryBookCategory.
     * @example
     * // Create one LibraryBookCategory
     * const LibraryBookCategory = await prisma.libraryBookCategory.create({
     *   data: {
     *     // ... data to create a LibraryBookCategory
     *   }
     * })
     * 
    **/
    create<T extends LibraryBookCategoryCreateArgs>(
      args: SelectSubset<T, LibraryBookCategoryCreateArgs>
    ): Prisma__LibraryBookCategoryClient<LibraryBookCategoryGetPayload<T>>

    /**
     * Create many LibraryBookCategories.
     *     @param {LibraryBookCategoryCreateManyArgs} args - Arguments to create many LibraryBookCategories.
     *     @example
     *     // Create many LibraryBookCategories
     *     const libraryBookCategory = await prisma.libraryBookCategory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LibraryBookCategoryCreateManyArgs>(
      args?: SelectSubset<T, LibraryBookCategoryCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LibraryBookCategory.
     * @param {LibraryBookCategoryDeleteArgs} args - Arguments to delete one LibraryBookCategory.
     * @example
     * // Delete one LibraryBookCategory
     * const LibraryBookCategory = await prisma.libraryBookCategory.delete({
     *   where: {
     *     // ... filter to delete one LibraryBookCategory
     *   }
     * })
     * 
    **/
    delete<T extends LibraryBookCategoryDeleteArgs>(
      args: SelectSubset<T, LibraryBookCategoryDeleteArgs>
    ): Prisma__LibraryBookCategoryClient<LibraryBookCategoryGetPayload<T>>

    /**
     * Update one LibraryBookCategory.
     * @param {LibraryBookCategoryUpdateArgs} args - Arguments to update one LibraryBookCategory.
     * @example
     * // Update one LibraryBookCategory
     * const libraryBookCategory = await prisma.libraryBookCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LibraryBookCategoryUpdateArgs>(
      args: SelectSubset<T, LibraryBookCategoryUpdateArgs>
    ): Prisma__LibraryBookCategoryClient<LibraryBookCategoryGetPayload<T>>

    /**
     * Delete zero or more LibraryBookCategories.
     * @param {LibraryBookCategoryDeleteManyArgs} args - Arguments to filter LibraryBookCategories to delete.
     * @example
     * // Delete a few LibraryBookCategories
     * const { count } = await prisma.libraryBookCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LibraryBookCategoryDeleteManyArgs>(
      args?: SelectSubset<T, LibraryBookCategoryDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LibraryBookCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LibraryBookCategories
     * const libraryBookCategory = await prisma.libraryBookCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LibraryBookCategoryUpdateManyArgs>(
      args: SelectSubset<T, LibraryBookCategoryUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LibraryBookCategory.
     * @param {LibraryBookCategoryUpsertArgs} args - Arguments to update or create a LibraryBookCategory.
     * @example
     * // Update or create a LibraryBookCategory
     * const libraryBookCategory = await prisma.libraryBookCategory.upsert({
     *   create: {
     *     // ... data to create a LibraryBookCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LibraryBookCategory we want to update
     *   }
     * })
    **/
    upsert<T extends LibraryBookCategoryUpsertArgs>(
      args: SelectSubset<T, LibraryBookCategoryUpsertArgs>
    ): Prisma__LibraryBookCategoryClient<LibraryBookCategoryGetPayload<T>>

    /**
     * Count the number of LibraryBookCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookCategoryCountArgs} args - Arguments to filter LibraryBookCategories to count.
     * @example
     * // Count the number of LibraryBookCategories
     * const count = await prisma.libraryBookCategory.count({
     *   where: {
     *     // ... the filter for the LibraryBookCategories we want to count
     *   }
     * })
    **/
    count<T extends LibraryBookCategoryCountArgs>(
      args?: Subset<T, LibraryBookCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LibraryBookCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LibraryBookCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LibraryBookCategoryAggregateArgs>(args: Subset<T, LibraryBookCategoryAggregateArgs>): Prisma.PrismaPromise<GetLibraryBookCategoryAggregateType<T>>

    /**
     * Group by LibraryBookCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LibraryBookCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LibraryBookCategoryGroupByArgs['orderBy'] }
        : { orderBy?: LibraryBookCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LibraryBookCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLibraryBookCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LibraryBookCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LibraryBookCategoryClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    libraryCategoriesToBooks<T extends LibraryBookCategory$libraryCategoriesToBooksArgs= {}>(args?: Subset<T, LibraryBookCategory$libraryCategoriesToBooksArgs>): Prisma.PrismaPromise<Array<LibraryCategoryToBookGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LibraryBookCategory base type for findUnique actions
   */
  export type LibraryBookCategoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the LibraryBookCategory
     */
    select?: LibraryBookCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCategoryInclude | null
    /**
     * Filter, which LibraryBookCategory to fetch.
     */
    where: LibraryBookCategoryWhereUniqueInput
  }

  /**
   * LibraryBookCategory findUnique
   */
  export interface LibraryBookCategoryFindUniqueArgs extends LibraryBookCategoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LibraryBookCategory findUniqueOrThrow
   */
  export type LibraryBookCategoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookCategory
     */
    select?: LibraryBookCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCategoryInclude | null
    /**
     * Filter, which LibraryBookCategory to fetch.
     */
    where: LibraryBookCategoryWhereUniqueInput
  }


  /**
   * LibraryBookCategory base type for findFirst actions
   */
  export type LibraryBookCategoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the LibraryBookCategory
     */
    select?: LibraryBookCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCategoryInclude | null
    /**
     * Filter, which LibraryBookCategory to fetch.
     */
    where?: LibraryBookCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBookCategories to fetch.
     */
    orderBy?: Enumerable<LibraryBookCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryBookCategories.
     */
    cursor?: LibraryBookCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBookCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBookCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryBookCategories.
     */
    distinct?: Enumerable<LibraryBookCategoryScalarFieldEnum>
  }

  /**
   * LibraryBookCategory findFirst
   */
  export interface LibraryBookCategoryFindFirstArgs extends LibraryBookCategoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LibraryBookCategory findFirstOrThrow
   */
  export type LibraryBookCategoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookCategory
     */
    select?: LibraryBookCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCategoryInclude | null
    /**
     * Filter, which LibraryBookCategory to fetch.
     */
    where?: LibraryBookCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBookCategories to fetch.
     */
    orderBy?: Enumerable<LibraryBookCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryBookCategories.
     */
    cursor?: LibraryBookCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBookCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBookCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryBookCategories.
     */
    distinct?: Enumerable<LibraryBookCategoryScalarFieldEnum>
  }


  /**
   * LibraryBookCategory findMany
   */
  export type LibraryBookCategoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookCategory
     */
    select?: LibraryBookCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCategoryInclude | null
    /**
     * Filter, which LibraryBookCategories to fetch.
     */
    where?: LibraryBookCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBookCategories to fetch.
     */
    orderBy?: Enumerable<LibraryBookCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LibraryBookCategories.
     */
    cursor?: LibraryBookCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBookCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBookCategories.
     */
    skip?: number
    distinct?: Enumerable<LibraryBookCategoryScalarFieldEnum>
  }


  /**
   * LibraryBookCategory create
   */
  export type LibraryBookCategoryCreateArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookCategory
     */
    select?: LibraryBookCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCategoryInclude | null
    /**
     * The data needed to create a LibraryBookCategory.
     */
    data: XOR<LibraryBookCategoryCreateInput, LibraryBookCategoryUncheckedCreateInput>
  }


  /**
   * LibraryBookCategory createMany
   */
  export type LibraryBookCategoryCreateManyArgs = {
    /**
     * The data used to create many LibraryBookCategories.
     */
    data: Enumerable<LibraryBookCategoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LibraryBookCategory update
   */
  export type LibraryBookCategoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookCategory
     */
    select?: LibraryBookCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCategoryInclude | null
    /**
     * The data needed to update a LibraryBookCategory.
     */
    data: XOR<LibraryBookCategoryUpdateInput, LibraryBookCategoryUncheckedUpdateInput>
    /**
     * Choose, which LibraryBookCategory to update.
     */
    where: LibraryBookCategoryWhereUniqueInput
  }


  /**
   * LibraryBookCategory updateMany
   */
  export type LibraryBookCategoryUpdateManyArgs = {
    /**
     * The data used to update LibraryBookCategories.
     */
    data: XOR<LibraryBookCategoryUpdateManyMutationInput, LibraryBookCategoryUncheckedUpdateManyInput>
    /**
     * Filter which LibraryBookCategories to update
     */
    where?: LibraryBookCategoryWhereInput
  }


  /**
   * LibraryBookCategory upsert
   */
  export type LibraryBookCategoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookCategory
     */
    select?: LibraryBookCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCategoryInclude | null
    /**
     * The filter to search for the LibraryBookCategory to update in case it exists.
     */
    where: LibraryBookCategoryWhereUniqueInput
    /**
     * In case the LibraryBookCategory found by the `where` argument doesn't exist, create a new LibraryBookCategory with this data.
     */
    create: XOR<LibraryBookCategoryCreateInput, LibraryBookCategoryUncheckedCreateInput>
    /**
     * In case the LibraryBookCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LibraryBookCategoryUpdateInput, LibraryBookCategoryUncheckedUpdateInput>
  }


  /**
   * LibraryBookCategory delete
   */
  export type LibraryBookCategoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookCategory
     */
    select?: LibraryBookCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCategoryInclude | null
    /**
     * Filter which LibraryBookCategory to delete.
     */
    where: LibraryBookCategoryWhereUniqueInput
  }


  /**
   * LibraryBookCategory deleteMany
   */
  export type LibraryBookCategoryDeleteManyArgs = {
    /**
     * Filter which LibraryBookCategories to delete
     */
    where?: LibraryBookCategoryWhereInput
  }


  /**
   * LibraryBookCategory.libraryCategoriesToBooks
   */
  export type LibraryBookCategory$libraryCategoriesToBooksArgs = {
    /**
     * Select specific fields to fetch from the LibraryCategoryToBook
     */
    select?: LibraryCategoryToBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryCategoryToBookInclude | null
    where?: LibraryCategoryToBookWhereInput
    orderBy?: Enumerable<LibraryCategoryToBookOrderByWithRelationInput>
    cursor?: LibraryCategoryToBookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LibraryCategoryToBookScalarFieldEnum>
  }


  /**
   * LibraryBookCategory without action
   */
  export type LibraryBookCategoryArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookCategory
     */
    select?: LibraryBookCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCategoryInclude | null
  }



  /**
   * Model LibraryBook
   */


  export type AggregateLibraryBook = {
    _count: LibraryBookCountAggregateOutputType | null
    _avg: LibraryBookAvgAggregateOutputType | null
    _sum: LibraryBookSumAggregateOutputType | null
    _min: LibraryBookMinAggregateOutputType | null
    _max: LibraryBookMaxAggregateOutputType | null
  }

  export type LibraryBookAvgAggregateOutputType = {
    id: number | null
    ISBN: number | null
  }

  export type LibraryBookSumAggregateOutputType = {
    id: number | null
    ISBN: number | null
  }

  export type LibraryBookMinAggregateOutputType = {
    id: number | null
    name: string | null
    ISBN: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LibraryBookMaxAggregateOutputType = {
    id: number | null
    name: string | null
    ISBN: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LibraryBookCountAggregateOutputType = {
    id: number
    name: number
    ISBN: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LibraryBookAvgAggregateInputType = {
    id?: true
    ISBN?: true
  }

  export type LibraryBookSumAggregateInputType = {
    id?: true
    ISBN?: true
  }

  export type LibraryBookMinAggregateInputType = {
    id?: true
    name?: true
    ISBN?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LibraryBookMaxAggregateInputType = {
    id?: true
    name?: true
    ISBN?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LibraryBookCountAggregateInputType = {
    id?: true
    name?: true
    ISBN?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LibraryBookAggregateArgs = {
    /**
     * Filter which LibraryBook to aggregate.
     */
    where?: LibraryBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBooks to fetch.
     */
    orderBy?: Enumerable<LibraryBookOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LibraryBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LibraryBooks
    **/
    _count?: true | LibraryBookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LibraryBookAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LibraryBookSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LibraryBookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LibraryBookMaxAggregateInputType
  }

  export type GetLibraryBookAggregateType<T extends LibraryBookAggregateArgs> = {
        [P in keyof T & keyof AggregateLibraryBook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLibraryBook[P]>
      : GetScalarType<T[P], AggregateLibraryBook[P]>
  }




  export type LibraryBookGroupByArgs = {
    where?: LibraryBookWhereInput
    orderBy?: Enumerable<LibraryBookOrderByWithAggregationInput>
    by: LibraryBookScalarFieldEnum[]
    having?: LibraryBookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LibraryBookCountAggregateInputType | true
    _avg?: LibraryBookAvgAggregateInputType
    _sum?: LibraryBookSumAggregateInputType
    _min?: LibraryBookMinAggregateInputType
    _max?: LibraryBookMaxAggregateInputType
  }


  export type LibraryBookGroupByOutputType = {
    id: number
    name: string
    ISBN: number
    createdAt: Date
    updatedAt: Date
    _count: LibraryBookCountAggregateOutputType | null
    _avg: LibraryBookAvgAggregateOutputType | null
    _sum: LibraryBookSumAggregateOutputType | null
    _min: LibraryBookMinAggregateOutputType | null
    _max: LibraryBookMaxAggregateOutputType | null
  }

  type GetLibraryBookGroupByPayload<T extends LibraryBookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LibraryBookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LibraryBookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LibraryBookGroupByOutputType[P]>
            : GetScalarType<T[P], LibraryBookGroupByOutputType[P]>
        }
      >
    >


  export type LibraryBookSelect = {
    id?: boolean
    name?: boolean
    ISBN?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    libraryCategoriesToBooks?: boolean | LibraryBook$libraryCategoriesToBooksArgs
    libraryBooksToAuthors?: boolean | LibraryBook$libraryBooksToAuthorsArgs
    libraryBookCopies?: boolean | LibraryBook$libraryBookCopiesArgs
    _count?: boolean | LibraryBookCountOutputTypeArgs
  }


  export type LibraryBookInclude = {
    libraryCategoriesToBooks?: boolean | LibraryBook$libraryCategoriesToBooksArgs
    libraryBooksToAuthors?: boolean | LibraryBook$libraryBooksToAuthorsArgs
    libraryBookCopies?: boolean | LibraryBook$libraryBookCopiesArgs
    _count?: boolean | LibraryBookCountOutputTypeArgs
  }

  export type LibraryBookGetPayload<S extends boolean | null | undefined | LibraryBookArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LibraryBook :
    S extends undefined ? never :
    S extends { include: any } & (LibraryBookArgs | LibraryBookFindManyArgs)
    ? LibraryBook  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'libraryCategoriesToBooks' ? Array < LibraryCategoryToBookGetPayload<S['include'][P]>>  :
        P extends 'libraryBooksToAuthors' ? Array < LibraryBookToAuthorGetPayload<S['include'][P]>>  :
        P extends 'libraryBookCopies' ? Array < LibraryBookCopyGetPayload<S['include'][P]>>  :
        P extends '_count' ? LibraryBookCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (LibraryBookArgs | LibraryBookFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'libraryCategoriesToBooks' ? Array < LibraryCategoryToBookGetPayload<S['select'][P]>>  :
        P extends 'libraryBooksToAuthors' ? Array < LibraryBookToAuthorGetPayload<S['select'][P]>>  :
        P extends 'libraryBookCopies' ? Array < LibraryBookCopyGetPayload<S['select'][P]>>  :
        P extends '_count' ? LibraryBookCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof LibraryBook ? LibraryBook[P] : never
  } 
      : LibraryBook


  type LibraryBookCountArgs = 
    Omit<LibraryBookFindManyArgs, 'select' | 'include'> & {
      select?: LibraryBookCountAggregateInputType | true
    }

  export interface LibraryBookDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one LibraryBook that matches the filter.
     * @param {LibraryBookFindUniqueArgs} args - Arguments to find a LibraryBook
     * @example
     * // Get one LibraryBook
     * const libraryBook = await prisma.libraryBook.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LibraryBookFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LibraryBookFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LibraryBook'> extends True ? Prisma__LibraryBookClient<LibraryBookGetPayload<T>> : Prisma__LibraryBookClient<LibraryBookGetPayload<T> | null, null>

    /**
     * Find one LibraryBook that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LibraryBookFindUniqueOrThrowArgs} args - Arguments to find a LibraryBook
     * @example
     * // Get one LibraryBook
     * const libraryBook = await prisma.libraryBook.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LibraryBookFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LibraryBookFindUniqueOrThrowArgs>
    ): Prisma__LibraryBookClient<LibraryBookGetPayload<T>>

    /**
     * Find the first LibraryBook that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookFindFirstArgs} args - Arguments to find a LibraryBook
     * @example
     * // Get one LibraryBook
     * const libraryBook = await prisma.libraryBook.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LibraryBookFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LibraryBookFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LibraryBook'> extends True ? Prisma__LibraryBookClient<LibraryBookGetPayload<T>> : Prisma__LibraryBookClient<LibraryBookGetPayload<T> | null, null>

    /**
     * Find the first LibraryBook that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookFindFirstOrThrowArgs} args - Arguments to find a LibraryBook
     * @example
     * // Get one LibraryBook
     * const libraryBook = await prisma.libraryBook.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LibraryBookFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LibraryBookFindFirstOrThrowArgs>
    ): Prisma__LibraryBookClient<LibraryBookGetPayload<T>>

    /**
     * Find zero or more LibraryBooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LibraryBooks
     * const libraryBooks = await prisma.libraryBook.findMany()
     * 
     * // Get first 10 LibraryBooks
     * const libraryBooks = await prisma.libraryBook.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const libraryBookWithIdOnly = await prisma.libraryBook.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LibraryBookFindManyArgs>(
      args?: SelectSubset<T, LibraryBookFindManyArgs>
    ): Prisma.PrismaPromise<Array<LibraryBookGetPayload<T>>>

    /**
     * Create a LibraryBook.
     * @param {LibraryBookCreateArgs} args - Arguments to create a LibraryBook.
     * @example
     * // Create one LibraryBook
     * const LibraryBook = await prisma.libraryBook.create({
     *   data: {
     *     // ... data to create a LibraryBook
     *   }
     * })
     * 
    **/
    create<T extends LibraryBookCreateArgs>(
      args: SelectSubset<T, LibraryBookCreateArgs>
    ): Prisma__LibraryBookClient<LibraryBookGetPayload<T>>

    /**
     * Create many LibraryBooks.
     *     @param {LibraryBookCreateManyArgs} args - Arguments to create many LibraryBooks.
     *     @example
     *     // Create many LibraryBooks
     *     const libraryBook = await prisma.libraryBook.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LibraryBookCreateManyArgs>(
      args?: SelectSubset<T, LibraryBookCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LibraryBook.
     * @param {LibraryBookDeleteArgs} args - Arguments to delete one LibraryBook.
     * @example
     * // Delete one LibraryBook
     * const LibraryBook = await prisma.libraryBook.delete({
     *   where: {
     *     // ... filter to delete one LibraryBook
     *   }
     * })
     * 
    **/
    delete<T extends LibraryBookDeleteArgs>(
      args: SelectSubset<T, LibraryBookDeleteArgs>
    ): Prisma__LibraryBookClient<LibraryBookGetPayload<T>>

    /**
     * Update one LibraryBook.
     * @param {LibraryBookUpdateArgs} args - Arguments to update one LibraryBook.
     * @example
     * // Update one LibraryBook
     * const libraryBook = await prisma.libraryBook.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LibraryBookUpdateArgs>(
      args: SelectSubset<T, LibraryBookUpdateArgs>
    ): Prisma__LibraryBookClient<LibraryBookGetPayload<T>>

    /**
     * Delete zero or more LibraryBooks.
     * @param {LibraryBookDeleteManyArgs} args - Arguments to filter LibraryBooks to delete.
     * @example
     * // Delete a few LibraryBooks
     * const { count } = await prisma.libraryBook.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LibraryBookDeleteManyArgs>(
      args?: SelectSubset<T, LibraryBookDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LibraryBooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LibraryBooks
     * const libraryBook = await prisma.libraryBook.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LibraryBookUpdateManyArgs>(
      args: SelectSubset<T, LibraryBookUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LibraryBook.
     * @param {LibraryBookUpsertArgs} args - Arguments to update or create a LibraryBook.
     * @example
     * // Update or create a LibraryBook
     * const libraryBook = await prisma.libraryBook.upsert({
     *   create: {
     *     // ... data to create a LibraryBook
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LibraryBook we want to update
     *   }
     * })
    **/
    upsert<T extends LibraryBookUpsertArgs>(
      args: SelectSubset<T, LibraryBookUpsertArgs>
    ): Prisma__LibraryBookClient<LibraryBookGetPayload<T>>

    /**
     * Count the number of LibraryBooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookCountArgs} args - Arguments to filter LibraryBooks to count.
     * @example
     * // Count the number of LibraryBooks
     * const count = await prisma.libraryBook.count({
     *   where: {
     *     // ... the filter for the LibraryBooks we want to count
     *   }
     * })
    **/
    count<T extends LibraryBookCountArgs>(
      args?: Subset<T, LibraryBookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LibraryBookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LibraryBook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LibraryBookAggregateArgs>(args: Subset<T, LibraryBookAggregateArgs>): Prisma.PrismaPromise<GetLibraryBookAggregateType<T>>

    /**
     * Group by LibraryBook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LibraryBookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LibraryBookGroupByArgs['orderBy'] }
        : { orderBy?: LibraryBookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LibraryBookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLibraryBookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LibraryBook.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LibraryBookClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    libraryCategoriesToBooks<T extends LibraryBook$libraryCategoriesToBooksArgs= {}>(args?: Subset<T, LibraryBook$libraryCategoriesToBooksArgs>): Prisma.PrismaPromise<Array<LibraryCategoryToBookGetPayload<T>>| Null>;

    libraryBooksToAuthors<T extends LibraryBook$libraryBooksToAuthorsArgs= {}>(args?: Subset<T, LibraryBook$libraryBooksToAuthorsArgs>): Prisma.PrismaPromise<Array<LibraryBookToAuthorGetPayload<T>>| Null>;

    libraryBookCopies<T extends LibraryBook$libraryBookCopiesArgs= {}>(args?: Subset<T, LibraryBook$libraryBookCopiesArgs>): Prisma.PrismaPromise<Array<LibraryBookCopyGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LibraryBook base type for findUnique actions
   */
  export type LibraryBookFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookInclude | null
    /**
     * Filter, which LibraryBook to fetch.
     */
    where: LibraryBookWhereUniqueInput
  }

  /**
   * LibraryBook findUnique
   */
  export interface LibraryBookFindUniqueArgs extends LibraryBookFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LibraryBook findUniqueOrThrow
   */
  export type LibraryBookFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookInclude | null
    /**
     * Filter, which LibraryBook to fetch.
     */
    where: LibraryBookWhereUniqueInput
  }


  /**
   * LibraryBook base type for findFirst actions
   */
  export type LibraryBookFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookInclude | null
    /**
     * Filter, which LibraryBook to fetch.
     */
    where?: LibraryBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBooks to fetch.
     */
    orderBy?: Enumerable<LibraryBookOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryBooks.
     */
    cursor?: LibraryBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryBooks.
     */
    distinct?: Enumerable<LibraryBookScalarFieldEnum>
  }

  /**
   * LibraryBook findFirst
   */
  export interface LibraryBookFindFirstArgs extends LibraryBookFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LibraryBook findFirstOrThrow
   */
  export type LibraryBookFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookInclude | null
    /**
     * Filter, which LibraryBook to fetch.
     */
    where?: LibraryBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBooks to fetch.
     */
    orderBy?: Enumerable<LibraryBookOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryBooks.
     */
    cursor?: LibraryBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryBooks.
     */
    distinct?: Enumerable<LibraryBookScalarFieldEnum>
  }


  /**
   * LibraryBook findMany
   */
  export type LibraryBookFindManyArgs = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookInclude | null
    /**
     * Filter, which LibraryBooks to fetch.
     */
    where?: LibraryBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBooks to fetch.
     */
    orderBy?: Enumerable<LibraryBookOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LibraryBooks.
     */
    cursor?: LibraryBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBooks.
     */
    skip?: number
    distinct?: Enumerable<LibraryBookScalarFieldEnum>
  }


  /**
   * LibraryBook create
   */
  export type LibraryBookCreateArgs = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookInclude | null
    /**
     * The data needed to create a LibraryBook.
     */
    data: XOR<LibraryBookCreateInput, LibraryBookUncheckedCreateInput>
  }


  /**
   * LibraryBook createMany
   */
  export type LibraryBookCreateManyArgs = {
    /**
     * The data used to create many LibraryBooks.
     */
    data: Enumerable<LibraryBookCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LibraryBook update
   */
  export type LibraryBookUpdateArgs = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookInclude | null
    /**
     * The data needed to update a LibraryBook.
     */
    data: XOR<LibraryBookUpdateInput, LibraryBookUncheckedUpdateInput>
    /**
     * Choose, which LibraryBook to update.
     */
    where: LibraryBookWhereUniqueInput
  }


  /**
   * LibraryBook updateMany
   */
  export type LibraryBookUpdateManyArgs = {
    /**
     * The data used to update LibraryBooks.
     */
    data: XOR<LibraryBookUpdateManyMutationInput, LibraryBookUncheckedUpdateManyInput>
    /**
     * Filter which LibraryBooks to update
     */
    where?: LibraryBookWhereInput
  }


  /**
   * LibraryBook upsert
   */
  export type LibraryBookUpsertArgs = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookInclude | null
    /**
     * The filter to search for the LibraryBook to update in case it exists.
     */
    where: LibraryBookWhereUniqueInput
    /**
     * In case the LibraryBook found by the `where` argument doesn't exist, create a new LibraryBook with this data.
     */
    create: XOR<LibraryBookCreateInput, LibraryBookUncheckedCreateInput>
    /**
     * In case the LibraryBook was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LibraryBookUpdateInput, LibraryBookUncheckedUpdateInput>
  }


  /**
   * LibraryBook delete
   */
  export type LibraryBookDeleteArgs = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookInclude | null
    /**
     * Filter which LibraryBook to delete.
     */
    where: LibraryBookWhereUniqueInput
  }


  /**
   * LibraryBook deleteMany
   */
  export type LibraryBookDeleteManyArgs = {
    /**
     * Filter which LibraryBooks to delete
     */
    where?: LibraryBookWhereInput
  }


  /**
   * LibraryBook.libraryCategoriesToBooks
   */
  export type LibraryBook$libraryCategoriesToBooksArgs = {
    /**
     * Select specific fields to fetch from the LibraryCategoryToBook
     */
    select?: LibraryCategoryToBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryCategoryToBookInclude | null
    where?: LibraryCategoryToBookWhereInput
    orderBy?: Enumerable<LibraryCategoryToBookOrderByWithRelationInput>
    cursor?: LibraryCategoryToBookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LibraryCategoryToBookScalarFieldEnum>
  }


  /**
   * LibraryBook.libraryBooksToAuthors
   */
  export type LibraryBook$libraryBooksToAuthorsArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookToAuthor
     */
    select?: LibraryBookToAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookToAuthorInclude | null
    where?: LibraryBookToAuthorWhereInput
    orderBy?: Enumerable<LibraryBookToAuthorOrderByWithRelationInput>
    cursor?: LibraryBookToAuthorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LibraryBookToAuthorScalarFieldEnum>
  }


  /**
   * LibraryBook.libraryBookCopies
   */
  export type LibraryBook$libraryBookCopiesArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookCopy
     */
    select?: LibraryBookCopySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCopyInclude | null
    where?: LibraryBookCopyWhereInput
    orderBy?: Enumerable<LibraryBookCopyOrderByWithRelationInput>
    cursor?: LibraryBookCopyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LibraryBookCopyScalarFieldEnum>
  }


  /**
   * LibraryBook without action
   */
  export type LibraryBookArgs = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookInclude | null
  }



  /**
   * Model LibraryCategoryToBook
   */


  export type AggregateLibraryCategoryToBook = {
    _count: LibraryCategoryToBookCountAggregateOutputType | null
    _avg: LibraryCategoryToBookAvgAggregateOutputType | null
    _sum: LibraryCategoryToBookSumAggregateOutputType | null
    _min: LibraryCategoryToBookMinAggregateOutputType | null
    _max: LibraryCategoryToBookMaxAggregateOutputType | null
  }

  export type LibraryCategoryToBookAvgAggregateOutputType = {
    id: number | null
    libraryBookCategoryId: number | null
    libraryBookId: number | null
  }

  export type LibraryCategoryToBookSumAggregateOutputType = {
    id: number | null
    libraryBookCategoryId: number | null
    libraryBookId: number | null
  }

  export type LibraryCategoryToBookMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    libraryBookCategoryId: number | null
    libraryBookId: number | null
  }

  export type LibraryCategoryToBookMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    libraryBookCategoryId: number | null
    libraryBookId: number | null
  }

  export type LibraryCategoryToBookCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    libraryBookCategoryId: number
    libraryBookId: number
    _all: number
  }


  export type LibraryCategoryToBookAvgAggregateInputType = {
    id?: true
    libraryBookCategoryId?: true
    libraryBookId?: true
  }

  export type LibraryCategoryToBookSumAggregateInputType = {
    id?: true
    libraryBookCategoryId?: true
    libraryBookId?: true
  }

  export type LibraryCategoryToBookMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    libraryBookCategoryId?: true
    libraryBookId?: true
  }

  export type LibraryCategoryToBookMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    libraryBookCategoryId?: true
    libraryBookId?: true
  }

  export type LibraryCategoryToBookCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    libraryBookCategoryId?: true
    libraryBookId?: true
    _all?: true
  }

  export type LibraryCategoryToBookAggregateArgs = {
    /**
     * Filter which LibraryCategoryToBook to aggregate.
     */
    where?: LibraryCategoryToBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryCategoryToBooks to fetch.
     */
    orderBy?: Enumerable<LibraryCategoryToBookOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LibraryCategoryToBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryCategoryToBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryCategoryToBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LibraryCategoryToBooks
    **/
    _count?: true | LibraryCategoryToBookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LibraryCategoryToBookAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LibraryCategoryToBookSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LibraryCategoryToBookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LibraryCategoryToBookMaxAggregateInputType
  }

  export type GetLibraryCategoryToBookAggregateType<T extends LibraryCategoryToBookAggregateArgs> = {
        [P in keyof T & keyof AggregateLibraryCategoryToBook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLibraryCategoryToBook[P]>
      : GetScalarType<T[P], AggregateLibraryCategoryToBook[P]>
  }




  export type LibraryCategoryToBookGroupByArgs = {
    where?: LibraryCategoryToBookWhereInput
    orderBy?: Enumerable<LibraryCategoryToBookOrderByWithAggregationInput>
    by: LibraryCategoryToBookScalarFieldEnum[]
    having?: LibraryCategoryToBookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LibraryCategoryToBookCountAggregateInputType | true
    _avg?: LibraryCategoryToBookAvgAggregateInputType
    _sum?: LibraryCategoryToBookSumAggregateInputType
    _min?: LibraryCategoryToBookMinAggregateInputType
    _max?: LibraryCategoryToBookMaxAggregateInputType
  }


  export type LibraryCategoryToBookGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    libraryBookCategoryId: number
    libraryBookId: number
    _count: LibraryCategoryToBookCountAggregateOutputType | null
    _avg: LibraryCategoryToBookAvgAggregateOutputType | null
    _sum: LibraryCategoryToBookSumAggregateOutputType | null
    _min: LibraryCategoryToBookMinAggregateOutputType | null
    _max: LibraryCategoryToBookMaxAggregateOutputType | null
  }

  type GetLibraryCategoryToBookGroupByPayload<T extends LibraryCategoryToBookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LibraryCategoryToBookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LibraryCategoryToBookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LibraryCategoryToBookGroupByOutputType[P]>
            : GetScalarType<T[P], LibraryCategoryToBookGroupByOutputType[P]>
        }
      >
    >


  export type LibraryCategoryToBookSelect = {
    id?: boolean
    category?: boolean | LibraryBookCategoryArgs
    book?: boolean | LibraryBookArgs
    createdAt?: boolean
    updatedAt?: boolean
    libraryBookCategoryId?: boolean
    libraryBookId?: boolean
  }


  export type LibraryCategoryToBookInclude = {
    category?: boolean | LibraryBookCategoryArgs
    book?: boolean | LibraryBookArgs
  }

  export type LibraryCategoryToBookGetPayload<S extends boolean | null | undefined | LibraryCategoryToBookArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LibraryCategoryToBook :
    S extends undefined ? never :
    S extends { include: any } & (LibraryCategoryToBookArgs | LibraryCategoryToBookFindManyArgs)
    ? LibraryCategoryToBook  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'category' ? LibraryBookCategoryGetPayload<S['include'][P]> :
        P extends 'book' ? LibraryBookGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (LibraryCategoryToBookArgs | LibraryCategoryToBookFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'category' ? LibraryBookCategoryGetPayload<S['select'][P]> :
        P extends 'book' ? LibraryBookGetPayload<S['select'][P]> :  P extends keyof LibraryCategoryToBook ? LibraryCategoryToBook[P] : never
  } 
      : LibraryCategoryToBook


  type LibraryCategoryToBookCountArgs = 
    Omit<LibraryCategoryToBookFindManyArgs, 'select' | 'include'> & {
      select?: LibraryCategoryToBookCountAggregateInputType | true
    }

  export interface LibraryCategoryToBookDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one LibraryCategoryToBook that matches the filter.
     * @param {LibraryCategoryToBookFindUniqueArgs} args - Arguments to find a LibraryCategoryToBook
     * @example
     * // Get one LibraryCategoryToBook
     * const libraryCategoryToBook = await prisma.libraryCategoryToBook.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LibraryCategoryToBookFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LibraryCategoryToBookFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LibraryCategoryToBook'> extends True ? Prisma__LibraryCategoryToBookClient<LibraryCategoryToBookGetPayload<T>> : Prisma__LibraryCategoryToBookClient<LibraryCategoryToBookGetPayload<T> | null, null>

    /**
     * Find one LibraryCategoryToBook that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LibraryCategoryToBookFindUniqueOrThrowArgs} args - Arguments to find a LibraryCategoryToBook
     * @example
     * // Get one LibraryCategoryToBook
     * const libraryCategoryToBook = await prisma.libraryCategoryToBook.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LibraryCategoryToBookFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LibraryCategoryToBookFindUniqueOrThrowArgs>
    ): Prisma__LibraryCategoryToBookClient<LibraryCategoryToBookGetPayload<T>>

    /**
     * Find the first LibraryCategoryToBook that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryCategoryToBookFindFirstArgs} args - Arguments to find a LibraryCategoryToBook
     * @example
     * // Get one LibraryCategoryToBook
     * const libraryCategoryToBook = await prisma.libraryCategoryToBook.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LibraryCategoryToBookFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LibraryCategoryToBookFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LibraryCategoryToBook'> extends True ? Prisma__LibraryCategoryToBookClient<LibraryCategoryToBookGetPayload<T>> : Prisma__LibraryCategoryToBookClient<LibraryCategoryToBookGetPayload<T> | null, null>

    /**
     * Find the first LibraryCategoryToBook that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryCategoryToBookFindFirstOrThrowArgs} args - Arguments to find a LibraryCategoryToBook
     * @example
     * // Get one LibraryCategoryToBook
     * const libraryCategoryToBook = await prisma.libraryCategoryToBook.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LibraryCategoryToBookFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LibraryCategoryToBookFindFirstOrThrowArgs>
    ): Prisma__LibraryCategoryToBookClient<LibraryCategoryToBookGetPayload<T>>

    /**
     * Find zero or more LibraryCategoryToBooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryCategoryToBookFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LibraryCategoryToBooks
     * const libraryCategoryToBooks = await prisma.libraryCategoryToBook.findMany()
     * 
     * // Get first 10 LibraryCategoryToBooks
     * const libraryCategoryToBooks = await prisma.libraryCategoryToBook.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const libraryCategoryToBookWithIdOnly = await prisma.libraryCategoryToBook.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LibraryCategoryToBookFindManyArgs>(
      args?: SelectSubset<T, LibraryCategoryToBookFindManyArgs>
    ): Prisma.PrismaPromise<Array<LibraryCategoryToBookGetPayload<T>>>

    /**
     * Create a LibraryCategoryToBook.
     * @param {LibraryCategoryToBookCreateArgs} args - Arguments to create a LibraryCategoryToBook.
     * @example
     * // Create one LibraryCategoryToBook
     * const LibraryCategoryToBook = await prisma.libraryCategoryToBook.create({
     *   data: {
     *     // ... data to create a LibraryCategoryToBook
     *   }
     * })
     * 
    **/
    create<T extends LibraryCategoryToBookCreateArgs>(
      args: SelectSubset<T, LibraryCategoryToBookCreateArgs>
    ): Prisma__LibraryCategoryToBookClient<LibraryCategoryToBookGetPayload<T>>

    /**
     * Create many LibraryCategoryToBooks.
     *     @param {LibraryCategoryToBookCreateManyArgs} args - Arguments to create many LibraryCategoryToBooks.
     *     @example
     *     // Create many LibraryCategoryToBooks
     *     const libraryCategoryToBook = await prisma.libraryCategoryToBook.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LibraryCategoryToBookCreateManyArgs>(
      args?: SelectSubset<T, LibraryCategoryToBookCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LibraryCategoryToBook.
     * @param {LibraryCategoryToBookDeleteArgs} args - Arguments to delete one LibraryCategoryToBook.
     * @example
     * // Delete one LibraryCategoryToBook
     * const LibraryCategoryToBook = await prisma.libraryCategoryToBook.delete({
     *   where: {
     *     // ... filter to delete one LibraryCategoryToBook
     *   }
     * })
     * 
    **/
    delete<T extends LibraryCategoryToBookDeleteArgs>(
      args: SelectSubset<T, LibraryCategoryToBookDeleteArgs>
    ): Prisma__LibraryCategoryToBookClient<LibraryCategoryToBookGetPayload<T>>

    /**
     * Update one LibraryCategoryToBook.
     * @param {LibraryCategoryToBookUpdateArgs} args - Arguments to update one LibraryCategoryToBook.
     * @example
     * // Update one LibraryCategoryToBook
     * const libraryCategoryToBook = await prisma.libraryCategoryToBook.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LibraryCategoryToBookUpdateArgs>(
      args: SelectSubset<T, LibraryCategoryToBookUpdateArgs>
    ): Prisma__LibraryCategoryToBookClient<LibraryCategoryToBookGetPayload<T>>

    /**
     * Delete zero or more LibraryCategoryToBooks.
     * @param {LibraryCategoryToBookDeleteManyArgs} args - Arguments to filter LibraryCategoryToBooks to delete.
     * @example
     * // Delete a few LibraryCategoryToBooks
     * const { count } = await prisma.libraryCategoryToBook.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LibraryCategoryToBookDeleteManyArgs>(
      args?: SelectSubset<T, LibraryCategoryToBookDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LibraryCategoryToBooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryCategoryToBookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LibraryCategoryToBooks
     * const libraryCategoryToBook = await prisma.libraryCategoryToBook.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LibraryCategoryToBookUpdateManyArgs>(
      args: SelectSubset<T, LibraryCategoryToBookUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LibraryCategoryToBook.
     * @param {LibraryCategoryToBookUpsertArgs} args - Arguments to update or create a LibraryCategoryToBook.
     * @example
     * // Update or create a LibraryCategoryToBook
     * const libraryCategoryToBook = await prisma.libraryCategoryToBook.upsert({
     *   create: {
     *     // ... data to create a LibraryCategoryToBook
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LibraryCategoryToBook we want to update
     *   }
     * })
    **/
    upsert<T extends LibraryCategoryToBookUpsertArgs>(
      args: SelectSubset<T, LibraryCategoryToBookUpsertArgs>
    ): Prisma__LibraryCategoryToBookClient<LibraryCategoryToBookGetPayload<T>>

    /**
     * Count the number of LibraryCategoryToBooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryCategoryToBookCountArgs} args - Arguments to filter LibraryCategoryToBooks to count.
     * @example
     * // Count the number of LibraryCategoryToBooks
     * const count = await prisma.libraryCategoryToBook.count({
     *   where: {
     *     // ... the filter for the LibraryCategoryToBooks we want to count
     *   }
     * })
    **/
    count<T extends LibraryCategoryToBookCountArgs>(
      args?: Subset<T, LibraryCategoryToBookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LibraryCategoryToBookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LibraryCategoryToBook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryCategoryToBookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LibraryCategoryToBookAggregateArgs>(args: Subset<T, LibraryCategoryToBookAggregateArgs>): Prisma.PrismaPromise<GetLibraryCategoryToBookAggregateType<T>>

    /**
     * Group by LibraryCategoryToBook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryCategoryToBookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LibraryCategoryToBookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LibraryCategoryToBookGroupByArgs['orderBy'] }
        : { orderBy?: LibraryCategoryToBookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LibraryCategoryToBookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLibraryCategoryToBookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LibraryCategoryToBook.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LibraryCategoryToBookClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    category<T extends LibraryBookCategoryArgs= {}>(args?: Subset<T, LibraryBookCategoryArgs>): Prisma__LibraryBookCategoryClient<LibraryBookCategoryGetPayload<T> | Null>;

    book<T extends LibraryBookArgs= {}>(args?: Subset<T, LibraryBookArgs>): Prisma__LibraryBookClient<LibraryBookGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LibraryCategoryToBook base type for findUnique actions
   */
  export type LibraryCategoryToBookFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the LibraryCategoryToBook
     */
    select?: LibraryCategoryToBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryCategoryToBookInclude | null
    /**
     * Filter, which LibraryCategoryToBook to fetch.
     */
    where: LibraryCategoryToBookWhereUniqueInput
  }

  /**
   * LibraryCategoryToBook findUnique
   */
  export interface LibraryCategoryToBookFindUniqueArgs extends LibraryCategoryToBookFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LibraryCategoryToBook findUniqueOrThrow
   */
  export type LibraryCategoryToBookFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LibraryCategoryToBook
     */
    select?: LibraryCategoryToBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryCategoryToBookInclude | null
    /**
     * Filter, which LibraryCategoryToBook to fetch.
     */
    where: LibraryCategoryToBookWhereUniqueInput
  }


  /**
   * LibraryCategoryToBook base type for findFirst actions
   */
  export type LibraryCategoryToBookFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the LibraryCategoryToBook
     */
    select?: LibraryCategoryToBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryCategoryToBookInclude | null
    /**
     * Filter, which LibraryCategoryToBook to fetch.
     */
    where?: LibraryCategoryToBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryCategoryToBooks to fetch.
     */
    orderBy?: Enumerable<LibraryCategoryToBookOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryCategoryToBooks.
     */
    cursor?: LibraryCategoryToBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryCategoryToBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryCategoryToBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryCategoryToBooks.
     */
    distinct?: Enumerable<LibraryCategoryToBookScalarFieldEnum>
  }

  /**
   * LibraryCategoryToBook findFirst
   */
  export interface LibraryCategoryToBookFindFirstArgs extends LibraryCategoryToBookFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LibraryCategoryToBook findFirstOrThrow
   */
  export type LibraryCategoryToBookFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LibraryCategoryToBook
     */
    select?: LibraryCategoryToBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryCategoryToBookInclude | null
    /**
     * Filter, which LibraryCategoryToBook to fetch.
     */
    where?: LibraryCategoryToBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryCategoryToBooks to fetch.
     */
    orderBy?: Enumerable<LibraryCategoryToBookOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryCategoryToBooks.
     */
    cursor?: LibraryCategoryToBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryCategoryToBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryCategoryToBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryCategoryToBooks.
     */
    distinct?: Enumerable<LibraryCategoryToBookScalarFieldEnum>
  }


  /**
   * LibraryCategoryToBook findMany
   */
  export type LibraryCategoryToBookFindManyArgs = {
    /**
     * Select specific fields to fetch from the LibraryCategoryToBook
     */
    select?: LibraryCategoryToBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryCategoryToBookInclude | null
    /**
     * Filter, which LibraryCategoryToBooks to fetch.
     */
    where?: LibraryCategoryToBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryCategoryToBooks to fetch.
     */
    orderBy?: Enumerable<LibraryCategoryToBookOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LibraryCategoryToBooks.
     */
    cursor?: LibraryCategoryToBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryCategoryToBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryCategoryToBooks.
     */
    skip?: number
    distinct?: Enumerable<LibraryCategoryToBookScalarFieldEnum>
  }


  /**
   * LibraryCategoryToBook create
   */
  export type LibraryCategoryToBookCreateArgs = {
    /**
     * Select specific fields to fetch from the LibraryCategoryToBook
     */
    select?: LibraryCategoryToBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryCategoryToBookInclude | null
    /**
     * The data needed to create a LibraryCategoryToBook.
     */
    data: XOR<LibraryCategoryToBookCreateInput, LibraryCategoryToBookUncheckedCreateInput>
  }


  /**
   * LibraryCategoryToBook createMany
   */
  export type LibraryCategoryToBookCreateManyArgs = {
    /**
     * The data used to create many LibraryCategoryToBooks.
     */
    data: Enumerable<LibraryCategoryToBookCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LibraryCategoryToBook update
   */
  export type LibraryCategoryToBookUpdateArgs = {
    /**
     * Select specific fields to fetch from the LibraryCategoryToBook
     */
    select?: LibraryCategoryToBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryCategoryToBookInclude | null
    /**
     * The data needed to update a LibraryCategoryToBook.
     */
    data: XOR<LibraryCategoryToBookUpdateInput, LibraryCategoryToBookUncheckedUpdateInput>
    /**
     * Choose, which LibraryCategoryToBook to update.
     */
    where: LibraryCategoryToBookWhereUniqueInput
  }


  /**
   * LibraryCategoryToBook updateMany
   */
  export type LibraryCategoryToBookUpdateManyArgs = {
    /**
     * The data used to update LibraryCategoryToBooks.
     */
    data: XOR<LibraryCategoryToBookUpdateManyMutationInput, LibraryCategoryToBookUncheckedUpdateManyInput>
    /**
     * Filter which LibraryCategoryToBooks to update
     */
    where?: LibraryCategoryToBookWhereInput
  }


  /**
   * LibraryCategoryToBook upsert
   */
  export type LibraryCategoryToBookUpsertArgs = {
    /**
     * Select specific fields to fetch from the LibraryCategoryToBook
     */
    select?: LibraryCategoryToBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryCategoryToBookInclude | null
    /**
     * The filter to search for the LibraryCategoryToBook to update in case it exists.
     */
    where: LibraryCategoryToBookWhereUniqueInput
    /**
     * In case the LibraryCategoryToBook found by the `where` argument doesn't exist, create a new LibraryCategoryToBook with this data.
     */
    create: XOR<LibraryCategoryToBookCreateInput, LibraryCategoryToBookUncheckedCreateInput>
    /**
     * In case the LibraryCategoryToBook was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LibraryCategoryToBookUpdateInput, LibraryCategoryToBookUncheckedUpdateInput>
  }


  /**
   * LibraryCategoryToBook delete
   */
  export type LibraryCategoryToBookDeleteArgs = {
    /**
     * Select specific fields to fetch from the LibraryCategoryToBook
     */
    select?: LibraryCategoryToBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryCategoryToBookInclude | null
    /**
     * Filter which LibraryCategoryToBook to delete.
     */
    where: LibraryCategoryToBookWhereUniqueInput
  }


  /**
   * LibraryCategoryToBook deleteMany
   */
  export type LibraryCategoryToBookDeleteManyArgs = {
    /**
     * Filter which LibraryCategoryToBooks to delete
     */
    where?: LibraryCategoryToBookWhereInput
  }


  /**
   * LibraryCategoryToBook without action
   */
  export type LibraryCategoryToBookArgs = {
    /**
     * Select specific fields to fetch from the LibraryCategoryToBook
     */
    select?: LibraryCategoryToBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryCategoryToBookInclude | null
  }



  /**
   * Model LibraryBookAuthor
   */


  export type AggregateLibraryBookAuthor = {
    _count: LibraryBookAuthorCountAggregateOutputType | null
    _avg: LibraryBookAuthorAvgAggregateOutputType | null
    _sum: LibraryBookAuthorSumAggregateOutputType | null
    _min: LibraryBookAuthorMinAggregateOutputType | null
    _max: LibraryBookAuthorMaxAggregateOutputType | null
  }

  export type LibraryBookAuthorAvgAggregateOutputType = {
    id: number | null
  }

  export type LibraryBookAuthorSumAggregateOutputType = {
    id: number | null
  }

  export type LibraryBookAuthorMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LibraryBookAuthorMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LibraryBookAuthorCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LibraryBookAuthorAvgAggregateInputType = {
    id?: true
  }

  export type LibraryBookAuthorSumAggregateInputType = {
    id?: true
  }

  export type LibraryBookAuthorMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LibraryBookAuthorMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LibraryBookAuthorCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LibraryBookAuthorAggregateArgs = {
    /**
     * Filter which LibraryBookAuthor to aggregate.
     */
    where?: LibraryBookAuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBookAuthors to fetch.
     */
    orderBy?: Enumerable<LibraryBookAuthorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LibraryBookAuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBookAuthors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBookAuthors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LibraryBookAuthors
    **/
    _count?: true | LibraryBookAuthorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LibraryBookAuthorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LibraryBookAuthorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LibraryBookAuthorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LibraryBookAuthorMaxAggregateInputType
  }

  export type GetLibraryBookAuthorAggregateType<T extends LibraryBookAuthorAggregateArgs> = {
        [P in keyof T & keyof AggregateLibraryBookAuthor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLibraryBookAuthor[P]>
      : GetScalarType<T[P], AggregateLibraryBookAuthor[P]>
  }




  export type LibraryBookAuthorGroupByArgs = {
    where?: LibraryBookAuthorWhereInput
    orderBy?: Enumerable<LibraryBookAuthorOrderByWithAggregationInput>
    by: LibraryBookAuthorScalarFieldEnum[]
    having?: LibraryBookAuthorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LibraryBookAuthorCountAggregateInputType | true
    _avg?: LibraryBookAuthorAvgAggregateInputType
    _sum?: LibraryBookAuthorSumAggregateInputType
    _min?: LibraryBookAuthorMinAggregateInputType
    _max?: LibraryBookAuthorMaxAggregateInputType
  }


  export type LibraryBookAuthorGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: LibraryBookAuthorCountAggregateOutputType | null
    _avg: LibraryBookAuthorAvgAggregateOutputType | null
    _sum: LibraryBookAuthorSumAggregateOutputType | null
    _min: LibraryBookAuthorMinAggregateOutputType | null
    _max: LibraryBookAuthorMaxAggregateOutputType | null
  }

  type GetLibraryBookAuthorGroupByPayload<T extends LibraryBookAuthorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LibraryBookAuthorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LibraryBookAuthorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LibraryBookAuthorGroupByOutputType[P]>
            : GetScalarType<T[P], LibraryBookAuthorGroupByOutputType[P]>
        }
      >
    >


  export type LibraryBookAuthorSelect = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    libraryBooksToAuthors?: boolean | LibraryBookAuthor$libraryBooksToAuthorsArgs
    _count?: boolean | LibraryBookAuthorCountOutputTypeArgs
  }


  export type LibraryBookAuthorInclude = {
    libraryBooksToAuthors?: boolean | LibraryBookAuthor$libraryBooksToAuthorsArgs
    _count?: boolean | LibraryBookAuthorCountOutputTypeArgs
  }

  export type LibraryBookAuthorGetPayload<S extends boolean | null | undefined | LibraryBookAuthorArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LibraryBookAuthor :
    S extends undefined ? never :
    S extends { include: any } & (LibraryBookAuthorArgs | LibraryBookAuthorFindManyArgs)
    ? LibraryBookAuthor  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'libraryBooksToAuthors' ? Array < LibraryBookToAuthorGetPayload<S['include'][P]>>  :
        P extends '_count' ? LibraryBookAuthorCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (LibraryBookAuthorArgs | LibraryBookAuthorFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'libraryBooksToAuthors' ? Array < LibraryBookToAuthorGetPayload<S['select'][P]>>  :
        P extends '_count' ? LibraryBookAuthorCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof LibraryBookAuthor ? LibraryBookAuthor[P] : never
  } 
      : LibraryBookAuthor


  type LibraryBookAuthorCountArgs = 
    Omit<LibraryBookAuthorFindManyArgs, 'select' | 'include'> & {
      select?: LibraryBookAuthorCountAggregateInputType | true
    }

  export interface LibraryBookAuthorDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one LibraryBookAuthor that matches the filter.
     * @param {LibraryBookAuthorFindUniqueArgs} args - Arguments to find a LibraryBookAuthor
     * @example
     * // Get one LibraryBookAuthor
     * const libraryBookAuthor = await prisma.libraryBookAuthor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LibraryBookAuthorFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LibraryBookAuthorFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LibraryBookAuthor'> extends True ? Prisma__LibraryBookAuthorClient<LibraryBookAuthorGetPayload<T>> : Prisma__LibraryBookAuthorClient<LibraryBookAuthorGetPayload<T> | null, null>

    /**
     * Find one LibraryBookAuthor that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LibraryBookAuthorFindUniqueOrThrowArgs} args - Arguments to find a LibraryBookAuthor
     * @example
     * // Get one LibraryBookAuthor
     * const libraryBookAuthor = await prisma.libraryBookAuthor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LibraryBookAuthorFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LibraryBookAuthorFindUniqueOrThrowArgs>
    ): Prisma__LibraryBookAuthorClient<LibraryBookAuthorGetPayload<T>>

    /**
     * Find the first LibraryBookAuthor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookAuthorFindFirstArgs} args - Arguments to find a LibraryBookAuthor
     * @example
     * // Get one LibraryBookAuthor
     * const libraryBookAuthor = await prisma.libraryBookAuthor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LibraryBookAuthorFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LibraryBookAuthorFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LibraryBookAuthor'> extends True ? Prisma__LibraryBookAuthorClient<LibraryBookAuthorGetPayload<T>> : Prisma__LibraryBookAuthorClient<LibraryBookAuthorGetPayload<T> | null, null>

    /**
     * Find the first LibraryBookAuthor that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookAuthorFindFirstOrThrowArgs} args - Arguments to find a LibraryBookAuthor
     * @example
     * // Get one LibraryBookAuthor
     * const libraryBookAuthor = await prisma.libraryBookAuthor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LibraryBookAuthorFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LibraryBookAuthorFindFirstOrThrowArgs>
    ): Prisma__LibraryBookAuthorClient<LibraryBookAuthorGetPayload<T>>

    /**
     * Find zero or more LibraryBookAuthors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookAuthorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LibraryBookAuthors
     * const libraryBookAuthors = await prisma.libraryBookAuthor.findMany()
     * 
     * // Get first 10 LibraryBookAuthors
     * const libraryBookAuthors = await prisma.libraryBookAuthor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const libraryBookAuthorWithIdOnly = await prisma.libraryBookAuthor.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LibraryBookAuthorFindManyArgs>(
      args?: SelectSubset<T, LibraryBookAuthorFindManyArgs>
    ): Prisma.PrismaPromise<Array<LibraryBookAuthorGetPayload<T>>>

    /**
     * Create a LibraryBookAuthor.
     * @param {LibraryBookAuthorCreateArgs} args - Arguments to create a LibraryBookAuthor.
     * @example
     * // Create one LibraryBookAuthor
     * const LibraryBookAuthor = await prisma.libraryBookAuthor.create({
     *   data: {
     *     // ... data to create a LibraryBookAuthor
     *   }
     * })
     * 
    **/
    create<T extends LibraryBookAuthorCreateArgs>(
      args: SelectSubset<T, LibraryBookAuthorCreateArgs>
    ): Prisma__LibraryBookAuthorClient<LibraryBookAuthorGetPayload<T>>

    /**
     * Create many LibraryBookAuthors.
     *     @param {LibraryBookAuthorCreateManyArgs} args - Arguments to create many LibraryBookAuthors.
     *     @example
     *     // Create many LibraryBookAuthors
     *     const libraryBookAuthor = await prisma.libraryBookAuthor.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LibraryBookAuthorCreateManyArgs>(
      args?: SelectSubset<T, LibraryBookAuthorCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LibraryBookAuthor.
     * @param {LibraryBookAuthorDeleteArgs} args - Arguments to delete one LibraryBookAuthor.
     * @example
     * // Delete one LibraryBookAuthor
     * const LibraryBookAuthor = await prisma.libraryBookAuthor.delete({
     *   where: {
     *     // ... filter to delete one LibraryBookAuthor
     *   }
     * })
     * 
    **/
    delete<T extends LibraryBookAuthorDeleteArgs>(
      args: SelectSubset<T, LibraryBookAuthorDeleteArgs>
    ): Prisma__LibraryBookAuthorClient<LibraryBookAuthorGetPayload<T>>

    /**
     * Update one LibraryBookAuthor.
     * @param {LibraryBookAuthorUpdateArgs} args - Arguments to update one LibraryBookAuthor.
     * @example
     * // Update one LibraryBookAuthor
     * const libraryBookAuthor = await prisma.libraryBookAuthor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LibraryBookAuthorUpdateArgs>(
      args: SelectSubset<T, LibraryBookAuthorUpdateArgs>
    ): Prisma__LibraryBookAuthorClient<LibraryBookAuthorGetPayload<T>>

    /**
     * Delete zero or more LibraryBookAuthors.
     * @param {LibraryBookAuthorDeleteManyArgs} args - Arguments to filter LibraryBookAuthors to delete.
     * @example
     * // Delete a few LibraryBookAuthors
     * const { count } = await prisma.libraryBookAuthor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LibraryBookAuthorDeleteManyArgs>(
      args?: SelectSubset<T, LibraryBookAuthorDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LibraryBookAuthors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookAuthorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LibraryBookAuthors
     * const libraryBookAuthor = await prisma.libraryBookAuthor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LibraryBookAuthorUpdateManyArgs>(
      args: SelectSubset<T, LibraryBookAuthorUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LibraryBookAuthor.
     * @param {LibraryBookAuthorUpsertArgs} args - Arguments to update or create a LibraryBookAuthor.
     * @example
     * // Update or create a LibraryBookAuthor
     * const libraryBookAuthor = await prisma.libraryBookAuthor.upsert({
     *   create: {
     *     // ... data to create a LibraryBookAuthor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LibraryBookAuthor we want to update
     *   }
     * })
    **/
    upsert<T extends LibraryBookAuthorUpsertArgs>(
      args: SelectSubset<T, LibraryBookAuthorUpsertArgs>
    ): Prisma__LibraryBookAuthorClient<LibraryBookAuthorGetPayload<T>>

    /**
     * Count the number of LibraryBookAuthors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookAuthorCountArgs} args - Arguments to filter LibraryBookAuthors to count.
     * @example
     * // Count the number of LibraryBookAuthors
     * const count = await prisma.libraryBookAuthor.count({
     *   where: {
     *     // ... the filter for the LibraryBookAuthors we want to count
     *   }
     * })
    **/
    count<T extends LibraryBookAuthorCountArgs>(
      args?: Subset<T, LibraryBookAuthorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LibraryBookAuthorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LibraryBookAuthor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookAuthorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LibraryBookAuthorAggregateArgs>(args: Subset<T, LibraryBookAuthorAggregateArgs>): Prisma.PrismaPromise<GetLibraryBookAuthorAggregateType<T>>

    /**
     * Group by LibraryBookAuthor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookAuthorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LibraryBookAuthorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LibraryBookAuthorGroupByArgs['orderBy'] }
        : { orderBy?: LibraryBookAuthorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LibraryBookAuthorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLibraryBookAuthorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LibraryBookAuthor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LibraryBookAuthorClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    libraryBooksToAuthors<T extends LibraryBookAuthor$libraryBooksToAuthorsArgs= {}>(args?: Subset<T, LibraryBookAuthor$libraryBooksToAuthorsArgs>): Prisma.PrismaPromise<Array<LibraryBookToAuthorGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LibraryBookAuthor base type for findUnique actions
   */
  export type LibraryBookAuthorFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the LibraryBookAuthor
     */
    select?: LibraryBookAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookAuthorInclude | null
    /**
     * Filter, which LibraryBookAuthor to fetch.
     */
    where: LibraryBookAuthorWhereUniqueInput
  }

  /**
   * LibraryBookAuthor findUnique
   */
  export interface LibraryBookAuthorFindUniqueArgs extends LibraryBookAuthorFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LibraryBookAuthor findUniqueOrThrow
   */
  export type LibraryBookAuthorFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookAuthor
     */
    select?: LibraryBookAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookAuthorInclude | null
    /**
     * Filter, which LibraryBookAuthor to fetch.
     */
    where: LibraryBookAuthorWhereUniqueInput
  }


  /**
   * LibraryBookAuthor base type for findFirst actions
   */
  export type LibraryBookAuthorFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the LibraryBookAuthor
     */
    select?: LibraryBookAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookAuthorInclude | null
    /**
     * Filter, which LibraryBookAuthor to fetch.
     */
    where?: LibraryBookAuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBookAuthors to fetch.
     */
    orderBy?: Enumerable<LibraryBookAuthorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryBookAuthors.
     */
    cursor?: LibraryBookAuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBookAuthors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBookAuthors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryBookAuthors.
     */
    distinct?: Enumerable<LibraryBookAuthorScalarFieldEnum>
  }

  /**
   * LibraryBookAuthor findFirst
   */
  export interface LibraryBookAuthorFindFirstArgs extends LibraryBookAuthorFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LibraryBookAuthor findFirstOrThrow
   */
  export type LibraryBookAuthorFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookAuthor
     */
    select?: LibraryBookAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookAuthorInclude | null
    /**
     * Filter, which LibraryBookAuthor to fetch.
     */
    where?: LibraryBookAuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBookAuthors to fetch.
     */
    orderBy?: Enumerable<LibraryBookAuthorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryBookAuthors.
     */
    cursor?: LibraryBookAuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBookAuthors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBookAuthors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryBookAuthors.
     */
    distinct?: Enumerable<LibraryBookAuthorScalarFieldEnum>
  }


  /**
   * LibraryBookAuthor findMany
   */
  export type LibraryBookAuthorFindManyArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookAuthor
     */
    select?: LibraryBookAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookAuthorInclude | null
    /**
     * Filter, which LibraryBookAuthors to fetch.
     */
    where?: LibraryBookAuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBookAuthors to fetch.
     */
    orderBy?: Enumerable<LibraryBookAuthorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LibraryBookAuthors.
     */
    cursor?: LibraryBookAuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBookAuthors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBookAuthors.
     */
    skip?: number
    distinct?: Enumerable<LibraryBookAuthorScalarFieldEnum>
  }


  /**
   * LibraryBookAuthor create
   */
  export type LibraryBookAuthorCreateArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookAuthor
     */
    select?: LibraryBookAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookAuthorInclude | null
    /**
     * The data needed to create a LibraryBookAuthor.
     */
    data: XOR<LibraryBookAuthorCreateInput, LibraryBookAuthorUncheckedCreateInput>
  }


  /**
   * LibraryBookAuthor createMany
   */
  export type LibraryBookAuthorCreateManyArgs = {
    /**
     * The data used to create many LibraryBookAuthors.
     */
    data: Enumerable<LibraryBookAuthorCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LibraryBookAuthor update
   */
  export type LibraryBookAuthorUpdateArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookAuthor
     */
    select?: LibraryBookAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookAuthorInclude | null
    /**
     * The data needed to update a LibraryBookAuthor.
     */
    data: XOR<LibraryBookAuthorUpdateInput, LibraryBookAuthorUncheckedUpdateInput>
    /**
     * Choose, which LibraryBookAuthor to update.
     */
    where: LibraryBookAuthorWhereUniqueInput
  }


  /**
   * LibraryBookAuthor updateMany
   */
  export type LibraryBookAuthorUpdateManyArgs = {
    /**
     * The data used to update LibraryBookAuthors.
     */
    data: XOR<LibraryBookAuthorUpdateManyMutationInput, LibraryBookAuthorUncheckedUpdateManyInput>
    /**
     * Filter which LibraryBookAuthors to update
     */
    where?: LibraryBookAuthorWhereInput
  }


  /**
   * LibraryBookAuthor upsert
   */
  export type LibraryBookAuthorUpsertArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookAuthor
     */
    select?: LibraryBookAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookAuthorInclude | null
    /**
     * The filter to search for the LibraryBookAuthor to update in case it exists.
     */
    where: LibraryBookAuthorWhereUniqueInput
    /**
     * In case the LibraryBookAuthor found by the `where` argument doesn't exist, create a new LibraryBookAuthor with this data.
     */
    create: XOR<LibraryBookAuthorCreateInput, LibraryBookAuthorUncheckedCreateInput>
    /**
     * In case the LibraryBookAuthor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LibraryBookAuthorUpdateInput, LibraryBookAuthorUncheckedUpdateInput>
  }


  /**
   * LibraryBookAuthor delete
   */
  export type LibraryBookAuthorDeleteArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookAuthor
     */
    select?: LibraryBookAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookAuthorInclude | null
    /**
     * Filter which LibraryBookAuthor to delete.
     */
    where: LibraryBookAuthorWhereUniqueInput
  }


  /**
   * LibraryBookAuthor deleteMany
   */
  export type LibraryBookAuthorDeleteManyArgs = {
    /**
     * Filter which LibraryBookAuthors to delete
     */
    where?: LibraryBookAuthorWhereInput
  }


  /**
   * LibraryBookAuthor.libraryBooksToAuthors
   */
  export type LibraryBookAuthor$libraryBooksToAuthorsArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookToAuthor
     */
    select?: LibraryBookToAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookToAuthorInclude | null
    where?: LibraryBookToAuthorWhereInput
    orderBy?: Enumerable<LibraryBookToAuthorOrderByWithRelationInput>
    cursor?: LibraryBookToAuthorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LibraryBookToAuthorScalarFieldEnum>
  }


  /**
   * LibraryBookAuthor without action
   */
  export type LibraryBookAuthorArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookAuthor
     */
    select?: LibraryBookAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookAuthorInclude | null
  }



  /**
   * Model LibraryBookToAuthor
   */


  export type AggregateLibraryBookToAuthor = {
    _count: LibraryBookToAuthorCountAggregateOutputType | null
    _avg: LibraryBookToAuthorAvgAggregateOutputType | null
    _sum: LibraryBookToAuthorSumAggregateOutputType | null
    _min: LibraryBookToAuthorMinAggregateOutputType | null
    _max: LibraryBookToAuthorMaxAggregateOutputType | null
  }

  export type LibraryBookToAuthorAvgAggregateOutputType = {
    id: number | null
    libraryBookId: number | null
    libraryBookAuthorId: number | null
  }

  export type LibraryBookToAuthorSumAggregateOutputType = {
    id: number | null
    libraryBookId: number | null
    libraryBookAuthorId: number | null
  }

  export type LibraryBookToAuthorMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    libraryBookId: number | null
    libraryBookAuthorId: number | null
  }

  export type LibraryBookToAuthorMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    libraryBookId: number | null
    libraryBookAuthorId: number | null
  }

  export type LibraryBookToAuthorCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    libraryBookId: number
    libraryBookAuthorId: number
    _all: number
  }


  export type LibraryBookToAuthorAvgAggregateInputType = {
    id?: true
    libraryBookId?: true
    libraryBookAuthorId?: true
  }

  export type LibraryBookToAuthorSumAggregateInputType = {
    id?: true
    libraryBookId?: true
    libraryBookAuthorId?: true
  }

  export type LibraryBookToAuthorMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    libraryBookId?: true
    libraryBookAuthorId?: true
  }

  export type LibraryBookToAuthorMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    libraryBookId?: true
    libraryBookAuthorId?: true
  }

  export type LibraryBookToAuthorCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    libraryBookId?: true
    libraryBookAuthorId?: true
    _all?: true
  }

  export type LibraryBookToAuthorAggregateArgs = {
    /**
     * Filter which LibraryBookToAuthor to aggregate.
     */
    where?: LibraryBookToAuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBookToAuthors to fetch.
     */
    orderBy?: Enumerable<LibraryBookToAuthorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LibraryBookToAuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBookToAuthors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBookToAuthors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LibraryBookToAuthors
    **/
    _count?: true | LibraryBookToAuthorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LibraryBookToAuthorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LibraryBookToAuthorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LibraryBookToAuthorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LibraryBookToAuthorMaxAggregateInputType
  }

  export type GetLibraryBookToAuthorAggregateType<T extends LibraryBookToAuthorAggregateArgs> = {
        [P in keyof T & keyof AggregateLibraryBookToAuthor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLibraryBookToAuthor[P]>
      : GetScalarType<T[P], AggregateLibraryBookToAuthor[P]>
  }




  export type LibraryBookToAuthorGroupByArgs = {
    where?: LibraryBookToAuthorWhereInput
    orderBy?: Enumerable<LibraryBookToAuthorOrderByWithAggregationInput>
    by: LibraryBookToAuthorScalarFieldEnum[]
    having?: LibraryBookToAuthorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LibraryBookToAuthorCountAggregateInputType | true
    _avg?: LibraryBookToAuthorAvgAggregateInputType
    _sum?: LibraryBookToAuthorSumAggregateInputType
    _min?: LibraryBookToAuthorMinAggregateInputType
    _max?: LibraryBookToAuthorMaxAggregateInputType
  }


  export type LibraryBookToAuthorGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    libraryBookId: number
    libraryBookAuthorId: number
    _count: LibraryBookToAuthorCountAggregateOutputType | null
    _avg: LibraryBookToAuthorAvgAggregateOutputType | null
    _sum: LibraryBookToAuthorSumAggregateOutputType | null
    _min: LibraryBookToAuthorMinAggregateOutputType | null
    _max: LibraryBookToAuthorMaxAggregateOutputType | null
  }

  type GetLibraryBookToAuthorGroupByPayload<T extends LibraryBookToAuthorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LibraryBookToAuthorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LibraryBookToAuthorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LibraryBookToAuthorGroupByOutputType[P]>
            : GetScalarType<T[P], LibraryBookToAuthorGroupByOutputType[P]>
        }
      >
    >


  export type LibraryBookToAuthorSelect = {
    id?: boolean
    book?: boolean | LibraryBookArgs
    author?: boolean | LibraryBookAuthorArgs
    createdAt?: boolean
    updatedAt?: boolean
    libraryBookId?: boolean
    libraryBookAuthorId?: boolean
  }


  export type LibraryBookToAuthorInclude = {
    book?: boolean | LibraryBookArgs
    author?: boolean | LibraryBookAuthorArgs
  }

  export type LibraryBookToAuthorGetPayload<S extends boolean | null | undefined | LibraryBookToAuthorArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LibraryBookToAuthor :
    S extends undefined ? never :
    S extends { include: any } & (LibraryBookToAuthorArgs | LibraryBookToAuthorFindManyArgs)
    ? LibraryBookToAuthor  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'book' ? LibraryBookGetPayload<S['include'][P]> :
        P extends 'author' ? LibraryBookAuthorGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (LibraryBookToAuthorArgs | LibraryBookToAuthorFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'book' ? LibraryBookGetPayload<S['select'][P]> :
        P extends 'author' ? LibraryBookAuthorGetPayload<S['select'][P]> :  P extends keyof LibraryBookToAuthor ? LibraryBookToAuthor[P] : never
  } 
      : LibraryBookToAuthor


  type LibraryBookToAuthorCountArgs = 
    Omit<LibraryBookToAuthorFindManyArgs, 'select' | 'include'> & {
      select?: LibraryBookToAuthorCountAggregateInputType | true
    }

  export interface LibraryBookToAuthorDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one LibraryBookToAuthor that matches the filter.
     * @param {LibraryBookToAuthorFindUniqueArgs} args - Arguments to find a LibraryBookToAuthor
     * @example
     * // Get one LibraryBookToAuthor
     * const libraryBookToAuthor = await prisma.libraryBookToAuthor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LibraryBookToAuthorFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LibraryBookToAuthorFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LibraryBookToAuthor'> extends True ? Prisma__LibraryBookToAuthorClient<LibraryBookToAuthorGetPayload<T>> : Prisma__LibraryBookToAuthorClient<LibraryBookToAuthorGetPayload<T> | null, null>

    /**
     * Find one LibraryBookToAuthor that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LibraryBookToAuthorFindUniqueOrThrowArgs} args - Arguments to find a LibraryBookToAuthor
     * @example
     * // Get one LibraryBookToAuthor
     * const libraryBookToAuthor = await prisma.libraryBookToAuthor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LibraryBookToAuthorFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LibraryBookToAuthorFindUniqueOrThrowArgs>
    ): Prisma__LibraryBookToAuthorClient<LibraryBookToAuthorGetPayload<T>>

    /**
     * Find the first LibraryBookToAuthor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookToAuthorFindFirstArgs} args - Arguments to find a LibraryBookToAuthor
     * @example
     * // Get one LibraryBookToAuthor
     * const libraryBookToAuthor = await prisma.libraryBookToAuthor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LibraryBookToAuthorFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LibraryBookToAuthorFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LibraryBookToAuthor'> extends True ? Prisma__LibraryBookToAuthorClient<LibraryBookToAuthorGetPayload<T>> : Prisma__LibraryBookToAuthorClient<LibraryBookToAuthorGetPayload<T> | null, null>

    /**
     * Find the first LibraryBookToAuthor that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookToAuthorFindFirstOrThrowArgs} args - Arguments to find a LibraryBookToAuthor
     * @example
     * // Get one LibraryBookToAuthor
     * const libraryBookToAuthor = await prisma.libraryBookToAuthor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LibraryBookToAuthorFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LibraryBookToAuthorFindFirstOrThrowArgs>
    ): Prisma__LibraryBookToAuthorClient<LibraryBookToAuthorGetPayload<T>>

    /**
     * Find zero or more LibraryBookToAuthors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookToAuthorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LibraryBookToAuthors
     * const libraryBookToAuthors = await prisma.libraryBookToAuthor.findMany()
     * 
     * // Get first 10 LibraryBookToAuthors
     * const libraryBookToAuthors = await prisma.libraryBookToAuthor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const libraryBookToAuthorWithIdOnly = await prisma.libraryBookToAuthor.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LibraryBookToAuthorFindManyArgs>(
      args?: SelectSubset<T, LibraryBookToAuthorFindManyArgs>
    ): Prisma.PrismaPromise<Array<LibraryBookToAuthorGetPayload<T>>>

    /**
     * Create a LibraryBookToAuthor.
     * @param {LibraryBookToAuthorCreateArgs} args - Arguments to create a LibraryBookToAuthor.
     * @example
     * // Create one LibraryBookToAuthor
     * const LibraryBookToAuthor = await prisma.libraryBookToAuthor.create({
     *   data: {
     *     // ... data to create a LibraryBookToAuthor
     *   }
     * })
     * 
    **/
    create<T extends LibraryBookToAuthorCreateArgs>(
      args: SelectSubset<T, LibraryBookToAuthorCreateArgs>
    ): Prisma__LibraryBookToAuthorClient<LibraryBookToAuthorGetPayload<T>>

    /**
     * Create many LibraryBookToAuthors.
     *     @param {LibraryBookToAuthorCreateManyArgs} args - Arguments to create many LibraryBookToAuthors.
     *     @example
     *     // Create many LibraryBookToAuthors
     *     const libraryBookToAuthor = await prisma.libraryBookToAuthor.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LibraryBookToAuthorCreateManyArgs>(
      args?: SelectSubset<T, LibraryBookToAuthorCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LibraryBookToAuthor.
     * @param {LibraryBookToAuthorDeleteArgs} args - Arguments to delete one LibraryBookToAuthor.
     * @example
     * // Delete one LibraryBookToAuthor
     * const LibraryBookToAuthor = await prisma.libraryBookToAuthor.delete({
     *   where: {
     *     // ... filter to delete one LibraryBookToAuthor
     *   }
     * })
     * 
    **/
    delete<T extends LibraryBookToAuthorDeleteArgs>(
      args: SelectSubset<T, LibraryBookToAuthorDeleteArgs>
    ): Prisma__LibraryBookToAuthorClient<LibraryBookToAuthorGetPayload<T>>

    /**
     * Update one LibraryBookToAuthor.
     * @param {LibraryBookToAuthorUpdateArgs} args - Arguments to update one LibraryBookToAuthor.
     * @example
     * // Update one LibraryBookToAuthor
     * const libraryBookToAuthor = await prisma.libraryBookToAuthor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LibraryBookToAuthorUpdateArgs>(
      args: SelectSubset<T, LibraryBookToAuthorUpdateArgs>
    ): Prisma__LibraryBookToAuthorClient<LibraryBookToAuthorGetPayload<T>>

    /**
     * Delete zero or more LibraryBookToAuthors.
     * @param {LibraryBookToAuthorDeleteManyArgs} args - Arguments to filter LibraryBookToAuthors to delete.
     * @example
     * // Delete a few LibraryBookToAuthors
     * const { count } = await prisma.libraryBookToAuthor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LibraryBookToAuthorDeleteManyArgs>(
      args?: SelectSubset<T, LibraryBookToAuthorDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LibraryBookToAuthors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookToAuthorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LibraryBookToAuthors
     * const libraryBookToAuthor = await prisma.libraryBookToAuthor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LibraryBookToAuthorUpdateManyArgs>(
      args: SelectSubset<T, LibraryBookToAuthorUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LibraryBookToAuthor.
     * @param {LibraryBookToAuthorUpsertArgs} args - Arguments to update or create a LibraryBookToAuthor.
     * @example
     * // Update or create a LibraryBookToAuthor
     * const libraryBookToAuthor = await prisma.libraryBookToAuthor.upsert({
     *   create: {
     *     // ... data to create a LibraryBookToAuthor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LibraryBookToAuthor we want to update
     *   }
     * })
    **/
    upsert<T extends LibraryBookToAuthorUpsertArgs>(
      args: SelectSubset<T, LibraryBookToAuthorUpsertArgs>
    ): Prisma__LibraryBookToAuthorClient<LibraryBookToAuthorGetPayload<T>>

    /**
     * Count the number of LibraryBookToAuthors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookToAuthorCountArgs} args - Arguments to filter LibraryBookToAuthors to count.
     * @example
     * // Count the number of LibraryBookToAuthors
     * const count = await prisma.libraryBookToAuthor.count({
     *   where: {
     *     // ... the filter for the LibraryBookToAuthors we want to count
     *   }
     * })
    **/
    count<T extends LibraryBookToAuthorCountArgs>(
      args?: Subset<T, LibraryBookToAuthorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LibraryBookToAuthorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LibraryBookToAuthor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookToAuthorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LibraryBookToAuthorAggregateArgs>(args: Subset<T, LibraryBookToAuthorAggregateArgs>): Prisma.PrismaPromise<GetLibraryBookToAuthorAggregateType<T>>

    /**
     * Group by LibraryBookToAuthor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookToAuthorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LibraryBookToAuthorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LibraryBookToAuthorGroupByArgs['orderBy'] }
        : { orderBy?: LibraryBookToAuthorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LibraryBookToAuthorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLibraryBookToAuthorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LibraryBookToAuthor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LibraryBookToAuthorClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    book<T extends LibraryBookArgs= {}>(args?: Subset<T, LibraryBookArgs>): Prisma__LibraryBookClient<LibraryBookGetPayload<T> | Null>;

    author<T extends LibraryBookAuthorArgs= {}>(args?: Subset<T, LibraryBookAuthorArgs>): Prisma__LibraryBookAuthorClient<LibraryBookAuthorGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LibraryBookToAuthor base type for findUnique actions
   */
  export type LibraryBookToAuthorFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the LibraryBookToAuthor
     */
    select?: LibraryBookToAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookToAuthorInclude | null
    /**
     * Filter, which LibraryBookToAuthor to fetch.
     */
    where: LibraryBookToAuthorWhereUniqueInput
  }

  /**
   * LibraryBookToAuthor findUnique
   */
  export interface LibraryBookToAuthorFindUniqueArgs extends LibraryBookToAuthorFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LibraryBookToAuthor findUniqueOrThrow
   */
  export type LibraryBookToAuthorFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookToAuthor
     */
    select?: LibraryBookToAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookToAuthorInclude | null
    /**
     * Filter, which LibraryBookToAuthor to fetch.
     */
    where: LibraryBookToAuthorWhereUniqueInput
  }


  /**
   * LibraryBookToAuthor base type for findFirst actions
   */
  export type LibraryBookToAuthorFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the LibraryBookToAuthor
     */
    select?: LibraryBookToAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookToAuthorInclude | null
    /**
     * Filter, which LibraryBookToAuthor to fetch.
     */
    where?: LibraryBookToAuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBookToAuthors to fetch.
     */
    orderBy?: Enumerable<LibraryBookToAuthorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryBookToAuthors.
     */
    cursor?: LibraryBookToAuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBookToAuthors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBookToAuthors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryBookToAuthors.
     */
    distinct?: Enumerable<LibraryBookToAuthorScalarFieldEnum>
  }

  /**
   * LibraryBookToAuthor findFirst
   */
  export interface LibraryBookToAuthorFindFirstArgs extends LibraryBookToAuthorFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LibraryBookToAuthor findFirstOrThrow
   */
  export type LibraryBookToAuthorFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookToAuthor
     */
    select?: LibraryBookToAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookToAuthorInclude | null
    /**
     * Filter, which LibraryBookToAuthor to fetch.
     */
    where?: LibraryBookToAuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBookToAuthors to fetch.
     */
    orderBy?: Enumerable<LibraryBookToAuthorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryBookToAuthors.
     */
    cursor?: LibraryBookToAuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBookToAuthors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBookToAuthors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryBookToAuthors.
     */
    distinct?: Enumerable<LibraryBookToAuthorScalarFieldEnum>
  }


  /**
   * LibraryBookToAuthor findMany
   */
  export type LibraryBookToAuthorFindManyArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookToAuthor
     */
    select?: LibraryBookToAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookToAuthorInclude | null
    /**
     * Filter, which LibraryBookToAuthors to fetch.
     */
    where?: LibraryBookToAuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBookToAuthors to fetch.
     */
    orderBy?: Enumerable<LibraryBookToAuthorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LibraryBookToAuthors.
     */
    cursor?: LibraryBookToAuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBookToAuthors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBookToAuthors.
     */
    skip?: number
    distinct?: Enumerable<LibraryBookToAuthorScalarFieldEnum>
  }


  /**
   * LibraryBookToAuthor create
   */
  export type LibraryBookToAuthorCreateArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookToAuthor
     */
    select?: LibraryBookToAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookToAuthorInclude | null
    /**
     * The data needed to create a LibraryBookToAuthor.
     */
    data: XOR<LibraryBookToAuthorCreateInput, LibraryBookToAuthorUncheckedCreateInput>
  }


  /**
   * LibraryBookToAuthor createMany
   */
  export type LibraryBookToAuthorCreateManyArgs = {
    /**
     * The data used to create many LibraryBookToAuthors.
     */
    data: Enumerable<LibraryBookToAuthorCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LibraryBookToAuthor update
   */
  export type LibraryBookToAuthorUpdateArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookToAuthor
     */
    select?: LibraryBookToAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookToAuthorInclude | null
    /**
     * The data needed to update a LibraryBookToAuthor.
     */
    data: XOR<LibraryBookToAuthorUpdateInput, LibraryBookToAuthorUncheckedUpdateInput>
    /**
     * Choose, which LibraryBookToAuthor to update.
     */
    where: LibraryBookToAuthorWhereUniqueInput
  }


  /**
   * LibraryBookToAuthor updateMany
   */
  export type LibraryBookToAuthorUpdateManyArgs = {
    /**
     * The data used to update LibraryBookToAuthors.
     */
    data: XOR<LibraryBookToAuthorUpdateManyMutationInput, LibraryBookToAuthorUncheckedUpdateManyInput>
    /**
     * Filter which LibraryBookToAuthors to update
     */
    where?: LibraryBookToAuthorWhereInput
  }


  /**
   * LibraryBookToAuthor upsert
   */
  export type LibraryBookToAuthorUpsertArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookToAuthor
     */
    select?: LibraryBookToAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookToAuthorInclude | null
    /**
     * The filter to search for the LibraryBookToAuthor to update in case it exists.
     */
    where: LibraryBookToAuthorWhereUniqueInput
    /**
     * In case the LibraryBookToAuthor found by the `where` argument doesn't exist, create a new LibraryBookToAuthor with this data.
     */
    create: XOR<LibraryBookToAuthorCreateInput, LibraryBookToAuthorUncheckedCreateInput>
    /**
     * In case the LibraryBookToAuthor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LibraryBookToAuthorUpdateInput, LibraryBookToAuthorUncheckedUpdateInput>
  }


  /**
   * LibraryBookToAuthor delete
   */
  export type LibraryBookToAuthorDeleteArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookToAuthor
     */
    select?: LibraryBookToAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookToAuthorInclude | null
    /**
     * Filter which LibraryBookToAuthor to delete.
     */
    where: LibraryBookToAuthorWhereUniqueInput
  }


  /**
   * LibraryBookToAuthor deleteMany
   */
  export type LibraryBookToAuthorDeleteManyArgs = {
    /**
     * Filter which LibraryBookToAuthors to delete
     */
    where?: LibraryBookToAuthorWhereInput
  }


  /**
   * LibraryBookToAuthor without action
   */
  export type LibraryBookToAuthorArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookToAuthor
     */
    select?: LibraryBookToAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookToAuthorInclude | null
  }



  /**
   * Model LibraryUniversity
   */


  export type AggregateLibraryUniversity = {
    _count: LibraryUniversityCountAggregateOutputType | null
    _avg: LibraryUniversityAvgAggregateOutputType | null
    _sum: LibraryUniversitySumAggregateOutputType | null
    _min: LibraryUniversityMinAggregateOutputType | null
    _max: LibraryUniversityMaxAggregateOutputType | null
  }

  export type LibraryUniversityAvgAggregateOutputType = {
    id: number | null
  }

  export type LibraryUniversitySumAggregateOutputType = {
    id: number | null
  }

  export type LibraryUniversityMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LibraryUniversityMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LibraryUniversityCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LibraryUniversityAvgAggregateInputType = {
    id?: true
  }

  export type LibraryUniversitySumAggregateInputType = {
    id?: true
  }

  export type LibraryUniversityMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LibraryUniversityMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LibraryUniversityCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LibraryUniversityAggregateArgs = {
    /**
     * Filter which LibraryUniversity to aggregate.
     */
    where?: LibraryUniversityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryUniversities to fetch.
     */
    orderBy?: Enumerable<LibraryUniversityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LibraryUniversityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryUniversities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryUniversities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LibraryUniversities
    **/
    _count?: true | LibraryUniversityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LibraryUniversityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LibraryUniversitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LibraryUniversityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LibraryUniversityMaxAggregateInputType
  }

  export type GetLibraryUniversityAggregateType<T extends LibraryUniversityAggregateArgs> = {
        [P in keyof T & keyof AggregateLibraryUniversity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLibraryUniversity[P]>
      : GetScalarType<T[P], AggregateLibraryUniversity[P]>
  }




  export type LibraryUniversityGroupByArgs = {
    where?: LibraryUniversityWhereInput
    orderBy?: Enumerable<LibraryUniversityOrderByWithAggregationInput>
    by: LibraryUniversityScalarFieldEnum[]
    having?: LibraryUniversityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LibraryUniversityCountAggregateInputType | true
    _avg?: LibraryUniversityAvgAggregateInputType
    _sum?: LibraryUniversitySumAggregateInputType
    _min?: LibraryUniversityMinAggregateInputType
    _max?: LibraryUniversityMaxAggregateInputType
  }


  export type LibraryUniversityGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: LibraryUniversityCountAggregateOutputType | null
    _avg: LibraryUniversityAvgAggregateOutputType | null
    _sum: LibraryUniversitySumAggregateOutputType | null
    _min: LibraryUniversityMinAggregateOutputType | null
    _max: LibraryUniversityMaxAggregateOutputType | null
  }

  type GetLibraryUniversityGroupByPayload<T extends LibraryUniversityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LibraryUniversityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LibraryUniversityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LibraryUniversityGroupByOutputType[P]>
            : GetScalarType<T[P], LibraryUniversityGroupByOutputType[P]>
        }
      >
    >


  export type LibraryUniversitySelect = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    libraryStudenta?: boolean | LibraryUniversity$libraryStudentaArgs
    libraryBookCopies?: boolean | LibraryUniversity$libraryBookCopiesArgs
    libraryBorrowingHistories?: boolean | LibraryUniversity$libraryBorrowingHistoriesArgs
    fromLibraryRequests?: boolean | LibraryUniversity$fromLibraryRequestsArgs
    toLibraryRequests?: boolean | LibraryUniversity$toLibraryRequestsArgs
    _count?: boolean | LibraryUniversityCountOutputTypeArgs
  }


  export type LibraryUniversityInclude = {
    libraryStudenta?: boolean | LibraryUniversity$libraryStudentaArgs
    libraryBookCopies?: boolean | LibraryUniversity$libraryBookCopiesArgs
    libraryBorrowingHistories?: boolean | LibraryUniversity$libraryBorrowingHistoriesArgs
    fromLibraryRequests?: boolean | LibraryUniversity$fromLibraryRequestsArgs
    toLibraryRequests?: boolean | LibraryUniversity$toLibraryRequestsArgs
    _count?: boolean | LibraryUniversityCountOutputTypeArgs
  }

  export type LibraryUniversityGetPayload<S extends boolean | null | undefined | LibraryUniversityArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LibraryUniversity :
    S extends undefined ? never :
    S extends { include: any } & (LibraryUniversityArgs | LibraryUniversityFindManyArgs)
    ? LibraryUniversity  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'libraryStudenta' ? Array < LibraryStudentGetPayload<S['include'][P]>>  :
        P extends 'libraryBookCopies' ? Array < LibraryBookCopyGetPayload<S['include'][P]>>  :
        P extends 'libraryBorrowingHistories' ? Array < LibraryBorrowingHistoryGetPayload<S['include'][P]>>  :
        P extends 'fromLibraryRequests' ? Array < LibraryRequestGetPayload<S['include'][P]>>  :
        P extends 'toLibraryRequests' ? Array < LibraryRequestGetPayload<S['include'][P]>>  :
        P extends '_count' ? LibraryUniversityCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (LibraryUniversityArgs | LibraryUniversityFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'libraryStudenta' ? Array < LibraryStudentGetPayload<S['select'][P]>>  :
        P extends 'libraryBookCopies' ? Array < LibraryBookCopyGetPayload<S['select'][P]>>  :
        P extends 'libraryBorrowingHistories' ? Array < LibraryBorrowingHistoryGetPayload<S['select'][P]>>  :
        P extends 'fromLibraryRequests' ? Array < LibraryRequestGetPayload<S['select'][P]>>  :
        P extends 'toLibraryRequests' ? Array < LibraryRequestGetPayload<S['select'][P]>>  :
        P extends '_count' ? LibraryUniversityCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof LibraryUniversity ? LibraryUniversity[P] : never
  } 
      : LibraryUniversity


  type LibraryUniversityCountArgs = 
    Omit<LibraryUniversityFindManyArgs, 'select' | 'include'> & {
      select?: LibraryUniversityCountAggregateInputType | true
    }

  export interface LibraryUniversityDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one LibraryUniversity that matches the filter.
     * @param {LibraryUniversityFindUniqueArgs} args - Arguments to find a LibraryUniversity
     * @example
     * // Get one LibraryUniversity
     * const libraryUniversity = await prisma.libraryUniversity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LibraryUniversityFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LibraryUniversityFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LibraryUniversity'> extends True ? Prisma__LibraryUniversityClient<LibraryUniversityGetPayload<T>> : Prisma__LibraryUniversityClient<LibraryUniversityGetPayload<T> | null, null>

    /**
     * Find one LibraryUniversity that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LibraryUniversityFindUniqueOrThrowArgs} args - Arguments to find a LibraryUniversity
     * @example
     * // Get one LibraryUniversity
     * const libraryUniversity = await prisma.libraryUniversity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LibraryUniversityFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LibraryUniversityFindUniqueOrThrowArgs>
    ): Prisma__LibraryUniversityClient<LibraryUniversityGetPayload<T>>

    /**
     * Find the first LibraryUniversity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryUniversityFindFirstArgs} args - Arguments to find a LibraryUniversity
     * @example
     * // Get one LibraryUniversity
     * const libraryUniversity = await prisma.libraryUniversity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LibraryUniversityFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LibraryUniversityFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LibraryUniversity'> extends True ? Prisma__LibraryUniversityClient<LibraryUniversityGetPayload<T>> : Prisma__LibraryUniversityClient<LibraryUniversityGetPayload<T> | null, null>

    /**
     * Find the first LibraryUniversity that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryUniversityFindFirstOrThrowArgs} args - Arguments to find a LibraryUniversity
     * @example
     * // Get one LibraryUniversity
     * const libraryUniversity = await prisma.libraryUniversity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LibraryUniversityFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LibraryUniversityFindFirstOrThrowArgs>
    ): Prisma__LibraryUniversityClient<LibraryUniversityGetPayload<T>>

    /**
     * Find zero or more LibraryUniversities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryUniversityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LibraryUniversities
     * const libraryUniversities = await prisma.libraryUniversity.findMany()
     * 
     * // Get first 10 LibraryUniversities
     * const libraryUniversities = await prisma.libraryUniversity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const libraryUniversityWithIdOnly = await prisma.libraryUniversity.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LibraryUniversityFindManyArgs>(
      args?: SelectSubset<T, LibraryUniversityFindManyArgs>
    ): Prisma.PrismaPromise<Array<LibraryUniversityGetPayload<T>>>

    /**
     * Create a LibraryUniversity.
     * @param {LibraryUniversityCreateArgs} args - Arguments to create a LibraryUniversity.
     * @example
     * // Create one LibraryUniversity
     * const LibraryUniversity = await prisma.libraryUniversity.create({
     *   data: {
     *     // ... data to create a LibraryUniversity
     *   }
     * })
     * 
    **/
    create<T extends LibraryUniversityCreateArgs>(
      args: SelectSubset<T, LibraryUniversityCreateArgs>
    ): Prisma__LibraryUniversityClient<LibraryUniversityGetPayload<T>>

    /**
     * Create many LibraryUniversities.
     *     @param {LibraryUniversityCreateManyArgs} args - Arguments to create many LibraryUniversities.
     *     @example
     *     // Create many LibraryUniversities
     *     const libraryUniversity = await prisma.libraryUniversity.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LibraryUniversityCreateManyArgs>(
      args?: SelectSubset<T, LibraryUniversityCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LibraryUniversity.
     * @param {LibraryUniversityDeleteArgs} args - Arguments to delete one LibraryUniversity.
     * @example
     * // Delete one LibraryUniversity
     * const LibraryUniversity = await prisma.libraryUniversity.delete({
     *   where: {
     *     // ... filter to delete one LibraryUniversity
     *   }
     * })
     * 
    **/
    delete<T extends LibraryUniversityDeleteArgs>(
      args: SelectSubset<T, LibraryUniversityDeleteArgs>
    ): Prisma__LibraryUniversityClient<LibraryUniversityGetPayload<T>>

    /**
     * Update one LibraryUniversity.
     * @param {LibraryUniversityUpdateArgs} args - Arguments to update one LibraryUniversity.
     * @example
     * // Update one LibraryUniversity
     * const libraryUniversity = await prisma.libraryUniversity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LibraryUniversityUpdateArgs>(
      args: SelectSubset<T, LibraryUniversityUpdateArgs>
    ): Prisma__LibraryUniversityClient<LibraryUniversityGetPayload<T>>

    /**
     * Delete zero or more LibraryUniversities.
     * @param {LibraryUniversityDeleteManyArgs} args - Arguments to filter LibraryUniversities to delete.
     * @example
     * // Delete a few LibraryUniversities
     * const { count } = await prisma.libraryUniversity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LibraryUniversityDeleteManyArgs>(
      args?: SelectSubset<T, LibraryUniversityDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LibraryUniversities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryUniversityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LibraryUniversities
     * const libraryUniversity = await prisma.libraryUniversity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LibraryUniversityUpdateManyArgs>(
      args: SelectSubset<T, LibraryUniversityUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LibraryUniversity.
     * @param {LibraryUniversityUpsertArgs} args - Arguments to update or create a LibraryUniversity.
     * @example
     * // Update or create a LibraryUniversity
     * const libraryUniversity = await prisma.libraryUniversity.upsert({
     *   create: {
     *     // ... data to create a LibraryUniversity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LibraryUniversity we want to update
     *   }
     * })
    **/
    upsert<T extends LibraryUniversityUpsertArgs>(
      args: SelectSubset<T, LibraryUniversityUpsertArgs>
    ): Prisma__LibraryUniversityClient<LibraryUniversityGetPayload<T>>

    /**
     * Count the number of LibraryUniversities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryUniversityCountArgs} args - Arguments to filter LibraryUniversities to count.
     * @example
     * // Count the number of LibraryUniversities
     * const count = await prisma.libraryUniversity.count({
     *   where: {
     *     // ... the filter for the LibraryUniversities we want to count
     *   }
     * })
    **/
    count<T extends LibraryUniversityCountArgs>(
      args?: Subset<T, LibraryUniversityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LibraryUniversityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LibraryUniversity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryUniversityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LibraryUniversityAggregateArgs>(args: Subset<T, LibraryUniversityAggregateArgs>): Prisma.PrismaPromise<GetLibraryUniversityAggregateType<T>>

    /**
     * Group by LibraryUniversity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryUniversityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LibraryUniversityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LibraryUniversityGroupByArgs['orderBy'] }
        : { orderBy?: LibraryUniversityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LibraryUniversityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLibraryUniversityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LibraryUniversity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LibraryUniversityClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    libraryStudenta<T extends LibraryUniversity$libraryStudentaArgs= {}>(args?: Subset<T, LibraryUniversity$libraryStudentaArgs>): Prisma.PrismaPromise<Array<LibraryStudentGetPayload<T>>| Null>;

    libraryBookCopies<T extends LibraryUniversity$libraryBookCopiesArgs= {}>(args?: Subset<T, LibraryUniversity$libraryBookCopiesArgs>): Prisma.PrismaPromise<Array<LibraryBookCopyGetPayload<T>>| Null>;

    libraryBorrowingHistories<T extends LibraryUniversity$libraryBorrowingHistoriesArgs= {}>(args?: Subset<T, LibraryUniversity$libraryBorrowingHistoriesArgs>): Prisma.PrismaPromise<Array<LibraryBorrowingHistoryGetPayload<T>>| Null>;

    fromLibraryRequests<T extends LibraryUniversity$fromLibraryRequestsArgs= {}>(args?: Subset<T, LibraryUniversity$fromLibraryRequestsArgs>): Prisma.PrismaPromise<Array<LibraryRequestGetPayload<T>>| Null>;

    toLibraryRequests<T extends LibraryUniversity$toLibraryRequestsArgs= {}>(args?: Subset<T, LibraryUniversity$toLibraryRequestsArgs>): Prisma.PrismaPromise<Array<LibraryRequestGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LibraryUniversity base type for findUnique actions
   */
  export type LibraryUniversityFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the LibraryUniversity
     */
    select?: LibraryUniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryUniversityInclude | null
    /**
     * Filter, which LibraryUniversity to fetch.
     */
    where: LibraryUniversityWhereUniqueInput
  }

  /**
   * LibraryUniversity findUnique
   */
  export interface LibraryUniversityFindUniqueArgs extends LibraryUniversityFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LibraryUniversity findUniqueOrThrow
   */
  export type LibraryUniversityFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LibraryUniversity
     */
    select?: LibraryUniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryUniversityInclude | null
    /**
     * Filter, which LibraryUniversity to fetch.
     */
    where: LibraryUniversityWhereUniqueInput
  }


  /**
   * LibraryUniversity base type for findFirst actions
   */
  export type LibraryUniversityFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the LibraryUniversity
     */
    select?: LibraryUniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryUniversityInclude | null
    /**
     * Filter, which LibraryUniversity to fetch.
     */
    where?: LibraryUniversityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryUniversities to fetch.
     */
    orderBy?: Enumerable<LibraryUniversityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryUniversities.
     */
    cursor?: LibraryUniversityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryUniversities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryUniversities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryUniversities.
     */
    distinct?: Enumerable<LibraryUniversityScalarFieldEnum>
  }

  /**
   * LibraryUniversity findFirst
   */
  export interface LibraryUniversityFindFirstArgs extends LibraryUniversityFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LibraryUniversity findFirstOrThrow
   */
  export type LibraryUniversityFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LibraryUniversity
     */
    select?: LibraryUniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryUniversityInclude | null
    /**
     * Filter, which LibraryUniversity to fetch.
     */
    where?: LibraryUniversityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryUniversities to fetch.
     */
    orderBy?: Enumerable<LibraryUniversityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryUniversities.
     */
    cursor?: LibraryUniversityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryUniversities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryUniversities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryUniversities.
     */
    distinct?: Enumerable<LibraryUniversityScalarFieldEnum>
  }


  /**
   * LibraryUniversity findMany
   */
  export type LibraryUniversityFindManyArgs = {
    /**
     * Select specific fields to fetch from the LibraryUniversity
     */
    select?: LibraryUniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryUniversityInclude | null
    /**
     * Filter, which LibraryUniversities to fetch.
     */
    where?: LibraryUniversityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryUniversities to fetch.
     */
    orderBy?: Enumerable<LibraryUniversityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LibraryUniversities.
     */
    cursor?: LibraryUniversityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryUniversities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryUniversities.
     */
    skip?: number
    distinct?: Enumerable<LibraryUniversityScalarFieldEnum>
  }


  /**
   * LibraryUniversity create
   */
  export type LibraryUniversityCreateArgs = {
    /**
     * Select specific fields to fetch from the LibraryUniversity
     */
    select?: LibraryUniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryUniversityInclude | null
    /**
     * The data needed to create a LibraryUniversity.
     */
    data: XOR<LibraryUniversityCreateInput, LibraryUniversityUncheckedCreateInput>
  }


  /**
   * LibraryUniversity createMany
   */
  export type LibraryUniversityCreateManyArgs = {
    /**
     * The data used to create many LibraryUniversities.
     */
    data: Enumerable<LibraryUniversityCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LibraryUniversity update
   */
  export type LibraryUniversityUpdateArgs = {
    /**
     * Select specific fields to fetch from the LibraryUniversity
     */
    select?: LibraryUniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryUniversityInclude | null
    /**
     * The data needed to update a LibraryUniversity.
     */
    data: XOR<LibraryUniversityUpdateInput, LibraryUniversityUncheckedUpdateInput>
    /**
     * Choose, which LibraryUniversity to update.
     */
    where: LibraryUniversityWhereUniqueInput
  }


  /**
   * LibraryUniversity updateMany
   */
  export type LibraryUniversityUpdateManyArgs = {
    /**
     * The data used to update LibraryUniversities.
     */
    data: XOR<LibraryUniversityUpdateManyMutationInput, LibraryUniversityUncheckedUpdateManyInput>
    /**
     * Filter which LibraryUniversities to update
     */
    where?: LibraryUniversityWhereInput
  }


  /**
   * LibraryUniversity upsert
   */
  export type LibraryUniversityUpsertArgs = {
    /**
     * Select specific fields to fetch from the LibraryUniversity
     */
    select?: LibraryUniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryUniversityInclude | null
    /**
     * The filter to search for the LibraryUniversity to update in case it exists.
     */
    where: LibraryUniversityWhereUniqueInput
    /**
     * In case the LibraryUniversity found by the `where` argument doesn't exist, create a new LibraryUniversity with this data.
     */
    create: XOR<LibraryUniversityCreateInput, LibraryUniversityUncheckedCreateInput>
    /**
     * In case the LibraryUniversity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LibraryUniversityUpdateInput, LibraryUniversityUncheckedUpdateInput>
  }


  /**
   * LibraryUniversity delete
   */
  export type LibraryUniversityDeleteArgs = {
    /**
     * Select specific fields to fetch from the LibraryUniversity
     */
    select?: LibraryUniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryUniversityInclude | null
    /**
     * Filter which LibraryUniversity to delete.
     */
    where: LibraryUniversityWhereUniqueInput
  }


  /**
   * LibraryUniversity deleteMany
   */
  export type LibraryUniversityDeleteManyArgs = {
    /**
     * Filter which LibraryUniversities to delete
     */
    where?: LibraryUniversityWhereInput
  }


  /**
   * LibraryUniversity.libraryStudenta
   */
  export type LibraryUniversity$libraryStudentaArgs = {
    /**
     * Select specific fields to fetch from the LibraryStudent
     */
    select?: LibraryStudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryStudentInclude | null
    where?: LibraryStudentWhereInput
    orderBy?: Enumerable<LibraryStudentOrderByWithRelationInput>
    cursor?: LibraryStudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LibraryStudentScalarFieldEnum>
  }


  /**
   * LibraryUniversity.libraryBookCopies
   */
  export type LibraryUniversity$libraryBookCopiesArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookCopy
     */
    select?: LibraryBookCopySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCopyInclude | null
    where?: LibraryBookCopyWhereInput
    orderBy?: Enumerable<LibraryBookCopyOrderByWithRelationInput>
    cursor?: LibraryBookCopyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LibraryBookCopyScalarFieldEnum>
  }


  /**
   * LibraryUniversity.libraryBorrowingHistories
   */
  export type LibraryUniversity$libraryBorrowingHistoriesArgs = {
    /**
     * Select specific fields to fetch from the LibraryBorrowingHistory
     */
    select?: LibraryBorrowingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBorrowingHistoryInclude | null
    where?: LibraryBorrowingHistoryWhereInput
    orderBy?: Enumerable<LibraryBorrowingHistoryOrderByWithRelationInput>
    cursor?: LibraryBorrowingHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LibraryBorrowingHistoryScalarFieldEnum>
  }


  /**
   * LibraryUniversity.fromLibraryRequests
   */
  export type LibraryUniversity$fromLibraryRequestsArgs = {
    /**
     * Select specific fields to fetch from the LibraryRequest
     */
    select?: LibraryRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryRequestInclude | null
    where?: LibraryRequestWhereInput
    orderBy?: Enumerable<LibraryRequestOrderByWithRelationInput>
    cursor?: LibraryRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LibraryRequestScalarFieldEnum>
  }


  /**
   * LibraryUniversity.toLibraryRequests
   */
  export type LibraryUniversity$toLibraryRequestsArgs = {
    /**
     * Select specific fields to fetch from the LibraryRequest
     */
    select?: LibraryRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryRequestInclude | null
    where?: LibraryRequestWhereInput
    orderBy?: Enumerable<LibraryRequestOrderByWithRelationInput>
    cursor?: LibraryRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LibraryRequestScalarFieldEnum>
  }


  /**
   * LibraryUniversity without action
   */
  export type LibraryUniversityArgs = {
    /**
     * Select specific fields to fetch from the LibraryUniversity
     */
    select?: LibraryUniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryUniversityInclude | null
  }



  /**
   * Model LibraryStudent
   */


  export type AggregateLibraryStudent = {
    _count: LibraryStudentCountAggregateOutputType | null
    _avg: LibraryStudentAvgAggregateOutputType | null
    _sum: LibraryStudentSumAggregateOutputType | null
    _min: LibraryStudentMinAggregateOutputType | null
    _max: LibraryStudentMaxAggregateOutputType | null
  }

  export type LibraryStudentAvgAggregateOutputType = {
    id: number | null
    studentId: number | null
    libraryUniversityId: number | null
  }

  export type LibraryStudentSumAggregateOutputType = {
    id: number | null
    studentId: number | null
    libraryUniversityId: number | null
  }

  export type LibraryStudentMinAggregateOutputType = {
    id: number | null
    studentId: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    libraryUniversityId: number | null
  }

  export type LibraryStudentMaxAggregateOutputType = {
    id: number | null
    studentId: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    libraryUniversityId: number | null
  }

  export type LibraryStudentCountAggregateOutputType = {
    id: number
    studentId: number
    name: number
    createdAt: number
    updatedAt: number
    libraryUniversityId: number
    _all: number
  }


  export type LibraryStudentAvgAggregateInputType = {
    id?: true
    studentId?: true
    libraryUniversityId?: true
  }

  export type LibraryStudentSumAggregateInputType = {
    id?: true
    studentId?: true
    libraryUniversityId?: true
  }

  export type LibraryStudentMinAggregateInputType = {
    id?: true
    studentId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    libraryUniversityId?: true
  }

  export type LibraryStudentMaxAggregateInputType = {
    id?: true
    studentId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    libraryUniversityId?: true
  }

  export type LibraryStudentCountAggregateInputType = {
    id?: true
    studentId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    libraryUniversityId?: true
    _all?: true
  }

  export type LibraryStudentAggregateArgs = {
    /**
     * Filter which LibraryStudent to aggregate.
     */
    where?: LibraryStudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryStudents to fetch.
     */
    orderBy?: Enumerable<LibraryStudentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LibraryStudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryStudents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LibraryStudents
    **/
    _count?: true | LibraryStudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LibraryStudentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LibraryStudentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LibraryStudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LibraryStudentMaxAggregateInputType
  }

  export type GetLibraryStudentAggregateType<T extends LibraryStudentAggregateArgs> = {
        [P in keyof T & keyof AggregateLibraryStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLibraryStudent[P]>
      : GetScalarType<T[P], AggregateLibraryStudent[P]>
  }




  export type LibraryStudentGroupByArgs = {
    where?: LibraryStudentWhereInput
    orderBy?: Enumerable<LibraryStudentOrderByWithAggregationInput>
    by: LibraryStudentScalarFieldEnum[]
    having?: LibraryStudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LibraryStudentCountAggregateInputType | true
    _avg?: LibraryStudentAvgAggregateInputType
    _sum?: LibraryStudentSumAggregateInputType
    _min?: LibraryStudentMinAggregateInputType
    _max?: LibraryStudentMaxAggregateInputType
  }


  export type LibraryStudentGroupByOutputType = {
    id: number
    studentId: number
    name: string
    createdAt: Date
    updatedAt: Date
    libraryUniversityId: number
    _count: LibraryStudentCountAggregateOutputType | null
    _avg: LibraryStudentAvgAggregateOutputType | null
    _sum: LibraryStudentSumAggregateOutputType | null
    _min: LibraryStudentMinAggregateOutputType | null
    _max: LibraryStudentMaxAggregateOutputType | null
  }

  type GetLibraryStudentGroupByPayload<T extends LibraryStudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LibraryStudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LibraryStudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LibraryStudentGroupByOutputType[P]>
            : GetScalarType<T[P], LibraryStudentGroupByOutputType[P]>
        }
      >
    >


  export type LibraryStudentSelect = {
    id?: boolean
    studentId?: boolean
    name?: boolean
    university?: boolean | LibraryUniversityArgs
    createdAt?: boolean
    updatedAt?: boolean
    libraryUniversityId?: boolean
    libraryBookCopies?: boolean | LibraryStudent$libraryBookCopiesArgs
    libraryBorrowingHistories?: boolean | LibraryStudent$libraryBorrowingHistoriesArgs
    libraryRequests?: boolean | LibraryStudent$libraryRequestsArgs
    _count?: boolean | LibraryStudentCountOutputTypeArgs
  }


  export type LibraryStudentInclude = {
    university?: boolean | LibraryUniversityArgs
    libraryBookCopies?: boolean | LibraryStudent$libraryBookCopiesArgs
    libraryBorrowingHistories?: boolean | LibraryStudent$libraryBorrowingHistoriesArgs
    libraryRequests?: boolean | LibraryStudent$libraryRequestsArgs
    _count?: boolean | LibraryStudentCountOutputTypeArgs
  }

  export type LibraryStudentGetPayload<S extends boolean | null | undefined | LibraryStudentArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LibraryStudent :
    S extends undefined ? never :
    S extends { include: any } & (LibraryStudentArgs | LibraryStudentFindManyArgs)
    ? LibraryStudent  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'university' ? LibraryUniversityGetPayload<S['include'][P]> :
        P extends 'libraryBookCopies' ? Array < LibraryBookCopyGetPayload<S['include'][P]>>  :
        P extends 'libraryBorrowingHistories' ? Array < LibraryBorrowingHistoryGetPayload<S['include'][P]>>  :
        P extends 'libraryRequests' ? Array < LibraryRequestGetPayload<S['include'][P]>>  :
        P extends '_count' ? LibraryStudentCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (LibraryStudentArgs | LibraryStudentFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'university' ? LibraryUniversityGetPayload<S['select'][P]> :
        P extends 'libraryBookCopies' ? Array < LibraryBookCopyGetPayload<S['select'][P]>>  :
        P extends 'libraryBorrowingHistories' ? Array < LibraryBorrowingHistoryGetPayload<S['select'][P]>>  :
        P extends 'libraryRequests' ? Array < LibraryRequestGetPayload<S['select'][P]>>  :
        P extends '_count' ? LibraryStudentCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof LibraryStudent ? LibraryStudent[P] : never
  } 
      : LibraryStudent


  type LibraryStudentCountArgs = 
    Omit<LibraryStudentFindManyArgs, 'select' | 'include'> & {
      select?: LibraryStudentCountAggregateInputType | true
    }

  export interface LibraryStudentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one LibraryStudent that matches the filter.
     * @param {LibraryStudentFindUniqueArgs} args - Arguments to find a LibraryStudent
     * @example
     * // Get one LibraryStudent
     * const libraryStudent = await prisma.libraryStudent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LibraryStudentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LibraryStudentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LibraryStudent'> extends True ? Prisma__LibraryStudentClient<LibraryStudentGetPayload<T>> : Prisma__LibraryStudentClient<LibraryStudentGetPayload<T> | null, null>

    /**
     * Find one LibraryStudent that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LibraryStudentFindUniqueOrThrowArgs} args - Arguments to find a LibraryStudent
     * @example
     * // Get one LibraryStudent
     * const libraryStudent = await prisma.libraryStudent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LibraryStudentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LibraryStudentFindUniqueOrThrowArgs>
    ): Prisma__LibraryStudentClient<LibraryStudentGetPayload<T>>

    /**
     * Find the first LibraryStudent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryStudentFindFirstArgs} args - Arguments to find a LibraryStudent
     * @example
     * // Get one LibraryStudent
     * const libraryStudent = await prisma.libraryStudent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LibraryStudentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LibraryStudentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LibraryStudent'> extends True ? Prisma__LibraryStudentClient<LibraryStudentGetPayload<T>> : Prisma__LibraryStudentClient<LibraryStudentGetPayload<T> | null, null>

    /**
     * Find the first LibraryStudent that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryStudentFindFirstOrThrowArgs} args - Arguments to find a LibraryStudent
     * @example
     * // Get one LibraryStudent
     * const libraryStudent = await prisma.libraryStudent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LibraryStudentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LibraryStudentFindFirstOrThrowArgs>
    ): Prisma__LibraryStudentClient<LibraryStudentGetPayload<T>>

    /**
     * Find zero or more LibraryStudents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryStudentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LibraryStudents
     * const libraryStudents = await prisma.libraryStudent.findMany()
     * 
     * // Get first 10 LibraryStudents
     * const libraryStudents = await prisma.libraryStudent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const libraryStudentWithIdOnly = await prisma.libraryStudent.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LibraryStudentFindManyArgs>(
      args?: SelectSubset<T, LibraryStudentFindManyArgs>
    ): Prisma.PrismaPromise<Array<LibraryStudentGetPayload<T>>>

    /**
     * Create a LibraryStudent.
     * @param {LibraryStudentCreateArgs} args - Arguments to create a LibraryStudent.
     * @example
     * // Create one LibraryStudent
     * const LibraryStudent = await prisma.libraryStudent.create({
     *   data: {
     *     // ... data to create a LibraryStudent
     *   }
     * })
     * 
    **/
    create<T extends LibraryStudentCreateArgs>(
      args: SelectSubset<T, LibraryStudentCreateArgs>
    ): Prisma__LibraryStudentClient<LibraryStudentGetPayload<T>>

    /**
     * Create many LibraryStudents.
     *     @param {LibraryStudentCreateManyArgs} args - Arguments to create many LibraryStudents.
     *     @example
     *     // Create many LibraryStudents
     *     const libraryStudent = await prisma.libraryStudent.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LibraryStudentCreateManyArgs>(
      args?: SelectSubset<T, LibraryStudentCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LibraryStudent.
     * @param {LibraryStudentDeleteArgs} args - Arguments to delete one LibraryStudent.
     * @example
     * // Delete one LibraryStudent
     * const LibraryStudent = await prisma.libraryStudent.delete({
     *   where: {
     *     // ... filter to delete one LibraryStudent
     *   }
     * })
     * 
    **/
    delete<T extends LibraryStudentDeleteArgs>(
      args: SelectSubset<T, LibraryStudentDeleteArgs>
    ): Prisma__LibraryStudentClient<LibraryStudentGetPayload<T>>

    /**
     * Update one LibraryStudent.
     * @param {LibraryStudentUpdateArgs} args - Arguments to update one LibraryStudent.
     * @example
     * // Update one LibraryStudent
     * const libraryStudent = await prisma.libraryStudent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LibraryStudentUpdateArgs>(
      args: SelectSubset<T, LibraryStudentUpdateArgs>
    ): Prisma__LibraryStudentClient<LibraryStudentGetPayload<T>>

    /**
     * Delete zero or more LibraryStudents.
     * @param {LibraryStudentDeleteManyArgs} args - Arguments to filter LibraryStudents to delete.
     * @example
     * // Delete a few LibraryStudents
     * const { count } = await prisma.libraryStudent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LibraryStudentDeleteManyArgs>(
      args?: SelectSubset<T, LibraryStudentDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LibraryStudents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryStudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LibraryStudents
     * const libraryStudent = await prisma.libraryStudent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LibraryStudentUpdateManyArgs>(
      args: SelectSubset<T, LibraryStudentUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LibraryStudent.
     * @param {LibraryStudentUpsertArgs} args - Arguments to update or create a LibraryStudent.
     * @example
     * // Update or create a LibraryStudent
     * const libraryStudent = await prisma.libraryStudent.upsert({
     *   create: {
     *     // ... data to create a LibraryStudent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LibraryStudent we want to update
     *   }
     * })
    **/
    upsert<T extends LibraryStudentUpsertArgs>(
      args: SelectSubset<T, LibraryStudentUpsertArgs>
    ): Prisma__LibraryStudentClient<LibraryStudentGetPayload<T>>

    /**
     * Count the number of LibraryStudents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryStudentCountArgs} args - Arguments to filter LibraryStudents to count.
     * @example
     * // Count the number of LibraryStudents
     * const count = await prisma.libraryStudent.count({
     *   where: {
     *     // ... the filter for the LibraryStudents we want to count
     *   }
     * })
    **/
    count<T extends LibraryStudentCountArgs>(
      args?: Subset<T, LibraryStudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LibraryStudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LibraryStudent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryStudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LibraryStudentAggregateArgs>(args: Subset<T, LibraryStudentAggregateArgs>): Prisma.PrismaPromise<GetLibraryStudentAggregateType<T>>

    /**
     * Group by LibraryStudent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryStudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LibraryStudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LibraryStudentGroupByArgs['orderBy'] }
        : { orderBy?: LibraryStudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LibraryStudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLibraryStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LibraryStudent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LibraryStudentClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    university<T extends LibraryUniversityArgs= {}>(args?: Subset<T, LibraryUniversityArgs>): Prisma__LibraryUniversityClient<LibraryUniversityGetPayload<T> | Null>;

    libraryBookCopies<T extends LibraryStudent$libraryBookCopiesArgs= {}>(args?: Subset<T, LibraryStudent$libraryBookCopiesArgs>): Prisma.PrismaPromise<Array<LibraryBookCopyGetPayload<T>>| Null>;

    libraryBorrowingHistories<T extends LibraryStudent$libraryBorrowingHistoriesArgs= {}>(args?: Subset<T, LibraryStudent$libraryBorrowingHistoriesArgs>): Prisma.PrismaPromise<Array<LibraryBorrowingHistoryGetPayload<T>>| Null>;

    libraryRequests<T extends LibraryStudent$libraryRequestsArgs= {}>(args?: Subset<T, LibraryStudent$libraryRequestsArgs>): Prisma.PrismaPromise<Array<LibraryRequestGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LibraryStudent base type for findUnique actions
   */
  export type LibraryStudentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the LibraryStudent
     */
    select?: LibraryStudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryStudentInclude | null
    /**
     * Filter, which LibraryStudent to fetch.
     */
    where: LibraryStudentWhereUniqueInput
  }

  /**
   * LibraryStudent findUnique
   */
  export interface LibraryStudentFindUniqueArgs extends LibraryStudentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LibraryStudent findUniqueOrThrow
   */
  export type LibraryStudentFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LibraryStudent
     */
    select?: LibraryStudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryStudentInclude | null
    /**
     * Filter, which LibraryStudent to fetch.
     */
    where: LibraryStudentWhereUniqueInput
  }


  /**
   * LibraryStudent base type for findFirst actions
   */
  export type LibraryStudentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the LibraryStudent
     */
    select?: LibraryStudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryStudentInclude | null
    /**
     * Filter, which LibraryStudent to fetch.
     */
    where?: LibraryStudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryStudents to fetch.
     */
    orderBy?: Enumerable<LibraryStudentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryStudents.
     */
    cursor?: LibraryStudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryStudents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryStudents.
     */
    distinct?: Enumerable<LibraryStudentScalarFieldEnum>
  }

  /**
   * LibraryStudent findFirst
   */
  export interface LibraryStudentFindFirstArgs extends LibraryStudentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LibraryStudent findFirstOrThrow
   */
  export type LibraryStudentFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LibraryStudent
     */
    select?: LibraryStudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryStudentInclude | null
    /**
     * Filter, which LibraryStudent to fetch.
     */
    where?: LibraryStudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryStudents to fetch.
     */
    orderBy?: Enumerable<LibraryStudentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryStudents.
     */
    cursor?: LibraryStudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryStudents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryStudents.
     */
    distinct?: Enumerable<LibraryStudentScalarFieldEnum>
  }


  /**
   * LibraryStudent findMany
   */
  export type LibraryStudentFindManyArgs = {
    /**
     * Select specific fields to fetch from the LibraryStudent
     */
    select?: LibraryStudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryStudentInclude | null
    /**
     * Filter, which LibraryStudents to fetch.
     */
    where?: LibraryStudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryStudents to fetch.
     */
    orderBy?: Enumerable<LibraryStudentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LibraryStudents.
     */
    cursor?: LibraryStudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryStudents.
     */
    skip?: number
    distinct?: Enumerable<LibraryStudentScalarFieldEnum>
  }


  /**
   * LibraryStudent create
   */
  export type LibraryStudentCreateArgs = {
    /**
     * Select specific fields to fetch from the LibraryStudent
     */
    select?: LibraryStudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryStudentInclude | null
    /**
     * The data needed to create a LibraryStudent.
     */
    data: XOR<LibraryStudentCreateInput, LibraryStudentUncheckedCreateInput>
  }


  /**
   * LibraryStudent createMany
   */
  export type LibraryStudentCreateManyArgs = {
    /**
     * The data used to create many LibraryStudents.
     */
    data: Enumerable<LibraryStudentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LibraryStudent update
   */
  export type LibraryStudentUpdateArgs = {
    /**
     * Select specific fields to fetch from the LibraryStudent
     */
    select?: LibraryStudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryStudentInclude | null
    /**
     * The data needed to update a LibraryStudent.
     */
    data: XOR<LibraryStudentUpdateInput, LibraryStudentUncheckedUpdateInput>
    /**
     * Choose, which LibraryStudent to update.
     */
    where: LibraryStudentWhereUniqueInput
  }


  /**
   * LibraryStudent updateMany
   */
  export type LibraryStudentUpdateManyArgs = {
    /**
     * The data used to update LibraryStudents.
     */
    data: XOR<LibraryStudentUpdateManyMutationInput, LibraryStudentUncheckedUpdateManyInput>
    /**
     * Filter which LibraryStudents to update
     */
    where?: LibraryStudentWhereInput
  }


  /**
   * LibraryStudent upsert
   */
  export type LibraryStudentUpsertArgs = {
    /**
     * Select specific fields to fetch from the LibraryStudent
     */
    select?: LibraryStudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryStudentInclude | null
    /**
     * The filter to search for the LibraryStudent to update in case it exists.
     */
    where: LibraryStudentWhereUniqueInput
    /**
     * In case the LibraryStudent found by the `where` argument doesn't exist, create a new LibraryStudent with this data.
     */
    create: XOR<LibraryStudentCreateInput, LibraryStudentUncheckedCreateInput>
    /**
     * In case the LibraryStudent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LibraryStudentUpdateInput, LibraryStudentUncheckedUpdateInput>
  }


  /**
   * LibraryStudent delete
   */
  export type LibraryStudentDeleteArgs = {
    /**
     * Select specific fields to fetch from the LibraryStudent
     */
    select?: LibraryStudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryStudentInclude | null
    /**
     * Filter which LibraryStudent to delete.
     */
    where: LibraryStudentWhereUniqueInput
  }


  /**
   * LibraryStudent deleteMany
   */
  export type LibraryStudentDeleteManyArgs = {
    /**
     * Filter which LibraryStudents to delete
     */
    where?: LibraryStudentWhereInput
  }


  /**
   * LibraryStudent.libraryBookCopies
   */
  export type LibraryStudent$libraryBookCopiesArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookCopy
     */
    select?: LibraryBookCopySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCopyInclude | null
    where?: LibraryBookCopyWhereInput
    orderBy?: Enumerable<LibraryBookCopyOrderByWithRelationInput>
    cursor?: LibraryBookCopyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LibraryBookCopyScalarFieldEnum>
  }


  /**
   * LibraryStudent.libraryBorrowingHistories
   */
  export type LibraryStudent$libraryBorrowingHistoriesArgs = {
    /**
     * Select specific fields to fetch from the LibraryBorrowingHistory
     */
    select?: LibraryBorrowingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBorrowingHistoryInclude | null
    where?: LibraryBorrowingHistoryWhereInput
    orderBy?: Enumerable<LibraryBorrowingHistoryOrderByWithRelationInput>
    cursor?: LibraryBorrowingHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LibraryBorrowingHistoryScalarFieldEnum>
  }


  /**
   * LibraryStudent.libraryRequests
   */
  export type LibraryStudent$libraryRequestsArgs = {
    /**
     * Select specific fields to fetch from the LibraryRequest
     */
    select?: LibraryRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryRequestInclude | null
    where?: LibraryRequestWhereInput
    orderBy?: Enumerable<LibraryRequestOrderByWithRelationInput>
    cursor?: LibraryRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LibraryRequestScalarFieldEnum>
  }


  /**
   * LibraryStudent without action
   */
  export type LibraryStudentArgs = {
    /**
     * Select specific fields to fetch from the LibraryStudent
     */
    select?: LibraryStudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryStudentInclude | null
  }



  /**
   * Model LibraryBookCopy
   */


  export type AggregateLibraryBookCopy = {
    _count: LibraryBookCopyCountAggregateOutputType | null
    _avg: LibraryBookCopyAvgAggregateOutputType | null
    _sum: LibraryBookCopySumAggregateOutputType | null
    _min: LibraryBookCopyMinAggregateOutputType | null
    _max: LibraryBookCopyMaxAggregateOutputType | null
  }

  export type LibraryBookCopyAvgAggregateOutputType = {
    id: number | null
    libraryBookId: number | null
    libraryUniversityId: number | null
    libraryStudentId: number | null
  }

  export type LibraryBookCopySumAggregateOutputType = {
    id: number | null
    libraryBookId: number | null
    libraryUniversityId: number | null
    libraryStudentId: number | null
  }

  export type LibraryBookCopyMinAggregateOutputType = {
    id: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    libraryBookId: number | null
    libraryUniversityId: number | null
    libraryStudentId: number | null
  }

  export type LibraryBookCopyMaxAggregateOutputType = {
    id: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    libraryBookId: number | null
    libraryUniversityId: number | null
    libraryStudentId: number | null
  }

  export type LibraryBookCopyCountAggregateOutputType = {
    id: number
    status: number
    createdAt: number
    updatedAt: number
    libraryBookId: number
    libraryUniversityId: number
    libraryStudentId: number
    _all: number
  }


  export type LibraryBookCopyAvgAggregateInputType = {
    id?: true
    libraryBookId?: true
    libraryUniversityId?: true
    libraryStudentId?: true
  }

  export type LibraryBookCopySumAggregateInputType = {
    id?: true
    libraryBookId?: true
    libraryUniversityId?: true
    libraryStudentId?: true
  }

  export type LibraryBookCopyMinAggregateInputType = {
    id?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    libraryBookId?: true
    libraryUniversityId?: true
    libraryStudentId?: true
  }

  export type LibraryBookCopyMaxAggregateInputType = {
    id?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    libraryBookId?: true
    libraryUniversityId?: true
    libraryStudentId?: true
  }

  export type LibraryBookCopyCountAggregateInputType = {
    id?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    libraryBookId?: true
    libraryUniversityId?: true
    libraryStudentId?: true
    _all?: true
  }

  export type LibraryBookCopyAggregateArgs = {
    /**
     * Filter which LibraryBookCopy to aggregate.
     */
    where?: LibraryBookCopyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBookCopies to fetch.
     */
    orderBy?: Enumerable<LibraryBookCopyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LibraryBookCopyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBookCopies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBookCopies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LibraryBookCopies
    **/
    _count?: true | LibraryBookCopyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LibraryBookCopyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LibraryBookCopySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LibraryBookCopyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LibraryBookCopyMaxAggregateInputType
  }

  export type GetLibraryBookCopyAggregateType<T extends LibraryBookCopyAggregateArgs> = {
        [P in keyof T & keyof AggregateLibraryBookCopy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLibraryBookCopy[P]>
      : GetScalarType<T[P], AggregateLibraryBookCopy[P]>
  }




  export type LibraryBookCopyGroupByArgs = {
    where?: LibraryBookCopyWhereInput
    orderBy?: Enumerable<LibraryBookCopyOrderByWithAggregationInput>
    by: LibraryBookCopyScalarFieldEnum[]
    having?: LibraryBookCopyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LibraryBookCopyCountAggregateInputType | true
    _avg?: LibraryBookCopyAvgAggregateInputType
    _sum?: LibraryBookCopySumAggregateInputType
    _min?: LibraryBookCopyMinAggregateInputType
    _max?: LibraryBookCopyMaxAggregateInputType
  }


  export type LibraryBookCopyGroupByOutputType = {
    id: number
    status: string
    createdAt: Date
    updatedAt: Date
    libraryBookId: number
    libraryUniversityId: number
    libraryStudentId: number
    _count: LibraryBookCopyCountAggregateOutputType | null
    _avg: LibraryBookCopyAvgAggregateOutputType | null
    _sum: LibraryBookCopySumAggregateOutputType | null
    _min: LibraryBookCopyMinAggregateOutputType | null
    _max: LibraryBookCopyMaxAggregateOutputType | null
  }

  type GetLibraryBookCopyGroupByPayload<T extends LibraryBookCopyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LibraryBookCopyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LibraryBookCopyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LibraryBookCopyGroupByOutputType[P]>
            : GetScalarType<T[P], LibraryBookCopyGroupByOutputType[P]>
        }
      >
    >


  export type LibraryBookCopySelect = {
    id?: boolean
    book?: boolean | LibraryBookArgs
    status?: boolean
    university?: boolean | LibraryUniversityArgs
    borrowedBy?: boolean | LibraryStudentArgs
    createdAt?: boolean
    updatedAt?: boolean
    libraryBookId?: boolean
    libraryUniversityId?: boolean
    libraryStudentId?: boolean
    libraryBorrowingHistories?: boolean | LibraryBookCopy$libraryBorrowingHistoriesArgs
    libraryRequests?: boolean | LibraryBookCopy$libraryRequestsArgs
    _count?: boolean | LibraryBookCopyCountOutputTypeArgs
  }


  export type LibraryBookCopyInclude = {
    book?: boolean | LibraryBookArgs
    university?: boolean | LibraryUniversityArgs
    borrowedBy?: boolean | LibraryStudentArgs
    libraryBorrowingHistories?: boolean | LibraryBookCopy$libraryBorrowingHistoriesArgs
    libraryRequests?: boolean | LibraryBookCopy$libraryRequestsArgs
    _count?: boolean | LibraryBookCopyCountOutputTypeArgs
  }

  export type LibraryBookCopyGetPayload<S extends boolean | null | undefined | LibraryBookCopyArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LibraryBookCopy :
    S extends undefined ? never :
    S extends { include: any } & (LibraryBookCopyArgs | LibraryBookCopyFindManyArgs)
    ? LibraryBookCopy  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'book' ? LibraryBookGetPayload<S['include'][P]> :
        P extends 'university' ? LibraryUniversityGetPayload<S['include'][P]> :
        P extends 'borrowedBy' ? LibraryStudentGetPayload<S['include'][P]> :
        P extends 'libraryBorrowingHistories' ? Array < LibraryBorrowingHistoryGetPayload<S['include'][P]>>  :
        P extends 'libraryRequests' ? Array < LibraryRequestGetPayload<S['include'][P]>>  :
        P extends '_count' ? LibraryBookCopyCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (LibraryBookCopyArgs | LibraryBookCopyFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'book' ? LibraryBookGetPayload<S['select'][P]> :
        P extends 'university' ? LibraryUniversityGetPayload<S['select'][P]> :
        P extends 'borrowedBy' ? LibraryStudentGetPayload<S['select'][P]> :
        P extends 'libraryBorrowingHistories' ? Array < LibraryBorrowingHistoryGetPayload<S['select'][P]>>  :
        P extends 'libraryRequests' ? Array < LibraryRequestGetPayload<S['select'][P]>>  :
        P extends '_count' ? LibraryBookCopyCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof LibraryBookCopy ? LibraryBookCopy[P] : never
  } 
      : LibraryBookCopy


  type LibraryBookCopyCountArgs = 
    Omit<LibraryBookCopyFindManyArgs, 'select' | 'include'> & {
      select?: LibraryBookCopyCountAggregateInputType | true
    }

  export interface LibraryBookCopyDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one LibraryBookCopy that matches the filter.
     * @param {LibraryBookCopyFindUniqueArgs} args - Arguments to find a LibraryBookCopy
     * @example
     * // Get one LibraryBookCopy
     * const libraryBookCopy = await prisma.libraryBookCopy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LibraryBookCopyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LibraryBookCopyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LibraryBookCopy'> extends True ? Prisma__LibraryBookCopyClient<LibraryBookCopyGetPayload<T>> : Prisma__LibraryBookCopyClient<LibraryBookCopyGetPayload<T> | null, null>

    /**
     * Find one LibraryBookCopy that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LibraryBookCopyFindUniqueOrThrowArgs} args - Arguments to find a LibraryBookCopy
     * @example
     * // Get one LibraryBookCopy
     * const libraryBookCopy = await prisma.libraryBookCopy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LibraryBookCopyFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LibraryBookCopyFindUniqueOrThrowArgs>
    ): Prisma__LibraryBookCopyClient<LibraryBookCopyGetPayload<T>>

    /**
     * Find the first LibraryBookCopy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookCopyFindFirstArgs} args - Arguments to find a LibraryBookCopy
     * @example
     * // Get one LibraryBookCopy
     * const libraryBookCopy = await prisma.libraryBookCopy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LibraryBookCopyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LibraryBookCopyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LibraryBookCopy'> extends True ? Prisma__LibraryBookCopyClient<LibraryBookCopyGetPayload<T>> : Prisma__LibraryBookCopyClient<LibraryBookCopyGetPayload<T> | null, null>

    /**
     * Find the first LibraryBookCopy that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookCopyFindFirstOrThrowArgs} args - Arguments to find a LibraryBookCopy
     * @example
     * // Get one LibraryBookCopy
     * const libraryBookCopy = await prisma.libraryBookCopy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LibraryBookCopyFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LibraryBookCopyFindFirstOrThrowArgs>
    ): Prisma__LibraryBookCopyClient<LibraryBookCopyGetPayload<T>>

    /**
     * Find zero or more LibraryBookCopies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookCopyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LibraryBookCopies
     * const libraryBookCopies = await prisma.libraryBookCopy.findMany()
     * 
     * // Get first 10 LibraryBookCopies
     * const libraryBookCopies = await prisma.libraryBookCopy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const libraryBookCopyWithIdOnly = await prisma.libraryBookCopy.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LibraryBookCopyFindManyArgs>(
      args?: SelectSubset<T, LibraryBookCopyFindManyArgs>
    ): Prisma.PrismaPromise<Array<LibraryBookCopyGetPayload<T>>>

    /**
     * Create a LibraryBookCopy.
     * @param {LibraryBookCopyCreateArgs} args - Arguments to create a LibraryBookCopy.
     * @example
     * // Create one LibraryBookCopy
     * const LibraryBookCopy = await prisma.libraryBookCopy.create({
     *   data: {
     *     // ... data to create a LibraryBookCopy
     *   }
     * })
     * 
    **/
    create<T extends LibraryBookCopyCreateArgs>(
      args: SelectSubset<T, LibraryBookCopyCreateArgs>
    ): Prisma__LibraryBookCopyClient<LibraryBookCopyGetPayload<T>>

    /**
     * Create many LibraryBookCopies.
     *     @param {LibraryBookCopyCreateManyArgs} args - Arguments to create many LibraryBookCopies.
     *     @example
     *     // Create many LibraryBookCopies
     *     const libraryBookCopy = await prisma.libraryBookCopy.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LibraryBookCopyCreateManyArgs>(
      args?: SelectSubset<T, LibraryBookCopyCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LibraryBookCopy.
     * @param {LibraryBookCopyDeleteArgs} args - Arguments to delete one LibraryBookCopy.
     * @example
     * // Delete one LibraryBookCopy
     * const LibraryBookCopy = await prisma.libraryBookCopy.delete({
     *   where: {
     *     // ... filter to delete one LibraryBookCopy
     *   }
     * })
     * 
    **/
    delete<T extends LibraryBookCopyDeleteArgs>(
      args: SelectSubset<T, LibraryBookCopyDeleteArgs>
    ): Prisma__LibraryBookCopyClient<LibraryBookCopyGetPayload<T>>

    /**
     * Update one LibraryBookCopy.
     * @param {LibraryBookCopyUpdateArgs} args - Arguments to update one LibraryBookCopy.
     * @example
     * // Update one LibraryBookCopy
     * const libraryBookCopy = await prisma.libraryBookCopy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LibraryBookCopyUpdateArgs>(
      args: SelectSubset<T, LibraryBookCopyUpdateArgs>
    ): Prisma__LibraryBookCopyClient<LibraryBookCopyGetPayload<T>>

    /**
     * Delete zero or more LibraryBookCopies.
     * @param {LibraryBookCopyDeleteManyArgs} args - Arguments to filter LibraryBookCopies to delete.
     * @example
     * // Delete a few LibraryBookCopies
     * const { count } = await prisma.libraryBookCopy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LibraryBookCopyDeleteManyArgs>(
      args?: SelectSubset<T, LibraryBookCopyDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LibraryBookCopies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookCopyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LibraryBookCopies
     * const libraryBookCopy = await prisma.libraryBookCopy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LibraryBookCopyUpdateManyArgs>(
      args: SelectSubset<T, LibraryBookCopyUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LibraryBookCopy.
     * @param {LibraryBookCopyUpsertArgs} args - Arguments to update or create a LibraryBookCopy.
     * @example
     * // Update or create a LibraryBookCopy
     * const libraryBookCopy = await prisma.libraryBookCopy.upsert({
     *   create: {
     *     // ... data to create a LibraryBookCopy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LibraryBookCopy we want to update
     *   }
     * })
    **/
    upsert<T extends LibraryBookCopyUpsertArgs>(
      args: SelectSubset<T, LibraryBookCopyUpsertArgs>
    ): Prisma__LibraryBookCopyClient<LibraryBookCopyGetPayload<T>>

    /**
     * Count the number of LibraryBookCopies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookCopyCountArgs} args - Arguments to filter LibraryBookCopies to count.
     * @example
     * // Count the number of LibraryBookCopies
     * const count = await prisma.libraryBookCopy.count({
     *   where: {
     *     // ... the filter for the LibraryBookCopies we want to count
     *   }
     * })
    **/
    count<T extends LibraryBookCopyCountArgs>(
      args?: Subset<T, LibraryBookCopyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LibraryBookCopyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LibraryBookCopy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookCopyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LibraryBookCopyAggregateArgs>(args: Subset<T, LibraryBookCopyAggregateArgs>): Prisma.PrismaPromise<GetLibraryBookCopyAggregateType<T>>

    /**
     * Group by LibraryBookCopy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookCopyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LibraryBookCopyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LibraryBookCopyGroupByArgs['orderBy'] }
        : { orderBy?: LibraryBookCopyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LibraryBookCopyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLibraryBookCopyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LibraryBookCopy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LibraryBookCopyClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    book<T extends LibraryBookArgs= {}>(args?: Subset<T, LibraryBookArgs>): Prisma__LibraryBookClient<LibraryBookGetPayload<T> | Null>;

    university<T extends LibraryUniversityArgs= {}>(args?: Subset<T, LibraryUniversityArgs>): Prisma__LibraryUniversityClient<LibraryUniversityGetPayload<T> | Null>;

    borrowedBy<T extends LibraryStudentArgs= {}>(args?: Subset<T, LibraryStudentArgs>): Prisma__LibraryStudentClient<LibraryStudentGetPayload<T> | Null>;

    libraryBorrowingHistories<T extends LibraryBookCopy$libraryBorrowingHistoriesArgs= {}>(args?: Subset<T, LibraryBookCopy$libraryBorrowingHistoriesArgs>): Prisma.PrismaPromise<Array<LibraryBorrowingHistoryGetPayload<T>>| Null>;

    libraryRequests<T extends LibraryBookCopy$libraryRequestsArgs= {}>(args?: Subset<T, LibraryBookCopy$libraryRequestsArgs>): Prisma.PrismaPromise<Array<LibraryRequestGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LibraryBookCopy base type for findUnique actions
   */
  export type LibraryBookCopyFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the LibraryBookCopy
     */
    select?: LibraryBookCopySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCopyInclude | null
    /**
     * Filter, which LibraryBookCopy to fetch.
     */
    where: LibraryBookCopyWhereUniqueInput
  }

  /**
   * LibraryBookCopy findUnique
   */
  export interface LibraryBookCopyFindUniqueArgs extends LibraryBookCopyFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LibraryBookCopy findUniqueOrThrow
   */
  export type LibraryBookCopyFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookCopy
     */
    select?: LibraryBookCopySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCopyInclude | null
    /**
     * Filter, which LibraryBookCopy to fetch.
     */
    where: LibraryBookCopyWhereUniqueInput
  }


  /**
   * LibraryBookCopy base type for findFirst actions
   */
  export type LibraryBookCopyFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the LibraryBookCopy
     */
    select?: LibraryBookCopySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCopyInclude | null
    /**
     * Filter, which LibraryBookCopy to fetch.
     */
    where?: LibraryBookCopyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBookCopies to fetch.
     */
    orderBy?: Enumerable<LibraryBookCopyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryBookCopies.
     */
    cursor?: LibraryBookCopyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBookCopies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBookCopies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryBookCopies.
     */
    distinct?: Enumerable<LibraryBookCopyScalarFieldEnum>
  }

  /**
   * LibraryBookCopy findFirst
   */
  export interface LibraryBookCopyFindFirstArgs extends LibraryBookCopyFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LibraryBookCopy findFirstOrThrow
   */
  export type LibraryBookCopyFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookCopy
     */
    select?: LibraryBookCopySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCopyInclude | null
    /**
     * Filter, which LibraryBookCopy to fetch.
     */
    where?: LibraryBookCopyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBookCopies to fetch.
     */
    orderBy?: Enumerable<LibraryBookCopyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryBookCopies.
     */
    cursor?: LibraryBookCopyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBookCopies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBookCopies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryBookCopies.
     */
    distinct?: Enumerable<LibraryBookCopyScalarFieldEnum>
  }


  /**
   * LibraryBookCopy findMany
   */
  export type LibraryBookCopyFindManyArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookCopy
     */
    select?: LibraryBookCopySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCopyInclude | null
    /**
     * Filter, which LibraryBookCopies to fetch.
     */
    where?: LibraryBookCopyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBookCopies to fetch.
     */
    orderBy?: Enumerable<LibraryBookCopyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LibraryBookCopies.
     */
    cursor?: LibraryBookCopyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBookCopies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBookCopies.
     */
    skip?: number
    distinct?: Enumerable<LibraryBookCopyScalarFieldEnum>
  }


  /**
   * LibraryBookCopy create
   */
  export type LibraryBookCopyCreateArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookCopy
     */
    select?: LibraryBookCopySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCopyInclude | null
    /**
     * The data needed to create a LibraryBookCopy.
     */
    data: XOR<LibraryBookCopyCreateInput, LibraryBookCopyUncheckedCreateInput>
  }


  /**
   * LibraryBookCopy createMany
   */
  export type LibraryBookCopyCreateManyArgs = {
    /**
     * The data used to create many LibraryBookCopies.
     */
    data: Enumerable<LibraryBookCopyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LibraryBookCopy update
   */
  export type LibraryBookCopyUpdateArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookCopy
     */
    select?: LibraryBookCopySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCopyInclude | null
    /**
     * The data needed to update a LibraryBookCopy.
     */
    data: XOR<LibraryBookCopyUpdateInput, LibraryBookCopyUncheckedUpdateInput>
    /**
     * Choose, which LibraryBookCopy to update.
     */
    where: LibraryBookCopyWhereUniqueInput
  }


  /**
   * LibraryBookCopy updateMany
   */
  export type LibraryBookCopyUpdateManyArgs = {
    /**
     * The data used to update LibraryBookCopies.
     */
    data: XOR<LibraryBookCopyUpdateManyMutationInput, LibraryBookCopyUncheckedUpdateManyInput>
    /**
     * Filter which LibraryBookCopies to update
     */
    where?: LibraryBookCopyWhereInput
  }


  /**
   * LibraryBookCopy upsert
   */
  export type LibraryBookCopyUpsertArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookCopy
     */
    select?: LibraryBookCopySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCopyInclude | null
    /**
     * The filter to search for the LibraryBookCopy to update in case it exists.
     */
    where: LibraryBookCopyWhereUniqueInput
    /**
     * In case the LibraryBookCopy found by the `where` argument doesn't exist, create a new LibraryBookCopy with this data.
     */
    create: XOR<LibraryBookCopyCreateInput, LibraryBookCopyUncheckedCreateInput>
    /**
     * In case the LibraryBookCopy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LibraryBookCopyUpdateInput, LibraryBookCopyUncheckedUpdateInput>
  }


  /**
   * LibraryBookCopy delete
   */
  export type LibraryBookCopyDeleteArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookCopy
     */
    select?: LibraryBookCopySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCopyInclude | null
    /**
     * Filter which LibraryBookCopy to delete.
     */
    where: LibraryBookCopyWhereUniqueInput
  }


  /**
   * LibraryBookCopy deleteMany
   */
  export type LibraryBookCopyDeleteManyArgs = {
    /**
     * Filter which LibraryBookCopies to delete
     */
    where?: LibraryBookCopyWhereInput
  }


  /**
   * LibraryBookCopy.libraryBorrowingHistories
   */
  export type LibraryBookCopy$libraryBorrowingHistoriesArgs = {
    /**
     * Select specific fields to fetch from the LibraryBorrowingHistory
     */
    select?: LibraryBorrowingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBorrowingHistoryInclude | null
    where?: LibraryBorrowingHistoryWhereInput
    orderBy?: Enumerable<LibraryBorrowingHistoryOrderByWithRelationInput>
    cursor?: LibraryBorrowingHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LibraryBorrowingHistoryScalarFieldEnum>
  }


  /**
   * LibraryBookCopy.libraryRequests
   */
  export type LibraryBookCopy$libraryRequestsArgs = {
    /**
     * Select specific fields to fetch from the LibraryRequest
     */
    select?: LibraryRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryRequestInclude | null
    where?: LibraryRequestWhereInput
    orderBy?: Enumerable<LibraryRequestOrderByWithRelationInput>
    cursor?: LibraryRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LibraryRequestScalarFieldEnum>
  }


  /**
   * LibraryBookCopy without action
   */
  export type LibraryBookCopyArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookCopy
     */
    select?: LibraryBookCopySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCopyInclude | null
  }



  /**
   * Model LibraryBorrowingHistory
   */


  export type AggregateLibraryBorrowingHistory = {
    _count: LibraryBorrowingHistoryCountAggregateOutputType | null
    _avg: LibraryBorrowingHistoryAvgAggregateOutputType | null
    _sum: LibraryBorrowingHistorySumAggregateOutputType | null
    _min: LibraryBorrowingHistoryMinAggregateOutputType | null
    _max: LibraryBorrowingHistoryMaxAggregateOutputType | null
  }

  export type LibraryBorrowingHistoryAvgAggregateOutputType = {
    id: number | null
    borrowDate: number | null
    returnDate: number | null
    actualReturnDate: number | null
    libraryStudentId: number | null
    libraryBookCopyId: number | null
    libraryUniversityId: number | null
  }

  export type LibraryBorrowingHistorySumAggregateOutputType = {
    id: number | null
    borrowDate: number | null
    returnDate: number | null
    actualReturnDate: number | null
    libraryStudentId: number | null
    libraryBookCopyId: number | null
    libraryUniversityId: number | null
  }

  export type LibraryBorrowingHistoryMinAggregateOutputType = {
    id: number | null
    borrowDate: number | null
    returnDate: number | null
    actualReturnDate: number | null
    createdAt: Date | null
    updatedAt: Date | null
    libraryStudentId: number | null
    libraryBookCopyId: number | null
    libraryUniversityId: number | null
  }

  export type LibraryBorrowingHistoryMaxAggregateOutputType = {
    id: number | null
    borrowDate: number | null
    returnDate: number | null
    actualReturnDate: number | null
    createdAt: Date | null
    updatedAt: Date | null
    libraryStudentId: number | null
    libraryBookCopyId: number | null
    libraryUniversityId: number | null
  }

  export type LibraryBorrowingHistoryCountAggregateOutputType = {
    id: number
    borrowDate: number
    returnDate: number
    actualReturnDate: number
    createdAt: number
    updatedAt: number
    libraryStudentId: number
    libraryBookCopyId: number
    libraryUniversityId: number
    _all: number
  }


  export type LibraryBorrowingHistoryAvgAggregateInputType = {
    id?: true
    borrowDate?: true
    returnDate?: true
    actualReturnDate?: true
    libraryStudentId?: true
    libraryBookCopyId?: true
    libraryUniversityId?: true
  }

  export type LibraryBorrowingHistorySumAggregateInputType = {
    id?: true
    borrowDate?: true
    returnDate?: true
    actualReturnDate?: true
    libraryStudentId?: true
    libraryBookCopyId?: true
    libraryUniversityId?: true
  }

  export type LibraryBorrowingHistoryMinAggregateInputType = {
    id?: true
    borrowDate?: true
    returnDate?: true
    actualReturnDate?: true
    createdAt?: true
    updatedAt?: true
    libraryStudentId?: true
    libraryBookCopyId?: true
    libraryUniversityId?: true
  }

  export type LibraryBorrowingHistoryMaxAggregateInputType = {
    id?: true
    borrowDate?: true
    returnDate?: true
    actualReturnDate?: true
    createdAt?: true
    updatedAt?: true
    libraryStudentId?: true
    libraryBookCopyId?: true
    libraryUniversityId?: true
  }

  export type LibraryBorrowingHistoryCountAggregateInputType = {
    id?: true
    borrowDate?: true
    returnDate?: true
    actualReturnDate?: true
    createdAt?: true
    updatedAt?: true
    libraryStudentId?: true
    libraryBookCopyId?: true
    libraryUniversityId?: true
    _all?: true
  }

  export type LibraryBorrowingHistoryAggregateArgs = {
    /**
     * Filter which LibraryBorrowingHistory to aggregate.
     */
    where?: LibraryBorrowingHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBorrowingHistories to fetch.
     */
    orderBy?: Enumerable<LibraryBorrowingHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LibraryBorrowingHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBorrowingHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBorrowingHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LibraryBorrowingHistories
    **/
    _count?: true | LibraryBorrowingHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LibraryBorrowingHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LibraryBorrowingHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LibraryBorrowingHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LibraryBorrowingHistoryMaxAggregateInputType
  }

  export type GetLibraryBorrowingHistoryAggregateType<T extends LibraryBorrowingHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateLibraryBorrowingHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLibraryBorrowingHistory[P]>
      : GetScalarType<T[P], AggregateLibraryBorrowingHistory[P]>
  }




  export type LibraryBorrowingHistoryGroupByArgs = {
    where?: LibraryBorrowingHistoryWhereInput
    orderBy?: Enumerable<LibraryBorrowingHistoryOrderByWithAggregationInput>
    by: LibraryBorrowingHistoryScalarFieldEnum[]
    having?: LibraryBorrowingHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LibraryBorrowingHistoryCountAggregateInputType | true
    _avg?: LibraryBorrowingHistoryAvgAggregateInputType
    _sum?: LibraryBorrowingHistorySumAggregateInputType
    _min?: LibraryBorrowingHistoryMinAggregateInputType
    _max?: LibraryBorrowingHistoryMaxAggregateInputType
  }


  export type LibraryBorrowingHistoryGroupByOutputType = {
    id: number
    borrowDate: number
    returnDate: number
    actualReturnDate: number
    createdAt: Date
    updatedAt: Date
    libraryStudentId: number
    libraryBookCopyId: number
    libraryUniversityId: number
    _count: LibraryBorrowingHistoryCountAggregateOutputType | null
    _avg: LibraryBorrowingHistoryAvgAggregateOutputType | null
    _sum: LibraryBorrowingHistorySumAggregateOutputType | null
    _min: LibraryBorrowingHistoryMinAggregateOutputType | null
    _max: LibraryBorrowingHistoryMaxAggregateOutputType | null
  }

  type GetLibraryBorrowingHistoryGroupByPayload<T extends LibraryBorrowingHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LibraryBorrowingHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LibraryBorrowingHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LibraryBorrowingHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], LibraryBorrowingHistoryGroupByOutputType[P]>
        }
      >
    >


  export type LibraryBorrowingHistorySelect = {
    id?: boolean
    student?: boolean | LibraryStudentArgs
    copy?: boolean | LibraryBookCopyArgs
    borrowDate?: boolean
    returnDate?: boolean
    actualReturnDate?: boolean
    borrowedFrom?: boolean | LibraryUniversityArgs
    createdAt?: boolean
    updatedAt?: boolean
    libraryStudentId?: boolean
    libraryBookCopyId?: boolean
    libraryUniversityId?: boolean
  }


  export type LibraryBorrowingHistoryInclude = {
    student?: boolean | LibraryStudentArgs
    copy?: boolean | LibraryBookCopyArgs
    borrowedFrom?: boolean | LibraryUniversityArgs
  }

  export type LibraryBorrowingHistoryGetPayload<S extends boolean | null | undefined | LibraryBorrowingHistoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LibraryBorrowingHistory :
    S extends undefined ? never :
    S extends { include: any } & (LibraryBorrowingHistoryArgs | LibraryBorrowingHistoryFindManyArgs)
    ? LibraryBorrowingHistory  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'student' ? LibraryStudentGetPayload<S['include'][P]> :
        P extends 'copy' ? LibraryBookCopyGetPayload<S['include'][P]> :
        P extends 'borrowedFrom' ? LibraryUniversityGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (LibraryBorrowingHistoryArgs | LibraryBorrowingHistoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'student' ? LibraryStudentGetPayload<S['select'][P]> :
        P extends 'copy' ? LibraryBookCopyGetPayload<S['select'][P]> :
        P extends 'borrowedFrom' ? LibraryUniversityGetPayload<S['select'][P]> :  P extends keyof LibraryBorrowingHistory ? LibraryBorrowingHistory[P] : never
  } 
      : LibraryBorrowingHistory


  type LibraryBorrowingHistoryCountArgs = 
    Omit<LibraryBorrowingHistoryFindManyArgs, 'select' | 'include'> & {
      select?: LibraryBorrowingHistoryCountAggregateInputType | true
    }

  export interface LibraryBorrowingHistoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one LibraryBorrowingHistory that matches the filter.
     * @param {LibraryBorrowingHistoryFindUniqueArgs} args - Arguments to find a LibraryBorrowingHistory
     * @example
     * // Get one LibraryBorrowingHistory
     * const libraryBorrowingHistory = await prisma.libraryBorrowingHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LibraryBorrowingHistoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LibraryBorrowingHistoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LibraryBorrowingHistory'> extends True ? Prisma__LibraryBorrowingHistoryClient<LibraryBorrowingHistoryGetPayload<T>> : Prisma__LibraryBorrowingHistoryClient<LibraryBorrowingHistoryGetPayload<T> | null, null>

    /**
     * Find one LibraryBorrowingHistory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LibraryBorrowingHistoryFindUniqueOrThrowArgs} args - Arguments to find a LibraryBorrowingHistory
     * @example
     * // Get one LibraryBorrowingHistory
     * const libraryBorrowingHistory = await prisma.libraryBorrowingHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LibraryBorrowingHistoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LibraryBorrowingHistoryFindUniqueOrThrowArgs>
    ): Prisma__LibraryBorrowingHistoryClient<LibraryBorrowingHistoryGetPayload<T>>

    /**
     * Find the first LibraryBorrowingHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBorrowingHistoryFindFirstArgs} args - Arguments to find a LibraryBorrowingHistory
     * @example
     * // Get one LibraryBorrowingHistory
     * const libraryBorrowingHistory = await prisma.libraryBorrowingHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LibraryBorrowingHistoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LibraryBorrowingHistoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LibraryBorrowingHistory'> extends True ? Prisma__LibraryBorrowingHistoryClient<LibraryBorrowingHistoryGetPayload<T>> : Prisma__LibraryBorrowingHistoryClient<LibraryBorrowingHistoryGetPayload<T> | null, null>

    /**
     * Find the first LibraryBorrowingHistory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBorrowingHistoryFindFirstOrThrowArgs} args - Arguments to find a LibraryBorrowingHistory
     * @example
     * // Get one LibraryBorrowingHistory
     * const libraryBorrowingHistory = await prisma.libraryBorrowingHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LibraryBorrowingHistoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LibraryBorrowingHistoryFindFirstOrThrowArgs>
    ): Prisma__LibraryBorrowingHistoryClient<LibraryBorrowingHistoryGetPayload<T>>

    /**
     * Find zero or more LibraryBorrowingHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBorrowingHistoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LibraryBorrowingHistories
     * const libraryBorrowingHistories = await prisma.libraryBorrowingHistory.findMany()
     * 
     * // Get first 10 LibraryBorrowingHistories
     * const libraryBorrowingHistories = await prisma.libraryBorrowingHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const libraryBorrowingHistoryWithIdOnly = await prisma.libraryBorrowingHistory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LibraryBorrowingHistoryFindManyArgs>(
      args?: SelectSubset<T, LibraryBorrowingHistoryFindManyArgs>
    ): Prisma.PrismaPromise<Array<LibraryBorrowingHistoryGetPayload<T>>>

    /**
     * Create a LibraryBorrowingHistory.
     * @param {LibraryBorrowingHistoryCreateArgs} args - Arguments to create a LibraryBorrowingHistory.
     * @example
     * // Create one LibraryBorrowingHistory
     * const LibraryBorrowingHistory = await prisma.libraryBorrowingHistory.create({
     *   data: {
     *     // ... data to create a LibraryBorrowingHistory
     *   }
     * })
     * 
    **/
    create<T extends LibraryBorrowingHistoryCreateArgs>(
      args: SelectSubset<T, LibraryBorrowingHistoryCreateArgs>
    ): Prisma__LibraryBorrowingHistoryClient<LibraryBorrowingHistoryGetPayload<T>>

    /**
     * Create many LibraryBorrowingHistories.
     *     @param {LibraryBorrowingHistoryCreateManyArgs} args - Arguments to create many LibraryBorrowingHistories.
     *     @example
     *     // Create many LibraryBorrowingHistories
     *     const libraryBorrowingHistory = await prisma.libraryBorrowingHistory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LibraryBorrowingHistoryCreateManyArgs>(
      args?: SelectSubset<T, LibraryBorrowingHistoryCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LibraryBorrowingHistory.
     * @param {LibraryBorrowingHistoryDeleteArgs} args - Arguments to delete one LibraryBorrowingHistory.
     * @example
     * // Delete one LibraryBorrowingHistory
     * const LibraryBorrowingHistory = await prisma.libraryBorrowingHistory.delete({
     *   where: {
     *     // ... filter to delete one LibraryBorrowingHistory
     *   }
     * })
     * 
    **/
    delete<T extends LibraryBorrowingHistoryDeleteArgs>(
      args: SelectSubset<T, LibraryBorrowingHistoryDeleteArgs>
    ): Prisma__LibraryBorrowingHistoryClient<LibraryBorrowingHistoryGetPayload<T>>

    /**
     * Update one LibraryBorrowingHistory.
     * @param {LibraryBorrowingHistoryUpdateArgs} args - Arguments to update one LibraryBorrowingHistory.
     * @example
     * // Update one LibraryBorrowingHistory
     * const libraryBorrowingHistory = await prisma.libraryBorrowingHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LibraryBorrowingHistoryUpdateArgs>(
      args: SelectSubset<T, LibraryBorrowingHistoryUpdateArgs>
    ): Prisma__LibraryBorrowingHistoryClient<LibraryBorrowingHistoryGetPayload<T>>

    /**
     * Delete zero or more LibraryBorrowingHistories.
     * @param {LibraryBorrowingHistoryDeleteManyArgs} args - Arguments to filter LibraryBorrowingHistories to delete.
     * @example
     * // Delete a few LibraryBorrowingHistories
     * const { count } = await prisma.libraryBorrowingHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LibraryBorrowingHistoryDeleteManyArgs>(
      args?: SelectSubset<T, LibraryBorrowingHistoryDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LibraryBorrowingHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBorrowingHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LibraryBorrowingHistories
     * const libraryBorrowingHistory = await prisma.libraryBorrowingHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LibraryBorrowingHistoryUpdateManyArgs>(
      args: SelectSubset<T, LibraryBorrowingHistoryUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LibraryBorrowingHistory.
     * @param {LibraryBorrowingHistoryUpsertArgs} args - Arguments to update or create a LibraryBorrowingHistory.
     * @example
     * // Update or create a LibraryBorrowingHistory
     * const libraryBorrowingHistory = await prisma.libraryBorrowingHistory.upsert({
     *   create: {
     *     // ... data to create a LibraryBorrowingHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LibraryBorrowingHistory we want to update
     *   }
     * })
    **/
    upsert<T extends LibraryBorrowingHistoryUpsertArgs>(
      args: SelectSubset<T, LibraryBorrowingHistoryUpsertArgs>
    ): Prisma__LibraryBorrowingHistoryClient<LibraryBorrowingHistoryGetPayload<T>>

    /**
     * Count the number of LibraryBorrowingHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBorrowingHistoryCountArgs} args - Arguments to filter LibraryBorrowingHistories to count.
     * @example
     * // Count the number of LibraryBorrowingHistories
     * const count = await prisma.libraryBorrowingHistory.count({
     *   where: {
     *     // ... the filter for the LibraryBorrowingHistories we want to count
     *   }
     * })
    **/
    count<T extends LibraryBorrowingHistoryCountArgs>(
      args?: Subset<T, LibraryBorrowingHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LibraryBorrowingHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LibraryBorrowingHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBorrowingHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LibraryBorrowingHistoryAggregateArgs>(args: Subset<T, LibraryBorrowingHistoryAggregateArgs>): Prisma.PrismaPromise<GetLibraryBorrowingHistoryAggregateType<T>>

    /**
     * Group by LibraryBorrowingHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBorrowingHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LibraryBorrowingHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LibraryBorrowingHistoryGroupByArgs['orderBy'] }
        : { orderBy?: LibraryBorrowingHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LibraryBorrowingHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLibraryBorrowingHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LibraryBorrowingHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LibraryBorrowingHistoryClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    student<T extends LibraryStudentArgs= {}>(args?: Subset<T, LibraryStudentArgs>): Prisma__LibraryStudentClient<LibraryStudentGetPayload<T> | Null>;

    copy<T extends LibraryBookCopyArgs= {}>(args?: Subset<T, LibraryBookCopyArgs>): Prisma__LibraryBookCopyClient<LibraryBookCopyGetPayload<T> | Null>;

    borrowedFrom<T extends LibraryUniversityArgs= {}>(args?: Subset<T, LibraryUniversityArgs>): Prisma__LibraryUniversityClient<LibraryUniversityGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LibraryBorrowingHistory base type for findUnique actions
   */
  export type LibraryBorrowingHistoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the LibraryBorrowingHistory
     */
    select?: LibraryBorrowingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBorrowingHistoryInclude | null
    /**
     * Filter, which LibraryBorrowingHistory to fetch.
     */
    where: LibraryBorrowingHistoryWhereUniqueInput
  }

  /**
   * LibraryBorrowingHistory findUnique
   */
  export interface LibraryBorrowingHistoryFindUniqueArgs extends LibraryBorrowingHistoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LibraryBorrowingHistory findUniqueOrThrow
   */
  export type LibraryBorrowingHistoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LibraryBorrowingHistory
     */
    select?: LibraryBorrowingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBorrowingHistoryInclude | null
    /**
     * Filter, which LibraryBorrowingHistory to fetch.
     */
    where: LibraryBorrowingHistoryWhereUniqueInput
  }


  /**
   * LibraryBorrowingHistory base type for findFirst actions
   */
  export type LibraryBorrowingHistoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the LibraryBorrowingHistory
     */
    select?: LibraryBorrowingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBorrowingHistoryInclude | null
    /**
     * Filter, which LibraryBorrowingHistory to fetch.
     */
    where?: LibraryBorrowingHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBorrowingHistories to fetch.
     */
    orderBy?: Enumerable<LibraryBorrowingHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryBorrowingHistories.
     */
    cursor?: LibraryBorrowingHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBorrowingHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBorrowingHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryBorrowingHistories.
     */
    distinct?: Enumerable<LibraryBorrowingHistoryScalarFieldEnum>
  }

  /**
   * LibraryBorrowingHistory findFirst
   */
  export interface LibraryBorrowingHistoryFindFirstArgs extends LibraryBorrowingHistoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LibraryBorrowingHistory findFirstOrThrow
   */
  export type LibraryBorrowingHistoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LibraryBorrowingHistory
     */
    select?: LibraryBorrowingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBorrowingHistoryInclude | null
    /**
     * Filter, which LibraryBorrowingHistory to fetch.
     */
    where?: LibraryBorrowingHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBorrowingHistories to fetch.
     */
    orderBy?: Enumerable<LibraryBorrowingHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryBorrowingHistories.
     */
    cursor?: LibraryBorrowingHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBorrowingHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBorrowingHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryBorrowingHistories.
     */
    distinct?: Enumerable<LibraryBorrowingHistoryScalarFieldEnum>
  }


  /**
   * LibraryBorrowingHistory findMany
   */
  export type LibraryBorrowingHistoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the LibraryBorrowingHistory
     */
    select?: LibraryBorrowingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBorrowingHistoryInclude | null
    /**
     * Filter, which LibraryBorrowingHistories to fetch.
     */
    where?: LibraryBorrowingHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBorrowingHistories to fetch.
     */
    orderBy?: Enumerable<LibraryBorrowingHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LibraryBorrowingHistories.
     */
    cursor?: LibraryBorrowingHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBorrowingHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBorrowingHistories.
     */
    skip?: number
    distinct?: Enumerable<LibraryBorrowingHistoryScalarFieldEnum>
  }


  /**
   * LibraryBorrowingHistory create
   */
  export type LibraryBorrowingHistoryCreateArgs = {
    /**
     * Select specific fields to fetch from the LibraryBorrowingHistory
     */
    select?: LibraryBorrowingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBorrowingHistoryInclude | null
    /**
     * The data needed to create a LibraryBorrowingHistory.
     */
    data: XOR<LibraryBorrowingHistoryCreateInput, LibraryBorrowingHistoryUncheckedCreateInput>
  }


  /**
   * LibraryBorrowingHistory createMany
   */
  export type LibraryBorrowingHistoryCreateManyArgs = {
    /**
     * The data used to create many LibraryBorrowingHistories.
     */
    data: Enumerable<LibraryBorrowingHistoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LibraryBorrowingHistory update
   */
  export type LibraryBorrowingHistoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the LibraryBorrowingHistory
     */
    select?: LibraryBorrowingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBorrowingHistoryInclude | null
    /**
     * The data needed to update a LibraryBorrowingHistory.
     */
    data: XOR<LibraryBorrowingHistoryUpdateInput, LibraryBorrowingHistoryUncheckedUpdateInput>
    /**
     * Choose, which LibraryBorrowingHistory to update.
     */
    where: LibraryBorrowingHistoryWhereUniqueInput
  }


  /**
   * LibraryBorrowingHistory updateMany
   */
  export type LibraryBorrowingHistoryUpdateManyArgs = {
    /**
     * The data used to update LibraryBorrowingHistories.
     */
    data: XOR<LibraryBorrowingHistoryUpdateManyMutationInput, LibraryBorrowingHistoryUncheckedUpdateManyInput>
    /**
     * Filter which LibraryBorrowingHistories to update
     */
    where?: LibraryBorrowingHistoryWhereInput
  }


  /**
   * LibraryBorrowingHistory upsert
   */
  export type LibraryBorrowingHistoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the LibraryBorrowingHistory
     */
    select?: LibraryBorrowingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBorrowingHistoryInclude | null
    /**
     * The filter to search for the LibraryBorrowingHistory to update in case it exists.
     */
    where: LibraryBorrowingHistoryWhereUniqueInput
    /**
     * In case the LibraryBorrowingHistory found by the `where` argument doesn't exist, create a new LibraryBorrowingHistory with this data.
     */
    create: XOR<LibraryBorrowingHistoryCreateInput, LibraryBorrowingHistoryUncheckedCreateInput>
    /**
     * In case the LibraryBorrowingHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LibraryBorrowingHistoryUpdateInput, LibraryBorrowingHistoryUncheckedUpdateInput>
  }


  /**
   * LibraryBorrowingHistory delete
   */
  export type LibraryBorrowingHistoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the LibraryBorrowingHistory
     */
    select?: LibraryBorrowingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBorrowingHistoryInclude | null
    /**
     * Filter which LibraryBorrowingHistory to delete.
     */
    where: LibraryBorrowingHistoryWhereUniqueInput
  }


  /**
   * LibraryBorrowingHistory deleteMany
   */
  export type LibraryBorrowingHistoryDeleteManyArgs = {
    /**
     * Filter which LibraryBorrowingHistories to delete
     */
    where?: LibraryBorrowingHistoryWhereInput
  }


  /**
   * LibraryBorrowingHistory without action
   */
  export type LibraryBorrowingHistoryArgs = {
    /**
     * Select specific fields to fetch from the LibraryBorrowingHistory
     */
    select?: LibraryBorrowingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBorrowingHistoryInclude | null
  }



  /**
   * Model LibraryRequest
   */


  export type AggregateLibraryRequest = {
    _count: LibraryRequestCountAggregateOutputType | null
    _avg: LibraryRequestAvgAggregateOutputType | null
    _sum: LibraryRequestSumAggregateOutputType | null
    _min: LibraryRequestMinAggregateOutputType | null
    _max: LibraryRequestMaxAggregateOutputType | null
  }

  export type LibraryRequestAvgAggregateOutputType = {
    id: number | null
    libraryStudentId: number | null
    libraryBookCopyId: number | null
    fromLibraryUniversityId: number | null
    toLibraryUniversityId: number | null
  }

  export type LibraryRequestSumAggregateOutputType = {
    id: number | null
    libraryStudentId: number | null
    libraryBookCopyId: number | null
    fromLibraryUniversityId: number | null
    toLibraryUniversityId: number | null
  }

  export type LibraryRequestMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    libraryStudentId: number | null
    libraryBookCopyId: number | null
    fromLibraryUniversityId: number | null
    toLibraryUniversityId: number | null
  }

  export type LibraryRequestMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    libraryStudentId: number | null
    libraryBookCopyId: number | null
    fromLibraryUniversityId: number | null
    toLibraryUniversityId: number | null
  }

  export type LibraryRequestCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    libraryStudentId: number
    libraryBookCopyId: number
    fromLibraryUniversityId: number
    toLibraryUniversityId: number
    _all: number
  }


  export type LibraryRequestAvgAggregateInputType = {
    id?: true
    libraryStudentId?: true
    libraryBookCopyId?: true
    fromLibraryUniversityId?: true
    toLibraryUniversityId?: true
  }

  export type LibraryRequestSumAggregateInputType = {
    id?: true
    libraryStudentId?: true
    libraryBookCopyId?: true
    fromLibraryUniversityId?: true
    toLibraryUniversityId?: true
  }

  export type LibraryRequestMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    libraryStudentId?: true
    libraryBookCopyId?: true
    fromLibraryUniversityId?: true
    toLibraryUniversityId?: true
  }

  export type LibraryRequestMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    libraryStudentId?: true
    libraryBookCopyId?: true
    fromLibraryUniversityId?: true
    toLibraryUniversityId?: true
  }

  export type LibraryRequestCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    libraryStudentId?: true
    libraryBookCopyId?: true
    fromLibraryUniversityId?: true
    toLibraryUniversityId?: true
    _all?: true
  }

  export type LibraryRequestAggregateArgs = {
    /**
     * Filter which LibraryRequest to aggregate.
     */
    where?: LibraryRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryRequests to fetch.
     */
    orderBy?: Enumerable<LibraryRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LibraryRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LibraryRequests
    **/
    _count?: true | LibraryRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LibraryRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LibraryRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LibraryRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LibraryRequestMaxAggregateInputType
  }

  export type GetLibraryRequestAggregateType<T extends LibraryRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateLibraryRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLibraryRequest[P]>
      : GetScalarType<T[P], AggregateLibraryRequest[P]>
  }




  export type LibraryRequestGroupByArgs = {
    where?: LibraryRequestWhereInput
    orderBy?: Enumerable<LibraryRequestOrderByWithAggregationInput>
    by: LibraryRequestScalarFieldEnum[]
    having?: LibraryRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LibraryRequestCountAggregateInputType | true
    _avg?: LibraryRequestAvgAggregateInputType
    _sum?: LibraryRequestSumAggregateInputType
    _min?: LibraryRequestMinAggregateInputType
    _max?: LibraryRequestMaxAggregateInputType
  }


  export type LibraryRequestGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    libraryStudentId: number
    libraryBookCopyId: number
    fromLibraryUniversityId: number
    toLibraryUniversityId: number
    _count: LibraryRequestCountAggregateOutputType | null
    _avg: LibraryRequestAvgAggregateOutputType | null
    _sum: LibraryRequestSumAggregateOutputType | null
    _min: LibraryRequestMinAggregateOutputType | null
    _max: LibraryRequestMaxAggregateOutputType | null
  }

  type GetLibraryRequestGroupByPayload<T extends LibraryRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LibraryRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LibraryRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LibraryRequestGroupByOutputType[P]>
            : GetScalarType<T[P], LibraryRequestGroupByOutputType[P]>
        }
      >
    >


  export type LibraryRequestSelect = {
    id?: boolean
    student?: boolean | LibraryStudentArgs
    copy?: boolean | LibraryBookCopyArgs
    from?: boolean | LibraryUniversityArgs
    to?: boolean | LibraryUniversityArgs
    createdAt?: boolean
    updatedAt?: boolean
    libraryStudentId?: boolean
    libraryBookCopyId?: boolean
    fromLibraryUniversityId?: boolean
    toLibraryUniversityId?: boolean
  }


  export type LibraryRequestInclude = {
    student?: boolean | LibraryStudentArgs
    copy?: boolean | LibraryBookCopyArgs
    from?: boolean | LibraryUniversityArgs
    to?: boolean | LibraryUniversityArgs
  }

  export type LibraryRequestGetPayload<S extends boolean | null | undefined | LibraryRequestArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LibraryRequest :
    S extends undefined ? never :
    S extends { include: any } & (LibraryRequestArgs | LibraryRequestFindManyArgs)
    ? LibraryRequest  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'student' ? LibraryStudentGetPayload<S['include'][P]> :
        P extends 'copy' ? LibraryBookCopyGetPayload<S['include'][P]> :
        P extends 'from' ? LibraryUniversityGetPayload<S['include'][P]> :
        P extends 'to' ? LibraryUniversityGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (LibraryRequestArgs | LibraryRequestFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'student' ? LibraryStudentGetPayload<S['select'][P]> :
        P extends 'copy' ? LibraryBookCopyGetPayload<S['select'][P]> :
        P extends 'from' ? LibraryUniversityGetPayload<S['select'][P]> :
        P extends 'to' ? LibraryUniversityGetPayload<S['select'][P]> :  P extends keyof LibraryRequest ? LibraryRequest[P] : never
  } 
      : LibraryRequest


  type LibraryRequestCountArgs = 
    Omit<LibraryRequestFindManyArgs, 'select' | 'include'> & {
      select?: LibraryRequestCountAggregateInputType | true
    }

  export interface LibraryRequestDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one LibraryRequest that matches the filter.
     * @param {LibraryRequestFindUniqueArgs} args - Arguments to find a LibraryRequest
     * @example
     * // Get one LibraryRequest
     * const libraryRequest = await prisma.libraryRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LibraryRequestFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LibraryRequestFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LibraryRequest'> extends True ? Prisma__LibraryRequestClient<LibraryRequestGetPayload<T>> : Prisma__LibraryRequestClient<LibraryRequestGetPayload<T> | null, null>

    /**
     * Find one LibraryRequest that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LibraryRequestFindUniqueOrThrowArgs} args - Arguments to find a LibraryRequest
     * @example
     * // Get one LibraryRequest
     * const libraryRequest = await prisma.libraryRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LibraryRequestFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LibraryRequestFindUniqueOrThrowArgs>
    ): Prisma__LibraryRequestClient<LibraryRequestGetPayload<T>>

    /**
     * Find the first LibraryRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryRequestFindFirstArgs} args - Arguments to find a LibraryRequest
     * @example
     * // Get one LibraryRequest
     * const libraryRequest = await prisma.libraryRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LibraryRequestFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LibraryRequestFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LibraryRequest'> extends True ? Prisma__LibraryRequestClient<LibraryRequestGetPayload<T>> : Prisma__LibraryRequestClient<LibraryRequestGetPayload<T> | null, null>

    /**
     * Find the first LibraryRequest that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryRequestFindFirstOrThrowArgs} args - Arguments to find a LibraryRequest
     * @example
     * // Get one LibraryRequest
     * const libraryRequest = await prisma.libraryRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LibraryRequestFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LibraryRequestFindFirstOrThrowArgs>
    ): Prisma__LibraryRequestClient<LibraryRequestGetPayload<T>>

    /**
     * Find zero or more LibraryRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryRequestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LibraryRequests
     * const libraryRequests = await prisma.libraryRequest.findMany()
     * 
     * // Get first 10 LibraryRequests
     * const libraryRequests = await prisma.libraryRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const libraryRequestWithIdOnly = await prisma.libraryRequest.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LibraryRequestFindManyArgs>(
      args?: SelectSubset<T, LibraryRequestFindManyArgs>
    ): Prisma.PrismaPromise<Array<LibraryRequestGetPayload<T>>>

    /**
     * Create a LibraryRequest.
     * @param {LibraryRequestCreateArgs} args - Arguments to create a LibraryRequest.
     * @example
     * // Create one LibraryRequest
     * const LibraryRequest = await prisma.libraryRequest.create({
     *   data: {
     *     // ... data to create a LibraryRequest
     *   }
     * })
     * 
    **/
    create<T extends LibraryRequestCreateArgs>(
      args: SelectSubset<T, LibraryRequestCreateArgs>
    ): Prisma__LibraryRequestClient<LibraryRequestGetPayload<T>>

    /**
     * Create many LibraryRequests.
     *     @param {LibraryRequestCreateManyArgs} args - Arguments to create many LibraryRequests.
     *     @example
     *     // Create many LibraryRequests
     *     const libraryRequest = await prisma.libraryRequest.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LibraryRequestCreateManyArgs>(
      args?: SelectSubset<T, LibraryRequestCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LibraryRequest.
     * @param {LibraryRequestDeleteArgs} args - Arguments to delete one LibraryRequest.
     * @example
     * // Delete one LibraryRequest
     * const LibraryRequest = await prisma.libraryRequest.delete({
     *   where: {
     *     // ... filter to delete one LibraryRequest
     *   }
     * })
     * 
    **/
    delete<T extends LibraryRequestDeleteArgs>(
      args: SelectSubset<T, LibraryRequestDeleteArgs>
    ): Prisma__LibraryRequestClient<LibraryRequestGetPayload<T>>

    /**
     * Update one LibraryRequest.
     * @param {LibraryRequestUpdateArgs} args - Arguments to update one LibraryRequest.
     * @example
     * // Update one LibraryRequest
     * const libraryRequest = await prisma.libraryRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LibraryRequestUpdateArgs>(
      args: SelectSubset<T, LibraryRequestUpdateArgs>
    ): Prisma__LibraryRequestClient<LibraryRequestGetPayload<T>>

    /**
     * Delete zero or more LibraryRequests.
     * @param {LibraryRequestDeleteManyArgs} args - Arguments to filter LibraryRequests to delete.
     * @example
     * // Delete a few LibraryRequests
     * const { count } = await prisma.libraryRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LibraryRequestDeleteManyArgs>(
      args?: SelectSubset<T, LibraryRequestDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LibraryRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LibraryRequests
     * const libraryRequest = await prisma.libraryRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LibraryRequestUpdateManyArgs>(
      args: SelectSubset<T, LibraryRequestUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LibraryRequest.
     * @param {LibraryRequestUpsertArgs} args - Arguments to update or create a LibraryRequest.
     * @example
     * // Update or create a LibraryRequest
     * const libraryRequest = await prisma.libraryRequest.upsert({
     *   create: {
     *     // ... data to create a LibraryRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LibraryRequest we want to update
     *   }
     * })
    **/
    upsert<T extends LibraryRequestUpsertArgs>(
      args: SelectSubset<T, LibraryRequestUpsertArgs>
    ): Prisma__LibraryRequestClient<LibraryRequestGetPayload<T>>

    /**
     * Count the number of LibraryRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryRequestCountArgs} args - Arguments to filter LibraryRequests to count.
     * @example
     * // Count the number of LibraryRequests
     * const count = await prisma.libraryRequest.count({
     *   where: {
     *     // ... the filter for the LibraryRequests we want to count
     *   }
     * })
    **/
    count<T extends LibraryRequestCountArgs>(
      args?: Subset<T, LibraryRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LibraryRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LibraryRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LibraryRequestAggregateArgs>(args: Subset<T, LibraryRequestAggregateArgs>): Prisma.PrismaPromise<GetLibraryRequestAggregateType<T>>

    /**
     * Group by LibraryRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LibraryRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LibraryRequestGroupByArgs['orderBy'] }
        : { orderBy?: LibraryRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LibraryRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLibraryRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LibraryRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LibraryRequestClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    student<T extends LibraryStudentArgs= {}>(args?: Subset<T, LibraryStudentArgs>): Prisma__LibraryStudentClient<LibraryStudentGetPayload<T> | Null>;

    copy<T extends LibraryBookCopyArgs= {}>(args?: Subset<T, LibraryBookCopyArgs>): Prisma__LibraryBookCopyClient<LibraryBookCopyGetPayload<T> | Null>;

    from<T extends LibraryUniversityArgs= {}>(args?: Subset<T, LibraryUniversityArgs>): Prisma__LibraryUniversityClient<LibraryUniversityGetPayload<T> | Null>;

    to<T extends LibraryUniversityArgs= {}>(args?: Subset<T, LibraryUniversityArgs>): Prisma__LibraryUniversityClient<LibraryUniversityGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LibraryRequest base type for findUnique actions
   */
  export type LibraryRequestFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the LibraryRequest
     */
    select?: LibraryRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryRequestInclude | null
    /**
     * Filter, which LibraryRequest to fetch.
     */
    where: LibraryRequestWhereUniqueInput
  }

  /**
   * LibraryRequest findUnique
   */
  export interface LibraryRequestFindUniqueArgs extends LibraryRequestFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LibraryRequest findUniqueOrThrow
   */
  export type LibraryRequestFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LibraryRequest
     */
    select?: LibraryRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryRequestInclude | null
    /**
     * Filter, which LibraryRequest to fetch.
     */
    where: LibraryRequestWhereUniqueInput
  }


  /**
   * LibraryRequest base type for findFirst actions
   */
  export type LibraryRequestFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the LibraryRequest
     */
    select?: LibraryRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryRequestInclude | null
    /**
     * Filter, which LibraryRequest to fetch.
     */
    where?: LibraryRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryRequests to fetch.
     */
    orderBy?: Enumerable<LibraryRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryRequests.
     */
    cursor?: LibraryRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryRequests.
     */
    distinct?: Enumerable<LibraryRequestScalarFieldEnum>
  }

  /**
   * LibraryRequest findFirst
   */
  export interface LibraryRequestFindFirstArgs extends LibraryRequestFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LibraryRequest findFirstOrThrow
   */
  export type LibraryRequestFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LibraryRequest
     */
    select?: LibraryRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryRequestInclude | null
    /**
     * Filter, which LibraryRequest to fetch.
     */
    where?: LibraryRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryRequests to fetch.
     */
    orderBy?: Enumerable<LibraryRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryRequests.
     */
    cursor?: LibraryRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryRequests.
     */
    distinct?: Enumerable<LibraryRequestScalarFieldEnum>
  }


  /**
   * LibraryRequest findMany
   */
  export type LibraryRequestFindManyArgs = {
    /**
     * Select specific fields to fetch from the LibraryRequest
     */
    select?: LibraryRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryRequestInclude | null
    /**
     * Filter, which LibraryRequests to fetch.
     */
    where?: LibraryRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryRequests to fetch.
     */
    orderBy?: Enumerable<LibraryRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LibraryRequests.
     */
    cursor?: LibraryRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryRequests.
     */
    skip?: number
    distinct?: Enumerable<LibraryRequestScalarFieldEnum>
  }


  /**
   * LibraryRequest create
   */
  export type LibraryRequestCreateArgs = {
    /**
     * Select specific fields to fetch from the LibraryRequest
     */
    select?: LibraryRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryRequestInclude | null
    /**
     * The data needed to create a LibraryRequest.
     */
    data: XOR<LibraryRequestCreateInput, LibraryRequestUncheckedCreateInput>
  }


  /**
   * LibraryRequest createMany
   */
  export type LibraryRequestCreateManyArgs = {
    /**
     * The data used to create many LibraryRequests.
     */
    data: Enumerable<LibraryRequestCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LibraryRequest update
   */
  export type LibraryRequestUpdateArgs = {
    /**
     * Select specific fields to fetch from the LibraryRequest
     */
    select?: LibraryRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryRequestInclude | null
    /**
     * The data needed to update a LibraryRequest.
     */
    data: XOR<LibraryRequestUpdateInput, LibraryRequestUncheckedUpdateInput>
    /**
     * Choose, which LibraryRequest to update.
     */
    where: LibraryRequestWhereUniqueInput
  }


  /**
   * LibraryRequest updateMany
   */
  export type LibraryRequestUpdateManyArgs = {
    /**
     * The data used to update LibraryRequests.
     */
    data: XOR<LibraryRequestUpdateManyMutationInput, LibraryRequestUncheckedUpdateManyInput>
    /**
     * Filter which LibraryRequests to update
     */
    where?: LibraryRequestWhereInput
  }


  /**
   * LibraryRequest upsert
   */
  export type LibraryRequestUpsertArgs = {
    /**
     * Select specific fields to fetch from the LibraryRequest
     */
    select?: LibraryRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryRequestInclude | null
    /**
     * The filter to search for the LibraryRequest to update in case it exists.
     */
    where: LibraryRequestWhereUniqueInput
    /**
     * In case the LibraryRequest found by the `where` argument doesn't exist, create a new LibraryRequest with this data.
     */
    create: XOR<LibraryRequestCreateInput, LibraryRequestUncheckedCreateInput>
    /**
     * In case the LibraryRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LibraryRequestUpdateInput, LibraryRequestUncheckedUpdateInput>
  }


  /**
   * LibraryRequest delete
   */
  export type LibraryRequestDeleteArgs = {
    /**
     * Select specific fields to fetch from the LibraryRequest
     */
    select?: LibraryRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryRequestInclude | null
    /**
     * Filter which LibraryRequest to delete.
     */
    where: LibraryRequestWhereUniqueInput
  }


  /**
   * LibraryRequest deleteMany
   */
  export type LibraryRequestDeleteManyArgs = {
    /**
     * Filter which LibraryRequests to delete
     */
    where?: LibraryRequestWhereInput
  }


  /**
   * LibraryRequest without action
   */
  export type LibraryRequestArgs = {
    /**
     * Select specific fields to fetch from the LibraryRequest
     */
    select?: LibraryRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryRequestInclude | null
  }



  /**
   * Model QuizCategory
   */


  export type AggregateQuizCategory = {
    _count: QuizCategoryCountAggregateOutputType | null
    _avg: QuizCategoryAvgAggregateOutputType | null
    _sum: QuizCategorySumAggregateOutputType | null
    _min: QuizCategoryMinAggregateOutputType | null
    _max: QuizCategoryMaxAggregateOutputType | null
  }

  export type QuizCategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type QuizCategorySumAggregateOutputType = {
    id: number | null
  }

  export type QuizCategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizCategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizCategoryCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuizCategoryAvgAggregateInputType = {
    id?: true
  }

  export type QuizCategorySumAggregateInputType = {
    id?: true
  }

  export type QuizCategoryMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizCategoryCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuizCategoryAggregateArgs = {
    /**
     * Filter which QuizCategory to aggregate.
     */
    where?: QuizCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizCategories to fetch.
     */
    orderBy?: Enumerable<QuizCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizCategories
    **/
    _count?: true | QuizCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizCategoryMaxAggregateInputType
  }

  export type GetQuizCategoryAggregateType<T extends QuizCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizCategory[P]>
      : GetScalarType<T[P], AggregateQuizCategory[P]>
  }




  export type QuizCategoryGroupByArgs = {
    where?: QuizCategoryWhereInput
    orderBy?: Enumerable<QuizCategoryOrderByWithAggregationInput>
    by: QuizCategoryScalarFieldEnum[]
    having?: QuizCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizCategoryCountAggregateInputType | true
    _avg?: QuizCategoryAvgAggregateInputType
    _sum?: QuizCategorySumAggregateInputType
    _min?: QuizCategoryMinAggregateInputType
    _max?: QuizCategoryMaxAggregateInputType
  }


  export type QuizCategoryGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: QuizCategoryCountAggregateOutputType | null
    _avg: QuizCategoryAvgAggregateOutputType | null
    _sum: QuizCategorySumAggregateOutputType | null
    _min: QuizCategoryMinAggregateOutputType | null
    _max: QuizCategoryMaxAggregateOutputType | null
  }

  type GetQuizCategoryGroupByPayload<T extends QuizCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<QuizCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], QuizCategoryGroupByOutputType[P]>
        }
      >
    >


  export type QuizCategorySelect = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    QuizQuestion?: boolean | QuizCategory$QuizQuestionArgs
    QuizRound?: boolean | QuizCategory$QuizRoundArgs
    _count?: boolean | QuizCategoryCountOutputTypeArgs
  }


  export type QuizCategoryInclude = {
    QuizQuestion?: boolean | QuizCategory$QuizQuestionArgs
    QuizRound?: boolean | QuizCategory$QuizRoundArgs
    _count?: boolean | QuizCategoryCountOutputTypeArgs
  }

  export type QuizCategoryGetPayload<S extends boolean | null | undefined | QuizCategoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? QuizCategory :
    S extends undefined ? never :
    S extends { include: any } & (QuizCategoryArgs | QuizCategoryFindManyArgs)
    ? QuizCategory  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'QuizQuestion' ? Array < QuizQuestionGetPayload<S['include'][P]>>  :
        P extends 'QuizRound' ? Array < QuizRoundGetPayload<S['include'][P]>>  :
        P extends '_count' ? QuizCategoryCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (QuizCategoryArgs | QuizCategoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'QuizQuestion' ? Array < QuizQuestionGetPayload<S['select'][P]>>  :
        P extends 'QuizRound' ? Array < QuizRoundGetPayload<S['select'][P]>>  :
        P extends '_count' ? QuizCategoryCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof QuizCategory ? QuizCategory[P] : never
  } 
      : QuizCategory


  type QuizCategoryCountArgs = 
    Omit<QuizCategoryFindManyArgs, 'select' | 'include'> & {
      select?: QuizCategoryCountAggregateInputType | true
    }

  export interface QuizCategoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one QuizCategory that matches the filter.
     * @param {QuizCategoryFindUniqueArgs} args - Arguments to find a QuizCategory
     * @example
     * // Get one QuizCategory
     * const quizCategory = await prisma.quizCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuizCategoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, QuizCategoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'QuizCategory'> extends True ? Prisma__QuizCategoryClient<QuizCategoryGetPayload<T>> : Prisma__QuizCategoryClient<QuizCategoryGetPayload<T> | null, null>

    /**
     * Find one QuizCategory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {QuizCategoryFindUniqueOrThrowArgs} args - Arguments to find a QuizCategory
     * @example
     * // Get one QuizCategory
     * const quizCategory = await prisma.quizCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QuizCategoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, QuizCategoryFindUniqueOrThrowArgs>
    ): Prisma__QuizCategoryClient<QuizCategoryGetPayload<T>>

    /**
     * Find the first QuizCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizCategoryFindFirstArgs} args - Arguments to find a QuizCategory
     * @example
     * // Get one QuizCategory
     * const quizCategory = await prisma.quizCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuizCategoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, QuizCategoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'QuizCategory'> extends True ? Prisma__QuizCategoryClient<QuizCategoryGetPayload<T>> : Prisma__QuizCategoryClient<QuizCategoryGetPayload<T> | null, null>

    /**
     * Find the first QuizCategory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizCategoryFindFirstOrThrowArgs} args - Arguments to find a QuizCategory
     * @example
     * // Get one QuizCategory
     * const quizCategory = await prisma.quizCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QuizCategoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, QuizCategoryFindFirstOrThrowArgs>
    ): Prisma__QuizCategoryClient<QuizCategoryGetPayload<T>>

    /**
     * Find zero or more QuizCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizCategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizCategories
     * const quizCategories = await prisma.quizCategory.findMany()
     * 
     * // Get first 10 QuizCategories
     * const quizCategories = await prisma.quizCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizCategoryWithIdOnly = await prisma.quizCategory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends QuizCategoryFindManyArgs>(
      args?: SelectSubset<T, QuizCategoryFindManyArgs>
    ): Prisma.PrismaPromise<Array<QuizCategoryGetPayload<T>>>

    /**
     * Create a QuizCategory.
     * @param {QuizCategoryCreateArgs} args - Arguments to create a QuizCategory.
     * @example
     * // Create one QuizCategory
     * const QuizCategory = await prisma.quizCategory.create({
     *   data: {
     *     // ... data to create a QuizCategory
     *   }
     * })
     * 
    **/
    create<T extends QuizCategoryCreateArgs>(
      args: SelectSubset<T, QuizCategoryCreateArgs>
    ): Prisma__QuizCategoryClient<QuizCategoryGetPayload<T>>

    /**
     * Create many QuizCategories.
     *     @param {QuizCategoryCreateManyArgs} args - Arguments to create many QuizCategories.
     *     @example
     *     // Create many QuizCategories
     *     const quizCategory = await prisma.quizCategory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QuizCategoryCreateManyArgs>(
      args?: SelectSubset<T, QuizCategoryCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QuizCategory.
     * @param {QuizCategoryDeleteArgs} args - Arguments to delete one QuizCategory.
     * @example
     * // Delete one QuizCategory
     * const QuizCategory = await prisma.quizCategory.delete({
     *   where: {
     *     // ... filter to delete one QuizCategory
     *   }
     * })
     * 
    **/
    delete<T extends QuizCategoryDeleteArgs>(
      args: SelectSubset<T, QuizCategoryDeleteArgs>
    ): Prisma__QuizCategoryClient<QuizCategoryGetPayload<T>>

    /**
     * Update one QuizCategory.
     * @param {QuizCategoryUpdateArgs} args - Arguments to update one QuizCategory.
     * @example
     * // Update one QuizCategory
     * const quizCategory = await prisma.quizCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuizCategoryUpdateArgs>(
      args: SelectSubset<T, QuizCategoryUpdateArgs>
    ): Prisma__QuizCategoryClient<QuizCategoryGetPayload<T>>

    /**
     * Delete zero or more QuizCategories.
     * @param {QuizCategoryDeleteManyArgs} args - Arguments to filter QuizCategories to delete.
     * @example
     * // Delete a few QuizCategories
     * const { count } = await prisma.quizCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuizCategoryDeleteManyArgs>(
      args?: SelectSubset<T, QuizCategoryDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizCategories
     * const quizCategory = await prisma.quizCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuizCategoryUpdateManyArgs>(
      args: SelectSubset<T, QuizCategoryUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuizCategory.
     * @param {QuizCategoryUpsertArgs} args - Arguments to update or create a QuizCategory.
     * @example
     * // Update or create a QuizCategory
     * const quizCategory = await prisma.quizCategory.upsert({
     *   create: {
     *     // ... data to create a QuizCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizCategory we want to update
     *   }
     * })
    **/
    upsert<T extends QuizCategoryUpsertArgs>(
      args: SelectSubset<T, QuizCategoryUpsertArgs>
    ): Prisma__QuizCategoryClient<QuizCategoryGetPayload<T>>

    /**
     * Count the number of QuizCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizCategoryCountArgs} args - Arguments to filter QuizCategories to count.
     * @example
     * // Count the number of QuizCategories
     * const count = await prisma.quizCategory.count({
     *   where: {
     *     // ... the filter for the QuizCategories we want to count
     *   }
     * })
    **/
    count<T extends QuizCategoryCountArgs>(
      args?: Subset<T, QuizCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizCategoryAggregateArgs>(args: Subset<T, QuizCategoryAggregateArgs>): Prisma.PrismaPromise<GetQuizCategoryAggregateType<T>>

    /**
     * Group by QuizCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizCategoryGroupByArgs['orderBy'] }
        : { orderBy?: QuizCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__QuizCategoryClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    QuizQuestion<T extends QuizCategory$QuizQuestionArgs= {}>(args?: Subset<T, QuizCategory$QuizQuestionArgs>): Prisma.PrismaPromise<Array<QuizQuestionGetPayload<T>>| Null>;

    QuizRound<T extends QuizCategory$QuizRoundArgs= {}>(args?: Subset<T, QuizCategory$QuizRoundArgs>): Prisma.PrismaPromise<Array<QuizRoundGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * QuizCategory base type for findUnique actions
   */
  export type QuizCategoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the QuizCategory
     */
    select?: QuizCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizCategoryInclude | null
    /**
     * Filter, which QuizCategory to fetch.
     */
    where: QuizCategoryWhereUniqueInput
  }

  /**
   * QuizCategory findUnique
   */
  export interface QuizCategoryFindUniqueArgs extends QuizCategoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuizCategory findUniqueOrThrow
   */
  export type QuizCategoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the QuizCategory
     */
    select?: QuizCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizCategoryInclude | null
    /**
     * Filter, which QuizCategory to fetch.
     */
    where: QuizCategoryWhereUniqueInput
  }


  /**
   * QuizCategory base type for findFirst actions
   */
  export type QuizCategoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the QuizCategory
     */
    select?: QuizCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizCategoryInclude | null
    /**
     * Filter, which QuizCategory to fetch.
     */
    where?: QuizCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizCategories to fetch.
     */
    orderBy?: Enumerable<QuizCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizCategories.
     */
    cursor?: QuizCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizCategories.
     */
    distinct?: Enumerable<QuizCategoryScalarFieldEnum>
  }

  /**
   * QuizCategory findFirst
   */
  export interface QuizCategoryFindFirstArgs extends QuizCategoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuizCategory findFirstOrThrow
   */
  export type QuizCategoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the QuizCategory
     */
    select?: QuizCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizCategoryInclude | null
    /**
     * Filter, which QuizCategory to fetch.
     */
    where?: QuizCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizCategories to fetch.
     */
    orderBy?: Enumerable<QuizCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizCategories.
     */
    cursor?: QuizCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizCategories.
     */
    distinct?: Enumerable<QuizCategoryScalarFieldEnum>
  }


  /**
   * QuizCategory findMany
   */
  export type QuizCategoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the QuizCategory
     */
    select?: QuizCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizCategoryInclude | null
    /**
     * Filter, which QuizCategories to fetch.
     */
    where?: QuizCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizCategories to fetch.
     */
    orderBy?: Enumerable<QuizCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizCategories.
     */
    cursor?: QuizCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizCategories.
     */
    skip?: number
    distinct?: Enumerable<QuizCategoryScalarFieldEnum>
  }


  /**
   * QuizCategory create
   */
  export type QuizCategoryCreateArgs = {
    /**
     * Select specific fields to fetch from the QuizCategory
     */
    select?: QuizCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizCategoryInclude | null
    /**
     * The data needed to create a QuizCategory.
     */
    data: XOR<QuizCategoryCreateInput, QuizCategoryUncheckedCreateInput>
  }


  /**
   * QuizCategory createMany
   */
  export type QuizCategoryCreateManyArgs = {
    /**
     * The data used to create many QuizCategories.
     */
    data: Enumerable<QuizCategoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * QuizCategory update
   */
  export type QuizCategoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the QuizCategory
     */
    select?: QuizCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizCategoryInclude | null
    /**
     * The data needed to update a QuizCategory.
     */
    data: XOR<QuizCategoryUpdateInput, QuizCategoryUncheckedUpdateInput>
    /**
     * Choose, which QuizCategory to update.
     */
    where: QuizCategoryWhereUniqueInput
  }


  /**
   * QuizCategory updateMany
   */
  export type QuizCategoryUpdateManyArgs = {
    /**
     * The data used to update QuizCategories.
     */
    data: XOR<QuizCategoryUpdateManyMutationInput, QuizCategoryUncheckedUpdateManyInput>
    /**
     * Filter which QuizCategories to update
     */
    where?: QuizCategoryWhereInput
  }


  /**
   * QuizCategory upsert
   */
  export type QuizCategoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the QuizCategory
     */
    select?: QuizCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizCategoryInclude | null
    /**
     * The filter to search for the QuizCategory to update in case it exists.
     */
    where: QuizCategoryWhereUniqueInput
    /**
     * In case the QuizCategory found by the `where` argument doesn't exist, create a new QuizCategory with this data.
     */
    create: XOR<QuizCategoryCreateInput, QuizCategoryUncheckedCreateInput>
    /**
     * In case the QuizCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizCategoryUpdateInput, QuizCategoryUncheckedUpdateInput>
  }


  /**
   * QuizCategory delete
   */
  export type QuizCategoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the QuizCategory
     */
    select?: QuizCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizCategoryInclude | null
    /**
     * Filter which QuizCategory to delete.
     */
    where: QuizCategoryWhereUniqueInput
  }


  /**
   * QuizCategory deleteMany
   */
  export type QuizCategoryDeleteManyArgs = {
    /**
     * Filter which QuizCategories to delete
     */
    where?: QuizCategoryWhereInput
  }


  /**
   * QuizCategory.QuizQuestion
   */
  export type QuizCategory$QuizQuestionArgs = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizQuestionInclude | null
    where?: QuizQuestionWhereInput
    orderBy?: Enumerable<QuizQuestionOrderByWithRelationInput>
    cursor?: QuizQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<QuizQuestionScalarFieldEnum>
  }


  /**
   * QuizCategory.QuizRound
   */
  export type QuizCategory$QuizRoundArgs = {
    /**
     * Select specific fields to fetch from the QuizRound
     */
    select?: QuizRoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRoundInclude | null
    where?: QuizRoundWhereInput
    orderBy?: Enumerable<QuizRoundOrderByWithRelationInput>
    cursor?: QuizRoundWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<QuizRoundScalarFieldEnum>
  }


  /**
   * QuizCategory without action
   */
  export type QuizCategoryArgs = {
    /**
     * Select specific fields to fetch from the QuizCategory
     */
    select?: QuizCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizCategoryInclude | null
  }



  /**
   * Model QuizQuestion
   */


  export type AggregateQuizQuestion = {
    _count: QuizQuestionCountAggregateOutputType | null
    _avg: QuizQuestionAvgAggregateOutputType | null
    _sum: QuizQuestionSumAggregateOutputType | null
    _min: QuizQuestionMinAggregateOutputType | null
    _max: QuizQuestionMaxAggregateOutputType | null
  }

  export type QuizQuestionAvgAggregateOutputType = {
    id: number | null
    answerId: number | null
    quizCategoryId: number | null
  }

  export type QuizQuestionSumAggregateOutputType = {
    id: number | null
    answerId: number | null
    quizCategoryId: number | null
  }

  export type QuizQuestionMinAggregateOutputType = {
    id: number | null
    name: string | null
    answerId: number | null
    quizCategoryId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizQuestionMaxAggregateOutputType = {
    id: number | null
    name: string | null
    answerId: number | null
    quizCategoryId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizQuestionCountAggregateOutputType = {
    id: number
    name: number
    answerId: number
    quizCategoryId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuizQuestionAvgAggregateInputType = {
    id?: true
    answerId?: true
    quizCategoryId?: true
  }

  export type QuizQuestionSumAggregateInputType = {
    id?: true
    answerId?: true
    quizCategoryId?: true
  }

  export type QuizQuestionMinAggregateInputType = {
    id?: true
    name?: true
    answerId?: true
    quizCategoryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizQuestionMaxAggregateInputType = {
    id?: true
    name?: true
    answerId?: true
    quizCategoryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizQuestionCountAggregateInputType = {
    id?: true
    name?: true
    answerId?: true
    quizCategoryId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuizQuestionAggregateArgs = {
    /**
     * Filter which QuizQuestion to aggregate.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: Enumerable<QuizQuestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizQuestions
    **/
    _count?: true | QuizQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizQuestionMaxAggregateInputType
  }

  export type GetQuizQuestionAggregateType<T extends QuizQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizQuestion[P]>
      : GetScalarType<T[P], AggregateQuizQuestion[P]>
  }




  export type QuizQuestionGroupByArgs = {
    where?: QuizQuestionWhereInput
    orderBy?: Enumerable<QuizQuestionOrderByWithAggregationInput>
    by: QuizQuestionScalarFieldEnum[]
    having?: QuizQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizQuestionCountAggregateInputType | true
    _avg?: QuizQuestionAvgAggregateInputType
    _sum?: QuizQuestionSumAggregateInputType
    _min?: QuizQuestionMinAggregateInputType
    _max?: QuizQuestionMaxAggregateInputType
  }


  export type QuizQuestionGroupByOutputType = {
    id: number
    name: string
    answerId: number
    quizCategoryId: number | null
    createdAt: Date
    updatedAt: Date
    _count: QuizQuestionCountAggregateOutputType | null
    _avg: QuizQuestionAvgAggregateOutputType | null
    _sum: QuizQuestionSumAggregateOutputType | null
    _min: QuizQuestionMinAggregateOutputType | null
    _max: QuizQuestionMaxAggregateOutputType | null
  }

  type GetQuizQuestionGroupByPayload<T extends QuizQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<QuizQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], QuizQuestionGroupByOutputType[P]>
        }
      >
    >


  export type QuizQuestionSelect = {
    id?: boolean
    name?: boolean
    answerId?: boolean
    category?: boolean | QuizCategoryArgs
    quizCategoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quizChoices?: boolean | QuizQuestion$quizChoicesArgs
    quizRecords?: boolean | QuizQuestion$quizRecordsArgs
    _count?: boolean | QuizQuestionCountOutputTypeArgs
  }


  export type QuizQuestionInclude = {
    category?: boolean | QuizCategoryArgs
    quizChoices?: boolean | QuizQuestion$quizChoicesArgs
    quizRecords?: boolean | QuizQuestion$quizRecordsArgs
    _count?: boolean | QuizQuestionCountOutputTypeArgs
  }

  export type QuizQuestionGetPayload<S extends boolean | null | undefined | QuizQuestionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? QuizQuestion :
    S extends undefined ? never :
    S extends { include: any } & (QuizQuestionArgs | QuizQuestionFindManyArgs)
    ? QuizQuestion  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'category' ? QuizCategoryGetPayload<S['include'][P]> | null :
        P extends 'quizChoices' ? Array < QuizChoiceGetPayload<S['include'][P]>>  :
        P extends 'quizRecords' ? Array < QuizRecordGetPayload<S['include'][P]>>  :
        P extends '_count' ? QuizQuestionCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (QuizQuestionArgs | QuizQuestionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'category' ? QuizCategoryGetPayload<S['select'][P]> | null :
        P extends 'quizChoices' ? Array < QuizChoiceGetPayload<S['select'][P]>>  :
        P extends 'quizRecords' ? Array < QuizRecordGetPayload<S['select'][P]>>  :
        P extends '_count' ? QuizQuestionCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof QuizQuestion ? QuizQuestion[P] : never
  } 
      : QuizQuestion


  type QuizQuestionCountArgs = 
    Omit<QuizQuestionFindManyArgs, 'select' | 'include'> & {
      select?: QuizQuestionCountAggregateInputType | true
    }

  export interface QuizQuestionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one QuizQuestion that matches the filter.
     * @param {QuizQuestionFindUniqueArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuizQuestionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, QuizQuestionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'QuizQuestion'> extends True ? Prisma__QuizQuestionClient<QuizQuestionGetPayload<T>> : Prisma__QuizQuestionClient<QuizQuestionGetPayload<T> | null, null>

    /**
     * Find one QuizQuestion that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {QuizQuestionFindUniqueOrThrowArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QuizQuestionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, QuizQuestionFindUniqueOrThrowArgs>
    ): Prisma__QuizQuestionClient<QuizQuestionGetPayload<T>>

    /**
     * Find the first QuizQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionFindFirstArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuizQuestionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, QuizQuestionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'QuizQuestion'> extends True ? Prisma__QuizQuestionClient<QuizQuestionGetPayload<T>> : Prisma__QuizQuestionClient<QuizQuestionGetPayload<T> | null, null>

    /**
     * Find the first QuizQuestion that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionFindFirstOrThrowArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QuizQuestionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, QuizQuestionFindFirstOrThrowArgs>
    ): Prisma__QuizQuestionClient<QuizQuestionGetPayload<T>>

    /**
     * Find zero or more QuizQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizQuestions
     * const quizQuestions = await prisma.quizQuestion.findMany()
     * 
     * // Get first 10 QuizQuestions
     * const quizQuestions = await prisma.quizQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizQuestionWithIdOnly = await prisma.quizQuestion.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends QuizQuestionFindManyArgs>(
      args?: SelectSubset<T, QuizQuestionFindManyArgs>
    ): Prisma.PrismaPromise<Array<QuizQuestionGetPayload<T>>>

    /**
     * Create a QuizQuestion.
     * @param {QuizQuestionCreateArgs} args - Arguments to create a QuizQuestion.
     * @example
     * // Create one QuizQuestion
     * const QuizQuestion = await prisma.quizQuestion.create({
     *   data: {
     *     // ... data to create a QuizQuestion
     *   }
     * })
     * 
    **/
    create<T extends QuizQuestionCreateArgs>(
      args: SelectSubset<T, QuizQuestionCreateArgs>
    ): Prisma__QuizQuestionClient<QuizQuestionGetPayload<T>>

    /**
     * Create many QuizQuestions.
     *     @param {QuizQuestionCreateManyArgs} args - Arguments to create many QuizQuestions.
     *     @example
     *     // Create many QuizQuestions
     *     const quizQuestion = await prisma.quizQuestion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QuizQuestionCreateManyArgs>(
      args?: SelectSubset<T, QuizQuestionCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QuizQuestion.
     * @param {QuizQuestionDeleteArgs} args - Arguments to delete one QuizQuestion.
     * @example
     * // Delete one QuizQuestion
     * const QuizQuestion = await prisma.quizQuestion.delete({
     *   where: {
     *     // ... filter to delete one QuizQuestion
     *   }
     * })
     * 
    **/
    delete<T extends QuizQuestionDeleteArgs>(
      args: SelectSubset<T, QuizQuestionDeleteArgs>
    ): Prisma__QuizQuestionClient<QuizQuestionGetPayload<T>>

    /**
     * Update one QuizQuestion.
     * @param {QuizQuestionUpdateArgs} args - Arguments to update one QuizQuestion.
     * @example
     * // Update one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuizQuestionUpdateArgs>(
      args: SelectSubset<T, QuizQuestionUpdateArgs>
    ): Prisma__QuizQuestionClient<QuizQuestionGetPayload<T>>

    /**
     * Delete zero or more QuizQuestions.
     * @param {QuizQuestionDeleteManyArgs} args - Arguments to filter QuizQuestions to delete.
     * @example
     * // Delete a few QuizQuestions
     * const { count } = await prisma.quizQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuizQuestionDeleteManyArgs>(
      args?: SelectSubset<T, QuizQuestionDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizQuestions
     * const quizQuestion = await prisma.quizQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuizQuestionUpdateManyArgs>(
      args: SelectSubset<T, QuizQuestionUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuizQuestion.
     * @param {QuizQuestionUpsertArgs} args - Arguments to update or create a QuizQuestion.
     * @example
     * // Update or create a QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.upsert({
     *   create: {
     *     // ... data to create a QuizQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizQuestion we want to update
     *   }
     * })
    **/
    upsert<T extends QuizQuestionUpsertArgs>(
      args: SelectSubset<T, QuizQuestionUpsertArgs>
    ): Prisma__QuizQuestionClient<QuizQuestionGetPayload<T>>

    /**
     * Count the number of QuizQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionCountArgs} args - Arguments to filter QuizQuestions to count.
     * @example
     * // Count the number of QuizQuestions
     * const count = await prisma.quizQuestion.count({
     *   where: {
     *     // ... the filter for the QuizQuestions we want to count
     *   }
     * })
    **/
    count<T extends QuizQuestionCountArgs>(
      args?: Subset<T, QuizQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizQuestionAggregateArgs>(args: Subset<T, QuizQuestionAggregateArgs>): Prisma.PrismaPromise<GetQuizQuestionAggregateType<T>>

    /**
     * Group by QuizQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizQuestionGroupByArgs['orderBy'] }
        : { orderBy?: QuizQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__QuizQuestionClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    category<T extends QuizCategoryArgs= {}>(args?: Subset<T, QuizCategoryArgs>): Prisma__QuizCategoryClient<QuizCategoryGetPayload<T> | Null>;

    quizChoices<T extends QuizQuestion$quizChoicesArgs= {}>(args?: Subset<T, QuizQuestion$quizChoicesArgs>): Prisma.PrismaPromise<Array<QuizChoiceGetPayload<T>>| Null>;

    quizRecords<T extends QuizQuestion$quizRecordsArgs= {}>(args?: Subset<T, QuizQuestion$quizRecordsArgs>): Prisma.PrismaPromise<Array<QuizRecordGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * QuizQuestion base type for findUnique actions
   */
  export type QuizQuestionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizQuestionInclude | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where: QuizQuestionWhereUniqueInput
  }

  /**
   * QuizQuestion findUnique
   */
  export interface QuizQuestionFindUniqueArgs extends QuizQuestionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuizQuestion findUniqueOrThrow
   */
  export type QuizQuestionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizQuestionInclude | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where: QuizQuestionWhereUniqueInput
  }


  /**
   * QuizQuestion base type for findFirst actions
   */
  export type QuizQuestionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizQuestionInclude | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: Enumerable<QuizQuestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizQuestions.
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizQuestions.
     */
    distinct?: Enumerable<QuizQuestionScalarFieldEnum>
  }

  /**
   * QuizQuestion findFirst
   */
  export interface QuizQuestionFindFirstArgs extends QuizQuestionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuizQuestion findFirstOrThrow
   */
  export type QuizQuestionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizQuestionInclude | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: Enumerable<QuizQuestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizQuestions.
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizQuestions.
     */
    distinct?: Enumerable<QuizQuestionScalarFieldEnum>
  }


  /**
   * QuizQuestion findMany
   */
  export type QuizQuestionFindManyArgs = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizQuestionInclude | null
    /**
     * Filter, which QuizQuestions to fetch.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: Enumerable<QuizQuestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizQuestions.
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    distinct?: Enumerable<QuizQuestionScalarFieldEnum>
  }


  /**
   * QuizQuestion create
   */
  export type QuizQuestionCreateArgs = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizQuestionInclude | null
    /**
     * The data needed to create a QuizQuestion.
     */
    data: XOR<QuizQuestionCreateInput, QuizQuestionUncheckedCreateInput>
  }


  /**
   * QuizQuestion createMany
   */
  export type QuizQuestionCreateManyArgs = {
    /**
     * The data used to create many QuizQuestions.
     */
    data: Enumerable<QuizQuestionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * QuizQuestion update
   */
  export type QuizQuestionUpdateArgs = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizQuestionInclude | null
    /**
     * The data needed to update a QuizQuestion.
     */
    data: XOR<QuizQuestionUpdateInput, QuizQuestionUncheckedUpdateInput>
    /**
     * Choose, which QuizQuestion to update.
     */
    where: QuizQuestionWhereUniqueInput
  }


  /**
   * QuizQuestion updateMany
   */
  export type QuizQuestionUpdateManyArgs = {
    /**
     * The data used to update QuizQuestions.
     */
    data: XOR<QuizQuestionUpdateManyMutationInput, QuizQuestionUncheckedUpdateManyInput>
    /**
     * Filter which QuizQuestions to update
     */
    where?: QuizQuestionWhereInput
  }


  /**
   * QuizQuestion upsert
   */
  export type QuizQuestionUpsertArgs = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizQuestionInclude | null
    /**
     * The filter to search for the QuizQuestion to update in case it exists.
     */
    where: QuizQuestionWhereUniqueInput
    /**
     * In case the QuizQuestion found by the `where` argument doesn't exist, create a new QuizQuestion with this data.
     */
    create: XOR<QuizQuestionCreateInput, QuizQuestionUncheckedCreateInput>
    /**
     * In case the QuizQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizQuestionUpdateInput, QuizQuestionUncheckedUpdateInput>
  }


  /**
   * QuizQuestion delete
   */
  export type QuizQuestionDeleteArgs = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizQuestionInclude | null
    /**
     * Filter which QuizQuestion to delete.
     */
    where: QuizQuestionWhereUniqueInput
  }


  /**
   * QuizQuestion deleteMany
   */
  export type QuizQuestionDeleteManyArgs = {
    /**
     * Filter which QuizQuestions to delete
     */
    where?: QuizQuestionWhereInput
  }


  /**
   * QuizQuestion.quizChoices
   */
  export type QuizQuestion$quizChoicesArgs = {
    /**
     * Select specific fields to fetch from the QuizChoice
     */
    select?: QuizChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizChoiceInclude | null
    where?: QuizChoiceWhereInput
    orderBy?: Enumerable<QuizChoiceOrderByWithRelationInput>
    cursor?: QuizChoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<QuizChoiceScalarFieldEnum>
  }


  /**
   * QuizQuestion.quizRecords
   */
  export type QuizQuestion$quizRecordsArgs = {
    /**
     * Select specific fields to fetch from the QuizRecord
     */
    select?: QuizRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRecordInclude | null
    where?: QuizRecordWhereInput
    orderBy?: Enumerable<QuizRecordOrderByWithRelationInput>
    cursor?: QuizRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<QuizRecordScalarFieldEnum>
  }


  /**
   * QuizQuestion without action
   */
  export type QuizQuestionArgs = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizQuestionInclude | null
  }



  /**
   * Model QuizChoice
   */


  export type AggregateQuizChoice = {
    _count: QuizChoiceCountAggregateOutputType | null
    _avg: QuizChoiceAvgAggregateOutputType | null
    _sum: QuizChoiceSumAggregateOutputType | null
    _min: QuizChoiceMinAggregateOutputType | null
    _max: QuizChoiceMaxAggregateOutputType | null
  }

  export type QuizChoiceAvgAggregateOutputType = {
    id: number | null
    quizQuestionId: number | null
  }

  export type QuizChoiceSumAggregateOutputType = {
    id: number | null
    quizQuestionId: number | null
  }

  export type QuizChoiceMinAggregateOutputType = {
    id: number | null
    name: string | null
    quizQuestionId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizChoiceMaxAggregateOutputType = {
    id: number | null
    name: string | null
    quizQuestionId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizChoiceCountAggregateOutputType = {
    id: number
    name: number
    quizQuestionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuizChoiceAvgAggregateInputType = {
    id?: true
    quizQuestionId?: true
  }

  export type QuizChoiceSumAggregateInputType = {
    id?: true
    quizQuestionId?: true
  }

  export type QuizChoiceMinAggregateInputType = {
    id?: true
    name?: true
    quizQuestionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizChoiceMaxAggregateInputType = {
    id?: true
    name?: true
    quizQuestionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizChoiceCountAggregateInputType = {
    id?: true
    name?: true
    quizQuestionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuizChoiceAggregateArgs = {
    /**
     * Filter which QuizChoice to aggregate.
     */
    where?: QuizChoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizChoices to fetch.
     */
    orderBy?: Enumerable<QuizChoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizChoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizChoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizChoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizChoices
    **/
    _count?: true | QuizChoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizChoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizChoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizChoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizChoiceMaxAggregateInputType
  }

  export type GetQuizChoiceAggregateType<T extends QuizChoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizChoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizChoice[P]>
      : GetScalarType<T[P], AggregateQuizChoice[P]>
  }




  export type QuizChoiceGroupByArgs = {
    where?: QuizChoiceWhereInput
    orderBy?: Enumerable<QuizChoiceOrderByWithAggregationInput>
    by: QuizChoiceScalarFieldEnum[]
    having?: QuizChoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizChoiceCountAggregateInputType | true
    _avg?: QuizChoiceAvgAggregateInputType
    _sum?: QuizChoiceSumAggregateInputType
    _min?: QuizChoiceMinAggregateInputType
    _max?: QuizChoiceMaxAggregateInputType
  }


  export type QuizChoiceGroupByOutputType = {
    id: number
    name: string
    quizQuestionId: number
    createdAt: Date
    updatedAt: Date
    _count: QuizChoiceCountAggregateOutputType | null
    _avg: QuizChoiceAvgAggregateOutputType | null
    _sum: QuizChoiceSumAggregateOutputType | null
    _min: QuizChoiceMinAggregateOutputType | null
    _max: QuizChoiceMaxAggregateOutputType | null
  }

  type GetQuizChoiceGroupByPayload<T extends QuizChoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<QuizChoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizChoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizChoiceGroupByOutputType[P]>
            : GetScalarType<T[P], QuizChoiceGroupByOutputType[P]>
        }
      >
    >


  export type QuizChoiceSelect = {
    id?: boolean
    name?: boolean
    question?: boolean | QuizQuestionArgs
    quizQuestionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quizRecords?: boolean | QuizChoice$quizRecordsArgs
    _count?: boolean | QuizChoiceCountOutputTypeArgs
  }


  export type QuizChoiceInclude = {
    question?: boolean | QuizQuestionArgs
    quizRecords?: boolean | QuizChoice$quizRecordsArgs
    _count?: boolean | QuizChoiceCountOutputTypeArgs
  }

  export type QuizChoiceGetPayload<S extends boolean | null | undefined | QuizChoiceArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? QuizChoice :
    S extends undefined ? never :
    S extends { include: any } & (QuizChoiceArgs | QuizChoiceFindManyArgs)
    ? QuizChoice  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'question' ? QuizQuestionGetPayload<S['include'][P]> | null :
        P extends 'quizRecords' ? Array < QuizRecordGetPayload<S['include'][P]>>  :
        P extends '_count' ? QuizChoiceCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (QuizChoiceArgs | QuizChoiceFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'question' ? QuizQuestionGetPayload<S['select'][P]> | null :
        P extends 'quizRecords' ? Array < QuizRecordGetPayload<S['select'][P]>>  :
        P extends '_count' ? QuizChoiceCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof QuizChoice ? QuizChoice[P] : never
  } 
      : QuizChoice


  type QuizChoiceCountArgs = 
    Omit<QuizChoiceFindManyArgs, 'select' | 'include'> & {
      select?: QuizChoiceCountAggregateInputType | true
    }

  export interface QuizChoiceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one QuizChoice that matches the filter.
     * @param {QuizChoiceFindUniqueArgs} args - Arguments to find a QuizChoice
     * @example
     * // Get one QuizChoice
     * const quizChoice = await prisma.quizChoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuizChoiceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, QuizChoiceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'QuizChoice'> extends True ? Prisma__QuizChoiceClient<QuizChoiceGetPayload<T>> : Prisma__QuizChoiceClient<QuizChoiceGetPayload<T> | null, null>

    /**
     * Find one QuizChoice that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {QuizChoiceFindUniqueOrThrowArgs} args - Arguments to find a QuizChoice
     * @example
     * // Get one QuizChoice
     * const quizChoice = await prisma.quizChoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QuizChoiceFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, QuizChoiceFindUniqueOrThrowArgs>
    ): Prisma__QuizChoiceClient<QuizChoiceGetPayload<T>>

    /**
     * Find the first QuizChoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizChoiceFindFirstArgs} args - Arguments to find a QuizChoice
     * @example
     * // Get one QuizChoice
     * const quizChoice = await prisma.quizChoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuizChoiceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, QuizChoiceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'QuizChoice'> extends True ? Prisma__QuizChoiceClient<QuizChoiceGetPayload<T>> : Prisma__QuizChoiceClient<QuizChoiceGetPayload<T> | null, null>

    /**
     * Find the first QuizChoice that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizChoiceFindFirstOrThrowArgs} args - Arguments to find a QuizChoice
     * @example
     * // Get one QuizChoice
     * const quizChoice = await prisma.quizChoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QuizChoiceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, QuizChoiceFindFirstOrThrowArgs>
    ): Prisma__QuizChoiceClient<QuizChoiceGetPayload<T>>

    /**
     * Find zero or more QuizChoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizChoiceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizChoices
     * const quizChoices = await prisma.quizChoice.findMany()
     * 
     * // Get first 10 QuizChoices
     * const quizChoices = await prisma.quizChoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizChoiceWithIdOnly = await prisma.quizChoice.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends QuizChoiceFindManyArgs>(
      args?: SelectSubset<T, QuizChoiceFindManyArgs>
    ): Prisma.PrismaPromise<Array<QuizChoiceGetPayload<T>>>

    /**
     * Create a QuizChoice.
     * @param {QuizChoiceCreateArgs} args - Arguments to create a QuizChoice.
     * @example
     * // Create one QuizChoice
     * const QuizChoice = await prisma.quizChoice.create({
     *   data: {
     *     // ... data to create a QuizChoice
     *   }
     * })
     * 
    **/
    create<T extends QuizChoiceCreateArgs>(
      args: SelectSubset<T, QuizChoiceCreateArgs>
    ): Prisma__QuizChoiceClient<QuizChoiceGetPayload<T>>

    /**
     * Create many QuizChoices.
     *     @param {QuizChoiceCreateManyArgs} args - Arguments to create many QuizChoices.
     *     @example
     *     // Create many QuizChoices
     *     const quizChoice = await prisma.quizChoice.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QuizChoiceCreateManyArgs>(
      args?: SelectSubset<T, QuizChoiceCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QuizChoice.
     * @param {QuizChoiceDeleteArgs} args - Arguments to delete one QuizChoice.
     * @example
     * // Delete one QuizChoice
     * const QuizChoice = await prisma.quizChoice.delete({
     *   where: {
     *     // ... filter to delete one QuizChoice
     *   }
     * })
     * 
    **/
    delete<T extends QuizChoiceDeleteArgs>(
      args: SelectSubset<T, QuizChoiceDeleteArgs>
    ): Prisma__QuizChoiceClient<QuizChoiceGetPayload<T>>

    /**
     * Update one QuizChoice.
     * @param {QuizChoiceUpdateArgs} args - Arguments to update one QuizChoice.
     * @example
     * // Update one QuizChoice
     * const quizChoice = await prisma.quizChoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuizChoiceUpdateArgs>(
      args: SelectSubset<T, QuizChoiceUpdateArgs>
    ): Prisma__QuizChoiceClient<QuizChoiceGetPayload<T>>

    /**
     * Delete zero or more QuizChoices.
     * @param {QuizChoiceDeleteManyArgs} args - Arguments to filter QuizChoices to delete.
     * @example
     * // Delete a few QuizChoices
     * const { count } = await prisma.quizChoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuizChoiceDeleteManyArgs>(
      args?: SelectSubset<T, QuizChoiceDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizChoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizChoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizChoices
     * const quizChoice = await prisma.quizChoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuizChoiceUpdateManyArgs>(
      args: SelectSubset<T, QuizChoiceUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuizChoice.
     * @param {QuizChoiceUpsertArgs} args - Arguments to update or create a QuizChoice.
     * @example
     * // Update or create a QuizChoice
     * const quizChoice = await prisma.quizChoice.upsert({
     *   create: {
     *     // ... data to create a QuizChoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizChoice we want to update
     *   }
     * })
    **/
    upsert<T extends QuizChoiceUpsertArgs>(
      args: SelectSubset<T, QuizChoiceUpsertArgs>
    ): Prisma__QuizChoiceClient<QuizChoiceGetPayload<T>>

    /**
     * Count the number of QuizChoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizChoiceCountArgs} args - Arguments to filter QuizChoices to count.
     * @example
     * // Count the number of QuizChoices
     * const count = await prisma.quizChoice.count({
     *   where: {
     *     // ... the filter for the QuizChoices we want to count
     *   }
     * })
    **/
    count<T extends QuizChoiceCountArgs>(
      args?: Subset<T, QuizChoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizChoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizChoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizChoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizChoiceAggregateArgs>(args: Subset<T, QuizChoiceAggregateArgs>): Prisma.PrismaPromise<GetQuizChoiceAggregateType<T>>

    /**
     * Group by QuizChoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizChoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizChoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizChoiceGroupByArgs['orderBy'] }
        : { orderBy?: QuizChoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizChoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizChoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizChoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__QuizChoiceClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    question<T extends QuizQuestionArgs= {}>(args?: Subset<T, QuizQuestionArgs>): Prisma__QuizQuestionClient<QuizQuestionGetPayload<T> | Null>;

    quizRecords<T extends QuizChoice$quizRecordsArgs= {}>(args?: Subset<T, QuizChoice$quizRecordsArgs>): Prisma.PrismaPromise<Array<QuizRecordGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * QuizChoice base type for findUnique actions
   */
  export type QuizChoiceFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the QuizChoice
     */
    select?: QuizChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizChoiceInclude | null
    /**
     * Filter, which QuizChoice to fetch.
     */
    where: QuizChoiceWhereUniqueInput
  }

  /**
   * QuizChoice findUnique
   */
  export interface QuizChoiceFindUniqueArgs extends QuizChoiceFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuizChoice findUniqueOrThrow
   */
  export type QuizChoiceFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the QuizChoice
     */
    select?: QuizChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizChoiceInclude | null
    /**
     * Filter, which QuizChoice to fetch.
     */
    where: QuizChoiceWhereUniqueInput
  }


  /**
   * QuizChoice base type for findFirst actions
   */
  export type QuizChoiceFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the QuizChoice
     */
    select?: QuizChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizChoiceInclude | null
    /**
     * Filter, which QuizChoice to fetch.
     */
    where?: QuizChoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizChoices to fetch.
     */
    orderBy?: Enumerable<QuizChoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizChoices.
     */
    cursor?: QuizChoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizChoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizChoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizChoices.
     */
    distinct?: Enumerable<QuizChoiceScalarFieldEnum>
  }

  /**
   * QuizChoice findFirst
   */
  export interface QuizChoiceFindFirstArgs extends QuizChoiceFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuizChoice findFirstOrThrow
   */
  export type QuizChoiceFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the QuizChoice
     */
    select?: QuizChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizChoiceInclude | null
    /**
     * Filter, which QuizChoice to fetch.
     */
    where?: QuizChoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizChoices to fetch.
     */
    orderBy?: Enumerable<QuizChoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizChoices.
     */
    cursor?: QuizChoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizChoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizChoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizChoices.
     */
    distinct?: Enumerable<QuizChoiceScalarFieldEnum>
  }


  /**
   * QuizChoice findMany
   */
  export type QuizChoiceFindManyArgs = {
    /**
     * Select specific fields to fetch from the QuizChoice
     */
    select?: QuizChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizChoiceInclude | null
    /**
     * Filter, which QuizChoices to fetch.
     */
    where?: QuizChoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizChoices to fetch.
     */
    orderBy?: Enumerable<QuizChoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizChoices.
     */
    cursor?: QuizChoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizChoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizChoices.
     */
    skip?: number
    distinct?: Enumerable<QuizChoiceScalarFieldEnum>
  }


  /**
   * QuizChoice create
   */
  export type QuizChoiceCreateArgs = {
    /**
     * Select specific fields to fetch from the QuizChoice
     */
    select?: QuizChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizChoiceInclude | null
    /**
     * The data needed to create a QuizChoice.
     */
    data: XOR<QuizChoiceCreateInput, QuizChoiceUncheckedCreateInput>
  }


  /**
   * QuizChoice createMany
   */
  export type QuizChoiceCreateManyArgs = {
    /**
     * The data used to create many QuizChoices.
     */
    data: Enumerable<QuizChoiceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * QuizChoice update
   */
  export type QuizChoiceUpdateArgs = {
    /**
     * Select specific fields to fetch from the QuizChoice
     */
    select?: QuizChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizChoiceInclude | null
    /**
     * The data needed to update a QuizChoice.
     */
    data: XOR<QuizChoiceUpdateInput, QuizChoiceUncheckedUpdateInput>
    /**
     * Choose, which QuizChoice to update.
     */
    where: QuizChoiceWhereUniqueInput
  }


  /**
   * QuizChoice updateMany
   */
  export type QuizChoiceUpdateManyArgs = {
    /**
     * The data used to update QuizChoices.
     */
    data: XOR<QuizChoiceUpdateManyMutationInput, QuizChoiceUncheckedUpdateManyInput>
    /**
     * Filter which QuizChoices to update
     */
    where?: QuizChoiceWhereInput
  }


  /**
   * QuizChoice upsert
   */
  export type QuizChoiceUpsertArgs = {
    /**
     * Select specific fields to fetch from the QuizChoice
     */
    select?: QuizChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizChoiceInclude | null
    /**
     * The filter to search for the QuizChoice to update in case it exists.
     */
    where: QuizChoiceWhereUniqueInput
    /**
     * In case the QuizChoice found by the `where` argument doesn't exist, create a new QuizChoice with this data.
     */
    create: XOR<QuizChoiceCreateInput, QuizChoiceUncheckedCreateInput>
    /**
     * In case the QuizChoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizChoiceUpdateInput, QuizChoiceUncheckedUpdateInput>
  }


  /**
   * QuizChoice delete
   */
  export type QuizChoiceDeleteArgs = {
    /**
     * Select specific fields to fetch from the QuizChoice
     */
    select?: QuizChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizChoiceInclude | null
    /**
     * Filter which QuizChoice to delete.
     */
    where: QuizChoiceWhereUniqueInput
  }


  /**
   * QuizChoice deleteMany
   */
  export type QuizChoiceDeleteManyArgs = {
    /**
     * Filter which QuizChoices to delete
     */
    where?: QuizChoiceWhereInput
  }


  /**
   * QuizChoice.quizRecords
   */
  export type QuizChoice$quizRecordsArgs = {
    /**
     * Select specific fields to fetch from the QuizRecord
     */
    select?: QuizRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRecordInclude | null
    where?: QuizRecordWhereInput
    orderBy?: Enumerable<QuizRecordOrderByWithRelationInput>
    cursor?: QuizRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<QuizRecordScalarFieldEnum>
  }


  /**
   * QuizChoice without action
   */
  export type QuizChoiceArgs = {
    /**
     * Select specific fields to fetch from the QuizChoice
     */
    select?: QuizChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizChoiceInclude | null
  }



  /**
   * Model QuizRound
   */


  export type AggregateQuizRound = {
    _count: QuizRoundCountAggregateOutputType | null
    _avg: QuizRoundAvgAggregateOutputType | null
    _sum: QuizRoundSumAggregateOutputType | null
    _min: QuizRoundMinAggregateOutputType | null
    _max: QuizRoundMaxAggregateOutputType | null
  }

  export type QuizRoundAvgAggregateOutputType = {
    id: number | null
    quizCategoryId: number | null
  }

  export type QuizRoundSumAggregateOutputType = {
    id: number | null
    quizCategoryId: number | null
  }

  export type QuizRoundMinAggregateOutputType = {
    id: number | null
    name: string | null
    totalScore: string | null
    quizCategoryId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizRoundMaxAggregateOutputType = {
    id: number | null
    name: string | null
    totalScore: string | null
    quizCategoryId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizRoundCountAggregateOutputType = {
    id: number
    name: number
    totalScore: number
    quizCategoryId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuizRoundAvgAggregateInputType = {
    id?: true
    quizCategoryId?: true
  }

  export type QuizRoundSumAggregateInputType = {
    id?: true
    quizCategoryId?: true
  }

  export type QuizRoundMinAggregateInputType = {
    id?: true
    name?: true
    totalScore?: true
    quizCategoryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizRoundMaxAggregateInputType = {
    id?: true
    name?: true
    totalScore?: true
    quizCategoryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizRoundCountAggregateInputType = {
    id?: true
    name?: true
    totalScore?: true
    quizCategoryId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuizRoundAggregateArgs = {
    /**
     * Filter which QuizRound to aggregate.
     */
    where?: QuizRoundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizRounds to fetch.
     */
    orderBy?: Enumerable<QuizRoundOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizRoundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizRounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizRounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizRounds
    **/
    _count?: true | QuizRoundCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizRoundAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizRoundSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizRoundMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizRoundMaxAggregateInputType
  }

  export type GetQuizRoundAggregateType<T extends QuizRoundAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizRound]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizRound[P]>
      : GetScalarType<T[P], AggregateQuizRound[P]>
  }




  export type QuizRoundGroupByArgs = {
    where?: QuizRoundWhereInput
    orderBy?: Enumerable<QuizRoundOrderByWithAggregationInput>
    by: QuizRoundScalarFieldEnum[]
    having?: QuizRoundScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizRoundCountAggregateInputType | true
    _avg?: QuizRoundAvgAggregateInputType
    _sum?: QuizRoundSumAggregateInputType
    _min?: QuizRoundMinAggregateInputType
    _max?: QuizRoundMaxAggregateInputType
  }


  export type QuizRoundGroupByOutputType = {
    id: number
    name: string
    totalScore: string
    quizCategoryId: number
    createdAt: Date
    updatedAt: Date
    _count: QuizRoundCountAggregateOutputType | null
    _avg: QuizRoundAvgAggregateOutputType | null
    _sum: QuizRoundSumAggregateOutputType | null
    _min: QuizRoundMinAggregateOutputType | null
    _max: QuizRoundMaxAggregateOutputType | null
  }

  type GetQuizRoundGroupByPayload<T extends QuizRoundGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<QuizRoundGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizRoundGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizRoundGroupByOutputType[P]>
            : GetScalarType<T[P], QuizRoundGroupByOutputType[P]>
        }
      >
    >


  export type QuizRoundSelect = {
    id?: boolean
    name?: boolean
    totalScore?: boolean
    category?: boolean | QuizCategoryArgs
    quizCategoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quizRecords?: boolean | QuizRound$quizRecordsArgs
    _count?: boolean | QuizRoundCountOutputTypeArgs
  }


  export type QuizRoundInclude = {
    category?: boolean | QuizCategoryArgs
    quizRecords?: boolean | QuizRound$quizRecordsArgs
    _count?: boolean | QuizRoundCountOutputTypeArgs
  }

  export type QuizRoundGetPayload<S extends boolean | null | undefined | QuizRoundArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? QuizRound :
    S extends undefined ? never :
    S extends { include: any } & (QuizRoundArgs | QuizRoundFindManyArgs)
    ? QuizRound  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'category' ? QuizCategoryGetPayload<S['include'][P]> | null :
        P extends 'quizRecords' ? Array < QuizRecordGetPayload<S['include'][P]>>  :
        P extends '_count' ? QuizRoundCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (QuizRoundArgs | QuizRoundFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'category' ? QuizCategoryGetPayload<S['select'][P]> | null :
        P extends 'quizRecords' ? Array < QuizRecordGetPayload<S['select'][P]>>  :
        P extends '_count' ? QuizRoundCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof QuizRound ? QuizRound[P] : never
  } 
      : QuizRound


  type QuizRoundCountArgs = 
    Omit<QuizRoundFindManyArgs, 'select' | 'include'> & {
      select?: QuizRoundCountAggregateInputType | true
    }

  export interface QuizRoundDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one QuizRound that matches the filter.
     * @param {QuizRoundFindUniqueArgs} args - Arguments to find a QuizRound
     * @example
     * // Get one QuizRound
     * const quizRound = await prisma.quizRound.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuizRoundFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, QuizRoundFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'QuizRound'> extends True ? Prisma__QuizRoundClient<QuizRoundGetPayload<T>> : Prisma__QuizRoundClient<QuizRoundGetPayload<T> | null, null>

    /**
     * Find one QuizRound that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {QuizRoundFindUniqueOrThrowArgs} args - Arguments to find a QuizRound
     * @example
     * // Get one QuizRound
     * const quizRound = await prisma.quizRound.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QuizRoundFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, QuizRoundFindUniqueOrThrowArgs>
    ): Prisma__QuizRoundClient<QuizRoundGetPayload<T>>

    /**
     * Find the first QuizRound that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizRoundFindFirstArgs} args - Arguments to find a QuizRound
     * @example
     * // Get one QuizRound
     * const quizRound = await prisma.quizRound.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuizRoundFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, QuizRoundFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'QuizRound'> extends True ? Prisma__QuizRoundClient<QuizRoundGetPayload<T>> : Prisma__QuizRoundClient<QuizRoundGetPayload<T> | null, null>

    /**
     * Find the first QuizRound that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizRoundFindFirstOrThrowArgs} args - Arguments to find a QuizRound
     * @example
     * // Get one QuizRound
     * const quizRound = await prisma.quizRound.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QuizRoundFindFirstOrThrowArgs>(
      args?: SelectSubset<T, QuizRoundFindFirstOrThrowArgs>
    ): Prisma__QuizRoundClient<QuizRoundGetPayload<T>>

    /**
     * Find zero or more QuizRounds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizRoundFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizRounds
     * const quizRounds = await prisma.quizRound.findMany()
     * 
     * // Get first 10 QuizRounds
     * const quizRounds = await prisma.quizRound.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizRoundWithIdOnly = await prisma.quizRound.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends QuizRoundFindManyArgs>(
      args?: SelectSubset<T, QuizRoundFindManyArgs>
    ): Prisma.PrismaPromise<Array<QuizRoundGetPayload<T>>>

    /**
     * Create a QuizRound.
     * @param {QuizRoundCreateArgs} args - Arguments to create a QuizRound.
     * @example
     * // Create one QuizRound
     * const QuizRound = await prisma.quizRound.create({
     *   data: {
     *     // ... data to create a QuizRound
     *   }
     * })
     * 
    **/
    create<T extends QuizRoundCreateArgs>(
      args: SelectSubset<T, QuizRoundCreateArgs>
    ): Prisma__QuizRoundClient<QuizRoundGetPayload<T>>

    /**
     * Create many QuizRounds.
     *     @param {QuizRoundCreateManyArgs} args - Arguments to create many QuizRounds.
     *     @example
     *     // Create many QuizRounds
     *     const quizRound = await prisma.quizRound.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QuizRoundCreateManyArgs>(
      args?: SelectSubset<T, QuizRoundCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QuizRound.
     * @param {QuizRoundDeleteArgs} args - Arguments to delete one QuizRound.
     * @example
     * // Delete one QuizRound
     * const QuizRound = await prisma.quizRound.delete({
     *   where: {
     *     // ... filter to delete one QuizRound
     *   }
     * })
     * 
    **/
    delete<T extends QuizRoundDeleteArgs>(
      args: SelectSubset<T, QuizRoundDeleteArgs>
    ): Prisma__QuizRoundClient<QuizRoundGetPayload<T>>

    /**
     * Update one QuizRound.
     * @param {QuizRoundUpdateArgs} args - Arguments to update one QuizRound.
     * @example
     * // Update one QuizRound
     * const quizRound = await prisma.quizRound.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuizRoundUpdateArgs>(
      args: SelectSubset<T, QuizRoundUpdateArgs>
    ): Prisma__QuizRoundClient<QuizRoundGetPayload<T>>

    /**
     * Delete zero or more QuizRounds.
     * @param {QuizRoundDeleteManyArgs} args - Arguments to filter QuizRounds to delete.
     * @example
     * // Delete a few QuizRounds
     * const { count } = await prisma.quizRound.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuizRoundDeleteManyArgs>(
      args?: SelectSubset<T, QuizRoundDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizRounds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizRoundUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizRounds
     * const quizRound = await prisma.quizRound.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuizRoundUpdateManyArgs>(
      args: SelectSubset<T, QuizRoundUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuizRound.
     * @param {QuizRoundUpsertArgs} args - Arguments to update or create a QuizRound.
     * @example
     * // Update or create a QuizRound
     * const quizRound = await prisma.quizRound.upsert({
     *   create: {
     *     // ... data to create a QuizRound
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizRound we want to update
     *   }
     * })
    **/
    upsert<T extends QuizRoundUpsertArgs>(
      args: SelectSubset<T, QuizRoundUpsertArgs>
    ): Prisma__QuizRoundClient<QuizRoundGetPayload<T>>

    /**
     * Count the number of QuizRounds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizRoundCountArgs} args - Arguments to filter QuizRounds to count.
     * @example
     * // Count the number of QuizRounds
     * const count = await prisma.quizRound.count({
     *   where: {
     *     // ... the filter for the QuizRounds we want to count
     *   }
     * })
    **/
    count<T extends QuizRoundCountArgs>(
      args?: Subset<T, QuizRoundCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizRoundCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizRound.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizRoundAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizRoundAggregateArgs>(args: Subset<T, QuizRoundAggregateArgs>): Prisma.PrismaPromise<GetQuizRoundAggregateType<T>>

    /**
     * Group by QuizRound.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizRoundGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizRoundGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizRoundGroupByArgs['orderBy'] }
        : { orderBy?: QuizRoundGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizRoundGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizRoundGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizRound.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__QuizRoundClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    category<T extends QuizCategoryArgs= {}>(args?: Subset<T, QuizCategoryArgs>): Prisma__QuizCategoryClient<QuizCategoryGetPayload<T> | Null>;

    quizRecords<T extends QuizRound$quizRecordsArgs= {}>(args?: Subset<T, QuizRound$quizRecordsArgs>): Prisma.PrismaPromise<Array<QuizRecordGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * QuizRound base type for findUnique actions
   */
  export type QuizRoundFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the QuizRound
     */
    select?: QuizRoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRoundInclude | null
    /**
     * Filter, which QuizRound to fetch.
     */
    where: QuizRoundWhereUniqueInput
  }

  /**
   * QuizRound findUnique
   */
  export interface QuizRoundFindUniqueArgs extends QuizRoundFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuizRound findUniqueOrThrow
   */
  export type QuizRoundFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the QuizRound
     */
    select?: QuizRoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRoundInclude | null
    /**
     * Filter, which QuizRound to fetch.
     */
    where: QuizRoundWhereUniqueInput
  }


  /**
   * QuizRound base type for findFirst actions
   */
  export type QuizRoundFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the QuizRound
     */
    select?: QuizRoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRoundInclude | null
    /**
     * Filter, which QuizRound to fetch.
     */
    where?: QuizRoundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizRounds to fetch.
     */
    orderBy?: Enumerable<QuizRoundOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizRounds.
     */
    cursor?: QuizRoundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizRounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizRounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizRounds.
     */
    distinct?: Enumerable<QuizRoundScalarFieldEnum>
  }

  /**
   * QuizRound findFirst
   */
  export interface QuizRoundFindFirstArgs extends QuizRoundFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuizRound findFirstOrThrow
   */
  export type QuizRoundFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the QuizRound
     */
    select?: QuizRoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRoundInclude | null
    /**
     * Filter, which QuizRound to fetch.
     */
    where?: QuizRoundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizRounds to fetch.
     */
    orderBy?: Enumerable<QuizRoundOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizRounds.
     */
    cursor?: QuizRoundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizRounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizRounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizRounds.
     */
    distinct?: Enumerable<QuizRoundScalarFieldEnum>
  }


  /**
   * QuizRound findMany
   */
  export type QuizRoundFindManyArgs = {
    /**
     * Select specific fields to fetch from the QuizRound
     */
    select?: QuizRoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRoundInclude | null
    /**
     * Filter, which QuizRounds to fetch.
     */
    where?: QuizRoundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizRounds to fetch.
     */
    orderBy?: Enumerable<QuizRoundOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizRounds.
     */
    cursor?: QuizRoundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizRounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizRounds.
     */
    skip?: number
    distinct?: Enumerable<QuizRoundScalarFieldEnum>
  }


  /**
   * QuizRound create
   */
  export type QuizRoundCreateArgs = {
    /**
     * Select specific fields to fetch from the QuizRound
     */
    select?: QuizRoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRoundInclude | null
    /**
     * The data needed to create a QuizRound.
     */
    data: XOR<QuizRoundCreateInput, QuizRoundUncheckedCreateInput>
  }


  /**
   * QuizRound createMany
   */
  export type QuizRoundCreateManyArgs = {
    /**
     * The data used to create many QuizRounds.
     */
    data: Enumerable<QuizRoundCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * QuizRound update
   */
  export type QuizRoundUpdateArgs = {
    /**
     * Select specific fields to fetch from the QuizRound
     */
    select?: QuizRoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRoundInclude | null
    /**
     * The data needed to update a QuizRound.
     */
    data: XOR<QuizRoundUpdateInput, QuizRoundUncheckedUpdateInput>
    /**
     * Choose, which QuizRound to update.
     */
    where: QuizRoundWhereUniqueInput
  }


  /**
   * QuizRound updateMany
   */
  export type QuizRoundUpdateManyArgs = {
    /**
     * The data used to update QuizRounds.
     */
    data: XOR<QuizRoundUpdateManyMutationInput, QuizRoundUncheckedUpdateManyInput>
    /**
     * Filter which QuizRounds to update
     */
    where?: QuizRoundWhereInput
  }


  /**
   * QuizRound upsert
   */
  export type QuizRoundUpsertArgs = {
    /**
     * Select specific fields to fetch from the QuizRound
     */
    select?: QuizRoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRoundInclude | null
    /**
     * The filter to search for the QuizRound to update in case it exists.
     */
    where: QuizRoundWhereUniqueInput
    /**
     * In case the QuizRound found by the `where` argument doesn't exist, create a new QuizRound with this data.
     */
    create: XOR<QuizRoundCreateInput, QuizRoundUncheckedCreateInput>
    /**
     * In case the QuizRound was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizRoundUpdateInput, QuizRoundUncheckedUpdateInput>
  }


  /**
   * QuizRound delete
   */
  export type QuizRoundDeleteArgs = {
    /**
     * Select specific fields to fetch from the QuizRound
     */
    select?: QuizRoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRoundInclude | null
    /**
     * Filter which QuizRound to delete.
     */
    where: QuizRoundWhereUniqueInput
  }


  /**
   * QuizRound deleteMany
   */
  export type QuizRoundDeleteManyArgs = {
    /**
     * Filter which QuizRounds to delete
     */
    where?: QuizRoundWhereInput
  }


  /**
   * QuizRound.quizRecords
   */
  export type QuizRound$quizRecordsArgs = {
    /**
     * Select specific fields to fetch from the QuizRecord
     */
    select?: QuizRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRecordInclude | null
    where?: QuizRecordWhereInput
    orderBy?: Enumerable<QuizRecordOrderByWithRelationInput>
    cursor?: QuizRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<QuizRecordScalarFieldEnum>
  }


  /**
   * QuizRound without action
   */
  export type QuizRoundArgs = {
    /**
     * Select specific fields to fetch from the QuizRound
     */
    select?: QuizRoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRoundInclude | null
  }



  /**
   * Model QuizRecord
   */


  export type AggregateQuizRecord = {
    _count: QuizRecordCountAggregateOutputType | null
    _avg: QuizRecordAvgAggregateOutputType | null
    _sum: QuizRecordSumAggregateOutputType | null
    _min: QuizRecordMinAggregateOutputType | null
    _max: QuizRecordMaxAggregateOutputType | null
  }

  export type QuizRecordAvgAggregateOutputType = {
    id: number | null
    quizRoundId: number | null
    quizChoiceId: number | null
    quizQuestionId: number | null
  }

  export type QuizRecordSumAggregateOutputType = {
    id: number | null
    quizRoundId: number | null
    quizChoiceId: number | null
    quizQuestionId: number | null
  }

  export type QuizRecordMinAggregateOutputType = {
    id: number | null
    quizRoundId: number | null
    quizChoiceId: number | null
    quizQuestionId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizRecordMaxAggregateOutputType = {
    id: number | null
    quizRoundId: number | null
    quizChoiceId: number | null
    quizQuestionId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizRecordCountAggregateOutputType = {
    id: number
    quizRoundId: number
    quizChoiceId: number
    quizQuestionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuizRecordAvgAggregateInputType = {
    id?: true
    quizRoundId?: true
    quizChoiceId?: true
    quizQuestionId?: true
  }

  export type QuizRecordSumAggregateInputType = {
    id?: true
    quizRoundId?: true
    quizChoiceId?: true
    quizQuestionId?: true
  }

  export type QuizRecordMinAggregateInputType = {
    id?: true
    quizRoundId?: true
    quizChoiceId?: true
    quizQuestionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizRecordMaxAggregateInputType = {
    id?: true
    quizRoundId?: true
    quizChoiceId?: true
    quizQuestionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizRecordCountAggregateInputType = {
    id?: true
    quizRoundId?: true
    quizChoiceId?: true
    quizQuestionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuizRecordAggregateArgs = {
    /**
     * Filter which QuizRecord to aggregate.
     */
    where?: QuizRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizRecords to fetch.
     */
    orderBy?: Enumerable<QuizRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizRecords
    **/
    _count?: true | QuizRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizRecordMaxAggregateInputType
  }

  export type GetQuizRecordAggregateType<T extends QuizRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizRecord[P]>
      : GetScalarType<T[P], AggregateQuizRecord[P]>
  }




  export type QuizRecordGroupByArgs = {
    where?: QuizRecordWhereInput
    orderBy?: Enumerable<QuizRecordOrderByWithAggregationInput>
    by: QuizRecordScalarFieldEnum[]
    having?: QuizRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizRecordCountAggregateInputType | true
    _avg?: QuizRecordAvgAggregateInputType
    _sum?: QuizRecordSumAggregateInputType
    _min?: QuizRecordMinAggregateInputType
    _max?: QuizRecordMaxAggregateInputType
  }


  export type QuizRecordGroupByOutputType = {
    id: number
    quizRoundId: number
    quizChoiceId: number
    quizQuestionId: number
    createdAt: Date
    updatedAt: Date
    _count: QuizRecordCountAggregateOutputType | null
    _avg: QuizRecordAvgAggregateOutputType | null
    _sum: QuizRecordSumAggregateOutputType | null
    _min: QuizRecordMinAggregateOutputType | null
    _max: QuizRecordMaxAggregateOutputType | null
  }

  type GetQuizRecordGroupByPayload<T extends QuizRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<QuizRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizRecordGroupByOutputType[P]>
            : GetScalarType<T[P], QuizRecordGroupByOutputType[P]>
        }
      >
    >


  export type QuizRecordSelect = {
    id?: boolean
    round?: boolean | QuizRoundArgs
    playerChoice?: boolean | QuizChoiceArgs
    question?: boolean | QuizQuestionArgs
    quizRoundId?: boolean
    quizChoiceId?: boolean
    quizQuestionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type QuizRecordInclude = {
    round?: boolean | QuizRoundArgs
    playerChoice?: boolean | QuizChoiceArgs
    question?: boolean | QuizQuestionArgs
  }

  export type QuizRecordGetPayload<S extends boolean | null | undefined | QuizRecordArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? QuizRecord :
    S extends undefined ? never :
    S extends { include: any } & (QuizRecordArgs | QuizRecordFindManyArgs)
    ? QuizRecord  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'round' ? QuizRoundGetPayload<S['include'][P]> | null :
        P extends 'playerChoice' ? QuizChoiceGetPayload<S['include'][P]> | null :
        P extends 'question' ? QuizQuestionGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (QuizRecordArgs | QuizRecordFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'round' ? QuizRoundGetPayload<S['select'][P]> | null :
        P extends 'playerChoice' ? QuizChoiceGetPayload<S['select'][P]> | null :
        P extends 'question' ? QuizQuestionGetPayload<S['select'][P]> | null :  P extends keyof QuizRecord ? QuizRecord[P] : never
  } 
      : QuizRecord


  type QuizRecordCountArgs = 
    Omit<QuizRecordFindManyArgs, 'select' | 'include'> & {
      select?: QuizRecordCountAggregateInputType | true
    }

  export interface QuizRecordDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one QuizRecord that matches the filter.
     * @param {QuizRecordFindUniqueArgs} args - Arguments to find a QuizRecord
     * @example
     * // Get one QuizRecord
     * const quizRecord = await prisma.quizRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuizRecordFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, QuizRecordFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'QuizRecord'> extends True ? Prisma__QuizRecordClient<QuizRecordGetPayload<T>> : Prisma__QuizRecordClient<QuizRecordGetPayload<T> | null, null>

    /**
     * Find one QuizRecord that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {QuizRecordFindUniqueOrThrowArgs} args - Arguments to find a QuizRecord
     * @example
     * // Get one QuizRecord
     * const quizRecord = await prisma.quizRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QuizRecordFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, QuizRecordFindUniqueOrThrowArgs>
    ): Prisma__QuizRecordClient<QuizRecordGetPayload<T>>

    /**
     * Find the first QuizRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizRecordFindFirstArgs} args - Arguments to find a QuizRecord
     * @example
     * // Get one QuizRecord
     * const quizRecord = await prisma.quizRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuizRecordFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, QuizRecordFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'QuizRecord'> extends True ? Prisma__QuizRecordClient<QuizRecordGetPayload<T>> : Prisma__QuizRecordClient<QuizRecordGetPayload<T> | null, null>

    /**
     * Find the first QuizRecord that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizRecordFindFirstOrThrowArgs} args - Arguments to find a QuizRecord
     * @example
     * // Get one QuizRecord
     * const quizRecord = await prisma.quizRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QuizRecordFindFirstOrThrowArgs>(
      args?: SelectSubset<T, QuizRecordFindFirstOrThrowArgs>
    ): Prisma__QuizRecordClient<QuizRecordGetPayload<T>>

    /**
     * Find zero or more QuizRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizRecordFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizRecords
     * const quizRecords = await prisma.quizRecord.findMany()
     * 
     * // Get first 10 QuizRecords
     * const quizRecords = await prisma.quizRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizRecordWithIdOnly = await prisma.quizRecord.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends QuizRecordFindManyArgs>(
      args?: SelectSubset<T, QuizRecordFindManyArgs>
    ): Prisma.PrismaPromise<Array<QuizRecordGetPayload<T>>>

    /**
     * Create a QuizRecord.
     * @param {QuizRecordCreateArgs} args - Arguments to create a QuizRecord.
     * @example
     * // Create one QuizRecord
     * const QuizRecord = await prisma.quizRecord.create({
     *   data: {
     *     // ... data to create a QuizRecord
     *   }
     * })
     * 
    **/
    create<T extends QuizRecordCreateArgs>(
      args: SelectSubset<T, QuizRecordCreateArgs>
    ): Prisma__QuizRecordClient<QuizRecordGetPayload<T>>

    /**
     * Create many QuizRecords.
     *     @param {QuizRecordCreateManyArgs} args - Arguments to create many QuizRecords.
     *     @example
     *     // Create many QuizRecords
     *     const quizRecord = await prisma.quizRecord.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QuizRecordCreateManyArgs>(
      args?: SelectSubset<T, QuizRecordCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QuizRecord.
     * @param {QuizRecordDeleteArgs} args - Arguments to delete one QuizRecord.
     * @example
     * // Delete one QuizRecord
     * const QuizRecord = await prisma.quizRecord.delete({
     *   where: {
     *     // ... filter to delete one QuizRecord
     *   }
     * })
     * 
    **/
    delete<T extends QuizRecordDeleteArgs>(
      args: SelectSubset<T, QuizRecordDeleteArgs>
    ): Prisma__QuizRecordClient<QuizRecordGetPayload<T>>

    /**
     * Update one QuizRecord.
     * @param {QuizRecordUpdateArgs} args - Arguments to update one QuizRecord.
     * @example
     * // Update one QuizRecord
     * const quizRecord = await prisma.quizRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuizRecordUpdateArgs>(
      args: SelectSubset<T, QuizRecordUpdateArgs>
    ): Prisma__QuizRecordClient<QuizRecordGetPayload<T>>

    /**
     * Delete zero or more QuizRecords.
     * @param {QuizRecordDeleteManyArgs} args - Arguments to filter QuizRecords to delete.
     * @example
     * // Delete a few QuizRecords
     * const { count } = await prisma.quizRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuizRecordDeleteManyArgs>(
      args?: SelectSubset<T, QuizRecordDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizRecords
     * const quizRecord = await prisma.quizRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuizRecordUpdateManyArgs>(
      args: SelectSubset<T, QuizRecordUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuizRecord.
     * @param {QuizRecordUpsertArgs} args - Arguments to update or create a QuizRecord.
     * @example
     * // Update or create a QuizRecord
     * const quizRecord = await prisma.quizRecord.upsert({
     *   create: {
     *     // ... data to create a QuizRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizRecord we want to update
     *   }
     * })
    **/
    upsert<T extends QuizRecordUpsertArgs>(
      args: SelectSubset<T, QuizRecordUpsertArgs>
    ): Prisma__QuizRecordClient<QuizRecordGetPayload<T>>

    /**
     * Count the number of QuizRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizRecordCountArgs} args - Arguments to filter QuizRecords to count.
     * @example
     * // Count the number of QuizRecords
     * const count = await prisma.quizRecord.count({
     *   where: {
     *     // ... the filter for the QuizRecords we want to count
     *   }
     * })
    **/
    count<T extends QuizRecordCountArgs>(
      args?: Subset<T, QuizRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizRecordAggregateArgs>(args: Subset<T, QuizRecordAggregateArgs>): Prisma.PrismaPromise<GetQuizRecordAggregateType<T>>

    /**
     * Group by QuizRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizRecordGroupByArgs['orderBy'] }
        : { orderBy?: QuizRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__QuizRecordClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    round<T extends QuizRoundArgs= {}>(args?: Subset<T, QuizRoundArgs>): Prisma__QuizRoundClient<QuizRoundGetPayload<T> | Null>;

    playerChoice<T extends QuizChoiceArgs= {}>(args?: Subset<T, QuizChoiceArgs>): Prisma__QuizChoiceClient<QuizChoiceGetPayload<T> | Null>;

    question<T extends QuizQuestionArgs= {}>(args?: Subset<T, QuizQuestionArgs>): Prisma__QuizQuestionClient<QuizQuestionGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * QuizRecord base type for findUnique actions
   */
  export type QuizRecordFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the QuizRecord
     */
    select?: QuizRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRecordInclude | null
    /**
     * Filter, which QuizRecord to fetch.
     */
    where: QuizRecordWhereUniqueInput
  }

  /**
   * QuizRecord findUnique
   */
  export interface QuizRecordFindUniqueArgs extends QuizRecordFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuizRecord findUniqueOrThrow
   */
  export type QuizRecordFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the QuizRecord
     */
    select?: QuizRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRecordInclude | null
    /**
     * Filter, which QuizRecord to fetch.
     */
    where: QuizRecordWhereUniqueInput
  }


  /**
   * QuizRecord base type for findFirst actions
   */
  export type QuizRecordFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the QuizRecord
     */
    select?: QuizRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRecordInclude | null
    /**
     * Filter, which QuizRecord to fetch.
     */
    where?: QuizRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizRecords to fetch.
     */
    orderBy?: Enumerable<QuizRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizRecords.
     */
    cursor?: QuizRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizRecords.
     */
    distinct?: Enumerable<QuizRecordScalarFieldEnum>
  }

  /**
   * QuizRecord findFirst
   */
  export interface QuizRecordFindFirstArgs extends QuizRecordFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuizRecord findFirstOrThrow
   */
  export type QuizRecordFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the QuizRecord
     */
    select?: QuizRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRecordInclude | null
    /**
     * Filter, which QuizRecord to fetch.
     */
    where?: QuizRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizRecords to fetch.
     */
    orderBy?: Enumerable<QuizRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizRecords.
     */
    cursor?: QuizRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizRecords.
     */
    distinct?: Enumerable<QuizRecordScalarFieldEnum>
  }


  /**
   * QuizRecord findMany
   */
  export type QuizRecordFindManyArgs = {
    /**
     * Select specific fields to fetch from the QuizRecord
     */
    select?: QuizRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRecordInclude | null
    /**
     * Filter, which QuizRecords to fetch.
     */
    where?: QuizRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizRecords to fetch.
     */
    orderBy?: Enumerable<QuizRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizRecords.
     */
    cursor?: QuizRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizRecords.
     */
    skip?: number
    distinct?: Enumerable<QuizRecordScalarFieldEnum>
  }


  /**
   * QuizRecord create
   */
  export type QuizRecordCreateArgs = {
    /**
     * Select specific fields to fetch from the QuizRecord
     */
    select?: QuizRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRecordInclude | null
    /**
     * The data needed to create a QuizRecord.
     */
    data: XOR<QuizRecordCreateInput, QuizRecordUncheckedCreateInput>
  }


  /**
   * QuizRecord createMany
   */
  export type QuizRecordCreateManyArgs = {
    /**
     * The data used to create many QuizRecords.
     */
    data: Enumerable<QuizRecordCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * QuizRecord update
   */
  export type QuizRecordUpdateArgs = {
    /**
     * Select specific fields to fetch from the QuizRecord
     */
    select?: QuizRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRecordInclude | null
    /**
     * The data needed to update a QuizRecord.
     */
    data: XOR<QuizRecordUpdateInput, QuizRecordUncheckedUpdateInput>
    /**
     * Choose, which QuizRecord to update.
     */
    where: QuizRecordWhereUniqueInput
  }


  /**
   * QuizRecord updateMany
   */
  export type QuizRecordUpdateManyArgs = {
    /**
     * The data used to update QuizRecords.
     */
    data: XOR<QuizRecordUpdateManyMutationInput, QuizRecordUncheckedUpdateManyInput>
    /**
     * Filter which QuizRecords to update
     */
    where?: QuizRecordWhereInput
  }


  /**
   * QuizRecord upsert
   */
  export type QuizRecordUpsertArgs = {
    /**
     * Select specific fields to fetch from the QuizRecord
     */
    select?: QuizRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRecordInclude | null
    /**
     * The filter to search for the QuizRecord to update in case it exists.
     */
    where: QuizRecordWhereUniqueInput
    /**
     * In case the QuizRecord found by the `where` argument doesn't exist, create a new QuizRecord with this data.
     */
    create: XOR<QuizRecordCreateInput, QuizRecordUncheckedCreateInput>
    /**
     * In case the QuizRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizRecordUpdateInput, QuizRecordUncheckedUpdateInput>
  }


  /**
   * QuizRecord delete
   */
  export type QuizRecordDeleteArgs = {
    /**
     * Select specific fields to fetch from the QuizRecord
     */
    select?: QuizRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRecordInclude | null
    /**
     * Filter which QuizRecord to delete.
     */
    where: QuizRecordWhereUniqueInput
  }


  /**
   * QuizRecord deleteMany
   */
  export type QuizRecordDeleteManyArgs = {
    /**
     * Filter which QuizRecords to delete
     */
    where?: QuizRecordWhereInput
  }


  /**
   * QuizRecord without action
   */
  export type QuizRecordArgs = {
    /**
     * Select specific fields to fetch from the QuizRecord
     */
    select?: QuizRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRecordInclude | null
  }



  /**
   * Model TodoList
   */


  export type AggregateTodoList = {
    _count: TodoListCountAggregateOutputType | null
    _avg: TodoListAvgAggregateOutputType | null
    _sum: TodoListSumAggregateOutputType | null
    _min: TodoListMinAggregateOutputType | null
    _max: TodoListMaxAggregateOutputType | null
  }

  export type TodoListAvgAggregateOutputType = {
    id: number | null
  }

  export type TodoListSumAggregateOutputType = {
    id: number | null
  }

  export type TodoListMinAggregateOutputType = {
    id: number | null
    task: string | null
    note: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TodoListMaxAggregateOutputType = {
    id: number | null
    task: string | null
    note: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TodoListCountAggregateOutputType = {
    id: number
    task: number
    note: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TodoListAvgAggregateInputType = {
    id?: true
  }

  export type TodoListSumAggregateInputType = {
    id?: true
  }

  export type TodoListMinAggregateInputType = {
    id?: true
    task?: true
    note?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TodoListMaxAggregateInputType = {
    id?: true
    task?: true
    note?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TodoListCountAggregateInputType = {
    id?: true
    task?: true
    note?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TodoListAggregateArgs = {
    /**
     * Filter which TodoList to aggregate.
     */
    where?: TodoListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TodoLists to fetch.
     */
    orderBy?: Enumerable<TodoListOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TodoListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TodoLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TodoLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TodoLists
    **/
    _count?: true | TodoListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TodoListAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TodoListSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TodoListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TodoListMaxAggregateInputType
  }

  export type GetTodoListAggregateType<T extends TodoListAggregateArgs> = {
        [P in keyof T & keyof AggregateTodoList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTodoList[P]>
      : GetScalarType<T[P], AggregateTodoList[P]>
  }




  export type TodoListGroupByArgs = {
    where?: TodoListWhereInput
    orderBy?: Enumerable<TodoListOrderByWithAggregationInput>
    by: TodoListScalarFieldEnum[]
    having?: TodoListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TodoListCountAggregateInputType | true
    _avg?: TodoListAvgAggregateInputType
    _sum?: TodoListSumAggregateInputType
    _min?: TodoListMinAggregateInputType
    _max?: TodoListMaxAggregateInputType
  }


  export type TodoListGroupByOutputType = {
    id: number
    task: string
    note: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: TodoListCountAggregateOutputType | null
    _avg: TodoListAvgAggregateOutputType | null
    _sum: TodoListSumAggregateOutputType | null
    _min: TodoListMinAggregateOutputType | null
    _max: TodoListMaxAggregateOutputType | null
  }

  type GetTodoListGroupByPayload<T extends TodoListGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TodoListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TodoListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TodoListGroupByOutputType[P]>
            : GetScalarType<T[P], TodoListGroupByOutputType[P]>
        }
      >
    >


  export type TodoListSelect = {
    id?: boolean
    task?: boolean
    note?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type TodoListGetPayload<S extends boolean | null | undefined | TodoListArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TodoList :
    S extends undefined ? never :
    S extends { include: any } & (TodoListArgs | TodoListFindManyArgs)
    ? TodoList 
    : S extends { select: any } & (TodoListArgs | TodoListFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TodoList ? TodoList[P] : never
  } 
      : TodoList


  type TodoListCountArgs = 
    Omit<TodoListFindManyArgs, 'select' | 'include'> & {
      select?: TodoListCountAggregateInputType | true
    }

  export interface TodoListDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TodoList that matches the filter.
     * @param {TodoListFindUniqueArgs} args - Arguments to find a TodoList
     * @example
     * // Get one TodoList
     * const todoList = await prisma.todoList.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TodoListFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TodoListFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TodoList'> extends True ? Prisma__TodoListClient<TodoListGetPayload<T>> : Prisma__TodoListClient<TodoListGetPayload<T> | null, null>

    /**
     * Find one TodoList that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TodoListFindUniqueOrThrowArgs} args - Arguments to find a TodoList
     * @example
     * // Get one TodoList
     * const todoList = await prisma.todoList.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TodoListFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TodoListFindUniqueOrThrowArgs>
    ): Prisma__TodoListClient<TodoListGetPayload<T>>

    /**
     * Find the first TodoList that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoListFindFirstArgs} args - Arguments to find a TodoList
     * @example
     * // Get one TodoList
     * const todoList = await prisma.todoList.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TodoListFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TodoListFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TodoList'> extends True ? Prisma__TodoListClient<TodoListGetPayload<T>> : Prisma__TodoListClient<TodoListGetPayload<T> | null, null>

    /**
     * Find the first TodoList that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoListFindFirstOrThrowArgs} args - Arguments to find a TodoList
     * @example
     * // Get one TodoList
     * const todoList = await prisma.todoList.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TodoListFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TodoListFindFirstOrThrowArgs>
    ): Prisma__TodoListClient<TodoListGetPayload<T>>

    /**
     * Find zero or more TodoLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoListFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TodoLists
     * const todoLists = await prisma.todoList.findMany()
     * 
     * // Get first 10 TodoLists
     * const todoLists = await prisma.todoList.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const todoListWithIdOnly = await prisma.todoList.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TodoListFindManyArgs>(
      args?: SelectSubset<T, TodoListFindManyArgs>
    ): Prisma.PrismaPromise<Array<TodoListGetPayload<T>>>

    /**
     * Create a TodoList.
     * @param {TodoListCreateArgs} args - Arguments to create a TodoList.
     * @example
     * // Create one TodoList
     * const TodoList = await prisma.todoList.create({
     *   data: {
     *     // ... data to create a TodoList
     *   }
     * })
     * 
    **/
    create<T extends TodoListCreateArgs>(
      args: SelectSubset<T, TodoListCreateArgs>
    ): Prisma__TodoListClient<TodoListGetPayload<T>>

    /**
     * Create many TodoLists.
     *     @param {TodoListCreateManyArgs} args - Arguments to create many TodoLists.
     *     @example
     *     // Create many TodoLists
     *     const todoList = await prisma.todoList.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TodoListCreateManyArgs>(
      args?: SelectSubset<T, TodoListCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TodoList.
     * @param {TodoListDeleteArgs} args - Arguments to delete one TodoList.
     * @example
     * // Delete one TodoList
     * const TodoList = await prisma.todoList.delete({
     *   where: {
     *     // ... filter to delete one TodoList
     *   }
     * })
     * 
    **/
    delete<T extends TodoListDeleteArgs>(
      args: SelectSubset<T, TodoListDeleteArgs>
    ): Prisma__TodoListClient<TodoListGetPayload<T>>

    /**
     * Update one TodoList.
     * @param {TodoListUpdateArgs} args - Arguments to update one TodoList.
     * @example
     * // Update one TodoList
     * const todoList = await prisma.todoList.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TodoListUpdateArgs>(
      args: SelectSubset<T, TodoListUpdateArgs>
    ): Prisma__TodoListClient<TodoListGetPayload<T>>

    /**
     * Delete zero or more TodoLists.
     * @param {TodoListDeleteManyArgs} args - Arguments to filter TodoLists to delete.
     * @example
     * // Delete a few TodoLists
     * const { count } = await prisma.todoList.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TodoListDeleteManyArgs>(
      args?: SelectSubset<T, TodoListDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TodoLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TodoLists
     * const todoList = await prisma.todoList.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TodoListUpdateManyArgs>(
      args: SelectSubset<T, TodoListUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TodoList.
     * @param {TodoListUpsertArgs} args - Arguments to update or create a TodoList.
     * @example
     * // Update or create a TodoList
     * const todoList = await prisma.todoList.upsert({
     *   create: {
     *     // ... data to create a TodoList
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TodoList we want to update
     *   }
     * })
    **/
    upsert<T extends TodoListUpsertArgs>(
      args: SelectSubset<T, TodoListUpsertArgs>
    ): Prisma__TodoListClient<TodoListGetPayload<T>>

    /**
     * Count the number of TodoLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoListCountArgs} args - Arguments to filter TodoLists to count.
     * @example
     * // Count the number of TodoLists
     * const count = await prisma.todoList.count({
     *   where: {
     *     // ... the filter for the TodoLists we want to count
     *   }
     * })
    **/
    count<T extends TodoListCountArgs>(
      args?: Subset<T, TodoListCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TodoListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TodoList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TodoListAggregateArgs>(args: Subset<T, TodoListAggregateArgs>): Prisma.PrismaPromise<GetTodoListAggregateType<T>>

    /**
     * Group by TodoList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TodoListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TodoListGroupByArgs['orderBy'] }
        : { orderBy?: TodoListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TodoListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTodoListGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TodoList.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TodoListClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TodoList base type for findUnique actions
   */
  export type TodoListFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
    /**
     * Filter, which TodoList to fetch.
     */
    where: TodoListWhereUniqueInput
  }

  /**
   * TodoList findUnique
   */
  export interface TodoListFindUniqueArgs extends TodoListFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TodoList findUniqueOrThrow
   */
  export type TodoListFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
    /**
     * Filter, which TodoList to fetch.
     */
    where: TodoListWhereUniqueInput
  }


  /**
   * TodoList base type for findFirst actions
   */
  export type TodoListFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
    /**
     * Filter, which TodoList to fetch.
     */
    where?: TodoListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TodoLists to fetch.
     */
    orderBy?: Enumerable<TodoListOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TodoLists.
     */
    cursor?: TodoListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TodoLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TodoLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TodoLists.
     */
    distinct?: Enumerable<TodoListScalarFieldEnum>
  }

  /**
   * TodoList findFirst
   */
  export interface TodoListFindFirstArgs extends TodoListFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TodoList findFirstOrThrow
   */
  export type TodoListFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
    /**
     * Filter, which TodoList to fetch.
     */
    where?: TodoListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TodoLists to fetch.
     */
    orderBy?: Enumerable<TodoListOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TodoLists.
     */
    cursor?: TodoListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TodoLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TodoLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TodoLists.
     */
    distinct?: Enumerable<TodoListScalarFieldEnum>
  }


  /**
   * TodoList findMany
   */
  export type TodoListFindManyArgs = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
    /**
     * Filter, which TodoLists to fetch.
     */
    where?: TodoListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TodoLists to fetch.
     */
    orderBy?: Enumerable<TodoListOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TodoLists.
     */
    cursor?: TodoListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TodoLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TodoLists.
     */
    skip?: number
    distinct?: Enumerable<TodoListScalarFieldEnum>
  }


  /**
   * TodoList create
   */
  export type TodoListCreateArgs = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
    /**
     * The data needed to create a TodoList.
     */
    data: XOR<TodoListCreateInput, TodoListUncheckedCreateInput>
  }


  /**
   * TodoList createMany
   */
  export type TodoListCreateManyArgs = {
    /**
     * The data used to create many TodoLists.
     */
    data: Enumerable<TodoListCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TodoList update
   */
  export type TodoListUpdateArgs = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
    /**
     * The data needed to update a TodoList.
     */
    data: XOR<TodoListUpdateInput, TodoListUncheckedUpdateInput>
    /**
     * Choose, which TodoList to update.
     */
    where: TodoListWhereUniqueInput
  }


  /**
   * TodoList updateMany
   */
  export type TodoListUpdateManyArgs = {
    /**
     * The data used to update TodoLists.
     */
    data: XOR<TodoListUpdateManyMutationInput, TodoListUncheckedUpdateManyInput>
    /**
     * Filter which TodoLists to update
     */
    where?: TodoListWhereInput
  }


  /**
   * TodoList upsert
   */
  export type TodoListUpsertArgs = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
    /**
     * The filter to search for the TodoList to update in case it exists.
     */
    where: TodoListWhereUniqueInput
    /**
     * In case the TodoList found by the `where` argument doesn't exist, create a new TodoList with this data.
     */
    create: XOR<TodoListCreateInput, TodoListUncheckedCreateInput>
    /**
     * In case the TodoList was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TodoListUpdateInput, TodoListUncheckedUpdateInput>
  }


  /**
   * TodoList delete
   */
  export type TodoListDeleteArgs = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
    /**
     * Filter which TodoList to delete.
     */
    where: TodoListWhereUniqueInput
  }


  /**
   * TodoList deleteMany
   */
  export type TodoListDeleteManyArgs = {
    /**
     * Filter which TodoLists to delete
     */
    where?: TodoListWhereInput
  }


  /**
   * TodoList without action
   */
  export type TodoListArgs = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
  }



  /**
   * Model TwitterUser
   */


  export type AggregateTwitterUser = {
    _count: TwitterUserCountAggregateOutputType | null
    _avg: TwitterUserAvgAggregateOutputType | null
    _sum: TwitterUserSumAggregateOutputType | null
    _min: TwitterUserMinAggregateOutputType | null
    _max: TwitterUserMaxAggregateOutputType | null
  }

  export type TwitterUserAvgAggregateOutputType = {
    id: number | null
  }

  export type TwitterUserSumAggregateOutputType = {
    id: number | null
  }

  export type TwitterUserMinAggregateOutputType = {
    id: number | null
    name: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TwitterUserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TwitterUserCountAggregateOutputType = {
    id: number
    name: number
    image: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TwitterUserAvgAggregateInputType = {
    id?: true
  }

  export type TwitterUserSumAggregateInputType = {
    id?: true
  }

  export type TwitterUserMinAggregateInputType = {
    id?: true
    name?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TwitterUserMaxAggregateInputType = {
    id?: true
    name?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TwitterUserCountAggregateInputType = {
    id?: true
    name?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TwitterUserAggregateArgs = {
    /**
     * Filter which TwitterUser to aggregate.
     */
    where?: TwitterUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterUsers to fetch.
     */
    orderBy?: Enumerable<TwitterUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TwitterUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TwitterUsers
    **/
    _count?: true | TwitterUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TwitterUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TwitterUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TwitterUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TwitterUserMaxAggregateInputType
  }

  export type GetTwitterUserAggregateType<T extends TwitterUserAggregateArgs> = {
        [P in keyof T & keyof AggregateTwitterUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTwitterUser[P]>
      : GetScalarType<T[P], AggregateTwitterUser[P]>
  }




  export type TwitterUserGroupByArgs = {
    where?: TwitterUserWhereInput
    orderBy?: Enumerable<TwitterUserOrderByWithAggregationInput>
    by: TwitterUserScalarFieldEnum[]
    having?: TwitterUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TwitterUserCountAggregateInputType | true
    _avg?: TwitterUserAvgAggregateInputType
    _sum?: TwitterUserSumAggregateInputType
    _min?: TwitterUserMinAggregateInputType
    _max?: TwitterUserMaxAggregateInputType
  }


  export type TwitterUserGroupByOutputType = {
    id: number
    name: string
    image: string
    createdAt: Date
    updatedAt: Date
    _count: TwitterUserCountAggregateOutputType | null
    _avg: TwitterUserAvgAggregateOutputType | null
    _sum: TwitterUserSumAggregateOutputType | null
    _min: TwitterUserMinAggregateOutputType | null
    _max: TwitterUserMaxAggregateOutputType | null
  }

  type GetTwitterUserGroupByPayload<T extends TwitterUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TwitterUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TwitterUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TwitterUserGroupByOutputType[P]>
            : GetScalarType<T[P], TwitterUserGroupByOutputType[P]>
        }
      >
    >


  export type TwitterUserSelect = {
    id?: boolean
    name?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    posts?: boolean | TwitterUser$postsArgs
    fromDirectMessages?: boolean | TwitterUser$fromDirectMessagesArgs
    comments?: boolean | TwitterUser$commentsArgs
    toDirectMessages?: boolean | TwitterUser$toDirectMessagesArgs
    followingUserRelations?: boolean | TwitterUser$followingUserRelationsArgs
    followerUserRelations?: boolean | TwitterUser$followerUserRelationsArgs
    _count?: boolean | TwitterUserCountOutputTypeArgs
  }


  export type TwitterUserInclude = {
    posts?: boolean | TwitterUser$postsArgs
    fromDirectMessages?: boolean | TwitterUser$fromDirectMessagesArgs
    comments?: boolean | TwitterUser$commentsArgs
    toDirectMessages?: boolean | TwitterUser$toDirectMessagesArgs
    followingUserRelations?: boolean | TwitterUser$followingUserRelationsArgs
    followerUserRelations?: boolean | TwitterUser$followerUserRelationsArgs
    _count?: boolean | TwitterUserCountOutputTypeArgs
  }

  export type TwitterUserGetPayload<S extends boolean | null | undefined | TwitterUserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TwitterUser :
    S extends undefined ? never :
    S extends { include: any } & (TwitterUserArgs | TwitterUserFindManyArgs)
    ? TwitterUser  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'posts' ? Array < TwitterPostGetPayload<S['include'][P]>>  :
        P extends 'fromDirectMessages' ? Array < TwitterDirectMessageGetPayload<S['include'][P]>>  :
        P extends 'comments' ? Array < TwitterCommentGetPayload<S['include'][P]>>  :
        P extends 'toDirectMessages' ? Array < TwitterDirectMessageGetPayload<S['include'][P]>>  :
        P extends 'followingUserRelations' ? Array < TwitterUserRelationGetPayload<S['include'][P]>>  :
        P extends 'followerUserRelations' ? Array < TwitterUserRelationGetPayload<S['include'][P]>>  :
        P extends '_count' ? TwitterUserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TwitterUserArgs | TwitterUserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'posts' ? Array < TwitterPostGetPayload<S['select'][P]>>  :
        P extends 'fromDirectMessages' ? Array < TwitterDirectMessageGetPayload<S['select'][P]>>  :
        P extends 'comments' ? Array < TwitterCommentGetPayload<S['select'][P]>>  :
        P extends 'toDirectMessages' ? Array < TwitterDirectMessageGetPayload<S['select'][P]>>  :
        P extends 'followingUserRelations' ? Array < TwitterUserRelationGetPayload<S['select'][P]>>  :
        P extends 'followerUserRelations' ? Array < TwitterUserRelationGetPayload<S['select'][P]>>  :
        P extends '_count' ? TwitterUserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof TwitterUser ? TwitterUser[P] : never
  } 
      : TwitterUser


  type TwitterUserCountArgs = 
    Omit<TwitterUserFindManyArgs, 'select' | 'include'> & {
      select?: TwitterUserCountAggregateInputType | true
    }

  export interface TwitterUserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TwitterUser that matches the filter.
     * @param {TwitterUserFindUniqueArgs} args - Arguments to find a TwitterUser
     * @example
     * // Get one TwitterUser
     * const twitterUser = await prisma.twitterUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TwitterUserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TwitterUserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TwitterUser'> extends True ? Prisma__TwitterUserClient<TwitterUserGetPayload<T>> : Prisma__TwitterUserClient<TwitterUserGetPayload<T> | null, null>

    /**
     * Find one TwitterUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TwitterUserFindUniqueOrThrowArgs} args - Arguments to find a TwitterUser
     * @example
     * // Get one TwitterUser
     * const twitterUser = await prisma.twitterUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TwitterUserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TwitterUserFindUniqueOrThrowArgs>
    ): Prisma__TwitterUserClient<TwitterUserGetPayload<T>>

    /**
     * Find the first TwitterUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterUserFindFirstArgs} args - Arguments to find a TwitterUser
     * @example
     * // Get one TwitterUser
     * const twitterUser = await prisma.twitterUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TwitterUserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TwitterUserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TwitterUser'> extends True ? Prisma__TwitterUserClient<TwitterUserGetPayload<T>> : Prisma__TwitterUserClient<TwitterUserGetPayload<T> | null, null>

    /**
     * Find the first TwitterUser that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterUserFindFirstOrThrowArgs} args - Arguments to find a TwitterUser
     * @example
     * // Get one TwitterUser
     * const twitterUser = await prisma.twitterUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TwitterUserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TwitterUserFindFirstOrThrowArgs>
    ): Prisma__TwitterUserClient<TwitterUserGetPayload<T>>

    /**
     * Find zero or more TwitterUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TwitterUsers
     * const twitterUsers = await prisma.twitterUser.findMany()
     * 
     * // Get first 10 TwitterUsers
     * const twitterUsers = await prisma.twitterUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const twitterUserWithIdOnly = await prisma.twitterUser.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TwitterUserFindManyArgs>(
      args?: SelectSubset<T, TwitterUserFindManyArgs>
    ): Prisma.PrismaPromise<Array<TwitterUserGetPayload<T>>>

    /**
     * Create a TwitterUser.
     * @param {TwitterUserCreateArgs} args - Arguments to create a TwitterUser.
     * @example
     * // Create one TwitterUser
     * const TwitterUser = await prisma.twitterUser.create({
     *   data: {
     *     // ... data to create a TwitterUser
     *   }
     * })
     * 
    **/
    create<T extends TwitterUserCreateArgs>(
      args: SelectSubset<T, TwitterUserCreateArgs>
    ): Prisma__TwitterUserClient<TwitterUserGetPayload<T>>

    /**
     * Create many TwitterUsers.
     *     @param {TwitterUserCreateManyArgs} args - Arguments to create many TwitterUsers.
     *     @example
     *     // Create many TwitterUsers
     *     const twitterUser = await prisma.twitterUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TwitterUserCreateManyArgs>(
      args?: SelectSubset<T, TwitterUserCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TwitterUser.
     * @param {TwitterUserDeleteArgs} args - Arguments to delete one TwitterUser.
     * @example
     * // Delete one TwitterUser
     * const TwitterUser = await prisma.twitterUser.delete({
     *   where: {
     *     // ... filter to delete one TwitterUser
     *   }
     * })
     * 
    **/
    delete<T extends TwitterUserDeleteArgs>(
      args: SelectSubset<T, TwitterUserDeleteArgs>
    ): Prisma__TwitterUserClient<TwitterUserGetPayload<T>>

    /**
     * Update one TwitterUser.
     * @param {TwitterUserUpdateArgs} args - Arguments to update one TwitterUser.
     * @example
     * // Update one TwitterUser
     * const twitterUser = await prisma.twitterUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TwitterUserUpdateArgs>(
      args: SelectSubset<T, TwitterUserUpdateArgs>
    ): Prisma__TwitterUserClient<TwitterUserGetPayload<T>>

    /**
     * Delete zero or more TwitterUsers.
     * @param {TwitterUserDeleteManyArgs} args - Arguments to filter TwitterUsers to delete.
     * @example
     * // Delete a few TwitterUsers
     * const { count } = await prisma.twitterUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TwitterUserDeleteManyArgs>(
      args?: SelectSubset<T, TwitterUserDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TwitterUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TwitterUsers
     * const twitterUser = await prisma.twitterUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TwitterUserUpdateManyArgs>(
      args: SelectSubset<T, TwitterUserUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TwitterUser.
     * @param {TwitterUserUpsertArgs} args - Arguments to update or create a TwitterUser.
     * @example
     * // Update or create a TwitterUser
     * const twitterUser = await prisma.twitterUser.upsert({
     *   create: {
     *     // ... data to create a TwitterUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TwitterUser we want to update
     *   }
     * })
    **/
    upsert<T extends TwitterUserUpsertArgs>(
      args: SelectSubset<T, TwitterUserUpsertArgs>
    ): Prisma__TwitterUserClient<TwitterUserGetPayload<T>>

    /**
     * Count the number of TwitterUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterUserCountArgs} args - Arguments to filter TwitterUsers to count.
     * @example
     * // Count the number of TwitterUsers
     * const count = await prisma.twitterUser.count({
     *   where: {
     *     // ... the filter for the TwitterUsers we want to count
     *   }
     * })
    **/
    count<T extends TwitterUserCountArgs>(
      args?: Subset<T, TwitterUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TwitterUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TwitterUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TwitterUserAggregateArgs>(args: Subset<T, TwitterUserAggregateArgs>): Prisma.PrismaPromise<GetTwitterUserAggregateType<T>>

    /**
     * Group by TwitterUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TwitterUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TwitterUserGroupByArgs['orderBy'] }
        : { orderBy?: TwitterUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TwitterUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTwitterUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TwitterUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TwitterUserClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    posts<T extends TwitterUser$postsArgs= {}>(args?: Subset<T, TwitterUser$postsArgs>): Prisma.PrismaPromise<Array<TwitterPostGetPayload<T>>| Null>;

    fromDirectMessages<T extends TwitterUser$fromDirectMessagesArgs= {}>(args?: Subset<T, TwitterUser$fromDirectMessagesArgs>): Prisma.PrismaPromise<Array<TwitterDirectMessageGetPayload<T>>| Null>;

    comments<T extends TwitterUser$commentsArgs= {}>(args?: Subset<T, TwitterUser$commentsArgs>): Prisma.PrismaPromise<Array<TwitterCommentGetPayload<T>>| Null>;

    toDirectMessages<T extends TwitterUser$toDirectMessagesArgs= {}>(args?: Subset<T, TwitterUser$toDirectMessagesArgs>): Prisma.PrismaPromise<Array<TwitterDirectMessageGetPayload<T>>| Null>;

    followingUserRelations<T extends TwitterUser$followingUserRelationsArgs= {}>(args?: Subset<T, TwitterUser$followingUserRelationsArgs>): Prisma.PrismaPromise<Array<TwitterUserRelationGetPayload<T>>| Null>;

    followerUserRelations<T extends TwitterUser$followerUserRelationsArgs= {}>(args?: Subset<T, TwitterUser$followerUserRelationsArgs>): Prisma.PrismaPromise<Array<TwitterUserRelationGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TwitterUser base type for findUnique actions
   */
  export type TwitterUserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TwitterUser
     */
    select?: TwitterUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserInclude | null
    /**
     * Filter, which TwitterUser to fetch.
     */
    where: TwitterUserWhereUniqueInput
  }

  /**
   * TwitterUser findUnique
   */
  export interface TwitterUserFindUniqueArgs extends TwitterUserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TwitterUser findUniqueOrThrow
   */
  export type TwitterUserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TwitterUser
     */
    select?: TwitterUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserInclude | null
    /**
     * Filter, which TwitterUser to fetch.
     */
    where: TwitterUserWhereUniqueInput
  }


  /**
   * TwitterUser base type for findFirst actions
   */
  export type TwitterUserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TwitterUser
     */
    select?: TwitterUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserInclude | null
    /**
     * Filter, which TwitterUser to fetch.
     */
    where?: TwitterUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterUsers to fetch.
     */
    orderBy?: Enumerable<TwitterUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterUsers.
     */
    cursor?: TwitterUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterUsers.
     */
    distinct?: Enumerable<TwitterUserScalarFieldEnum>
  }

  /**
   * TwitterUser findFirst
   */
  export interface TwitterUserFindFirstArgs extends TwitterUserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TwitterUser findFirstOrThrow
   */
  export type TwitterUserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TwitterUser
     */
    select?: TwitterUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserInclude | null
    /**
     * Filter, which TwitterUser to fetch.
     */
    where?: TwitterUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterUsers to fetch.
     */
    orderBy?: Enumerable<TwitterUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterUsers.
     */
    cursor?: TwitterUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterUsers.
     */
    distinct?: Enumerable<TwitterUserScalarFieldEnum>
  }


  /**
   * TwitterUser findMany
   */
  export type TwitterUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the TwitterUser
     */
    select?: TwitterUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserInclude | null
    /**
     * Filter, which TwitterUsers to fetch.
     */
    where?: TwitterUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterUsers to fetch.
     */
    orderBy?: Enumerable<TwitterUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TwitterUsers.
     */
    cursor?: TwitterUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterUsers.
     */
    skip?: number
    distinct?: Enumerable<TwitterUserScalarFieldEnum>
  }


  /**
   * TwitterUser create
   */
  export type TwitterUserCreateArgs = {
    /**
     * Select specific fields to fetch from the TwitterUser
     */
    select?: TwitterUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserInclude | null
    /**
     * The data needed to create a TwitterUser.
     */
    data: XOR<TwitterUserCreateInput, TwitterUserUncheckedCreateInput>
  }


  /**
   * TwitterUser createMany
   */
  export type TwitterUserCreateManyArgs = {
    /**
     * The data used to create many TwitterUsers.
     */
    data: Enumerable<TwitterUserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TwitterUser update
   */
  export type TwitterUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the TwitterUser
     */
    select?: TwitterUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserInclude | null
    /**
     * The data needed to update a TwitterUser.
     */
    data: XOR<TwitterUserUpdateInput, TwitterUserUncheckedUpdateInput>
    /**
     * Choose, which TwitterUser to update.
     */
    where: TwitterUserWhereUniqueInput
  }


  /**
   * TwitterUser updateMany
   */
  export type TwitterUserUpdateManyArgs = {
    /**
     * The data used to update TwitterUsers.
     */
    data: XOR<TwitterUserUpdateManyMutationInput, TwitterUserUncheckedUpdateManyInput>
    /**
     * Filter which TwitterUsers to update
     */
    where?: TwitterUserWhereInput
  }


  /**
   * TwitterUser upsert
   */
  export type TwitterUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the TwitterUser
     */
    select?: TwitterUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserInclude | null
    /**
     * The filter to search for the TwitterUser to update in case it exists.
     */
    where: TwitterUserWhereUniqueInput
    /**
     * In case the TwitterUser found by the `where` argument doesn't exist, create a new TwitterUser with this data.
     */
    create: XOR<TwitterUserCreateInput, TwitterUserUncheckedCreateInput>
    /**
     * In case the TwitterUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TwitterUserUpdateInput, TwitterUserUncheckedUpdateInput>
  }


  /**
   * TwitterUser delete
   */
  export type TwitterUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the TwitterUser
     */
    select?: TwitterUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserInclude | null
    /**
     * Filter which TwitterUser to delete.
     */
    where: TwitterUserWhereUniqueInput
  }


  /**
   * TwitterUser deleteMany
   */
  export type TwitterUserDeleteManyArgs = {
    /**
     * Filter which TwitterUsers to delete
     */
    where?: TwitterUserWhereInput
  }


  /**
   * TwitterUser.posts
   */
  export type TwitterUser$postsArgs = {
    /**
     * Select specific fields to fetch from the TwitterPost
     */
    select?: TwitterPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostInclude | null
    where?: TwitterPostWhereInput
    orderBy?: Enumerable<TwitterPostOrderByWithRelationInput>
    cursor?: TwitterPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TwitterPostScalarFieldEnum>
  }


  /**
   * TwitterUser.fromDirectMessages
   */
  export type TwitterUser$fromDirectMessagesArgs = {
    /**
     * Select specific fields to fetch from the TwitterDirectMessage
     */
    select?: TwitterDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterDirectMessageInclude | null
    where?: TwitterDirectMessageWhereInput
    orderBy?: Enumerable<TwitterDirectMessageOrderByWithRelationInput>
    cursor?: TwitterDirectMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TwitterDirectMessageScalarFieldEnum>
  }


  /**
   * TwitterUser.comments
   */
  export type TwitterUser$commentsArgs = {
    /**
     * Select specific fields to fetch from the TwitterComment
     */
    select?: TwitterCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterCommentInclude | null
    where?: TwitterCommentWhereInput
    orderBy?: Enumerable<TwitterCommentOrderByWithRelationInput>
    cursor?: TwitterCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TwitterCommentScalarFieldEnum>
  }


  /**
   * TwitterUser.toDirectMessages
   */
  export type TwitterUser$toDirectMessagesArgs = {
    /**
     * Select specific fields to fetch from the TwitterDirectMessage
     */
    select?: TwitterDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterDirectMessageInclude | null
    where?: TwitterDirectMessageWhereInput
    orderBy?: Enumerable<TwitterDirectMessageOrderByWithRelationInput>
    cursor?: TwitterDirectMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TwitterDirectMessageScalarFieldEnum>
  }


  /**
   * TwitterUser.followingUserRelations
   */
  export type TwitterUser$followingUserRelationsArgs = {
    /**
     * Select specific fields to fetch from the TwitterUserRelation
     */
    select?: TwitterUserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserRelationInclude | null
    where?: TwitterUserRelationWhereInput
    orderBy?: Enumerable<TwitterUserRelationOrderByWithRelationInput>
    cursor?: TwitterUserRelationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TwitterUserRelationScalarFieldEnum>
  }


  /**
   * TwitterUser.followerUserRelations
   */
  export type TwitterUser$followerUserRelationsArgs = {
    /**
     * Select specific fields to fetch from the TwitterUserRelation
     */
    select?: TwitterUserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserRelationInclude | null
    where?: TwitterUserRelationWhereInput
    orderBy?: Enumerable<TwitterUserRelationOrderByWithRelationInput>
    cursor?: TwitterUserRelationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TwitterUserRelationScalarFieldEnum>
  }


  /**
   * TwitterUser without action
   */
  export type TwitterUserArgs = {
    /**
     * Select specific fields to fetch from the TwitterUser
     */
    select?: TwitterUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserInclude | null
  }



  /**
   * Model TwitterPost
   */


  export type AggregateTwitterPost = {
    _count: TwitterPostCountAggregateOutputType | null
    _avg: TwitterPostAvgAggregateOutputType | null
    _sum: TwitterPostSumAggregateOutputType | null
    _min: TwitterPostMinAggregateOutputType | null
    _max: TwitterPostMaxAggregateOutputType | null
  }

  export type TwitterPostAvgAggregateOutputType = {
    id: number | null
    twitterUserId: number | null
  }

  export type TwitterPostSumAggregateOutputType = {
    id: number | null
    twitterUserId: number | null
  }

  export type TwitterPostMinAggregateOutputType = {
    id: number | null
    post: string | null
    createdAt: Date | null
    updatedAt: Date | null
    twitterUserId: number | null
  }

  export type TwitterPostMaxAggregateOutputType = {
    id: number | null
    post: string | null
    createdAt: Date | null
    updatedAt: Date | null
    twitterUserId: number | null
  }

  export type TwitterPostCountAggregateOutputType = {
    id: number
    post: number
    createdAt: number
    updatedAt: number
    twitterUserId: number
    _all: number
  }


  export type TwitterPostAvgAggregateInputType = {
    id?: true
    twitterUserId?: true
  }

  export type TwitterPostSumAggregateInputType = {
    id?: true
    twitterUserId?: true
  }

  export type TwitterPostMinAggregateInputType = {
    id?: true
    post?: true
    createdAt?: true
    updatedAt?: true
    twitterUserId?: true
  }

  export type TwitterPostMaxAggregateInputType = {
    id?: true
    post?: true
    createdAt?: true
    updatedAt?: true
    twitterUserId?: true
  }

  export type TwitterPostCountAggregateInputType = {
    id?: true
    post?: true
    createdAt?: true
    updatedAt?: true
    twitterUserId?: true
    _all?: true
  }

  export type TwitterPostAggregateArgs = {
    /**
     * Filter which TwitterPost to aggregate.
     */
    where?: TwitterPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterPosts to fetch.
     */
    orderBy?: Enumerable<TwitterPostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TwitterPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TwitterPosts
    **/
    _count?: true | TwitterPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TwitterPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TwitterPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TwitterPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TwitterPostMaxAggregateInputType
  }

  export type GetTwitterPostAggregateType<T extends TwitterPostAggregateArgs> = {
        [P in keyof T & keyof AggregateTwitterPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTwitterPost[P]>
      : GetScalarType<T[P], AggregateTwitterPost[P]>
  }




  export type TwitterPostGroupByArgs = {
    where?: TwitterPostWhereInput
    orderBy?: Enumerable<TwitterPostOrderByWithAggregationInput>
    by: TwitterPostScalarFieldEnum[]
    having?: TwitterPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TwitterPostCountAggregateInputType | true
    _avg?: TwitterPostAvgAggregateInputType
    _sum?: TwitterPostSumAggregateInputType
    _min?: TwitterPostMinAggregateInputType
    _max?: TwitterPostMaxAggregateInputType
  }


  export type TwitterPostGroupByOutputType = {
    id: number
    post: string
    createdAt: Date
    updatedAt: Date
    twitterUserId: number
    _count: TwitterPostCountAggregateOutputType | null
    _avg: TwitterPostAvgAggregateOutputType | null
    _sum: TwitterPostSumAggregateOutputType | null
    _min: TwitterPostMinAggregateOutputType | null
    _max: TwitterPostMaxAggregateOutputType | null
  }

  type GetTwitterPostGroupByPayload<T extends TwitterPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TwitterPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TwitterPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TwitterPostGroupByOutputType[P]>
            : GetScalarType<T[P], TwitterPostGroupByOutputType[P]>
        }
      >
    >


  export type TwitterPostSelect = {
    id?: boolean
    user?: boolean | TwitterUserArgs
    post?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    twitterUserId?: boolean
    postToHashtags?: boolean | TwitterPost$postToHashtagsArgs
    comments?: boolean | TwitterPost$commentsArgs
    _count?: boolean | TwitterPostCountOutputTypeArgs
  }


  export type TwitterPostInclude = {
    user?: boolean | TwitterUserArgs
    postToHashtags?: boolean | TwitterPost$postToHashtagsArgs
    comments?: boolean | TwitterPost$commentsArgs
    _count?: boolean | TwitterPostCountOutputTypeArgs
  }

  export type TwitterPostGetPayload<S extends boolean | null | undefined | TwitterPostArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TwitterPost :
    S extends undefined ? never :
    S extends { include: any } & (TwitterPostArgs | TwitterPostFindManyArgs)
    ? TwitterPost  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? TwitterUserGetPayload<S['include'][P]> :
        P extends 'postToHashtags' ? Array < TwitterPostToHashtagGetPayload<S['include'][P]>>  :
        P extends 'comments' ? Array < TwitterCommentGetPayload<S['include'][P]>>  :
        P extends '_count' ? TwitterPostCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TwitterPostArgs | TwitterPostFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? TwitterUserGetPayload<S['select'][P]> :
        P extends 'postToHashtags' ? Array < TwitterPostToHashtagGetPayload<S['select'][P]>>  :
        P extends 'comments' ? Array < TwitterCommentGetPayload<S['select'][P]>>  :
        P extends '_count' ? TwitterPostCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof TwitterPost ? TwitterPost[P] : never
  } 
      : TwitterPost


  type TwitterPostCountArgs = 
    Omit<TwitterPostFindManyArgs, 'select' | 'include'> & {
      select?: TwitterPostCountAggregateInputType | true
    }

  export interface TwitterPostDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TwitterPost that matches the filter.
     * @param {TwitterPostFindUniqueArgs} args - Arguments to find a TwitterPost
     * @example
     * // Get one TwitterPost
     * const twitterPost = await prisma.twitterPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TwitterPostFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TwitterPostFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TwitterPost'> extends True ? Prisma__TwitterPostClient<TwitterPostGetPayload<T>> : Prisma__TwitterPostClient<TwitterPostGetPayload<T> | null, null>

    /**
     * Find one TwitterPost that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TwitterPostFindUniqueOrThrowArgs} args - Arguments to find a TwitterPost
     * @example
     * // Get one TwitterPost
     * const twitterPost = await prisma.twitterPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TwitterPostFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TwitterPostFindUniqueOrThrowArgs>
    ): Prisma__TwitterPostClient<TwitterPostGetPayload<T>>

    /**
     * Find the first TwitterPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterPostFindFirstArgs} args - Arguments to find a TwitterPost
     * @example
     * // Get one TwitterPost
     * const twitterPost = await prisma.twitterPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TwitterPostFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TwitterPostFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TwitterPost'> extends True ? Prisma__TwitterPostClient<TwitterPostGetPayload<T>> : Prisma__TwitterPostClient<TwitterPostGetPayload<T> | null, null>

    /**
     * Find the first TwitterPost that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterPostFindFirstOrThrowArgs} args - Arguments to find a TwitterPost
     * @example
     * // Get one TwitterPost
     * const twitterPost = await prisma.twitterPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TwitterPostFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TwitterPostFindFirstOrThrowArgs>
    ): Prisma__TwitterPostClient<TwitterPostGetPayload<T>>

    /**
     * Find zero or more TwitterPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterPostFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TwitterPosts
     * const twitterPosts = await prisma.twitterPost.findMany()
     * 
     * // Get first 10 TwitterPosts
     * const twitterPosts = await prisma.twitterPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const twitterPostWithIdOnly = await prisma.twitterPost.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TwitterPostFindManyArgs>(
      args?: SelectSubset<T, TwitterPostFindManyArgs>
    ): Prisma.PrismaPromise<Array<TwitterPostGetPayload<T>>>

    /**
     * Create a TwitterPost.
     * @param {TwitterPostCreateArgs} args - Arguments to create a TwitterPost.
     * @example
     * // Create one TwitterPost
     * const TwitterPost = await prisma.twitterPost.create({
     *   data: {
     *     // ... data to create a TwitterPost
     *   }
     * })
     * 
    **/
    create<T extends TwitterPostCreateArgs>(
      args: SelectSubset<T, TwitterPostCreateArgs>
    ): Prisma__TwitterPostClient<TwitterPostGetPayload<T>>

    /**
     * Create many TwitterPosts.
     *     @param {TwitterPostCreateManyArgs} args - Arguments to create many TwitterPosts.
     *     @example
     *     // Create many TwitterPosts
     *     const twitterPost = await prisma.twitterPost.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TwitterPostCreateManyArgs>(
      args?: SelectSubset<T, TwitterPostCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TwitterPost.
     * @param {TwitterPostDeleteArgs} args - Arguments to delete one TwitterPost.
     * @example
     * // Delete one TwitterPost
     * const TwitterPost = await prisma.twitterPost.delete({
     *   where: {
     *     // ... filter to delete one TwitterPost
     *   }
     * })
     * 
    **/
    delete<T extends TwitterPostDeleteArgs>(
      args: SelectSubset<T, TwitterPostDeleteArgs>
    ): Prisma__TwitterPostClient<TwitterPostGetPayload<T>>

    /**
     * Update one TwitterPost.
     * @param {TwitterPostUpdateArgs} args - Arguments to update one TwitterPost.
     * @example
     * // Update one TwitterPost
     * const twitterPost = await prisma.twitterPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TwitterPostUpdateArgs>(
      args: SelectSubset<T, TwitterPostUpdateArgs>
    ): Prisma__TwitterPostClient<TwitterPostGetPayload<T>>

    /**
     * Delete zero or more TwitterPosts.
     * @param {TwitterPostDeleteManyArgs} args - Arguments to filter TwitterPosts to delete.
     * @example
     * // Delete a few TwitterPosts
     * const { count } = await prisma.twitterPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TwitterPostDeleteManyArgs>(
      args?: SelectSubset<T, TwitterPostDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TwitterPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TwitterPosts
     * const twitterPost = await prisma.twitterPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TwitterPostUpdateManyArgs>(
      args: SelectSubset<T, TwitterPostUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TwitterPost.
     * @param {TwitterPostUpsertArgs} args - Arguments to update or create a TwitterPost.
     * @example
     * // Update or create a TwitterPost
     * const twitterPost = await prisma.twitterPost.upsert({
     *   create: {
     *     // ... data to create a TwitterPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TwitterPost we want to update
     *   }
     * })
    **/
    upsert<T extends TwitterPostUpsertArgs>(
      args: SelectSubset<T, TwitterPostUpsertArgs>
    ): Prisma__TwitterPostClient<TwitterPostGetPayload<T>>

    /**
     * Count the number of TwitterPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterPostCountArgs} args - Arguments to filter TwitterPosts to count.
     * @example
     * // Count the number of TwitterPosts
     * const count = await prisma.twitterPost.count({
     *   where: {
     *     // ... the filter for the TwitterPosts we want to count
     *   }
     * })
    **/
    count<T extends TwitterPostCountArgs>(
      args?: Subset<T, TwitterPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TwitterPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TwitterPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TwitterPostAggregateArgs>(args: Subset<T, TwitterPostAggregateArgs>): Prisma.PrismaPromise<GetTwitterPostAggregateType<T>>

    /**
     * Group by TwitterPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TwitterPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TwitterPostGroupByArgs['orderBy'] }
        : { orderBy?: TwitterPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TwitterPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTwitterPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TwitterPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TwitterPostClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends TwitterUserArgs= {}>(args?: Subset<T, TwitterUserArgs>): Prisma__TwitterUserClient<TwitterUserGetPayload<T> | Null>;

    postToHashtags<T extends TwitterPost$postToHashtagsArgs= {}>(args?: Subset<T, TwitterPost$postToHashtagsArgs>): Prisma.PrismaPromise<Array<TwitterPostToHashtagGetPayload<T>>| Null>;

    comments<T extends TwitterPost$commentsArgs= {}>(args?: Subset<T, TwitterPost$commentsArgs>): Prisma.PrismaPromise<Array<TwitterCommentGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TwitterPost base type for findUnique actions
   */
  export type TwitterPostFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TwitterPost
     */
    select?: TwitterPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostInclude | null
    /**
     * Filter, which TwitterPost to fetch.
     */
    where: TwitterPostWhereUniqueInput
  }

  /**
   * TwitterPost findUnique
   */
  export interface TwitterPostFindUniqueArgs extends TwitterPostFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TwitterPost findUniqueOrThrow
   */
  export type TwitterPostFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TwitterPost
     */
    select?: TwitterPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostInclude | null
    /**
     * Filter, which TwitterPost to fetch.
     */
    where: TwitterPostWhereUniqueInput
  }


  /**
   * TwitterPost base type for findFirst actions
   */
  export type TwitterPostFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TwitterPost
     */
    select?: TwitterPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostInclude | null
    /**
     * Filter, which TwitterPost to fetch.
     */
    where?: TwitterPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterPosts to fetch.
     */
    orderBy?: Enumerable<TwitterPostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterPosts.
     */
    cursor?: TwitterPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterPosts.
     */
    distinct?: Enumerable<TwitterPostScalarFieldEnum>
  }

  /**
   * TwitterPost findFirst
   */
  export interface TwitterPostFindFirstArgs extends TwitterPostFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TwitterPost findFirstOrThrow
   */
  export type TwitterPostFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TwitterPost
     */
    select?: TwitterPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostInclude | null
    /**
     * Filter, which TwitterPost to fetch.
     */
    where?: TwitterPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterPosts to fetch.
     */
    orderBy?: Enumerable<TwitterPostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterPosts.
     */
    cursor?: TwitterPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterPosts.
     */
    distinct?: Enumerable<TwitterPostScalarFieldEnum>
  }


  /**
   * TwitterPost findMany
   */
  export type TwitterPostFindManyArgs = {
    /**
     * Select specific fields to fetch from the TwitterPost
     */
    select?: TwitterPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostInclude | null
    /**
     * Filter, which TwitterPosts to fetch.
     */
    where?: TwitterPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterPosts to fetch.
     */
    orderBy?: Enumerable<TwitterPostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TwitterPosts.
     */
    cursor?: TwitterPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterPosts.
     */
    skip?: number
    distinct?: Enumerable<TwitterPostScalarFieldEnum>
  }


  /**
   * TwitterPost create
   */
  export type TwitterPostCreateArgs = {
    /**
     * Select specific fields to fetch from the TwitterPost
     */
    select?: TwitterPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostInclude | null
    /**
     * The data needed to create a TwitterPost.
     */
    data: XOR<TwitterPostCreateInput, TwitterPostUncheckedCreateInput>
  }


  /**
   * TwitterPost createMany
   */
  export type TwitterPostCreateManyArgs = {
    /**
     * The data used to create many TwitterPosts.
     */
    data: Enumerable<TwitterPostCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TwitterPost update
   */
  export type TwitterPostUpdateArgs = {
    /**
     * Select specific fields to fetch from the TwitterPost
     */
    select?: TwitterPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostInclude | null
    /**
     * The data needed to update a TwitterPost.
     */
    data: XOR<TwitterPostUpdateInput, TwitterPostUncheckedUpdateInput>
    /**
     * Choose, which TwitterPost to update.
     */
    where: TwitterPostWhereUniqueInput
  }


  /**
   * TwitterPost updateMany
   */
  export type TwitterPostUpdateManyArgs = {
    /**
     * The data used to update TwitterPosts.
     */
    data: XOR<TwitterPostUpdateManyMutationInput, TwitterPostUncheckedUpdateManyInput>
    /**
     * Filter which TwitterPosts to update
     */
    where?: TwitterPostWhereInput
  }


  /**
   * TwitterPost upsert
   */
  export type TwitterPostUpsertArgs = {
    /**
     * Select specific fields to fetch from the TwitterPost
     */
    select?: TwitterPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostInclude | null
    /**
     * The filter to search for the TwitterPost to update in case it exists.
     */
    where: TwitterPostWhereUniqueInput
    /**
     * In case the TwitterPost found by the `where` argument doesn't exist, create a new TwitterPost with this data.
     */
    create: XOR<TwitterPostCreateInput, TwitterPostUncheckedCreateInput>
    /**
     * In case the TwitterPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TwitterPostUpdateInput, TwitterPostUncheckedUpdateInput>
  }


  /**
   * TwitterPost delete
   */
  export type TwitterPostDeleteArgs = {
    /**
     * Select specific fields to fetch from the TwitterPost
     */
    select?: TwitterPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostInclude | null
    /**
     * Filter which TwitterPost to delete.
     */
    where: TwitterPostWhereUniqueInput
  }


  /**
   * TwitterPost deleteMany
   */
  export type TwitterPostDeleteManyArgs = {
    /**
     * Filter which TwitterPosts to delete
     */
    where?: TwitterPostWhereInput
  }


  /**
   * TwitterPost.postToHashtags
   */
  export type TwitterPost$postToHashtagsArgs = {
    /**
     * Select specific fields to fetch from the TwitterPostToHashtag
     */
    select?: TwitterPostToHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostToHashtagInclude | null
    where?: TwitterPostToHashtagWhereInput
    orderBy?: Enumerable<TwitterPostToHashtagOrderByWithRelationInput>
    cursor?: TwitterPostToHashtagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TwitterPostToHashtagScalarFieldEnum>
  }


  /**
   * TwitterPost.comments
   */
  export type TwitterPost$commentsArgs = {
    /**
     * Select specific fields to fetch from the TwitterComment
     */
    select?: TwitterCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterCommentInclude | null
    where?: TwitterCommentWhereInput
    orderBy?: Enumerable<TwitterCommentOrderByWithRelationInput>
    cursor?: TwitterCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TwitterCommentScalarFieldEnum>
  }


  /**
   * TwitterPost without action
   */
  export type TwitterPostArgs = {
    /**
     * Select specific fields to fetch from the TwitterPost
     */
    select?: TwitterPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostInclude | null
  }



  /**
   * Model TwitterHashtag
   */


  export type AggregateTwitterHashtag = {
    _count: TwitterHashtagCountAggregateOutputType | null
    _avg: TwitterHashtagAvgAggregateOutputType | null
    _sum: TwitterHashtagSumAggregateOutputType | null
    _min: TwitterHashtagMinAggregateOutputType | null
    _max: TwitterHashtagMaxAggregateOutputType | null
  }

  export type TwitterHashtagAvgAggregateOutputType = {
    id: number | null
  }

  export type TwitterHashtagSumAggregateOutputType = {
    id: number | null
  }

  export type TwitterHashtagMinAggregateOutputType = {
    id: number | null
    hashtag: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TwitterHashtagMaxAggregateOutputType = {
    id: number | null
    hashtag: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TwitterHashtagCountAggregateOutputType = {
    id: number
    hashtag: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TwitterHashtagAvgAggregateInputType = {
    id?: true
  }

  export type TwitterHashtagSumAggregateInputType = {
    id?: true
  }

  export type TwitterHashtagMinAggregateInputType = {
    id?: true
    hashtag?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TwitterHashtagMaxAggregateInputType = {
    id?: true
    hashtag?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TwitterHashtagCountAggregateInputType = {
    id?: true
    hashtag?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TwitterHashtagAggregateArgs = {
    /**
     * Filter which TwitterHashtag to aggregate.
     */
    where?: TwitterHashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterHashtags to fetch.
     */
    orderBy?: Enumerable<TwitterHashtagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TwitterHashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterHashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterHashtags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TwitterHashtags
    **/
    _count?: true | TwitterHashtagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TwitterHashtagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TwitterHashtagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TwitterHashtagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TwitterHashtagMaxAggregateInputType
  }

  export type GetTwitterHashtagAggregateType<T extends TwitterHashtagAggregateArgs> = {
        [P in keyof T & keyof AggregateTwitterHashtag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTwitterHashtag[P]>
      : GetScalarType<T[P], AggregateTwitterHashtag[P]>
  }




  export type TwitterHashtagGroupByArgs = {
    where?: TwitterHashtagWhereInput
    orderBy?: Enumerable<TwitterHashtagOrderByWithAggregationInput>
    by: TwitterHashtagScalarFieldEnum[]
    having?: TwitterHashtagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TwitterHashtagCountAggregateInputType | true
    _avg?: TwitterHashtagAvgAggregateInputType
    _sum?: TwitterHashtagSumAggregateInputType
    _min?: TwitterHashtagMinAggregateInputType
    _max?: TwitterHashtagMaxAggregateInputType
  }


  export type TwitterHashtagGroupByOutputType = {
    id: number
    hashtag: string
    createdAt: Date
    updatedAt: Date
    _count: TwitterHashtagCountAggregateOutputType | null
    _avg: TwitterHashtagAvgAggregateOutputType | null
    _sum: TwitterHashtagSumAggregateOutputType | null
    _min: TwitterHashtagMinAggregateOutputType | null
    _max: TwitterHashtagMaxAggregateOutputType | null
  }

  type GetTwitterHashtagGroupByPayload<T extends TwitterHashtagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TwitterHashtagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TwitterHashtagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TwitterHashtagGroupByOutputType[P]>
            : GetScalarType<T[P], TwitterHashtagGroupByOutputType[P]>
        }
      >
    >


  export type TwitterHashtagSelect = {
    id?: boolean
    hashtag?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    postsToHashtags?: boolean | TwitterHashtag$postsToHashtagsArgs
    _count?: boolean | TwitterHashtagCountOutputTypeArgs
  }


  export type TwitterHashtagInclude = {
    postsToHashtags?: boolean | TwitterHashtag$postsToHashtagsArgs
    _count?: boolean | TwitterHashtagCountOutputTypeArgs
  }

  export type TwitterHashtagGetPayload<S extends boolean | null | undefined | TwitterHashtagArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TwitterHashtag :
    S extends undefined ? never :
    S extends { include: any } & (TwitterHashtagArgs | TwitterHashtagFindManyArgs)
    ? TwitterHashtag  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'postsToHashtags' ? Array < TwitterPostToHashtagGetPayload<S['include'][P]>>  :
        P extends '_count' ? TwitterHashtagCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TwitterHashtagArgs | TwitterHashtagFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'postsToHashtags' ? Array < TwitterPostToHashtagGetPayload<S['select'][P]>>  :
        P extends '_count' ? TwitterHashtagCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof TwitterHashtag ? TwitterHashtag[P] : never
  } 
      : TwitterHashtag


  type TwitterHashtagCountArgs = 
    Omit<TwitterHashtagFindManyArgs, 'select' | 'include'> & {
      select?: TwitterHashtagCountAggregateInputType | true
    }

  export interface TwitterHashtagDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TwitterHashtag that matches the filter.
     * @param {TwitterHashtagFindUniqueArgs} args - Arguments to find a TwitterHashtag
     * @example
     * // Get one TwitterHashtag
     * const twitterHashtag = await prisma.twitterHashtag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TwitterHashtagFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TwitterHashtagFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TwitterHashtag'> extends True ? Prisma__TwitterHashtagClient<TwitterHashtagGetPayload<T>> : Prisma__TwitterHashtagClient<TwitterHashtagGetPayload<T> | null, null>

    /**
     * Find one TwitterHashtag that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TwitterHashtagFindUniqueOrThrowArgs} args - Arguments to find a TwitterHashtag
     * @example
     * // Get one TwitterHashtag
     * const twitterHashtag = await prisma.twitterHashtag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TwitterHashtagFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TwitterHashtagFindUniqueOrThrowArgs>
    ): Prisma__TwitterHashtagClient<TwitterHashtagGetPayload<T>>

    /**
     * Find the first TwitterHashtag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterHashtagFindFirstArgs} args - Arguments to find a TwitterHashtag
     * @example
     * // Get one TwitterHashtag
     * const twitterHashtag = await prisma.twitterHashtag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TwitterHashtagFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TwitterHashtagFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TwitterHashtag'> extends True ? Prisma__TwitterHashtagClient<TwitterHashtagGetPayload<T>> : Prisma__TwitterHashtagClient<TwitterHashtagGetPayload<T> | null, null>

    /**
     * Find the first TwitterHashtag that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterHashtagFindFirstOrThrowArgs} args - Arguments to find a TwitterHashtag
     * @example
     * // Get one TwitterHashtag
     * const twitterHashtag = await prisma.twitterHashtag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TwitterHashtagFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TwitterHashtagFindFirstOrThrowArgs>
    ): Prisma__TwitterHashtagClient<TwitterHashtagGetPayload<T>>

    /**
     * Find zero or more TwitterHashtags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterHashtagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TwitterHashtags
     * const twitterHashtags = await prisma.twitterHashtag.findMany()
     * 
     * // Get first 10 TwitterHashtags
     * const twitterHashtags = await prisma.twitterHashtag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const twitterHashtagWithIdOnly = await prisma.twitterHashtag.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TwitterHashtagFindManyArgs>(
      args?: SelectSubset<T, TwitterHashtagFindManyArgs>
    ): Prisma.PrismaPromise<Array<TwitterHashtagGetPayload<T>>>

    /**
     * Create a TwitterHashtag.
     * @param {TwitterHashtagCreateArgs} args - Arguments to create a TwitterHashtag.
     * @example
     * // Create one TwitterHashtag
     * const TwitterHashtag = await prisma.twitterHashtag.create({
     *   data: {
     *     // ... data to create a TwitterHashtag
     *   }
     * })
     * 
    **/
    create<T extends TwitterHashtagCreateArgs>(
      args: SelectSubset<T, TwitterHashtagCreateArgs>
    ): Prisma__TwitterHashtagClient<TwitterHashtagGetPayload<T>>

    /**
     * Create many TwitterHashtags.
     *     @param {TwitterHashtagCreateManyArgs} args - Arguments to create many TwitterHashtags.
     *     @example
     *     // Create many TwitterHashtags
     *     const twitterHashtag = await prisma.twitterHashtag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TwitterHashtagCreateManyArgs>(
      args?: SelectSubset<T, TwitterHashtagCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TwitterHashtag.
     * @param {TwitterHashtagDeleteArgs} args - Arguments to delete one TwitterHashtag.
     * @example
     * // Delete one TwitterHashtag
     * const TwitterHashtag = await prisma.twitterHashtag.delete({
     *   where: {
     *     // ... filter to delete one TwitterHashtag
     *   }
     * })
     * 
    **/
    delete<T extends TwitterHashtagDeleteArgs>(
      args: SelectSubset<T, TwitterHashtagDeleteArgs>
    ): Prisma__TwitterHashtagClient<TwitterHashtagGetPayload<T>>

    /**
     * Update one TwitterHashtag.
     * @param {TwitterHashtagUpdateArgs} args - Arguments to update one TwitterHashtag.
     * @example
     * // Update one TwitterHashtag
     * const twitterHashtag = await prisma.twitterHashtag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TwitterHashtagUpdateArgs>(
      args: SelectSubset<T, TwitterHashtagUpdateArgs>
    ): Prisma__TwitterHashtagClient<TwitterHashtagGetPayload<T>>

    /**
     * Delete zero or more TwitterHashtags.
     * @param {TwitterHashtagDeleteManyArgs} args - Arguments to filter TwitterHashtags to delete.
     * @example
     * // Delete a few TwitterHashtags
     * const { count } = await prisma.twitterHashtag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TwitterHashtagDeleteManyArgs>(
      args?: SelectSubset<T, TwitterHashtagDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TwitterHashtags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterHashtagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TwitterHashtags
     * const twitterHashtag = await prisma.twitterHashtag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TwitterHashtagUpdateManyArgs>(
      args: SelectSubset<T, TwitterHashtagUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TwitterHashtag.
     * @param {TwitterHashtagUpsertArgs} args - Arguments to update or create a TwitterHashtag.
     * @example
     * // Update or create a TwitterHashtag
     * const twitterHashtag = await prisma.twitterHashtag.upsert({
     *   create: {
     *     // ... data to create a TwitterHashtag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TwitterHashtag we want to update
     *   }
     * })
    **/
    upsert<T extends TwitterHashtagUpsertArgs>(
      args: SelectSubset<T, TwitterHashtagUpsertArgs>
    ): Prisma__TwitterHashtagClient<TwitterHashtagGetPayload<T>>

    /**
     * Count the number of TwitterHashtags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterHashtagCountArgs} args - Arguments to filter TwitterHashtags to count.
     * @example
     * // Count the number of TwitterHashtags
     * const count = await prisma.twitterHashtag.count({
     *   where: {
     *     // ... the filter for the TwitterHashtags we want to count
     *   }
     * })
    **/
    count<T extends TwitterHashtagCountArgs>(
      args?: Subset<T, TwitterHashtagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TwitterHashtagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TwitterHashtag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterHashtagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TwitterHashtagAggregateArgs>(args: Subset<T, TwitterHashtagAggregateArgs>): Prisma.PrismaPromise<GetTwitterHashtagAggregateType<T>>

    /**
     * Group by TwitterHashtag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterHashtagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TwitterHashtagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TwitterHashtagGroupByArgs['orderBy'] }
        : { orderBy?: TwitterHashtagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TwitterHashtagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTwitterHashtagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TwitterHashtag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TwitterHashtagClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    postsToHashtags<T extends TwitterHashtag$postsToHashtagsArgs= {}>(args?: Subset<T, TwitterHashtag$postsToHashtagsArgs>): Prisma.PrismaPromise<Array<TwitterPostToHashtagGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TwitterHashtag base type for findUnique actions
   */
  export type TwitterHashtagFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TwitterHashtag
     */
    select?: TwitterHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterHashtagInclude | null
    /**
     * Filter, which TwitterHashtag to fetch.
     */
    where: TwitterHashtagWhereUniqueInput
  }

  /**
   * TwitterHashtag findUnique
   */
  export interface TwitterHashtagFindUniqueArgs extends TwitterHashtagFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TwitterHashtag findUniqueOrThrow
   */
  export type TwitterHashtagFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TwitterHashtag
     */
    select?: TwitterHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterHashtagInclude | null
    /**
     * Filter, which TwitterHashtag to fetch.
     */
    where: TwitterHashtagWhereUniqueInput
  }


  /**
   * TwitterHashtag base type for findFirst actions
   */
  export type TwitterHashtagFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TwitterHashtag
     */
    select?: TwitterHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterHashtagInclude | null
    /**
     * Filter, which TwitterHashtag to fetch.
     */
    where?: TwitterHashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterHashtags to fetch.
     */
    orderBy?: Enumerable<TwitterHashtagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterHashtags.
     */
    cursor?: TwitterHashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterHashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterHashtags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterHashtags.
     */
    distinct?: Enumerable<TwitterHashtagScalarFieldEnum>
  }

  /**
   * TwitterHashtag findFirst
   */
  export interface TwitterHashtagFindFirstArgs extends TwitterHashtagFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TwitterHashtag findFirstOrThrow
   */
  export type TwitterHashtagFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TwitterHashtag
     */
    select?: TwitterHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterHashtagInclude | null
    /**
     * Filter, which TwitterHashtag to fetch.
     */
    where?: TwitterHashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterHashtags to fetch.
     */
    orderBy?: Enumerable<TwitterHashtagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterHashtags.
     */
    cursor?: TwitterHashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterHashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterHashtags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterHashtags.
     */
    distinct?: Enumerable<TwitterHashtagScalarFieldEnum>
  }


  /**
   * TwitterHashtag findMany
   */
  export type TwitterHashtagFindManyArgs = {
    /**
     * Select specific fields to fetch from the TwitterHashtag
     */
    select?: TwitterHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterHashtagInclude | null
    /**
     * Filter, which TwitterHashtags to fetch.
     */
    where?: TwitterHashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterHashtags to fetch.
     */
    orderBy?: Enumerable<TwitterHashtagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TwitterHashtags.
     */
    cursor?: TwitterHashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterHashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterHashtags.
     */
    skip?: number
    distinct?: Enumerable<TwitterHashtagScalarFieldEnum>
  }


  /**
   * TwitterHashtag create
   */
  export type TwitterHashtagCreateArgs = {
    /**
     * Select specific fields to fetch from the TwitterHashtag
     */
    select?: TwitterHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterHashtagInclude | null
    /**
     * The data needed to create a TwitterHashtag.
     */
    data: XOR<TwitterHashtagCreateInput, TwitterHashtagUncheckedCreateInput>
  }


  /**
   * TwitterHashtag createMany
   */
  export type TwitterHashtagCreateManyArgs = {
    /**
     * The data used to create many TwitterHashtags.
     */
    data: Enumerable<TwitterHashtagCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TwitterHashtag update
   */
  export type TwitterHashtagUpdateArgs = {
    /**
     * Select specific fields to fetch from the TwitterHashtag
     */
    select?: TwitterHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterHashtagInclude | null
    /**
     * The data needed to update a TwitterHashtag.
     */
    data: XOR<TwitterHashtagUpdateInput, TwitterHashtagUncheckedUpdateInput>
    /**
     * Choose, which TwitterHashtag to update.
     */
    where: TwitterHashtagWhereUniqueInput
  }


  /**
   * TwitterHashtag updateMany
   */
  export type TwitterHashtagUpdateManyArgs = {
    /**
     * The data used to update TwitterHashtags.
     */
    data: XOR<TwitterHashtagUpdateManyMutationInput, TwitterHashtagUncheckedUpdateManyInput>
    /**
     * Filter which TwitterHashtags to update
     */
    where?: TwitterHashtagWhereInput
  }


  /**
   * TwitterHashtag upsert
   */
  export type TwitterHashtagUpsertArgs = {
    /**
     * Select specific fields to fetch from the TwitterHashtag
     */
    select?: TwitterHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterHashtagInclude | null
    /**
     * The filter to search for the TwitterHashtag to update in case it exists.
     */
    where: TwitterHashtagWhereUniqueInput
    /**
     * In case the TwitterHashtag found by the `where` argument doesn't exist, create a new TwitterHashtag with this data.
     */
    create: XOR<TwitterHashtagCreateInput, TwitterHashtagUncheckedCreateInput>
    /**
     * In case the TwitterHashtag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TwitterHashtagUpdateInput, TwitterHashtagUncheckedUpdateInput>
  }


  /**
   * TwitterHashtag delete
   */
  export type TwitterHashtagDeleteArgs = {
    /**
     * Select specific fields to fetch from the TwitterHashtag
     */
    select?: TwitterHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterHashtagInclude | null
    /**
     * Filter which TwitterHashtag to delete.
     */
    where: TwitterHashtagWhereUniqueInput
  }


  /**
   * TwitterHashtag deleteMany
   */
  export type TwitterHashtagDeleteManyArgs = {
    /**
     * Filter which TwitterHashtags to delete
     */
    where?: TwitterHashtagWhereInput
  }


  /**
   * TwitterHashtag.postsToHashtags
   */
  export type TwitterHashtag$postsToHashtagsArgs = {
    /**
     * Select specific fields to fetch from the TwitterPostToHashtag
     */
    select?: TwitterPostToHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostToHashtagInclude | null
    where?: TwitterPostToHashtagWhereInput
    orderBy?: Enumerable<TwitterPostToHashtagOrderByWithRelationInput>
    cursor?: TwitterPostToHashtagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TwitterPostToHashtagScalarFieldEnum>
  }


  /**
   * TwitterHashtag without action
   */
  export type TwitterHashtagArgs = {
    /**
     * Select specific fields to fetch from the TwitterHashtag
     */
    select?: TwitterHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterHashtagInclude | null
  }



  /**
   * Model TwitterPostToHashtag
   */


  export type AggregateTwitterPostToHashtag = {
    _count: TwitterPostToHashtagCountAggregateOutputType | null
    _avg: TwitterPostToHashtagAvgAggregateOutputType | null
    _sum: TwitterPostToHashtagSumAggregateOutputType | null
    _min: TwitterPostToHashtagMinAggregateOutputType | null
    _max: TwitterPostToHashtagMaxAggregateOutputType | null
  }

  export type TwitterPostToHashtagAvgAggregateOutputType = {
    id: number | null
    twitterPostId: number | null
    twitterHashtagId: number | null
  }

  export type TwitterPostToHashtagSumAggregateOutputType = {
    id: number | null
    twitterPostId: number | null
    twitterHashtagId: number | null
  }

  export type TwitterPostToHashtagMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    twitterPostId: number | null
    twitterHashtagId: number | null
  }

  export type TwitterPostToHashtagMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    twitterPostId: number | null
    twitterHashtagId: number | null
  }

  export type TwitterPostToHashtagCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    twitterPostId: number
    twitterHashtagId: number
    _all: number
  }


  export type TwitterPostToHashtagAvgAggregateInputType = {
    id?: true
    twitterPostId?: true
    twitterHashtagId?: true
  }

  export type TwitterPostToHashtagSumAggregateInputType = {
    id?: true
    twitterPostId?: true
    twitterHashtagId?: true
  }

  export type TwitterPostToHashtagMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    twitterPostId?: true
    twitterHashtagId?: true
  }

  export type TwitterPostToHashtagMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    twitterPostId?: true
    twitterHashtagId?: true
  }

  export type TwitterPostToHashtagCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    twitterPostId?: true
    twitterHashtagId?: true
    _all?: true
  }

  export type TwitterPostToHashtagAggregateArgs = {
    /**
     * Filter which TwitterPostToHashtag to aggregate.
     */
    where?: TwitterPostToHashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterPostToHashtags to fetch.
     */
    orderBy?: Enumerable<TwitterPostToHashtagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TwitterPostToHashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterPostToHashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterPostToHashtags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TwitterPostToHashtags
    **/
    _count?: true | TwitterPostToHashtagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TwitterPostToHashtagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TwitterPostToHashtagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TwitterPostToHashtagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TwitterPostToHashtagMaxAggregateInputType
  }

  export type GetTwitterPostToHashtagAggregateType<T extends TwitterPostToHashtagAggregateArgs> = {
        [P in keyof T & keyof AggregateTwitterPostToHashtag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTwitterPostToHashtag[P]>
      : GetScalarType<T[P], AggregateTwitterPostToHashtag[P]>
  }




  export type TwitterPostToHashtagGroupByArgs = {
    where?: TwitterPostToHashtagWhereInput
    orderBy?: Enumerable<TwitterPostToHashtagOrderByWithAggregationInput>
    by: TwitterPostToHashtagScalarFieldEnum[]
    having?: TwitterPostToHashtagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TwitterPostToHashtagCountAggregateInputType | true
    _avg?: TwitterPostToHashtagAvgAggregateInputType
    _sum?: TwitterPostToHashtagSumAggregateInputType
    _min?: TwitterPostToHashtagMinAggregateInputType
    _max?: TwitterPostToHashtagMaxAggregateInputType
  }


  export type TwitterPostToHashtagGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    twitterPostId: number
    twitterHashtagId: number
    _count: TwitterPostToHashtagCountAggregateOutputType | null
    _avg: TwitterPostToHashtagAvgAggregateOutputType | null
    _sum: TwitterPostToHashtagSumAggregateOutputType | null
    _min: TwitterPostToHashtagMinAggregateOutputType | null
    _max: TwitterPostToHashtagMaxAggregateOutputType | null
  }

  type GetTwitterPostToHashtagGroupByPayload<T extends TwitterPostToHashtagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TwitterPostToHashtagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TwitterPostToHashtagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TwitterPostToHashtagGroupByOutputType[P]>
            : GetScalarType<T[P], TwitterPostToHashtagGroupByOutputType[P]>
        }
      >
    >


  export type TwitterPostToHashtagSelect = {
    id?: boolean
    post?: boolean | TwitterPostArgs
    hashtag?: boolean | TwitterHashtagArgs
    createdAt?: boolean
    updatedAt?: boolean
    twitterPostId?: boolean
    twitterHashtagId?: boolean
  }


  export type TwitterPostToHashtagInclude = {
    post?: boolean | TwitterPostArgs
    hashtag?: boolean | TwitterHashtagArgs
  }

  export type TwitterPostToHashtagGetPayload<S extends boolean | null | undefined | TwitterPostToHashtagArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TwitterPostToHashtag :
    S extends undefined ? never :
    S extends { include: any } & (TwitterPostToHashtagArgs | TwitterPostToHashtagFindManyArgs)
    ? TwitterPostToHashtag  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'post' ? TwitterPostGetPayload<S['include'][P]> :
        P extends 'hashtag' ? TwitterHashtagGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TwitterPostToHashtagArgs | TwitterPostToHashtagFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'post' ? TwitterPostGetPayload<S['select'][P]> :
        P extends 'hashtag' ? TwitterHashtagGetPayload<S['select'][P]> :  P extends keyof TwitterPostToHashtag ? TwitterPostToHashtag[P] : never
  } 
      : TwitterPostToHashtag


  type TwitterPostToHashtagCountArgs = 
    Omit<TwitterPostToHashtagFindManyArgs, 'select' | 'include'> & {
      select?: TwitterPostToHashtagCountAggregateInputType | true
    }

  export interface TwitterPostToHashtagDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TwitterPostToHashtag that matches the filter.
     * @param {TwitterPostToHashtagFindUniqueArgs} args - Arguments to find a TwitterPostToHashtag
     * @example
     * // Get one TwitterPostToHashtag
     * const twitterPostToHashtag = await prisma.twitterPostToHashtag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TwitterPostToHashtagFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TwitterPostToHashtagFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TwitterPostToHashtag'> extends True ? Prisma__TwitterPostToHashtagClient<TwitterPostToHashtagGetPayload<T>> : Prisma__TwitterPostToHashtagClient<TwitterPostToHashtagGetPayload<T> | null, null>

    /**
     * Find one TwitterPostToHashtag that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TwitterPostToHashtagFindUniqueOrThrowArgs} args - Arguments to find a TwitterPostToHashtag
     * @example
     * // Get one TwitterPostToHashtag
     * const twitterPostToHashtag = await prisma.twitterPostToHashtag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TwitterPostToHashtagFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TwitterPostToHashtagFindUniqueOrThrowArgs>
    ): Prisma__TwitterPostToHashtagClient<TwitterPostToHashtagGetPayload<T>>

    /**
     * Find the first TwitterPostToHashtag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterPostToHashtagFindFirstArgs} args - Arguments to find a TwitterPostToHashtag
     * @example
     * // Get one TwitterPostToHashtag
     * const twitterPostToHashtag = await prisma.twitterPostToHashtag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TwitterPostToHashtagFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TwitterPostToHashtagFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TwitterPostToHashtag'> extends True ? Prisma__TwitterPostToHashtagClient<TwitterPostToHashtagGetPayload<T>> : Prisma__TwitterPostToHashtagClient<TwitterPostToHashtagGetPayload<T> | null, null>

    /**
     * Find the first TwitterPostToHashtag that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterPostToHashtagFindFirstOrThrowArgs} args - Arguments to find a TwitterPostToHashtag
     * @example
     * // Get one TwitterPostToHashtag
     * const twitterPostToHashtag = await prisma.twitterPostToHashtag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TwitterPostToHashtagFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TwitterPostToHashtagFindFirstOrThrowArgs>
    ): Prisma__TwitterPostToHashtagClient<TwitterPostToHashtagGetPayload<T>>

    /**
     * Find zero or more TwitterPostToHashtags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterPostToHashtagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TwitterPostToHashtags
     * const twitterPostToHashtags = await prisma.twitterPostToHashtag.findMany()
     * 
     * // Get first 10 TwitterPostToHashtags
     * const twitterPostToHashtags = await prisma.twitterPostToHashtag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const twitterPostToHashtagWithIdOnly = await prisma.twitterPostToHashtag.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TwitterPostToHashtagFindManyArgs>(
      args?: SelectSubset<T, TwitterPostToHashtagFindManyArgs>
    ): Prisma.PrismaPromise<Array<TwitterPostToHashtagGetPayload<T>>>

    /**
     * Create a TwitterPostToHashtag.
     * @param {TwitterPostToHashtagCreateArgs} args - Arguments to create a TwitterPostToHashtag.
     * @example
     * // Create one TwitterPostToHashtag
     * const TwitterPostToHashtag = await prisma.twitterPostToHashtag.create({
     *   data: {
     *     // ... data to create a TwitterPostToHashtag
     *   }
     * })
     * 
    **/
    create<T extends TwitterPostToHashtagCreateArgs>(
      args: SelectSubset<T, TwitterPostToHashtagCreateArgs>
    ): Prisma__TwitterPostToHashtagClient<TwitterPostToHashtagGetPayload<T>>

    /**
     * Create many TwitterPostToHashtags.
     *     @param {TwitterPostToHashtagCreateManyArgs} args - Arguments to create many TwitterPostToHashtags.
     *     @example
     *     // Create many TwitterPostToHashtags
     *     const twitterPostToHashtag = await prisma.twitterPostToHashtag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TwitterPostToHashtagCreateManyArgs>(
      args?: SelectSubset<T, TwitterPostToHashtagCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TwitterPostToHashtag.
     * @param {TwitterPostToHashtagDeleteArgs} args - Arguments to delete one TwitterPostToHashtag.
     * @example
     * // Delete one TwitterPostToHashtag
     * const TwitterPostToHashtag = await prisma.twitterPostToHashtag.delete({
     *   where: {
     *     // ... filter to delete one TwitterPostToHashtag
     *   }
     * })
     * 
    **/
    delete<T extends TwitterPostToHashtagDeleteArgs>(
      args: SelectSubset<T, TwitterPostToHashtagDeleteArgs>
    ): Prisma__TwitterPostToHashtagClient<TwitterPostToHashtagGetPayload<T>>

    /**
     * Update one TwitterPostToHashtag.
     * @param {TwitterPostToHashtagUpdateArgs} args - Arguments to update one TwitterPostToHashtag.
     * @example
     * // Update one TwitterPostToHashtag
     * const twitterPostToHashtag = await prisma.twitterPostToHashtag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TwitterPostToHashtagUpdateArgs>(
      args: SelectSubset<T, TwitterPostToHashtagUpdateArgs>
    ): Prisma__TwitterPostToHashtagClient<TwitterPostToHashtagGetPayload<T>>

    /**
     * Delete zero or more TwitterPostToHashtags.
     * @param {TwitterPostToHashtagDeleteManyArgs} args - Arguments to filter TwitterPostToHashtags to delete.
     * @example
     * // Delete a few TwitterPostToHashtags
     * const { count } = await prisma.twitterPostToHashtag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TwitterPostToHashtagDeleteManyArgs>(
      args?: SelectSubset<T, TwitterPostToHashtagDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TwitterPostToHashtags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterPostToHashtagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TwitterPostToHashtags
     * const twitterPostToHashtag = await prisma.twitterPostToHashtag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TwitterPostToHashtagUpdateManyArgs>(
      args: SelectSubset<T, TwitterPostToHashtagUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TwitterPostToHashtag.
     * @param {TwitterPostToHashtagUpsertArgs} args - Arguments to update or create a TwitterPostToHashtag.
     * @example
     * // Update or create a TwitterPostToHashtag
     * const twitterPostToHashtag = await prisma.twitterPostToHashtag.upsert({
     *   create: {
     *     // ... data to create a TwitterPostToHashtag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TwitterPostToHashtag we want to update
     *   }
     * })
    **/
    upsert<T extends TwitterPostToHashtagUpsertArgs>(
      args: SelectSubset<T, TwitterPostToHashtagUpsertArgs>
    ): Prisma__TwitterPostToHashtagClient<TwitterPostToHashtagGetPayload<T>>

    /**
     * Count the number of TwitterPostToHashtags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterPostToHashtagCountArgs} args - Arguments to filter TwitterPostToHashtags to count.
     * @example
     * // Count the number of TwitterPostToHashtags
     * const count = await prisma.twitterPostToHashtag.count({
     *   where: {
     *     // ... the filter for the TwitterPostToHashtags we want to count
     *   }
     * })
    **/
    count<T extends TwitterPostToHashtagCountArgs>(
      args?: Subset<T, TwitterPostToHashtagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TwitterPostToHashtagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TwitterPostToHashtag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterPostToHashtagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TwitterPostToHashtagAggregateArgs>(args: Subset<T, TwitterPostToHashtagAggregateArgs>): Prisma.PrismaPromise<GetTwitterPostToHashtagAggregateType<T>>

    /**
     * Group by TwitterPostToHashtag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterPostToHashtagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TwitterPostToHashtagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TwitterPostToHashtagGroupByArgs['orderBy'] }
        : { orderBy?: TwitterPostToHashtagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TwitterPostToHashtagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTwitterPostToHashtagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TwitterPostToHashtag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TwitterPostToHashtagClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    post<T extends TwitterPostArgs= {}>(args?: Subset<T, TwitterPostArgs>): Prisma__TwitterPostClient<TwitterPostGetPayload<T> | Null>;

    hashtag<T extends TwitterHashtagArgs= {}>(args?: Subset<T, TwitterHashtagArgs>): Prisma__TwitterHashtagClient<TwitterHashtagGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TwitterPostToHashtag base type for findUnique actions
   */
  export type TwitterPostToHashtagFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TwitterPostToHashtag
     */
    select?: TwitterPostToHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostToHashtagInclude | null
    /**
     * Filter, which TwitterPostToHashtag to fetch.
     */
    where: TwitterPostToHashtagWhereUniqueInput
  }

  /**
   * TwitterPostToHashtag findUnique
   */
  export interface TwitterPostToHashtagFindUniqueArgs extends TwitterPostToHashtagFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TwitterPostToHashtag findUniqueOrThrow
   */
  export type TwitterPostToHashtagFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TwitterPostToHashtag
     */
    select?: TwitterPostToHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostToHashtagInclude | null
    /**
     * Filter, which TwitterPostToHashtag to fetch.
     */
    where: TwitterPostToHashtagWhereUniqueInput
  }


  /**
   * TwitterPostToHashtag base type for findFirst actions
   */
  export type TwitterPostToHashtagFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TwitterPostToHashtag
     */
    select?: TwitterPostToHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostToHashtagInclude | null
    /**
     * Filter, which TwitterPostToHashtag to fetch.
     */
    where?: TwitterPostToHashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterPostToHashtags to fetch.
     */
    orderBy?: Enumerable<TwitterPostToHashtagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterPostToHashtags.
     */
    cursor?: TwitterPostToHashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterPostToHashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterPostToHashtags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterPostToHashtags.
     */
    distinct?: Enumerable<TwitterPostToHashtagScalarFieldEnum>
  }

  /**
   * TwitterPostToHashtag findFirst
   */
  export interface TwitterPostToHashtagFindFirstArgs extends TwitterPostToHashtagFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TwitterPostToHashtag findFirstOrThrow
   */
  export type TwitterPostToHashtagFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TwitterPostToHashtag
     */
    select?: TwitterPostToHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostToHashtagInclude | null
    /**
     * Filter, which TwitterPostToHashtag to fetch.
     */
    where?: TwitterPostToHashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterPostToHashtags to fetch.
     */
    orderBy?: Enumerable<TwitterPostToHashtagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterPostToHashtags.
     */
    cursor?: TwitterPostToHashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterPostToHashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterPostToHashtags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterPostToHashtags.
     */
    distinct?: Enumerable<TwitterPostToHashtagScalarFieldEnum>
  }


  /**
   * TwitterPostToHashtag findMany
   */
  export type TwitterPostToHashtagFindManyArgs = {
    /**
     * Select specific fields to fetch from the TwitterPostToHashtag
     */
    select?: TwitterPostToHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostToHashtagInclude | null
    /**
     * Filter, which TwitterPostToHashtags to fetch.
     */
    where?: TwitterPostToHashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterPostToHashtags to fetch.
     */
    orderBy?: Enumerable<TwitterPostToHashtagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TwitterPostToHashtags.
     */
    cursor?: TwitterPostToHashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterPostToHashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterPostToHashtags.
     */
    skip?: number
    distinct?: Enumerable<TwitterPostToHashtagScalarFieldEnum>
  }


  /**
   * TwitterPostToHashtag create
   */
  export type TwitterPostToHashtagCreateArgs = {
    /**
     * Select specific fields to fetch from the TwitterPostToHashtag
     */
    select?: TwitterPostToHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostToHashtagInclude | null
    /**
     * The data needed to create a TwitterPostToHashtag.
     */
    data: XOR<TwitterPostToHashtagCreateInput, TwitterPostToHashtagUncheckedCreateInput>
  }


  /**
   * TwitterPostToHashtag createMany
   */
  export type TwitterPostToHashtagCreateManyArgs = {
    /**
     * The data used to create many TwitterPostToHashtags.
     */
    data: Enumerable<TwitterPostToHashtagCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TwitterPostToHashtag update
   */
  export type TwitterPostToHashtagUpdateArgs = {
    /**
     * Select specific fields to fetch from the TwitterPostToHashtag
     */
    select?: TwitterPostToHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostToHashtagInclude | null
    /**
     * The data needed to update a TwitterPostToHashtag.
     */
    data: XOR<TwitterPostToHashtagUpdateInput, TwitterPostToHashtagUncheckedUpdateInput>
    /**
     * Choose, which TwitterPostToHashtag to update.
     */
    where: TwitterPostToHashtagWhereUniqueInput
  }


  /**
   * TwitterPostToHashtag updateMany
   */
  export type TwitterPostToHashtagUpdateManyArgs = {
    /**
     * The data used to update TwitterPostToHashtags.
     */
    data: XOR<TwitterPostToHashtagUpdateManyMutationInput, TwitterPostToHashtagUncheckedUpdateManyInput>
    /**
     * Filter which TwitterPostToHashtags to update
     */
    where?: TwitterPostToHashtagWhereInput
  }


  /**
   * TwitterPostToHashtag upsert
   */
  export type TwitterPostToHashtagUpsertArgs = {
    /**
     * Select specific fields to fetch from the TwitterPostToHashtag
     */
    select?: TwitterPostToHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostToHashtagInclude | null
    /**
     * The filter to search for the TwitterPostToHashtag to update in case it exists.
     */
    where: TwitterPostToHashtagWhereUniqueInput
    /**
     * In case the TwitterPostToHashtag found by the `where` argument doesn't exist, create a new TwitterPostToHashtag with this data.
     */
    create: XOR<TwitterPostToHashtagCreateInput, TwitterPostToHashtagUncheckedCreateInput>
    /**
     * In case the TwitterPostToHashtag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TwitterPostToHashtagUpdateInput, TwitterPostToHashtagUncheckedUpdateInput>
  }


  /**
   * TwitterPostToHashtag delete
   */
  export type TwitterPostToHashtagDeleteArgs = {
    /**
     * Select specific fields to fetch from the TwitterPostToHashtag
     */
    select?: TwitterPostToHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostToHashtagInclude | null
    /**
     * Filter which TwitterPostToHashtag to delete.
     */
    where: TwitterPostToHashtagWhereUniqueInput
  }


  /**
   * TwitterPostToHashtag deleteMany
   */
  export type TwitterPostToHashtagDeleteManyArgs = {
    /**
     * Filter which TwitterPostToHashtags to delete
     */
    where?: TwitterPostToHashtagWhereInput
  }


  /**
   * TwitterPostToHashtag without action
   */
  export type TwitterPostToHashtagArgs = {
    /**
     * Select specific fields to fetch from the TwitterPostToHashtag
     */
    select?: TwitterPostToHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostToHashtagInclude | null
  }



  /**
   * Model TwitterDirectMessage
   */


  export type AggregateTwitterDirectMessage = {
    _count: TwitterDirectMessageCountAggregateOutputType | null
    _avg: TwitterDirectMessageAvgAggregateOutputType | null
    _sum: TwitterDirectMessageSumAggregateOutputType | null
    _min: TwitterDirectMessageMinAggregateOutputType | null
    _max: TwitterDirectMessageMaxAggregateOutputType | null
  }

  export type TwitterDirectMessageAvgAggregateOutputType = {
    id: number | null
    followingUserId: number | null
    followerUserId: number | null
  }

  export type TwitterDirectMessageSumAggregateOutputType = {
    id: number | null
    followingUserId: number | null
    followerUserId: number | null
  }

  export type TwitterDirectMessageMinAggregateOutputType = {
    id: number | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
    followingUserId: number | null
    followerUserId: number | null
  }

  export type TwitterDirectMessageMaxAggregateOutputType = {
    id: number | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
    followingUserId: number | null
    followerUserId: number | null
  }

  export type TwitterDirectMessageCountAggregateOutputType = {
    id: number
    message: number
    createdAt: number
    updatedAt: number
    followingUserId: number
    followerUserId: number
    _all: number
  }


  export type TwitterDirectMessageAvgAggregateInputType = {
    id?: true
    followingUserId?: true
    followerUserId?: true
  }

  export type TwitterDirectMessageSumAggregateInputType = {
    id?: true
    followingUserId?: true
    followerUserId?: true
  }

  export type TwitterDirectMessageMinAggregateInputType = {
    id?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    followingUserId?: true
    followerUserId?: true
  }

  export type TwitterDirectMessageMaxAggregateInputType = {
    id?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    followingUserId?: true
    followerUserId?: true
  }

  export type TwitterDirectMessageCountAggregateInputType = {
    id?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    followingUserId?: true
    followerUserId?: true
    _all?: true
  }

  export type TwitterDirectMessageAggregateArgs = {
    /**
     * Filter which TwitterDirectMessage to aggregate.
     */
    where?: TwitterDirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterDirectMessages to fetch.
     */
    orderBy?: Enumerable<TwitterDirectMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TwitterDirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterDirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterDirectMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TwitterDirectMessages
    **/
    _count?: true | TwitterDirectMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TwitterDirectMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TwitterDirectMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TwitterDirectMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TwitterDirectMessageMaxAggregateInputType
  }

  export type GetTwitterDirectMessageAggregateType<T extends TwitterDirectMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateTwitterDirectMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTwitterDirectMessage[P]>
      : GetScalarType<T[P], AggregateTwitterDirectMessage[P]>
  }




  export type TwitterDirectMessageGroupByArgs = {
    where?: TwitterDirectMessageWhereInput
    orderBy?: Enumerable<TwitterDirectMessageOrderByWithAggregationInput>
    by: TwitterDirectMessageScalarFieldEnum[]
    having?: TwitterDirectMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TwitterDirectMessageCountAggregateInputType | true
    _avg?: TwitterDirectMessageAvgAggregateInputType
    _sum?: TwitterDirectMessageSumAggregateInputType
    _min?: TwitterDirectMessageMinAggregateInputType
    _max?: TwitterDirectMessageMaxAggregateInputType
  }


  export type TwitterDirectMessageGroupByOutputType = {
    id: number
    message: string
    createdAt: Date
    updatedAt: Date
    followingUserId: number
    followerUserId: number
    _count: TwitterDirectMessageCountAggregateOutputType | null
    _avg: TwitterDirectMessageAvgAggregateOutputType | null
    _sum: TwitterDirectMessageSumAggregateOutputType | null
    _min: TwitterDirectMessageMinAggregateOutputType | null
    _max: TwitterDirectMessageMaxAggregateOutputType | null
  }

  type GetTwitterDirectMessageGroupByPayload<T extends TwitterDirectMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TwitterDirectMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TwitterDirectMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TwitterDirectMessageGroupByOutputType[P]>
            : GetScalarType<T[P], TwitterDirectMessageGroupByOutputType[P]>
        }
      >
    >


  export type TwitterDirectMessageSelect = {
    id?: boolean
    message?: boolean
    from?: boolean | TwitterUserArgs
    to?: boolean | TwitterUserArgs
    createdAt?: boolean
    updatedAt?: boolean
    followingUserId?: boolean
    followerUserId?: boolean
  }


  export type TwitterDirectMessageInclude = {
    from?: boolean | TwitterUserArgs
    to?: boolean | TwitterUserArgs
  }

  export type TwitterDirectMessageGetPayload<S extends boolean | null | undefined | TwitterDirectMessageArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TwitterDirectMessage :
    S extends undefined ? never :
    S extends { include: any } & (TwitterDirectMessageArgs | TwitterDirectMessageFindManyArgs)
    ? TwitterDirectMessage  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'from' ? TwitterUserGetPayload<S['include'][P]> :
        P extends 'to' ? TwitterUserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TwitterDirectMessageArgs | TwitterDirectMessageFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'from' ? TwitterUserGetPayload<S['select'][P]> :
        P extends 'to' ? TwitterUserGetPayload<S['select'][P]> :  P extends keyof TwitterDirectMessage ? TwitterDirectMessage[P] : never
  } 
      : TwitterDirectMessage


  type TwitterDirectMessageCountArgs = 
    Omit<TwitterDirectMessageFindManyArgs, 'select' | 'include'> & {
      select?: TwitterDirectMessageCountAggregateInputType | true
    }

  export interface TwitterDirectMessageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TwitterDirectMessage that matches the filter.
     * @param {TwitterDirectMessageFindUniqueArgs} args - Arguments to find a TwitterDirectMessage
     * @example
     * // Get one TwitterDirectMessage
     * const twitterDirectMessage = await prisma.twitterDirectMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TwitterDirectMessageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TwitterDirectMessageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TwitterDirectMessage'> extends True ? Prisma__TwitterDirectMessageClient<TwitterDirectMessageGetPayload<T>> : Prisma__TwitterDirectMessageClient<TwitterDirectMessageGetPayload<T> | null, null>

    /**
     * Find one TwitterDirectMessage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TwitterDirectMessageFindUniqueOrThrowArgs} args - Arguments to find a TwitterDirectMessage
     * @example
     * // Get one TwitterDirectMessage
     * const twitterDirectMessage = await prisma.twitterDirectMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TwitterDirectMessageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TwitterDirectMessageFindUniqueOrThrowArgs>
    ): Prisma__TwitterDirectMessageClient<TwitterDirectMessageGetPayload<T>>

    /**
     * Find the first TwitterDirectMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterDirectMessageFindFirstArgs} args - Arguments to find a TwitterDirectMessage
     * @example
     * // Get one TwitterDirectMessage
     * const twitterDirectMessage = await prisma.twitterDirectMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TwitterDirectMessageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TwitterDirectMessageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TwitterDirectMessage'> extends True ? Prisma__TwitterDirectMessageClient<TwitterDirectMessageGetPayload<T>> : Prisma__TwitterDirectMessageClient<TwitterDirectMessageGetPayload<T> | null, null>

    /**
     * Find the first TwitterDirectMessage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterDirectMessageFindFirstOrThrowArgs} args - Arguments to find a TwitterDirectMessage
     * @example
     * // Get one TwitterDirectMessage
     * const twitterDirectMessage = await prisma.twitterDirectMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TwitterDirectMessageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TwitterDirectMessageFindFirstOrThrowArgs>
    ): Prisma__TwitterDirectMessageClient<TwitterDirectMessageGetPayload<T>>

    /**
     * Find zero or more TwitterDirectMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterDirectMessageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TwitterDirectMessages
     * const twitterDirectMessages = await prisma.twitterDirectMessage.findMany()
     * 
     * // Get first 10 TwitterDirectMessages
     * const twitterDirectMessages = await prisma.twitterDirectMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const twitterDirectMessageWithIdOnly = await prisma.twitterDirectMessage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TwitterDirectMessageFindManyArgs>(
      args?: SelectSubset<T, TwitterDirectMessageFindManyArgs>
    ): Prisma.PrismaPromise<Array<TwitterDirectMessageGetPayload<T>>>

    /**
     * Create a TwitterDirectMessage.
     * @param {TwitterDirectMessageCreateArgs} args - Arguments to create a TwitterDirectMessage.
     * @example
     * // Create one TwitterDirectMessage
     * const TwitterDirectMessage = await prisma.twitterDirectMessage.create({
     *   data: {
     *     // ... data to create a TwitterDirectMessage
     *   }
     * })
     * 
    **/
    create<T extends TwitterDirectMessageCreateArgs>(
      args: SelectSubset<T, TwitterDirectMessageCreateArgs>
    ): Prisma__TwitterDirectMessageClient<TwitterDirectMessageGetPayload<T>>

    /**
     * Create many TwitterDirectMessages.
     *     @param {TwitterDirectMessageCreateManyArgs} args - Arguments to create many TwitterDirectMessages.
     *     @example
     *     // Create many TwitterDirectMessages
     *     const twitterDirectMessage = await prisma.twitterDirectMessage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TwitterDirectMessageCreateManyArgs>(
      args?: SelectSubset<T, TwitterDirectMessageCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TwitterDirectMessage.
     * @param {TwitterDirectMessageDeleteArgs} args - Arguments to delete one TwitterDirectMessage.
     * @example
     * // Delete one TwitterDirectMessage
     * const TwitterDirectMessage = await prisma.twitterDirectMessage.delete({
     *   where: {
     *     // ... filter to delete one TwitterDirectMessage
     *   }
     * })
     * 
    **/
    delete<T extends TwitterDirectMessageDeleteArgs>(
      args: SelectSubset<T, TwitterDirectMessageDeleteArgs>
    ): Prisma__TwitterDirectMessageClient<TwitterDirectMessageGetPayload<T>>

    /**
     * Update one TwitterDirectMessage.
     * @param {TwitterDirectMessageUpdateArgs} args - Arguments to update one TwitterDirectMessage.
     * @example
     * // Update one TwitterDirectMessage
     * const twitterDirectMessage = await prisma.twitterDirectMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TwitterDirectMessageUpdateArgs>(
      args: SelectSubset<T, TwitterDirectMessageUpdateArgs>
    ): Prisma__TwitterDirectMessageClient<TwitterDirectMessageGetPayload<T>>

    /**
     * Delete zero or more TwitterDirectMessages.
     * @param {TwitterDirectMessageDeleteManyArgs} args - Arguments to filter TwitterDirectMessages to delete.
     * @example
     * // Delete a few TwitterDirectMessages
     * const { count } = await prisma.twitterDirectMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TwitterDirectMessageDeleteManyArgs>(
      args?: SelectSubset<T, TwitterDirectMessageDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TwitterDirectMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterDirectMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TwitterDirectMessages
     * const twitterDirectMessage = await prisma.twitterDirectMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TwitterDirectMessageUpdateManyArgs>(
      args: SelectSubset<T, TwitterDirectMessageUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TwitterDirectMessage.
     * @param {TwitterDirectMessageUpsertArgs} args - Arguments to update or create a TwitterDirectMessage.
     * @example
     * // Update or create a TwitterDirectMessage
     * const twitterDirectMessage = await prisma.twitterDirectMessage.upsert({
     *   create: {
     *     // ... data to create a TwitterDirectMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TwitterDirectMessage we want to update
     *   }
     * })
    **/
    upsert<T extends TwitterDirectMessageUpsertArgs>(
      args: SelectSubset<T, TwitterDirectMessageUpsertArgs>
    ): Prisma__TwitterDirectMessageClient<TwitterDirectMessageGetPayload<T>>

    /**
     * Count the number of TwitterDirectMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterDirectMessageCountArgs} args - Arguments to filter TwitterDirectMessages to count.
     * @example
     * // Count the number of TwitterDirectMessages
     * const count = await prisma.twitterDirectMessage.count({
     *   where: {
     *     // ... the filter for the TwitterDirectMessages we want to count
     *   }
     * })
    **/
    count<T extends TwitterDirectMessageCountArgs>(
      args?: Subset<T, TwitterDirectMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TwitterDirectMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TwitterDirectMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterDirectMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TwitterDirectMessageAggregateArgs>(args: Subset<T, TwitterDirectMessageAggregateArgs>): Prisma.PrismaPromise<GetTwitterDirectMessageAggregateType<T>>

    /**
     * Group by TwitterDirectMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterDirectMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TwitterDirectMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TwitterDirectMessageGroupByArgs['orderBy'] }
        : { orderBy?: TwitterDirectMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TwitterDirectMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTwitterDirectMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TwitterDirectMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TwitterDirectMessageClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    from<T extends TwitterUserArgs= {}>(args?: Subset<T, TwitterUserArgs>): Prisma__TwitterUserClient<TwitterUserGetPayload<T> | Null>;

    to<T extends TwitterUserArgs= {}>(args?: Subset<T, TwitterUserArgs>): Prisma__TwitterUserClient<TwitterUserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TwitterDirectMessage base type for findUnique actions
   */
  export type TwitterDirectMessageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TwitterDirectMessage
     */
    select?: TwitterDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterDirectMessageInclude | null
    /**
     * Filter, which TwitterDirectMessage to fetch.
     */
    where: TwitterDirectMessageWhereUniqueInput
  }

  /**
   * TwitterDirectMessage findUnique
   */
  export interface TwitterDirectMessageFindUniqueArgs extends TwitterDirectMessageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TwitterDirectMessage findUniqueOrThrow
   */
  export type TwitterDirectMessageFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TwitterDirectMessage
     */
    select?: TwitterDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterDirectMessageInclude | null
    /**
     * Filter, which TwitterDirectMessage to fetch.
     */
    where: TwitterDirectMessageWhereUniqueInput
  }


  /**
   * TwitterDirectMessage base type for findFirst actions
   */
  export type TwitterDirectMessageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TwitterDirectMessage
     */
    select?: TwitterDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterDirectMessageInclude | null
    /**
     * Filter, which TwitterDirectMessage to fetch.
     */
    where?: TwitterDirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterDirectMessages to fetch.
     */
    orderBy?: Enumerable<TwitterDirectMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterDirectMessages.
     */
    cursor?: TwitterDirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterDirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterDirectMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterDirectMessages.
     */
    distinct?: Enumerable<TwitterDirectMessageScalarFieldEnum>
  }

  /**
   * TwitterDirectMessage findFirst
   */
  export interface TwitterDirectMessageFindFirstArgs extends TwitterDirectMessageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TwitterDirectMessage findFirstOrThrow
   */
  export type TwitterDirectMessageFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TwitterDirectMessage
     */
    select?: TwitterDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterDirectMessageInclude | null
    /**
     * Filter, which TwitterDirectMessage to fetch.
     */
    where?: TwitterDirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterDirectMessages to fetch.
     */
    orderBy?: Enumerable<TwitterDirectMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterDirectMessages.
     */
    cursor?: TwitterDirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterDirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterDirectMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterDirectMessages.
     */
    distinct?: Enumerable<TwitterDirectMessageScalarFieldEnum>
  }


  /**
   * TwitterDirectMessage findMany
   */
  export type TwitterDirectMessageFindManyArgs = {
    /**
     * Select specific fields to fetch from the TwitterDirectMessage
     */
    select?: TwitterDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterDirectMessageInclude | null
    /**
     * Filter, which TwitterDirectMessages to fetch.
     */
    where?: TwitterDirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterDirectMessages to fetch.
     */
    orderBy?: Enumerable<TwitterDirectMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TwitterDirectMessages.
     */
    cursor?: TwitterDirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterDirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterDirectMessages.
     */
    skip?: number
    distinct?: Enumerable<TwitterDirectMessageScalarFieldEnum>
  }


  /**
   * TwitterDirectMessage create
   */
  export type TwitterDirectMessageCreateArgs = {
    /**
     * Select specific fields to fetch from the TwitterDirectMessage
     */
    select?: TwitterDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterDirectMessageInclude | null
    /**
     * The data needed to create a TwitterDirectMessage.
     */
    data: XOR<TwitterDirectMessageCreateInput, TwitterDirectMessageUncheckedCreateInput>
  }


  /**
   * TwitterDirectMessage createMany
   */
  export type TwitterDirectMessageCreateManyArgs = {
    /**
     * The data used to create many TwitterDirectMessages.
     */
    data: Enumerable<TwitterDirectMessageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TwitterDirectMessage update
   */
  export type TwitterDirectMessageUpdateArgs = {
    /**
     * Select specific fields to fetch from the TwitterDirectMessage
     */
    select?: TwitterDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterDirectMessageInclude | null
    /**
     * The data needed to update a TwitterDirectMessage.
     */
    data: XOR<TwitterDirectMessageUpdateInput, TwitterDirectMessageUncheckedUpdateInput>
    /**
     * Choose, which TwitterDirectMessage to update.
     */
    where: TwitterDirectMessageWhereUniqueInput
  }


  /**
   * TwitterDirectMessage updateMany
   */
  export type TwitterDirectMessageUpdateManyArgs = {
    /**
     * The data used to update TwitterDirectMessages.
     */
    data: XOR<TwitterDirectMessageUpdateManyMutationInput, TwitterDirectMessageUncheckedUpdateManyInput>
    /**
     * Filter which TwitterDirectMessages to update
     */
    where?: TwitterDirectMessageWhereInput
  }


  /**
   * TwitterDirectMessage upsert
   */
  export type TwitterDirectMessageUpsertArgs = {
    /**
     * Select specific fields to fetch from the TwitterDirectMessage
     */
    select?: TwitterDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterDirectMessageInclude | null
    /**
     * The filter to search for the TwitterDirectMessage to update in case it exists.
     */
    where: TwitterDirectMessageWhereUniqueInput
    /**
     * In case the TwitterDirectMessage found by the `where` argument doesn't exist, create a new TwitterDirectMessage with this data.
     */
    create: XOR<TwitterDirectMessageCreateInput, TwitterDirectMessageUncheckedCreateInput>
    /**
     * In case the TwitterDirectMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TwitterDirectMessageUpdateInput, TwitterDirectMessageUncheckedUpdateInput>
  }


  /**
   * TwitterDirectMessage delete
   */
  export type TwitterDirectMessageDeleteArgs = {
    /**
     * Select specific fields to fetch from the TwitterDirectMessage
     */
    select?: TwitterDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterDirectMessageInclude | null
    /**
     * Filter which TwitterDirectMessage to delete.
     */
    where: TwitterDirectMessageWhereUniqueInput
  }


  /**
   * TwitterDirectMessage deleteMany
   */
  export type TwitterDirectMessageDeleteManyArgs = {
    /**
     * Filter which TwitterDirectMessages to delete
     */
    where?: TwitterDirectMessageWhereInput
  }


  /**
   * TwitterDirectMessage without action
   */
  export type TwitterDirectMessageArgs = {
    /**
     * Select specific fields to fetch from the TwitterDirectMessage
     */
    select?: TwitterDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterDirectMessageInclude | null
  }



  /**
   * Model TwitterUserRelation
   */


  export type AggregateTwitterUserRelation = {
    _count: TwitterUserRelationCountAggregateOutputType | null
    _avg: TwitterUserRelationAvgAggregateOutputType | null
    _sum: TwitterUserRelationSumAggregateOutputType | null
    _min: TwitterUserRelationMinAggregateOutputType | null
    _max: TwitterUserRelationMaxAggregateOutputType | null
  }

  export type TwitterUserRelationAvgAggregateOutputType = {
    id: number | null
    fromUserId: number | null
    toUserId: number | null
  }

  export type TwitterUserRelationSumAggregateOutputType = {
    id: number | null
    fromUserId: number | null
    toUserId: number | null
  }

  export type TwitterUserRelationMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    fromUserId: number | null
    toUserId: number | null
  }

  export type TwitterUserRelationMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    fromUserId: number | null
    toUserId: number | null
  }

  export type TwitterUserRelationCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    fromUserId: number
    toUserId: number
    _all: number
  }


  export type TwitterUserRelationAvgAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
  }

  export type TwitterUserRelationSumAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
  }

  export type TwitterUserRelationMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    fromUserId?: true
    toUserId?: true
  }

  export type TwitterUserRelationMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    fromUserId?: true
    toUserId?: true
  }

  export type TwitterUserRelationCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    fromUserId?: true
    toUserId?: true
    _all?: true
  }

  export type TwitterUserRelationAggregateArgs = {
    /**
     * Filter which TwitterUserRelation to aggregate.
     */
    where?: TwitterUserRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterUserRelations to fetch.
     */
    orderBy?: Enumerable<TwitterUserRelationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TwitterUserRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterUserRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterUserRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TwitterUserRelations
    **/
    _count?: true | TwitterUserRelationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TwitterUserRelationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TwitterUserRelationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TwitterUserRelationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TwitterUserRelationMaxAggregateInputType
  }

  export type GetTwitterUserRelationAggregateType<T extends TwitterUserRelationAggregateArgs> = {
        [P in keyof T & keyof AggregateTwitterUserRelation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTwitterUserRelation[P]>
      : GetScalarType<T[P], AggregateTwitterUserRelation[P]>
  }




  export type TwitterUserRelationGroupByArgs = {
    where?: TwitterUserRelationWhereInput
    orderBy?: Enumerable<TwitterUserRelationOrderByWithAggregationInput>
    by: TwitterUserRelationScalarFieldEnum[]
    having?: TwitterUserRelationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TwitterUserRelationCountAggregateInputType | true
    _avg?: TwitterUserRelationAvgAggregateInputType
    _sum?: TwitterUserRelationSumAggregateInputType
    _min?: TwitterUserRelationMinAggregateInputType
    _max?: TwitterUserRelationMaxAggregateInputType
  }


  export type TwitterUserRelationGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    fromUserId: number
    toUserId: number
    _count: TwitterUserRelationCountAggregateOutputType | null
    _avg: TwitterUserRelationAvgAggregateOutputType | null
    _sum: TwitterUserRelationSumAggregateOutputType | null
    _min: TwitterUserRelationMinAggregateOutputType | null
    _max: TwitterUserRelationMaxAggregateOutputType | null
  }

  type GetTwitterUserRelationGroupByPayload<T extends TwitterUserRelationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TwitterUserRelationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TwitterUserRelationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TwitterUserRelationGroupByOutputType[P]>
            : GetScalarType<T[P], TwitterUserRelationGroupByOutputType[P]>
        }
      >
    >


  export type TwitterUserRelationSelect = {
    id?: boolean
    from?: boolean | TwitterUserArgs
    to?: boolean | TwitterUserArgs
    createdAt?: boolean
    updatedAt?: boolean
    fromUserId?: boolean
    toUserId?: boolean
  }


  export type TwitterUserRelationInclude = {
    from?: boolean | TwitterUserArgs
    to?: boolean | TwitterUserArgs
  }

  export type TwitterUserRelationGetPayload<S extends boolean | null | undefined | TwitterUserRelationArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TwitterUserRelation :
    S extends undefined ? never :
    S extends { include: any } & (TwitterUserRelationArgs | TwitterUserRelationFindManyArgs)
    ? TwitterUserRelation  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'from' ? TwitterUserGetPayload<S['include'][P]> :
        P extends 'to' ? TwitterUserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TwitterUserRelationArgs | TwitterUserRelationFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'from' ? TwitterUserGetPayload<S['select'][P]> :
        P extends 'to' ? TwitterUserGetPayload<S['select'][P]> :  P extends keyof TwitterUserRelation ? TwitterUserRelation[P] : never
  } 
      : TwitterUserRelation


  type TwitterUserRelationCountArgs = 
    Omit<TwitterUserRelationFindManyArgs, 'select' | 'include'> & {
      select?: TwitterUserRelationCountAggregateInputType | true
    }

  export interface TwitterUserRelationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TwitterUserRelation that matches the filter.
     * @param {TwitterUserRelationFindUniqueArgs} args - Arguments to find a TwitterUserRelation
     * @example
     * // Get one TwitterUserRelation
     * const twitterUserRelation = await prisma.twitterUserRelation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TwitterUserRelationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TwitterUserRelationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TwitterUserRelation'> extends True ? Prisma__TwitterUserRelationClient<TwitterUserRelationGetPayload<T>> : Prisma__TwitterUserRelationClient<TwitterUserRelationGetPayload<T> | null, null>

    /**
     * Find one TwitterUserRelation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TwitterUserRelationFindUniqueOrThrowArgs} args - Arguments to find a TwitterUserRelation
     * @example
     * // Get one TwitterUserRelation
     * const twitterUserRelation = await prisma.twitterUserRelation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TwitterUserRelationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TwitterUserRelationFindUniqueOrThrowArgs>
    ): Prisma__TwitterUserRelationClient<TwitterUserRelationGetPayload<T>>

    /**
     * Find the first TwitterUserRelation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterUserRelationFindFirstArgs} args - Arguments to find a TwitterUserRelation
     * @example
     * // Get one TwitterUserRelation
     * const twitterUserRelation = await prisma.twitterUserRelation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TwitterUserRelationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TwitterUserRelationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TwitterUserRelation'> extends True ? Prisma__TwitterUserRelationClient<TwitterUserRelationGetPayload<T>> : Prisma__TwitterUserRelationClient<TwitterUserRelationGetPayload<T> | null, null>

    /**
     * Find the first TwitterUserRelation that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterUserRelationFindFirstOrThrowArgs} args - Arguments to find a TwitterUserRelation
     * @example
     * // Get one TwitterUserRelation
     * const twitterUserRelation = await prisma.twitterUserRelation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TwitterUserRelationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TwitterUserRelationFindFirstOrThrowArgs>
    ): Prisma__TwitterUserRelationClient<TwitterUserRelationGetPayload<T>>

    /**
     * Find zero or more TwitterUserRelations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterUserRelationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TwitterUserRelations
     * const twitterUserRelations = await prisma.twitterUserRelation.findMany()
     * 
     * // Get first 10 TwitterUserRelations
     * const twitterUserRelations = await prisma.twitterUserRelation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const twitterUserRelationWithIdOnly = await prisma.twitterUserRelation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TwitterUserRelationFindManyArgs>(
      args?: SelectSubset<T, TwitterUserRelationFindManyArgs>
    ): Prisma.PrismaPromise<Array<TwitterUserRelationGetPayload<T>>>

    /**
     * Create a TwitterUserRelation.
     * @param {TwitterUserRelationCreateArgs} args - Arguments to create a TwitterUserRelation.
     * @example
     * // Create one TwitterUserRelation
     * const TwitterUserRelation = await prisma.twitterUserRelation.create({
     *   data: {
     *     // ... data to create a TwitterUserRelation
     *   }
     * })
     * 
    **/
    create<T extends TwitterUserRelationCreateArgs>(
      args: SelectSubset<T, TwitterUserRelationCreateArgs>
    ): Prisma__TwitterUserRelationClient<TwitterUserRelationGetPayload<T>>

    /**
     * Create many TwitterUserRelations.
     *     @param {TwitterUserRelationCreateManyArgs} args - Arguments to create many TwitterUserRelations.
     *     @example
     *     // Create many TwitterUserRelations
     *     const twitterUserRelation = await prisma.twitterUserRelation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TwitterUserRelationCreateManyArgs>(
      args?: SelectSubset<T, TwitterUserRelationCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TwitterUserRelation.
     * @param {TwitterUserRelationDeleteArgs} args - Arguments to delete one TwitterUserRelation.
     * @example
     * // Delete one TwitterUserRelation
     * const TwitterUserRelation = await prisma.twitterUserRelation.delete({
     *   where: {
     *     // ... filter to delete one TwitterUserRelation
     *   }
     * })
     * 
    **/
    delete<T extends TwitterUserRelationDeleteArgs>(
      args: SelectSubset<T, TwitterUserRelationDeleteArgs>
    ): Prisma__TwitterUserRelationClient<TwitterUserRelationGetPayload<T>>

    /**
     * Update one TwitterUserRelation.
     * @param {TwitterUserRelationUpdateArgs} args - Arguments to update one TwitterUserRelation.
     * @example
     * // Update one TwitterUserRelation
     * const twitterUserRelation = await prisma.twitterUserRelation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TwitterUserRelationUpdateArgs>(
      args: SelectSubset<T, TwitterUserRelationUpdateArgs>
    ): Prisma__TwitterUserRelationClient<TwitterUserRelationGetPayload<T>>

    /**
     * Delete zero or more TwitterUserRelations.
     * @param {TwitterUserRelationDeleteManyArgs} args - Arguments to filter TwitterUserRelations to delete.
     * @example
     * // Delete a few TwitterUserRelations
     * const { count } = await prisma.twitterUserRelation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TwitterUserRelationDeleteManyArgs>(
      args?: SelectSubset<T, TwitterUserRelationDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TwitterUserRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterUserRelationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TwitterUserRelations
     * const twitterUserRelation = await prisma.twitterUserRelation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TwitterUserRelationUpdateManyArgs>(
      args: SelectSubset<T, TwitterUserRelationUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TwitterUserRelation.
     * @param {TwitterUserRelationUpsertArgs} args - Arguments to update or create a TwitterUserRelation.
     * @example
     * // Update or create a TwitterUserRelation
     * const twitterUserRelation = await prisma.twitterUserRelation.upsert({
     *   create: {
     *     // ... data to create a TwitterUserRelation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TwitterUserRelation we want to update
     *   }
     * })
    **/
    upsert<T extends TwitterUserRelationUpsertArgs>(
      args: SelectSubset<T, TwitterUserRelationUpsertArgs>
    ): Prisma__TwitterUserRelationClient<TwitterUserRelationGetPayload<T>>

    /**
     * Count the number of TwitterUserRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterUserRelationCountArgs} args - Arguments to filter TwitterUserRelations to count.
     * @example
     * // Count the number of TwitterUserRelations
     * const count = await prisma.twitterUserRelation.count({
     *   where: {
     *     // ... the filter for the TwitterUserRelations we want to count
     *   }
     * })
    **/
    count<T extends TwitterUserRelationCountArgs>(
      args?: Subset<T, TwitterUserRelationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TwitterUserRelationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TwitterUserRelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterUserRelationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TwitterUserRelationAggregateArgs>(args: Subset<T, TwitterUserRelationAggregateArgs>): Prisma.PrismaPromise<GetTwitterUserRelationAggregateType<T>>

    /**
     * Group by TwitterUserRelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterUserRelationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TwitterUserRelationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TwitterUserRelationGroupByArgs['orderBy'] }
        : { orderBy?: TwitterUserRelationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TwitterUserRelationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTwitterUserRelationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TwitterUserRelation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TwitterUserRelationClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    from<T extends TwitterUserArgs= {}>(args?: Subset<T, TwitterUserArgs>): Prisma__TwitterUserClient<TwitterUserGetPayload<T> | Null>;

    to<T extends TwitterUserArgs= {}>(args?: Subset<T, TwitterUserArgs>): Prisma__TwitterUserClient<TwitterUserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TwitterUserRelation base type for findUnique actions
   */
  export type TwitterUserRelationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TwitterUserRelation
     */
    select?: TwitterUserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserRelationInclude | null
    /**
     * Filter, which TwitterUserRelation to fetch.
     */
    where: TwitterUserRelationWhereUniqueInput
  }

  /**
   * TwitterUserRelation findUnique
   */
  export interface TwitterUserRelationFindUniqueArgs extends TwitterUserRelationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TwitterUserRelation findUniqueOrThrow
   */
  export type TwitterUserRelationFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TwitterUserRelation
     */
    select?: TwitterUserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserRelationInclude | null
    /**
     * Filter, which TwitterUserRelation to fetch.
     */
    where: TwitterUserRelationWhereUniqueInput
  }


  /**
   * TwitterUserRelation base type for findFirst actions
   */
  export type TwitterUserRelationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TwitterUserRelation
     */
    select?: TwitterUserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserRelationInclude | null
    /**
     * Filter, which TwitterUserRelation to fetch.
     */
    where?: TwitterUserRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterUserRelations to fetch.
     */
    orderBy?: Enumerable<TwitterUserRelationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterUserRelations.
     */
    cursor?: TwitterUserRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterUserRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterUserRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterUserRelations.
     */
    distinct?: Enumerable<TwitterUserRelationScalarFieldEnum>
  }

  /**
   * TwitterUserRelation findFirst
   */
  export interface TwitterUserRelationFindFirstArgs extends TwitterUserRelationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TwitterUserRelation findFirstOrThrow
   */
  export type TwitterUserRelationFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TwitterUserRelation
     */
    select?: TwitterUserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserRelationInclude | null
    /**
     * Filter, which TwitterUserRelation to fetch.
     */
    where?: TwitterUserRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterUserRelations to fetch.
     */
    orderBy?: Enumerable<TwitterUserRelationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterUserRelations.
     */
    cursor?: TwitterUserRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterUserRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterUserRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterUserRelations.
     */
    distinct?: Enumerable<TwitterUserRelationScalarFieldEnum>
  }


  /**
   * TwitterUserRelation findMany
   */
  export type TwitterUserRelationFindManyArgs = {
    /**
     * Select specific fields to fetch from the TwitterUserRelation
     */
    select?: TwitterUserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserRelationInclude | null
    /**
     * Filter, which TwitterUserRelations to fetch.
     */
    where?: TwitterUserRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterUserRelations to fetch.
     */
    orderBy?: Enumerable<TwitterUserRelationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TwitterUserRelations.
     */
    cursor?: TwitterUserRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterUserRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterUserRelations.
     */
    skip?: number
    distinct?: Enumerable<TwitterUserRelationScalarFieldEnum>
  }


  /**
   * TwitterUserRelation create
   */
  export type TwitterUserRelationCreateArgs = {
    /**
     * Select specific fields to fetch from the TwitterUserRelation
     */
    select?: TwitterUserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserRelationInclude | null
    /**
     * The data needed to create a TwitterUserRelation.
     */
    data: XOR<TwitterUserRelationCreateInput, TwitterUserRelationUncheckedCreateInput>
  }


  /**
   * TwitterUserRelation createMany
   */
  export type TwitterUserRelationCreateManyArgs = {
    /**
     * The data used to create many TwitterUserRelations.
     */
    data: Enumerable<TwitterUserRelationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TwitterUserRelation update
   */
  export type TwitterUserRelationUpdateArgs = {
    /**
     * Select specific fields to fetch from the TwitterUserRelation
     */
    select?: TwitterUserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserRelationInclude | null
    /**
     * The data needed to update a TwitterUserRelation.
     */
    data: XOR<TwitterUserRelationUpdateInput, TwitterUserRelationUncheckedUpdateInput>
    /**
     * Choose, which TwitterUserRelation to update.
     */
    where: TwitterUserRelationWhereUniqueInput
  }


  /**
   * TwitterUserRelation updateMany
   */
  export type TwitterUserRelationUpdateManyArgs = {
    /**
     * The data used to update TwitterUserRelations.
     */
    data: XOR<TwitterUserRelationUpdateManyMutationInput, TwitterUserRelationUncheckedUpdateManyInput>
    /**
     * Filter which TwitterUserRelations to update
     */
    where?: TwitterUserRelationWhereInput
  }


  /**
   * TwitterUserRelation upsert
   */
  export type TwitterUserRelationUpsertArgs = {
    /**
     * Select specific fields to fetch from the TwitterUserRelation
     */
    select?: TwitterUserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserRelationInclude | null
    /**
     * The filter to search for the TwitterUserRelation to update in case it exists.
     */
    where: TwitterUserRelationWhereUniqueInput
    /**
     * In case the TwitterUserRelation found by the `where` argument doesn't exist, create a new TwitterUserRelation with this data.
     */
    create: XOR<TwitterUserRelationCreateInput, TwitterUserRelationUncheckedCreateInput>
    /**
     * In case the TwitterUserRelation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TwitterUserRelationUpdateInput, TwitterUserRelationUncheckedUpdateInput>
  }


  /**
   * TwitterUserRelation delete
   */
  export type TwitterUserRelationDeleteArgs = {
    /**
     * Select specific fields to fetch from the TwitterUserRelation
     */
    select?: TwitterUserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserRelationInclude | null
    /**
     * Filter which TwitterUserRelation to delete.
     */
    where: TwitterUserRelationWhereUniqueInput
  }


  /**
   * TwitterUserRelation deleteMany
   */
  export type TwitterUserRelationDeleteManyArgs = {
    /**
     * Filter which TwitterUserRelations to delete
     */
    where?: TwitterUserRelationWhereInput
  }


  /**
   * TwitterUserRelation without action
   */
  export type TwitterUserRelationArgs = {
    /**
     * Select specific fields to fetch from the TwitterUserRelation
     */
    select?: TwitterUserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserRelationInclude | null
  }



  /**
   * Model TwitterComment
   */


  export type AggregateTwitterComment = {
    _count: TwitterCommentCountAggregateOutputType | null
    _avg: TwitterCommentAvgAggregateOutputType | null
    _sum: TwitterCommentSumAggregateOutputType | null
    _min: TwitterCommentMinAggregateOutputType | null
    _max: TwitterCommentMaxAggregateOutputType | null
  }

  export type TwitterCommentAvgAggregateOutputType = {
    id: number | null
    twitterPostId: number | null
    twitterUserId: number | null
  }

  export type TwitterCommentSumAggregateOutputType = {
    id: number | null
    twitterPostId: number | null
    twitterUserId: number | null
  }

  export type TwitterCommentMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    twitterPostId: number | null
    twitterUserId: number | null
  }

  export type TwitterCommentMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    twitterPostId: number | null
    twitterUserId: number | null
  }

  export type TwitterCommentCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    twitterPostId: number
    twitterUserId: number
    _all: number
  }


  export type TwitterCommentAvgAggregateInputType = {
    id?: true
    twitterPostId?: true
    twitterUserId?: true
  }

  export type TwitterCommentSumAggregateInputType = {
    id?: true
    twitterPostId?: true
    twitterUserId?: true
  }

  export type TwitterCommentMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    twitterPostId?: true
    twitterUserId?: true
  }

  export type TwitterCommentMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    twitterPostId?: true
    twitterUserId?: true
  }

  export type TwitterCommentCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    twitterPostId?: true
    twitterUserId?: true
    _all?: true
  }

  export type TwitterCommentAggregateArgs = {
    /**
     * Filter which TwitterComment to aggregate.
     */
    where?: TwitterCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterComments to fetch.
     */
    orderBy?: Enumerable<TwitterCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TwitterCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TwitterComments
    **/
    _count?: true | TwitterCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TwitterCommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TwitterCommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TwitterCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TwitterCommentMaxAggregateInputType
  }

  export type GetTwitterCommentAggregateType<T extends TwitterCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateTwitterComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTwitterComment[P]>
      : GetScalarType<T[P], AggregateTwitterComment[P]>
  }




  export type TwitterCommentGroupByArgs = {
    where?: TwitterCommentWhereInput
    orderBy?: Enumerable<TwitterCommentOrderByWithAggregationInput>
    by: TwitterCommentScalarFieldEnum[]
    having?: TwitterCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TwitterCommentCountAggregateInputType | true
    _avg?: TwitterCommentAvgAggregateInputType
    _sum?: TwitterCommentSumAggregateInputType
    _min?: TwitterCommentMinAggregateInputType
    _max?: TwitterCommentMaxAggregateInputType
  }


  export type TwitterCommentGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    twitterPostId: number
    twitterUserId: number
    _count: TwitterCommentCountAggregateOutputType | null
    _avg: TwitterCommentAvgAggregateOutputType | null
    _sum: TwitterCommentSumAggregateOutputType | null
    _min: TwitterCommentMinAggregateOutputType | null
    _max: TwitterCommentMaxAggregateOutputType | null
  }

  type GetTwitterCommentGroupByPayload<T extends TwitterCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TwitterCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TwitterCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TwitterCommentGroupByOutputType[P]>
            : GetScalarType<T[P], TwitterCommentGroupByOutputType[P]>
        }
      >
    >


  export type TwitterCommentSelect = {
    id?: boolean
    post?: boolean | TwitterPostArgs
    user?: boolean | TwitterUserArgs
    createdAt?: boolean
    updatedAt?: boolean
    twitterPostId?: boolean
    twitterUserId?: boolean
  }


  export type TwitterCommentInclude = {
    post?: boolean | TwitterPostArgs
    user?: boolean | TwitterUserArgs
  }

  export type TwitterCommentGetPayload<S extends boolean | null | undefined | TwitterCommentArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TwitterComment :
    S extends undefined ? never :
    S extends { include: any } & (TwitterCommentArgs | TwitterCommentFindManyArgs)
    ? TwitterComment  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'post' ? TwitterPostGetPayload<S['include'][P]> :
        P extends 'user' ? TwitterUserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TwitterCommentArgs | TwitterCommentFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'post' ? TwitterPostGetPayload<S['select'][P]> :
        P extends 'user' ? TwitterUserGetPayload<S['select'][P]> :  P extends keyof TwitterComment ? TwitterComment[P] : never
  } 
      : TwitterComment


  type TwitterCommentCountArgs = 
    Omit<TwitterCommentFindManyArgs, 'select' | 'include'> & {
      select?: TwitterCommentCountAggregateInputType | true
    }

  export interface TwitterCommentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TwitterComment that matches the filter.
     * @param {TwitterCommentFindUniqueArgs} args - Arguments to find a TwitterComment
     * @example
     * // Get one TwitterComment
     * const twitterComment = await prisma.twitterComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TwitterCommentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TwitterCommentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TwitterComment'> extends True ? Prisma__TwitterCommentClient<TwitterCommentGetPayload<T>> : Prisma__TwitterCommentClient<TwitterCommentGetPayload<T> | null, null>

    /**
     * Find one TwitterComment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TwitterCommentFindUniqueOrThrowArgs} args - Arguments to find a TwitterComment
     * @example
     * // Get one TwitterComment
     * const twitterComment = await prisma.twitterComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TwitterCommentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TwitterCommentFindUniqueOrThrowArgs>
    ): Prisma__TwitterCommentClient<TwitterCommentGetPayload<T>>

    /**
     * Find the first TwitterComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterCommentFindFirstArgs} args - Arguments to find a TwitterComment
     * @example
     * // Get one TwitterComment
     * const twitterComment = await prisma.twitterComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TwitterCommentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TwitterCommentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TwitterComment'> extends True ? Prisma__TwitterCommentClient<TwitterCommentGetPayload<T>> : Prisma__TwitterCommentClient<TwitterCommentGetPayload<T> | null, null>

    /**
     * Find the first TwitterComment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterCommentFindFirstOrThrowArgs} args - Arguments to find a TwitterComment
     * @example
     * // Get one TwitterComment
     * const twitterComment = await prisma.twitterComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TwitterCommentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TwitterCommentFindFirstOrThrowArgs>
    ): Prisma__TwitterCommentClient<TwitterCommentGetPayload<T>>

    /**
     * Find zero or more TwitterComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterCommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TwitterComments
     * const twitterComments = await prisma.twitterComment.findMany()
     * 
     * // Get first 10 TwitterComments
     * const twitterComments = await prisma.twitterComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const twitterCommentWithIdOnly = await prisma.twitterComment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TwitterCommentFindManyArgs>(
      args?: SelectSubset<T, TwitterCommentFindManyArgs>
    ): Prisma.PrismaPromise<Array<TwitterCommentGetPayload<T>>>

    /**
     * Create a TwitterComment.
     * @param {TwitterCommentCreateArgs} args - Arguments to create a TwitterComment.
     * @example
     * // Create one TwitterComment
     * const TwitterComment = await prisma.twitterComment.create({
     *   data: {
     *     // ... data to create a TwitterComment
     *   }
     * })
     * 
    **/
    create<T extends TwitterCommentCreateArgs>(
      args: SelectSubset<T, TwitterCommentCreateArgs>
    ): Prisma__TwitterCommentClient<TwitterCommentGetPayload<T>>

    /**
     * Create many TwitterComments.
     *     @param {TwitterCommentCreateManyArgs} args - Arguments to create many TwitterComments.
     *     @example
     *     // Create many TwitterComments
     *     const twitterComment = await prisma.twitterComment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TwitterCommentCreateManyArgs>(
      args?: SelectSubset<T, TwitterCommentCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TwitterComment.
     * @param {TwitterCommentDeleteArgs} args - Arguments to delete one TwitterComment.
     * @example
     * // Delete one TwitterComment
     * const TwitterComment = await prisma.twitterComment.delete({
     *   where: {
     *     // ... filter to delete one TwitterComment
     *   }
     * })
     * 
    **/
    delete<T extends TwitterCommentDeleteArgs>(
      args: SelectSubset<T, TwitterCommentDeleteArgs>
    ): Prisma__TwitterCommentClient<TwitterCommentGetPayload<T>>

    /**
     * Update one TwitterComment.
     * @param {TwitterCommentUpdateArgs} args - Arguments to update one TwitterComment.
     * @example
     * // Update one TwitterComment
     * const twitterComment = await prisma.twitterComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TwitterCommentUpdateArgs>(
      args: SelectSubset<T, TwitterCommentUpdateArgs>
    ): Prisma__TwitterCommentClient<TwitterCommentGetPayload<T>>

    /**
     * Delete zero or more TwitterComments.
     * @param {TwitterCommentDeleteManyArgs} args - Arguments to filter TwitterComments to delete.
     * @example
     * // Delete a few TwitterComments
     * const { count } = await prisma.twitterComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TwitterCommentDeleteManyArgs>(
      args?: SelectSubset<T, TwitterCommentDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TwitterComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TwitterComments
     * const twitterComment = await prisma.twitterComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TwitterCommentUpdateManyArgs>(
      args: SelectSubset<T, TwitterCommentUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TwitterComment.
     * @param {TwitterCommentUpsertArgs} args - Arguments to update or create a TwitterComment.
     * @example
     * // Update or create a TwitterComment
     * const twitterComment = await prisma.twitterComment.upsert({
     *   create: {
     *     // ... data to create a TwitterComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TwitterComment we want to update
     *   }
     * })
    **/
    upsert<T extends TwitterCommentUpsertArgs>(
      args: SelectSubset<T, TwitterCommentUpsertArgs>
    ): Prisma__TwitterCommentClient<TwitterCommentGetPayload<T>>

    /**
     * Count the number of TwitterComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterCommentCountArgs} args - Arguments to filter TwitterComments to count.
     * @example
     * // Count the number of TwitterComments
     * const count = await prisma.twitterComment.count({
     *   where: {
     *     // ... the filter for the TwitterComments we want to count
     *   }
     * })
    **/
    count<T extends TwitterCommentCountArgs>(
      args?: Subset<T, TwitterCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TwitterCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TwitterComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TwitterCommentAggregateArgs>(args: Subset<T, TwitterCommentAggregateArgs>): Prisma.PrismaPromise<GetTwitterCommentAggregateType<T>>

    /**
     * Group by TwitterComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TwitterCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TwitterCommentGroupByArgs['orderBy'] }
        : { orderBy?: TwitterCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TwitterCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTwitterCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TwitterComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TwitterCommentClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    post<T extends TwitterPostArgs= {}>(args?: Subset<T, TwitterPostArgs>): Prisma__TwitterPostClient<TwitterPostGetPayload<T> | Null>;

    user<T extends TwitterUserArgs= {}>(args?: Subset<T, TwitterUserArgs>): Prisma__TwitterUserClient<TwitterUserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TwitterComment base type for findUnique actions
   */
  export type TwitterCommentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TwitterComment
     */
    select?: TwitterCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterCommentInclude | null
    /**
     * Filter, which TwitterComment to fetch.
     */
    where: TwitterCommentWhereUniqueInput
  }

  /**
   * TwitterComment findUnique
   */
  export interface TwitterCommentFindUniqueArgs extends TwitterCommentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TwitterComment findUniqueOrThrow
   */
  export type TwitterCommentFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TwitterComment
     */
    select?: TwitterCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterCommentInclude | null
    /**
     * Filter, which TwitterComment to fetch.
     */
    where: TwitterCommentWhereUniqueInput
  }


  /**
   * TwitterComment base type for findFirst actions
   */
  export type TwitterCommentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TwitterComment
     */
    select?: TwitterCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterCommentInclude | null
    /**
     * Filter, which TwitterComment to fetch.
     */
    where?: TwitterCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterComments to fetch.
     */
    orderBy?: Enumerable<TwitterCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterComments.
     */
    cursor?: TwitterCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterComments.
     */
    distinct?: Enumerable<TwitterCommentScalarFieldEnum>
  }

  /**
   * TwitterComment findFirst
   */
  export interface TwitterCommentFindFirstArgs extends TwitterCommentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TwitterComment findFirstOrThrow
   */
  export type TwitterCommentFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TwitterComment
     */
    select?: TwitterCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterCommentInclude | null
    /**
     * Filter, which TwitterComment to fetch.
     */
    where?: TwitterCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterComments to fetch.
     */
    orderBy?: Enumerable<TwitterCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterComments.
     */
    cursor?: TwitterCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterComments.
     */
    distinct?: Enumerable<TwitterCommentScalarFieldEnum>
  }


  /**
   * TwitterComment findMany
   */
  export type TwitterCommentFindManyArgs = {
    /**
     * Select specific fields to fetch from the TwitterComment
     */
    select?: TwitterCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterCommentInclude | null
    /**
     * Filter, which TwitterComments to fetch.
     */
    where?: TwitterCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterComments to fetch.
     */
    orderBy?: Enumerable<TwitterCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TwitterComments.
     */
    cursor?: TwitterCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterComments.
     */
    skip?: number
    distinct?: Enumerable<TwitterCommentScalarFieldEnum>
  }


  /**
   * TwitterComment create
   */
  export type TwitterCommentCreateArgs = {
    /**
     * Select specific fields to fetch from the TwitterComment
     */
    select?: TwitterCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterCommentInclude | null
    /**
     * The data needed to create a TwitterComment.
     */
    data: XOR<TwitterCommentCreateInput, TwitterCommentUncheckedCreateInput>
  }


  /**
   * TwitterComment createMany
   */
  export type TwitterCommentCreateManyArgs = {
    /**
     * The data used to create many TwitterComments.
     */
    data: Enumerable<TwitterCommentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TwitterComment update
   */
  export type TwitterCommentUpdateArgs = {
    /**
     * Select specific fields to fetch from the TwitterComment
     */
    select?: TwitterCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterCommentInclude | null
    /**
     * The data needed to update a TwitterComment.
     */
    data: XOR<TwitterCommentUpdateInput, TwitterCommentUncheckedUpdateInput>
    /**
     * Choose, which TwitterComment to update.
     */
    where: TwitterCommentWhereUniqueInput
  }


  /**
   * TwitterComment updateMany
   */
  export type TwitterCommentUpdateManyArgs = {
    /**
     * The data used to update TwitterComments.
     */
    data: XOR<TwitterCommentUpdateManyMutationInput, TwitterCommentUncheckedUpdateManyInput>
    /**
     * Filter which TwitterComments to update
     */
    where?: TwitterCommentWhereInput
  }


  /**
   * TwitterComment upsert
   */
  export type TwitterCommentUpsertArgs = {
    /**
     * Select specific fields to fetch from the TwitterComment
     */
    select?: TwitterCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterCommentInclude | null
    /**
     * The filter to search for the TwitterComment to update in case it exists.
     */
    where: TwitterCommentWhereUniqueInput
    /**
     * In case the TwitterComment found by the `where` argument doesn't exist, create a new TwitterComment with this data.
     */
    create: XOR<TwitterCommentCreateInput, TwitterCommentUncheckedCreateInput>
    /**
     * In case the TwitterComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TwitterCommentUpdateInput, TwitterCommentUncheckedUpdateInput>
  }


  /**
   * TwitterComment delete
   */
  export type TwitterCommentDeleteArgs = {
    /**
     * Select specific fields to fetch from the TwitterComment
     */
    select?: TwitterCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterCommentInclude | null
    /**
     * Filter which TwitterComment to delete.
     */
    where: TwitterCommentWhereUniqueInput
  }


  /**
   * TwitterComment deleteMany
   */
  export type TwitterCommentDeleteManyArgs = {
    /**
     * Filter which TwitterComments to delete
     */
    where?: TwitterCommentWhereInput
  }


  /**
   * TwitterComment without action
   */
  export type TwitterCommentArgs = {
    /**
     * Select specific fields to fetch from the TwitterComment
     */
    select?: TwitterCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterCommentInclude | null
  }



  /**
   * Model YoutubeUser
   */


  export type AggregateYoutubeUser = {
    _count: YoutubeUserCountAggregateOutputType | null
    _avg: YoutubeUserAvgAggregateOutputType | null
    _sum: YoutubeUserSumAggregateOutputType | null
    _min: YoutubeUserMinAggregateOutputType | null
    _max: YoutubeUserMaxAggregateOutputType | null
  }

  export type YoutubeUserAvgAggregateOutputType = {
    id: number | null
  }

  export type YoutubeUserSumAggregateOutputType = {
    id: number | null
  }

  export type YoutubeUserMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type YoutubeUserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type YoutubeUserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type YoutubeUserAvgAggregateInputType = {
    id?: true
  }

  export type YoutubeUserSumAggregateInputType = {
    id?: true
  }

  export type YoutubeUserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    createdAt?: true
    updatedAt?: true
  }

  export type YoutubeUserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    createdAt?: true
    updatedAt?: true
  }

  export type YoutubeUserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type YoutubeUserAggregateArgs = {
    /**
     * Filter which YoutubeUser to aggregate.
     */
    where?: YoutubeUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeUsers to fetch.
     */
    orderBy?: Enumerable<YoutubeUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YoutubeUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YoutubeUsers
    **/
    _count?: true | YoutubeUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YoutubeUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YoutubeUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YoutubeUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YoutubeUserMaxAggregateInputType
  }

  export type GetYoutubeUserAggregateType<T extends YoutubeUserAggregateArgs> = {
        [P in keyof T & keyof AggregateYoutubeUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYoutubeUser[P]>
      : GetScalarType<T[P], AggregateYoutubeUser[P]>
  }




  export type YoutubeUserGroupByArgs = {
    where?: YoutubeUserWhereInput
    orderBy?: Enumerable<YoutubeUserOrderByWithAggregationInput>
    by: YoutubeUserScalarFieldEnum[]
    having?: YoutubeUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YoutubeUserCountAggregateInputType | true
    _avg?: YoutubeUserAvgAggregateInputType
    _sum?: YoutubeUserSumAggregateInputType
    _min?: YoutubeUserMinAggregateInputType
    _max?: YoutubeUserMaxAggregateInputType
  }


  export type YoutubeUserGroupByOutputType = {
    id: number
    name: string
    email: string
    createdAt: Date
    updatedAt: Date
    _count: YoutubeUserCountAggregateOutputType | null
    _avg: YoutubeUserAvgAggregateOutputType | null
    _sum: YoutubeUserSumAggregateOutputType | null
    _min: YoutubeUserMinAggregateOutputType | null
    _max: YoutubeUserMaxAggregateOutputType | null
  }

  type GetYoutubeUserGroupByPayload<T extends YoutubeUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<YoutubeUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YoutubeUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YoutubeUserGroupByOutputType[P]>
            : GetScalarType<T[P], YoutubeUserGroupByOutputType[P]>
        }
      >
    >


  export type YoutubeUserSelect = {
    id?: boolean
    name?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    youtubeUsersToChannels?: boolean | YoutubeUser$youtubeUsersToChannelsArgs
    youtubeSubscriptions?: boolean | YoutubeUser$youtubeSubscriptionsArgs
    YoutubeReaction?: boolean | YoutubeUser$YoutubeReactionArgs
    YoutubeComment?: boolean | YoutubeUser$YoutubeCommentArgs
    YoutubeCommentReaction?: boolean | YoutubeUser$YoutubeCommentReactionArgs
    _count?: boolean | YoutubeUserCountOutputTypeArgs
  }


  export type YoutubeUserInclude = {
    youtubeUsersToChannels?: boolean | YoutubeUser$youtubeUsersToChannelsArgs
    youtubeSubscriptions?: boolean | YoutubeUser$youtubeSubscriptionsArgs
    YoutubeReaction?: boolean | YoutubeUser$YoutubeReactionArgs
    YoutubeComment?: boolean | YoutubeUser$YoutubeCommentArgs
    YoutubeCommentReaction?: boolean | YoutubeUser$YoutubeCommentReactionArgs
    _count?: boolean | YoutubeUserCountOutputTypeArgs
  }

  export type YoutubeUserGetPayload<S extends boolean | null | undefined | YoutubeUserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YoutubeUser :
    S extends undefined ? never :
    S extends { include: any } & (YoutubeUserArgs | YoutubeUserFindManyArgs)
    ? YoutubeUser  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'youtubeUsersToChannels' ? Array < YoutubeUserToChannelGetPayload<S['include'][P]>>  :
        P extends 'youtubeSubscriptions' ? Array < YoutubeSubscriptionGetPayload<S['include'][P]>>  :
        P extends 'YoutubeReaction' ? Array < YoutubeReactionGetPayload<S['include'][P]>>  :
        P extends 'YoutubeComment' ? Array < YoutubeCommentGetPayload<S['include'][P]>>  :
        P extends 'YoutubeCommentReaction' ? Array < YoutubeCommentReactionGetPayload<S['include'][P]>>  :
        P extends '_count' ? YoutubeUserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (YoutubeUserArgs | YoutubeUserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'youtubeUsersToChannels' ? Array < YoutubeUserToChannelGetPayload<S['select'][P]>>  :
        P extends 'youtubeSubscriptions' ? Array < YoutubeSubscriptionGetPayload<S['select'][P]>>  :
        P extends 'YoutubeReaction' ? Array < YoutubeReactionGetPayload<S['select'][P]>>  :
        P extends 'YoutubeComment' ? Array < YoutubeCommentGetPayload<S['select'][P]>>  :
        P extends 'YoutubeCommentReaction' ? Array < YoutubeCommentReactionGetPayload<S['select'][P]>>  :
        P extends '_count' ? YoutubeUserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof YoutubeUser ? YoutubeUser[P] : never
  } 
      : YoutubeUser


  type YoutubeUserCountArgs = 
    Omit<YoutubeUserFindManyArgs, 'select' | 'include'> & {
      select?: YoutubeUserCountAggregateInputType | true
    }

  export interface YoutubeUserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one YoutubeUser that matches the filter.
     * @param {YoutubeUserFindUniqueArgs} args - Arguments to find a YoutubeUser
     * @example
     * // Get one YoutubeUser
     * const youtubeUser = await prisma.youtubeUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends YoutubeUserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, YoutubeUserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'YoutubeUser'> extends True ? Prisma__YoutubeUserClient<YoutubeUserGetPayload<T>> : Prisma__YoutubeUserClient<YoutubeUserGetPayload<T> | null, null>

    /**
     * Find one YoutubeUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {YoutubeUserFindUniqueOrThrowArgs} args - Arguments to find a YoutubeUser
     * @example
     * // Get one YoutubeUser
     * const youtubeUser = await prisma.youtubeUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends YoutubeUserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, YoutubeUserFindUniqueOrThrowArgs>
    ): Prisma__YoutubeUserClient<YoutubeUserGetPayload<T>>

    /**
     * Find the first YoutubeUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeUserFindFirstArgs} args - Arguments to find a YoutubeUser
     * @example
     * // Get one YoutubeUser
     * const youtubeUser = await prisma.youtubeUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends YoutubeUserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, YoutubeUserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'YoutubeUser'> extends True ? Prisma__YoutubeUserClient<YoutubeUserGetPayload<T>> : Prisma__YoutubeUserClient<YoutubeUserGetPayload<T> | null, null>

    /**
     * Find the first YoutubeUser that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeUserFindFirstOrThrowArgs} args - Arguments to find a YoutubeUser
     * @example
     * // Get one YoutubeUser
     * const youtubeUser = await prisma.youtubeUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends YoutubeUserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, YoutubeUserFindFirstOrThrowArgs>
    ): Prisma__YoutubeUserClient<YoutubeUserGetPayload<T>>

    /**
     * Find zero or more YoutubeUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YoutubeUsers
     * const youtubeUsers = await prisma.youtubeUser.findMany()
     * 
     * // Get first 10 YoutubeUsers
     * const youtubeUsers = await prisma.youtubeUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const youtubeUserWithIdOnly = await prisma.youtubeUser.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends YoutubeUserFindManyArgs>(
      args?: SelectSubset<T, YoutubeUserFindManyArgs>
    ): Prisma.PrismaPromise<Array<YoutubeUserGetPayload<T>>>

    /**
     * Create a YoutubeUser.
     * @param {YoutubeUserCreateArgs} args - Arguments to create a YoutubeUser.
     * @example
     * // Create one YoutubeUser
     * const YoutubeUser = await prisma.youtubeUser.create({
     *   data: {
     *     // ... data to create a YoutubeUser
     *   }
     * })
     * 
    **/
    create<T extends YoutubeUserCreateArgs>(
      args: SelectSubset<T, YoutubeUserCreateArgs>
    ): Prisma__YoutubeUserClient<YoutubeUserGetPayload<T>>

    /**
     * Create many YoutubeUsers.
     *     @param {YoutubeUserCreateManyArgs} args - Arguments to create many YoutubeUsers.
     *     @example
     *     // Create many YoutubeUsers
     *     const youtubeUser = await prisma.youtubeUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends YoutubeUserCreateManyArgs>(
      args?: SelectSubset<T, YoutubeUserCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a YoutubeUser.
     * @param {YoutubeUserDeleteArgs} args - Arguments to delete one YoutubeUser.
     * @example
     * // Delete one YoutubeUser
     * const YoutubeUser = await prisma.youtubeUser.delete({
     *   where: {
     *     // ... filter to delete one YoutubeUser
     *   }
     * })
     * 
    **/
    delete<T extends YoutubeUserDeleteArgs>(
      args: SelectSubset<T, YoutubeUserDeleteArgs>
    ): Prisma__YoutubeUserClient<YoutubeUserGetPayload<T>>

    /**
     * Update one YoutubeUser.
     * @param {YoutubeUserUpdateArgs} args - Arguments to update one YoutubeUser.
     * @example
     * // Update one YoutubeUser
     * const youtubeUser = await prisma.youtubeUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends YoutubeUserUpdateArgs>(
      args: SelectSubset<T, YoutubeUserUpdateArgs>
    ): Prisma__YoutubeUserClient<YoutubeUserGetPayload<T>>

    /**
     * Delete zero or more YoutubeUsers.
     * @param {YoutubeUserDeleteManyArgs} args - Arguments to filter YoutubeUsers to delete.
     * @example
     * // Delete a few YoutubeUsers
     * const { count } = await prisma.youtubeUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends YoutubeUserDeleteManyArgs>(
      args?: SelectSubset<T, YoutubeUserDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YoutubeUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YoutubeUsers
     * const youtubeUser = await prisma.youtubeUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends YoutubeUserUpdateManyArgs>(
      args: SelectSubset<T, YoutubeUserUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one YoutubeUser.
     * @param {YoutubeUserUpsertArgs} args - Arguments to update or create a YoutubeUser.
     * @example
     * // Update or create a YoutubeUser
     * const youtubeUser = await prisma.youtubeUser.upsert({
     *   create: {
     *     // ... data to create a YoutubeUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YoutubeUser we want to update
     *   }
     * })
    **/
    upsert<T extends YoutubeUserUpsertArgs>(
      args: SelectSubset<T, YoutubeUserUpsertArgs>
    ): Prisma__YoutubeUserClient<YoutubeUserGetPayload<T>>

    /**
     * Count the number of YoutubeUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeUserCountArgs} args - Arguments to filter YoutubeUsers to count.
     * @example
     * // Count the number of YoutubeUsers
     * const count = await prisma.youtubeUser.count({
     *   where: {
     *     // ... the filter for the YoutubeUsers we want to count
     *   }
     * })
    **/
    count<T extends YoutubeUserCountArgs>(
      args?: Subset<T, YoutubeUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YoutubeUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YoutubeUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YoutubeUserAggregateArgs>(args: Subset<T, YoutubeUserAggregateArgs>): Prisma.PrismaPromise<GetYoutubeUserAggregateType<T>>

    /**
     * Group by YoutubeUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YoutubeUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YoutubeUserGroupByArgs['orderBy'] }
        : { orderBy?: YoutubeUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YoutubeUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYoutubeUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for YoutubeUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__YoutubeUserClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    youtubeUsersToChannels<T extends YoutubeUser$youtubeUsersToChannelsArgs= {}>(args?: Subset<T, YoutubeUser$youtubeUsersToChannelsArgs>): Prisma.PrismaPromise<Array<YoutubeUserToChannelGetPayload<T>>| Null>;

    youtubeSubscriptions<T extends YoutubeUser$youtubeSubscriptionsArgs= {}>(args?: Subset<T, YoutubeUser$youtubeSubscriptionsArgs>): Prisma.PrismaPromise<Array<YoutubeSubscriptionGetPayload<T>>| Null>;

    YoutubeReaction<T extends YoutubeUser$YoutubeReactionArgs= {}>(args?: Subset<T, YoutubeUser$YoutubeReactionArgs>): Prisma.PrismaPromise<Array<YoutubeReactionGetPayload<T>>| Null>;

    YoutubeComment<T extends YoutubeUser$YoutubeCommentArgs= {}>(args?: Subset<T, YoutubeUser$YoutubeCommentArgs>): Prisma.PrismaPromise<Array<YoutubeCommentGetPayload<T>>| Null>;

    YoutubeCommentReaction<T extends YoutubeUser$YoutubeCommentReactionArgs= {}>(args?: Subset<T, YoutubeUser$YoutubeCommentReactionArgs>): Prisma.PrismaPromise<Array<YoutubeCommentReactionGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * YoutubeUser base type for findUnique actions
   */
  export type YoutubeUserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeUser
     */
    select?: YoutubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserInclude | null
    /**
     * Filter, which YoutubeUser to fetch.
     */
    where: YoutubeUserWhereUniqueInput
  }

  /**
   * YoutubeUser findUnique
   */
  export interface YoutubeUserFindUniqueArgs extends YoutubeUserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeUser findUniqueOrThrow
   */
  export type YoutubeUserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUser
     */
    select?: YoutubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserInclude | null
    /**
     * Filter, which YoutubeUser to fetch.
     */
    where: YoutubeUserWhereUniqueInput
  }


  /**
   * YoutubeUser base type for findFirst actions
   */
  export type YoutubeUserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeUser
     */
    select?: YoutubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserInclude | null
    /**
     * Filter, which YoutubeUser to fetch.
     */
    where?: YoutubeUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeUsers to fetch.
     */
    orderBy?: Enumerable<YoutubeUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeUsers.
     */
    cursor?: YoutubeUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeUsers.
     */
    distinct?: Enumerable<YoutubeUserScalarFieldEnum>
  }

  /**
   * YoutubeUser findFirst
   */
  export interface YoutubeUserFindFirstArgs extends YoutubeUserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeUser findFirstOrThrow
   */
  export type YoutubeUserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUser
     */
    select?: YoutubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserInclude | null
    /**
     * Filter, which YoutubeUser to fetch.
     */
    where?: YoutubeUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeUsers to fetch.
     */
    orderBy?: Enumerable<YoutubeUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeUsers.
     */
    cursor?: YoutubeUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeUsers.
     */
    distinct?: Enumerable<YoutubeUserScalarFieldEnum>
  }


  /**
   * YoutubeUser findMany
   */
  export type YoutubeUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUser
     */
    select?: YoutubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserInclude | null
    /**
     * Filter, which YoutubeUsers to fetch.
     */
    where?: YoutubeUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeUsers to fetch.
     */
    orderBy?: Enumerable<YoutubeUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YoutubeUsers.
     */
    cursor?: YoutubeUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeUsers.
     */
    skip?: number
    distinct?: Enumerable<YoutubeUserScalarFieldEnum>
  }


  /**
   * YoutubeUser create
   */
  export type YoutubeUserCreateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUser
     */
    select?: YoutubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserInclude | null
    /**
     * The data needed to create a YoutubeUser.
     */
    data: XOR<YoutubeUserCreateInput, YoutubeUserUncheckedCreateInput>
  }


  /**
   * YoutubeUser createMany
   */
  export type YoutubeUserCreateManyArgs = {
    /**
     * The data used to create many YoutubeUsers.
     */
    data: Enumerable<YoutubeUserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * YoutubeUser update
   */
  export type YoutubeUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUser
     */
    select?: YoutubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserInclude | null
    /**
     * The data needed to update a YoutubeUser.
     */
    data: XOR<YoutubeUserUpdateInput, YoutubeUserUncheckedUpdateInput>
    /**
     * Choose, which YoutubeUser to update.
     */
    where: YoutubeUserWhereUniqueInput
  }


  /**
   * YoutubeUser updateMany
   */
  export type YoutubeUserUpdateManyArgs = {
    /**
     * The data used to update YoutubeUsers.
     */
    data: XOR<YoutubeUserUpdateManyMutationInput, YoutubeUserUncheckedUpdateManyInput>
    /**
     * Filter which YoutubeUsers to update
     */
    where?: YoutubeUserWhereInput
  }


  /**
   * YoutubeUser upsert
   */
  export type YoutubeUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUser
     */
    select?: YoutubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserInclude | null
    /**
     * The filter to search for the YoutubeUser to update in case it exists.
     */
    where: YoutubeUserWhereUniqueInput
    /**
     * In case the YoutubeUser found by the `where` argument doesn't exist, create a new YoutubeUser with this data.
     */
    create: XOR<YoutubeUserCreateInput, YoutubeUserUncheckedCreateInput>
    /**
     * In case the YoutubeUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YoutubeUserUpdateInput, YoutubeUserUncheckedUpdateInput>
  }


  /**
   * YoutubeUser delete
   */
  export type YoutubeUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUser
     */
    select?: YoutubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserInclude | null
    /**
     * Filter which YoutubeUser to delete.
     */
    where: YoutubeUserWhereUniqueInput
  }


  /**
   * YoutubeUser deleteMany
   */
  export type YoutubeUserDeleteManyArgs = {
    /**
     * Filter which YoutubeUsers to delete
     */
    where?: YoutubeUserWhereInput
  }


  /**
   * YoutubeUser.youtubeUsersToChannels
   */
  export type YoutubeUser$youtubeUsersToChannelsArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUserToChannel
     */
    select?: YoutubeUserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserToChannelInclude | null
    where?: YoutubeUserToChannelWhereInput
    orderBy?: Enumerable<YoutubeUserToChannelOrderByWithRelationInput>
    cursor?: YoutubeUserToChannelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YoutubeUserToChannelScalarFieldEnum>
  }


  /**
   * YoutubeUser.youtubeSubscriptions
   */
  export type YoutubeUser$youtubeSubscriptionsArgs = {
    /**
     * Select specific fields to fetch from the YoutubeSubscription
     */
    select?: YoutubeSubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeSubscriptionInclude | null
    where?: YoutubeSubscriptionWhereInput
    orderBy?: Enumerable<YoutubeSubscriptionOrderByWithRelationInput>
    cursor?: YoutubeSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YoutubeSubscriptionScalarFieldEnum>
  }


  /**
   * YoutubeUser.YoutubeReaction
   */
  export type YoutubeUser$YoutubeReactionArgs = {
    /**
     * Select specific fields to fetch from the YoutubeReaction
     */
    select?: YoutubeReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeReactionInclude | null
    where?: YoutubeReactionWhereInput
    orderBy?: Enumerable<YoutubeReactionOrderByWithRelationInput>
    cursor?: YoutubeReactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YoutubeReactionScalarFieldEnum>
  }


  /**
   * YoutubeUser.YoutubeComment
   */
  export type YoutubeUser$YoutubeCommentArgs = {
    /**
     * Select specific fields to fetch from the YoutubeComment
     */
    select?: YoutubeCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentInclude | null
    where?: YoutubeCommentWhereInput
    orderBy?: Enumerable<YoutubeCommentOrderByWithRelationInput>
    cursor?: YoutubeCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YoutubeCommentScalarFieldEnum>
  }


  /**
   * YoutubeUser.YoutubeCommentReaction
   */
  export type YoutubeUser$YoutubeCommentReactionArgs = {
    /**
     * Select specific fields to fetch from the YoutubeCommentReaction
     */
    select?: YoutubeCommentReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentReactionInclude | null
    where?: YoutubeCommentReactionWhereInput
    orderBy?: Enumerable<YoutubeCommentReactionOrderByWithRelationInput>
    cursor?: YoutubeCommentReactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YoutubeCommentReactionScalarFieldEnum>
  }


  /**
   * YoutubeUser without action
   */
  export type YoutubeUserArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUser
     */
    select?: YoutubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserInclude | null
  }



  /**
   * Model YoutubeChannel
   */


  export type AggregateYoutubeChannel = {
    _count: YoutubeChannelCountAggregateOutputType | null
    _avg: YoutubeChannelAvgAggregateOutputType | null
    _sum: YoutubeChannelSumAggregateOutputType | null
    _min: YoutubeChannelMinAggregateOutputType | null
    _max: YoutubeChannelMaxAggregateOutputType | null
  }

  export type YoutubeChannelAvgAggregateOutputType = {
    id: number | null
  }

  export type YoutubeChannelSumAggregateOutputType = {
    id: number | null
  }

  export type YoutubeChannelMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type YoutubeChannelMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type YoutubeChannelCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type YoutubeChannelAvgAggregateInputType = {
    id?: true
  }

  export type YoutubeChannelSumAggregateInputType = {
    id?: true
  }

  export type YoutubeChannelMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type YoutubeChannelMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type YoutubeChannelCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type YoutubeChannelAggregateArgs = {
    /**
     * Filter which YoutubeChannel to aggregate.
     */
    where?: YoutubeChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeChannels to fetch.
     */
    orderBy?: Enumerable<YoutubeChannelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YoutubeChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YoutubeChannels
    **/
    _count?: true | YoutubeChannelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YoutubeChannelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YoutubeChannelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YoutubeChannelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YoutubeChannelMaxAggregateInputType
  }

  export type GetYoutubeChannelAggregateType<T extends YoutubeChannelAggregateArgs> = {
        [P in keyof T & keyof AggregateYoutubeChannel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYoutubeChannel[P]>
      : GetScalarType<T[P], AggregateYoutubeChannel[P]>
  }




  export type YoutubeChannelGroupByArgs = {
    where?: YoutubeChannelWhereInput
    orderBy?: Enumerable<YoutubeChannelOrderByWithAggregationInput>
    by: YoutubeChannelScalarFieldEnum[]
    having?: YoutubeChannelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YoutubeChannelCountAggregateInputType | true
    _avg?: YoutubeChannelAvgAggregateInputType
    _sum?: YoutubeChannelSumAggregateInputType
    _min?: YoutubeChannelMinAggregateInputType
    _max?: YoutubeChannelMaxAggregateInputType
  }


  export type YoutubeChannelGroupByOutputType = {
    id: number
    name: string
    description: string
    createdAt: Date
    updatedAt: Date
    _count: YoutubeChannelCountAggregateOutputType | null
    _avg: YoutubeChannelAvgAggregateOutputType | null
    _sum: YoutubeChannelSumAggregateOutputType | null
    _min: YoutubeChannelMinAggregateOutputType | null
    _max: YoutubeChannelMaxAggregateOutputType | null
  }

  type GetYoutubeChannelGroupByPayload<T extends YoutubeChannelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<YoutubeChannelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YoutubeChannelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YoutubeChannelGroupByOutputType[P]>
            : GetScalarType<T[P], YoutubeChannelGroupByOutputType[P]>
        }
      >
    >


  export type YoutubeChannelSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    youtubeUsersToChannels?: boolean | YoutubeChannel$youtubeUsersToChannelsArgs
    youtubeVideos?: boolean | YoutubeChannel$youtubeVideosArgs
    youtubeSubscriptions?: boolean | YoutubeChannel$youtubeSubscriptionsArgs
    _count?: boolean | YoutubeChannelCountOutputTypeArgs
  }


  export type YoutubeChannelInclude = {
    youtubeUsersToChannels?: boolean | YoutubeChannel$youtubeUsersToChannelsArgs
    youtubeVideos?: boolean | YoutubeChannel$youtubeVideosArgs
    youtubeSubscriptions?: boolean | YoutubeChannel$youtubeSubscriptionsArgs
    _count?: boolean | YoutubeChannelCountOutputTypeArgs
  }

  export type YoutubeChannelGetPayload<S extends boolean | null | undefined | YoutubeChannelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YoutubeChannel :
    S extends undefined ? never :
    S extends { include: any } & (YoutubeChannelArgs | YoutubeChannelFindManyArgs)
    ? YoutubeChannel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'youtubeUsersToChannels' ? Array < YoutubeUserToChannelGetPayload<S['include'][P]>>  :
        P extends 'youtubeVideos' ? Array < YoutubeVideoGetPayload<S['include'][P]>>  :
        P extends 'youtubeSubscriptions' ? Array < YoutubeSubscriptionGetPayload<S['include'][P]>>  :
        P extends '_count' ? YoutubeChannelCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (YoutubeChannelArgs | YoutubeChannelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'youtubeUsersToChannels' ? Array < YoutubeUserToChannelGetPayload<S['select'][P]>>  :
        P extends 'youtubeVideos' ? Array < YoutubeVideoGetPayload<S['select'][P]>>  :
        P extends 'youtubeSubscriptions' ? Array < YoutubeSubscriptionGetPayload<S['select'][P]>>  :
        P extends '_count' ? YoutubeChannelCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof YoutubeChannel ? YoutubeChannel[P] : never
  } 
      : YoutubeChannel


  type YoutubeChannelCountArgs = 
    Omit<YoutubeChannelFindManyArgs, 'select' | 'include'> & {
      select?: YoutubeChannelCountAggregateInputType | true
    }

  export interface YoutubeChannelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one YoutubeChannel that matches the filter.
     * @param {YoutubeChannelFindUniqueArgs} args - Arguments to find a YoutubeChannel
     * @example
     * // Get one YoutubeChannel
     * const youtubeChannel = await prisma.youtubeChannel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends YoutubeChannelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, YoutubeChannelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'YoutubeChannel'> extends True ? Prisma__YoutubeChannelClient<YoutubeChannelGetPayload<T>> : Prisma__YoutubeChannelClient<YoutubeChannelGetPayload<T> | null, null>

    /**
     * Find one YoutubeChannel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {YoutubeChannelFindUniqueOrThrowArgs} args - Arguments to find a YoutubeChannel
     * @example
     * // Get one YoutubeChannel
     * const youtubeChannel = await prisma.youtubeChannel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends YoutubeChannelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, YoutubeChannelFindUniqueOrThrowArgs>
    ): Prisma__YoutubeChannelClient<YoutubeChannelGetPayload<T>>

    /**
     * Find the first YoutubeChannel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeChannelFindFirstArgs} args - Arguments to find a YoutubeChannel
     * @example
     * // Get one YoutubeChannel
     * const youtubeChannel = await prisma.youtubeChannel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends YoutubeChannelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, YoutubeChannelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'YoutubeChannel'> extends True ? Prisma__YoutubeChannelClient<YoutubeChannelGetPayload<T>> : Prisma__YoutubeChannelClient<YoutubeChannelGetPayload<T> | null, null>

    /**
     * Find the first YoutubeChannel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeChannelFindFirstOrThrowArgs} args - Arguments to find a YoutubeChannel
     * @example
     * // Get one YoutubeChannel
     * const youtubeChannel = await prisma.youtubeChannel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends YoutubeChannelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, YoutubeChannelFindFirstOrThrowArgs>
    ): Prisma__YoutubeChannelClient<YoutubeChannelGetPayload<T>>

    /**
     * Find zero or more YoutubeChannels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeChannelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YoutubeChannels
     * const youtubeChannels = await prisma.youtubeChannel.findMany()
     * 
     * // Get first 10 YoutubeChannels
     * const youtubeChannels = await prisma.youtubeChannel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const youtubeChannelWithIdOnly = await prisma.youtubeChannel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends YoutubeChannelFindManyArgs>(
      args?: SelectSubset<T, YoutubeChannelFindManyArgs>
    ): Prisma.PrismaPromise<Array<YoutubeChannelGetPayload<T>>>

    /**
     * Create a YoutubeChannel.
     * @param {YoutubeChannelCreateArgs} args - Arguments to create a YoutubeChannel.
     * @example
     * // Create one YoutubeChannel
     * const YoutubeChannel = await prisma.youtubeChannel.create({
     *   data: {
     *     // ... data to create a YoutubeChannel
     *   }
     * })
     * 
    **/
    create<T extends YoutubeChannelCreateArgs>(
      args: SelectSubset<T, YoutubeChannelCreateArgs>
    ): Prisma__YoutubeChannelClient<YoutubeChannelGetPayload<T>>

    /**
     * Create many YoutubeChannels.
     *     @param {YoutubeChannelCreateManyArgs} args - Arguments to create many YoutubeChannels.
     *     @example
     *     // Create many YoutubeChannels
     *     const youtubeChannel = await prisma.youtubeChannel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends YoutubeChannelCreateManyArgs>(
      args?: SelectSubset<T, YoutubeChannelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a YoutubeChannel.
     * @param {YoutubeChannelDeleteArgs} args - Arguments to delete one YoutubeChannel.
     * @example
     * // Delete one YoutubeChannel
     * const YoutubeChannel = await prisma.youtubeChannel.delete({
     *   where: {
     *     // ... filter to delete one YoutubeChannel
     *   }
     * })
     * 
    **/
    delete<T extends YoutubeChannelDeleteArgs>(
      args: SelectSubset<T, YoutubeChannelDeleteArgs>
    ): Prisma__YoutubeChannelClient<YoutubeChannelGetPayload<T>>

    /**
     * Update one YoutubeChannel.
     * @param {YoutubeChannelUpdateArgs} args - Arguments to update one YoutubeChannel.
     * @example
     * // Update one YoutubeChannel
     * const youtubeChannel = await prisma.youtubeChannel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends YoutubeChannelUpdateArgs>(
      args: SelectSubset<T, YoutubeChannelUpdateArgs>
    ): Prisma__YoutubeChannelClient<YoutubeChannelGetPayload<T>>

    /**
     * Delete zero or more YoutubeChannels.
     * @param {YoutubeChannelDeleteManyArgs} args - Arguments to filter YoutubeChannels to delete.
     * @example
     * // Delete a few YoutubeChannels
     * const { count } = await prisma.youtubeChannel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends YoutubeChannelDeleteManyArgs>(
      args?: SelectSubset<T, YoutubeChannelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YoutubeChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeChannelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YoutubeChannels
     * const youtubeChannel = await prisma.youtubeChannel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends YoutubeChannelUpdateManyArgs>(
      args: SelectSubset<T, YoutubeChannelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one YoutubeChannel.
     * @param {YoutubeChannelUpsertArgs} args - Arguments to update or create a YoutubeChannel.
     * @example
     * // Update or create a YoutubeChannel
     * const youtubeChannel = await prisma.youtubeChannel.upsert({
     *   create: {
     *     // ... data to create a YoutubeChannel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YoutubeChannel we want to update
     *   }
     * })
    **/
    upsert<T extends YoutubeChannelUpsertArgs>(
      args: SelectSubset<T, YoutubeChannelUpsertArgs>
    ): Prisma__YoutubeChannelClient<YoutubeChannelGetPayload<T>>

    /**
     * Count the number of YoutubeChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeChannelCountArgs} args - Arguments to filter YoutubeChannels to count.
     * @example
     * // Count the number of YoutubeChannels
     * const count = await prisma.youtubeChannel.count({
     *   where: {
     *     // ... the filter for the YoutubeChannels we want to count
     *   }
     * })
    **/
    count<T extends YoutubeChannelCountArgs>(
      args?: Subset<T, YoutubeChannelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YoutubeChannelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YoutubeChannel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeChannelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YoutubeChannelAggregateArgs>(args: Subset<T, YoutubeChannelAggregateArgs>): Prisma.PrismaPromise<GetYoutubeChannelAggregateType<T>>

    /**
     * Group by YoutubeChannel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeChannelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YoutubeChannelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YoutubeChannelGroupByArgs['orderBy'] }
        : { orderBy?: YoutubeChannelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YoutubeChannelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYoutubeChannelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for YoutubeChannel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__YoutubeChannelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    youtubeUsersToChannels<T extends YoutubeChannel$youtubeUsersToChannelsArgs= {}>(args?: Subset<T, YoutubeChannel$youtubeUsersToChannelsArgs>): Prisma.PrismaPromise<Array<YoutubeUserToChannelGetPayload<T>>| Null>;

    youtubeVideos<T extends YoutubeChannel$youtubeVideosArgs= {}>(args?: Subset<T, YoutubeChannel$youtubeVideosArgs>): Prisma.PrismaPromise<Array<YoutubeVideoGetPayload<T>>| Null>;

    youtubeSubscriptions<T extends YoutubeChannel$youtubeSubscriptionsArgs= {}>(args?: Subset<T, YoutubeChannel$youtubeSubscriptionsArgs>): Prisma.PrismaPromise<Array<YoutubeSubscriptionGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * YoutubeChannel base type for findUnique actions
   */
  export type YoutubeChannelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeChannel
     */
    select?: YoutubeChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeChannelInclude | null
    /**
     * Filter, which YoutubeChannel to fetch.
     */
    where: YoutubeChannelWhereUniqueInput
  }

  /**
   * YoutubeChannel findUnique
   */
  export interface YoutubeChannelFindUniqueArgs extends YoutubeChannelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeChannel findUniqueOrThrow
   */
  export type YoutubeChannelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeChannel
     */
    select?: YoutubeChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeChannelInclude | null
    /**
     * Filter, which YoutubeChannel to fetch.
     */
    where: YoutubeChannelWhereUniqueInput
  }


  /**
   * YoutubeChannel base type for findFirst actions
   */
  export type YoutubeChannelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeChannel
     */
    select?: YoutubeChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeChannelInclude | null
    /**
     * Filter, which YoutubeChannel to fetch.
     */
    where?: YoutubeChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeChannels to fetch.
     */
    orderBy?: Enumerable<YoutubeChannelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeChannels.
     */
    cursor?: YoutubeChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeChannels.
     */
    distinct?: Enumerable<YoutubeChannelScalarFieldEnum>
  }

  /**
   * YoutubeChannel findFirst
   */
  export interface YoutubeChannelFindFirstArgs extends YoutubeChannelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeChannel findFirstOrThrow
   */
  export type YoutubeChannelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeChannel
     */
    select?: YoutubeChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeChannelInclude | null
    /**
     * Filter, which YoutubeChannel to fetch.
     */
    where?: YoutubeChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeChannels to fetch.
     */
    orderBy?: Enumerable<YoutubeChannelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeChannels.
     */
    cursor?: YoutubeChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeChannels.
     */
    distinct?: Enumerable<YoutubeChannelScalarFieldEnum>
  }


  /**
   * YoutubeChannel findMany
   */
  export type YoutubeChannelFindManyArgs = {
    /**
     * Select specific fields to fetch from the YoutubeChannel
     */
    select?: YoutubeChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeChannelInclude | null
    /**
     * Filter, which YoutubeChannels to fetch.
     */
    where?: YoutubeChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeChannels to fetch.
     */
    orderBy?: Enumerable<YoutubeChannelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YoutubeChannels.
     */
    cursor?: YoutubeChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeChannels.
     */
    skip?: number
    distinct?: Enumerable<YoutubeChannelScalarFieldEnum>
  }


  /**
   * YoutubeChannel create
   */
  export type YoutubeChannelCreateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeChannel
     */
    select?: YoutubeChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeChannelInclude | null
    /**
     * The data needed to create a YoutubeChannel.
     */
    data: XOR<YoutubeChannelCreateInput, YoutubeChannelUncheckedCreateInput>
  }


  /**
   * YoutubeChannel createMany
   */
  export type YoutubeChannelCreateManyArgs = {
    /**
     * The data used to create many YoutubeChannels.
     */
    data: Enumerable<YoutubeChannelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * YoutubeChannel update
   */
  export type YoutubeChannelUpdateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeChannel
     */
    select?: YoutubeChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeChannelInclude | null
    /**
     * The data needed to update a YoutubeChannel.
     */
    data: XOR<YoutubeChannelUpdateInput, YoutubeChannelUncheckedUpdateInput>
    /**
     * Choose, which YoutubeChannel to update.
     */
    where: YoutubeChannelWhereUniqueInput
  }


  /**
   * YoutubeChannel updateMany
   */
  export type YoutubeChannelUpdateManyArgs = {
    /**
     * The data used to update YoutubeChannels.
     */
    data: XOR<YoutubeChannelUpdateManyMutationInput, YoutubeChannelUncheckedUpdateManyInput>
    /**
     * Filter which YoutubeChannels to update
     */
    where?: YoutubeChannelWhereInput
  }


  /**
   * YoutubeChannel upsert
   */
  export type YoutubeChannelUpsertArgs = {
    /**
     * Select specific fields to fetch from the YoutubeChannel
     */
    select?: YoutubeChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeChannelInclude | null
    /**
     * The filter to search for the YoutubeChannel to update in case it exists.
     */
    where: YoutubeChannelWhereUniqueInput
    /**
     * In case the YoutubeChannel found by the `where` argument doesn't exist, create a new YoutubeChannel with this data.
     */
    create: XOR<YoutubeChannelCreateInput, YoutubeChannelUncheckedCreateInput>
    /**
     * In case the YoutubeChannel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YoutubeChannelUpdateInput, YoutubeChannelUncheckedUpdateInput>
  }


  /**
   * YoutubeChannel delete
   */
  export type YoutubeChannelDeleteArgs = {
    /**
     * Select specific fields to fetch from the YoutubeChannel
     */
    select?: YoutubeChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeChannelInclude | null
    /**
     * Filter which YoutubeChannel to delete.
     */
    where: YoutubeChannelWhereUniqueInput
  }


  /**
   * YoutubeChannel deleteMany
   */
  export type YoutubeChannelDeleteManyArgs = {
    /**
     * Filter which YoutubeChannels to delete
     */
    where?: YoutubeChannelWhereInput
  }


  /**
   * YoutubeChannel.youtubeUsersToChannels
   */
  export type YoutubeChannel$youtubeUsersToChannelsArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUserToChannel
     */
    select?: YoutubeUserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserToChannelInclude | null
    where?: YoutubeUserToChannelWhereInput
    orderBy?: Enumerable<YoutubeUserToChannelOrderByWithRelationInput>
    cursor?: YoutubeUserToChannelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YoutubeUserToChannelScalarFieldEnum>
  }


  /**
   * YoutubeChannel.youtubeVideos
   */
  export type YoutubeChannel$youtubeVideosArgs = {
    /**
     * Select specific fields to fetch from the YoutubeVideo
     */
    select?: YoutubeVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeVideoInclude | null
    where?: YoutubeVideoWhereInput
    orderBy?: Enumerable<YoutubeVideoOrderByWithRelationInput>
    cursor?: YoutubeVideoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YoutubeVideoScalarFieldEnum>
  }


  /**
   * YoutubeChannel.youtubeSubscriptions
   */
  export type YoutubeChannel$youtubeSubscriptionsArgs = {
    /**
     * Select specific fields to fetch from the YoutubeSubscription
     */
    select?: YoutubeSubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeSubscriptionInclude | null
    where?: YoutubeSubscriptionWhereInput
    orderBy?: Enumerable<YoutubeSubscriptionOrderByWithRelationInput>
    cursor?: YoutubeSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YoutubeSubscriptionScalarFieldEnum>
  }


  /**
   * YoutubeChannel without action
   */
  export type YoutubeChannelArgs = {
    /**
     * Select specific fields to fetch from the YoutubeChannel
     */
    select?: YoutubeChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeChannelInclude | null
  }



  /**
   * Model YoutubeSubscription
   */


  export type AggregateYoutubeSubscription = {
    _count: YoutubeSubscriptionCountAggregateOutputType | null
    _avg: YoutubeSubscriptionAvgAggregateOutputType | null
    _sum: YoutubeSubscriptionSumAggregateOutputType | null
    _min: YoutubeSubscriptionMinAggregateOutputType | null
    _max: YoutubeSubscriptionMaxAggregateOutputType | null
  }

  export type YoutubeSubscriptionAvgAggregateOutputType = {
    id: number | null
    youtubeUserId: number | null
    youtubeChannelId: number | null
  }

  export type YoutubeSubscriptionSumAggregateOutputType = {
    id: number | null
    youtubeUserId: number | null
    youtubeChannelId: number | null
  }

  export type YoutubeSubscriptionMinAggregateOutputType = {
    id: number | null
    membership: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    youtubeUserId: number | null
    youtubeChannelId: number | null
  }

  export type YoutubeSubscriptionMaxAggregateOutputType = {
    id: number | null
    membership: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    youtubeUserId: number | null
    youtubeChannelId: number | null
  }

  export type YoutubeSubscriptionCountAggregateOutputType = {
    id: number
    membership: number
    createdAt: number
    updatedAt: number
    youtubeUserId: number
    youtubeChannelId: number
    _all: number
  }


  export type YoutubeSubscriptionAvgAggregateInputType = {
    id?: true
    youtubeUserId?: true
    youtubeChannelId?: true
  }

  export type YoutubeSubscriptionSumAggregateInputType = {
    id?: true
    youtubeUserId?: true
    youtubeChannelId?: true
  }

  export type YoutubeSubscriptionMinAggregateInputType = {
    id?: true
    membership?: true
    createdAt?: true
    updatedAt?: true
    youtubeUserId?: true
    youtubeChannelId?: true
  }

  export type YoutubeSubscriptionMaxAggregateInputType = {
    id?: true
    membership?: true
    createdAt?: true
    updatedAt?: true
    youtubeUserId?: true
    youtubeChannelId?: true
  }

  export type YoutubeSubscriptionCountAggregateInputType = {
    id?: true
    membership?: true
    createdAt?: true
    updatedAt?: true
    youtubeUserId?: true
    youtubeChannelId?: true
    _all?: true
  }

  export type YoutubeSubscriptionAggregateArgs = {
    /**
     * Filter which YoutubeSubscription to aggregate.
     */
    where?: YoutubeSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeSubscriptions to fetch.
     */
    orderBy?: Enumerable<YoutubeSubscriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YoutubeSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YoutubeSubscriptions
    **/
    _count?: true | YoutubeSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YoutubeSubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YoutubeSubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YoutubeSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YoutubeSubscriptionMaxAggregateInputType
  }

  export type GetYoutubeSubscriptionAggregateType<T extends YoutubeSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateYoutubeSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYoutubeSubscription[P]>
      : GetScalarType<T[P], AggregateYoutubeSubscription[P]>
  }




  export type YoutubeSubscriptionGroupByArgs = {
    where?: YoutubeSubscriptionWhereInput
    orderBy?: Enumerable<YoutubeSubscriptionOrderByWithAggregationInput>
    by: YoutubeSubscriptionScalarFieldEnum[]
    having?: YoutubeSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YoutubeSubscriptionCountAggregateInputType | true
    _avg?: YoutubeSubscriptionAvgAggregateInputType
    _sum?: YoutubeSubscriptionSumAggregateInputType
    _min?: YoutubeSubscriptionMinAggregateInputType
    _max?: YoutubeSubscriptionMaxAggregateInputType
  }


  export type YoutubeSubscriptionGroupByOutputType = {
    id: number
    membership: boolean
    createdAt: Date
    updatedAt: Date
    youtubeUserId: number
    youtubeChannelId: number
    _count: YoutubeSubscriptionCountAggregateOutputType | null
    _avg: YoutubeSubscriptionAvgAggregateOutputType | null
    _sum: YoutubeSubscriptionSumAggregateOutputType | null
    _min: YoutubeSubscriptionMinAggregateOutputType | null
    _max: YoutubeSubscriptionMaxAggregateOutputType | null
  }

  type GetYoutubeSubscriptionGroupByPayload<T extends YoutubeSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<YoutubeSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YoutubeSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YoutubeSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], YoutubeSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type YoutubeSubscriptionSelect = {
    id?: boolean
    user?: boolean | YoutubeUserArgs
    channel?: boolean | YoutubeChannelArgs
    membership?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    youtubeUserId?: boolean
    youtubeChannelId?: boolean
  }


  export type YoutubeSubscriptionInclude = {
    user?: boolean | YoutubeUserArgs
    channel?: boolean | YoutubeChannelArgs
  }

  export type YoutubeSubscriptionGetPayload<S extends boolean | null | undefined | YoutubeSubscriptionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YoutubeSubscription :
    S extends undefined ? never :
    S extends { include: any } & (YoutubeSubscriptionArgs | YoutubeSubscriptionFindManyArgs)
    ? YoutubeSubscription  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? YoutubeUserGetPayload<S['include'][P]> :
        P extends 'channel' ? YoutubeChannelGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (YoutubeSubscriptionArgs | YoutubeSubscriptionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? YoutubeUserGetPayload<S['select'][P]> :
        P extends 'channel' ? YoutubeChannelGetPayload<S['select'][P]> :  P extends keyof YoutubeSubscription ? YoutubeSubscription[P] : never
  } 
      : YoutubeSubscription


  type YoutubeSubscriptionCountArgs = 
    Omit<YoutubeSubscriptionFindManyArgs, 'select' | 'include'> & {
      select?: YoutubeSubscriptionCountAggregateInputType | true
    }

  export interface YoutubeSubscriptionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one YoutubeSubscription that matches the filter.
     * @param {YoutubeSubscriptionFindUniqueArgs} args - Arguments to find a YoutubeSubscription
     * @example
     * // Get one YoutubeSubscription
     * const youtubeSubscription = await prisma.youtubeSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends YoutubeSubscriptionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, YoutubeSubscriptionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'YoutubeSubscription'> extends True ? Prisma__YoutubeSubscriptionClient<YoutubeSubscriptionGetPayload<T>> : Prisma__YoutubeSubscriptionClient<YoutubeSubscriptionGetPayload<T> | null, null>

    /**
     * Find one YoutubeSubscription that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {YoutubeSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a YoutubeSubscription
     * @example
     * // Get one YoutubeSubscription
     * const youtubeSubscription = await prisma.youtubeSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends YoutubeSubscriptionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, YoutubeSubscriptionFindUniqueOrThrowArgs>
    ): Prisma__YoutubeSubscriptionClient<YoutubeSubscriptionGetPayload<T>>

    /**
     * Find the first YoutubeSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeSubscriptionFindFirstArgs} args - Arguments to find a YoutubeSubscription
     * @example
     * // Get one YoutubeSubscription
     * const youtubeSubscription = await prisma.youtubeSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends YoutubeSubscriptionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, YoutubeSubscriptionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'YoutubeSubscription'> extends True ? Prisma__YoutubeSubscriptionClient<YoutubeSubscriptionGetPayload<T>> : Prisma__YoutubeSubscriptionClient<YoutubeSubscriptionGetPayload<T> | null, null>

    /**
     * Find the first YoutubeSubscription that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeSubscriptionFindFirstOrThrowArgs} args - Arguments to find a YoutubeSubscription
     * @example
     * // Get one YoutubeSubscription
     * const youtubeSubscription = await prisma.youtubeSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends YoutubeSubscriptionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, YoutubeSubscriptionFindFirstOrThrowArgs>
    ): Prisma__YoutubeSubscriptionClient<YoutubeSubscriptionGetPayload<T>>

    /**
     * Find zero or more YoutubeSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeSubscriptionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YoutubeSubscriptions
     * const youtubeSubscriptions = await prisma.youtubeSubscription.findMany()
     * 
     * // Get first 10 YoutubeSubscriptions
     * const youtubeSubscriptions = await prisma.youtubeSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const youtubeSubscriptionWithIdOnly = await prisma.youtubeSubscription.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends YoutubeSubscriptionFindManyArgs>(
      args?: SelectSubset<T, YoutubeSubscriptionFindManyArgs>
    ): Prisma.PrismaPromise<Array<YoutubeSubscriptionGetPayload<T>>>

    /**
     * Create a YoutubeSubscription.
     * @param {YoutubeSubscriptionCreateArgs} args - Arguments to create a YoutubeSubscription.
     * @example
     * // Create one YoutubeSubscription
     * const YoutubeSubscription = await prisma.youtubeSubscription.create({
     *   data: {
     *     // ... data to create a YoutubeSubscription
     *   }
     * })
     * 
    **/
    create<T extends YoutubeSubscriptionCreateArgs>(
      args: SelectSubset<T, YoutubeSubscriptionCreateArgs>
    ): Prisma__YoutubeSubscriptionClient<YoutubeSubscriptionGetPayload<T>>

    /**
     * Create many YoutubeSubscriptions.
     *     @param {YoutubeSubscriptionCreateManyArgs} args - Arguments to create many YoutubeSubscriptions.
     *     @example
     *     // Create many YoutubeSubscriptions
     *     const youtubeSubscription = await prisma.youtubeSubscription.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends YoutubeSubscriptionCreateManyArgs>(
      args?: SelectSubset<T, YoutubeSubscriptionCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a YoutubeSubscription.
     * @param {YoutubeSubscriptionDeleteArgs} args - Arguments to delete one YoutubeSubscription.
     * @example
     * // Delete one YoutubeSubscription
     * const YoutubeSubscription = await prisma.youtubeSubscription.delete({
     *   where: {
     *     // ... filter to delete one YoutubeSubscription
     *   }
     * })
     * 
    **/
    delete<T extends YoutubeSubscriptionDeleteArgs>(
      args: SelectSubset<T, YoutubeSubscriptionDeleteArgs>
    ): Prisma__YoutubeSubscriptionClient<YoutubeSubscriptionGetPayload<T>>

    /**
     * Update one YoutubeSubscription.
     * @param {YoutubeSubscriptionUpdateArgs} args - Arguments to update one YoutubeSubscription.
     * @example
     * // Update one YoutubeSubscription
     * const youtubeSubscription = await prisma.youtubeSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends YoutubeSubscriptionUpdateArgs>(
      args: SelectSubset<T, YoutubeSubscriptionUpdateArgs>
    ): Prisma__YoutubeSubscriptionClient<YoutubeSubscriptionGetPayload<T>>

    /**
     * Delete zero or more YoutubeSubscriptions.
     * @param {YoutubeSubscriptionDeleteManyArgs} args - Arguments to filter YoutubeSubscriptions to delete.
     * @example
     * // Delete a few YoutubeSubscriptions
     * const { count } = await prisma.youtubeSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends YoutubeSubscriptionDeleteManyArgs>(
      args?: SelectSubset<T, YoutubeSubscriptionDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YoutubeSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YoutubeSubscriptions
     * const youtubeSubscription = await prisma.youtubeSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends YoutubeSubscriptionUpdateManyArgs>(
      args: SelectSubset<T, YoutubeSubscriptionUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one YoutubeSubscription.
     * @param {YoutubeSubscriptionUpsertArgs} args - Arguments to update or create a YoutubeSubscription.
     * @example
     * // Update or create a YoutubeSubscription
     * const youtubeSubscription = await prisma.youtubeSubscription.upsert({
     *   create: {
     *     // ... data to create a YoutubeSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YoutubeSubscription we want to update
     *   }
     * })
    **/
    upsert<T extends YoutubeSubscriptionUpsertArgs>(
      args: SelectSubset<T, YoutubeSubscriptionUpsertArgs>
    ): Prisma__YoutubeSubscriptionClient<YoutubeSubscriptionGetPayload<T>>

    /**
     * Count the number of YoutubeSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeSubscriptionCountArgs} args - Arguments to filter YoutubeSubscriptions to count.
     * @example
     * // Count the number of YoutubeSubscriptions
     * const count = await prisma.youtubeSubscription.count({
     *   where: {
     *     // ... the filter for the YoutubeSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends YoutubeSubscriptionCountArgs>(
      args?: Subset<T, YoutubeSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YoutubeSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YoutubeSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YoutubeSubscriptionAggregateArgs>(args: Subset<T, YoutubeSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetYoutubeSubscriptionAggregateType<T>>

    /**
     * Group by YoutubeSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YoutubeSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YoutubeSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: YoutubeSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YoutubeSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYoutubeSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for YoutubeSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__YoutubeSubscriptionClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends YoutubeUserArgs= {}>(args?: Subset<T, YoutubeUserArgs>): Prisma__YoutubeUserClient<YoutubeUserGetPayload<T> | Null>;

    channel<T extends YoutubeChannelArgs= {}>(args?: Subset<T, YoutubeChannelArgs>): Prisma__YoutubeChannelClient<YoutubeChannelGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * YoutubeSubscription base type for findUnique actions
   */
  export type YoutubeSubscriptionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeSubscription
     */
    select?: YoutubeSubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeSubscriptionInclude | null
    /**
     * Filter, which YoutubeSubscription to fetch.
     */
    where: YoutubeSubscriptionWhereUniqueInput
  }

  /**
   * YoutubeSubscription findUnique
   */
  export interface YoutubeSubscriptionFindUniqueArgs extends YoutubeSubscriptionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeSubscription findUniqueOrThrow
   */
  export type YoutubeSubscriptionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeSubscription
     */
    select?: YoutubeSubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeSubscriptionInclude | null
    /**
     * Filter, which YoutubeSubscription to fetch.
     */
    where: YoutubeSubscriptionWhereUniqueInput
  }


  /**
   * YoutubeSubscription base type for findFirst actions
   */
  export type YoutubeSubscriptionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeSubscription
     */
    select?: YoutubeSubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeSubscriptionInclude | null
    /**
     * Filter, which YoutubeSubscription to fetch.
     */
    where?: YoutubeSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeSubscriptions to fetch.
     */
    orderBy?: Enumerable<YoutubeSubscriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeSubscriptions.
     */
    cursor?: YoutubeSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeSubscriptions.
     */
    distinct?: Enumerable<YoutubeSubscriptionScalarFieldEnum>
  }

  /**
   * YoutubeSubscription findFirst
   */
  export interface YoutubeSubscriptionFindFirstArgs extends YoutubeSubscriptionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeSubscription findFirstOrThrow
   */
  export type YoutubeSubscriptionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeSubscription
     */
    select?: YoutubeSubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeSubscriptionInclude | null
    /**
     * Filter, which YoutubeSubscription to fetch.
     */
    where?: YoutubeSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeSubscriptions to fetch.
     */
    orderBy?: Enumerable<YoutubeSubscriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeSubscriptions.
     */
    cursor?: YoutubeSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeSubscriptions.
     */
    distinct?: Enumerable<YoutubeSubscriptionScalarFieldEnum>
  }


  /**
   * YoutubeSubscription findMany
   */
  export type YoutubeSubscriptionFindManyArgs = {
    /**
     * Select specific fields to fetch from the YoutubeSubscription
     */
    select?: YoutubeSubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeSubscriptionInclude | null
    /**
     * Filter, which YoutubeSubscriptions to fetch.
     */
    where?: YoutubeSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeSubscriptions to fetch.
     */
    orderBy?: Enumerable<YoutubeSubscriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YoutubeSubscriptions.
     */
    cursor?: YoutubeSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeSubscriptions.
     */
    skip?: number
    distinct?: Enumerable<YoutubeSubscriptionScalarFieldEnum>
  }


  /**
   * YoutubeSubscription create
   */
  export type YoutubeSubscriptionCreateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeSubscription
     */
    select?: YoutubeSubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeSubscriptionInclude | null
    /**
     * The data needed to create a YoutubeSubscription.
     */
    data: XOR<YoutubeSubscriptionCreateInput, YoutubeSubscriptionUncheckedCreateInput>
  }


  /**
   * YoutubeSubscription createMany
   */
  export type YoutubeSubscriptionCreateManyArgs = {
    /**
     * The data used to create many YoutubeSubscriptions.
     */
    data: Enumerable<YoutubeSubscriptionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * YoutubeSubscription update
   */
  export type YoutubeSubscriptionUpdateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeSubscription
     */
    select?: YoutubeSubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeSubscriptionInclude | null
    /**
     * The data needed to update a YoutubeSubscription.
     */
    data: XOR<YoutubeSubscriptionUpdateInput, YoutubeSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which YoutubeSubscription to update.
     */
    where: YoutubeSubscriptionWhereUniqueInput
  }


  /**
   * YoutubeSubscription updateMany
   */
  export type YoutubeSubscriptionUpdateManyArgs = {
    /**
     * The data used to update YoutubeSubscriptions.
     */
    data: XOR<YoutubeSubscriptionUpdateManyMutationInput, YoutubeSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which YoutubeSubscriptions to update
     */
    where?: YoutubeSubscriptionWhereInput
  }


  /**
   * YoutubeSubscription upsert
   */
  export type YoutubeSubscriptionUpsertArgs = {
    /**
     * Select specific fields to fetch from the YoutubeSubscription
     */
    select?: YoutubeSubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeSubscriptionInclude | null
    /**
     * The filter to search for the YoutubeSubscription to update in case it exists.
     */
    where: YoutubeSubscriptionWhereUniqueInput
    /**
     * In case the YoutubeSubscription found by the `where` argument doesn't exist, create a new YoutubeSubscription with this data.
     */
    create: XOR<YoutubeSubscriptionCreateInput, YoutubeSubscriptionUncheckedCreateInput>
    /**
     * In case the YoutubeSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YoutubeSubscriptionUpdateInput, YoutubeSubscriptionUncheckedUpdateInput>
  }


  /**
   * YoutubeSubscription delete
   */
  export type YoutubeSubscriptionDeleteArgs = {
    /**
     * Select specific fields to fetch from the YoutubeSubscription
     */
    select?: YoutubeSubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeSubscriptionInclude | null
    /**
     * Filter which YoutubeSubscription to delete.
     */
    where: YoutubeSubscriptionWhereUniqueInput
  }


  /**
   * YoutubeSubscription deleteMany
   */
  export type YoutubeSubscriptionDeleteManyArgs = {
    /**
     * Filter which YoutubeSubscriptions to delete
     */
    where?: YoutubeSubscriptionWhereInput
  }


  /**
   * YoutubeSubscription without action
   */
  export type YoutubeSubscriptionArgs = {
    /**
     * Select specific fields to fetch from the YoutubeSubscription
     */
    select?: YoutubeSubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeSubscriptionInclude | null
  }



  /**
   * Model YoutubeUserToChannel
   */


  export type AggregateYoutubeUserToChannel = {
    _count: YoutubeUserToChannelCountAggregateOutputType | null
    _avg: YoutubeUserToChannelAvgAggregateOutputType | null
    _sum: YoutubeUserToChannelSumAggregateOutputType | null
    _min: YoutubeUserToChannelMinAggregateOutputType | null
    _max: YoutubeUserToChannelMaxAggregateOutputType | null
  }

  export type YoutubeUserToChannelAvgAggregateOutputType = {
    id: number | null
    youtubeUserId: number | null
    youtubeChannelId: number | null
  }

  export type YoutubeUserToChannelSumAggregateOutputType = {
    id: number | null
    youtubeUserId: number | null
    youtubeChannelId: number | null
  }

  export type YoutubeUserToChannelMinAggregateOutputType = {
    id: number | null
    description: string | null
    role: RoleEnum | null
    createdAt: Date | null
    updatedAt: Date | null
    youtubeUserId: number | null
    youtubeChannelId: number | null
  }

  export type YoutubeUserToChannelMaxAggregateOutputType = {
    id: number | null
    description: string | null
    role: RoleEnum | null
    createdAt: Date | null
    updatedAt: Date | null
    youtubeUserId: number | null
    youtubeChannelId: number | null
  }

  export type YoutubeUserToChannelCountAggregateOutputType = {
    id: number
    description: number
    role: number
    createdAt: number
    updatedAt: number
    youtubeUserId: number
    youtubeChannelId: number
    _all: number
  }


  export type YoutubeUserToChannelAvgAggregateInputType = {
    id?: true
    youtubeUserId?: true
    youtubeChannelId?: true
  }

  export type YoutubeUserToChannelSumAggregateInputType = {
    id?: true
    youtubeUserId?: true
    youtubeChannelId?: true
  }

  export type YoutubeUserToChannelMinAggregateInputType = {
    id?: true
    description?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    youtubeUserId?: true
    youtubeChannelId?: true
  }

  export type YoutubeUserToChannelMaxAggregateInputType = {
    id?: true
    description?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    youtubeUserId?: true
    youtubeChannelId?: true
  }

  export type YoutubeUserToChannelCountAggregateInputType = {
    id?: true
    description?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    youtubeUserId?: true
    youtubeChannelId?: true
    _all?: true
  }

  export type YoutubeUserToChannelAggregateArgs = {
    /**
     * Filter which YoutubeUserToChannel to aggregate.
     */
    where?: YoutubeUserToChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeUserToChannels to fetch.
     */
    orderBy?: Enumerable<YoutubeUserToChannelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YoutubeUserToChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeUserToChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeUserToChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YoutubeUserToChannels
    **/
    _count?: true | YoutubeUserToChannelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YoutubeUserToChannelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YoutubeUserToChannelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YoutubeUserToChannelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YoutubeUserToChannelMaxAggregateInputType
  }

  export type GetYoutubeUserToChannelAggregateType<T extends YoutubeUserToChannelAggregateArgs> = {
        [P in keyof T & keyof AggregateYoutubeUserToChannel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYoutubeUserToChannel[P]>
      : GetScalarType<T[P], AggregateYoutubeUserToChannel[P]>
  }




  export type YoutubeUserToChannelGroupByArgs = {
    where?: YoutubeUserToChannelWhereInput
    orderBy?: Enumerable<YoutubeUserToChannelOrderByWithAggregationInput>
    by: YoutubeUserToChannelScalarFieldEnum[]
    having?: YoutubeUserToChannelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YoutubeUserToChannelCountAggregateInputType | true
    _avg?: YoutubeUserToChannelAvgAggregateInputType
    _sum?: YoutubeUserToChannelSumAggregateInputType
    _min?: YoutubeUserToChannelMinAggregateInputType
    _max?: YoutubeUserToChannelMaxAggregateInputType
  }


  export type YoutubeUserToChannelGroupByOutputType = {
    id: number
    description: string
    role: RoleEnum
    createdAt: Date
    updatedAt: Date
    youtubeUserId: number
    youtubeChannelId: number
    _count: YoutubeUserToChannelCountAggregateOutputType | null
    _avg: YoutubeUserToChannelAvgAggregateOutputType | null
    _sum: YoutubeUserToChannelSumAggregateOutputType | null
    _min: YoutubeUserToChannelMinAggregateOutputType | null
    _max: YoutubeUserToChannelMaxAggregateOutputType | null
  }

  type GetYoutubeUserToChannelGroupByPayload<T extends YoutubeUserToChannelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<YoutubeUserToChannelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YoutubeUserToChannelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YoutubeUserToChannelGroupByOutputType[P]>
            : GetScalarType<T[P], YoutubeUserToChannelGroupByOutputType[P]>
        }
      >
    >


  export type YoutubeUserToChannelSelect = {
    id?: boolean
    user?: boolean | YoutubeUserArgs
    channel?: boolean | YoutubeChannelArgs
    description?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    youtubeUserId?: boolean
    youtubeChannelId?: boolean
  }


  export type YoutubeUserToChannelInclude = {
    user?: boolean | YoutubeUserArgs
    channel?: boolean | YoutubeChannelArgs
  }

  export type YoutubeUserToChannelGetPayload<S extends boolean | null | undefined | YoutubeUserToChannelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YoutubeUserToChannel :
    S extends undefined ? never :
    S extends { include: any } & (YoutubeUserToChannelArgs | YoutubeUserToChannelFindManyArgs)
    ? YoutubeUserToChannel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? YoutubeUserGetPayload<S['include'][P]> :
        P extends 'channel' ? YoutubeChannelGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (YoutubeUserToChannelArgs | YoutubeUserToChannelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? YoutubeUserGetPayload<S['select'][P]> :
        P extends 'channel' ? YoutubeChannelGetPayload<S['select'][P]> :  P extends keyof YoutubeUserToChannel ? YoutubeUserToChannel[P] : never
  } 
      : YoutubeUserToChannel


  type YoutubeUserToChannelCountArgs = 
    Omit<YoutubeUserToChannelFindManyArgs, 'select' | 'include'> & {
      select?: YoutubeUserToChannelCountAggregateInputType | true
    }

  export interface YoutubeUserToChannelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one YoutubeUserToChannel that matches the filter.
     * @param {YoutubeUserToChannelFindUniqueArgs} args - Arguments to find a YoutubeUserToChannel
     * @example
     * // Get one YoutubeUserToChannel
     * const youtubeUserToChannel = await prisma.youtubeUserToChannel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends YoutubeUserToChannelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, YoutubeUserToChannelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'YoutubeUserToChannel'> extends True ? Prisma__YoutubeUserToChannelClient<YoutubeUserToChannelGetPayload<T>> : Prisma__YoutubeUserToChannelClient<YoutubeUserToChannelGetPayload<T> | null, null>

    /**
     * Find one YoutubeUserToChannel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {YoutubeUserToChannelFindUniqueOrThrowArgs} args - Arguments to find a YoutubeUserToChannel
     * @example
     * // Get one YoutubeUserToChannel
     * const youtubeUserToChannel = await prisma.youtubeUserToChannel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends YoutubeUserToChannelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, YoutubeUserToChannelFindUniqueOrThrowArgs>
    ): Prisma__YoutubeUserToChannelClient<YoutubeUserToChannelGetPayload<T>>

    /**
     * Find the first YoutubeUserToChannel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeUserToChannelFindFirstArgs} args - Arguments to find a YoutubeUserToChannel
     * @example
     * // Get one YoutubeUserToChannel
     * const youtubeUserToChannel = await prisma.youtubeUserToChannel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends YoutubeUserToChannelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, YoutubeUserToChannelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'YoutubeUserToChannel'> extends True ? Prisma__YoutubeUserToChannelClient<YoutubeUserToChannelGetPayload<T>> : Prisma__YoutubeUserToChannelClient<YoutubeUserToChannelGetPayload<T> | null, null>

    /**
     * Find the first YoutubeUserToChannel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeUserToChannelFindFirstOrThrowArgs} args - Arguments to find a YoutubeUserToChannel
     * @example
     * // Get one YoutubeUserToChannel
     * const youtubeUserToChannel = await prisma.youtubeUserToChannel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends YoutubeUserToChannelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, YoutubeUserToChannelFindFirstOrThrowArgs>
    ): Prisma__YoutubeUserToChannelClient<YoutubeUserToChannelGetPayload<T>>

    /**
     * Find zero or more YoutubeUserToChannels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeUserToChannelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YoutubeUserToChannels
     * const youtubeUserToChannels = await prisma.youtubeUserToChannel.findMany()
     * 
     * // Get first 10 YoutubeUserToChannels
     * const youtubeUserToChannels = await prisma.youtubeUserToChannel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const youtubeUserToChannelWithIdOnly = await prisma.youtubeUserToChannel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends YoutubeUserToChannelFindManyArgs>(
      args?: SelectSubset<T, YoutubeUserToChannelFindManyArgs>
    ): Prisma.PrismaPromise<Array<YoutubeUserToChannelGetPayload<T>>>

    /**
     * Create a YoutubeUserToChannel.
     * @param {YoutubeUserToChannelCreateArgs} args - Arguments to create a YoutubeUserToChannel.
     * @example
     * // Create one YoutubeUserToChannel
     * const YoutubeUserToChannel = await prisma.youtubeUserToChannel.create({
     *   data: {
     *     // ... data to create a YoutubeUserToChannel
     *   }
     * })
     * 
    **/
    create<T extends YoutubeUserToChannelCreateArgs>(
      args: SelectSubset<T, YoutubeUserToChannelCreateArgs>
    ): Prisma__YoutubeUserToChannelClient<YoutubeUserToChannelGetPayload<T>>

    /**
     * Create many YoutubeUserToChannels.
     *     @param {YoutubeUserToChannelCreateManyArgs} args - Arguments to create many YoutubeUserToChannels.
     *     @example
     *     // Create many YoutubeUserToChannels
     *     const youtubeUserToChannel = await prisma.youtubeUserToChannel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends YoutubeUserToChannelCreateManyArgs>(
      args?: SelectSubset<T, YoutubeUserToChannelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a YoutubeUserToChannel.
     * @param {YoutubeUserToChannelDeleteArgs} args - Arguments to delete one YoutubeUserToChannel.
     * @example
     * // Delete one YoutubeUserToChannel
     * const YoutubeUserToChannel = await prisma.youtubeUserToChannel.delete({
     *   where: {
     *     // ... filter to delete one YoutubeUserToChannel
     *   }
     * })
     * 
    **/
    delete<T extends YoutubeUserToChannelDeleteArgs>(
      args: SelectSubset<T, YoutubeUserToChannelDeleteArgs>
    ): Prisma__YoutubeUserToChannelClient<YoutubeUserToChannelGetPayload<T>>

    /**
     * Update one YoutubeUserToChannel.
     * @param {YoutubeUserToChannelUpdateArgs} args - Arguments to update one YoutubeUserToChannel.
     * @example
     * // Update one YoutubeUserToChannel
     * const youtubeUserToChannel = await prisma.youtubeUserToChannel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends YoutubeUserToChannelUpdateArgs>(
      args: SelectSubset<T, YoutubeUserToChannelUpdateArgs>
    ): Prisma__YoutubeUserToChannelClient<YoutubeUserToChannelGetPayload<T>>

    /**
     * Delete zero or more YoutubeUserToChannels.
     * @param {YoutubeUserToChannelDeleteManyArgs} args - Arguments to filter YoutubeUserToChannels to delete.
     * @example
     * // Delete a few YoutubeUserToChannels
     * const { count } = await prisma.youtubeUserToChannel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends YoutubeUserToChannelDeleteManyArgs>(
      args?: SelectSubset<T, YoutubeUserToChannelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YoutubeUserToChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeUserToChannelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YoutubeUserToChannels
     * const youtubeUserToChannel = await prisma.youtubeUserToChannel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends YoutubeUserToChannelUpdateManyArgs>(
      args: SelectSubset<T, YoutubeUserToChannelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one YoutubeUserToChannel.
     * @param {YoutubeUserToChannelUpsertArgs} args - Arguments to update or create a YoutubeUserToChannel.
     * @example
     * // Update or create a YoutubeUserToChannel
     * const youtubeUserToChannel = await prisma.youtubeUserToChannel.upsert({
     *   create: {
     *     // ... data to create a YoutubeUserToChannel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YoutubeUserToChannel we want to update
     *   }
     * })
    **/
    upsert<T extends YoutubeUserToChannelUpsertArgs>(
      args: SelectSubset<T, YoutubeUserToChannelUpsertArgs>
    ): Prisma__YoutubeUserToChannelClient<YoutubeUserToChannelGetPayload<T>>

    /**
     * Count the number of YoutubeUserToChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeUserToChannelCountArgs} args - Arguments to filter YoutubeUserToChannels to count.
     * @example
     * // Count the number of YoutubeUserToChannels
     * const count = await prisma.youtubeUserToChannel.count({
     *   where: {
     *     // ... the filter for the YoutubeUserToChannels we want to count
     *   }
     * })
    **/
    count<T extends YoutubeUserToChannelCountArgs>(
      args?: Subset<T, YoutubeUserToChannelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YoutubeUserToChannelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YoutubeUserToChannel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeUserToChannelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YoutubeUserToChannelAggregateArgs>(args: Subset<T, YoutubeUserToChannelAggregateArgs>): Prisma.PrismaPromise<GetYoutubeUserToChannelAggregateType<T>>

    /**
     * Group by YoutubeUserToChannel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeUserToChannelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YoutubeUserToChannelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YoutubeUserToChannelGroupByArgs['orderBy'] }
        : { orderBy?: YoutubeUserToChannelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YoutubeUserToChannelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYoutubeUserToChannelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for YoutubeUserToChannel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__YoutubeUserToChannelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends YoutubeUserArgs= {}>(args?: Subset<T, YoutubeUserArgs>): Prisma__YoutubeUserClient<YoutubeUserGetPayload<T> | Null>;

    channel<T extends YoutubeChannelArgs= {}>(args?: Subset<T, YoutubeChannelArgs>): Prisma__YoutubeChannelClient<YoutubeChannelGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * YoutubeUserToChannel base type for findUnique actions
   */
  export type YoutubeUserToChannelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeUserToChannel
     */
    select?: YoutubeUserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserToChannelInclude | null
    /**
     * Filter, which YoutubeUserToChannel to fetch.
     */
    where: YoutubeUserToChannelWhereUniqueInput
  }

  /**
   * YoutubeUserToChannel findUnique
   */
  export interface YoutubeUserToChannelFindUniqueArgs extends YoutubeUserToChannelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeUserToChannel findUniqueOrThrow
   */
  export type YoutubeUserToChannelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUserToChannel
     */
    select?: YoutubeUserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserToChannelInclude | null
    /**
     * Filter, which YoutubeUserToChannel to fetch.
     */
    where: YoutubeUserToChannelWhereUniqueInput
  }


  /**
   * YoutubeUserToChannel base type for findFirst actions
   */
  export type YoutubeUserToChannelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeUserToChannel
     */
    select?: YoutubeUserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserToChannelInclude | null
    /**
     * Filter, which YoutubeUserToChannel to fetch.
     */
    where?: YoutubeUserToChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeUserToChannels to fetch.
     */
    orderBy?: Enumerable<YoutubeUserToChannelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeUserToChannels.
     */
    cursor?: YoutubeUserToChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeUserToChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeUserToChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeUserToChannels.
     */
    distinct?: Enumerable<YoutubeUserToChannelScalarFieldEnum>
  }

  /**
   * YoutubeUserToChannel findFirst
   */
  export interface YoutubeUserToChannelFindFirstArgs extends YoutubeUserToChannelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeUserToChannel findFirstOrThrow
   */
  export type YoutubeUserToChannelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUserToChannel
     */
    select?: YoutubeUserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserToChannelInclude | null
    /**
     * Filter, which YoutubeUserToChannel to fetch.
     */
    where?: YoutubeUserToChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeUserToChannels to fetch.
     */
    orderBy?: Enumerable<YoutubeUserToChannelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeUserToChannels.
     */
    cursor?: YoutubeUserToChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeUserToChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeUserToChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeUserToChannels.
     */
    distinct?: Enumerable<YoutubeUserToChannelScalarFieldEnum>
  }


  /**
   * YoutubeUserToChannel findMany
   */
  export type YoutubeUserToChannelFindManyArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUserToChannel
     */
    select?: YoutubeUserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserToChannelInclude | null
    /**
     * Filter, which YoutubeUserToChannels to fetch.
     */
    where?: YoutubeUserToChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeUserToChannels to fetch.
     */
    orderBy?: Enumerable<YoutubeUserToChannelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YoutubeUserToChannels.
     */
    cursor?: YoutubeUserToChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeUserToChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeUserToChannels.
     */
    skip?: number
    distinct?: Enumerable<YoutubeUserToChannelScalarFieldEnum>
  }


  /**
   * YoutubeUserToChannel create
   */
  export type YoutubeUserToChannelCreateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUserToChannel
     */
    select?: YoutubeUserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserToChannelInclude | null
    /**
     * The data needed to create a YoutubeUserToChannel.
     */
    data: XOR<YoutubeUserToChannelCreateInput, YoutubeUserToChannelUncheckedCreateInput>
  }


  /**
   * YoutubeUserToChannel createMany
   */
  export type YoutubeUserToChannelCreateManyArgs = {
    /**
     * The data used to create many YoutubeUserToChannels.
     */
    data: Enumerable<YoutubeUserToChannelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * YoutubeUserToChannel update
   */
  export type YoutubeUserToChannelUpdateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUserToChannel
     */
    select?: YoutubeUserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserToChannelInclude | null
    /**
     * The data needed to update a YoutubeUserToChannel.
     */
    data: XOR<YoutubeUserToChannelUpdateInput, YoutubeUserToChannelUncheckedUpdateInput>
    /**
     * Choose, which YoutubeUserToChannel to update.
     */
    where: YoutubeUserToChannelWhereUniqueInput
  }


  /**
   * YoutubeUserToChannel updateMany
   */
  export type YoutubeUserToChannelUpdateManyArgs = {
    /**
     * The data used to update YoutubeUserToChannels.
     */
    data: XOR<YoutubeUserToChannelUpdateManyMutationInput, YoutubeUserToChannelUncheckedUpdateManyInput>
    /**
     * Filter which YoutubeUserToChannels to update
     */
    where?: YoutubeUserToChannelWhereInput
  }


  /**
   * YoutubeUserToChannel upsert
   */
  export type YoutubeUserToChannelUpsertArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUserToChannel
     */
    select?: YoutubeUserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserToChannelInclude | null
    /**
     * The filter to search for the YoutubeUserToChannel to update in case it exists.
     */
    where: YoutubeUserToChannelWhereUniqueInput
    /**
     * In case the YoutubeUserToChannel found by the `where` argument doesn't exist, create a new YoutubeUserToChannel with this data.
     */
    create: XOR<YoutubeUserToChannelCreateInput, YoutubeUserToChannelUncheckedCreateInput>
    /**
     * In case the YoutubeUserToChannel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YoutubeUserToChannelUpdateInput, YoutubeUserToChannelUncheckedUpdateInput>
  }


  /**
   * YoutubeUserToChannel delete
   */
  export type YoutubeUserToChannelDeleteArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUserToChannel
     */
    select?: YoutubeUserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserToChannelInclude | null
    /**
     * Filter which YoutubeUserToChannel to delete.
     */
    where: YoutubeUserToChannelWhereUniqueInput
  }


  /**
   * YoutubeUserToChannel deleteMany
   */
  export type YoutubeUserToChannelDeleteManyArgs = {
    /**
     * Filter which YoutubeUserToChannels to delete
     */
    where?: YoutubeUserToChannelWhereInput
  }


  /**
   * YoutubeUserToChannel without action
   */
  export type YoutubeUserToChannelArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUserToChannel
     */
    select?: YoutubeUserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserToChannelInclude | null
  }



  /**
   * Model YoutubeVideo
   */


  export type AggregateYoutubeVideo = {
    _count: YoutubeVideoCountAggregateOutputType | null
    _avg: YoutubeVideoAvgAggregateOutputType | null
    _sum: YoutubeVideoSumAggregateOutputType | null
    _min: YoutubeVideoMinAggregateOutputType | null
    _max: YoutubeVideoMaxAggregateOutputType | null
  }

  export type YoutubeVideoAvgAggregateOutputType = {
    id: number | null
    youtubeChannelId: number | null
  }

  export type YoutubeVideoSumAggregateOutputType = {
    id: number | null
    youtubeChannelId: number | null
  }

  export type YoutubeVideoMinAggregateOutputType = {
    id: number | null
    name: string | null
    videoUrl: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    youtubeChannelId: number | null
  }

  export type YoutubeVideoMaxAggregateOutputType = {
    id: number | null
    name: string | null
    videoUrl: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    youtubeChannelId: number | null
  }

  export type YoutubeVideoCountAggregateOutputType = {
    id: number
    name: number
    videoUrl: number
    description: number
    createdAt: number
    updatedAt: number
    youtubeChannelId: number
    _all: number
  }


  export type YoutubeVideoAvgAggregateInputType = {
    id?: true
    youtubeChannelId?: true
  }

  export type YoutubeVideoSumAggregateInputType = {
    id?: true
    youtubeChannelId?: true
  }

  export type YoutubeVideoMinAggregateInputType = {
    id?: true
    name?: true
    videoUrl?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    youtubeChannelId?: true
  }

  export type YoutubeVideoMaxAggregateInputType = {
    id?: true
    name?: true
    videoUrl?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    youtubeChannelId?: true
  }

  export type YoutubeVideoCountAggregateInputType = {
    id?: true
    name?: true
    videoUrl?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    youtubeChannelId?: true
    _all?: true
  }

  export type YoutubeVideoAggregateArgs = {
    /**
     * Filter which YoutubeVideo to aggregate.
     */
    where?: YoutubeVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeVideos to fetch.
     */
    orderBy?: Enumerable<YoutubeVideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YoutubeVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YoutubeVideos
    **/
    _count?: true | YoutubeVideoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YoutubeVideoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YoutubeVideoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YoutubeVideoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YoutubeVideoMaxAggregateInputType
  }

  export type GetYoutubeVideoAggregateType<T extends YoutubeVideoAggregateArgs> = {
        [P in keyof T & keyof AggregateYoutubeVideo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYoutubeVideo[P]>
      : GetScalarType<T[P], AggregateYoutubeVideo[P]>
  }




  export type YoutubeVideoGroupByArgs = {
    where?: YoutubeVideoWhereInput
    orderBy?: Enumerable<YoutubeVideoOrderByWithAggregationInput>
    by: YoutubeVideoScalarFieldEnum[]
    having?: YoutubeVideoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YoutubeVideoCountAggregateInputType | true
    _avg?: YoutubeVideoAvgAggregateInputType
    _sum?: YoutubeVideoSumAggregateInputType
    _min?: YoutubeVideoMinAggregateInputType
    _max?: YoutubeVideoMaxAggregateInputType
  }


  export type YoutubeVideoGroupByOutputType = {
    id: number
    name: string
    videoUrl: string
    description: string
    createdAt: Date
    updatedAt: Date
    youtubeChannelId: number
    _count: YoutubeVideoCountAggregateOutputType | null
    _avg: YoutubeVideoAvgAggregateOutputType | null
    _sum: YoutubeVideoSumAggregateOutputType | null
    _min: YoutubeVideoMinAggregateOutputType | null
    _max: YoutubeVideoMaxAggregateOutputType | null
  }

  type GetYoutubeVideoGroupByPayload<T extends YoutubeVideoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<YoutubeVideoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YoutubeVideoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YoutubeVideoGroupByOutputType[P]>
            : GetScalarType<T[P], YoutubeVideoGroupByOutputType[P]>
        }
      >
    >


  export type YoutubeVideoSelect = {
    id?: boolean
    name?: boolean
    videoUrl?: boolean
    description?: boolean
    channel?: boolean | YoutubeChannelArgs
    createdAt?: boolean
    updatedAt?: boolean
    youtubeChannelId?: boolean
    youtubeComments?: boolean | YoutubeVideo$youtubeCommentsArgs
    youtubeReactions?: boolean | YoutubeVideo$youtubeReactionsArgs
    _count?: boolean | YoutubeVideoCountOutputTypeArgs
  }


  export type YoutubeVideoInclude = {
    channel?: boolean | YoutubeChannelArgs
    youtubeComments?: boolean | YoutubeVideo$youtubeCommentsArgs
    youtubeReactions?: boolean | YoutubeVideo$youtubeReactionsArgs
    _count?: boolean | YoutubeVideoCountOutputTypeArgs
  }

  export type YoutubeVideoGetPayload<S extends boolean | null | undefined | YoutubeVideoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YoutubeVideo :
    S extends undefined ? never :
    S extends { include: any } & (YoutubeVideoArgs | YoutubeVideoFindManyArgs)
    ? YoutubeVideo  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'channel' ? YoutubeChannelGetPayload<S['include'][P]> :
        P extends 'youtubeComments' ? Array < YoutubeCommentGetPayload<S['include'][P]>>  :
        P extends 'youtubeReactions' ? Array < YoutubeReactionGetPayload<S['include'][P]>>  :
        P extends '_count' ? YoutubeVideoCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (YoutubeVideoArgs | YoutubeVideoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'channel' ? YoutubeChannelGetPayload<S['select'][P]> :
        P extends 'youtubeComments' ? Array < YoutubeCommentGetPayload<S['select'][P]>>  :
        P extends 'youtubeReactions' ? Array < YoutubeReactionGetPayload<S['select'][P]>>  :
        P extends '_count' ? YoutubeVideoCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof YoutubeVideo ? YoutubeVideo[P] : never
  } 
      : YoutubeVideo


  type YoutubeVideoCountArgs = 
    Omit<YoutubeVideoFindManyArgs, 'select' | 'include'> & {
      select?: YoutubeVideoCountAggregateInputType | true
    }

  export interface YoutubeVideoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one YoutubeVideo that matches the filter.
     * @param {YoutubeVideoFindUniqueArgs} args - Arguments to find a YoutubeVideo
     * @example
     * // Get one YoutubeVideo
     * const youtubeVideo = await prisma.youtubeVideo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends YoutubeVideoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, YoutubeVideoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'YoutubeVideo'> extends True ? Prisma__YoutubeVideoClient<YoutubeVideoGetPayload<T>> : Prisma__YoutubeVideoClient<YoutubeVideoGetPayload<T> | null, null>

    /**
     * Find one YoutubeVideo that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {YoutubeVideoFindUniqueOrThrowArgs} args - Arguments to find a YoutubeVideo
     * @example
     * // Get one YoutubeVideo
     * const youtubeVideo = await prisma.youtubeVideo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends YoutubeVideoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, YoutubeVideoFindUniqueOrThrowArgs>
    ): Prisma__YoutubeVideoClient<YoutubeVideoGetPayload<T>>

    /**
     * Find the first YoutubeVideo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeVideoFindFirstArgs} args - Arguments to find a YoutubeVideo
     * @example
     * // Get one YoutubeVideo
     * const youtubeVideo = await prisma.youtubeVideo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends YoutubeVideoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, YoutubeVideoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'YoutubeVideo'> extends True ? Prisma__YoutubeVideoClient<YoutubeVideoGetPayload<T>> : Prisma__YoutubeVideoClient<YoutubeVideoGetPayload<T> | null, null>

    /**
     * Find the first YoutubeVideo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeVideoFindFirstOrThrowArgs} args - Arguments to find a YoutubeVideo
     * @example
     * // Get one YoutubeVideo
     * const youtubeVideo = await prisma.youtubeVideo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends YoutubeVideoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, YoutubeVideoFindFirstOrThrowArgs>
    ): Prisma__YoutubeVideoClient<YoutubeVideoGetPayload<T>>

    /**
     * Find zero or more YoutubeVideos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeVideoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YoutubeVideos
     * const youtubeVideos = await prisma.youtubeVideo.findMany()
     * 
     * // Get first 10 YoutubeVideos
     * const youtubeVideos = await prisma.youtubeVideo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const youtubeVideoWithIdOnly = await prisma.youtubeVideo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends YoutubeVideoFindManyArgs>(
      args?: SelectSubset<T, YoutubeVideoFindManyArgs>
    ): Prisma.PrismaPromise<Array<YoutubeVideoGetPayload<T>>>

    /**
     * Create a YoutubeVideo.
     * @param {YoutubeVideoCreateArgs} args - Arguments to create a YoutubeVideo.
     * @example
     * // Create one YoutubeVideo
     * const YoutubeVideo = await prisma.youtubeVideo.create({
     *   data: {
     *     // ... data to create a YoutubeVideo
     *   }
     * })
     * 
    **/
    create<T extends YoutubeVideoCreateArgs>(
      args: SelectSubset<T, YoutubeVideoCreateArgs>
    ): Prisma__YoutubeVideoClient<YoutubeVideoGetPayload<T>>

    /**
     * Create many YoutubeVideos.
     *     @param {YoutubeVideoCreateManyArgs} args - Arguments to create many YoutubeVideos.
     *     @example
     *     // Create many YoutubeVideos
     *     const youtubeVideo = await prisma.youtubeVideo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends YoutubeVideoCreateManyArgs>(
      args?: SelectSubset<T, YoutubeVideoCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a YoutubeVideo.
     * @param {YoutubeVideoDeleteArgs} args - Arguments to delete one YoutubeVideo.
     * @example
     * // Delete one YoutubeVideo
     * const YoutubeVideo = await prisma.youtubeVideo.delete({
     *   where: {
     *     // ... filter to delete one YoutubeVideo
     *   }
     * })
     * 
    **/
    delete<T extends YoutubeVideoDeleteArgs>(
      args: SelectSubset<T, YoutubeVideoDeleteArgs>
    ): Prisma__YoutubeVideoClient<YoutubeVideoGetPayload<T>>

    /**
     * Update one YoutubeVideo.
     * @param {YoutubeVideoUpdateArgs} args - Arguments to update one YoutubeVideo.
     * @example
     * // Update one YoutubeVideo
     * const youtubeVideo = await prisma.youtubeVideo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends YoutubeVideoUpdateArgs>(
      args: SelectSubset<T, YoutubeVideoUpdateArgs>
    ): Prisma__YoutubeVideoClient<YoutubeVideoGetPayload<T>>

    /**
     * Delete zero or more YoutubeVideos.
     * @param {YoutubeVideoDeleteManyArgs} args - Arguments to filter YoutubeVideos to delete.
     * @example
     * // Delete a few YoutubeVideos
     * const { count } = await prisma.youtubeVideo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends YoutubeVideoDeleteManyArgs>(
      args?: SelectSubset<T, YoutubeVideoDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YoutubeVideos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeVideoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YoutubeVideos
     * const youtubeVideo = await prisma.youtubeVideo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends YoutubeVideoUpdateManyArgs>(
      args: SelectSubset<T, YoutubeVideoUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one YoutubeVideo.
     * @param {YoutubeVideoUpsertArgs} args - Arguments to update or create a YoutubeVideo.
     * @example
     * // Update or create a YoutubeVideo
     * const youtubeVideo = await prisma.youtubeVideo.upsert({
     *   create: {
     *     // ... data to create a YoutubeVideo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YoutubeVideo we want to update
     *   }
     * })
    **/
    upsert<T extends YoutubeVideoUpsertArgs>(
      args: SelectSubset<T, YoutubeVideoUpsertArgs>
    ): Prisma__YoutubeVideoClient<YoutubeVideoGetPayload<T>>

    /**
     * Count the number of YoutubeVideos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeVideoCountArgs} args - Arguments to filter YoutubeVideos to count.
     * @example
     * // Count the number of YoutubeVideos
     * const count = await prisma.youtubeVideo.count({
     *   where: {
     *     // ... the filter for the YoutubeVideos we want to count
     *   }
     * })
    **/
    count<T extends YoutubeVideoCountArgs>(
      args?: Subset<T, YoutubeVideoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YoutubeVideoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YoutubeVideo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeVideoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YoutubeVideoAggregateArgs>(args: Subset<T, YoutubeVideoAggregateArgs>): Prisma.PrismaPromise<GetYoutubeVideoAggregateType<T>>

    /**
     * Group by YoutubeVideo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeVideoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YoutubeVideoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YoutubeVideoGroupByArgs['orderBy'] }
        : { orderBy?: YoutubeVideoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YoutubeVideoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYoutubeVideoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for YoutubeVideo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__YoutubeVideoClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    channel<T extends YoutubeChannelArgs= {}>(args?: Subset<T, YoutubeChannelArgs>): Prisma__YoutubeChannelClient<YoutubeChannelGetPayload<T> | Null>;

    youtubeComments<T extends YoutubeVideo$youtubeCommentsArgs= {}>(args?: Subset<T, YoutubeVideo$youtubeCommentsArgs>): Prisma.PrismaPromise<Array<YoutubeCommentGetPayload<T>>| Null>;

    youtubeReactions<T extends YoutubeVideo$youtubeReactionsArgs= {}>(args?: Subset<T, YoutubeVideo$youtubeReactionsArgs>): Prisma.PrismaPromise<Array<YoutubeReactionGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * YoutubeVideo base type for findUnique actions
   */
  export type YoutubeVideoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeVideo
     */
    select?: YoutubeVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeVideoInclude | null
    /**
     * Filter, which YoutubeVideo to fetch.
     */
    where: YoutubeVideoWhereUniqueInput
  }

  /**
   * YoutubeVideo findUnique
   */
  export interface YoutubeVideoFindUniqueArgs extends YoutubeVideoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeVideo findUniqueOrThrow
   */
  export type YoutubeVideoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeVideo
     */
    select?: YoutubeVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeVideoInclude | null
    /**
     * Filter, which YoutubeVideo to fetch.
     */
    where: YoutubeVideoWhereUniqueInput
  }


  /**
   * YoutubeVideo base type for findFirst actions
   */
  export type YoutubeVideoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeVideo
     */
    select?: YoutubeVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeVideoInclude | null
    /**
     * Filter, which YoutubeVideo to fetch.
     */
    where?: YoutubeVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeVideos to fetch.
     */
    orderBy?: Enumerable<YoutubeVideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeVideos.
     */
    cursor?: YoutubeVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeVideos.
     */
    distinct?: Enumerable<YoutubeVideoScalarFieldEnum>
  }

  /**
   * YoutubeVideo findFirst
   */
  export interface YoutubeVideoFindFirstArgs extends YoutubeVideoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeVideo findFirstOrThrow
   */
  export type YoutubeVideoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeVideo
     */
    select?: YoutubeVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeVideoInclude | null
    /**
     * Filter, which YoutubeVideo to fetch.
     */
    where?: YoutubeVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeVideos to fetch.
     */
    orderBy?: Enumerable<YoutubeVideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeVideos.
     */
    cursor?: YoutubeVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeVideos.
     */
    distinct?: Enumerable<YoutubeVideoScalarFieldEnum>
  }


  /**
   * YoutubeVideo findMany
   */
  export type YoutubeVideoFindManyArgs = {
    /**
     * Select specific fields to fetch from the YoutubeVideo
     */
    select?: YoutubeVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeVideoInclude | null
    /**
     * Filter, which YoutubeVideos to fetch.
     */
    where?: YoutubeVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeVideos to fetch.
     */
    orderBy?: Enumerable<YoutubeVideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YoutubeVideos.
     */
    cursor?: YoutubeVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeVideos.
     */
    skip?: number
    distinct?: Enumerable<YoutubeVideoScalarFieldEnum>
  }


  /**
   * YoutubeVideo create
   */
  export type YoutubeVideoCreateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeVideo
     */
    select?: YoutubeVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeVideoInclude | null
    /**
     * The data needed to create a YoutubeVideo.
     */
    data: XOR<YoutubeVideoCreateInput, YoutubeVideoUncheckedCreateInput>
  }


  /**
   * YoutubeVideo createMany
   */
  export type YoutubeVideoCreateManyArgs = {
    /**
     * The data used to create many YoutubeVideos.
     */
    data: Enumerable<YoutubeVideoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * YoutubeVideo update
   */
  export type YoutubeVideoUpdateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeVideo
     */
    select?: YoutubeVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeVideoInclude | null
    /**
     * The data needed to update a YoutubeVideo.
     */
    data: XOR<YoutubeVideoUpdateInput, YoutubeVideoUncheckedUpdateInput>
    /**
     * Choose, which YoutubeVideo to update.
     */
    where: YoutubeVideoWhereUniqueInput
  }


  /**
   * YoutubeVideo updateMany
   */
  export type YoutubeVideoUpdateManyArgs = {
    /**
     * The data used to update YoutubeVideos.
     */
    data: XOR<YoutubeVideoUpdateManyMutationInput, YoutubeVideoUncheckedUpdateManyInput>
    /**
     * Filter which YoutubeVideos to update
     */
    where?: YoutubeVideoWhereInput
  }


  /**
   * YoutubeVideo upsert
   */
  export type YoutubeVideoUpsertArgs = {
    /**
     * Select specific fields to fetch from the YoutubeVideo
     */
    select?: YoutubeVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeVideoInclude | null
    /**
     * The filter to search for the YoutubeVideo to update in case it exists.
     */
    where: YoutubeVideoWhereUniqueInput
    /**
     * In case the YoutubeVideo found by the `where` argument doesn't exist, create a new YoutubeVideo with this data.
     */
    create: XOR<YoutubeVideoCreateInput, YoutubeVideoUncheckedCreateInput>
    /**
     * In case the YoutubeVideo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YoutubeVideoUpdateInput, YoutubeVideoUncheckedUpdateInput>
  }


  /**
   * YoutubeVideo delete
   */
  export type YoutubeVideoDeleteArgs = {
    /**
     * Select specific fields to fetch from the YoutubeVideo
     */
    select?: YoutubeVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeVideoInclude | null
    /**
     * Filter which YoutubeVideo to delete.
     */
    where: YoutubeVideoWhereUniqueInput
  }


  /**
   * YoutubeVideo deleteMany
   */
  export type YoutubeVideoDeleteManyArgs = {
    /**
     * Filter which YoutubeVideos to delete
     */
    where?: YoutubeVideoWhereInput
  }


  /**
   * YoutubeVideo.youtubeComments
   */
  export type YoutubeVideo$youtubeCommentsArgs = {
    /**
     * Select specific fields to fetch from the YoutubeComment
     */
    select?: YoutubeCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentInclude | null
    where?: YoutubeCommentWhereInput
    orderBy?: Enumerable<YoutubeCommentOrderByWithRelationInput>
    cursor?: YoutubeCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YoutubeCommentScalarFieldEnum>
  }


  /**
   * YoutubeVideo.youtubeReactions
   */
  export type YoutubeVideo$youtubeReactionsArgs = {
    /**
     * Select specific fields to fetch from the YoutubeReaction
     */
    select?: YoutubeReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeReactionInclude | null
    where?: YoutubeReactionWhereInput
    orderBy?: Enumerable<YoutubeReactionOrderByWithRelationInput>
    cursor?: YoutubeReactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YoutubeReactionScalarFieldEnum>
  }


  /**
   * YoutubeVideo without action
   */
  export type YoutubeVideoArgs = {
    /**
     * Select specific fields to fetch from the YoutubeVideo
     */
    select?: YoutubeVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeVideoInclude | null
  }



  /**
   * Model YoutubeReaction
   */


  export type AggregateYoutubeReaction = {
    _count: YoutubeReactionCountAggregateOutputType | null
    _avg: YoutubeReactionAvgAggregateOutputType | null
    _sum: YoutubeReactionSumAggregateOutputType | null
    _min: YoutubeReactionMinAggregateOutputType | null
    _max: YoutubeReactionMaxAggregateOutputType | null
  }

  export type YoutubeReactionAvgAggregateOutputType = {
    id: number | null
    youtubeUserId: number | null
    youtubeChannelId: number | null
    youtubeVideoId: number | null
    youtubeCommentId: number | null
  }

  export type YoutubeReactionSumAggregateOutputType = {
    id: number | null
    youtubeUserId: number | null
    youtubeChannelId: number | null
    youtubeVideoId: number | null
    youtubeCommentId: number | null
  }

  export type YoutubeReactionMinAggregateOutputType = {
    id: number | null
    reaction: ReactionEnum | null
    createdAt: Date | null
    updatedAt: Date | null
    youtubeUserId: number | null
    youtubeChannelId: number | null
    youtubeVideoId: number | null
    youtubeCommentId: number | null
  }

  export type YoutubeReactionMaxAggregateOutputType = {
    id: number | null
    reaction: ReactionEnum | null
    createdAt: Date | null
    updatedAt: Date | null
    youtubeUserId: number | null
    youtubeChannelId: number | null
    youtubeVideoId: number | null
    youtubeCommentId: number | null
  }

  export type YoutubeReactionCountAggregateOutputType = {
    id: number
    reaction: number
    createdAt: number
    updatedAt: number
    youtubeUserId: number
    youtubeChannelId: number
    youtubeVideoId: number
    youtubeCommentId: number
    _all: number
  }


  export type YoutubeReactionAvgAggregateInputType = {
    id?: true
    youtubeUserId?: true
    youtubeChannelId?: true
    youtubeVideoId?: true
    youtubeCommentId?: true
  }

  export type YoutubeReactionSumAggregateInputType = {
    id?: true
    youtubeUserId?: true
    youtubeChannelId?: true
    youtubeVideoId?: true
    youtubeCommentId?: true
  }

  export type YoutubeReactionMinAggregateInputType = {
    id?: true
    reaction?: true
    createdAt?: true
    updatedAt?: true
    youtubeUserId?: true
    youtubeChannelId?: true
    youtubeVideoId?: true
    youtubeCommentId?: true
  }

  export type YoutubeReactionMaxAggregateInputType = {
    id?: true
    reaction?: true
    createdAt?: true
    updatedAt?: true
    youtubeUserId?: true
    youtubeChannelId?: true
    youtubeVideoId?: true
    youtubeCommentId?: true
  }

  export type YoutubeReactionCountAggregateInputType = {
    id?: true
    reaction?: true
    createdAt?: true
    updatedAt?: true
    youtubeUserId?: true
    youtubeChannelId?: true
    youtubeVideoId?: true
    youtubeCommentId?: true
    _all?: true
  }

  export type YoutubeReactionAggregateArgs = {
    /**
     * Filter which YoutubeReaction to aggregate.
     */
    where?: YoutubeReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeReactions to fetch.
     */
    orderBy?: Enumerable<YoutubeReactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YoutubeReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YoutubeReactions
    **/
    _count?: true | YoutubeReactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YoutubeReactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YoutubeReactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YoutubeReactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YoutubeReactionMaxAggregateInputType
  }

  export type GetYoutubeReactionAggregateType<T extends YoutubeReactionAggregateArgs> = {
        [P in keyof T & keyof AggregateYoutubeReaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYoutubeReaction[P]>
      : GetScalarType<T[P], AggregateYoutubeReaction[P]>
  }




  export type YoutubeReactionGroupByArgs = {
    where?: YoutubeReactionWhereInput
    orderBy?: Enumerable<YoutubeReactionOrderByWithAggregationInput>
    by: YoutubeReactionScalarFieldEnum[]
    having?: YoutubeReactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YoutubeReactionCountAggregateInputType | true
    _avg?: YoutubeReactionAvgAggregateInputType
    _sum?: YoutubeReactionSumAggregateInputType
    _min?: YoutubeReactionMinAggregateInputType
    _max?: YoutubeReactionMaxAggregateInputType
  }


  export type YoutubeReactionGroupByOutputType = {
    id: number
    reaction: ReactionEnum
    createdAt: Date
    updatedAt: Date
    youtubeUserId: number
    youtubeChannelId: number
    youtubeVideoId: number
    youtubeCommentId: number
    _count: YoutubeReactionCountAggregateOutputType | null
    _avg: YoutubeReactionAvgAggregateOutputType | null
    _sum: YoutubeReactionSumAggregateOutputType | null
    _min: YoutubeReactionMinAggregateOutputType | null
    _max: YoutubeReactionMaxAggregateOutputType | null
  }

  type GetYoutubeReactionGroupByPayload<T extends YoutubeReactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<YoutubeReactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YoutubeReactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YoutubeReactionGroupByOutputType[P]>
            : GetScalarType<T[P], YoutubeReactionGroupByOutputType[P]>
        }
      >
    >


  export type YoutubeReactionSelect = {
    id?: boolean
    user?: boolean | YoutubeUserArgs
    video?: boolean | YoutubeVideoArgs
    reaction?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    youtubeUserId?: boolean
    youtubeChannelId?: boolean
    youtubeVideoId?: boolean
    youtubeCommentId?: boolean
  }


  export type YoutubeReactionInclude = {
    user?: boolean | YoutubeUserArgs
    video?: boolean | YoutubeVideoArgs
  }

  export type YoutubeReactionGetPayload<S extends boolean | null | undefined | YoutubeReactionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YoutubeReaction :
    S extends undefined ? never :
    S extends { include: any } & (YoutubeReactionArgs | YoutubeReactionFindManyArgs)
    ? YoutubeReaction  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? YoutubeUserGetPayload<S['include'][P]> :
        P extends 'video' ? YoutubeVideoGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (YoutubeReactionArgs | YoutubeReactionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? YoutubeUserGetPayload<S['select'][P]> :
        P extends 'video' ? YoutubeVideoGetPayload<S['select'][P]> :  P extends keyof YoutubeReaction ? YoutubeReaction[P] : never
  } 
      : YoutubeReaction


  type YoutubeReactionCountArgs = 
    Omit<YoutubeReactionFindManyArgs, 'select' | 'include'> & {
      select?: YoutubeReactionCountAggregateInputType | true
    }

  export interface YoutubeReactionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one YoutubeReaction that matches the filter.
     * @param {YoutubeReactionFindUniqueArgs} args - Arguments to find a YoutubeReaction
     * @example
     * // Get one YoutubeReaction
     * const youtubeReaction = await prisma.youtubeReaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends YoutubeReactionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, YoutubeReactionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'YoutubeReaction'> extends True ? Prisma__YoutubeReactionClient<YoutubeReactionGetPayload<T>> : Prisma__YoutubeReactionClient<YoutubeReactionGetPayload<T> | null, null>

    /**
     * Find one YoutubeReaction that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {YoutubeReactionFindUniqueOrThrowArgs} args - Arguments to find a YoutubeReaction
     * @example
     * // Get one YoutubeReaction
     * const youtubeReaction = await prisma.youtubeReaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends YoutubeReactionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, YoutubeReactionFindUniqueOrThrowArgs>
    ): Prisma__YoutubeReactionClient<YoutubeReactionGetPayload<T>>

    /**
     * Find the first YoutubeReaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeReactionFindFirstArgs} args - Arguments to find a YoutubeReaction
     * @example
     * // Get one YoutubeReaction
     * const youtubeReaction = await prisma.youtubeReaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends YoutubeReactionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, YoutubeReactionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'YoutubeReaction'> extends True ? Prisma__YoutubeReactionClient<YoutubeReactionGetPayload<T>> : Prisma__YoutubeReactionClient<YoutubeReactionGetPayload<T> | null, null>

    /**
     * Find the first YoutubeReaction that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeReactionFindFirstOrThrowArgs} args - Arguments to find a YoutubeReaction
     * @example
     * // Get one YoutubeReaction
     * const youtubeReaction = await prisma.youtubeReaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends YoutubeReactionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, YoutubeReactionFindFirstOrThrowArgs>
    ): Prisma__YoutubeReactionClient<YoutubeReactionGetPayload<T>>

    /**
     * Find zero or more YoutubeReactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeReactionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YoutubeReactions
     * const youtubeReactions = await prisma.youtubeReaction.findMany()
     * 
     * // Get first 10 YoutubeReactions
     * const youtubeReactions = await prisma.youtubeReaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const youtubeReactionWithIdOnly = await prisma.youtubeReaction.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends YoutubeReactionFindManyArgs>(
      args?: SelectSubset<T, YoutubeReactionFindManyArgs>
    ): Prisma.PrismaPromise<Array<YoutubeReactionGetPayload<T>>>

    /**
     * Create a YoutubeReaction.
     * @param {YoutubeReactionCreateArgs} args - Arguments to create a YoutubeReaction.
     * @example
     * // Create one YoutubeReaction
     * const YoutubeReaction = await prisma.youtubeReaction.create({
     *   data: {
     *     // ... data to create a YoutubeReaction
     *   }
     * })
     * 
    **/
    create<T extends YoutubeReactionCreateArgs>(
      args: SelectSubset<T, YoutubeReactionCreateArgs>
    ): Prisma__YoutubeReactionClient<YoutubeReactionGetPayload<T>>

    /**
     * Create many YoutubeReactions.
     *     @param {YoutubeReactionCreateManyArgs} args - Arguments to create many YoutubeReactions.
     *     @example
     *     // Create many YoutubeReactions
     *     const youtubeReaction = await prisma.youtubeReaction.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends YoutubeReactionCreateManyArgs>(
      args?: SelectSubset<T, YoutubeReactionCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a YoutubeReaction.
     * @param {YoutubeReactionDeleteArgs} args - Arguments to delete one YoutubeReaction.
     * @example
     * // Delete one YoutubeReaction
     * const YoutubeReaction = await prisma.youtubeReaction.delete({
     *   where: {
     *     // ... filter to delete one YoutubeReaction
     *   }
     * })
     * 
    **/
    delete<T extends YoutubeReactionDeleteArgs>(
      args: SelectSubset<T, YoutubeReactionDeleteArgs>
    ): Prisma__YoutubeReactionClient<YoutubeReactionGetPayload<T>>

    /**
     * Update one YoutubeReaction.
     * @param {YoutubeReactionUpdateArgs} args - Arguments to update one YoutubeReaction.
     * @example
     * // Update one YoutubeReaction
     * const youtubeReaction = await prisma.youtubeReaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends YoutubeReactionUpdateArgs>(
      args: SelectSubset<T, YoutubeReactionUpdateArgs>
    ): Prisma__YoutubeReactionClient<YoutubeReactionGetPayload<T>>

    /**
     * Delete zero or more YoutubeReactions.
     * @param {YoutubeReactionDeleteManyArgs} args - Arguments to filter YoutubeReactions to delete.
     * @example
     * // Delete a few YoutubeReactions
     * const { count } = await prisma.youtubeReaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends YoutubeReactionDeleteManyArgs>(
      args?: SelectSubset<T, YoutubeReactionDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YoutubeReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeReactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YoutubeReactions
     * const youtubeReaction = await prisma.youtubeReaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends YoutubeReactionUpdateManyArgs>(
      args: SelectSubset<T, YoutubeReactionUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one YoutubeReaction.
     * @param {YoutubeReactionUpsertArgs} args - Arguments to update or create a YoutubeReaction.
     * @example
     * // Update or create a YoutubeReaction
     * const youtubeReaction = await prisma.youtubeReaction.upsert({
     *   create: {
     *     // ... data to create a YoutubeReaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YoutubeReaction we want to update
     *   }
     * })
    **/
    upsert<T extends YoutubeReactionUpsertArgs>(
      args: SelectSubset<T, YoutubeReactionUpsertArgs>
    ): Prisma__YoutubeReactionClient<YoutubeReactionGetPayload<T>>

    /**
     * Count the number of YoutubeReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeReactionCountArgs} args - Arguments to filter YoutubeReactions to count.
     * @example
     * // Count the number of YoutubeReactions
     * const count = await prisma.youtubeReaction.count({
     *   where: {
     *     // ... the filter for the YoutubeReactions we want to count
     *   }
     * })
    **/
    count<T extends YoutubeReactionCountArgs>(
      args?: Subset<T, YoutubeReactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YoutubeReactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YoutubeReaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeReactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YoutubeReactionAggregateArgs>(args: Subset<T, YoutubeReactionAggregateArgs>): Prisma.PrismaPromise<GetYoutubeReactionAggregateType<T>>

    /**
     * Group by YoutubeReaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeReactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YoutubeReactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YoutubeReactionGroupByArgs['orderBy'] }
        : { orderBy?: YoutubeReactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YoutubeReactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYoutubeReactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for YoutubeReaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__YoutubeReactionClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends YoutubeUserArgs= {}>(args?: Subset<T, YoutubeUserArgs>): Prisma__YoutubeUserClient<YoutubeUserGetPayload<T> | Null>;

    video<T extends YoutubeVideoArgs= {}>(args?: Subset<T, YoutubeVideoArgs>): Prisma__YoutubeVideoClient<YoutubeVideoGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * YoutubeReaction base type for findUnique actions
   */
  export type YoutubeReactionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeReaction
     */
    select?: YoutubeReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeReactionInclude | null
    /**
     * Filter, which YoutubeReaction to fetch.
     */
    where: YoutubeReactionWhereUniqueInput
  }

  /**
   * YoutubeReaction findUnique
   */
  export interface YoutubeReactionFindUniqueArgs extends YoutubeReactionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeReaction findUniqueOrThrow
   */
  export type YoutubeReactionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeReaction
     */
    select?: YoutubeReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeReactionInclude | null
    /**
     * Filter, which YoutubeReaction to fetch.
     */
    where: YoutubeReactionWhereUniqueInput
  }


  /**
   * YoutubeReaction base type for findFirst actions
   */
  export type YoutubeReactionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeReaction
     */
    select?: YoutubeReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeReactionInclude | null
    /**
     * Filter, which YoutubeReaction to fetch.
     */
    where?: YoutubeReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeReactions to fetch.
     */
    orderBy?: Enumerable<YoutubeReactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeReactions.
     */
    cursor?: YoutubeReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeReactions.
     */
    distinct?: Enumerable<YoutubeReactionScalarFieldEnum>
  }

  /**
   * YoutubeReaction findFirst
   */
  export interface YoutubeReactionFindFirstArgs extends YoutubeReactionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeReaction findFirstOrThrow
   */
  export type YoutubeReactionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeReaction
     */
    select?: YoutubeReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeReactionInclude | null
    /**
     * Filter, which YoutubeReaction to fetch.
     */
    where?: YoutubeReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeReactions to fetch.
     */
    orderBy?: Enumerable<YoutubeReactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeReactions.
     */
    cursor?: YoutubeReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeReactions.
     */
    distinct?: Enumerable<YoutubeReactionScalarFieldEnum>
  }


  /**
   * YoutubeReaction findMany
   */
  export type YoutubeReactionFindManyArgs = {
    /**
     * Select specific fields to fetch from the YoutubeReaction
     */
    select?: YoutubeReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeReactionInclude | null
    /**
     * Filter, which YoutubeReactions to fetch.
     */
    where?: YoutubeReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeReactions to fetch.
     */
    orderBy?: Enumerable<YoutubeReactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YoutubeReactions.
     */
    cursor?: YoutubeReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeReactions.
     */
    skip?: number
    distinct?: Enumerable<YoutubeReactionScalarFieldEnum>
  }


  /**
   * YoutubeReaction create
   */
  export type YoutubeReactionCreateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeReaction
     */
    select?: YoutubeReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeReactionInclude | null
    /**
     * The data needed to create a YoutubeReaction.
     */
    data: XOR<YoutubeReactionCreateInput, YoutubeReactionUncheckedCreateInput>
  }


  /**
   * YoutubeReaction createMany
   */
  export type YoutubeReactionCreateManyArgs = {
    /**
     * The data used to create many YoutubeReactions.
     */
    data: Enumerable<YoutubeReactionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * YoutubeReaction update
   */
  export type YoutubeReactionUpdateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeReaction
     */
    select?: YoutubeReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeReactionInclude | null
    /**
     * The data needed to update a YoutubeReaction.
     */
    data: XOR<YoutubeReactionUpdateInput, YoutubeReactionUncheckedUpdateInput>
    /**
     * Choose, which YoutubeReaction to update.
     */
    where: YoutubeReactionWhereUniqueInput
  }


  /**
   * YoutubeReaction updateMany
   */
  export type YoutubeReactionUpdateManyArgs = {
    /**
     * The data used to update YoutubeReactions.
     */
    data: XOR<YoutubeReactionUpdateManyMutationInput, YoutubeReactionUncheckedUpdateManyInput>
    /**
     * Filter which YoutubeReactions to update
     */
    where?: YoutubeReactionWhereInput
  }


  /**
   * YoutubeReaction upsert
   */
  export type YoutubeReactionUpsertArgs = {
    /**
     * Select specific fields to fetch from the YoutubeReaction
     */
    select?: YoutubeReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeReactionInclude | null
    /**
     * The filter to search for the YoutubeReaction to update in case it exists.
     */
    where: YoutubeReactionWhereUniqueInput
    /**
     * In case the YoutubeReaction found by the `where` argument doesn't exist, create a new YoutubeReaction with this data.
     */
    create: XOR<YoutubeReactionCreateInput, YoutubeReactionUncheckedCreateInput>
    /**
     * In case the YoutubeReaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YoutubeReactionUpdateInput, YoutubeReactionUncheckedUpdateInput>
  }


  /**
   * YoutubeReaction delete
   */
  export type YoutubeReactionDeleteArgs = {
    /**
     * Select specific fields to fetch from the YoutubeReaction
     */
    select?: YoutubeReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeReactionInclude | null
    /**
     * Filter which YoutubeReaction to delete.
     */
    where: YoutubeReactionWhereUniqueInput
  }


  /**
   * YoutubeReaction deleteMany
   */
  export type YoutubeReactionDeleteManyArgs = {
    /**
     * Filter which YoutubeReactions to delete
     */
    where?: YoutubeReactionWhereInput
  }


  /**
   * YoutubeReaction without action
   */
  export type YoutubeReactionArgs = {
    /**
     * Select specific fields to fetch from the YoutubeReaction
     */
    select?: YoutubeReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeReactionInclude | null
  }



  /**
   * Model YoutubeComment
   */


  export type AggregateYoutubeComment = {
    _count: YoutubeCommentCountAggregateOutputType | null
    _avg: YoutubeCommentAvgAggregateOutputType | null
    _sum: YoutubeCommentSumAggregateOutputType | null
    _min: YoutubeCommentMinAggregateOutputType | null
    _max: YoutubeCommentMaxAggregateOutputType | null
  }

  export type YoutubeCommentAvgAggregateOutputType = {
    id: number | null
    youtubeVideoId: number | null
    youtubeUserId: number | null
  }

  export type YoutubeCommentSumAggregateOutputType = {
    id: number | null
    youtubeVideoId: number | null
    youtubeUserId: number | null
  }

  export type YoutubeCommentMinAggregateOutputType = {
    id: number | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
    youtubeVideoId: number | null
    youtubeUserId: number | null
  }

  export type YoutubeCommentMaxAggregateOutputType = {
    id: number | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
    youtubeVideoId: number | null
    youtubeUserId: number | null
  }

  export type YoutubeCommentCountAggregateOutputType = {
    id: number
    comment: number
    createdAt: number
    updatedAt: number
    youtubeVideoId: number
    youtubeUserId: number
    _all: number
  }


  export type YoutubeCommentAvgAggregateInputType = {
    id?: true
    youtubeVideoId?: true
    youtubeUserId?: true
  }

  export type YoutubeCommentSumAggregateInputType = {
    id?: true
    youtubeVideoId?: true
    youtubeUserId?: true
  }

  export type YoutubeCommentMinAggregateInputType = {
    id?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
    youtubeVideoId?: true
    youtubeUserId?: true
  }

  export type YoutubeCommentMaxAggregateInputType = {
    id?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
    youtubeVideoId?: true
    youtubeUserId?: true
  }

  export type YoutubeCommentCountAggregateInputType = {
    id?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
    youtubeVideoId?: true
    youtubeUserId?: true
    _all?: true
  }

  export type YoutubeCommentAggregateArgs = {
    /**
     * Filter which YoutubeComment to aggregate.
     */
    where?: YoutubeCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeComments to fetch.
     */
    orderBy?: Enumerable<YoutubeCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YoutubeCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YoutubeComments
    **/
    _count?: true | YoutubeCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YoutubeCommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YoutubeCommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YoutubeCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YoutubeCommentMaxAggregateInputType
  }

  export type GetYoutubeCommentAggregateType<T extends YoutubeCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateYoutubeComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYoutubeComment[P]>
      : GetScalarType<T[P], AggregateYoutubeComment[P]>
  }




  export type YoutubeCommentGroupByArgs = {
    where?: YoutubeCommentWhereInput
    orderBy?: Enumerable<YoutubeCommentOrderByWithAggregationInput>
    by: YoutubeCommentScalarFieldEnum[]
    having?: YoutubeCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YoutubeCommentCountAggregateInputType | true
    _avg?: YoutubeCommentAvgAggregateInputType
    _sum?: YoutubeCommentSumAggregateInputType
    _min?: YoutubeCommentMinAggregateInputType
    _max?: YoutubeCommentMaxAggregateInputType
  }


  export type YoutubeCommentGroupByOutputType = {
    id: number
    comment: string
    createdAt: Date
    updatedAt: Date
    youtubeVideoId: number
    youtubeUserId: number
    _count: YoutubeCommentCountAggregateOutputType | null
    _avg: YoutubeCommentAvgAggregateOutputType | null
    _sum: YoutubeCommentSumAggregateOutputType | null
    _min: YoutubeCommentMinAggregateOutputType | null
    _max: YoutubeCommentMaxAggregateOutputType | null
  }

  type GetYoutubeCommentGroupByPayload<T extends YoutubeCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<YoutubeCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YoutubeCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YoutubeCommentGroupByOutputType[P]>
            : GetScalarType<T[P], YoutubeCommentGroupByOutputType[P]>
        }
      >
    >


  export type YoutubeCommentSelect = {
    id?: boolean
    comment?: boolean
    user?: boolean | YoutubeUserArgs
    video?: boolean | YoutubeVideoArgs
    createdAt?: boolean
    updatedAt?: boolean
    youtubeVideoId?: boolean
    youtubeUserId?: boolean
    youtubeCommentReactions?: boolean | YoutubeComment$youtubeCommentReactionsArgs
    _count?: boolean | YoutubeCommentCountOutputTypeArgs
  }


  export type YoutubeCommentInclude = {
    user?: boolean | YoutubeUserArgs
    video?: boolean | YoutubeVideoArgs
    youtubeCommentReactions?: boolean | YoutubeComment$youtubeCommentReactionsArgs
    _count?: boolean | YoutubeCommentCountOutputTypeArgs
  }

  export type YoutubeCommentGetPayload<S extends boolean | null | undefined | YoutubeCommentArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YoutubeComment :
    S extends undefined ? never :
    S extends { include: any } & (YoutubeCommentArgs | YoutubeCommentFindManyArgs)
    ? YoutubeComment  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? YoutubeUserGetPayload<S['include'][P]> :
        P extends 'video' ? YoutubeVideoGetPayload<S['include'][P]> :
        P extends 'youtubeCommentReactions' ? Array < YoutubeCommentReactionGetPayload<S['include'][P]>>  :
        P extends '_count' ? YoutubeCommentCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (YoutubeCommentArgs | YoutubeCommentFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? YoutubeUserGetPayload<S['select'][P]> :
        P extends 'video' ? YoutubeVideoGetPayload<S['select'][P]> :
        P extends 'youtubeCommentReactions' ? Array < YoutubeCommentReactionGetPayload<S['select'][P]>>  :
        P extends '_count' ? YoutubeCommentCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof YoutubeComment ? YoutubeComment[P] : never
  } 
      : YoutubeComment


  type YoutubeCommentCountArgs = 
    Omit<YoutubeCommentFindManyArgs, 'select' | 'include'> & {
      select?: YoutubeCommentCountAggregateInputType | true
    }

  export interface YoutubeCommentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one YoutubeComment that matches the filter.
     * @param {YoutubeCommentFindUniqueArgs} args - Arguments to find a YoutubeComment
     * @example
     * // Get one YoutubeComment
     * const youtubeComment = await prisma.youtubeComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends YoutubeCommentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, YoutubeCommentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'YoutubeComment'> extends True ? Prisma__YoutubeCommentClient<YoutubeCommentGetPayload<T>> : Prisma__YoutubeCommentClient<YoutubeCommentGetPayload<T> | null, null>

    /**
     * Find one YoutubeComment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {YoutubeCommentFindUniqueOrThrowArgs} args - Arguments to find a YoutubeComment
     * @example
     * // Get one YoutubeComment
     * const youtubeComment = await prisma.youtubeComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends YoutubeCommentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, YoutubeCommentFindUniqueOrThrowArgs>
    ): Prisma__YoutubeCommentClient<YoutubeCommentGetPayload<T>>

    /**
     * Find the first YoutubeComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeCommentFindFirstArgs} args - Arguments to find a YoutubeComment
     * @example
     * // Get one YoutubeComment
     * const youtubeComment = await prisma.youtubeComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends YoutubeCommentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, YoutubeCommentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'YoutubeComment'> extends True ? Prisma__YoutubeCommentClient<YoutubeCommentGetPayload<T>> : Prisma__YoutubeCommentClient<YoutubeCommentGetPayload<T> | null, null>

    /**
     * Find the first YoutubeComment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeCommentFindFirstOrThrowArgs} args - Arguments to find a YoutubeComment
     * @example
     * // Get one YoutubeComment
     * const youtubeComment = await prisma.youtubeComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends YoutubeCommentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, YoutubeCommentFindFirstOrThrowArgs>
    ): Prisma__YoutubeCommentClient<YoutubeCommentGetPayload<T>>

    /**
     * Find zero or more YoutubeComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeCommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YoutubeComments
     * const youtubeComments = await prisma.youtubeComment.findMany()
     * 
     * // Get first 10 YoutubeComments
     * const youtubeComments = await prisma.youtubeComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const youtubeCommentWithIdOnly = await prisma.youtubeComment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends YoutubeCommentFindManyArgs>(
      args?: SelectSubset<T, YoutubeCommentFindManyArgs>
    ): Prisma.PrismaPromise<Array<YoutubeCommentGetPayload<T>>>

    /**
     * Create a YoutubeComment.
     * @param {YoutubeCommentCreateArgs} args - Arguments to create a YoutubeComment.
     * @example
     * // Create one YoutubeComment
     * const YoutubeComment = await prisma.youtubeComment.create({
     *   data: {
     *     // ... data to create a YoutubeComment
     *   }
     * })
     * 
    **/
    create<T extends YoutubeCommentCreateArgs>(
      args: SelectSubset<T, YoutubeCommentCreateArgs>
    ): Prisma__YoutubeCommentClient<YoutubeCommentGetPayload<T>>

    /**
     * Create many YoutubeComments.
     *     @param {YoutubeCommentCreateManyArgs} args - Arguments to create many YoutubeComments.
     *     @example
     *     // Create many YoutubeComments
     *     const youtubeComment = await prisma.youtubeComment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends YoutubeCommentCreateManyArgs>(
      args?: SelectSubset<T, YoutubeCommentCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a YoutubeComment.
     * @param {YoutubeCommentDeleteArgs} args - Arguments to delete one YoutubeComment.
     * @example
     * // Delete one YoutubeComment
     * const YoutubeComment = await prisma.youtubeComment.delete({
     *   where: {
     *     // ... filter to delete one YoutubeComment
     *   }
     * })
     * 
    **/
    delete<T extends YoutubeCommentDeleteArgs>(
      args: SelectSubset<T, YoutubeCommentDeleteArgs>
    ): Prisma__YoutubeCommentClient<YoutubeCommentGetPayload<T>>

    /**
     * Update one YoutubeComment.
     * @param {YoutubeCommentUpdateArgs} args - Arguments to update one YoutubeComment.
     * @example
     * // Update one YoutubeComment
     * const youtubeComment = await prisma.youtubeComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends YoutubeCommentUpdateArgs>(
      args: SelectSubset<T, YoutubeCommentUpdateArgs>
    ): Prisma__YoutubeCommentClient<YoutubeCommentGetPayload<T>>

    /**
     * Delete zero or more YoutubeComments.
     * @param {YoutubeCommentDeleteManyArgs} args - Arguments to filter YoutubeComments to delete.
     * @example
     * // Delete a few YoutubeComments
     * const { count } = await prisma.youtubeComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends YoutubeCommentDeleteManyArgs>(
      args?: SelectSubset<T, YoutubeCommentDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YoutubeComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YoutubeComments
     * const youtubeComment = await prisma.youtubeComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends YoutubeCommentUpdateManyArgs>(
      args: SelectSubset<T, YoutubeCommentUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one YoutubeComment.
     * @param {YoutubeCommentUpsertArgs} args - Arguments to update or create a YoutubeComment.
     * @example
     * // Update or create a YoutubeComment
     * const youtubeComment = await prisma.youtubeComment.upsert({
     *   create: {
     *     // ... data to create a YoutubeComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YoutubeComment we want to update
     *   }
     * })
    **/
    upsert<T extends YoutubeCommentUpsertArgs>(
      args: SelectSubset<T, YoutubeCommentUpsertArgs>
    ): Prisma__YoutubeCommentClient<YoutubeCommentGetPayload<T>>

    /**
     * Count the number of YoutubeComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeCommentCountArgs} args - Arguments to filter YoutubeComments to count.
     * @example
     * // Count the number of YoutubeComments
     * const count = await prisma.youtubeComment.count({
     *   where: {
     *     // ... the filter for the YoutubeComments we want to count
     *   }
     * })
    **/
    count<T extends YoutubeCommentCountArgs>(
      args?: Subset<T, YoutubeCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YoutubeCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YoutubeComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YoutubeCommentAggregateArgs>(args: Subset<T, YoutubeCommentAggregateArgs>): Prisma.PrismaPromise<GetYoutubeCommentAggregateType<T>>

    /**
     * Group by YoutubeComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YoutubeCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YoutubeCommentGroupByArgs['orderBy'] }
        : { orderBy?: YoutubeCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YoutubeCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYoutubeCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for YoutubeComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__YoutubeCommentClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends YoutubeUserArgs= {}>(args?: Subset<T, YoutubeUserArgs>): Prisma__YoutubeUserClient<YoutubeUserGetPayload<T> | Null>;

    video<T extends YoutubeVideoArgs= {}>(args?: Subset<T, YoutubeVideoArgs>): Prisma__YoutubeVideoClient<YoutubeVideoGetPayload<T> | Null>;

    youtubeCommentReactions<T extends YoutubeComment$youtubeCommentReactionsArgs= {}>(args?: Subset<T, YoutubeComment$youtubeCommentReactionsArgs>): Prisma.PrismaPromise<Array<YoutubeCommentReactionGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * YoutubeComment base type for findUnique actions
   */
  export type YoutubeCommentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeComment
     */
    select?: YoutubeCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentInclude | null
    /**
     * Filter, which YoutubeComment to fetch.
     */
    where: YoutubeCommentWhereUniqueInput
  }

  /**
   * YoutubeComment findUnique
   */
  export interface YoutubeCommentFindUniqueArgs extends YoutubeCommentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeComment findUniqueOrThrow
   */
  export type YoutubeCommentFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeComment
     */
    select?: YoutubeCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentInclude | null
    /**
     * Filter, which YoutubeComment to fetch.
     */
    where: YoutubeCommentWhereUniqueInput
  }


  /**
   * YoutubeComment base type for findFirst actions
   */
  export type YoutubeCommentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeComment
     */
    select?: YoutubeCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentInclude | null
    /**
     * Filter, which YoutubeComment to fetch.
     */
    where?: YoutubeCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeComments to fetch.
     */
    orderBy?: Enumerable<YoutubeCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeComments.
     */
    cursor?: YoutubeCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeComments.
     */
    distinct?: Enumerable<YoutubeCommentScalarFieldEnum>
  }

  /**
   * YoutubeComment findFirst
   */
  export interface YoutubeCommentFindFirstArgs extends YoutubeCommentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeComment findFirstOrThrow
   */
  export type YoutubeCommentFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeComment
     */
    select?: YoutubeCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentInclude | null
    /**
     * Filter, which YoutubeComment to fetch.
     */
    where?: YoutubeCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeComments to fetch.
     */
    orderBy?: Enumerable<YoutubeCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeComments.
     */
    cursor?: YoutubeCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeComments.
     */
    distinct?: Enumerable<YoutubeCommentScalarFieldEnum>
  }


  /**
   * YoutubeComment findMany
   */
  export type YoutubeCommentFindManyArgs = {
    /**
     * Select specific fields to fetch from the YoutubeComment
     */
    select?: YoutubeCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentInclude | null
    /**
     * Filter, which YoutubeComments to fetch.
     */
    where?: YoutubeCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeComments to fetch.
     */
    orderBy?: Enumerable<YoutubeCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YoutubeComments.
     */
    cursor?: YoutubeCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeComments.
     */
    skip?: number
    distinct?: Enumerable<YoutubeCommentScalarFieldEnum>
  }


  /**
   * YoutubeComment create
   */
  export type YoutubeCommentCreateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeComment
     */
    select?: YoutubeCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentInclude | null
    /**
     * The data needed to create a YoutubeComment.
     */
    data: XOR<YoutubeCommentCreateInput, YoutubeCommentUncheckedCreateInput>
  }


  /**
   * YoutubeComment createMany
   */
  export type YoutubeCommentCreateManyArgs = {
    /**
     * The data used to create many YoutubeComments.
     */
    data: Enumerable<YoutubeCommentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * YoutubeComment update
   */
  export type YoutubeCommentUpdateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeComment
     */
    select?: YoutubeCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentInclude | null
    /**
     * The data needed to update a YoutubeComment.
     */
    data: XOR<YoutubeCommentUpdateInput, YoutubeCommentUncheckedUpdateInput>
    /**
     * Choose, which YoutubeComment to update.
     */
    where: YoutubeCommentWhereUniqueInput
  }


  /**
   * YoutubeComment updateMany
   */
  export type YoutubeCommentUpdateManyArgs = {
    /**
     * The data used to update YoutubeComments.
     */
    data: XOR<YoutubeCommentUpdateManyMutationInput, YoutubeCommentUncheckedUpdateManyInput>
    /**
     * Filter which YoutubeComments to update
     */
    where?: YoutubeCommentWhereInput
  }


  /**
   * YoutubeComment upsert
   */
  export type YoutubeCommentUpsertArgs = {
    /**
     * Select specific fields to fetch from the YoutubeComment
     */
    select?: YoutubeCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentInclude | null
    /**
     * The filter to search for the YoutubeComment to update in case it exists.
     */
    where: YoutubeCommentWhereUniqueInput
    /**
     * In case the YoutubeComment found by the `where` argument doesn't exist, create a new YoutubeComment with this data.
     */
    create: XOR<YoutubeCommentCreateInput, YoutubeCommentUncheckedCreateInput>
    /**
     * In case the YoutubeComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YoutubeCommentUpdateInput, YoutubeCommentUncheckedUpdateInput>
  }


  /**
   * YoutubeComment delete
   */
  export type YoutubeCommentDeleteArgs = {
    /**
     * Select specific fields to fetch from the YoutubeComment
     */
    select?: YoutubeCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentInclude | null
    /**
     * Filter which YoutubeComment to delete.
     */
    where: YoutubeCommentWhereUniqueInput
  }


  /**
   * YoutubeComment deleteMany
   */
  export type YoutubeCommentDeleteManyArgs = {
    /**
     * Filter which YoutubeComments to delete
     */
    where?: YoutubeCommentWhereInput
  }


  /**
   * YoutubeComment.youtubeCommentReactions
   */
  export type YoutubeComment$youtubeCommentReactionsArgs = {
    /**
     * Select specific fields to fetch from the YoutubeCommentReaction
     */
    select?: YoutubeCommentReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentReactionInclude | null
    where?: YoutubeCommentReactionWhereInput
    orderBy?: Enumerable<YoutubeCommentReactionOrderByWithRelationInput>
    cursor?: YoutubeCommentReactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YoutubeCommentReactionScalarFieldEnum>
  }


  /**
   * YoutubeComment without action
   */
  export type YoutubeCommentArgs = {
    /**
     * Select specific fields to fetch from the YoutubeComment
     */
    select?: YoutubeCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentInclude | null
  }



  /**
   * Model YoutubeCommentReaction
   */


  export type AggregateYoutubeCommentReaction = {
    _count: YoutubeCommentReactionCountAggregateOutputType | null
    _avg: YoutubeCommentReactionAvgAggregateOutputType | null
    _sum: YoutubeCommentReactionSumAggregateOutputType | null
    _min: YoutubeCommentReactionMinAggregateOutputType | null
    _max: YoutubeCommentReactionMaxAggregateOutputType | null
  }

  export type YoutubeCommentReactionAvgAggregateOutputType = {
    id: number | null
    youtubeUserId: number | null
    youtubeChannelId: number | null
    youtubeVideoId: number | null
    youtubeCommentId: number | null
  }

  export type YoutubeCommentReactionSumAggregateOutputType = {
    id: number | null
    youtubeUserId: number | null
    youtubeChannelId: number | null
    youtubeVideoId: number | null
    youtubeCommentId: number | null
  }

  export type YoutubeCommentReactionMinAggregateOutputType = {
    id: number | null
    reaction: ReactionEnum | null
    createdAt: Date | null
    updatedAt: Date | null
    youtubeUserId: number | null
    youtubeChannelId: number | null
    youtubeVideoId: number | null
    youtubeCommentId: number | null
  }

  export type YoutubeCommentReactionMaxAggregateOutputType = {
    id: number | null
    reaction: ReactionEnum | null
    createdAt: Date | null
    updatedAt: Date | null
    youtubeUserId: number | null
    youtubeChannelId: number | null
    youtubeVideoId: number | null
    youtubeCommentId: number | null
  }

  export type YoutubeCommentReactionCountAggregateOutputType = {
    id: number
    reaction: number
    createdAt: number
    updatedAt: number
    youtubeUserId: number
    youtubeChannelId: number
    youtubeVideoId: number
    youtubeCommentId: number
    _all: number
  }


  export type YoutubeCommentReactionAvgAggregateInputType = {
    id?: true
    youtubeUserId?: true
    youtubeChannelId?: true
    youtubeVideoId?: true
    youtubeCommentId?: true
  }

  export type YoutubeCommentReactionSumAggregateInputType = {
    id?: true
    youtubeUserId?: true
    youtubeChannelId?: true
    youtubeVideoId?: true
    youtubeCommentId?: true
  }

  export type YoutubeCommentReactionMinAggregateInputType = {
    id?: true
    reaction?: true
    createdAt?: true
    updatedAt?: true
    youtubeUserId?: true
    youtubeChannelId?: true
    youtubeVideoId?: true
    youtubeCommentId?: true
  }

  export type YoutubeCommentReactionMaxAggregateInputType = {
    id?: true
    reaction?: true
    createdAt?: true
    updatedAt?: true
    youtubeUserId?: true
    youtubeChannelId?: true
    youtubeVideoId?: true
    youtubeCommentId?: true
  }

  export type YoutubeCommentReactionCountAggregateInputType = {
    id?: true
    reaction?: true
    createdAt?: true
    updatedAt?: true
    youtubeUserId?: true
    youtubeChannelId?: true
    youtubeVideoId?: true
    youtubeCommentId?: true
    _all?: true
  }

  export type YoutubeCommentReactionAggregateArgs = {
    /**
     * Filter which YoutubeCommentReaction to aggregate.
     */
    where?: YoutubeCommentReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeCommentReactions to fetch.
     */
    orderBy?: Enumerable<YoutubeCommentReactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YoutubeCommentReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeCommentReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeCommentReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YoutubeCommentReactions
    **/
    _count?: true | YoutubeCommentReactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YoutubeCommentReactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YoutubeCommentReactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YoutubeCommentReactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YoutubeCommentReactionMaxAggregateInputType
  }

  export type GetYoutubeCommentReactionAggregateType<T extends YoutubeCommentReactionAggregateArgs> = {
        [P in keyof T & keyof AggregateYoutubeCommentReaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYoutubeCommentReaction[P]>
      : GetScalarType<T[P], AggregateYoutubeCommentReaction[P]>
  }




  export type YoutubeCommentReactionGroupByArgs = {
    where?: YoutubeCommentReactionWhereInput
    orderBy?: Enumerable<YoutubeCommentReactionOrderByWithAggregationInput>
    by: YoutubeCommentReactionScalarFieldEnum[]
    having?: YoutubeCommentReactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YoutubeCommentReactionCountAggregateInputType | true
    _avg?: YoutubeCommentReactionAvgAggregateInputType
    _sum?: YoutubeCommentReactionSumAggregateInputType
    _min?: YoutubeCommentReactionMinAggregateInputType
    _max?: YoutubeCommentReactionMaxAggregateInputType
  }


  export type YoutubeCommentReactionGroupByOutputType = {
    id: number
    reaction: ReactionEnum
    createdAt: Date
    updatedAt: Date
    youtubeUserId: number
    youtubeChannelId: number
    youtubeVideoId: number
    youtubeCommentId: number
    _count: YoutubeCommentReactionCountAggregateOutputType | null
    _avg: YoutubeCommentReactionAvgAggregateOutputType | null
    _sum: YoutubeCommentReactionSumAggregateOutputType | null
    _min: YoutubeCommentReactionMinAggregateOutputType | null
    _max: YoutubeCommentReactionMaxAggregateOutputType | null
  }

  type GetYoutubeCommentReactionGroupByPayload<T extends YoutubeCommentReactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<YoutubeCommentReactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YoutubeCommentReactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YoutubeCommentReactionGroupByOutputType[P]>
            : GetScalarType<T[P], YoutubeCommentReactionGroupByOutputType[P]>
        }
      >
    >


  export type YoutubeCommentReactionSelect = {
    id?: boolean
    user?: boolean | YoutubeUserArgs
    comment?: boolean | YoutubeCommentArgs
    reaction?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    youtubeUserId?: boolean
    youtubeChannelId?: boolean
    youtubeVideoId?: boolean
    youtubeCommentId?: boolean
  }


  export type YoutubeCommentReactionInclude = {
    user?: boolean | YoutubeUserArgs
    comment?: boolean | YoutubeCommentArgs
  }

  export type YoutubeCommentReactionGetPayload<S extends boolean | null | undefined | YoutubeCommentReactionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YoutubeCommentReaction :
    S extends undefined ? never :
    S extends { include: any } & (YoutubeCommentReactionArgs | YoutubeCommentReactionFindManyArgs)
    ? YoutubeCommentReaction  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? YoutubeUserGetPayload<S['include'][P]> :
        P extends 'comment' ? YoutubeCommentGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (YoutubeCommentReactionArgs | YoutubeCommentReactionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? YoutubeUserGetPayload<S['select'][P]> :
        P extends 'comment' ? YoutubeCommentGetPayload<S['select'][P]> :  P extends keyof YoutubeCommentReaction ? YoutubeCommentReaction[P] : never
  } 
      : YoutubeCommentReaction


  type YoutubeCommentReactionCountArgs = 
    Omit<YoutubeCommentReactionFindManyArgs, 'select' | 'include'> & {
      select?: YoutubeCommentReactionCountAggregateInputType | true
    }

  export interface YoutubeCommentReactionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one YoutubeCommentReaction that matches the filter.
     * @param {YoutubeCommentReactionFindUniqueArgs} args - Arguments to find a YoutubeCommentReaction
     * @example
     * // Get one YoutubeCommentReaction
     * const youtubeCommentReaction = await prisma.youtubeCommentReaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends YoutubeCommentReactionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, YoutubeCommentReactionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'YoutubeCommentReaction'> extends True ? Prisma__YoutubeCommentReactionClient<YoutubeCommentReactionGetPayload<T>> : Prisma__YoutubeCommentReactionClient<YoutubeCommentReactionGetPayload<T> | null, null>

    /**
     * Find one YoutubeCommentReaction that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {YoutubeCommentReactionFindUniqueOrThrowArgs} args - Arguments to find a YoutubeCommentReaction
     * @example
     * // Get one YoutubeCommentReaction
     * const youtubeCommentReaction = await prisma.youtubeCommentReaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends YoutubeCommentReactionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, YoutubeCommentReactionFindUniqueOrThrowArgs>
    ): Prisma__YoutubeCommentReactionClient<YoutubeCommentReactionGetPayload<T>>

    /**
     * Find the first YoutubeCommentReaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeCommentReactionFindFirstArgs} args - Arguments to find a YoutubeCommentReaction
     * @example
     * // Get one YoutubeCommentReaction
     * const youtubeCommentReaction = await prisma.youtubeCommentReaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends YoutubeCommentReactionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, YoutubeCommentReactionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'YoutubeCommentReaction'> extends True ? Prisma__YoutubeCommentReactionClient<YoutubeCommentReactionGetPayload<T>> : Prisma__YoutubeCommentReactionClient<YoutubeCommentReactionGetPayload<T> | null, null>

    /**
     * Find the first YoutubeCommentReaction that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeCommentReactionFindFirstOrThrowArgs} args - Arguments to find a YoutubeCommentReaction
     * @example
     * // Get one YoutubeCommentReaction
     * const youtubeCommentReaction = await prisma.youtubeCommentReaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends YoutubeCommentReactionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, YoutubeCommentReactionFindFirstOrThrowArgs>
    ): Prisma__YoutubeCommentReactionClient<YoutubeCommentReactionGetPayload<T>>

    /**
     * Find zero or more YoutubeCommentReactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeCommentReactionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YoutubeCommentReactions
     * const youtubeCommentReactions = await prisma.youtubeCommentReaction.findMany()
     * 
     * // Get first 10 YoutubeCommentReactions
     * const youtubeCommentReactions = await prisma.youtubeCommentReaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const youtubeCommentReactionWithIdOnly = await prisma.youtubeCommentReaction.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends YoutubeCommentReactionFindManyArgs>(
      args?: SelectSubset<T, YoutubeCommentReactionFindManyArgs>
    ): Prisma.PrismaPromise<Array<YoutubeCommentReactionGetPayload<T>>>

    /**
     * Create a YoutubeCommentReaction.
     * @param {YoutubeCommentReactionCreateArgs} args - Arguments to create a YoutubeCommentReaction.
     * @example
     * // Create one YoutubeCommentReaction
     * const YoutubeCommentReaction = await prisma.youtubeCommentReaction.create({
     *   data: {
     *     // ... data to create a YoutubeCommentReaction
     *   }
     * })
     * 
    **/
    create<T extends YoutubeCommentReactionCreateArgs>(
      args: SelectSubset<T, YoutubeCommentReactionCreateArgs>
    ): Prisma__YoutubeCommentReactionClient<YoutubeCommentReactionGetPayload<T>>

    /**
     * Create many YoutubeCommentReactions.
     *     @param {YoutubeCommentReactionCreateManyArgs} args - Arguments to create many YoutubeCommentReactions.
     *     @example
     *     // Create many YoutubeCommentReactions
     *     const youtubeCommentReaction = await prisma.youtubeCommentReaction.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends YoutubeCommentReactionCreateManyArgs>(
      args?: SelectSubset<T, YoutubeCommentReactionCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a YoutubeCommentReaction.
     * @param {YoutubeCommentReactionDeleteArgs} args - Arguments to delete one YoutubeCommentReaction.
     * @example
     * // Delete one YoutubeCommentReaction
     * const YoutubeCommentReaction = await prisma.youtubeCommentReaction.delete({
     *   where: {
     *     // ... filter to delete one YoutubeCommentReaction
     *   }
     * })
     * 
    **/
    delete<T extends YoutubeCommentReactionDeleteArgs>(
      args: SelectSubset<T, YoutubeCommentReactionDeleteArgs>
    ): Prisma__YoutubeCommentReactionClient<YoutubeCommentReactionGetPayload<T>>

    /**
     * Update one YoutubeCommentReaction.
     * @param {YoutubeCommentReactionUpdateArgs} args - Arguments to update one YoutubeCommentReaction.
     * @example
     * // Update one YoutubeCommentReaction
     * const youtubeCommentReaction = await prisma.youtubeCommentReaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends YoutubeCommentReactionUpdateArgs>(
      args: SelectSubset<T, YoutubeCommentReactionUpdateArgs>
    ): Prisma__YoutubeCommentReactionClient<YoutubeCommentReactionGetPayload<T>>

    /**
     * Delete zero or more YoutubeCommentReactions.
     * @param {YoutubeCommentReactionDeleteManyArgs} args - Arguments to filter YoutubeCommentReactions to delete.
     * @example
     * // Delete a few YoutubeCommentReactions
     * const { count } = await prisma.youtubeCommentReaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends YoutubeCommentReactionDeleteManyArgs>(
      args?: SelectSubset<T, YoutubeCommentReactionDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YoutubeCommentReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeCommentReactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YoutubeCommentReactions
     * const youtubeCommentReaction = await prisma.youtubeCommentReaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends YoutubeCommentReactionUpdateManyArgs>(
      args: SelectSubset<T, YoutubeCommentReactionUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one YoutubeCommentReaction.
     * @param {YoutubeCommentReactionUpsertArgs} args - Arguments to update or create a YoutubeCommentReaction.
     * @example
     * // Update or create a YoutubeCommentReaction
     * const youtubeCommentReaction = await prisma.youtubeCommentReaction.upsert({
     *   create: {
     *     // ... data to create a YoutubeCommentReaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YoutubeCommentReaction we want to update
     *   }
     * })
    **/
    upsert<T extends YoutubeCommentReactionUpsertArgs>(
      args: SelectSubset<T, YoutubeCommentReactionUpsertArgs>
    ): Prisma__YoutubeCommentReactionClient<YoutubeCommentReactionGetPayload<T>>

    /**
     * Count the number of YoutubeCommentReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeCommentReactionCountArgs} args - Arguments to filter YoutubeCommentReactions to count.
     * @example
     * // Count the number of YoutubeCommentReactions
     * const count = await prisma.youtubeCommentReaction.count({
     *   where: {
     *     // ... the filter for the YoutubeCommentReactions we want to count
     *   }
     * })
    **/
    count<T extends YoutubeCommentReactionCountArgs>(
      args?: Subset<T, YoutubeCommentReactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YoutubeCommentReactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YoutubeCommentReaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeCommentReactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YoutubeCommentReactionAggregateArgs>(args: Subset<T, YoutubeCommentReactionAggregateArgs>): Prisma.PrismaPromise<GetYoutubeCommentReactionAggregateType<T>>

    /**
     * Group by YoutubeCommentReaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeCommentReactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YoutubeCommentReactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YoutubeCommentReactionGroupByArgs['orderBy'] }
        : { orderBy?: YoutubeCommentReactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YoutubeCommentReactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYoutubeCommentReactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for YoutubeCommentReaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__YoutubeCommentReactionClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends YoutubeUserArgs= {}>(args?: Subset<T, YoutubeUserArgs>): Prisma__YoutubeUserClient<YoutubeUserGetPayload<T> | Null>;

    comment<T extends YoutubeCommentArgs= {}>(args?: Subset<T, YoutubeCommentArgs>): Prisma__YoutubeCommentClient<YoutubeCommentGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * YoutubeCommentReaction base type for findUnique actions
   */
  export type YoutubeCommentReactionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeCommentReaction
     */
    select?: YoutubeCommentReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentReactionInclude | null
    /**
     * Filter, which YoutubeCommentReaction to fetch.
     */
    where: YoutubeCommentReactionWhereUniqueInput
  }

  /**
   * YoutubeCommentReaction findUnique
   */
  export interface YoutubeCommentReactionFindUniqueArgs extends YoutubeCommentReactionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeCommentReaction findUniqueOrThrow
   */
  export type YoutubeCommentReactionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeCommentReaction
     */
    select?: YoutubeCommentReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentReactionInclude | null
    /**
     * Filter, which YoutubeCommentReaction to fetch.
     */
    where: YoutubeCommentReactionWhereUniqueInput
  }


  /**
   * YoutubeCommentReaction base type for findFirst actions
   */
  export type YoutubeCommentReactionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeCommentReaction
     */
    select?: YoutubeCommentReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentReactionInclude | null
    /**
     * Filter, which YoutubeCommentReaction to fetch.
     */
    where?: YoutubeCommentReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeCommentReactions to fetch.
     */
    orderBy?: Enumerable<YoutubeCommentReactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeCommentReactions.
     */
    cursor?: YoutubeCommentReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeCommentReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeCommentReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeCommentReactions.
     */
    distinct?: Enumerable<YoutubeCommentReactionScalarFieldEnum>
  }

  /**
   * YoutubeCommentReaction findFirst
   */
  export interface YoutubeCommentReactionFindFirstArgs extends YoutubeCommentReactionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeCommentReaction findFirstOrThrow
   */
  export type YoutubeCommentReactionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeCommentReaction
     */
    select?: YoutubeCommentReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentReactionInclude | null
    /**
     * Filter, which YoutubeCommentReaction to fetch.
     */
    where?: YoutubeCommentReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeCommentReactions to fetch.
     */
    orderBy?: Enumerable<YoutubeCommentReactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeCommentReactions.
     */
    cursor?: YoutubeCommentReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeCommentReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeCommentReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeCommentReactions.
     */
    distinct?: Enumerable<YoutubeCommentReactionScalarFieldEnum>
  }


  /**
   * YoutubeCommentReaction findMany
   */
  export type YoutubeCommentReactionFindManyArgs = {
    /**
     * Select specific fields to fetch from the YoutubeCommentReaction
     */
    select?: YoutubeCommentReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentReactionInclude | null
    /**
     * Filter, which YoutubeCommentReactions to fetch.
     */
    where?: YoutubeCommentReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeCommentReactions to fetch.
     */
    orderBy?: Enumerable<YoutubeCommentReactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YoutubeCommentReactions.
     */
    cursor?: YoutubeCommentReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeCommentReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeCommentReactions.
     */
    skip?: number
    distinct?: Enumerable<YoutubeCommentReactionScalarFieldEnum>
  }


  /**
   * YoutubeCommentReaction create
   */
  export type YoutubeCommentReactionCreateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeCommentReaction
     */
    select?: YoutubeCommentReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentReactionInclude | null
    /**
     * The data needed to create a YoutubeCommentReaction.
     */
    data: XOR<YoutubeCommentReactionCreateInput, YoutubeCommentReactionUncheckedCreateInput>
  }


  /**
   * YoutubeCommentReaction createMany
   */
  export type YoutubeCommentReactionCreateManyArgs = {
    /**
     * The data used to create many YoutubeCommentReactions.
     */
    data: Enumerable<YoutubeCommentReactionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * YoutubeCommentReaction update
   */
  export type YoutubeCommentReactionUpdateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeCommentReaction
     */
    select?: YoutubeCommentReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentReactionInclude | null
    /**
     * The data needed to update a YoutubeCommentReaction.
     */
    data: XOR<YoutubeCommentReactionUpdateInput, YoutubeCommentReactionUncheckedUpdateInput>
    /**
     * Choose, which YoutubeCommentReaction to update.
     */
    where: YoutubeCommentReactionWhereUniqueInput
  }


  /**
   * YoutubeCommentReaction updateMany
   */
  export type YoutubeCommentReactionUpdateManyArgs = {
    /**
     * The data used to update YoutubeCommentReactions.
     */
    data: XOR<YoutubeCommentReactionUpdateManyMutationInput, YoutubeCommentReactionUncheckedUpdateManyInput>
    /**
     * Filter which YoutubeCommentReactions to update
     */
    where?: YoutubeCommentReactionWhereInput
  }


  /**
   * YoutubeCommentReaction upsert
   */
  export type YoutubeCommentReactionUpsertArgs = {
    /**
     * Select specific fields to fetch from the YoutubeCommentReaction
     */
    select?: YoutubeCommentReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentReactionInclude | null
    /**
     * The filter to search for the YoutubeCommentReaction to update in case it exists.
     */
    where: YoutubeCommentReactionWhereUniqueInput
    /**
     * In case the YoutubeCommentReaction found by the `where` argument doesn't exist, create a new YoutubeCommentReaction with this data.
     */
    create: XOR<YoutubeCommentReactionCreateInput, YoutubeCommentReactionUncheckedCreateInput>
    /**
     * In case the YoutubeCommentReaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YoutubeCommentReactionUpdateInput, YoutubeCommentReactionUncheckedUpdateInput>
  }


  /**
   * YoutubeCommentReaction delete
   */
  export type YoutubeCommentReactionDeleteArgs = {
    /**
     * Select specific fields to fetch from the YoutubeCommentReaction
     */
    select?: YoutubeCommentReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentReactionInclude | null
    /**
     * Filter which YoutubeCommentReaction to delete.
     */
    where: YoutubeCommentReactionWhereUniqueInput
  }


  /**
   * YoutubeCommentReaction deleteMany
   */
  export type YoutubeCommentReactionDeleteManyArgs = {
    /**
     * Filter which YoutubeCommentReactions to delete
     */
    where?: YoutubeCommentReactionWhereInput
  }


  /**
   * YoutubeCommentReaction without action
   */
  export type YoutubeCommentReactionArgs = {
    /**
     * Select specific fields to fetch from the YoutubeCommentReaction
     */
    select?: YoutubeCommentReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentReactionInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const BinKitchenCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BinKitchenCategoryScalarFieldEnum = (typeof BinKitchenCategoryScalarFieldEnum)[keyof typeof BinKitchenCategoryScalarFieldEnum]


  export const BinKitchenMenuScalarFieldEnum: {
    id: 'id',
    name: 'name',
    image: 'image',
    price: 'price',
    categoryName: 'categoryName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BinKitchenMenuScalarFieldEnum = (typeof BinKitchenMenuScalarFieldEnum)[keyof typeof BinKitchenMenuScalarFieldEnum]


  export const BinKitchenOrderItemScalarFieldEnum: {
    id: 'id',
    quantity: 'quantity',
    totalPrice: 'totalPrice',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    menuId: 'menuId',
    orderId: 'orderId'
  };

  export type BinKitchenOrderItemScalarFieldEnum = (typeof BinKitchenOrderItemScalarFieldEnum)[keyof typeof BinKitchenOrderItemScalarFieldEnum]


  export const BinKitchenOrderScalarFieldEnum: {
    id: 'id',
    tableId: 'tableId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BinKitchenOrderScalarFieldEnum = (typeof BinKitchenOrderScalarFieldEnum)[keyof typeof BinKitchenOrderScalarFieldEnum]


  export const LaundryBalanceTopupScalarFieldEnum: {
    id: 'id',
    topUpRound: 'topUpRound',
    topUpAmount: 'topUpAmount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    laundryUserId: 'laundryUserId'
  };

  export type LaundryBalanceTopupScalarFieldEnum = (typeof LaundryBalanceTopupScalarFieldEnum)[keyof typeof LaundryBalanceTopupScalarFieldEnum]


  export const LaundryBranchScalarFieldEnum: {
    id: 'id',
    name: 'name',
    machineAmount: 'machineAmount',
    owner: 'owner',
    tel: 'tel',
    location: 'location',
    areaSize: 'areaSize',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LaundryBranchScalarFieldEnum = (typeof LaundryBranchScalarFieldEnum)[keyof typeof LaundryBranchScalarFieldEnum]


  export const LaundryMaintainanceScalarFieldEnum: {
    id: 'id',
    round: 'round',
    date: 'date',
    damageLevel: 'damageLevel',
    description: 'description',
    technicianName: 'technicianName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    laundryWashingMachineId: 'laundryWashingMachineId'
  };

  export type LaundryMaintainanceScalarFieldEnum = (typeof LaundryMaintainanceScalarFieldEnum)[keyof typeof LaundryMaintainanceScalarFieldEnum]


  export const LaundryProgramScalarFieldEnum: {
    id: 'id',
    name: 'name',
    price: 'price',
    duration: 'duration',
    weight: 'weight',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LaundryProgramScalarFieldEnum = (typeof LaundryProgramScalarFieldEnum)[keyof typeof LaundryProgramScalarFieldEnum]


  export const LaundryUserHistoryScalarFieldEnum: {
    id: 'id',
    washNumber: 'washNumber',
    date: 'date',
    duration: 'duration',
    price: 'price',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    laundryUserId: 'laundryUserId',
    laundryWashingMachineId: 'laundryWashingMachineId',
    laundryProgramId: 'laundryProgramId'
  };

  export type LaundryUserHistoryScalarFieldEnum = (typeof LaundryUserHistoryScalarFieldEnum)[keyof typeof LaundryUserHistoryScalarFieldEnum]


  export const LaundryUserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    tel: 'tel',
    balance: 'balance',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LaundryUserScalarFieldEnum = (typeof LaundryUserScalarFieldEnum)[keyof typeof LaundryUserScalarFieldEnum]


  export const LaundryWashingMachineScalarFieldEnum: {
    id: 'id',
    brand: 'brand',
    variant: 'variant',
    size: 'size',
    machineType: 'machineType',
    yearManufactured: 'yearManufactured',
    insuranceExpiryYear: 'insuranceExpiryYear',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    laundryBranchId: 'laundryBranchId'
  };

  export type LaundryWashingMachineScalarFieldEnum = (typeof LaundryWashingMachineScalarFieldEnum)[keyof typeof LaundryWashingMachineScalarFieldEnum]


  export const LaundryWashingMachineToProgramScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    laundryWashingMachineId: 'laundryWashingMachineId',
    laundryProgramId: 'laundryProgramId'
  };

  export type LaundryWashingMachineToProgramScalarFieldEnum = (typeof LaundryWashingMachineToProgramScalarFieldEnum)[keyof typeof LaundryWashingMachineToProgramScalarFieldEnum]


  export const LibraryBookAuthorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LibraryBookAuthorScalarFieldEnum = (typeof LibraryBookAuthorScalarFieldEnum)[keyof typeof LibraryBookAuthorScalarFieldEnum]


  export const LibraryBookCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LibraryBookCategoryScalarFieldEnum = (typeof LibraryBookCategoryScalarFieldEnum)[keyof typeof LibraryBookCategoryScalarFieldEnum]


  export const LibraryBookCopyScalarFieldEnum: {
    id: 'id',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    libraryBookId: 'libraryBookId',
    libraryUniversityId: 'libraryUniversityId',
    libraryStudentId: 'libraryStudentId'
  };

  export type LibraryBookCopyScalarFieldEnum = (typeof LibraryBookCopyScalarFieldEnum)[keyof typeof LibraryBookCopyScalarFieldEnum]


  export const LibraryBookScalarFieldEnum: {
    id: 'id',
    name: 'name',
    ISBN: 'ISBN',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LibraryBookScalarFieldEnum = (typeof LibraryBookScalarFieldEnum)[keyof typeof LibraryBookScalarFieldEnum]


  export const LibraryBookToAuthorScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    libraryBookId: 'libraryBookId',
    libraryBookAuthorId: 'libraryBookAuthorId'
  };

  export type LibraryBookToAuthorScalarFieldEnum = (typeof LibraryBookToAuthorScalarFieldEnum)[keyof typeof LibraryBookToAuthorScalarFieldEnum]


  export const LibraryBorrowingHistoryScalarFieldEnum: {
    id: 'id',
    borrowDate: 'borrowDate',
    returnDate: 'returnDate',
    actualReturnDate: 'actualReturnDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    libraryStudentId: 'libraryStudentId',
    libraryBookCopyId: 'libraryBookCopyId',
    libraryUniversityId: 'libraryUniversityId'
  };

  export type LibraryBorrowingHistoryScalarFieldEnum = (typeof LibraryBorrowingHistoryScalarFieldEnum)[keyof typeof LibraryBorrowingHistoryScalarFieldEnum]


  export const LibraryCategoryToBookScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    libraryBookCategoryId: 'libraryBookCategoryId',
    libraryBookId: 'libraryBookId'
  };

  export type LibraryCategoryToBookScalarFieldEnum = (typeof LibraryCategoryToBookScalarFieldEnum)[keyof typeof LibraryCategoryToBookScalarFieldEnum]


  export const LibraryRequestScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    libraryStudentId: 'libraryStudentId',
    libraryBookCopyId: 'libraryBookCopyId',
    fromLibraryUniversityId: 'fromLibraryUniversityId',
    toLibraryUniversityId: 'toLibraryUniversityId'
  };

  export type LibraryRequestScalarFieldEnum = (typeof LibraryRequestScalarFieldEnum)[keyof typeof LibraryRequestScalarFieldEnum]


  export const LibraryStudentScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    libraryUniversityId: 'libraryUniversityId'
  };

  export type LibraryStudentScalarFieldEnum = (typeof LibraryStudentScalarFieldEnum)[keyof typeof LibraryStudentScalarFieldEnum]


  export const LibraryUniversityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LibraryUniversityScalarFieldEnum = (typeof LibraryUniversityScalarFieldEnum)[keyof typeof LibraryUniversityScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const QuizCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuizCategoryScalarFieldEnum = (typeof QuizCategoryScalarFieldEnum)[keyof typeof QuizCategoryScalarFieldEnum]


  export const QuizChoiceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    quizQuestionId: 'quizQuestionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuizChoiceScalarFieldEnum = (typeof QuizChoiceScalarFieldEnum)[keyof typeof QuizChoiceScalarFieldEnum]


  export const QuizQuestionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    answerId: 'answerId',
    quizCategoryId: 'quizCategoryId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuizQuestionScalarFieldEnum = (typeof QuizQuestionScalarFieldEnum)[keyof typeof QuizQuestionScalarFieldEnum]


  export const QuizRecordScalarFieldEnum: {
    id: 'id',
    quizRoundId: 'quizRoundId',
    quizChoiceId: 'quizChoiceId',
    quizQuestionId: 'quizQuestionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuizRecordScalarFieldEnum = (typeof QuizRecordScalarFieldEnum)[keyof typeof QuizRecordScalarFieldEnum]


  export const QuizRoundScalarFieldEnum: {
    id: 'id',
    name: 'name',
    totalScore: 'totalScore',
    quizCategoryId: 'quizCategoryId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuizRoundScalarFieldEnum = (typeof QuizRoundScalarFieldEnum)[keyof typeof QuizRoundScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const TodoListScalarFieldEnum: {
    id: 'id',
    task: 'task',
    note: 'note',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TodoListScalarFieldEnum = (typeof TodoListScalarFieldEnum)[keyof typeof TodoListScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TwitterCommentScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    twitterPostId: 'twitterPostId',
    twitterUserId: 'twitterUserId'
  };

  export type TwitterCommentScalarFieldEnum = (typeof TwitterCommentScalarFieldEnum)[keyof typeof TwitterCommentScalarFieldEnum]


  export const TwitterDirectMessageScalarFieldEnum: {
    id: 'id',
    message: 'message',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    followingUserId: 'followingUserId',
    followerUserId: 'followerUserId'
  };

  export type TwitterDirectMessageScalarFieldEnum = (typeof TwitterDirectMessageScalarFieldEnum)[keyof typeof TwitterDirectMessageScalarFieldEnum]


  export const TwitterHashtagScalarFieldEnum: {
    id: 'id',
    hashtag: 'hashtag',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TwitterHashtagScalarFieldEnum = (typeof TwitterHashtagScalarFieldEnum)[keyof typeof TwitterHashtagScalarFieldEnum]


  export const TwitterPostScalarFieldEnum: {
    id: 'id',
    post: 'post',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    twitterUserId: 'twitterUserId'
  };

  export type TwitterPostScalarFieldEnum = (typeof TwitterPostScalarFieldEnum)[keyof typeof TwitterPostScalarFieldEnum]


  export const TwitterPostToHashtagScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    twitterPostId: 'twitterPostId',
    twitterHashtagId: 'twitterHashtagId'
  };

  export type TwitterPostToHashtagScalarFieldEnum = (typeof TwitterPostToHashtagScalarFieldEnum)[keyof typeof TwitterPostToHashtagScalarFieldEnum]


  export const TwitterUserRelationScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    fromUserId: 'fromUserId',
    toUserId: 'toUserId'
  };

  export type TwitterUserRelationScalarFieldEnum = (typeof TwitterUserRelationScalarFieldEnum)[keyof typeof TwitterUserRelationScalarFieldEnum]


  export const TwitterUserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TwitterUserScalarFieldEnum = (typeof TwitterUserScalarFieldEnum)[keyof typeof TwitterUserScalarFieldEnum]


  export const YoutubeChannelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type YoutubeChannelScalarFieldEnum = (typeof YoutubeChannelScalarFieldEnum)[keyof typeof YoutubeChannelScalarFieldEnum]


  export const YoutubeCommentReactionScalarFieldEnum: {
    id: 'id',
    reaction: 'reaction',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    youtubeUserId: 'youtubeUserId',
    youtubeChannelId: 'youtubeChannelId',
    youtubeVideoId: 'youtubeVideoId',
    youtubeCommentId: 'youtubeCommentId'
  };

  export type YoutubeCommentReactionScalarFieldEnum = (typeof YoutubeCommentReactionScalarFieldEnum)[keyof typeof YoutubeCommentReactionScalarFieldEnum]


  export const YoutubeCommentScalarFieldEnum: {
    id: 'id',
    comment: 'comment',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    youtubeVideoId: 'youtubeVideoId',
    youtubeUserId: 'youtubeUserId'
  };

  export type YoutubeCommentScalarFieldEnum = (typeof YoutubeCommentScalarFieldEnum)[keyof typeof YoutubeCommentScalarFieldEnum]


  export const YoutubeReactionScalarFieldEnum: {
    id: 'id',
    reaction: 'reaction',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    youtubeUserId: 'youtubeUserId',
    youtubeChannelId: 'youtubeChannelId',
    youtubeVideoId: 'youtubeVideoId',
    youtubeCommentId: 'youtubeCommentId'
  };

  export type YoutubeReactionScalarFieldEnum = (typeof YoutubeReactionScalarFieldEnum)[keyof typeof YoutubeReactionScalarFieldEnum]


  export const YoutubeSubscriptionScalarFieldEnum: {
    id: 'id',
    membership: 'membership',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    youtubeUserId: 'youtubeUserId',
    youtubeChannelId: 'youtubeChannelId'
  };

  export type YoutubeSubscriptionScalarFieldEnum = (typeof YoutubeSubscriptionScalarFieldEnum)[keyof typeof YoutubeSubscriptionScalarFieldEnum]


  export const YoutubeUserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type YoutubeUserScalarFieldEnum = (typeof YoutubeUserScalarFieldEnum)[keyof typeof YoutubeUserScalarFieldEnum]


  export const YoutubeUserToChannelScalarFieldEnum: {
    id: 'id',
    description: 'description',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    youtubeUserId: 'youtubeUserId',
    youtubeChannelId: 'youtubeChannelId'
  };

  export type YoutubeUserToChannelScalarFieldEnum = (typeof YoutubeUserToChannelScalarFieldEnum)[keyof typeof YoutubeUserToChannelScalarFieldEnum]


  export const YoutubeVideoScalarFieldEnum: {
    id: 'id',
    name: 'name',
    videoUrl: 'videoUrl',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    youtubeChannelId: 'youtubeChannelId'
  };

  export type YoutubeVideoScalarFieldEnum = (typeof YoutubeVideoScalarFieldEnum)[keyof typeof YoutubeVideoScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type BinKitchenCategoryWhereInput = {
    AND?: Enumerable<BinKitchenCategoryWhereInput>
    OR?: Enumerable<BinKitchenCategoryWhereInput>
    NOT?: Enumerable<BinKitchenCategoryWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    menus?: BinKitchenMenuListRelationFilter
  }

  export type BinKitchenCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    menus?: BinKitchenMenuOrderByRelationAggregateInput
  }

  export type BinKitchenCategoryWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type BinKitchenCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BinKitchenCategoryCountOrderByAggregateInput
    _avg?: BinKitchenCategoryAvgOrderByAggregateInput
    _max?: BinKitchenCategoryMaxOrderByAggregateInput
    _min?: BinKitchenCategoryMinOrderByAggregateInput
    _sum?: BinKitchenCategorySumOrderByAggregateInput
  }

  export type BinKitchenCategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BinKitchenCategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<BinKitchenCategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BinKitchenCategoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type BinKitchenMenuWhereInput = {
    AND?: Enumerable<BinKitchenMenuWhereInput>
    OR?: Enumerable<BinKitchenMenuWhereInput>
    NOT?: Enumerable<BinKitchenMenuWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    image?: StringFilter | string
    price?: FloatFilter | number
    category?: XOR<BinKitchenCategoryRelationFilter, BinKitchenCategoryWhereInput> | null
    categoryName?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    items?: BinKitchenOrderItemListRelationFilter
  }

  export type BinKitchenMenuOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    price?: SortOrder
    category?: BinKitchenCategoryOrderByWithRelationInput
    categoryName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    items?: BinKitchenOrderItemOrderByRelationAggregateInput
  }

  export type BinKitchenMenuWhereUniqueInput = {
    id?: number
  }

  export type BinKitchenMenuOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    price?: SortOrder
    categoryName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BinKitchenMenuCountOrderByAggregateInput
    _avg?: BinKitchenMenuAvgOrderByAggregateInput
    _max?: BinKitchenMenuMaxOrderByAggregateInput
    _min?: BinKitchenMenuMinOrderByAggregateInput
    _sum?: BinKitchenMenuSumOrderByAggregateInput
  }

  export type BinKitchenMenuScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BinKitchenMenuScalarWhereWithAggregatesInput>
    OR?: Enumerable<BinKitchenMenuScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BinKitchenMenuScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    image?: StringWithAggregatesFilter | string
    price?: FloatWithAggregatesFilter | number
    categoryName?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type BinKitchenOrderWhereInput = {
    AND?: Enumerable<BinKitchenOrderWhereInput>
    OR?: Enumerable<BinKitchenOrderWhereInput>
    NOT?: Enumerable<BinKitchenOrderWhereInput>
    id?: IntFilter | number
    tableId?: IntFilter | number
    status?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    items?: BinKitchenOrderItemListRelationFilter
  }

  export type BinKitchenOrderOrderByWithRelationInput = {
    id?: SortOrder
    tableId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    items?: BinKitchenOrderItemOrderByRelationAggregateInput
  }

  export type BinKitchenOrderWhereUniqueInput = {
    id?: number
  }

  export type BinKitchenOrderOrderByWithAggregationInput = {
    id?: SortOrder
    tableId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BinKitchenOrderCountOrderByAggregateInput
    _avg?: BinKitchenOrderAvgOrderByAggregateInput
    _max?: BinKitchenOrderMaxOrderByAggregateInput
    _min?: BinKitchenOrderMinOrderByAggregateInput
    _sum?: BinKitchenOrderSumOrderByAggregateInput
  }

  export type BinKitchenOrderScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BinKitchenOrderScalarWhereWithAggregatesInput>
    OR?: Enumerable<BinKitchenOrderScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BinKitchenOrderScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    tableId?: IntWithAggregatesFilter | number
    status?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type BinKitchenOrderItemWhereInput = {
    AND?: Enumerable<BinKitchenOrderItemWhereInput>
    OR?: Enumerable<BinKitchenOrderItemWhereInput>
    NOT?: Enumerable<BinKitchenOrderItemWhereInput>
    id?: IntFilter | number
    menu?: XOR<BinKitchenMenuRelationFilter, BinKitchenMenuWhereInput>
    order?: XOR<BinKitchenOrderRelationFilter, BinKitchenOrderWhereInput>
    quantity?: IntFilter | number
    totalPrice?: FloatFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    menuId?: IntFilter | number
    orderId?: IntFilter | number
  }

  export type BinKitchenOrderItemOrderByWithRelationInput = {
    id?: SortOrder
    menu?: BinKitchenMenuOrderByWithRelationInput
    order?: BinKitchenOrderOrderByWithRelationInput
    quantity?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    menuId?: SortOrder
    orderId?: SortOrder
  }

  export type BinKitchenOrderItemWhereUniqueInput = {
    id?: number
  }

  export type BinKitchenOrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    menuId?: SortOrder
    orderId?: SortOrder
    _count?: BinKitchenOrderItemCountOrderByAggregateInput
    _avg?: BinKitchenOrderItemAvgOrderByAggregateInput
    _max?: BinKitchenOrderItemMaxOrderByAggregateInput
    _min?: BinKitchenOrderItemMinOrderByAggregateInput
    _sum?: BinKitchenOrderItemSumOrderByAggregateInput
  }

  export type BinKitchenOrderItemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BinKitchenOrderItemScalarWhereWithAggregatesInput>
    OR?: Enumerable<BinKitchenOrderItemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BinKitchenOrderItemScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    quantity?: IntWithAggregatesFilter | number
    totalPrice?: FloatWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    menuId?: IntWithAggregatesFilter | number
    orderId?: IntWithAggregatesFilter | number
  }

  export type LaundryBranchWhereInput = {
    AND?: Enumerable<LaundryBranchWhereInput>
    OR?: Enumerable<LaundryBranchWhereInput>
    NOT?: Enumerable<LaundryBranchWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    machineAmount?: IntFilter | number
    owner?: StringFilter | string
    tel?: IntFilter | number
    location?: StringFilter | string
    areaSize?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    laundryWashingMachines?: LaundryWashingMachineListRelationFilter
  }

  export type LaundryBranchOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    machineAmount?: SortOrder
    owner?: SortOrder
    tel?: SortOrder
    location?: SortOrder
    areaSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    laundryWashingMachines?: LaundryWashingMachineOrderByRelationAggregateInput
  }

  export type LaundryBranchWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type LaundryBranchOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    machineAmount?: SortOrder
    owner?: SortOrder
    tel?: SortOrder
    location?: SortOrder
    areaSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LaundryBranchCountOrderByAggregateInput
    _avg?: LaundryBranchAvgOrderByAggregateInput
    _max?: LaundryBranchMaxOrderByAggregateInput
    _min?: LaundryBranchMinOrderByAggregateInput
    _sum?: LaundryBranchSumOrderByAggregateInput
  }

  export type LaundryBranchScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LaundryBranchScalarWhereWithAggregatesInput>
    OR?: Enumerable<LaundryBranchScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LaundryBranchScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    machineAmount?: IntWithAggregatesFilter | number
    owner?: StringWithAggregatesFilter | string
    tel?: IntWithAggregatesFilter | number
    location?: StringWithAggregatesFilter | string
    areaSize?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type LaundryWashingMachineWhereInput = {
    AND?: Enumerable<LaundryWashingMachineWhereInput>
    OR?: Enumerable<LaundryWashingMachineWhereInput>
    NOT?: Enumerable<LaundryWashingMachineWhereInput>
    id?: IntFilter | number
    branch?: XOR<LaundryBranchRelationFilter, LaundryBranchWhereInput>
    brand?: StringFilter | string
    variant?: StringFilter | string
    size?: IntFilter | number
    machineType?: StringFilter | string
    yearManufactured?: IntFilter | number
    insuranceExpiryYear?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    laundryBranchId?: IntFilter | number
    laundryWashingMachinesToPrograms?: LaundryWashingMachineToProgramListRelationFilter
    laundryMaintainances?: LaundryMaintainanceListRelationFilter
    laundryUserHistories?: LaundryUserHistoryListRelationFilter
  }

  export type LaundryWashingMachineOrderByWithRelationInput = {
    id?: SortOrder
    branch?: LaundryBranchOrderByWithRelationInput
    brand?: SortOrder
    variant?: SortOrder
    size?: SortOrder
    machineType?: SortOrder
    yearManufactured?: SortOrder
    insuranceExpiryYear?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    laundryBranchId?: SortOrder
    laundryWashingMachinesToPrograms?: LaundryWashingMachineToProgramOrderByRelationAggregateInput
    laundryMaintainances?: LaundryMaintainanceOrderByRelationAggregateInput
    laundryUserHistories?: LaundryUserHistoryOrderByRelationAggregateInput
  }

  export type LaundryWashingMachineWhereUniqueInput = {
    id?: number
  }

  export type LaundryWashingMachineOrderByWithAggregationInput = {
    id?: SortOrder
    brand?: SortOrder
    variant?: SortOrder
    size?: SortOrder
    machineType?: SortOrder
    yearManufactured?: SortOrder
    insuranceExpiryYear?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    laundryBranchId?: SortOrder
    _count?: LaundryWashingMachineCountOrderByAggregateInput
    _avg?: LaundryWashingMachineAvgOrderByAggregateInput
    _max?: LaundryWashingMachineMaxOrderByAggregateInput
    _min?: LaundryWashingMachineMinOrderByAggregateInput
    _sum?: LaundryWashingMachineSumOrderByAggregateInput
  }

  export type LaundryWashingMachineScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LaundryWashingMachineScalarWhereWithAggregatesInput>
    OR?: Enumerable<LaundryWashingMachineScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LaundryWashingMachineScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    brand?: StringWithAggregatesFilter | string
    variant?: StringWithAggregatesFilter | string
    size?: IntWithAggregatesFilter | number
    machineType?: StringWithAggregatesFilter | string
    yearManufactured?: IntWithAggregatesFilter | number
    insuranceExpiryYear?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    laundryBranchId?: IntWithAggregatesFilter | number
  }

  export type LaundryProgramWhereInput = {
    AND?: Enumerable<LaundryProgramWhereInput>
    OR?: Enumerable<LaundryProgramWhereInput>
    NOT?: Enumerable<LaundryProgramWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    price?: IntFilter | number
    duration?: IntFilter | number
    weight?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    laundryWashingMachinesToPrograms?: LaundryWashingMachineToProgramListRelationFilter
    laundryUserHistories?: LaundryUserHistoryListRelationFilter
  }

  export type LaundryProgramOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    weight?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    laundryWashingMachinesToPrograms?: LaundryWashingMachineToProgramOrderByRelationAggregateInput
    laundryUserHistories?: LaundryUserHistoryOrderByRelationAggregateInput
  }

  export type LaundryProgramWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type LaundryProgramOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    weight?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LaundryProgramCountOrderByAggregateInput
    _avg?: LaundryProgramAvgOrderByAggregateInput
    _max?: LaundryProgramMaxOrderByAggregateInput
    _min?: LaundryProgramMinOrderByAggregateInput
    _sum?: LaundryProgramSumOrderByAggregateInput
  }

  export type LaundryProgramScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LaundryProgramScalarWhereWithAggregatesInput>
    OR?: Enumerable<LaundryProgramScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LaundryProgramScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    price?: IntWithAggregatesFilter | number
    duration?: IntWithAggregatesFilter | number
    weight?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type LaundryWashingMachineToProgramWhereInput = {
    AND?: Enumerable<LaundryWashingMachineToProgramWhereInput>
    OR?: Enumerable<LaundryWashingMachineToProgramWhereInput>
    NOT?: Enumerable<LaundryWashingMachineToProgramWhereInput>
    id?: IntFilter | number
    machine?: XOR<LaundryWashingMachineRelationFilter, LaundryWashingMachineWhereInput>
    program?: XOR<LaundryProgramRelationFilter, LaundryProgramWhereInput>
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    laundryWashingMachineId?: IntFilter | number
    laundryProgramId?: IntFilter | number
  }

  export type LaundryWashingMachineToProgramOrderByWithRelationInput = {
    id?: SortOrder
    machine?: LaundryWashingMachineOrderByWithRelationInput
    program?: LaundryProgramOrderByWithRelationInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
    laundryWashingMachineId?: SortOrder
    laundryProgramId?: SortOrder
  }

  export type LaundryWashingMachineToProgramWhereUniqueInput = {
    id?: number
  }

  export type LaundryWashingMachineToProgramOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    laundryWashingMachineId?: SortOrder
    laundryProgramId?: SortOrder
    _count?: LaundryWashingMachineToProgramCountOrderByAggregateInput
    _avg?: LaundryWashingMachineToProgramAvgOrderByAggregateInput
    _max?: LaundryWashingMachineToProgramMaxOrderByAggregateInput
    _min?: LaundryWashingMachineToProgramMinOrderByAggregateInput
    _sum?: LaundryWashingMachineToProgramSumOrderByAggregateInput
  }

  export type LaundryWashingMachineToProgramScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LaundryWashingMachineToProgramScalarWhereWithAggregatesInput>
    OR?: Enumerable<LaundryWashingMachineToProgramScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LaundryWashingMachineToProgramScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    laundryWashingMachineId?: IntWithAggregatesFilter | number
    laundryProgramId?: IntWithAggregatesFilter | number
  }

  export type LaundryMaintainanceWhereInput = {
    AND?: Enumerable<LaundryMaintainanceWhereInput>
    OR?: Enumerable<LaundryMaintainanceWhereInput>
    NOT?: Enumerable<LaundryMaintainanceWhereInput>
    id?: IntFilter | number
    round?: IntFilter | number
    machine?: XOR<LaundryWashingMachineRelationFilter, LaundryWashingMachineWhereInput>
    date?: IntFilter | number
    damageLevel?: IntFilter | number
    description?: StringFilter | string
    technicianName?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    laundryWashingMachineId?: IntFilter | number
  }

  export type LaundryMaintainanceOrderByWithRelationInput = {
    id?: SortOrder
    round?: SortOrder
    machine?: LaundryWashingMachineOrderByWithRelationInput
    date?: SortOrder
    damageLevel?: SortOrder
    description?: SortOrder
    technicianName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    laundryWashingMachineId?: SortOrder
  }

  export type LaundryMaintainanceWhereUniqueInput = {
    id?: number
  }

  export type LaundryMaintainanceOrderByWithAggregationInput = {
    id?: SortOrder
    round?: SortOrder
    date?: SortOrder
    damageLevel?: SortOrder
    description?: SortOrder
    technicianName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    laundryWashingMachineId?: SortOrder
    _count?: LaundryMaintainanceCountOrderByAggregateInput
    _avg?: LaundryMaintainanceAvgOrderByAggregateInput
    _max?: LaundryMaintainanceMaxOrderByAggregateInput
    _min?: LaundryMaintainanceMinOrderByAggregateInput
    _sum?: LaundryMaintainanceSumOrderByAggregateInput
  }

  export type LaundryMaintainanceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LaundryMaintainanceScalarWhereWithAggregatesInput>
    OR?: Enumerable<LaundryMaintainanceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LaundryMaintainanceScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    round?: IntWithAggregatesFilter | number
    date?: IntWithAggregatesFilter | number
    damageLevel?: IntWithAggregatesFilter | number
    description?: StringWithAggregatesFilter | string
    technicianName?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    laundryWashingMachineId?: IntWithAggregatesFilter | number
  }

  export type LaundryUserWhereInput = {
    AND?: Enumerable<LaundryUserWhereInput>
    OR?: Enumerable<LaundryUserWhereInput>
    NOT?: Enumerable<LaundryUserWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    tel?: IntFilter | number
    balance?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    laundryUserHistories?: LaundryUserHistoryListRelationFilter
    laundryBalanceTopups?: LaundryBalanceTopupListRelationFilter
  }

  export type LaundryUserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    tel?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    laundryUserHistories?: LaundryUserHistoryOrderByRelationAggregateInput
    laundryBalanceTopups?: LaundryBalanceTopupOrderByRelationAggregateInput
  }

  export type LaundryUserWhereUniqueInput = {
    id?: number
  }

  export type LaundryUserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    tel?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LaundryUserCountOrderByAggregateInput
    _avg?: LaundryUserAvgOrderByAggregateInput
    _max?: LaundryUserMaxOrderByAggregateInput
    _min?: LaundryUserMinOrderByAggregateInput
    _sum?: LaundryUserSumOrderByAggregateInput
  }

  export type LaundryUserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LaundryUserScalarWhereWithAggregatesInput>
    OR?: Enumerable<LaundryUserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LaundryUserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    tel?: IntWithAggregatesFilter | number
    balance?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type LaundryUserHistoryWhereInput = {
    AND?: Enumerable<LaundryUserHistoryWhereInput>
    OR?: Enumerable<LaundryUserHistoryWhereInput>
    NOT?: Enumerable<LaundryUserHistoryWhereInput>
    id?: IntFilter | number
    user?: XOR<LaundryUserRelationFilter, LaundryUserWhereInput>
    washNumber?: IntFilter | number
    machine?: XOR<LaundryWashingMachineRelationFilter, LaundryWashingMachineWhereInput>
    program?: XOR<LaundryProgramRelationFilter, LaundryProgramWhereInput>
    date?: IntFilter | number
    duration?: IntFilter | number
    price?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    laundryUserId?: IntFilter | number
    laundryWashingMachineId?: IntFilter | number
    laundryProgramId?: IntFilter | number
  }

  export type LaundryUserHistoryOrderByWithRelationInput = {
    id?: SortOrder
    user?: LaundryUserOrderByWithRelationInput
    washNumber?: SortOrder
    machine?: LaundryWashingMachineOrderByWithRelationInput
    program?: LaundryProgramOrderByWithRelationInput
    date?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    laundryUserId?: SortOrder
    laundryWashingMachineId?: SortOrder
    laundryProgramId?: SortOrder
  }

  export type LaundryUserHistoryWhereUniqueInput = {
    id?: number
  }

  export type LaundryUserHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    washNumber?: SortOrder
    date?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    laundryUserId?: SortOrder
    laundryWashingMachineId?: SortOrder
    laundryProgramId?: SortOrder
    _count?: LaundryUserHistoryCountOrderByAggregateInput
    _avg?: LaundryUserHistoryAvgOrderByAggregateInput
    _max?: LaundryUserHistoryMaxOrderByAggregateInput
    _min?: LaundryUserHistoryMinOrderByAggregateInput
    _sum?: LaundryUserHistorySumOrderByAggregateInput
  }

  export type LaundryUserHistoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LaundryUserHistoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<LaundryUserHistoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LaundryUserHistoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    washNumber?: IntWithAggregatesFilter | number
    date?: IntWithAggregatesFilter | number
    duration?: IntWithAggregatesFilter | number
    price?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    laundryUserId?: IntWithAggregatesFilter | number
    laundryWashingMachineId?: IntWithAggregatesFilter | number
    laundryProgramId?: IntWithAggregatesFilter | number
  }

  export type LaundryBalanceTopupWhereInput = {
    AND?: Enumerable<LaundryBalanceTopupWhereInput>
    OR?: Enumerable<LaundryBalanceTopupWhereInput>
    NOT?: Enumerable<LaundryBalanceTopupWhereInput>
    id?: IntFilter | number
    user?: XOR<LaundryUserRelationFilter, LaundryUserWhereInput>
    topUpRound?: IntFilter | number
    topUpAmount?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    laundryUserId?: IntFilter | number
  }

  export type LaundryBalanceTopupOrderByWithRelationInput = {
    id?: SortOrder
    user?: LaundryUserOrderByWithRelationInput
    topUpRound?: SortOrder
    topUpAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    laundryUserId?: SortOrder
  }

  export type LaundryBalanceTopupWhereUniqueInput = {
    id?: number
  }

  export type LaundryBalanceTopupOrderByWithAggregationInput = {
    id?: SortOrder
    topUpRound?: SortOrder
    topUpAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    laundryUserId?: SortOrder
    _count?: LaundryBalanceTopupCountOrderByAggregateInput
    _avg?: LaundryBalanceTopupAvgOrderByAggregateInput
    _max?: LaundryBalanceTopupMaxOrderByAggregateInput
    _min?: LaundryBalanceTopupMinOrderByAggregateInput
    _sum?: LaundryBalanceTopupSumOrderByAggregateInput
  }

  export type LaundryBalanceTopupScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LaundryBalanceTopupScalarWhereWithAggregatesInput>
    OR?: Enumerable<LaundryBalanceTopupScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LaundryBalanceTopupScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    topUpRound?: IntWithAggregatesFilter | number
    topUpAmount?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    laundryUserId?: IntWithAggregatesFilter | number
  }

  export type LibraryBookCategoryWhereInput = {
    AND?: Enumerable<LibraryBookCategoryWhereInput>
    OR?: Enumerable<LibraryBookCategoryWhereInput>
    NOT?: Enumerable<LibraryBookCategoryWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    libraryCategoriesToBooks?: LibraryCategoryToBookListRelationFilter
  }

  export type LibraryBookCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    libraryCategoriesToBooks?: LibraryCategoryToBookOrderByRelationAggregateInput
  }

  export type LibraryBookCategoryWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type LibraryBookCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LibraryBookCategoryCountOrderByAggregateInput
    _avg?: LibraryBookCategoryAvgOrderByAggregateInput
    _max?: LibraryBookCategoryMaxOrderByAggregateInput
    _min?: LibraryBookCategoryMinOrderByAggregateInput
    _sum?: LibraryBookCategorySumOrderByAggregateInput
  }

  export type LibraryBookCategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LibraryBookCategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<LibraryBookCategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LibraryBookCategoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type LibraryBookWhereInput = {
    AND?: Enumerable<LibraryBookWhereInput>
    OR?: Enumerable<LibraryBookWhereInput>
    NOT?: Enumerable<LibraryBookWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    ISBN?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    libraryCategoriesToBooks?: LibraryCategoryToBookListRelationFilter
    libraryBooksToAuthors?: LibraryBookToAuthorListRelationFilter
    libraryBookCopies?: LibraryBookCopyListRelationFilter
  }

  export type LibraryBookOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    ISBN?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    libraryCategoriesToBooks?: LibraryCategoryToBookOrderByRelationAggregateInput
    libraryBooksToAuthors?: LibraryBookToAuthorOrderByRelationAggregateInput
    libraryBookCopies?: LibraryBookCopyOrderByRelationAggregateInput
  }

  export type LibraryBookWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type LibraryBookOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    ISBN?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LibraryBookCountOrderByAggregateInput
    _avg?: LibraryBookAvgOrderByAggregateInput
    _max?: LibraryBookMaxOrderByAggregateInput
    _min?: LibraryBookMinOrderByAggregateInput
    _sum?: LibraryBookSumOrderByAggregateInput
  }

  export type LibraryBookScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LibraryBookScalarWhereWithAggregatesInput>
    OR?: Enumerable<LibraryBookScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LibraryBookScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    ISBN?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type LibraryCategoryToBookWhereInput = {
    AND?: Enumerable<LibraryCategoryToBookWhereInput>
    OR?: Enumerable<LibraryCategoryToBookWhereInput>
    NOT?: Enumerable<LibraryCategoryToBookWhereInput>
    id?: IntFilter | number
    category?: XOR<LibraryBookCategoryRelationFilter, LibraryBookCategoryWhereInput>
    book?: XOR<LibraryBookRelationFilter, LibraryBookWhereInput>
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    libraryBookCategoryId?: IntFilter | number
    libraryBookId?: IntFilter | number
  }

  export type LibraryCategoryToBookOrderByWithRelationInput = {
    id?: SortOrder
    category?: LibraryBookCategoryOrderByWithRelationInput
    book?: LibraryBookOrderByWithRelationInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
    libraryBookCategoryId?: SortOrder
    libraryBookId?: SortOrder
  }

  export type LibraryCategoryToBookWhereUniqueInput = {
    id?: number
  }

  export type LibraryCategoryToBookOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    libraryBookCategoryId?: SortOrder
    libraryBookId?: SortOrder
    _count?: LibraryCategoryToBookCountOrderByAggregateInput
    _avg?: LibraryCategoryToBookAvgOrderByAggregateInput
    _max?: LibraryCategoryToBookMaxOrderByAggregateInput
    _min?: LibraryCategoryToBookMinOrderByAggregateInput
    _sum?: LibraryCategoryToBookSumOrderByAggregateInput
  }

  export type LibraryCategoryToBookScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LibraryCategoryToBookScalarWhereWithAggregatesInput>
    OR?: Enumerable<LibraryCategoryToBookScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LibraryCategoryToBookScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    libraryBookCategoryId?: IntWithAggregatesFilter | number
    libraryBookId?: IntWithAggregatesFilter | number
  }

  export type LibraryBookAuthorWhereInput = {
    AND?: Enumerable<LibraryBookAuthorWhereInput>
    OR?: Enumerable<LibraryBookAuthorWhereInput>
    NOT?: Enumerable<LibraryBookAuthorWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    libraryBooksToAuthors?: LibraryBookToAuthorListRelationFilter
  }

  export type LibraryBookAuthorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    libraryBooksToAuthors?: LibraryBookToAuthorOrderByRelationAggregateInput
  }

  export type LibraryBookAuthorWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type LibraryBookAuthorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LibraryBookAuthorCountOrderByAggregateInput
    _avg?: LibraryBookAuthorAvgOrderByAggregateInput
    _max?: LibraryBookAuthorMaxOrderByAggregateInput
    _min?: LibraryBookAuthorMinOrderByAggregateInput
    _sum?: LibraryBookAuthorSumOrderByAggregateInput
  }

  export type LibraryBookAuthorScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LibraryBookAuthorScalarWhereWithAggregatesInput>
    OR?: Enumerable<LibraryBookAuthorScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LibraryBookAuthorScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type LibraryBookToAuthorWhereInput = {
    AND?: Enumerable<LibraryBookToAuthorWhereInput>
    OR?: Enumerable<LibraryBookToAuthorWhereInput>
    NOT?: Enumerable<LibraryBookToAuthorWhereInput>
    id?: IntFilter | number
    book?: XOR<LibraryBookRelationFilter, LibraryBookWhereInput>
    author?: XOR<LibraryBookAuthorRelationFilter, LibraryBookAuthorWhereInput>
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    libraryBookId?: IntFilter | number
    libraryBookAuthorId?: IntFilter | number
  }

  export type LibraryBookToAuthorOrderByWithRelationInput = {
    id?: SortOrder
    book?: LibraryBookOrderByWithRelationInput
    author?: LibraryBookAuthorOrderByWithRelationInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
    libraryBookId?: SortOrder
    libraryBookAuthorId?: SortOrder
  }

  export type LibraryBookToAuthorWhereUniqueInput = {
    id?: number
  }

  export type LibraryBookToAuthorOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    libraryBookId?: SortOrder
    libraryBookAuthorId?: SortOrder
    _count?: LibraryBookToAuthorCountOrderByAggregateInput
    _avg?: LibraryBookToAuthorAvgOrderByAggregateInput
    _max?: LibraryBookToAuthorMaxOrderByAggregateInput
    _min?: LibraryBookToAuthorMinOrderByAggregateInput
    _sum?: LibraryBookToAuthorSumOrderByAggregateInput
  }

  export type LibraryBookToAuthorScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LibraryBookToAuthorScalarWhereWithAggregatesInput>
    OR?: Enumerable<LibraryBookToAuthorScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LibraryBookToAuthorScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    libraryBookId?: IntWithAggregatesFilter | number
    libraryBookAuthorId?: IntWithAggregatesFilter | number
  }

  export type LibraryUniversityWhereInput = {
    AND?: Enumerable<LibraryUniversityWhereInput>
    OR?: Enumerable<LibraryUniversityWhereInput>
    NOT?: Enumerable<LibraryUniversityWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    libraryStudenta?: LibraryStudentListRelationFilter
    libraryBookCopies?: LibraryBookCopyListRelationFilter
    libraryBorrowingHistories?: LibraryBorrowingHistoryListRelationFilter
    fromLibraryRequests?: LibraryRequestListRelationFilter
    toLibraryRequests?: LibraryRequestListRelationFilter
  }

  export type LibraryUniversityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    libraryStudenta?: LibraryStudentOrderByRelationAggregateInput
    libraryBookCopies?: LibraryBookCopyOrderByRelationAggregateInput
    libraryBorrowingHistories?: LibraryBorrowingHistoryOrderByRelationAggregateInput
    fromLibraryRequests?: LibraryRequestOrderByRelationAggregateInput
    toLibraryRequests?: LibraryRequestOrderByRelationAggregateInput
  }

  export type LibraryUniversityWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type LibraryUniversityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LibraryUniversityCountOrderByAggregateInput
    _avg?: LibraryUniversityAvgOrderByAggregateInput
    _max?: LibraryUniversityMaxOrderByAggregateInput
    _min?: LibraryUniversityMinOrderByAggregateInput
    _sum?: LibraryUniversitySumOrderByAggregateInput
  }

  export type LibraryUniversityScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LibraryUniversityScalarWhereWithAggregatesInput>
    OR?: Enumerable<LibraryUniversityScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LibraryUniversityScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type LibraryStudentWhereInput = {
    AND?: Enumerable<LibraryStudentWhereInput>
    OR?: Enumerable<LibraryStudentWhereInput>
    NOT?: Enumerable<LibraryStudentWhereInput>
    id?: IntFilter | number
    studentId?: IntFilter | number
    name?: StringFilter | string
    university?: XOR<LibraryUniversityRelationFilter, LibraryUniversityWhereInput>
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    libraryUniversityId?: IntFilter | number
    libraryBookCopies?: LibraryBookCopyListRelationFilter
    libraryBorrowingHistories?: LibraryBorrowingHistoryListRelationFilter
    libraryRequests?: LibraryRequestListRelationFilter
  }

  export type LibraryStudentOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    name?: SortOrder
    university?: LibraryUniversityOrderByWithRelationInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
    libraryUniversityId?: SortOrder
    libraryBookCopies?: LibraryBookCopyOrderByRelationAggregateInput
    libraryBorrowingHistories?: LibraryBorrowingHistoryOrderByRelationAggregateInput
    libraryRequests?: LibraryRequestOrderByRelationAggregateInput
  }

  export type LibraryStudentWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type LibraryStudentOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    libraryUniversityId?: SortOrder
    _count?: LibraryStudentCountOrderByAggregateInput
    _avg?: LibraryStudentAvgOrderByAggregateInput
    _max?: LibraryStudentMaxOrderByAggregateInput
    _min?: LibraryStudentMinOrderByAggregateInput
    _sum?: LibraryStudentSumOrderByAggregateInput
  }

  export type LibraryStudentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LibraryStudentScalarWhereWithAggregatesInput>
    OR?: Enumerable<LibraryStudentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LibraryStudentScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    studentId?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    libraryUniversityId?: IntWithAggregatesFilter | number
  }

  export type LibraryBookCopyWhereInput = {
    AND?: Enumerable<LibraryBookCopyWhereInput>
    OR?: Enumerable<LibraryBookCopyWhereInput>
    NOT?: Enumerable<LibraryBookCopyWhereInput>
    id?: IntFilter | number
    book?: XOR<LibraryBookRelationFilter, LibraryBookWhereInput>
    status?: StringFilter | string
    university?: XOR<LibraryUniversityRelationFilter, LibraryUniversityWhereInput>
    borrowedBy?: XOR<LibraryStudentRelationFilter, LibraryStudentWhereInput>
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    libraryBookId?: IntFilter | number
    libraryUniversityId?: IntFilter | number
    libraryStudentId?: IntFilter | number
    libraryBorrowingHistories?: LibraryBorrowingHistoryListRelationFilter
    libraryRequests?: LibraryRequestListRelationFilter
  }

  export type LibraryBookCopyOrderByWithRelationInput = {
    id?: SortOrder
    book?: LibraryBookOrderByWithRelationInput
    status?: SortOrder
    university?: LibraryUniversityOrderByWithRelationInput
    borrowedBy?: LibraryStudentOrderByWithRelationInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
    libraryBookId?: SortOrder
    libraryUniversityId?: SortOrder
    libraryStudentId?: SortOrder
    libraryBorrowingHistories?: LibraryBorrowingHistoryOrderByRelationAggregateInput
    libraryRequests?: LibraryRequestOrderByRelationAggregateInput
  }

  export type LibraryBookCopyWhereUniqueInput = {
    id?: number
  }

  export type LibraryBookCopyOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    libraryBookId?: SortOrder
    libraryUniversityId?: SortOrder
    libraryStudentId?: SortOrder
    _count?: LibraryBookCopyCountOrderByAggregateInput
    _avg?: LibraryBookCopyAvgOrderByAggregateInput
    _max?: LibraryBookCopyMaxOrderByAggregateInput
    _min?: LibraryBookCopyMinOrderByAggregateInput
    _sum?: LibraryBookCopySumOrderByAggregateInput
  }

  export type LibraryBookCopyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LibraryBookCopyScalarWhereWithAggregatesInput>
    OR?: Enumerable<LibraryBookCopyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LibraryBookCopyScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    status?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    libraryBookId?: IntWithAggregatesFilter | number
    libraryUniversityId?: IntWithAggregatesFilter | number
    libraryStudentId?: IntWithAggregatesFilter | number
  }

  export type LibraryBorrowingHistoryWhereInput = {
    AND?: Enumerable<LibraryBorrowingHistoryWhereInput>
    OR?: Enumerable<LibraryBorrowingHistoryWhereInput>
    NOT?: Enumerable<LibraryBorrowingHistoryWhereInput>
    id?: IntFilter | number
    student?: XOR<LibraryStudentRelationFilter, LibraryStudentWhereInput>
    copy?: XOR<LibraryBookCopyRelationFilter, LibraryBookCopyWhereInput>
    borrowDate?: IntFilter | number
    returnDate?: IntFilter | number
    actualReturnDate?: IntFilter | number
    borrowedFrom?: XOR<LibraryUniversityRelationFilter, LibraryUniversityWhereInput>
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    libraryStudentId?: IntFilter | number
    libraryBookCopyId?: IntFilter | number
    libraryUniversityId?: IntFilter | number
  }

  export type LibraryBorrowingHistoryOrderByWithRelationInput = {
    id?: SortOrder
    student?: LibraryStudentOrderByWithRelationInput
    copy?: LibraryBookCopyOrderByWithRelationInput
    borrowDate?: SortOrder
    returnDate?: SortOrder
    actualReturnDate?: SortOrder
    borrowedFrom?: LibraryUniversityOrderByWithRelationInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
    libraryStudentId?: SortOrder
    libraryBookCopyId?: SortOrder
    libraryUniversityId?: SortOrder
  }

  export type LibraryBorrowingHistoryWhereUniqueInput = {
    id?: number
  }

  export type LibraryBorrowingHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    borrowDate?: SortOrder
    returnDate?: SortOrder
    actualReturnDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    libraryStudentId?: SortOrder
    libraryBookCopyId?: SortOrder
    libraryUniversityId?: SortOrder
    _count?: LibraryBorrowingHistoryCountOrderByAggregateInput
    _avg?: LibraryBorrowingHistoryAvgOrderByAggregateInput
    _max?: LibraryBorrowingHistoryMaxOrderByAggregateInput
    _min?: LibraryBorrowingHistoryMinOrderByAggregateInput
    _sum?: LibraryBorrowingHistorySumOrderByAggregateInput
  }

  export type LibraryBorrowingHistoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LibraryBorrowingHistoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<LibraryBorrowingHistoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LibraryBorrowingHistoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    borrowDate?: IntWithAggregatesFilter | number
    returnDate?: IntWithAggregatesFilter | number
    actualReturnDate?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    libraryStudentId?: IntWithAggregatesFilter | number
    libraryBookCopyId?: IntWithAggregatesFilter | number
    libraryUniversityId?: IntWithAggregatesFilter | number
  }

  export type LibraryRequestWhereInput = {
    AND?: Enumerable<LibraryRequestWhereInput>
    OR?: Enumerable<LibraryRequestWhereInput>
    NOT?: Enumerable<LibraryRequestWhereInput>
    id?: IntFilter | number
    student?: XOR<LibraryStudentRelationFilter, LibraryStudentWhereInput>
    copy?: XOR<LibraryBookCopyRelationFilter, LibraryBookCopyWhereInput>
    from?: XOR<LibraryUniversityRelationFilter, LibraryUniversityWhereInput>
    to?: XOR<LibraryUniversityRelationFilter, LibraryUniversityWhereInput>
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    libraryStudentId?: IntFilter | number
    libraryBookCopyId?: IntFilter | number
    fromLibraryUniversityId?: IntFilter | number
    toLibraryUniversityId?: IntFilter | number
  }

  export type LibraryRequestOrderByWithRelationInput = {
    id?: SortOrder
    student?: LibraryStudentOrderByWithRelationInput
    copy?: LibraryBookCopyOrderByWithRelationInput
    from?: LibraryUniversityOrderByWithRelationInput
    to?: LibraryUniversityOrderByWithRelationInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
    libraryStudentId?: SortOrder
    libraryBookCopyId?: SortOrder
    fromLibraryUniversityId?: SortOrder
    toLibraryUniversityId?: SortOrder
  }

  export type LibraryRequestWhereUniqueInput = {
    id?: number
  }

  export type LibraryRequestOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    libraryStudentId?: SortOrder
    libraryBookCopyId?: SortOrder
    fromLibraryUniversityId?: SortOrder
    toLibraryUniversityId?: SortOrder
    _count?: LibraryRequestCountOrderByAggregateInput
    _avg?: LibraryRequestAvgOrderByAggregateInput
    _max?: LibraryRequestMaxOrderByAggregateInput
    _min?: LibraryRequestMinOrderByAggregateInput
    _sum?: LibraryRequestSumOrderByAggregateInput
  }

  export type LibraryRequestScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LibraryRequestScalarWhereWithAggregatesInput>
    OR?: Enumerable<LibraryRequestScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LibraryRequestScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    libraryStudentId?: IntWithAggregatesFilter | number
    libraryBookCopyId?: IntWithAggregatesFilter | number
    fromLibraryUniversityId?: IntWithAggregatesFilter | number
    toLibraryUniversityId?: IntWithAggregatesFilter | number
  }

  export type QuizCategoryWhereInput = {
    AND?: Enumerable<QuizCategoryWhereInput>
    OR?: Enumerable<QuizCategoryWhereInput>
    NOT?: Enumerable<QuizCategoryWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    QuizQuestion?: QuizQuestionListRelationFilter
    QuizRound?: QuizRoundListRelationFilter
  }

  export type QuizCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    QuizQuestion?: QuizQuestionOrderByRelationAggregateInput
    QuizRound?: QuizRoundOrderByRelationAggregateInput
  }

  export type QuizCategoryWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type QuizCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuizCategoryCountOrderByAggregateInput
    _avg?: QuizCategoryAvgOrderByAggregateInput
    _max?: QuizCategoryMaxOrderByAggregateInput
    _min?: QuizCategoryMinOrderByAggregateInput
    _sum?: QuizCategorySumOrderByAggregateInput
  }

  export type QuizCategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<QuizCategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<QuizCategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<QuizCategoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type QuizQuestionWhereInput = {
    AND?: Enumerable<QuizQuestionWhereInput>
    OR?: Enumerable<QuizQuestionWhereInput>
    NOT?: Enumerable<QuizQuestionWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    answerId?: IntFilter | number
    category?: XOR<QuizCategoryRelationFilter, QuizCategoryWhereInput> | null
    quizCategoryId?: IntNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    quizChoices?: QuizChoiceListRelationFilter
    quizRecords?: QuizRecordListRelationFilter
  }

  export type QuizQuestionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    answerId?: SortOrder
    category?: QuizCategoryOrderByWithRelationInput
    quizCategoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quizChoices?: QuizChoiceOrderByRelationAggregateInput
    quizRecords?: QuizRecordOrderByRelationAggregateInput
  }

  export type QuizQuestionWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type QuizQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    answerId?: SortOrder
    quizCategoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuizQuestionCountOrderByAggregateInput
    _avg?: QuizQuestionAvgOrderByAggregateInput
    _max?: QuizQuestionMaxOrderByAggregateInput
    _min?: QuizQuestionMinOrderByAggregateInput
    _sum?: QuizQuestionSumOrderByAggregateInput
  }

  export type QuizQuestionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<QuizQuestionScalarWhereWithAggregatesInput>
    OR?: Enumerable<QuizQuestionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<QuizQuestionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    answerId?: IntWithAggregatesFilter | number
    quizCategoryId?: IntNullableWithAggregatesFilter | number | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type QuizChoiceWhereInput = {
    AND?: Enumerable<QuizChoiceWhereInput>
    OR?: Enumerable<QuizChoiceWhereInput>
    NOT?: Enumerable<QuizChoiceWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    question?: XOR<QuizQuestionRelationFilter, QuizQuestionWhereInput> | null
    quizQuestionId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    quizRecords?: QuizRecordListRelationFilter
  }

  export type QuizChoiceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    question?: QuizQuestionOrderByWithRelationInput
    quizQuestionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quizRecords?: QuizRecordOrderByRelationAggregateInput
  }

  export type QuizChoiceWhereUniqueInput = {
    id?: number
  }

  export type QuizChoiceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    quizQuestionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuizChoiceCountOrderByAggregateInput
    _avg?: QuizChoiceAvgOrderByAggregateInput
    _max?: QuizChoiceMaxOrderByAggregateInput
    _min?: QuizChoiceMinOrderByAggregateInput
    _sum?: QuizChoiceSumOrderByAggregateInput
  }

  export type QuizChoiceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<QuizChoiceScalarWhereWithAggregatesInput>
    OR?: Enumerable<QuizChoiceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<QuizChoiceScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    quizQuestionId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type QuizRoundWhereInput = {
    AND?: Enumerable<QuizRoundWhereInput>
    OR?: Enumerable<QuizRoundWhereInput>
    NOT?: Enumerable<QuizRoundWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    totalScore?: StringFilter | string
    category?: XOR<QuizCategoryRelationFilter, QuizCategoryWhereInput> | null
    quizCategoryId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    quizRecords?: QuizRecordListRelationFilter
  }

  export type QuizRoundOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    totalScore?: SortOrder
    category?: QuizCategoryOrderByWithRelationInput
    quizCategoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quizRecords?: QuizRecordOrderByRelationAggregateInput
  }

  export type QuizRoundWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type QuizRoundOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    totalScore?: SortOrder
    quizCategoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuizRoundCountOrderByAggregateInput
    _avg?: QuizRoundAvgOrderByAggregateInput
    _max?: QuizRoundMaxOrderByAggregateInput
    _min?: QuizRoundMinOrderByAggregateInput
    _sum?: QuizRoundSumOrderByAggregateInput
  }

  export type QuizRoundScalarWhereWithAggregatesInput = {
    AND?: Enumerable<QuizRoundScalarWhereWithAggregatesInput>
    OR?: Enumerable<QuizRoundScalarWhereWithAggregatesInput>
    NOT?: Enumerable<QuizRoundScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    totalScore?: StringWithAggregatesFilter | string
    quizCategoryId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type QuizRecordWhereInput = {
    AND?: Enumerable<QuizRecordWhereInput>
    OR?: Enumerable<QuizRecordWhereInput>
    NOT?: Enumerable<QuizRecordWhereInput>
    id?: IntFilter | number
    round?: XOR<QuizRoundRelationFilter, QuizRoundWhereInput> | null
    playerChoice?: XOR<QuizChoiceRelationFilter, QuizChoiceWhereInput> | null
    question?: XOR<QuizQuestionRelationFilter, QuizQuestionWhereInput> | null
    quizRoundId?: IntFilter | number
    quizChoiceId?: IntFilter | number
    quizQuestionId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type QuizRecordOrderByWithRelationInput = {
    id?: SortOrder
    round?: QuizRoundOrderByWithRelationInput
    playerChoice?: QuizChoiceOrderByWithRelationInput
    question?: QuizQuestionOrderByWithRelationInput
    quizRoundId?: SortOrder
    quizChoiceId?: SortOrder
    quizQuestionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizRecordWhereUniqueInput = {
    id?: number
  }

  export type QuizRecordOrderByWithAggregationInput = {
    id?: SortOrder
    quizRoundId?: SortOrder
    quizChoiceId?: SortOrder
    quizQuestionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuizRecordCountOrderByAggregateInput
    _avg?: QuizRecordAvgOrderByAggregateInput
    _max?: QuizRecordMaxOrderByAggregateInput
    _min?: QuizRecordMinOrderByAggregateInput
    _sum?: QuizRecordSumOrderByAggregateInput
  }

  export type QuizRecordScalarWhereWithAggregatesInput = {
    AND?: Enumerable<QuizRecordScalarWhereWithAggregatesInput>
    OR?: Enumerable<QuizRecordScalarWhereWithAggregatesInput>
    NOT?: Enumerable<QuizRecordScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    quizRoundId?: IntWithAggregatesFilter | number
    quizChoiceId?: IntWithAggregatesFilter | number
    quizQuestionId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TodoListWhereInput = {
    AND?: Enumerable<TodoListWhereInput>
    OR?: Enumerable<TodoListWhereInput>
    NOT?: Enumerable<TodoListWhereInput>
    id?: IntFilter | number
    task?: StringFilter | string
    note?: StringNullableFilter | string | null
    status?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TodoListOrderByWithRelationInput = {
    id?: SortOrder
    task?: SortOrder
    note?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TodoListWhereUniqueInput = {
    id?: number
  }

  export type TodoListOrderByWithAggregationInput = {
    id?: SortOrder
    task?: SortOrder
    note?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TodoListCountOrderByAggregateInput
    _avg?: TodoListAvgOrderByAggregateInput
    _max?: TodoListMaxOrderByAggregateInput
    _min?: TodoListMinOrderByAggregateInput
    _sum?: TodoListSumOrderByAggregateInput
  }

  export type TodoListScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TodoListScalarWhereWithAggregatesInput>
    OR?: Enumerable<TodoListScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TodoListScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    task?: StringWithAggregatesFilter | string
    note?: StringNullableWithAggregatesFilter | string | null
    status?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TwitterUserWhereInput = {
    AND?: Enumerable<TwitterUserWhereInput>
    OR?: Enumerable<TwitterUserWhereInput>
    NOT?: Enumerable<TwitterUserWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    image?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    posts?: TwitterPostListRelationFilter
    fromDirectMessages?: TwitterDirectMessageListRelationFilter
    comments?: TwitterCommentListRelationFilter
    toDirectMessages?: TwitterDirectMessageListRelationFilter
    followingUserRelations?: TwitterUserRelationListRelationFilter
    followerUserRelations?: TwitterUserRelationListRelationFilter
  }

  export type TwitterUserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    posts?: TwitterPostOrderByRelationAggregateInput
    fromDirectMessages?: TwitterDirectMessageOrderByRelationAggregateInput
    comments?: TwitterCommentOrderByRelationAggregateInput
    toDirectMessages?: TwitterDirectMessageOrderByRelationAggregateInput
    followingUserRelations?: TwitterUserRelationOrderByRelationAggregateInput
    followerUserRelations?: TwitterUserRelationOrderByRelationAggregateInput
  }

  export type TwitterUserWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type TwitterUserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TwitterUserCountOrderByAggregateInput
    _avg?: TwitterUserAvgOrderByAggregateInput
    _max?: TwitterUserMaxOrderByAggregateInput
    _min?: TwitterUserMinOrderByAggregateInput
    _sum?: TwitterUserSumOrderByAggregateInput
  }

  export type TwitterUserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TwitterUserScalarWhereWithAggregatesInput>
    OR?: Enumerable<TwitterUserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TwitterUserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    image?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TwitterPostWhereInput = {
    AND?: Enumerable<TwitterPostWhereInput>
    OR?: Enumerable<TwitterPostWhereInput>
    NOT?: Enumerable<TwitterPostWhereInput>
    id?: IntFilter | number
    user?: XOR<TwitterUserRelationFilter, TwitterUserWhereInput>
    post?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    twitterUserId?: IntFilter | number
    postToHashtags?: TwitterPostToHashtagListRelationFilter
    comments?: TwitterCommentListRelationFilter
  }

  export type TwitterPostOrderByWithRelationInput = {
    id?: SortOrder
    user?: TwitterUserOrderByWithRelationInput
    post?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twitterUserId?: SortOrder
    postToHashtags?: TwitterPostToHashtagOrderByRelationAggregateInput
    comments?: TwitterCommentOrderByRelationAggregateInput
  }

  export type TwitterPostWhereUniqueInput = {
    id?: number
  }

  export type TwitterPostOrderByWithAggregationInput = {
    id?: SortOrder
    post?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twitterUserId?: SortOrder
    _count?: TwitterPostCountOrderByAggregateInput
    _avg?: TwitterPostAvgOrderByAggregateInput
    _max?: TwitterPostMaxOrderByAggregateInput
    _min?: TwitterPostMinOrderByAggregateInput
    _sum?: TwitterPostSumOrderByAggregateInput
  }

  export type TwitterPostScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TwitterPostScalarWhereWithAggregatesInput>
    OR?: Enumerable<TwitterPostScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TwitterPostScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    post?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    twitterUserId?: IntWithAggregatesFilter | number
  }

  export type TwitterHashtagWhereInput = {
    AND?: Enumerable<TwitterHashtagWhereInput>
    OR?: Enumerable<TwitterHashtagWhereInput>
    NOT?: Enumerable<TwitterHashtagWhereInput>
    id?: IntFilter | number
    hashtag?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    postsToHashtags?: TwitterPostToHashtagListRelationFilter
  }

  export type TwitterHashtagOrderByWithRelationInput = {
    id?: SortOrder
    hashtag?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postsToHashtags?: TwitterPostToHashtagOrderByRelationAggregateInput
  }

  export type TwitterHashtagWhereUniqueInput = {
    id?: number
  }

  export type TwitterHashtagOrderByWithAggregationInput = {
    id?: SortOrder
    hashtag?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TwitterHashtagCountOrderByAggregateInput
    _avg?: TwitterHashtagAvgOrderByAggregateInput
    _max?: TwitterHashtagMaxOrderByAggregateInput
    _min?: TwitterHashtagMinOrderByAggregateInput
    _sum?: TwitterHashtagSumOrderByAggregateInput
  }

  export type TwitterHashtagScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TwitterHashtagScalarWhereWithAggregatesInput>
    OR?: Enumerable<TwitterHashtagScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TwitterHashtagScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    hashtag?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TwitterPostToHashtagWhereInput = {
    AND?: Enumerable<TwitterPostToHashtagWhereInput>
    OR?: Enumerable<TwitterPostToHashtagWhereInput>
    NOT?: Enumerable<TwitterPostToHashtagWhereInput>
    id?: IntFilter | number
    post?: XOR<TwitterPostRelationFilter, TwitterPostWhereInput>
    hashtag?: XOR<TwitterHashtagRelationFilter, TwitterHashtagWhereInput>
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    twitterPostId?: IntFilter | number
    twitterHashtagId?: IntFilter | number
  }

  export type TwitterPostToHashtagOrderByWithRelationInput = {
    id?: SortOrder
    post?: TwitterPostOrderByWithRelationInput
    hashtag?: TwitterHashtagOrderByWithRelationInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twitterPostId?: SortOrder
    twitterHashtagId?: SortOrder
  }

  export type TwitterPostToHashtagWhereUniqueInput = {
    id?: number
  }

  export type TwitterPostToHashtagOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twitterPostId?: SortOrder
    twitterHashtagId?: SortOrder
    _count?: TwitterPostToHashtagCountOrderByAggregateInput
    _avg?: TwitterPostToHashtagAvgOrderByAggregateInput
    _max?: TwitterPostToHashtagMaxOrderByAggregateInput
    _min?: TwitterPostToHashtagMinOrderByAggregateInput
    _sum?: TwitterPostToHashtagSumOrderByAggregateInput
  }

  export type TwitterPostToHashtagScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TwitterPostToHashtagScalarWhereWithAggregatesInput>
    OR?: Enumerable<TwitterPostToHashtagScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TwitterPostToHashtagScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    twitterPostId?: IntWithAggregatesFilter | number
    twitterHashtagId?: IntWithAggregatesFilter | number
  }

  export type TwitterDirectMessageWhereInput = {
    AND?: Enumerable<TwitterDirectMessageWhereInput>
    OR?: Enumerable<TwitterDirectMessageWhereInput>
    NOT?: Enumerable<TwitterDirectMessageWhereInput>
    id?: IntFilter | number
    message?: StringFilter | string
    from?: XOR<TwitterUserRelationFilter, TwitterUserWhereInput>
    to?: XOR<TwitterUserRelationFilter, TwitterUserWhereInput>
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    followingUserId?: IntFilter | number
    followerUserId?: IntFilter | number
  }

  export type TwitterDirectMessageOrderByWithRelationInput = {
    id?: SortOrder
    message?: SortOrder
    from?: TwitterUserOrderByWithRelationInput
    to?: TwitterUserOrderByWithRelationInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
    followingUserId?: SortOrder
    followerUserId?: SortOrder
  }

  export type TwitterDirectMessageWhereUniqueInput = {
    id?: number
  }

  export type TwitterDirectMessageOrderByWithAggregationInput = {
    id?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    followingUserId?: SortOrder
    followerUserId?: SortOrder
    _count?: TwitterDirectMessageCountOrderByAggregateInput
    _avg?: TwitterDirectMessageAvgOrderByAggregateInput
    _max?: TwitterDirectMessageMaxOrderByAggregateInput
    _min?: TwitterDirectMessageMinOrderByAggregateInput
    _sum?: TwitterDirectMessageSumOrderByAggregateInput
  }

  export type TwitterDirectMessageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TwitterDirectMessageScalarWhereWithAggregatesInput>
    OR?: Enumerable<TwitterDirectMessageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TwitterDirectMessageScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    message?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    followingUserId?: IntWithAggregatesFilter | number
    followerUserId?: IntWithAggregatesFilter | number
  }

  export type TwitterUserRelationWhereInput = {
    AND?: Enumerable<TwitterUserRelationWhereInput>
    OR?: Enumerable<TwitterUserRelationWhereInput>
    NOT?: Enumerable<TwitterUserRelationWhereInput>
    id?: IntFilter | number
    from?: XOR<TwitterUserRelationFilter, TwitterUserWhereInput>
    to?: XOR<TwitterUserRelationFilter, TwitterUserWhereInput>
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    fromUserId?: IntFilter | number
    toUserId?: IntFilter | number
  }

  export type TwitterUserRelationOrderByWithRelationInput = {
    id?: SortOrder
    from?: TwitterUserOrderByWithRelationInput
    to?: TwitterUserOrderByWithRelationInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
  }

  export type TwitterUserRelationWhereUniqueInput = {
    id?: number
  }

  export type TwitterUserRelationOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    _count?: TwitterUserRelationCountOrderByAggregateInput
    _avg?: TwitterUserRelationAvgOrderByAggregateInput
    _max?: TwitterUserRelationMaxOrderByAggregateInput
    _min?: TwitterUserRelationMinOrderByAggregateInput
    _sum?: TwitterUserRelationSumOrderByAggregateInput
  }

  export type TwitterUserRelationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TwitterUserRelationScalarWhereWithAggregatesInput>
    OR?: Enumerable<TwitterUserRelationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TwitterUserRelationScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    fromUserId?: IntWithAggregatesFilter | number
    toUserId?: IntWithAggregatesFilter | number
  }

  export type TwitterCommentWhereInput = {
    AND?: Enumerable<TwitterCommentWhereInput>
    OR?: Enumerable<TwitterCommentWhereInput>
    NOT?: Enumerable<TwitterCommentWhereInput>
    id?: IntFilter | number
    post?: XOR<TwitterPostRelationFilter, TwitterPostWhereInput>
    user?: XOR<TwitterUserRelationFilter, TwitterUserWhereInput>
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    twitterPostId?: IntFilter | number
    twitterUserId?: IntFilter | number
  }

  export type TwitterCommentOrderByWithRelationInput = {
    id?: SortOrder
    post?: TwitterPostOrderByWithRelationInput
    user?: TwitterUserOrderByWithRelationInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twitterPostId?: SortOrder
    twitterUserId?: SortOrder
  }

  export type TwitterCommentWhereUniqueInput = {
    id?: number
  }

  export type TwitterCommentOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twitterPostId?: SortOrder
    twitterUserId?: SortOrder
    _count?: TwitterCommentCountOrderByAggregateInput
    _avg?: TwitterCommentAvgOrderByAggregateInput
    _max?: TwitterCommentMaxOrderByAggregateInput
    _min?: TwitterCommentMinOrderByAggregateInput
    _sum?: TwitterCommentSumOrderByAggregateInput
  }

  export type TwitterCommentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TwitterCommentScalarWhereWithAggregatesInput>
    OR?: Enumerable<TwitterCommentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TwitterCommentScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    twitterPostId?: IntWithAggregatesFilter | number
    twitterUserId?: IntWithAggregatesFilter | number
  }

  export type YoutubeUserWhereInput = {
    AND?: Enumerable<YoutubeUserWhereInput>
    OR?: Enumerable<YoutubeUserWhereInput>
    NOT?: Enumerable<YoutubeUserWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    email?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    youtubeUsersToChannels?: YoutubeUserToChannelListRelationFilter
    youtubeSubscriptions?: YoutubeSubscriptionListRelationFilter
    YoutubeReaction?: YoutubeReactionListRelationFilter
    YoutubeComment?: YoutubeCommentListRelationFilter
    YoutubeCommentReaction?: YoutubeCommentReactionListRelationFilter
  }

  export type YoutubeUserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    youtubeUsersToChannels?: YoutubeUserToChannelOrderByRelationAggregateInput
    youtubeSubscriptions?: YoutubeSubscriptionOrderByRelationAggregateInput
    YoutubeReaction?: YoutubeReactionOrderByRelationAggregateInput
    YoutubeComment?: YoutubeCommentOrderByRelationAggregateInput
    YoutubeCommentReaction?: YoutubeCommentReactionOrderByRelationAggregateInput
  }

  export type YoutubeUserWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type YoutubeUserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: YoutubeUserCountOrderByAggregateInput
    _avg?: YoutubeUserAvgOrderByAggregateInput
    _max?: YoutubeUserMaxOrderByAggregateInput
    _min?: YoutubeUserMinOrderByAggregateInput
    _sum?: YoutubeUserSumOrderByAggregateInput
  }

  export type YoutubeUserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<YoutubeUserScalarWhereWithAggregatesInput>
    OR?: Enumerable<YoutubeUserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<YoutubeUserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type YoutubeChannelWhereInput = {
    AND?: Enumerable<YoutubeChannelWhereInput>
    OR?: Enumerable<YoutubeChannelWhereInput>
    NOT?: Enumerable<YoutubeChannelWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    youtubeUsersToChannels?: YoutubeUserToChannelListRelationFilter
    youtubeVideos?: YoutubeVideoListRelationFilter
    youtubeSubscriptions?: YoutubeSubscriptionListRelationFilter
  }

  export type YoutubeChannelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    youtubeUsersToChannels?: YoutubeUserToChannelOrderByRelationAggregateInput
    youtubeVideos?: YoutubeVideoOrderByRelationAggregateInput
    youtubeSubscriptions?: YoutubeSubscriptionOrderByRelationAggregateInput
  }

  export type YoutubeChannelWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type YoutubeChannelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: YoutubeChannelCountOrderByAggregateInput
    _avg?: YoutubeChannelAvgOrderByAggregateInput
    _max?: YoutubeChannelMaxOrderByAggregateInput
    _min?: YoutubeChannelMinOrderByAggregateInput
    _sum?: YoutubeChannelSumOrderByAggregateInput
  }

  export type YoutubeChannelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<YoutubeChannelScalarWhereWithAggregatesInput>
    OR?: Enumerable<YoutubeChannelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<YoutubeChannelScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type YoutubeSubscriptionWhereInput = {
    AND?: Enumerable<YoutubeSubscriptionWhereInput>
    OR?: Enumerable<YoutubeSubscriptionWhereInput>
    NOT?: Enumerable<YoutubeSubscriptionWhereInput>
    id?: IntFilter | number
    user?: XOR<YoutubeUserRelationFilter, YoutubeUserWhereInput>
    channel?: XOR<YoutubeChannelRelationFilter, YoutubeChannelWhereInput>
    membership?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    youtubeUserId?: IntFilter | number
    youtubeChannelId?: IntFilter | number
  }

  export type YoutubeSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    user?: YoutubeUserOrderByWithRelationInput
    channel?: YoutubeChannelOrderByWithRelationInput
    membership?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    youtubeUserId?: SortOrder
    youtubeChannelId?: SortOrder
  }

  export type YoutubeSubscriptionWhereUniqueInput = {
    id?: number
  }

  export type YoutubeSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    membership?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    youtubeUserId?: SortOrder
    youtubeChannelId?: SortOrder
    _count?: YoutubeSubscriptionCountOrderByAggregateInput
    _avg?: YoutubeSubscriptionAvgOrderByAggregateInput
    _max?: YoutubeSubscriptionMaxOrderByAggregateInput
    _min?: YoutubeSubscriptionMinOrderByAggregateInput
    _sum?: YoutubeSubscriptionSumOrderByAggregateInput
  }

  export type YoutubeSubscriptionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<YoutubeSubscriptionScalarWhereWithAggregatesInput>
    OR?: Enumerable<YoutubeSubscriptionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<YoutubeSubscriptionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    membership?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    youtubeUserId?: IntWithAggregatesFilter | number
    youtubeChannelId?: IntWithAggregatesFilter | number
  }

  export type YoutubeUserToChannelWhereInput = {
    AND?: Enumerable<YoutubeUserToChannelWhereInput>
    OR?: Enumerable<YoutubeUserToChannelWhereInput>
    NOT?: Enumerable<YoutubeUserToChannelWhereInput>
    id?: IntFilter | number
    user?: XOR<YoutubeUserRelationFilter, YoutubeUserWhereInput>
    channel?: XOR<YoutubeChannelRelationFilter, YoutubeChannelWhereInput>
    description?: StringFilter | string
    role?: EnumRoleEnumFilter | RoleEnum
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    youtubeUserId?: IntFilter | number
    youtubeChannelId?: IntFilter | number
  }

  export type YoutubeUserToChannelOrderByWithRelationInput = {
    id?: SortOrder
    user?: YoutubeUserOrderByWithRelationInput
    channel?: YoutubeChannelOrderByWithRelationInput
    description?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    youtubeUserId?: SortOrder
    youtubeChannelId?: SortOrder
  }

  export type YoutubeUserToChannelWhereUniqueInput = {
    id?: number
  }

  export type YoutubeUserToChannelOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    youtubeUserId?: SortOrder
    youtubeChannelId?: SortOrder
    _count?: YoutubeUserToChannelCountOrderByAggregateInput
    _avg?: YoutubeUserToChannelAvgOrderByAggregateInput
    _max?: YoutubeUserToChannelMaxOrderByAggregateInput
    _min?: YoutubeUserToChannelMinOrderByAggregateInput
    _sum?: YoutubeUserToChannelSumOrderByAggregateInput
  }

  export type YoutubeUserToChannelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<YoutubeUserToChannelScalarWhereWithAggregatesInput>
    OR?: Enumerable<YoutubeUserToChannelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<YoutubeUserToChannelScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    description?: StringWithAggregatesFilter | string
    role?: EnumRoleEnumWithAggregatesFilter | RoleEnum
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    youtubeUserId?: IntWithAggregatesFilter | number
    youtubeChannelId?: IntWithAggregatesFilter | number
  }

  export type YoutubeVideoWhereInput = {
    AND?: Enumerable<YoutubeVideoWhereInput>
    OR?: Enumerable<YoutubeVideoWhereInput>
    NOT?: Enumerable<YoutubeVideoWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    videoUrl?: StringFilter | string
    description?: StringFilter | string
    channel?: XOR<YoutubeChannelRelationFilter, YoutubeChannelWhereInput>
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    youtubeChannelId?: IntFilter | number
    youtubeComments?: YoutubeCommentListRelationFilter
    youtubeReactions?: YoutubeReactionListRelationFilter
  }

  export type YoutubeVideoOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    videoUrl?: SortOrder
    description?: SortOrder
    channel?: YoutubeChannelOrderByWithRelationInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
    youtubeChannelId?: SortOrder
    youtubeComments?: YoutubeCommentOrderByRelationAggregateInput
    youtubeReactions?: YoutubeReactionOrderByRelationAggregateInput
  }

  export type YoutubeVideoWhereUniqueInput = {
    id?: number
  }

  export type YoutubeVideoOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    videoUrl?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    youtubeChannelId?: SortOrder
    _count?: YoutubeVideoCountOrderByAggregateInput
    _avg?: YoutubeVideoAvgOrderByAggregateInput
    _max?: YoutubeVideoMaxOrderByAggregateInput
    _min?: YoutubeVideoMinOrderByAggregateInput
    _sum?: YoutubeVideoSumOrderByAggregateInput
  }

  export type YoutubeVideoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<YoutubeVideoScalarWhereWithAggregatesInput>
    OR?: Enumerable<YoutubeVideoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<YoutubeVideoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    videoUrl?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    youtubeChannelId?: IntWithAggregatesFilter | number
  }

  export type YoutubeReactionWhereInput = {
    AND?: Enumerable<YoutubeReactionWhereInput>
    OR?: Enumerable<YoutubeReactionWhereInput>
    NOT?: Enumerable<YoutubeReactionWhereInput>
    id?: IntFilter | number
    user?: XOR<YoutubeUserRelationFilter, YoutubeUserWhereInput>
    video?: XOR<YoutubeVideoRelationFilter, YoutubeVideoWhereInput>
    reaction?: EnumReactionEnumFilter | ReactionEnum
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    youtubeUserId?: IntFilter | number
    youtubeChannelId?: IntFilter | number
    youtubeVideoId?: IntFilter | number
    youtubeCommentId?: IntFilter | number
  }

  export type YoutubeReactionOrderByWithRelationInput = {
    id?: SortOrder
    user?: YoutubeUserOrderByWithRelationInput
    video?: YoutubeVideoOrderByWithRelationInput
    reaction?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    youtubeUserId?: SortOrder
    youtubeChannelId?: SortOrder
    youtubeVideoId?: SortOrder
    youtubeCommentId?: SortOrder
  }

  export type YoutubeReactionWhereUniqueInput = {
    id?: number
  }

  export type YoutubeReactionOrderByWithAggregationInput = {
    id?: SortOrder
    reaction?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    youtubeUserId?: SortOrder
    youtubeChannelId?: SortOrder
    youtubeVideoId?: SortOrder
    youtubeCommentId?: SortOrder
    _count?: YoutubeReactionCountOrderByAggregateInput
    _avg?: YoutubeReactionAvgOrderByAggregateInput
    _max?: YoutubeReactionMaxOrderByAggregateInput
    _min?: YoutubeReactionMinOrderByAggregateInput
    _sum?: YoutubeReactionSumOrderByAggregateInput
  }

  export type YoutubeReactionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<YoutubeReactionScalarWhereWithAggregatesInput>
    OR?: Enumerable<YoutubeReactionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<YoutubeReactionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    reaction?: EnumReactionEnumWithAggregatesFilter | ReactionEnum
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    youtubeUserId?: IntWithAggregatesFilter | number
    youtubeChannelId?: IntWithAggregatesFilter | number
    youtubeVideoId?: IntWithAggregatesFilter | number
    youtubeCommentId?: IntWithAggregatesFilter | number
  }

  export type YoutubeCommentWhereInput = {
    AND?: Enumerable<YoutubeCommentWhereInput>
    OR?: Enumerable<YoutubeCommentWhereInput>
    NOT?: Enumerable<YoutubeCommentWhereInput>
    id?: IntFilter | number
    comment?: StringFilter | string
    user?: XOR<YoutubeUserRelationFilter, YoutubeUserWhereInput>
    video?: XOR<YoutubeVideoRelationFilter, YoutubeVideoWhereInput>
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    youtubeVideoId?: IntFilter | number
    youtubeUserId?: IntFilter | number
    youtubeCommentReactions?: YoutubeCommentReactionListRelationFilter
  }

  export type YoutubeCommentOrderByWithRelationInput = {
    id?: SortOrder
    comment?: SortOrder
    user?: YoutubeUserOrderByWithRelationInput
    video?: YoutubeVideoOrderByWithRelationInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
    youtubeVideoId?: SortOrder
    youtubeUserId?: SortOrder
    youtubeCommentReactions?: YoutubeCommentReactionOrderByRelationAggregateInput
  }

  export type YoutubeCommentWhereUniqueInput = {
    id?: number
  }

  export type YoutubeCommentOrderByWithAggregationInput = {
    id?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    youtubeVideoId?: SortOrder
    youtubeUserId?: SortOrder
    _count?: YoutubeCommentCountOrderByAggregateInput
    _avg?: YoutubeCommentAvgOrderByAggregateInput
    _max?: YoutubeCommentMaxOrderByAggregateInput
    _min?: YoutubeCommentMinOrderByAggregateInput
    _sum?: YoutubeCommentSumOrderByAggregateInput
  }

  export type YoutubeCommentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<YoutubeCommentScalarWhereWithAggregatesInput>
    OR?: Enumerable<YoutubeCommentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<YoutubeCommentScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    comment?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    youtubeVideoId?: IntWithAggregatesFilter | number
    youtubeUserId?: IntWithAggregatesFilter | number
  }

  export type YoutubeCommentReactionWhereInput = {
    AND?: Enumerable<YoutubeCommentReactionWhereInput>
    OR?: Enumerable<YoutubeCommentReactionWhereInput>
    NOT?: Enumerable<YoutubeCommentReactionWhereInput>
    id?: IntFilter | number
    user?: XOR<YoutubeUserRelationFilter, YoutubeUserWhereInput>
    comment?: XOR<YoutubeCommentRelationFilter, YoutubeCommentWhereInput>
    reaction?: EnumReactionEnumFilter | ReactionEnum
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    youtubeUserId?: IntFilter | number
    youtubeChannelId?: IntFilter | number
    youtubeVideoId?: IntFilter | number
    youtubeCommentId?: IntFilter | number
  }

  export type YoutubeCommentReactionOrderByWithRelationInput = {
    id?: SortOrder
    user?: YoutubeUserOrderByWithRelationInput
    comment?: YoutubeCommentOrderByWithRelationInput
    reaction?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    youtubeUserId?: SortOrder
    youtubeChannelId?: SortOrder
    youtubeVideoId?: SortOrder
    youtubeCommentId?: SortOrder
  }

  export type YoutubeCommentReactionWhereUniqueInput = {
    id?: number
  }

  export type YoutubeCommentReactionOrderByWithAggregationInput = {
    id?: SortOrder
    reaction?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    youtubeUserId?: SortOrder
    youtubeChannelId?: SortOrder
    youtubeVideoId?: SortOrder
    youtubeCommentId?: SortOrder
    _count?: YoutubeCommentReactionCountOrderByAggregateInput
    _avg?: YoutubeCommentReactionAvgOrderByAggregateInput
    _max?: YoutubeCommentReactionMaxOrderByAggregateInput
    _min?: YoutubeCommentReactionMinOrderByAggregateInput
    _sum?: YoutubeCommentReactionSumOrderByAggregateInput
  }

  export type YoutubeCommentReactionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<YoutubeCommentReactionScalarWhereWithAggregatesInput>
    OR?: Enumerable<YoutubeCommentReactionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<YoutubeCommentReactionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    reaction?: EnumReactionEnumWithAggregatesFilter | ReactionEnum
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    youtubeUserId?: IntWithAggregatesFilter | number
    youtubeChannelId?: IntWithAggregatesFilter | number
    youtubeVideoId?: IntWithAggregatesFilter | number
    youtubeCommentId?: IntWithAggregatesFilter | number
  }

  export type BinKitchenCategoryCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    menus?: BinKitchenMenuCreateNestedManyWithoutCategoryInput
  }

  export type BinKitchenCategoryUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    menus?: BinKitchenMenuUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type BinKitchenCategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menus?: BinKitchenMenuUpdateManyWithoutCategoryNestedInput
  }

  export type BinKitchenCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menus?: BinKitchenMenuUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type BinKitchenCategoryCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinKitchenCategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinKitchenCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinKitchenMenuCreateInput = {
    name: string
    image: string
    price: number
    category?: BinKitchenCategoryCreateNestedOneWithoutMenusInput
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: BinKitchenOrderItemCreateNestedManyWithoutMenuInput
  }

  export type BinKitchenMenuUncheckedCreateInput = {
    id?: number
    name: string
    image: string
    price: number
    categoryName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: BinKitchenOrderItemUncheckedCreateNestedManyWithoutMenuInput
  }

  export type BinKitchenMenuUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    category?: BinKitchenCategoryUpdateOneWithoutMenusNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: BinKitchenOrderItemUpdateManyWithoutMenuNestedInput
  }

  export type BinKitchenMenuUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    categoryName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: BinKitchenOrderItemUncheckedUpdateManyWithoutMenuNestedInput
  }

  export type BinKitchenMenuCreateManyInput = {
    id?: number
    name: string
    image: string
    price: number
    categoryName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinKitchenMenuUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinKitchenMenuUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    categoryName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinKitchenOrderCreateInput = {
    tableId: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: BinKitchenOrderItemCreateNestedManyWithoutOrderInput
  }

  export type BinKitchenOrderUncheckedCreateInput = {
    id?: number
    tableId: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: BinKitchenOrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type BinKitchenOrderUpdateInput = {
    tableId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: BinKitchenOrderItemUpdateManyWithoutOrderNestedInput
  }

  export type BinKitchenOrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tableId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: BinKitchenOrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type BinKitchenOrderCreateManyInput = {
    id?: number
    tableId: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinKitchenOrderUpdateManyMutationInput = {
    tableId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinKitchenOrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tableId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinKitchenOrderItemCreateInput = {
    menu: BinKitchenMenuCreateNestedOneWithoutItemsInput
    order: BinKitchenOrderCreateNestedOneWithoutItemsInput
    quantity: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinKitchenOrderItemUncheckedCreateInput = {
    id?: number
    quantity: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
    menuId: number
    orderId: number
  }

  export type BinKitchenOrderItemUpdateInput = {
    menu?: BinKitchenMenuUpdateOneRequiredWithoutItemsNestedInput
    order?: BinKitchenOrderUpdateOneRequiredWithoutItemsNestedInput
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinKitchenOrderItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menuId?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
  }

  export type BinKitchenOrderItemCreateManyInput = {
    id?: number
    quantity: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
    menuId: number
    orderId: number
  }

  export type BinKitchenOrderItemUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinKitchenOrderItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menuId?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
  }

  export type LaundryBranchCreateInput = {
    name: string
    machineAmount: number
    owner: string
    tel: number
    location: string
    areaSize: number
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryWashingMachines?: LaundryWashingMachineCreateNestedManyWithoutBranchInput
  }

  export type LaundryBranchUncheckedCreateInput = {
    id?: number
    name: string
    machineAmount: number
    owner: string
    tel: number
    location: string
    areaSize: number
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryWashingMachines?: LaundryWashingMachineUncheckedCreateNestedManyWithoutBranchInput
  }

  export type LaundryBranchUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    machineAmount?: IntFieldUpdateOperationsInput | number
    owner?: StringFieldUpdateOperationsInput | string
    tel?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    areaSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryWashingMachines?: LaundryWashingMachineUpdateManyWithoutBranchNestedInput
  }

  export type LaundryBranchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    machineAmount?: IntFieldUpdateOperationsInput | number
    owner?: StringFieldUpdateOperationsInput | string
    tel?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    areaSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryWashingMachines?: LaundryWashingMachineUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type LaundryBranchCreateManyInput = {
    id?: number
    name: string
    machineAmount: number
    owner: string
    tel: number
    location: string
    areaSize: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryBranchUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    machineAmount?: IntFieldUpdateOperationsInput | number
    owner?: StringFieldUpdateOperationsInput | string
    tel?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    areaSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryBranchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    machineAmount?: IntFieldUpdateOperationsInput | number
    owner?: StringFieldUpdateOperationsInput | string
    tel?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    areaSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryWashingMachineCreateInput = {
    branch: LaundryBranchCreateNestedOneWithoutLaundryWashingMachinesInput
    brand: string
    variant: string
    size: number
    machineType: string
    yearManufactured: number
    insuranceExpiryYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryWashingMachinesToPrograms?: LaundryWashingMachineToProgramCreateNestedManyWithoutMachineInput
    laundryMaintainances?: LaundryMaintainanceCreateNestedManyWithoutMachineInput
    laundryUserHistories?: LaundryUserHistoryCreateNestedManyWithoutMachineInput
  }

  export type LaundryWashingMachineUncheckedCreateInput = {
    id?: number
    brand: string
    variant: string
    size: number
    machineType: string
    yearManufactured: number
    insuranceExpiryYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryBranchId: number
    laundryWashingMachinesToPrograms?: LaundryWashingMachineToProgramUncheckedCreateNestedManyWithoutMachineInput
    laundryMaintainances?: LaundryMaintainanceUncheckedCreateNestedManyWithoutMachineInput
    laundryUserHistories?: LaundryUserHistoryUncheckedCreateNestedManyWithoutMachineInput
  }

  export type LaundryWashingMachineUpdateInput = {
    branch?: LaundryBranchUpdateOneRequiredWithoutLaundryWashingMachinesNestedInput
    brand?: StringFieldUpdateOperationsInput | string
    variant?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    machineType?: StringFieldUpdateOperationsInput | string
    yearManufactured?: IntFieldUpdateOperationsInput | number
    insuranceExpiryYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryWashingMachinesToPrograms?: LaundryWashingMachineToProgramUpdateManyWithoutMachineNestedInput
    laundryMaintainances?: LaundryMaintainanceUpdateManyWithoutMachineNestedInput
    laundryUserHistories?: LaundryUserHistoryUpdateManyWithoutMachineNestedInput
  }

  export type LaundryWashingMachineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand?: StringFieldUpdateOperationsInput | string
    variant?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    machineType?: StringFieldUpdateOperationsInput | string
    yearManufactured?: IntFieldUpdateOperationsInput | number
    insuranceExpiryYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryBranchId?: IntFieldUpdateOperationsInput | number
    laundryWashingMachinesToPrograms?: LaundryWashingMachineToProgramUncheckedUpdateManyWithoutMachineNestedInput
    laundryMaintainances?: LaundryMaintainanceUncheckedUpdateManyWithoutMachineNestedInput
    laundryUserHistories?: LaundryUserHistoryUncheckedUpdateManyWithoutMachineNestedInput
  }

  export type LaundryWashingMachineCreateManyInput = {
    id?: number
    brand: string
    variant: string
    size: number
    machineType: string
    yearManufactured: number
    insuranceExpiryYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryBranchId: number
  }

  export type LaundryWashingMachineUpdateManyMutationInput = {
    brand?: StringFieldUpdateOperationsInput | string
    variant?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    machineType?: StringFieldUpdateOperationsInput | string
    yearManufactured?: IntFieldUpdateOperationsInput | number
    insuranceExpiryYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryWashingMachineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand?: StringFieldUpdateOperationsInput | string
    variant?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    machineType?: StringFieldUpdateOperationsInput | string
    yearManufactured?: IntFieldUpdateOperationsInput | number
    insuranceExpiryYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryBranchId?: IntFieldUpdateOperationsInput | number
  }

  export type LaundryProgramCreateInput = {
    name: string
    price: number
    duration: number
    weight: number
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryWashingMachinesToPrograms?: LaundryWashingMachineToProgramCreateNestedManyWithoutProgramInput
    laundryUserHistories?: LaundryUserHistoryCreateNestedManyWithoutProgramInput
  }

  export type LaundryProgramUncheckedCreateInput = {
    id?: number
    name: string
    price: number
    duration: number
    weight: number
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryWashingMachinesToPrograms?: LaundryWashingMachineToProgramUncheckedCreateNestedManyWithoutProgramInput
    laundryUserHistories?: LaundryUserHistoryUncheckedCreateNestedManyWithoutProgramInput
  }

  export type LaundryProgramUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    weight?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryWashingMachinesToPrograms?: LaundryWashingMachineToProgramUpdateManyWithoutProgramNestedInput
    laundryUserHistories?: LaundryUserHistoryUpdateManyWithoutProgramNestedInput
  }

  export type LaundryProgramUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    weight?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryWashingMachinesToPrograms?: LaundryWashingMachineToProgramUncheckedUpdateManyWithoutProgramNestedInput
    laundryUserHistories?: LaundryUserHistoryUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type LaundryProgramCreateManyInput = {
    id?: number
    name: string
    price: number
    duration: number
    weight: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryProgramUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    weight?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryProgramUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    weight?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryWashingMachineToProgramCreateInput = {
    machine: LaundryWashingMachineCreateNestedOneWithoutLaundryWashingMachinesToProgramsInput
    program: LaundryProgramCreateNestedOneWithoutLaundryWashingMachinesToProgramsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryWashingMachineToProgramUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryWashingMachineId: number
    laundryProgramId: number
  }

  export type LaundryWashingMachineToProgramUpdateInput = {
    machine?: LaundryWashingMachineUpdateOneRequiredWithoutLaundryWashingMachinesToProgramsNestedInput
    program?: LaundryProgramUpdateOneRequiredWithoutLaundryWashingMachinesToProgramsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryWashingMachineToProgramUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryWashingMachineId?: IntFieldUpdateOperationsInput | number
    laundryProgramId?: IntFieldUpdateOperationsInput | number
  }

  export type LaundryWashingMachineToProgramCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryWashingMachineId: number
    laundryProgramId: number
  }

  export type LaundryWashingMachineToProgramUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryWashingMachineToProgramUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryWashingMachineId?: IntFieldUpdateOperationsInput | number
    laundryProgramId?: IntFieldUpdateOperationsInput | number
  }

  export type LaundryMaintainanceCreateInput = {
    round: number
    machine: LaundryWashingMachineCreateNestedOneWithoutLaundryMaintainancesInput
    date: number
    damageLevel: number
    description: string
    technicianName: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryMaintainanceUncheckedCreateInput = {
    id?: number
    round: number
    date: number
    damageLevel: number
    description: string
    technicianName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryWashingMachineId: number
  }

  export type LaundryMaintainanceUpdateInput = {
    round?: IntFieldUpdateOperationsInput | number
    machine?: LaundryWashingMachineUpdateOneRequiredWithoutLaundryMaintainancesNestedInput
    date?: IntFieldUpdateOperationsInput | number
    damageLevel?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    technicianName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryMaintainanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    round?: IntFieldUpdateOperationsInput | number
    date?: IntFieldUpdateOperationsInput | number
    damageLevel?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    technicianName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryWashingMachineId?: IntFieldUpdateOperationsInput | number
  }

  export type LaundryMaintainanceCreateManyInput = {
    id?: number
    round: number
    date: number
    damageLevel: number
    description: string
    technicianName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryWashingMachineId: number
  }

  export type LaundryMaintainanceUpdateManyMutationInput = {
    round?: IntFieldUpdateOperationsInput | number
    date?: IntFieldUpdateOperationsInput | number
    damageLevel?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    technicianName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryMaintainanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    round?: IntFieldUpdateOperationsInput | number
    date?: IntFieldUpdateOperationsInput | number
    damageLevel?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    technicianName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryWashingMachineId?: IntFieldUpdateOperationsInput | number
  }

  export type LaundryUserCreateInput = {
    name: string
    tel: number
    balance: number
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryUserHistories?: LaundryUserHistoryCreateNestedManyWithoutUserInput
    laundryBalanceTopups?: LaundryBalanceTopupCreateNestedManyWithoutUserInput
  }

  export type LaundryUserUncheckedCreateInput = {
    id?: number
    name: string
    tel: number
    balance: number
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryUserHistories?: LaundryUserHistoryUncheckedCreateNestedManyWithoutUserInput
    laundryBalanceTopups?: LaundryBalanceTopupUncheckedCreateNestedManyWithoutUserInput
  }

  export type LaundryUserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    tel?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryUserHistories?: LaundryUserHistoryUpdateManyWithoutUserNestedInput
    laundryBalanceTopups?: LaundryBalanceTopupUpdateManyWithoutUserNestedInput
  }

  export type LaundryUserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tel?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryUserHistories?: LaundryUserHistoryUncheckedUpdateManyWithoutUserNestedInput
    laundryBalanceTopups?: LaundryBalanceTopupUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LaundryUserCreateManyInput = {
    id?: number
    name: string
    tel: number
    balance: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryUserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    tel?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryUserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tel?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryUserHistoryCreateInput = {
    user: LaundryUserCreateNestedOneWithoutLaundryUserHistoriesInput
    washNumber: number
    machine: LaundryWashingMachineCreateNestedOneWithoutLaundryUserHistoriesInput
    program: LaundryProgramCreateNestedOneWithoutLaundryUserHistoriesInput
    date: number
    duration: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryUserHistoryUncheckedCreateInput = {
    id?: number
    washNumber: number
    date: number
    duration: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryUserId: number
    laundryWashingMachineId: number
    laundryProgramId: number
  }

  export type LaundryUserHistoryUpdateInput = {
    user?: LaundryUserUpdateOneRequiredWithoutLaundryUserHistoriesNestedInput
    washNumber?: IntFieldUpdateOperationsInput | number
    machine?: LaundryWashingMachineUpdateOneRequiredWithoutLaundryUserHistoriesNestedInput
    program?: LaundryProgramUpdateOneRequiredWithoutLaundryUserHistoriesNestedInput
    date?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryUserHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    washNumber?: IntFieldUpdateOperationsInput | number
    date?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryUserId?: IntFieldUpdateOperationsInput | number
    laundryWashingMachineId?: IntFieldUpdateOperationsInput | number
    laundryProgramId?: IntFieldUpdateOperationsInput | number
  }

  export type LaundryUserHistoryCreateManyInput = {
    id?: number
    washNumber: number
    date: number
    duration: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryUserId: number
    laundryWashingMachineId: number
    laundryProgramId: number
  }

  export type LaundryUserHistoryUpdateManyMutationInput = {
    washNumber?: IntFieldUpdateOperationsInput | number
    date?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryUserHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    washNumber?: IntFieldUpdateOperationsInput | number
    date?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryUserId?: IntFieldUpdateOperationsInput | number
    laundryWashingMachineId?: IntFieldUpdateOperationsInput | number
    laundryProgramId?: IntFieldUpdateOperationsInput | number
  }

  export type LaundryBalanceTopupCreateInput = {
    user: LaundryUserCreateNestedOneWithoutLaundryBalanceTopupsInput
    topUpRound: number
    topUpAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryBalanceTopupUncheckedCreateInput = {
    id?: number
    topUpRound: number
    topUpAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryUserId: number
  }

  export type LaundryBalanceTopupUpdateInput = {
    user?: LaundryUserUpdateOneRequiredWithoutLaundryBalanceTopupsNestedInput
    topUpRound?: IntFieldUpdateOperationsInput | number
    topUpAmount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryBalanceTopupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    topUpRound?: IntFieldUpdateOperationsInput | number
    topUpAmount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryUserId?: IntFieldUpdateOperationsInput | number
  }

  export type LaundryBalanceTopupCreateManyInput = {
    id?: number
    topUpRound: number
    topUpAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryUserId: number
  }

  export type LaundryBalanceTopupUpdateManyMutationInput = {
    topUpRound?: IntFieldUpdateOperationsInput | number
    topUpAmount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryBalanceTopupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    topUpRound?: IntFieldUpdateOperationsInput | number
    topUpAmount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryUserId?: IntFieldUpdateOperationsInput | number
  }

  export type LibraryBookCategoryCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryCategoriesToBooks?: LibraryCategoryToBookCreateNestedManyWithoutCategoryInput
  }

  export type LibraryBookCategoryUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryCategoriesToBooks?: LibraryCategoryToBookUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type LibraryBookCategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryCategoriesToBooks?: LibraryCategoryToBookUpdateManyWithoutCategoryNestedInput
  }

  export type LibraryBookCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryCategoriesToBooks?: LibraryCategoryToBookUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type LibraryBookCategoryCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBookCategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookCreateInput = {
    name: string
    ISBN: number
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryCategoriesToBooks?: LibraryCategoryToBookCreateNestedManyWithoutBookInput
    libraryBooksToAuthors?: LibraryBookToAuthorCreateNestedManyWithoutBookInput
    libraryBookCopies?: LibraryBookCopyCreateNestedManyWithoutBookInput
  }

  export type LibraryBookUncheckedCreateInput = {
    id?: number
    name: string
    ISBN: number
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryCategoriesToBooks?: LibraryCategoryToBookUncheckedCreateNestedManyWithoutBookInput
    libraryBooksToAuthors?: LibraryBookToAuthorUncheckedCreateNestedManyWithoutBookInput
    libraryBookCopies?: LibraryBookCopyUncheckedCreateNestedManyWithoutBookInput
  }

  export type LibraryBookUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    ISBN?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryCategoriesToBooks?: LibraryCategoryToBookUpdateManyWithoutBookNestedInput
    libraryBooksToAuthors?: LibraryBookToAuthorUpdateManyWithoutBookNestedInput
    libraryBookCopies?: LibraryBookCopyUpdateManyWithoutBookNestedInput
  }

  export type LibraryBookUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    ISBN?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryCategoriesToBooks?: LibraryCategoryToBookUncheckedUpdateManyWithoutBookNestedInput
    libraryBooksToAuthors?: LibraryBookToAuthorUncheckedUpdateManyWithoutBookNestedInput
    libraryBookCopies?: LibraryBookCopyUncheckedUpdateManyWithoutBookNestedInput
  }

  export type LibraryBookCreateManyInput = {
    id?: number
    name: string
    ISBN: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBookUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    ISBN?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    ISBN?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryCategoryToBookCreateInput = {
    category: LibraryBookCategoryCreateNestedOneWithoutLibraryCategoriesToBooksInput
    book: LibraryBookCreateNestedOneWithoutLibraryCategoriesToBooksInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryCategoryToBookUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryBookCategoryId: number
    libraryBookId: number
  }

  export type LibraryCategoryToBookUpdateInput = {
    category?: LibraryBookCategoryUpdateOneRequiredWithoutLibraryCategoriesToBooksNestedInput
    book?: LibraryBookUpdateOneRequiredWithoutLibraryCategoriesToBooksNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryCategoryToBookUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryBookCategoryId?: IntFieldUpdateOperationsInput | number
    libraryBookId?: IntFieldUpdateOperationsInput | number
  }

  export type LibraryCategoryToBookCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryBookCategoryId: number
    libraryBookId: number
  }

  export type LibraryCategoryToBookUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryCategoryToBookUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryBookCategoryId?: IntFieldUpdateOperationsInput | number
    libraryBookId?: IntFieldUpdateOperationsInput | number
  }

  export type LibraryBookAuthorCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryBooksToAuthors?: LibraryBookToAuthorCreateNestedManyWithoutAuthorInput
  }

  export type LibraryBookAuthorUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryBooksToAuthors?: LibraryBookToAuthorUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type LibraryBookAuthorUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryBooksToAuthors?: LibraryBookToAuthorUpdateManyWithoutAuthorNestedInput
  }

  export type LibraryBookAuthorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryBooksToAuthors?: LibraryBookToAuthorUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type LibraryBookAuthorCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBookAuthorUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookAuthorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookToAuthorCreateInput = {
    book: LibraryBookCreateNestedOneWithoutLibraryBooksToAuthorsInput
    author: LibraryBookAuthorCreateNestedOneWithoutLibraryBooksToAuthorsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBookToAuthorUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryBookId: number
    libraryBookAuthorId: number
  }

  export type LibraryBookToAuthorUpdateInput = {
    book?: LibraryBookUpdateOneRequiredWithoutLibraryBooksToAuthorsNestedInput
    author?: LibraryBookAuthorUpdateOneRequiredWithoutLibraryBooksToAuthorsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookToAuthorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryBookId?: IntFieldUpdateOperationsInput | number
    libraryBookAuthorId?: IntFieldUpdateOperationsInput | number
  }

  export type LibraryBookToAuthorCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryBookId: number
    libraryBookAuthorId: number
  }

  export type LibraryBookToAuthorUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookToAuthorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryBookId?: IntFieldUpdateOperationsInput | number
    libraryBookAuthorId?: IntFieldUpdateOperationsInput | number
  }

  export type LibraryUniversityCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryStudenta?: LibraryStudentCreateNestedManyWithoutUniversityInput
    libraryBookCopies?: LibraryBookCopyCreateNestedManyWithoutUniversityInput
    libraryBorrowingHistories?: LibraryBorrowingHistoryCreateNestedManyWithoutBorrowedFromInput
    fromLibraryRequests?: LibraryRequestCreateNestedManyWithoutFromInput
    toLibraryRequests?: LibraryRequestCreateNestedManyWithoutToInput
  }

  export type LibraryUniversityUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryStudenta?: LibraryStudentUncheckedCreateNestedManyWithoutUniversityInput
    libraryBookCopies?: LibraryBookCopyUncheckedCreateNestedManyWithoutUniversityInput
    libraryBorrowingHistories?: LibraryBorrowingHistoryUncheckedCreateNestedManyWithoutBorrowedFromInput
    fromLibraryRequests?: LibraryRequestUncheckedCreateNestedManyWithoutFromInput
    toLibraryRequests?: LibraryRequestUncheckedCreateNestedManyWithoutToInput
  }

  export type LibraryUniversityUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryStudenta?: LibraryStudentUpdateManyWithoutUniversityNestedInput
    libraryBookCopies?: LibraryBookCopyUpdateManyWithoutUniversityNestedInput
    libraryBorrowingHistories?: LibraryBorrowingHistoryUpdateManyWithoutBorrowedFromNestedInput
    fromLibraryRequests?: LibraryRequestUpdateManyWithoutFromNestedInput
    toLibraryRequests?: LibraryRequestUpdateManyWithoutToNestedInput
  }

  export type LibraryUniversityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryStudenta?: LibraryStudentUncheckedUpdateManyWithoutUniversityNestedInput
    libraryBookCopies?: LibraryBookCopyUncheckedUpdateManyWithoutUniversityNestedInput
    libraryBorrowingHistories?: LibraryBorrowingHistoryUncheckedUpdateManyWithoutBorrowedFromNestedInput
    fromLibraryRequests?: LibraryRequestUncheckedUpdateManyWithoutFromNestedInput
    toLibraryRequests?: LibraryRequestUncheckedUpdateManyWithoutToNestedInput
  }

  export type LibraryUniversityCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryUniversityUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryUniversityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryStudentCreateInput = {
    studentId: number
    name: string
    university: LibraryUniversityCreateNestedOneWithoutLibraryStudentaInput
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryBookCopies?: LibraryBookCopyCreateNestedManyWithoutBorrowedByInput
    libraryBorrowingHistories?: LibraryBorrowingHistoryCreateNestedManyWithoutStudentInput
    libraryRequests?: LibraryRequestCreateNestedManyWithoutStudentInput
  }

  export type LibraryStudentUncheckedCreateInput = {
    id?: number
    studentId: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryUniversityId: number
    libraryBookCopies?: LibraryBookCopyUncheckedCreateNestedManyWithoutBorrowedByInput
    libraryBorrowingHistories?: LibraryBorrowingHistoryUncheckedCreateNestedManyWithoutStudentInput
    libraryRequests?: LibraryRequestUncheckedCreateNestedManyWithoutStudentInput
  }

  export type LibraryStudentUpdateInput = {
    studentId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    university?: LibraryUniversityUpdateOneRequiredWithoutLibraryStudentaNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryBookCopies?: LibraryBookCopyUpdateManyWithoutBorrowedByNestedInput
    libraryBorrowingHistories?: LibraryBorrowingHistoryUpdateManyWithoutStudentNestedInput
    libraryRequests?: LibraryRequestUpdateManyWithoutStudentNestedInput
  }

  export type LibraryStudentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryUniversityId?: IntFieldUpdateOperationsInput | number
    libraryBookCopies?: LibraryBookCopyUncheckedUpdateManyWithoutBorrowedByNestedInput
    libraryBorrowingHistories?: LibraryBorrowingHistoryUncheckedUpdateManyWithoutStudentNestedInput
    libraryRequests?: LibraryRequestUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type LibraryStudentCreateManyInput = {
    id?: number
    studentId: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryUniversityId: number
  }

  export type LibraryStudentUpdateManyMutationInput = {
    studentId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryStudentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryUniversityId?: IntFieldUpdateOperationsInput | number
  }

  export type LibraryBookCopyCreateInput = {
    book: LibraryBookCreateNestedOneWithoutLibraryBookCopiesInput
    status: string
    university: LibraryUniversityCreateNestedOneWithoutLibraryBookCopiesInput
    borrowedBy: LibraryStudentCreateNestedOneWithoutLibraryBookCopiesInput
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryBorrowingHistories?: LibraryBorrowingHistoryCreateNestedManyWithoutCopyInput
    libraryRequests?: LibraryRequestCreateNestedManyWithoutCopyInput
  }

  export type LibraryBookCopyUncheckedCreateInput = {
    id?: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryBookId: number
    libraryUniversityId: number
    libraryStudentId: number
    libraryBorrowingHistories?: LibraryBorrowingHistoryUncheckedCreateNestedManyWithoutCopyInput
    libraryRequests?: LibraryRequestUncheckedCreateNestedManyWithoutCopyInput
  }

  export type LibraryBookCopyUpdateInput = {
    book?: LibraryBookUpdateOneRequiredWithoutLibraryBookCopiesNestedInput
    status?: StringFieldUpdateOperationsInput | string
    university?: LibraryUniversityUpdateOneRequiredWithoutLibraryBookCopiesNestedInput
    borrowedBy?: LibraryStudentUpdateOneRequiredWithoutLibraryBookCopiesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryBorrowingHistories?: LibraryBorrowingHistoryUpdateManyWithoutCopyNestedInput
    libraryRequests?: LibraryRequestUpdateManyWithoutCopyNestedInput
  }

  export type LibraryBookCopyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryBookId?: IntFieldUpdateOperationsInput | number
    libraryUniversityId?: IntFieldUpdateOperationsInput | number
    libraryStudentId?: IntFieldUpdateOperationsInput | number
    libraryBorrowingHistories?: LibraryBorrowingHistoryUncheckedUpdateManyWithoutCopyNestedInput
    libraryRequests?: LibraryRequestUncheckedUpdateManyWithoutCopyNestedInput
  }

  export type LibraryBookCopyCreateManyInput = {
    id?: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryBookId: number
    libraryUniversityId: number
    libraryStudentId: number
  }

  export type LibraryBookCopyUpdateManyMutationInput = {
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookCopyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryBookId?: IntFieldUpdateOperationsInput | number
    libraryUniversityId?: IntFieldUpdateOperationsInput | number
    libraryStudentId?: IntFieldUpdateOperationsInput | number
  }

  export type LibraryBorrowingHistoryCreateInput = {
    student: LibraryStudentCreateNestedOneWithoutLibraryBorrowingHistoriesInput
    copy: LibraryBookCopyCreateNestedOneWithoutLibraryBorrowingHistoriesInput
    borrowDate: number
    returnDate: number
    actualReturnDate: number
    borrowedFrom: LibraryUniversityCreateNestedOneWithoutLibraryBorrowingHistoriesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBorrowingHistoryUncheckedCreateInput = {
    id?: number
    borrowDate: number
    returnDate: number
    actualReturnDate: number
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryStudentId: number
    libraryBookCopyId: number
    libraryUniversityId: number
  }

  export type LibraryBorrowingHistoryUpdateInput = {
    student?: LibraryStudentUpdateOneRequiredWithoutLibraryBorrowingHistoriesNestedInput
    copy?: LibraryBookCopyUpdateOneRequiredWithoutLibraryBorrowingHistoriesNestedInput
    borrowDate?: IntFieldUpdateOperationsInput | number
    returnDate?: IntFieldUpdateOperationsInput | number
    actualReturnDate?: IntFieldUpdateOperationsInput | number
    borrowedFrom?: LibraryUniversityUpdateOneRequiredWithoutLibraryBorrowingHistoriesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBorrowingHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    borrowDate?: IntFieldUpdateOperationsInput | number
    returnDate?: IntFieldUpdateOperationsInput | number
    actualReturnDate?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryStudentId?: IntFieldUpdateOperationsInput | number
    libraryBookCopyId?: IntFieldUpdateOperationsInput | number
    libraryUniversityId?: IntFieldUpdateOperationsInput | number
  }

  export type LibraryBorrowingHistoryCreateManyInput = {
    id?: number
    borrowDate: number
    returnDate: number
    actualReturnDate: number
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryStudentId: number
    libraryBookCopyId: number
    libraryUniversityId: number
  }

  export type LibraryBorrowingHistoryUpdateManyMutationInput = {
    borrowDate?: IntFieldUpdateOperationsInput | number
    returnDate?: IntFieldUpdateOperationsInput | number
    actualReturnDate?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBorrowingHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    borrowDate?: IntFieldUpdateOperationsInput | number
    returnDate?: IntFieldUpdateOperationsInput | number
    actualReturnDate?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryStudentId?: IntFieldUpdateOperationsInput | number
    libraryBookCopyId?: IntFieldUpdateOperationsInput | number
    libraryUniversityId?: IntFieldUpdateOperationsInput | number
  }

  export type LibraryRequestCreateInput = {
    student: LibraryStudentCreateNestedOneWithoutLibraryRequestsInput
    copy: LibraryBookCopyCreateNestedOneWithoutLibraryRequestsInput
    from: LibraryUniversityCreateNestedOneWithoutFromLibraryRequestsInput
    to: LibraryUniversityCreateNestedOneWithoutToLibraryRequestsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryRequestUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryStudentId: number
    libraryBookCopyId: number
    fromLibraryUniversityId: number
    toLibraryUniversityId: number
  }

  export type LibraryRequestUpdateInput = {
    student?: LibraryStudentUpdateOneRequiredWithoutLibraryRequestsNestedInput
    copy?: LibraryBookCopyUpdateOneRequiredWithoutLibraryRequestsNestedInput
    from?: LibraryUniversityUpdateOneRequiredWithoutFromLibraryRequestsNestedInput
    to?: LibraryUniversityUpdateOneRequiredWithoutToLibraryRequestsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryRequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryStudentId?: IntFieldUpdateOperationsInput | number
    libraryBookCopyId?: IntFieldUpdateOperationsInput | number
    fromLibraryUniversityId?: IntFieldUpdateOperationsInput | number
    toLibraryUniversityId?: IntFieldUpdateOperationsInput | number
  }

  export type LibraryRequestCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryStudentId: number
    libraryBookCopyId: number
    fromLibraryUniversityId: number
    toLibraryUniversityId: number
  }

  export type LibraryRequestUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryRequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryStudentId?: IntFieldUpdateOperationsInput | number
    libraryBookCopyId?: IntFieldUpdateOperationsInput | number
    fromLibraryUniversityId?: IntFieldUpdateOperationsInput | number
    toLibraryUniversityId?: IntFieldUpdateOperationsInput | number
  }

  export type QuizCategoryCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    QuizQuestion?: QuizQuestionCreateNestedManyWithoutCategoryInput
    QuizRound?: QuizRoundCreateNestedManyWithoutCategoryInput
  }

  export type QuizCategoryUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    QuizQuestion?: QuizQuestionUncheckedCreateNestedManyWithoutCategoryInput
    QuizRound?: QuizRoundUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type QuizCategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    QuizQuestion?: QuizQuestionUpdateManyWithoutCategoryNestedInput
    QuizRound?: QuizRoundUpdateManyWithoutCategoryNestedInput
  }

  export type QuizCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    QuizQuestion?: QuizQuestionUncheckedUpdateManyWithoutCategoryNestedInput
    QuizRound?: QuizRoundUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type QuizCategoryCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizCategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizQuestionCreateInput = {
    name: string
    answerId: number
    category?: QuizCategoryCreateNestedOneWithoutQuizQuestionInput
    createdAt?: Date | string
    updatedAt?: Date | string
    quizChoices?: QuizChoiceCreateNestedManyWithoutQuestionInput
    quizRecords?: QuizRecordCreateNestedManyWithoutQuestionInput
  }

  export type QuizQuestionUncheckedCreateInput = {
    id?: number
    name: string
    answerId: number
    quizCategoryId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quizChoices?: QuizChoiceUncheckedCreateNestedManyWithoutQuestionInput
    quizRecords?: QuizRecordUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuizQuestionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    answerId?: IntFieldUpdateOperationsInput | number
    category?: QuizCategoryUpdateOneWithoutQuizQuestionNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizChoices?: QuizChoiceUpdateManyWithoutQuestionNestedInput
    quizRecords?: QuizRecordUpdateManyWithoutQuestionNestedInput
  }

  export type QuizQuestionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    answerId?: IntFieldUpdateOperationsInput | number
    quizCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizChoices?: QuizChoiceUncheckedUpdateManyWithoutQuestionNestedInput
    quizRecords?: QuizRecordUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuizQuestionCreateManyInput = {
    id?: number
    name: string
    answerId: number
    quizCategoryId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizQuestionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    answerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizQuestionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    answerId?: IntFieldUpdateOperationsInput | number
    quizCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizChoiceCreateInput = {
    name: string
    question?: QuizQuestionCreateNestedOneWithoutQuizChoicesInput
    createdAt?: Date | string
    updatedAt?: Date | string
    quizRecords?: QuizRecordCreateNestedManyWithoutPlayerChoiceInput
  }

  export type QuizChoiceUncheckedCreateInput = {
    id?: number
    name: string
    quizQuestionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    quizRecords?: QuizRecordUncheckedCreateNestedManyWithoutPlayerChoiceInput
  }

  export type QuizChoiceUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    question?: QuizQuestionUpdateOneWithoutQuizChoicesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizRecords?: QuizRecordUpdateManyWithoutPlayerChoiceNestedInput
  }

  export type QuizChoiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    quizQuestionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizRecords?: QuizRecordUncheckedUpdateManyWithoutPlayerChoiceNestedInput
  }

  export type QuizChoiceCreateManyInput = {
    id?: number
    name: string
    quizQuestionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizChoiceUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizChoiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    quizQuestionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizRoundCreateInput = {
    name: string
    totalScore: string
    category?: QuizCategoryCreateNestedOneWithoutQuizRoundInput
    createdAt?: Date | string
    updatedAt?: Date | string
    quizRecords?: QuizRecordCreateNestedManyWithoutRoundInput
  }

  export type QuizRoundUncheckedCreateInput = {
    id?: number
    name: string
    totalScore: string
    quizCategoryId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    quizRecords?: QuizRecordUncheckedCreateNestedManyWithoutRoundInput
  }

  export type QuizRoundUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    totalScore?: StringFieldUpdateOperationsInput | string
    category?: QuizCategoryUpdateOneWithoutQuizRoundNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizRecords?: QuizRecordUpdateManyWithoutRoundNestedInput
  }

  export type QuizRoundUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    totalScore?: StringFieldUpdateOperationsInput | string
    quizCategoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizRecords?: QuizRecordUncheckedUpdateManyWithoutRoundNestedInput
  }

  export type QuizRoundCreateManyInput = {
    id?: number
    name: string
    totalScore: string
    quizCategoryId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizRoundUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    totalScore?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizRoundUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    totalScore?: StringFieldUpdateOperationsInput | string
    quizCategoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizRecordCreateInput = {
    round?: QuizRoundCreateNestedOneWithoutQuizRecordsInput
    playerChoice?: QuizChoiceCreateNestedOneWithoutQuizRecordsInput
    question?: QuizQuestionCreateNestedOneWithoutQuizRecordsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizRecordUncheckedCreateInput = {
    id?: number
    quizRoundId: number
    quizChoiceId: number
    quizQuestionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizRecordUpdateInput = {
    round?: QuizRoundUpdateOneWithoutQuizRecordsNestedInput
    playerChoice?: QuizChoiceUpdateOneWithoutQuizRecordsNestedInput
    question?: QuizQuestionUpdateOneWithoutQuizRecordsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizRecordUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizRoundId?: IntFieldUpdateOperationsInput | number
    quizChoiceId?: IntFieldUpdateOperationsInput | number
    quizQuestionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizRecordCreateManyInput = {
    id?: number
    quizRoundId: number
    quizChoiceId: number
    quizQuestionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizRecordUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizRecordUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizRoundId?: IntFieldUpdateOperationsInput | number
    quizChoiceId?: IntFieldUpdateOperationsInput | number
    quizQuestionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TodoListCreateInput = {
    task: string
    note?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TodoListUncheckedCreateInput = {
    id?: number
    task: string
    note?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TodoListUpdateInput = {
    task?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TodoListUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    task?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TodoListCreateManyInput = {
    id?: number
    task: string
    note?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TodoListUpdateManyMutationInput = {
    task?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TodoListUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    task?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterUserCreateInput = {
    name: string
    image: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: TwitterPostCreateNestedManyWithoutUserInput
    fromDirectMessages?: TwitterDirectMessageCreateNestedManyWithoutFromInput
    comments?: TwitterCommentCreateNestedManyWithoutUserInput
    toDirectMessages?: TwitterDirectMessageCreateNestedManyWithoutToInput
    followingUserRelations?: TwitterUserRelationCreateNestedManyWithoutFromInput
    followerUserRelations?: TwitterUserRelationCreateNestedManyWithoutToInput
  }

  export type TwitterUserUncheckedCreateInput = {
    id?: number
    name: string
    image: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: TwitterPostUncheckedCreateNestedManyWithoutUserInput
    fromDirectMessages?: TwitterDirectMessageUncheckedCreateNestedManyWithoutFromInput
    comments?: TwitterCommentUncheckedCreateNestedManyWithoutUserInput
    toDirectMessages?: TwitterDirectMessageUncheckedCreateNestedManyWithoutToInput
    followingUserRelations?: TwitterUserRelationUncheckedCreateNestedManyWithoutFromInput
    followerUserRelations?: TwitterUserRelationUncheckedCreateNestedManyWithoutToInput
  }

  export type TwitterUserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: TwitterPostUpdateManyWithoutUserNestedInput
    fromDirectMessages?: TwitterDirectMessageUpdateManyWithoutFromNestedInput
    comments?: TwitterCommentUpdateManyWithoutUserNestedInput
    toDirectMessages?: TwitterDirectMessageUpdateManyWithoutToNestedInput
    followingUserRelations?: TwitterUserRelationUpdateManyWithoutFromNestedInput
    followerUserRelations?: TwitterUserRelationUpdateManyWithoutToNestedInput
  }

  export type TwitterUserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: TwitterPostUncheckedUpdateManyWithoutUserNestedInput
    fromDirectMessages?: TwitterDirectMessageUncheckedUpdateManyWithoutFromNestedInput
    comments?: TwitterCommentUncheckedUpdateManyWithoutUserNestedInput
    toDirectMessages?: TwitterDirectMessageUncheckedUpdateManyWithoutToNestedInput
    followingUserRelations?: TwitterUserRelationUncheckedUpdateManyWithoutFromNestedInput
    followerUserRelations?: TwitterUserRelationUncheckedUpdateManyWithoutToNestedInput
  }

  export type TwitterUserCreateManyInput = {
    id?: number
    name: string
    image: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterUserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterUserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterPostCreateInput = {
    user: TwitterUserCreateNestedOneWithoutPostsInput
    post: string
    createdAt?: Date | string
    updatedAt?: Date | string
    postToHashtags?: TwitterPostToHashtagCreateNestedManyWithoutPostInput
    comments?: TwitterCommentCreateNestedManyWithoutPostInput
  }

  export type TwitterPostUncheckedCreateInput = {
    id?: number
    post: string
    createdAt?: Date | string
    updatedAt?: Date | string
    twitterUserId: number
    postToHashtags?: TwitterPostToHashtagUncheckedCreateNestedManyWithoutPostInput
    comments?: TwitterCommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type TwitterPostUpdateInput = {
    user?: TwitterUserUpdateOneRequiredWithoutPostsNestedInput
    post?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postToHashtags?: TwitterPostToHashtagUpdateManyWithoutPostNestedInput
    comments?: TwitterCommentUpdateManyWithoutPostNestedInput
  }

  export type TwitterPostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    post?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twitterUserId?: IntFieldUpdateOperationsInput | number
    postToHashtags?: TwitterPostToHashtagUncheckedUpdateManyWithoutPostNestedInput
    comments?: TwitterCommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type TwitterPostCreateManyInput = {
    id?: number
    post: string
    createdAt?: Date | string
    updatedAt?: Date | string
    twitterUserId: number
  }

  export type TwitterPostUpdateManyMutationInput = {
    post?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterPostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    post?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twitterUserId?: IntFieldUpdateOperationsInput | number
  }

  export type TwitterHashtagCreateInput = {
    hashtag: string
    createdAt?: Date | string
    updatedAt?: Date | string
    postsToHashtags?: TwitterPostToHashtagCreateNestedManyWithoutHashtagInput
  }

  export type TwitterHashtagUncheckedCreateInput = {
    id?: number
    hashtag: string
    createdAt?: Date | string
    updatedAt?: Date | string
    postsToHashtags?: TwitterPostToHashtagUncheckedCreateNestedManyWithoutHashtagInput
  }

  export type TwitterHashtagUpdateInput = {
    hashtag?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postsToHashtags?: TwitterPostToHashtagUpdateManyWithoutHashtagNestedInput
  }

  export type TwitterHashtagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    hashtag?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postsToHashtags?: TwitterPostToHashtagUncheckedUpdateManyWithoutHashtagNestedInput
  }

  export type TwitterHashtagCreateManyInput = {
    id?: number
    hashtag: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterHashtagUpdateManyMutationInput = {
    hashtag?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterHashtagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    hashtag?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterPostToHashtagCreateInput = {
    post: TwitterPostCreateNestedOneWithoutPostToHashtagsInput
    hashtag: TwitterHashtagCreateNestedOneWithoutPostsToHashtagsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterPostToHashtagUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    twitterPostId: number
    twitterHashtagId: number
  }

  export type TwitterPostToHashtagUpdateInput = {
    post?: TwitterPostUpdateOneRequiredWithoutPostToHashtagsNestedInput
    hashtag?: TwitterHashtagUpdateOneRequiredWithoutPostsToHashtagsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterPostToHashtagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twitterPostId?: IntFieldUpdateOperationsInput | number
    twitterHashtagId?: IntFieldUpdateOperationsInput | number
  }

  export type TwitterPostToHashtagCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    twitterPostId: number
    twitterHashtagId: number
  }

  export type TwitterPostToHashtagUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterPostToHashtagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twitterPostId?: IntFieldUpdateOperationsInput | number
    twitterHashtagId?: IntFieldUpdateOperationsInput | number
  }

  export type TwitterDirectMessageCreateInput = {
    message: string
    from: TwitterUserCreateNestedOneWithoutFromDirectMessagesInput
    to: TwitterUserCreateNestedOneWithoutToDirectMessagesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterDirectMessageUncheckedCreateInput = {
    id?: number
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    followingUserId: number
    followerUserId: number
  }

  export type TwitterDirectMessageUpdateInput = {
    message?: StringFieldUpdateOperationsInput | string
    from?: TwitterUserUpdateOneRequiredWithoutFromDirectMessagesNestedInput
    to?: TwitterUserUpdateOneRequiredWithoutToDirectMessagesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterDirectMessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followingUserId?: IntFieldUpdateOperationsInput | number
    followerUserId?: IntFieldUpdateOperationsInput | number
  }

  export type TwitterDirectMessageCreateManyInput = {
    id?: number
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    followingUserId: number
    followerUserId: number
  }

  export type TwitterDirectMessageUpdateManyMutationInput = {
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterDirectMessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followingUserId?: IntFieldUpdateOperationsInput | number
    followerUserId?: IntFieldUpdateOperationsInput | number
  }

  export type TwitterUserRelationCreateInput = {
    from: TwitterUserCreateNestedOneWithoutFollowingUserRelationsInput
    to: TwitterUserCreateNestedOneWithoutFollowerUserRelationsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterUserRelationUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    fromUserId: number
    toUserId: number
  }

  export type TwitterUserRelationUpdateInput = {
    from?: TwitterUserUpdateOneRequiredWithoutFollowingUserRelationsNestedInput
    to?: TwitterUserUpdateOneRequiredWithoutFollowerUserRelationsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterUserRelationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromUserId?: IntFieldUpdateOperationsInput | number
    toUserId?: IntFieldUpdateOperationsInput | number
  }

  export type TwitterUserRelationCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    fromUserId: number
    toUserId: number
  }

  export type TwitterUserRelationUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterUserRelationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromUserId?: IntFieldUpdateOperationsInput | number
    toUserId?: IntFieldUpdateOperationsInput | number
  }

  export type TwitterCommentCreateInput = {
    post: TwitterPostCreateNestedOneWithoutCommentsInput
    user: TwitterUserCreateNestedOneWithoutCommentsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterCommentUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    twitterPostId: number
    twitterUserId: number
  }

  export type TwitterCommentUpdateInput = {
    post?: TwitterPostUpdateOneRequiredWithoutCommentsNestedInput
    user?: TwitterUserUpdateOneRequiredWithoutCommentsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterCommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twitterPostId?: IntFieldUpdateOperationsInput | number
    twitterUserId?: IntFieldUpdateOperationsInput | number
  }

  export type TwitterCommentCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    twitterPostId: number
    twitterUserId: number
  }

  export type TwitterCommentUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterCommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twitterPostId?: IntFieldUpdateOperationsInput | number
    twitterUserId?: IntFieldUpdateOperationsInput | number
  }

  export type YoutubeUserCreateInput = {
    name: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeUsersToChannels?: YoutubeUserToChannelCreateNestedManyWithoutUserInput
    youtubeSubscriptions?: YoutubeSubscriptionCreateNestedManyWithoutUserInput
    YoutubeReaction?: YoutubeReactionCreateNestedManyWithoutUserInput
    YoutubeComment?: YoutubeCommentCreateNestedManyWithoutUserInput
    YoutubeCommentReaction?: YoutubeCommentReactionCreateNestedManyWithoutUserInput
  }

  export type YoutubeUserUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeUsersToChannels?: YoutubeUserToChannelUncheckedCreateNestedManyWithoutUserInput
    youtubeSubscriptions?: YoutubeSubscriptionUncheckedCreateNestedManyWithoutUserInput
    YoutubeReaction?: YoutubeReactionUncheckedCreateNestedManyWithoutUserInput
    YoutubeComment?: YoutubeCommentUncheckedCreateNestedManyWithoutUserInput
    YoutubeCommentReaction?: YoutubeCommentReactionUncheckedCreateNestedManyWithoutUserInput
  }

  export type YoutubeUserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeUsersToChannels?: YoutubeUserToChannelUpdateManyWithoutUserNestedInput
    youtubeSubscriptions?: YoutubeSubscriptionUpdateManyWithoutUserNestedInput
    YoutubeReaction?: YoutubeReactionUpdateManyWithoutUserNestedInput
    YoutubeComment?: YoutubeCommentUpdateManyWithoutUserNestedInput
    YoutubeCommentReaction?: YoutubeCommentReactionUpdateManyWithoutUserNestedInput
  }

  export type YoutubeUserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeUsersToChannels?: YoutubeUserToChannelUncheckedUpdateManyWithoutUserNestedInput
    youtubeSubscriptions?: YoutubeSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    YoutubeReaction?: YoutubeReactionUncheckedUpdateManyWithoutUserNestedInput
    YoutubeComment?: YoutubeCommentUncheckedUpdateManyWithoutUserNestedInput
    YoutubeCommentReaction?: YoutubeCommentReactionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type YoutubeUserCreateManyInput = {
    id?: number
    name: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeUserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeUserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeChannelCreateInput = {
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeUsersToChannels?: YoutubeUserToChannelCreateNestedManyWithoutChannelInput
    youtubeVideos?: YoutubeVideoCreateNestedManyWithoutChannelInput
    youtubeSubscriptions?: YoutubeSubscriptionCreateNestedManyWithoutChannelInput
  }

  export type YoutubeChannelUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeUsersToChannels?: YoutubeUserToChannelUncheckedCreateNestedManyWithoutChannelInput
    youtubeVideos?: YoutubeVideoUncheckedCreateNestedManyWithoutChannelInput
    youtubeSubscriptions?: YoutubeSubscriptionUncheckedCreateNestedManyWithoutChannelInput
  }

  export type YoutubeChannelUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeUsersToChannels?: YoutubeUserToChannelUpdateManyWithoutChannelNestedInput
    youtubeVideos?: YoutubeVideoUpdateManyWithoutChannelNestedInput
    youtubeSubscriptions?: YoutubeSubscriptionUpdateManyWithoutChannelNestedInput
  }

  export type YoutubeChannelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeUsersToChannels?: YoutubeUserToChannelUncheckedUpdateManyWithoutChannelNestedInput
    youtubeVideos?: YoutubeVideoUncheckedUpdateManyWithoutChannelNestedInput
    youtubeSubscriptions?: YoutubeSubscriptionUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type YoutubeChannelCreateManyInput = {
    id?: number
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeChannelUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeChannelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeSubscriptionCreateInput = {
    user: YoutubeUserCreateNestedOneWithoutYoutubeSubscriptionsInput
    channel: YoutubeChannelCreateNestedOneWithoutYoutubeSubscriptionsInput
    membership: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeSubscriptionUncheckedCreateInput = {
    id?: number
    membership: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeUserId: number
    youtubeChannelId: number
  }

  export type YoutubeSubscriptionUpdateInput = {
    user?: YoutubeUserUpdateOneRequiredWithoutYoutubeSubscriptionsNestedInput
    channel?: YoutubeChannelUpdateOneRequiredWithoutYoutubeSubscriptionsNestedInput
    membership?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeSubscriptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    membership?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeUserId?: IntFieldUpdateOperationsInput | number
    youtubeChannelId?: IntFieldUpdateOperationsInput | number
  }

  export type YoutubeSubscriptionCreateManyInput = {
    id?: number
    membership: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeUserId: number
    youtubeChannelId: number
  }

  export type YoutubeSubscriptionUpdateManyMutationInput = {
    membership?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeSubscriptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    membership?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeUserId?: IntFieldUpdateOperationsInput | number
    youtubeChannelId?: IntFieldUpdateOperationsInput | number
  }

  export type YoutubeUserToChannelCreateInput = {
    user: YoutubeUserCreateNestedOneWithoutYoutubeUsersToChannelsInput
    channel: YoutubeChannelCreateNestedOneWithoutYoutubeUsersToChannelsInput
    description: string
    role: RoleEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeUserToChannelUncheckedCreateInput = {
    id?: number
    description: string
    role: RoleEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeUserId: number
    youtubeChannelId: number
  }

  export type YoutubeUserToChannelUpdateInput = {
    user?: YoutubeUserUpdateOneRequiredWithoutYoutubeUsersToChannelsNestedInput
    channel?: YoutubeChannelUpdateOneRequiredWithoutYoutubeUsersToChannelsNestedInput
    description?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleEnumFieldUpdateOperationsInput | RoleEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeUserToChannelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleEnumFieldUpdateOperationsInput | RoleEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeUserId?: IntFieldUpdateOperationsInput | number
    youtubeChannelId?: IntFieldUpdateOperationsInput | number
  }

  export type YoutubeUserToChannelCreateManyInput = {
    id?: number
    description: string
    role: RoleEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeUserId: number
    youtubeChannelId: number
  }

  export type YoutubeUserToChannelUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleEnumFieldUpdateOperationsInput | RoleEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeUserToChannelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleEnumFieldUpdateOperationsInput | RoleEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeUserId?: IntFieldUpdateOperationsInput | number
    youtubeChannelId?: IntFieldUpdateOperationsInput | number
  }

  export type YoutubeVideoCreateInput = {
    name: string
    videoUrl: string
    description: string
    channel: YoutubeChannelCreateNestedOneWithoutYoutubeVideosInput
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeComments?: YoutubeCommentCreateNestedManyWithoutVideoInput
    youtubeReactions?: YoutubeReactionCreateNestedManyWithoutVideoInput
  }

  export type YoutubeVideoUncheckedCreateInput = {
    id?: number
    name: string
    videoUrl: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeChannelId: number
    youtubeComments?: YoutubeCommentUncheckedCreateNestedManyWithoutVideoInput
    youtubeReactions?: YoutubeReactionUncheckedCreateNestedManyWithoutVideoInput
  }

  export type YoutubeVideoUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    channel?: YoutubeChannelUpdateOneRequiredWithoutYoutubeVideosNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeComments?: YoutubeCommentUpdateManyWithoutVideoNestedInput
    youtubeReactions?: YoutubeReactionUpdateManyWithoutVideoNestedInput
  }

  export type YoutubeVideoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeChannelId?: IntFieldUpdateOperationsInput | number
    youtubeComments?: YoutubeCommentUncheckedUpdateManyWithoutVideoNestedInput
    youtubeReactions?: YoutubeReactionUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type YoutubeVideoCreateManyInput = {
    id?: number
    name: string
    videoUrl: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeChannelId: number
  }

  export type YoutubeVideoUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeVideoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeChannelId?: IntFieldUpdateOperationsInput | number
  }

  export type YoutubeReactionCreateInput = {
    user: YoutubeUserCreateNestedOneWithoutYoutubeReactionInput
    video: YoutubeVideoCreateNestedOneWithoutYoutubeReactionsInput
    reaction: ReactionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeChannelId: number
    youtubeCommentId: number
  }

  export type YoutubeReactionUncheckedCreateInput = {
    id?: number
    reaction: ReactionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeUserId: number
    youtubeChannelId: number
    youtubeVideoId: number
    youtubeCommentId: number
  }

  export type YoutubeReactionUpdateInput = {
    user?: YoutubeUserUpdateOneRequiredWithoutYoutubeReactionNestedInput
    video?: YoutubeVideoUpdateOneRequiredWithoutYoutubeReactionsNestedInput
    reaction?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeChannelId?: IntFieldUpdateOperationsInput | number
    youtubeCommentId?: IntFieldUpdateOperationsInput | number
  }

  export type YoutubeReactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    reaction?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeUserId?: IntFieldUpdateOperationsInput | number
    youtubeChannelId?: IntFieldUpdateOperationsInput | number
    youtubeVideoId?: IntFieldUpdateOperationsInput | number
    youtubeCommentId?: IntFieldUpdateOperationsInput | number
  }

  export type YoutubeReactionCreateManyInput = {
    id?: number
    reaction: ReactionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeUserId: number
    youtubeChannelId: number
    youtubeVideoId: number
    youtubeCommentId: number
  }

  export type YoutubeReactionUpdateManyMutationInput = {
    reaction?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeChannelId?: IntFieldUpdateOperationsInput | number
    youtubeCommentId?: IntFieldUpdateOperationsInput | number
  }

  export type YoutubeReactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    reaction?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeUserId?: IntFieldUpdateOperationsInput | number
    youtubeChannelId?: IntFieldUpdateOperationsInput | number
    youtubeVideoId?: IntFieldUpdateOperationsInput | number
    youtubeCommentId?: IntFieldUpdateOperationsInput | number
  }

  export type YoutubeCommentCreateInput = {
    comment: string
    user: YoutubeUserCreateNestedOneWithoutYoutubeCommentInput
    video: YoutubeVideoCreateNestedOneWithoutYoutubeCommentsInput
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeCommentReactions?: YoutubeCommentReactionCreateNestedManyWithoutCommentInput
  }

  export type YoutubeCommentUncheckedCreateInput = {
    id?: number
    comment: string
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeVideoId: number
    youtubeUserId: number
    youtubeCommentReactions?: YoutubeCommentReactionUncheckedCreateNestedManyWithoutCommentInput
  }

  export type YoutubeCommentUpdateInput = {
    comment?: StringFieldUpdateOperationsInput | string
    user?: YoutubeUserUpdateOneRequiredWithoutYoutubeCommentNestedInput
    video?: YoutubeVideoUpdateOneRequiredWithoutYoutubeCommentsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeCommentReactions?: YoutubeCommentReactionUpdateManyWithoutCommentNestedInput
  }

  export type YoutubeCommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeVideoId?: IntFieldUpdateOperationsInput | number
    youtubeUserId?: IntFieldUpdateOperationsInput | number
    youtubeCommentReactions?: YoutubeCommentReactionUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type YoutubeCommentCreateManyInput = {
    id?: number
    comment: string
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeVideoId: number
    youtubeUserId: number
  }

  export type YoutubeCommentUpdateManyMutationInput = {
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeCommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeVideoId?: IntFieldUpdateOperationsInput | number
    youtubeUserId?: IntFieldUpdateOperationsInput | number
  }

  export type YoutubeCommentReactionCreateInput = {
    user: YoutubeUserCreateNestedOneWithoutYoutubeCommentReactionInput
    comment: YoutubeCommentCreateNestedOneWithoutYoutubeCommentReactionsInput
    reaction: ReactionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeChannelId: number
    youtubeVideoId: number
  }

  export type YoutubeCommentReactionUncheckedCreateInput = {
    id?: number
    reaction: ReactionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeUserId: number
    youtubeChannelId: number
    youtubeVideoId: number
    youtubeCommentId: number
  }

  export type YoutubeCommentReactionUpdateInput = {
    user?: YoutubeUserUpdateOneRequiredWithoutYoutubeCommentReactionNestedInput
    comment?: YoutubeCommentUpdateOneRequiredWithoutYoutubeCommentReactionsNestedInput
    reaction?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeChannelId?: IntFieldUpdateOperationsInput | number
    youtubeVideoId?: IntFieldUpdateOperationsInput | number
  }

  export type YoutubeCommentReactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    reaction?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeUserId?: IntFieldUpdateOperationsInput | number
    youtubeChannelId?: IntFieldUpdateOperationsInput | number
    youtubeVideoId?: IntFieldUpdateOperationsInput | number
    youtubeCommentId?: IntFieldUpdateOperationsInput | number
  }

  export type YoutubeCommentReactionCreateManyInput = {
    id?: number
    reaction: ReactionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeUserId: number
    youtubeChannelId: number
    youtubeVideoId: number
    youtubeCommentId: number
  }

  export type YoutubeCommentReactionUpdateManyMutationInput = {
    reaction?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeChannelId?: IntFieldUpdateOperationsInput | number
    youtubeVideoId?: IntFieldUpdateOperationsInput | number
  }

  export type YoutubeCommentReactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    reaction?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeUserId?: IntFieldUpdateOperationsInput | number
    youtubeChannelId?: IntFieldUpdateOperationsInput | number
    youtubeVideoId?: IntFieldUpdateOperationsInput | number
    youtubeCommentId?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type BinKitchenMenuListRelationFilter = {
    every?: BinKitchenMenuWhereInput
    some?: BinKitchenMenuWhereInput
    none?: BinKitchenMenuWhereInput
  }

  export type BinKitchenMenuOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BinKitchenCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BinKitchenCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BinKitchenCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BinKitchenCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BinKitchenCategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type BinKitchenCategoryRelationFilter = {
    is?: BinKitchenCategoryWhereInput | null
    isNot?: BinKitchenCategoryWhereInput | null
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type BinKitchenOrderItemListRelationFilter = {
    every?: BinKitchenOrderItemWhereInput
    some?: BinKitchenOrderItemWhereInput
    none?: BinKitchenOrderItemWhereInput
  }

  export type BinKitchenOrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BinKitchenMenuCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    price?: SortOrder
    categoryName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BinKitchenMenuAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type BinKitchenMenuMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    price?: SortOrder
    categoryName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BinKitchenMenuMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    price?: SortOrder
    categoryName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BinKitchenMenuSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type BinKitchenOrderCountOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BinKitchenOrderAvgOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
  }

  export type BinKitchenOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BinKitchenOrderMinOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BinKitchenOrderSumOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
  }

  export type BinKitchenMenuRelationFilter = {
    is?: BinKitchenMenuWhereInput
    isNot?: BinKitchenMenuWhereInput
  }

  export type BinKitchenOrderRelationFilter = {
    is?: BinKitchenOrderWhereInput
    isNot?: BinKitchenOrderWhereInput
  }

  export type BinKitchenOrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    menuId?: SortOrder
    orderId?: SortOrder
  }

  export type BinKitchenOrderItemAvgOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    menuId?: SortOrder
    orderId?: SortOrder
  }

  export type BinKitchenOrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    menuId?: SortOrder
    orderId?: SortOrder
  }

  export type BinKitchenOrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    menuId?: SortOrder
    orderId?: SortOrder
  }

  export type BinKitchenOrderItemSumOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    menuId?: SortOrder
    orderId?: SortOrder
  }

  export type LaundryWashingMachineListRelationFilter = {
    every?: LaundryWashingMachineWhereInput
    some?: LaundryWashingMachineWhereInput
    none?: LaundryWashingMachineWhereInput
  }

  export type LaundryWashingMachineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LaundryBranchCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    machineAmount?: SortOrder
    owner?: SortOrder
    tel?: SortOrder
    location?: SortOrder
    areaSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaundryBranchAvgOrderByAggregateInput = {
    id?: SortOrder
    machineAmount?: SortOrder
    tel?: SortOrder
    areaSize?: SortOrder
  }

  export type LaundryBranchMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    machineAmount?: SortOrder
    owner?: SortOrder
    tel?: SortOrder
    location?: SortOrder
    areaSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaundryBranchMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    machineAmount?: SortOrder
    owner?: SortOrder
    tel?: SortOrder
    location?: SortOrder
    areaSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaundryBranchSumOrderByAggregateInput = {
    id?: SortOrder
    machineAmount?: SortOrder
    tel?: SortOrder
    areaSize?: SortOrder
  }

  export type LaundryBranchRelationFilter = {
    is?: LaundryBranchWhereInput
    isNot?: LaundryBranchWhereInput
  }

  export type LaundryWashingMachineToProgramListRelationFilter = {
    every?: LaundryWashingMachineToProgramWhereInput
    some?: LaundryWashingMachineToProgramWhereInput
    none?: LaundryWashingMachineToProgramWhereInput
  }

  export type LaundryMaintainanceListRelationFilter = {
    every?: LaundryMaintainanceWhereInput
    some?: LaundryMaintainanceWhereInput
    none?: LaundryMaintainanceWhereInput
  }

  export type LaundryUserHistoryListRelationFilter = {
    every?: LaundryUserHistoryWhereInput
    some?: LaundryUserHistoryWhereInput
    none?: LaundryUserHistoryWhereInput
  }

  export type LaundryWashingMachineToProgramOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LaundryMaintainanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LaundryUserHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LaundryWashingMachineCountOrderByAggregateInput = {
    id?: SortOrder
    brand?: SortOrder
    variant?: SortOrder
    size?: SortOrder
    machineType?: SortOrder
    yearManufactured?: SortOrder
    insuranceExpiryYear?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    laundryBranchId?: SortOrder
  }

  export type LaundryWashingMachineAvgOrderByAggregateInput = {
    id?: SortOrder
    size?: SortOrder
    yearManufactured?: SortOrder
    insuranceExpiryYear?: SortOrder
    laundryBranchId?: SortOrder
  }

  export type LaundryWashingMachineMaxOrderByAggregateInput = {
    id?: SortOrder
    brand?: SortOrder
    variant?: SortOrder
    size?: SortOrder
    machineType?: SortOrder
    yearManufactured?: SortOrder
    insuranceExpiryYear?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    laundryBranchId?: SortOrder
  }

  export type LaundryWashingMachineMinOrderByAggregateInput = {
    id?: SortOrder
    brand?: SortOrder
    variant?: SortOrder
    size?: SortOrder
    machineType?: SortOrder
    yearManufactured?: SortOrder
    insuranceExpiryYear?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    laundryBranchId?: SortOrder
  }

  export type LaundryWashingMachineSumOrderByAggregateInput = {
    id?: SortOrder
    size?: SortOrder
    yearManufactured?: SortOrder
    insuranceExpiryYear?: SortOrder
    laundryBranchId?: SortOrder
  }

  export type LaundryProgramCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    weight?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaundryProgramAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    weight?: SortOrder
  }

  export type LaundryProgramMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    weight?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaundryProgramMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    weight?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaundryProgramSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    weight?: SortOrder
  }

  export type LaundryWashingMachineRelationFilter = {
    is?: LaundryWashingMachineWhereInput
    isNot?: LaundryWashingMachineWhereInput
  }

  export type LaundryProgramRelationFilter = {
    is?: LaundryProgramWhereInput
    isNot?: LaundryProgramWhereInput
  }

  export type LaundryWashingMachineToProgramCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    laundryWashingMachineId?: SortOrder
    laundryProgramId?: SortOrder
  }

  export type LaundryWashingMachineToProgramAvgOrderByAggregateInput = {
    id?: SortOrder
    laundryWashingMachineId?: SortOrder
    laundryProgramId?: SortOrder
  }

  export type LaundryWashingMachineToProgramMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    laundryWashingMachineId?: SortOrder
    laundryProgramId?: SortOrder
  }

  export type LaundryWashingMachineToProgramMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    laundryWashingMachineId?: SortOrder
    laundryProgramId?: SortOrder
  }

  export type LaundryWashingMachineToProgramSumOrderByAggregateInput = {
    id?: SortOrder
    laundryWashingMachineId?: SortOrder
    laundryProgramId?: SortOrder
  }

  export type LaundryMaintainanceCountOrderByAggregateInput = {
    id?: SortOrder
    round?: SortOrder
    date?: SortOrder
    damageLevel?: SortOrder
    description?: SortOrder
    technicianName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    laundryWashingMachineId?: SortOrder
  }

  export type LaundryMaintainanceAvgOrderByAggregateInput = {
    id?: SortOrder
    round?: SortOrder
    date?: SortOrder
    damageLevel?: SortOrder
    laundryWashingMachineId?: SortOrder
  }

  export type LaundryMaintainanceMaxOrderByAggregateInput = {
    id?: SortOrder
    round?: SortOrder
    date?: SortOrder
    damageLevel?: SortOrder
    description?: SortOrder
    technicianName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    laundryWashingMachineId?: SortOrder
  }

  export type LaundryMaintainanceMinOrderByAggregateInput = {
    id?: SortOrder
    round?: SortOrder
    date?: SortOrder
    damageLevel?: SortOrder
    description?: SortOrder
    technicianName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    laundryWashingMachineId?: SortOrder
  }

  export type LaundryMaintainanceSumOrderByAggregateInput = {
    id?: SortOrder
    round?: SortOrder
    date?: SortOrder
    damageLevel?: SortOrder
    laundryWashingMachineId?: SortOrder
  }

  export type LaundryBalanceTopupListRelationFilter = {
    every?: LaundryBalanceTopupWhereInput
    some?: LaundryBalanceTopupWhereInput
    none?: LaundryBalanceTopupWhereInput
  }

  export type LaundryBalanceTopupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LaundryUserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tel?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaundryUserAvgOrderByAggregateInput = {
    id?: SortOrder
    tel?: SortOrder
    balance?: SortOrder
  }

  export type LaundryUserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tel?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaundryUserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tel?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaundryUserSumOrderByAggregateInput = {
    id?: SortOrder
    tel?: SortOrder
    balance?: SortOrder
  }

  export type LaundryUserRelationFilter = {
    is?: LaundryUserWhereInput
    isNot?: LaundryUserWhereInput
  }

  export type LaundryUserHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    washNumber?: SortOrder
    date?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    laundryUserId?: SortOrder
    laundryWashingMachineId?: SortOrder
    laundryProgramId?: SortOrder
  }

  export type LaundryUserHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    washNumber?: SortOrder
    date?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    laundryUserId?: SortOrder
    laundryWashingMachineId?: SortOrder
    laundryProgramId?: SortOrder
  }

  export type LaundryUserHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    washNumber?: SortOrder
    date?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    laundryUserId?: SortOrder
    laundryWashingMachineId?: SortOrder
    laundryProgramId?: SortOrder
  }

  export type LaundryUserHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    washNumber?: SortOrder
    date?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    laundryUserId?: SortOrder
    laundryWashingMachineId?: SortOrder
    laundryProgramId?: SortOrder
  }

  export type LaundryUserHistorySumOrderByAggregateInput = {
    id?: SortOrder
    washNumber?: SortOrder
    date?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    laundryUserId?: SortOrder
    laundryWashingMachineId?: SortOrder
    laundryProgramId?: SortOrder
  }

  export type LaundryBalanceTopupCountOrderByAggregateInput = {
    id?: SortOrder
    topUpRound?: SortOrder
    topUpAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    laundryUserId?: SortOrder
  }

  export type LaundryBalanceTopupAvgOrderByAggregateInput = {
    id?: SortOrder
    topUpRound?: SortOrder
    topUpAmount?: SortOrder
    laundryUserId?: SortOrder
  }

  export type LaundryBalanceTopupMaxOrderByAggregateInput = {
    id?: SortOrder
    topUpRound?: SortOrder
    topUpAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    laundryUserId?: SortOrder
  }

  export type LaundryBalanceTopupMinOrderByAggregateInput = {
    id?: SortOrder
    topUpRound?: SortOrder
    topUpAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    laundryUserId?: SortOrder
  }

  export type LaundryBalanceTopupSumOrderByAggregateInput = {
    id?: SortOrder
    topUpRound?: SortOrder
    topUpAmount?: SortOrder
    laundryUserId?: SortOrder
  }

  export type LibraryCategoryToBookListRelationFilter = {
    every?: LibraryCategoryToBookWhereInput
    some?: LibraryCategoryToBookWhereInput
    none?: LibraryCategoryToBookWhereInput
  }

  export type LibraryCategoryToBookOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LibraryBookCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryBookCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LibraryBookCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryBookCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryBookCategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LibraryBookToAuthorListRelationFilter = {
    every?: LibraryBookToAuthorWhereInput
    some?: LibraryBookToAuthorWhereInput
    none?: LibraryBookToAuthorWhereInput
  }

  export type LibraryBookCopyListRelationFilter = {
    every?: LibraryBookCopyWhereInput
    some?: LibraryBookCopyWhereInput
    none?: LibraryBookCopyWhereInput
  }

  export type LibraryBookToAuthorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LibraryBookCopyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LibraryBookCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ISBN?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryBookAvgOrderByAggregateInput = {
    id?: SortOrder
    ISBN?: SortOrder
  }

  export type LibraryBookMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ISBN?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryBookMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ISBN?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryBookSumOrderByAggregateInput = {
    id?: SortOrder
    ISBN?: SortOrder
  }

  export type LibraryBookCategoryRelationFilter = {
    is?: LibraryBookCategoryWhereInput
    isNot?: LibraryBookCategoryWhereInput
  }

  export type LibraryBookRelationFilter = {
    is?: LibraryBookWhereInput
    isNot?: LibraryBookWhereInput
  }

  export type LibraryCategoryToBookCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    libraryBookCategoryId?: SortOrder
    libraryBookId?: SortOrder
  }

  export type LibraryCategoryToBookAvgOrderByAggregateInput = {
    id?: SortOrder
    libraryBookCategoryId?: SortOrder
    libraryBookId?: SortOrder
  }

  export type LibraryCategoryToBookMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    libraryBookCategoryId?: SortOrder
    libraryBookId?: SortOrder
  }

  export type LibraryCategoryToBookMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    libraryBookCategoryId?: SortOrder
    libraryBookId?: SortOrder
  }

  export type LibraryCategoryToBookSumOrderByAggregateInput = {
    id?: SortOrder
    libraryBookCategoryId?: SortOrder
    libraryBookId?: SortOrder
  }

  export type LibraryBookAuthorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryBookAuthorAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LibraryBookAuthorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryBookAuthorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryBookAuthorSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LibraryBookAuthorRelationFilter = {
    is?: LibraryBookAuthorWhereInput
    isNot?: LibraryBookAuthorWhereInput
  }

  export type LibraryBookToAuthorCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    libraryBookId?: SortOrder
    libraryBookAuthorId?: SortOrder
  }

  export type LibraryBookToAuthorAvgOrderByAggregateInput = {
    id?: SortOrder
    libraryBookId?: SortOrder
    libraryBookAuthorId?: SortOrder
  }

  export type LibraryBookToAuthorMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    libraryBookId?: SortOrder
    libraryBookAuthorId?: SortOrder
  }

  export type LibraryBookToAuthorMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    libraryBookId?: SortOrder
    libraryBookAuthorId?: SortOrder
  }

  export type LibraryBookToAuthorSumOrderByAggregateInput = {
    id?: SortOrder
    libraryBookId?: SortOrder
    libraryBookAuthorId?: SortOrder
  }

  export type LibraryStudentListRelationFilter = {
    every?: LibraryStudentWhereInput
    some?: LibraryStudentWhereInput
    none?: LibraryStudentWhereInput
  }

  export type LibraryBorrowingHistoryListRelationFilter = {
    every?: LibraryBorrowingHistoryWhereInput
    some?: LibraryBorrowingHistoryWhereInput
    none?: LibraryBorrowingHistoryWhereInput
  }

  export type LibraryRequestListRelationFilter = {
    every?: LibraryRequestWhereInput
    some?: LibraryRequestWhereInput
    none?: LibraryRequestWhereInput
  }

  export type LibraryStudentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LibraryBorrowingHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LibraryRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LibraryUniversityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryUniversityAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LibraryUniversityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryUniversityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryUniversitySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LibraryUniversityRelationFilter = {
    is?: LibraryUniversityWhereInput
    isNot?: LibraryUniversityWhereInput
  }

  export type LibraryStudentCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    libraryUniversityId?: SortOrder
  }

  export type LibraryStudentAvgOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    libraryUniversityId?: SortOrder
  }

  export type LibraryStudentMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    libraryUniversityId?: SortOrder
  }

  export type LibraryStudentMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    libraryUniversityId?: SortOrder
  }

  export type LibraryStudentSumOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    libraryUniversityId?: SortOrder
  }

  export type LibraryStudentRelationFilter = {
    is?: LibraryStudentWhereInput
    isNot?: LibraryStudentWhereInput
  }

  export type LibraryBookCopyCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    libraryBookId?: SortOrder
    libraryUniversityId?: SortOrder
    libraryStudentId?: SortOrder
  }

  export type LibraryBookCopyAvgOrderByAggregateInput = {
    id?: SortOrder
    libraryBookId?: SortOrder
    libraryUniversityId?: SortOrder
    libraryStudentId?: SortOrder
  }

  export type LibraryBookCopyMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    libraryBookId?: SortOrder
    libraryUniversityId?: SortOrder
    libraryStudentId?: SortOrder
  }

  export type LibraryBookCopyMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    libraryBookId?: SortOrder
    libraryUniversityId?: SortOrder
    libraryStudentId?: SortOrder
  }

  export type LibraryBookCopySumOrderByAggregateInput = {
    id?: SortOrder
    libraryBookId?: SortOrder
    libraryUniversityId?: SortOrder
    libraryStudentId?: SortOrder
  }

  export type LibraryBookCopyRelationFilter = {
    is?: LibraryBookCopyWhereInput
    isNot?: LibraryBookCopyWhereInput
  }

  export type LibraryBorrowingHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    borrowDate?: SortOrder
    returnDate?: SortOrder
    actualReturnDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    libraryStudentId?: SortOrder
    libraryBookCopyId?: SortOrder
    libraryUniversityId?: SortOrder
  }

  export type LibraryBorrowingHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    borrowDate?: SortOrder
    returnDate?: SortOrder
    actualReturnDate?: SortOrder
    libraryStudentId?: SortOrder
    libraryBookCopyId?: SortOrder
    libraryUniversityId?: SortOrder
  }

  export type LibraryBorrowingHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    borrowDate?: SortOrder
    returnDate?: SortOrder
    actualReturnDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    libraryStudentId?: SortOrder
    libraryBookCopyId?: SortOrder
    libraryUniversityId?: SortOrder
  }

  export type LibraryBorrowingHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    borrowDate?: SortOrder
    returnDate?: SortOrder
    actualReturnDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    libraryStudentId?: SortOrder
    libraryBookCopyId?: SortOrder
    libraryUniversityId?: SortOrder
  }

  export type LibraryBorrowingHistorySumOrderByAggregateInput = {
    id?: SortOrder
    borrowDate?: SortOrder
    returnDate?: SortOrder
    actualReturnDate?: SortOrder
    libraryStudentId?: SortOrder
    libraryBookCopyId?: SortOrder
    libraryUniversityId?: SortOrder
  }

  export type LibraryRequestCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    libraryStudentId?: SortOrder
    libraryBookCopyId?: SortOrder
    fromLibraryUniversityId?: SortOrder
    toLibraryUniversityId?: SortOrder
  }

  export type LibraryRequestAvgOrderByAggregateInput = {
    id?: SortOrder
    libraryStudentId?: SortOrder
    libraryBookCopyId?: SortOrder
    fromLibraryUniversityId?: SortOrder
    toLibraryUniversityId?: SortOrder
  }

  export type LibraryRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    libraryStudentId?: SortOrder
    libraryBookCopyId?: SortOrder
    fromLibraryUniversityId?: SortOrder
    toLibraryUniversityId?: SortOrder
  }

  export type LibraryRequestMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    libraryStudentId?: SortOrder
    libraryBookCopyId?: SortOrder
    fromLibraryUniversityId?: SortOrder
    toLibraryUniversityId?: SortOrder
  }

  export type LibraryRequestSumOrderByAggregateInput = {
    id?: SortOrder
    libraryStudentId?: SortOrder
    libraryBookCopyId?: SortOrder
    fromLibraryUniversityId?: SortOrder
    toLibraryUniversityId?: SortOrder
  }

  export type QuizQuestionListRelationFilter = {
    every?: QuizQuestionWhereInput
    some?: QuizQuestionWhereInput
    none?: QuizQuestionWhereInput
  }

  export type QuizRoundListRelationFilter = {
    every?: QuizRoundWhereInput
    some?: QuizRoundWhereInput
    none?: QuizRoundWhereInput
  }

  export type QuizQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizRoundOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type QuizCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizCategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type QuizCategoryRelationFilter = {
    is?: QuizCategoryWhereInput | null
    isNot?: QuizCategoryWhereInput | null
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type QuizChoiceListRelationFilter = {
    every?: QuizChoiceWhereInput
    some?: QuizChoiceWhereInput
    none?: QuizChoiceWhereInput
  }

  export type QuizRecordListRelationFilter = {
    every?: QuizRecordWhereInput
    some?: QuizRecordWhereInput
    none?: QuizRecordWhereInput
  }

  export type QuizChoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    answerId?: SortOrder
    quizCategoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizQuestionAvgOrderByAggregateInput = {
    id?: SortOrder
    answerId?: SortOrder
    quizCategoryId?: SortOrder
  }

  export type QuizQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    answerId?: SortOrder
    quizCategoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    answerId?: SortOrder
    quizCategoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizQuestionSumOrderByAggregateInput = {
    id?: SortOrder
    answerId?: SortOrder
    quizCategoryId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type QuizQuestionRelationFilter = {
    is?: QuizQuestionWhereInput | null
    isNot?: QuizQuestionWhereInput | null
  }

  export type QuizChoiceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    quizQuestionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizChoiceAvgOrderByAggregateInput = {
    id?: SortOrder
    quizQuestionId?: SortOrder
  }

  export type QuizChoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    quizQuestionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizChoiceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    quizQuestionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizChoiceSumOrderByAggregateInput = {
    id?: SortOrder
    quizQuestionId?: SortOrder
  }

  export type QuizRoundCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    totalScore?: SortOrder
    quizCategoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizRoundAvgOrderByAggregateInput = {
    id?: SortOrder
    quizCategoryId?: SortOrder
  }

  export type QuizRoundMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    totalScore?: SortOrder
    quizCategoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizRoundMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    totalScore?: SortOrder
    quizCategoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizRoundSumOrderByAggregateInput = {
    id?: SortOrder
    quizCategoryId?: SortOrder
  }

  export type QuizRoundRelationFilter = {
    is?: QuizRoundWhereInput | null
    isNot?: QuizRoundWhereInput | null
  }

  export type QuizChoiceRelationFilter = {
    is?: QuizChoiceWhereInput | null
    isNot?: QuizChoiceWhereInput | null
  }

  export type QuizRecordCountOrderByAggregateInput = {
    id?: SortOrder
    quizRoundId?: SortOrder
    quizChoiceId?: SortOrder
    quizQuestionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizRecordAvgOrderByAggregateInput = {
    id?: SortOrder
    quizRoundId?: SortOrder
    quizChoiceId?: SortOrder
    quizQuestionId?: SortOrder
  }

  export type QuizRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    quizRoundId?: SortOrder
    quizChoiceId?: SortOrder
    quizQuestionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizRecordMinOrderByAggregateInput = {
    id?: SortOrder
    quizRoundId?: SortOrder
    quizChoiceId?: SortOrder
    quizQuestionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizRecordSumOrderByAggregateInput = {
    id?: SortOrder
    quizRoundId?: SortOrder
    quizChoiceId?: SortOrder
    quizQuestionId?: SortOrder
  }

  export type TodoListCountOrderByAggregateInput = {
    id?: SortOrder
    task?: SortOrder
    note?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TodoListAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TodoListMaxOrderByAggregateInput = {
    id?: SortOrder
    task?: SortOrder
    note?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TodoListMinOrderByAggregateInput = {
    id?: SortOrder
    task?: SortOrder
    note?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TodoListSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TwitterPostListRelationFilter = {
    every?: TwitterPostWhereInput
    some?: TwitterPostWhereInput
    none?: TwitterPostWhereInput
  }

  export type TwitterDirectMessageListRelationFilter = {
    every?: TwitterDirectMessageWhereInput
    some?: TwitterDirectMessageWhereInput
    none?: TwitterDirectMessageWhereInput
  }

  export type TwitterCommentListRelationFilter = {
    every?: TwitterCommentWhereInput
    some?: TwitterCommentWhereInput
    none?: TwitterCommentWhereInput
  }

  export type TwitterUserRelationListRelationFilter = {
    every?: TwitterUserRelationWhereInput
    some?: TwitterUserRelationWhereInput
    none?: TwitterUserRelationWhereInput
  }

  export type TwitterPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TwitterDirectMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TwitterCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TwitterUserRelationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TwitterUserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterUserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TwitterUserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterUserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterUserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TwitterUserRelationFilter = {
    is?: TwitterUserWhereInput
    isNot?: TwitterUserWhereInput
  }

  export type TwitterPostToHashtagListRelationFilter = {
    every?: TwitterPostToHashtagWhereInput
    some?: TwitterPostToHashtagWhereInput
    none?: TwitterPostToHashtagWhereInput
  }

  export type TwitterPostToHashtagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TwitterPostCountOrderByAggregateInput = {
    id?: SortOrder
    post?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twitterUserId?: SortOrder
  }

  export type TwitterPostAvgOrderByAggregateInput = {
    id?: SortOrder
    twitterUserId?: SortOrder
  }

  export type TwitterPostMaxOrderByAggregateInput = {
    id?: SortOrder
    post?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twitterUserId?: SortOrder
  }

  export type TwitterPostMinOrderByAggregateInput = {
    id?: SortOrder
    post?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twitterUserId?: SortOrder
  }

  export type TwitterPostSumOrderByAggregateInput = {
    id?: SortOrder
    twitterUserId?: SortOrder
  }

  export type TwitterHashtagCountOrderByAggregateInput = {
    id?: SortOrder
    hashtag?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterHashtagAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TwitterHashtagMaxOrderByAggregateInput = {
    id?: SortOrder
    hashtag?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterHashtagMinOrderByAggregateInput = {
    id?: SortOrder
    hashtag?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterHashtagSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TwitterPostRelationFilter = {
    is?: TwitterPostWhereInput
    isNot?: TwitterPostWhereInput
  }

  export type TwitterHashtagRelationFilter = {
    is?: TwitterHashtagWhereInput
    isNot?: TwitterHashtagWhereInput
  }

  export type TwitterPostToHashtagCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twitterPostId?: SortOrder
    twitterHashtagId?: SortOrder
  }

  export type TwitterPostToHashtagAvgOrderByAggregateInput = {
    id?: SortOrder
    twitterPostId?: SortOrder
    twitterHashtagId?: SortOrder
  }

  export type TwitterPostToHashtagMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twitterPostId?: SortOrder
    twitterHashtagId?: SortOrder
  }

  export type TwitterPostToHashtagMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twitterPostId?: SortOrder
    twitterHashtagId?: SortOrder
  }

  export type TwitterPostToHashtagSumOrderByAggregateInput = {
    id?: SortOrder
    twitterPostId?: SortOrder
    twitterHashtagId?: SortOrder
  }

  export type TwitterDirectMessageCountOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    followingUserId?: SortOrder
    followerUserId?: SortOrder
  }

  export type TwitterDirectMessageAvgOrderByAggregateInput = {
    id?: SortOrder
    followingUserId?: SortOrder
    followerUserId?: SortOrder
  }

  export type TwitterDirectMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    followingUserId?: SortOrder
    followerUserId?: SortOrder
  }

  export type TwitterDirectMessageMinOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    followingUserId?: SortOrder
    followerUserId?: SortOrder
  }

  export type TwitterDirectMessageSumOrderByAggregateInput = {
    id?: SortOrder
    followingUserId?: SortOrder
    followerUserId?: SortOrder
  }

  export type TwitterUserRelationCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
  }

  export type TwitterUserRelationAvgOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
  }

  export type TwitterUserRelationMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
  }

  export type TwitterUserRelationMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
  }

  export type TwitterUserRelationSumOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
  }

  export type TwitterCommentCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twitterPostId?: SortOrder
    twitterUserId?: SortOrder
  }

  export type TwitterCommentAvgOrderByAggregateInput = {
    id?: SortOrder
    twitterPostId?: SortOrder
    twitterUserId?: SortOrder
  }

  export type TwitterCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twitterPostId?: SortOrder
    twitterUserId?: SortOrder
  }

  export type TwitterCommentMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twitterPostId?: SortOrder
    twitterUserId?: SortOrder
  }

  export type TwitterCommentSumOrderByAggregateInput = {
    id?: SortOrder
    twitterPostId?: SortOrder
    twitterUserId?: SortOrder
  }

  export type YoutubeUserToChannelListRelationFilter = {
    every?: YoutubeUserToChannelWhereInput
    some?: YoutubeUserToChannelWhereInput
    none?: YoutubeUserToChannelWhereInput
  }

  export type YoutubeSubscriptionListRelationFilter = {
    every?: YoutubeSubscriptionWhereInput
    some?: YoutubeSubscriptionWhereInput
    none?: YoutubeSubscriptionWhereInput
  }

  export type YoutubeReactionListRelationFilter = {
    every?: YoutubeReactionWhereInput
    some?: YoutubeReactionWhereInput
    none?: YoutubeReactionWhereInput
  }

  export type YoutubeCommentListRelationFilter = {
    every?: YoutubeCommentWhereInput
    some?: YoutubeCommentWhereInput
    none?: YoutubeCommentWhereInput
  }

  export type YoutubeCommentReactionListRelationFilter = {
    every?: YoutubeCommentReactionWhereInput
    some?: YoutubeCommentReactionWhereInput
    none?: YoutubeCommentReactionWhereInput
  }

  export type YoutubeUserToChannelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type YoutubeSubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type YoutubeReactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type YoutubeCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type YoutubeCommentReactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type YoutubeUserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YoutubeUserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type YoutubeUserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YoutubeUserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YoutubeUserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type YoutubeVideoListRelationFilter = {
    every?: YoutubeVideoWhereInput
    some?: YoutubeVideoWhereInput
    none?: YoutubeVideoWhereInput
  }

  export type YoutubeVideoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type YoutubeChannelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YoutubeChannelAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type YoutubeChannelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YoutubeChannelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YoutubeChannelSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type YoutubeUserRelationFilter = {
    is?: YoutubeUserWhereInput
    isNot?: YoutubeUserWhereInput
  }

  export type YoutubeChannelRelationFilter = {
    is?: YoutubeChannelWhereInput
    isNot?: YoutubeChannelWhereInput
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type YoutubeSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    membership?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    youtubeUserId?: SortOrder
    youtubeChannelId?: SortOrder
  }

  export type YoutubeSubscriptionAvgOrderByAggregateInput = {
    id?: SortOrder
    youtubeUserId?: SortOrder
    youtubeChannelId?: SortOrder
  }

  export type YoutubeSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    membership?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    youtubeUserId?: SortOrder
    youtubeChannelId?: SortOrder
  }

  export type YoutubeSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    membership?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    youtubeUserId?: SortOrder
    youtubeChannelId?: SortOrder
  }

  export type YoutubeSubscriptionSumOrderByAggregateInput = {
    id?: SortOrder
    youtubeUserId?: SortOrder
    youtubeChannelId?: SortOrder
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type EnumRoleEnumFilter = {
    equals?: RoleEnum
    in?: Enumerable<RoleEnum>
    notIn?: Enumerable<RoleEnum>
    not?: NestedEnumRoleEnumFilter | RoleEnum
  }

  export type YoutubeUserToChannelCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    youtubeUserId?: SortOrder
    youtubeChannelId?: SortOrder
  }

  export type YoutubeUserToChannelAvgOrderByAggregateInput = {
    id?: SortOrder
    youtubeUserId?: SortOrder
    youtubeChannelId?: SortOrder
  }

  export type YoutubeUserToChannelMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    youtubeUserId?: SortOrder
    youtubeChannelId?: SortOrder
  }

  export type YoutubeUserToChannelMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    youtubeUserId?: SortOrder
    youtubeChannelId?: SortOrder
  }

  export type YoutubeUserToChannelSumOrderByAggregateInput = {
    id?: SortOrder
    youtubeUserId?: SortOrder
    youtubeChannelId?: SortOrder
  }

  export type EnumRoleEnumWithAggregatesFilter = {
    equals?: RoleEnum
    in?: Enumerable<RoleEnum>
    notIn?: Enumerable<RoleEnum>
    not?: NestedEnumRoleEnumWithAggregatesFilter | RoleEnum
    _count?: NestedIntFilter
    _min?: NestedEnumRoleEnumFilter
    _max?: NestedEnumRoleEnumFilter
  }

  export type YoutubeVideoCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    videoUrl?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    youtubeChannelId?: SortOrder
  }

  export type YoutubeVideoAvgOrderByAggregateInput = {
    id?: SortOrder
    youtubeChannelId?: SortOrder
  }

  export type YoutubeVideoMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    videoUrl?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    youtubeChannelId?: SortOrder
  }

  export type YoutubeVideoMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    videoUrl?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    youtubeChannelId?: SortOrder
  }

  export type YoutubeVideoSumOrderByAggregateInput = {
    id?: SortOrder
    youtubeChannelId?: SortOrder
  }

  export type YoutubeVideoRelationFilter = {
    is?: YoutubeVideoWhereInput
    isNot?: YoutubeVideoWhereInput
  }

  export type EnumReactionEnumFilter = {
    equals?: ReactionEnum
    in?: Enumerable<ReactionEnum>
    notIn?: Enumerable<ReactionEnum>
    not?: NestedEnumReactionEnumFilter | ReactionEnum
  }

  export type YoutubeReactionCountOrderByAggregateInput = {
    id?: SortOrder
    reaction?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    youtubeUserId?: SortOrder
    youtubeChannelId?: SortOrder
    youtubeVideoId?: SortOrder
    youtubeCommentId?: SortOrder
  }

  export type YoutubeReactionAvgOrderByAggregateInput = {
    id?: SortOrder
    youtubeUserId?: SortOrder
    youtubeChannelId?: SortOrder
    youtubeVideoId?: SortOrder
    youtubeCommentId?: SortOrder
  }

  export type YoutubeReactionMaxOrderByAggregateInput = {
    id?: SortOrder
    reaction?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    youtubeUserId?: SortOrder
    youtubeChannelId?: SortOrder
    youtubeVideoId?: SortOrder
    youtubeCommentId?: SortOrder
  }

  export type YoutubeReactionMinOrderByAggregateInput = {
    id?: SortOrder
    reaction?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    youtubeUserId?: SortOrder
    youtubeChannelId?: SortOrder
    youtubeVideoId?: SortOrder
    youtubeCommentId?: SortOrder
  }

  export type YoutubeReactionSumOrderByAggregateInput = {
    id?: SortOrder
    youtubeUserId?: SortOrder
    youtubeChannelId?: SortOrder
    youtubeVideoId?: SortOrder
    youtubeCommentId?: SortOrder
  }

  export type EnumReactionEnumWithAggregatesFilter = {
    equals?: ReactionEnum
    in?: Enumerable<ReactionEnum>
    notIn?: Enumerable<ReactionEnum>
    not?: NestedEnumReactionEnumWithAggregatesFilter | ReactionEnum
    _count?: NestedIntFilter
    _min?: NestedEnumReactionEnumFilter
    _max?: NestedEnumReactionEnumFilter
  }

  export type YoutubeCommentCountOrderByAggregateInput = {
    id?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    youtubeVideoId?: SortOrder
    youtubeUserId?: SortOrder
  }

  export type YoutubeCommentAvgOrderByAggregateInput = {
    id?: SortOrder
    youtubeVideoId?: SortOrder
    youtubeUserId?: SortOrder
  }

  export type YoutubeCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    youtubeVideoId?: SortOrder
    youtubeUserId?: SortOrder
  }

  export type YoutubeCommentMinOrderByAggregateInput = {
    id?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    youtubeVideoId?: SortOrder
    youtubeUserId?: SortOrder
  }

  export type YoutubeCommentSumOrderByAggregateInput = {
    id?: SortOrder
    youtubeVideoId?: SortOrder
    youtubeUserId?: SortOrder
  }

  export type YoutubeCommentRelationFilter = {
    is?: YoutubeCommentWhereInput
    isNot?: YoutubeCommentWhereInput
  }

  export type YoutubeCommentReactionCountOrderByAggregateInput = {
    id?: SortOrder
    reaction?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    youtubeUserId?: SortOrder
    youtubeChannelId?: SortOrder
    youtubeVideoId?: SortOrder
    youtubeCommentId?: SortOrder
  }

  export type YoutubeCommentReactionAvgOrderByAggregateInput = {
    id?: SortOrder
    youtubeUserId?: SortOrder
    youtubeChannelId?: SortOrder
    youtubeVideoId?: SortOrder
    youtubeCommentId?: SortOrder
  }

  export type YoutubeCommentReactionMaxOrderByAggregateInput = {
    id?: SortOrder
    reaction?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    youtubeUserId?: SortOrder
    youtubeChannelId?: SortOrder
    youtubeVideoId?: SortOrder
    youtubeCommentId?: SortOrder
  }

  export type YoutubeCommentReactionMinOrderByAggregateInput = {
    id?: SortOrder
    reaction?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    youtubeUserId?: SortOrder
    youtubeChannelId?: SortOrder
    youtubeVideoId?: SortOrder
    youtubeCommentId?: SortOrder
  }

  export type YoutubeCommentReactionSumOrderByAggregateInput = {
    id?: SortOrder
    youtubeUserId?: SortOrder
    youtubeChannelId?: SortOrder
    youtubeVideoId?: SortOrder
    youtubeCommentId?: SortOrder
  }

  export type BinKitchenMenuCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<BinKitchenMenuCreateWithoutCategoryInput>, Enumerable<BinKitchenMenuUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<BinKitchenMenuCreateOrConnectWithoutCategoryInput>
    createMany?: BinKitchenMenuCreateManyCategoryInputEnvelope
    connect?: Enumerable<BinKitchenMenuWhereUniqueInput>
  }

  export type BinKitchenMenuUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<BinKitchenMenuCreateWithoutCategoryInput>, Enumerable<BinKitchenMenuUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<BinKitchenMenuCreateOrConnectWithoutCategoryInput>
    createMany?: BinKitchenMenuCreateManyCategoryInputEnvelope
    connect?: Enumerable<BinKitchenMenuWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BinKitchenMenuUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<BinKitchenMenuCreateWithoutCategoryInput>, Enumerable<BinKitchenMenuUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<BinKitchenMenuCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<BinKitchenMenuUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: BinKitchenMenuCreateManyCategoryInputEnvelope
    set?: Enumerable<BinKitchenMenuWhereUniqueInput>
    disconnect?: Enumerable<BinKitchenMenuWhereUniqueInput>
    delete?: Enumerable<BinKitchenMenuWhereUniqueInput>
    connect?: Enumerable<BinKitchenMenuWhereUniqueInput>
    update?: Enumerable<BinKitchenMenuUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<BinKitchenMenuUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<BinKitchenMenuScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BinKitchenMenuUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<BinKitchenMenuCreateWithoutCategoryInput>, Enumerable<BinKitchenMenuUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<BinKitchenMenuCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<BinKitchenMenuUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: BinKitchenMenuCreateManyCategoryInputEnvelope
    set?: Enumerable<BinKitchenMenuWhereUniqueInput>
    disconnect?: Enumerable<BinKitchenMenuWhereUniqueInput>
    delete?: Enumerable<BinKitchenMenuWhereUniqueInput>
    connect?: Enumerable<BinKitchenMenuWhereUniqueInput>
    update?: Enumerable<BinKitchenMenuUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<BinKitchenMenuUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<BinKitchenMenuScalarWhereInput>
  }

  export type BinKitchenCategoryCreateNestedOneWithoutMenusInput = {
    create?: XOR<BinKitchenCategoryCreateWithoutMenusInput, BinKitchenCategoryUncheckedCreateWithoutMenusInput>
    connectOrCreate?: BinKitchenCategoryCreateOrConnectWithoutMenusInput
    connect?: BinKitchenCategoryWhereUniqueInput
  }

  export type BinKitchenOrderItemCreateNestedManyWithoutMenuInput = {
    create?: XOR<Enumerable<BinKitchenOrderItemCreateWithoutMenuInput>, Enumerable<BinKitchenOrderItemUncheckedCreateWithoutMenuInput>>
    connectOrCreate?: Enumerable<BinKitchenOrderItemCreateOrConnectWithoutMenuInput>
    createMany?: BinKitchenOrderItemCreateManyMenuInputEnvelope
    connect?: Enumerable<BinKitchenOrderItemWhereUniqueInput>
  }

  export type BinKitchenOrderItemUncheckedCreateNestedManyWithoutMenuInput = {
    create?: XOR<Enumerable<BinKitchenOrderItemCreateWithoutMenuInput>, Enumerable<BinKitchenOrderItemUncheckedCreateWithoutMenuInput>>
    connectOrCreate?: Enumerable<BinKitchenOrderItemCreateOrConnectWithoutMenuInput>
    createMany?: BinKitchenOrderItemCreateManyMenuInputEnvelope
    connect?: Enumerable<BinKitchenOrderItemWhereUniqueInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BinKitchenCategoryUpdateOneWithoutMenusNestedInput = {
    create?: XOR<BinKitchenCategoryCreateWithoutMenusInput, BinKitchenCategoryUncheckedCreateWithoutMenusInput>
    connectOrCreate?: BinKitchenCategoryCreateOrConnectWithoutMenusInput
    upsert?: BinKitchenCategoryUpsertWithoutMenusInput
    disconnect?: boolean
    delete?: boolean
    connect?: BinKitchenCategoryWhereUniqueInput
    update?: XOR<BinKitchenCategoryUpdateWithoutMenusInput, BinKitchenCategoryUncheckedUpdateWithoutMenusInput>
  }

  export type BinKitchenOrderItemUpdateManyWithoutMenuNestedInput = {
    create?: XOR<Enumerable<BinKitchenOrderItemCreateWithoutMenuInput>, Enumerable<BinKitchenOrderItemUncheckedCreateWithoutMenuInput>>
    connectOrCreate?: Enumerable<BinKitchenOrderItemCreateOrConnectWithoutMenuInput>
    upsert?: Enumerable<BinKitchenOrderItemUpsertWithWhereUniqueWithoutMenuInput>
    createMany?: BinKitchenOrderItemCreateManyMenuInputEnvelope
    set?: Enumerable<BinKitchenOrderItemWhereUniqueInput>
    disconnect?: Enumerable<BinKitchenOrderItemWhereUniqueInput>
    delete?: Enumerable<BinKitchenOrderItemWhereUniqueInput>
    connect?: Enumerable<BinKitchenOrderItemWhereUniqueInput>
    update?: Enumerable<BinKitchenOrderItemUpdateWithWhereUniqueWithoutMenuInput>
    updateMany?: Enumerable<BinKitchenOrderItemUpdateManyWithWhereWithoutMenuInput>
    deleteMany?: Enumerable<BinKitchenOrderItemScalarWhereInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BinKitchenOrderItemUncheckedUpdateManyWithoutMenuNestedInput = {
    create?: XOR<Enumerable<BinKitchenOrderItemCreateWithoutMenuInput>, Enumerable<BinKitchenOrderItemUncheckedCreateWithoutMenuInput>>
    connectOrCreate?: Enumerable<BinKitchenOrderItemCreateOrConnectWithoutMenuInput>
    upsert?: Enumerable<BinKitchenOrderItemUpsertWithWhereUniqueWithoutMenuInput>
    createMany?: BinKitchenOrderItemCreateManyMenuInputEnvelope
    set?: Enumerable<BinKitchenOrderItemWhereUniqueInput>
    disconnect?: Enumerable<BinKitchenOrderItemWhereUniqueInput>
    delete?: Enumerable<BinKitchenOrderItemWhereUniqueInput>
    connect?: Enumerable<BinKitchenOrderItemWhereUniqueInput>
    update?: Enumerable<BinKitchenOrderItemUpdateWithWhereUniqueWithoutMenuInput>
    updateMany?: Enumerable<BinKitchenOrderItemUpdateManyWithWhereWithoutMenuInput>
    deleteMany?: Enumerable<BinKitchenOrderItemScalarWhereInput>
  }

  export type BinKitchenOrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<Enumerable<BinKitchenOrderItemCreateWithoutOrderInput>, Enumerable<BinKitchenOrderItemUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<BinKitchenOrderItemCreateOrConnectWithoutOrderInput>
    createMany?: BinKitchenOrderItemCreateManyOrderInputEnvelope
    connect?: Enumerable<BinKitchenOrderItemWhereUniqueInput>
  }

  export type BinKitchenOrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<Enumerable<BinKitchenOrderItemCreateWithoutOrderInput>, Enumerable<BinKitchenOrderItemUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<BinKitchenOrderItemCreateOrConnectWithoutOrderInput>
    createMany?: BinKitchenOrderItemCreateManyOrderInputEnvelope
    connect?: Enumerable<BinKitchenOrderItemWhereUniqueInput>
  }

  export type BinKitchenOrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<Enumerable<BinKitchenOrderItemCreateWithoutOrderInput>, Enumerable<BinKitchenOrderItemUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<BinKitchenOrderItemCreateOrConnectWithoutOrderInput>
    upsert?: Enumerable<BinKitchenOrderItemUpsertWithWhereUniqueWithoutOrderInput>
    createMany?: BinKitchenOrderItemCreateManyOrderInputEnvelope
    set?: Enumerable<BinKitchenOrderItemWhereUniqueInput>
    disconnect?: Enumerable<BinKitchenOrderItemWhereUniqueInput>
    delete?: Enumerable<BinKitchenOrderItemWhereUniqueInput>
    connect?: Enumerable<BinKitchenOrderItemWhereUniqueInput>
    update?: Enumerable<BinKitchenOrderItemUpdateWithWhereUniqueWithoutOrderInput>
    updateMany?: Enumerable<BinKitchenOrderItemUpdateManyWithWhereWithoutOrderInput>
    deleteMany?: Enumerable<BinKitchenOrderItemScalarWhereInput>
  }

  export type BinKitchenOrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<Enumerable<BinKitchenOrderItemCreateWithoutOrderInput>, Enumerable<BinKitchenOrderItemUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<BinKitchenOrderItemCreateOrConnectWithoutOrderInput>
    upsert?: Enumerable<BinKitchenOrderItemUpsertWithWhereUniqueWithoutOrderInput>
    createMany?: BinKitchenOrderItemCreateManyOrderInputEnvelope
    set?: Enumerable<BinKitchenOrderItemWhereUniqueInput>
    disconnect?: Enumerable<BinKitchenOrderItemWhereUniqueInput>
    delete?: Enumerable<BinKitchenOrderItemWhereUniqueInput>
    connect?: Enumerable<BinKitchenOrderItemWhereUniqueInput>
    update?: Enumerable<BinKitchenOrderItemUpdateWithWhereUniqueWithoutOrderInput>
    updateMany?: Enumerable<BinKitchenOrderItemUpdateManyWithWhereWithoutOrderInput>
    deleteMany?: Enumerable<BinKitchenOrderItemScalarWhereInput>
  }

  export type BinKitchenMenuCreateNestedOneWithoutItemsInput = {
    create?: XOR<BinKitchenMenuCreateWithoutItemsInput, BinKitchenMenuUncheckedCreateWithoutItemsInput>
    connectOrCreate?: BinKitchenMenuCreateOrConnectWithoutItemsInput
    connect?: BinKitchenMenuWhereUniqueInput
  }

  export type BinKitchenOrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<BinKitchenOrderCreateWithoutItemsInput, BinKitchenOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: BinKitchenOrderCreateOrConnectWithoutItemsInput
    connect?: BinKitchenOrderWhereUniqueInput
  }

  export type BinKitchenMenuUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<BinKitchenMenuCreateWithoutItemsInput, BinKitchenMenuUncheckedCreateWithoutItemsInput>
    connectOrCreate?: BinKitchenMenuCreateOrConnectWithoutItemsInput
    upsert?: BinKitchenMenuUpsertWithoutItemsInput
    connect?: BinKitchenMenuWhereUniqueInput
    update?: XOR<BinKitchenMenuUpdateWithoutItemsInput, BinKitchenMenuUncheckedUpdateWithoutItemsInput>
  }

  export type BinKitchenOrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<BinKitchenOrderCreateWithoutItemsInput, BinKitchenOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: BinKitchenOrderCreateOrConnectWithoutItemsInput
    upsert?: BinKitchenOrderUpsertWithoutItemsInput
    connect?: BinKitchenOrderWhereUniqueInput
    update?: XOR<BinKitchenOrderUpdateWithoutItemsInput, BinKitchenOrderUncheckedUpdateWithoutItemsInput>
  }

  export type LaundryWashingMachineCreateNestedManyWithoutBranchInput = {
    create?: XOR<Enumerable<LaundryWashingMachineCreateWithoutBranchInput>, Enumerable<LaundryWashingMachineUncheckedCreateWithoutBranchInput>>
    connectOrCreate?: Enumerable<LaundryWashingMachineCreateOrConnectWithoutBranchInput>
    createMany?: LaundryWashingMachineCreateManyBranchInputEnvelope
    connect?: Enumerable<LaundryWashingMachineWhereUniqueInput>
  }

  export type LaundryWashingMachineUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<Enumerable<LaundryWashingMachineCreateWithoutBranchInput>, Enumerable<LaundryWashingMachineUncheckedCreateWithoutBranchInput>>
    connectOrCreate?: Enumerable<LaundryWashingMachineCreateOrConnectWithoutBranchInput>
    createMany?: LaundryWashingMachineCreateManyBranchInputEnvelope
    connect?: Enumerable<LaundryWashingMachineWhereUniqueInput>
  }

  export type LaundryWashingMachineUpdateManyWithoutBranchNestedInput = {
    create?: XOR<Enumerable<LaundryWashingMachineCreateWithoutBranchInput>, Enumerable<LaundryWashingMachineUncheckedCreateWithoutBranchInput>>
    connectOrCreate?: Enumerable<LaundryWashingMachineCreateOrConnectWithoutBranchInput>
    upsert?: Enumerable<LaundryWashingMachineUpsertWithWhereUniqueWithoutBranchInput>
    createMany?: LaundryWashingMachineCreateManyBranchInputEnvelope
    set?: Enumerable<LaundryWashingMachineWhereUniqueInput>
    disconnect?: Enumerable<LaundryWashingMachineWhereUniqueInput>
    delete?: Enumerable<LaundryWashingMachineWhereUniqueInput>
    connect?: Enumerable<LaundryWashingMachineWhereUniqueInput>
    update?: Enumerable<LaundryWashingMachineUpdateWithWhereUniqueWithoutBranchInput>
    updateMany?: Enumerable<LaundryWashingMachineUpdateManyWithWhereWithoutBranchInput>
    deleteMany?: Enumerable<LaundryWashingMachineScalarWhereInput>
  }

  export type LaundryWashingMachineUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<Enumerable<LaundryWashingMachineCreateWithoutBranchInput>, Enumerable<LaundryWashingMachineUncheckedCreateWithoutBranchInput>>
    connectOrCreate?: Enumerable<LaundryWashingMachineCreateOrConnectWithoutBranchInput>
    upsert?: Enumerable<LaundryWashingMachineUpsertWithWhereUniqueWithoutBranchInput>
    createMany?: LaundryWashingMachineCreateManyBranchInputEnvelope
    set?: Enumerable<LaundryWashingMachineWhereUniqueInput>
    disconnect?: Enumerable<LaundryWashingMachineWhereUniqueInput>
    delete?: Enumerable<LaundryWashingMachineWhereUniqueInput>
    connect?: Enumerable<LaundryWashingMachineWhereUniqueInput>
    update?: Enumerable<LaundryWashingMachineUpdateWithWhereUniqueWithoutBranchInput>
    updateMany?: Enumerable<LaundryWashingMachineUpdateManyWithWhereWithoutBranchInput>
    deleteMany?: Enumerable<LaundryWashingMachineScalarWhereInput>
  }

  export type LaundryBranchCreateNestedOneWithoutLaundryWashingMachinesInput = {
    create?: XOR<LaundryBranchCreateWithoutLaundryWashingMachinesInput, LaundryBranchUncheckedCreateWithoutLaundryWashingMachinesInput>
    connectOrCreate?: LaundryBranchCreateOrConnectWithoutLaundryWashingMachinesInput
    connect?: LaundryBranchWhereUniqueInput
  }

  export type LaundryWashingMachineToProgramCreateNestedManyWithoutMachineInput = {
    create?: XOR<Enumerable<LaundryWashingMachineToProgramCreateWithoutMachineInput>, Enumerable<LaundryWashingMachineToProgramUncheckedCreateWithoutMachineInput>>
    connectOrCreate?: Enumerable<LaundryWashingMachineToProgramCreateOrConnectWithoutMachineInput>
    createMany?: LaundryWashingMachineToProgramCreateManyMachineInputEnvelope
    connect?: Enumerable<LaundryWashingMachineToProgramWhereUniqueInput>
  }

  export type LaundryMaintainanceCreateNestedManyWithoutMachineInput = {
    create?: XOR<Enumerable<LaundryMaintainanceCreateWithoutMachineInput>, Enumerable<LaundryMaintainanceUncheckedCreateWithoutMachineInput>>
    connectOrCreate?: Enumerable<LaundryMaintainanceCreateOrConnectWithoutMachineInput>
    createMany?: LaundryMaintainanceCreateManyMachineInputEnvelope
    connect?: Enumerable<LaundryMaintainanceWhereUniqueInput>
  }

  export type LaundryUserHistoryCreateNestedManyWithoutMachineInput = {
    create?: XOR<Enumerable<LaundryUserHistoryCreateWithoutMachineInput>, Enumerable<LaundryUserHistoryUncheckedCreateWithoutMachineInput>>
    connectOrCreate?: Enumerable<LaundryUserHistoryCreateOrConnectWithoutMachineInput>
    createMany?: LaundryUserHistoryCreateManyMachineInputEnvelope
    connect?: Enumerable<LaundryUserHistoryWhereUniqueInput>
  }

  export type LaundryWashingMachineToProgramUncheckedCreateNestedManyWithoutMachineInput = {
    create?: XOR<Enumerable<LaundryWashingMachineToProgramCreateWithoutMachineInput>, Enumerable<LaundryWashingMachineToProgramUncheckedCreateWithoutMachineInput>>
    connectOrCreate?: Enumerable<LaundryWashingMachineToProgramCreateOrConnectWithoutMachineInput>
    createMany?: LaundryWashingMachineToProgramCreateManyMachineInputEnvelope
    connect?: Enumerable<LaundryWashingMachineToProgramWhereUniqueInput>
  }

  export type LaundryMaintainanceUncheckedCreateNestedManyWithoutMachineInput = {
    create?: XOR<Enumerable<LaundryMaintainanceCreateWithoutMachineInput>, Enumerable<LaundryMaintainanceUncheckedCreateWithoutMachineInput>>
    connectOrCreate?: Enumerable<LaundryMaintainanceCreateOrConnectWithoutMachineInput>
    createMany?: LaundryMaintainanceCreateManyMachineInputEnvelope
    connect?: Enumerable<LaundryMaintainanceWhereUniqueInput>
  }

  export type LaundryUserHistoryUncheckedCreateNestedManyWithoutMachineInput = {
    create?: XOR<Enumerable<LaundryUserHistoryCreateWithoutMachineInput>, Enumerable<LaundryUserHistoryUncheckedCreateWithoutMachineInput>>
    connectOrCreate?: Enumerable<LaundryUserHistoryCreateOrConnectWithoutMachineInput>
    createMany?: LaundryUserHistoryCreateManyMachineInputEnvelope
    connect?: Enumerable<LaundryUserHistoryWhereUniqueInput>
  }

  export type LaundryBranchUpdateOneRequiredWithoutLaundryWashingMachinesNestedInput = {
    create?: XOR<LaundryBranchCreateWithoutLaundryWashingMachinesInput, LaundryBranchUncheckedCreateWithoutLaundryWashingMachinesInput>
    connectOrCreate?: LaundryBranchCreateOrConnectWithoutLaundryWashingMachinesInput
    upsert?: LaundryBranchUpsertWithoutLaundryWashingMachinesInput
    connect?: LaundryBranchWhereUniqueInput
    update?: XOR<LaundryBranchUpdateWithoutLaundryWashingMachinesInput, LaundryBranchUncheckedUpdateWithoutLaundryWashingMachinesInput>
  }

  export type LaundryWashingMachineToProgramUpdateManyWithoutMachineNestedInput = {
    create?: XOR<Enumerable<LaundryWashingMachineToProgramCreateWithoutMachineInput>, Enumerable<LaundryWashingMachineToProgramUncheckedCreateWithoutMachineInput>>
    connectOrCreate?: Enumerable<LaundryWashingMachineToProgramCreateOrConnectWithoutMachineInput>
    upsert?: Enumerable<LaundryWashingMachineToProgramUpsertWithWhereUniqueWithoutMachineInput>
    createMany?: LaundryWashingMachineToProgramCreateManyMachineInputEnvelope
    set?: Enumerable<LaundryWashingMachineToProgramWhereUniqueInput>
    disconnect?: Enumerable<LaundryWashingMachineToProgramWhereUniqueInput>
    delete?: Enumerable<LaundryWashingMachineToProgramWhereUniqueInput>
    connect?: Enumerable<LaundryWashingMachineToProgramWhereUniqueInput>
    update?: Enumerable<LaundryWashingMachineToProgramUpdateWithWhereUniqueWithoutMachineInput>
    updateMany?: Enumerable<LaundryWashingMachineToProgramUpdateManyWithWhereWithoutMachineInput>
    deleteMany?: Enumerable<LaundryWashingMachineToProgramScalarWhereInput>
  }

  export type LaundryMaintainanceUpdateManyWithoutMachineNestedInput = {
    create?: XOR<Enumerable<LaundryMaintainanceCreateWithoutMachineInput>, Enumerable<LaundryMaintainanceUncheckedCreateWithoutMachineInput>>
    connectOrCreate?: Enumerable<LaundryMaintainanceCreateOrConnectWithoutMachineInput>
    upsert?: Enumerable<LaundryMaintainanceUpsertWithWhereUniqueWithoutMachineInput>
    createMany?: LaundryMaintainanceCreateManyMachineInputEnvelope
    set?: Enumerable<LaundryMaintainanceWhereUniqueInput>
    disconnect?: Enumerable<LaundryMaintainanceWhereUniqueInput>
    delete?: Enumerable<LaundryMaintainanceWhereUniqueInput>
    connect?: Enumerable<LaundryMaintainanceWhereUniqueInput>
    update?: Enumerable<LaundryMaintainanceUpdateWithWhereUniqueWithoutMachineInput>
    updateMany?: Enumerable<LaundryMaintainanceUpdateManyWithWhereWithoutMachineInput>
    deleteMany?: Enumerable<LaundryMaintainanceScalarWhereInput>
  }

  export type LaundryUserHistoryUpdateManyWithoutMachineNestedInput = {
    create?: XOR<Enumerable<LaundryUserHistoryCreateWithoutMachineInput>, Enumerable<LaundryUserHistoryUncheckedCreateWithoutMachineInput>>
    connectOrCreate?: Enumerable<LaundryUserHistoryCreateOrConnectWithoutMachineInput>
    upsert?: Enumerable<LaundryUserHistoryUpsertWithWhereUniqueWithoutMachineInput>
    createMany?: LaundryUserHistoryCreateManyMachineInputEnvelope
    set?: Enumerable<LaundryUserHistoryWhereUniqueInput>
    disconnect?: Enumerable<LaundryUserHistoryWhereUniqueInput>
    delete?: Enumerable<LaundryUserHistoryWhereUniqueInput>
    connect?: Enumerable<LaundryUserHistoryWhereUniqueInput>
    update?: Enumerable<LaundryUserHistoryUpdateWithWhereUniqueWithoutMachineInput>
    updateMany?: Enumerable<LaundryUserHistoryUpdateManyWithWhereWithoutMachineInput>
    deleteMany?: Enumerable<LaundryUserHistoryScalarWhereInput>
  }

  export type LaundryWashingMachineToProgramUncheckedUpdateManyWithoutMachineNestedInput = {
    create?: XOR<Enumerable<LaundryWashingMachineToProgramCreateWithoutMachineInput>, Enumerable<LaundryWashingMachineToProgramUncheckedCreateWithoutMachineInput>>
    connectOrCreate?: Enumerable<LaundryWashingMachineToProgramCreateOrConnectWithoutMachineInput>
    upsert?: Enumerable<LaundryWashingMachineToProgramUpsertWithWhereUniqueWithoutMachineInput>
    createMany?: LaundryWashingMachineToProgramCreateManyMachineInputEnvelope
    set?: Enumerable<LaundryWashingMachineToProgramWhereUniqueInput>
    disconnect?: Enumerable<LaundryWashingMachineToProgramWhereUniqueInput>
    delete?: Enumerable<LaundryWashingMachineToProgramWhereUniqueInput>
    connect?: Enumerable<LaundryWashingMachineToProgramWhereUniqueInput>
    update?: Enumerable<LaundryWashingMachineToProgramUpdateWithWhereUniqueWithoutMachineInput>
    updateMany?: Enumerable<LaundryWashingMachineToProgramUpdateManyWithWhereWithoutMachineInput>
    deleteMany?: Enumerable<LaundryWashingMachineToProgramScalarWhereInput>
  }

  export type LaundryMaintainanceUncheckedUpdateManyWithoutMachineNestedInput = {
    create?: XOR<Enumerable<LaundryMaintainanceCreateWithoutMachineInput>, Enumerable<LaundryMaintainanceUncheckedCreateWithoutMachineInput>>
    connectOrCreate?: Enumerable<LaundryMaintainanceCreateOrConnectWithoutMachineInput>
    upsert?: Enumerable<LaundryMaintainanceUpsertWithWhereUniqueWithoutMachineInput>
    createMany?: LaundryMaintainanceCreateManyMachineInputEnvelope
    set?: Enumerable<LaundryMaintainanceWhereUniqueInput>
    disconnect?: Enumerable<LaundryMaintainanceWhereUniqueInput>
    delete?: Enumerable<LaundryMaintainanceWhereUniqueInput>
    connect?: Enumerable<LaundryMaintainanceWhereUniqueInput>
    update?: Enumerable<LaundryMaintainanceUpdateWithWhereUniqueWithoutMachineInput>
    updateMany?: Enumerable<LaundryMaintainanceUpdateManyWithWhereWithoutMachineInput>
    deleteMany?: Enumerable<LaundryMaintainanceScalarWhereInput>
  }

  export type LaundryUserHistoryUncheckedUpdateManyWithoutMachineNestedInput = {
    create?: XOR<Enumerable<LaundryUserHistoryCreateWithoutMachineInput>, Enumerable<LaundryUserHistoryUncheckedCreateWithoutMachineInput>>
    connectOrCreate?: Enumerable<LaundryUserHistoryCreateOrConnectWithoutMachineInput>
    upsert?: Enumerable<LaundryUserHistoryUpsertWithWhereUniqueWithoutMachineInput>
    createMany?: LaundryUserHistoryCreateManyMachineInputEnvelope
    set?: Enumerable<LaundryUserHistoryWhereUniqueInput>
    disconnect?: Enumerable<LaundryUserHistoryWhereUniqueInput>
    delete?: Enumerable<LaundryUserHistoryWhereUniqueInput>
    connect?: Enumerable<LaundryUserHistoryWhereUniqueInput>
    update?: Enumerable<LaundryUserHistoryUpdateWithWhereUniqueWithoutMachineInput>
    updateMany?: Enumerable<LaundryUserHistoryUpdateManyWithWhereWithoutMachineInput>
    deleteMany?: Enumerable<LaundryUserHistoryScalarWhereInput>
  }

  export type LaundryWashingMachineToProgramCreateNestedManyWithoutProgramInput = {
    create?: XOR<Enumerable<LaundryWashingMachineToProgramCreateWithoutProgramInput>, Enumerable<LaundryWashingMachineToProgramUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<LaundryWashingMachineToProgramCreateOrConnectWithoutProgramInput>
    createMany?: LaundryWashingMachineToProgramCreateManyProgramInputEnvelope
    connect?: Enumerable<LaundryWashingMachineToProgramWhereUniqueInput>
  }

  export type LaundryUserHistoryCreateNestedManyWithoutProgramInput = {
    create?: XOR<Enumerable<LaundryUserHistoryCreateWithoutProgramInput>, Enumerable<LaundryUserHistoryUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<LaundryUserHistoryCreateOrConnectWithoutProgramInput>
    createMany?: LaundryUserHistoryCreateManyProgramInputEnvelope
    connect?: Enumerable<LaundryUserHistoryWhereUniqueInput>
  }

  export type LaundryWashingMachineToProgramUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<Enumerable<LaundryWashingMachineToProgramCreateWithoutProgramInput>, Enumerable<LaundryWashingMachineToProgramUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<LaundryWashingMachineToProgramCreateOrConnectWithoutProgramInput>
    createMany?: LaundryWashingMachineToProgramCreateManyProgramInputEnvelope
    connect?: Enumerable<LaundryWashingMachineToProgramWhereUniqueInput>
  }

  export type LaundryUserHistoryUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<Enumerable<LaundryUserHistoryCreateWithoutProgramInput>, Enumerable<LaundryUserHistoryUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<LaundryUserHistoryCreateOrConnectWithoutProgramInput>
    createMany?: LaundryUserHistoryCreateManyProgramInputEnvelope
    connect?: Enumerable<LaundryUserHistoryWhereUniqueInput>
  }

  export type LaundryWashingMachineToProgramUpdateManyWithoutProgramNestedInput = {
    create?: XOR<Enumerable<LaundryWashingMachineToProgramCreateWithoutProgramInput>, Enumerable<LaundryWashingMachineToProgramUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<LaundryWashingMachineToProgramCreateOrConnectWithoutProgramInput>
    upsert?: Enumerable<LaundryWashingMachineToProgramUpsertWithWhereUniqueWithoutProgramInput>
    createMany?: LaundryWashingMachineToProgramCreateManyProgramInputEnvelope
    set?: Enumerable<LaundryWashingMachineToProgramWhereUniqueInput>
    disconnect?: Enumerable<LaundryWashingMachineToProgramWhereUniqueInput>
    delete?: Enumerable<LaundryWashingMachineToProgramWhereUniqueInput>
    connect?: Enumerable<LaundryWashingMachineToProgramWhereUniqueInput>
    update?: Enumerable<LaundryWashingMachineToProgramUpdateWithWhereUniqueWithoutProgramInput>
    updateMany?: Enumerable<LaundryWashingMachineToProgramUpdateManyWithWhereWithoutProgramInput>
    deleteMany?: Enumerable<LaundryWashingMachineToProgramScalarWhereInput>
  }

  export type LaundryUserHistoryUpdateManyWithoutProgramNestedInput = {
    create?: XOR<Enumerable<LaundryUserHistoryCreateWithoutProgramInput>, Enumerable<LaundryUserHistoryUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<LaundryUserHistoryCreateOrConnectWithoutProgramInput>
    upsert?: Enumerable<LaundryUserHistoryUpsertWithWhereUniqueWithoutProgramInput>
    createMany?: LaundryUserHistoryCreateManyProgramInputEnvelope
    set?: Enumerable<LaundryUserHistoryWhereUniqueInput>
    disconnect?: Enumerable<LaundryUserHistoryWhereUniqueInput>
    delete?: Enumerable<LaundryUserHistoryWhereUniqueInput>
    connect?: Enumerable<LaundryUserHistoryWhereUniqueInput>
    update?: Enumerable<LaundryUserHistoryUpdateWithWhereUniqueWithoutProgramInput>
    updateMany?: Enumerable<LaundryUserHistoryUpdateManyWithWhereWithoutProgramInput>
    deleteMany?: Enumerable<LaundryUserHistoryScalarWhereInput>
  }

  export type LaundryWashingMachineToProgramUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<Enumerable<LaundryWashingMachineToProgramCreateWithoutProgramInput>, Enumerable<LaundryWashingMachineToProgramUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<LaundryWashingMachineToProgramCreateOrConnectWithoutProgramInput>
    upsert?: Enumerable<LaundryWashingMachineToProgramUpsertWithWhereUniqueWithoutProgramInput>
    createMany?: LaundryWashingMachineToProgramCreateManyProgramInputEnvelope
    set?: Enumerable<LaundryWashingMachineToProgramWhereUniqueInput>
    disconnect?: Enumerable<LaundryWashingMachineToProgramWhereUniqueInput>
    delete?: Enumerable<LaundryWashingMachineToProgramWhereUniqueInput>
    connect?: Enumerable<LaundryWashingMachineToProgramWhereUniqueInput>
    update?: Enumerable<LaundryWashingMachineToProgramUpdateWithWhereUniqueWithoutProgramInput>
    updateMany?: Enumerable<LaundryWashingMachineToProgramUpdateManyWithWhereWithoutProgramInput>
    deleteMany?: Enumerable<LaundryWashingMachineToProgramScalarWhereInput>
  }

  export type LaundryUserHistoryUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<Enumerable<LaundryUserHistoryCreateWithoutProgramInput>, Enumerable<LaundryUserHistoryUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<LaundryUserHistoryCreateOrConnectWithoutProgramInput>
    upsert?: Enumerable<LaundryUserHistoryUpsertWithWhereUniqueWithoutProgramInput>
    createMany?: LaundryUserHistoryCreateManyProgramInputEnvelope
    set?: Enumerable<LaundryUserHistoryWhereUniqueInput>
    disconnect?: Enumerable<LaundryUserHistoryWhereUniqueInput>
    delete?: Enumerable<LaundryUserHistoryWhereUniqueInput>
    connect?: Enumerable<LaundryUserHistoryWhereUniqueInput>
    update?: Enumerable<LaundryUserHistoryUpdateWithWhereUniqueWithoutProgramInput>
    updateMany?: Enumerable<LaundryUserHistoryUpdateManyWithWhereWithoutProgramInput>
    deleteMany?: Enumerable<LaundryUserHistoryScalarWhereInput>
  }

  export type LaundryWashingMachineCreateNestedOneWithoutLaundryWashingMachinesToProgramsInput = {
    create?: XOR<LaundryWashingMachineCreateWithoutLaundryWashingMachinesToProgramsInput, LaundryWashingMachineUncheckedCreateWithoutLaundryWashingMachinesToProgramsInput>
    connectOrCreate?: LaundryWashingMachineCreateOrConnectWithoutLaundryWashingMachinesToProgramsInput
    connect?: LaundryWashingMachineWhereUniqueInput
  }

  export type LaundryProgramCreateNestedOneWithoutLaundryWashingMachinesToProgramsInput = {
    create?: XOR<LaundryProgramCreateWithoutLaundryWashingMachinesToProgramsInput, LaundryProgramUncheckedCreateWithoutLaundryWashingMachinesToProgramsInput>
    connectOrCreate?: LaundryProgramCreateOrConnectWithoutLaundryWashingMachinesToProgramsInput
    connect?: LaundryProgramWhereUniqueInput
  }

  export type LaundryWashingMachineUpdateOneRequiredWithoutLaundryWashingMachinesToProgramsNestedInput = {
    create?: XOR<LaundryWashingMachineCreateWithoutLaundryWashingMachinesToProgramsInput, LaundryWashingMachineUncheckedCreateWithoutLaundryWashingMachinesToProgramsInput>
    connectOrCreate?: LaundryWashingMachineCreateOrConnectWithoutLaundryWashingMachinesToProgramsInput
    upsert?: LaundryWashingMachineUpsertWithoutLaundryWashingMachinesToProgramsInput
    connect?: LaundryWashingMachineWhereUniqueInput
    update?: XOR<LaundryWashingMachineUpdateWithoutLaundryWashingMachinesToProgramsInput, LaundryWashingMachineUncheckedUpdateWithoutLaundryWashingMachinesToProgramsInput>
  }

  export type LaundryProgramUpdateOneRequiredWithoutLaundryWashingMachinesToProgramsNestedInput = {
    create?: XOR<LaundryProgramCreateWithoutLaundryWashingMachinesToProgramsInput, LaundryProgramUncheckedCreateWithoutLaundryWashingMachinesToProgramsInput>
    connectOrCreate?: LaundryProgramCreateOrConnectWithoutLaundryWashingMachinesToProgramsInput
    upsert?: LaundryProgramUpsertWithoutLaundryWashingMachinesToProgramsInput
    connect?: LaundryProgramWhereUniqueInput
    update?: XOR<LaundryProgramUpdateWithoutLaundryWashingMachinesToProgramsInput, LaundryProgramUncheckedUpdateWithoutLaundryWashingMachinesToProgramsInput>
  }

  export type LaundryWashingMachineCreateNestedOneWithoutLaundryMaintainancesInput = {
    create?: XOR<LaundryWashingMachineCreateWithoutLaundryMaintainancesInput, LaundryWashingMachineUncheckedCreateWithoutLaundryMaintainancesInput>
    connectOrCreate?: LaundryWashingMachineCreateOrConnectWithoutLaundryMaintainancesInput
    connect?: LaundryWashingMachineWhereUniqueInput
  }

  export type LaundryWashingMachineUpdateOneRequiredWithoutLaundryMaintainancesNestedInput = {
    create?: XOR<LaundryWashingMachineCreateWithoutLaundryMaintainancesInput, LaundryWashingMachineUncheckedCreateWithoutLaundryMaintainancesInput>
    connectOrCreate?: LaundryWashingMachineCreateOrConnectWithoutLaundryMaintainancesInput
    upsert?: LaundryWashingMachineUpsertWithoutLaundryMaintainancesInput
    connect?: LaundryWashingMachineWhereUniqueInput
    update?: XOR<LaundryWashingMachineUpdateWithoutLaundryMaintainancesInput, LaundryWashingMachineUncheckedUpdateWithoutLaundryMaintainancesInput>
  }

  export type LaundryUserHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<LaundryUserHistoryCreateWithoutUserInput>, Enumerable<LaundryUserHistoryUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LaundryUserHistoryCreateOrConnectWithoutUserInput>
    createMany?: LaundryUserHistoryCreateManyUserInputEnvelope
    connect?: Enumerable<LaundryUserHistoryWhereUniqueInput>
  }

  export type LaundryBalanceTopupCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<LaundryBalanceTopupCreateWithoutUserInput>, Enumerable<LaundryBalanceTopupUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LaundryBalanceTopupCreateOrConnectWithoutUserInput>
    createMany?: LaundryBalanceTopupCreateManyUserInputEnvelope
    connect?: Enumerable<LaundryBalanceTopupWhereUniqueInput>
  }

  export type LaundryUserHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<LaundryUserHistoryCreateWithoutUserInput>, Enumerable<LaundryUserHistoryUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LaundryUserHistoryCreateOrConnectWithoutUserInput>
    createMany?: LaundryUserHistoryCreateManyUserInputEnvelope
    connect?: Enumerable<LaundryUserHistoryWhereUniqueInput>
  }

  export type LaundryBalanceTopupUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<LaundryBalanceTopupCreateWithoutUserInput>, Enumerable<LaundryBalanceTopupUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LaundryBalanceTopupCreateOrConnectWithoutUserInput>
    createMany?: LaundryBalanceTopupCreateManyUserInputEnvelope
    connect?: Enumerable<LaundryBalanceTopupWhereUniqueInput>
  }

  export type LaundryUserHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<LaundryUserHistoryCreateWithoutUserInput>, Enumerable<LaundryUserHistoryUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LaundryUserHistoryCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<LaundryUserHistoryUpsertWithWhereUniqueWithoutUserInput>
    createMany?: LaundryUserHistoryCreateManyUserInputEnvelope
    set?: Enumerable<LaundryUserHistoryWhereUniqueInput>
    disconnect?: Enumerable<LaundryUserHistoryWhereUniqueInput>
    delete?: Enumerable<LaundryUserHistoryWhereUniqueInput>
    connect?: Enumerable<LaundryUserHistoryWhereUniqueInput>
    update?: Enumerable<LaundryUserHistoryUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<LaundryUserHistoryUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<LaundryUserHistoryScalarWhereInput>
  }

  export type LaundryBalanceTopupUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<LaundryBalanceTopupCreateWithoutUserInput>, Enumerable<LaundryBalanceTopupUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LaundryBalanceTopupCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<LaundryBalanceTopupUpsertWithWhereUniqueWithoutUserInput>
    createMany?: LaundryBalanceTopupCreateManyUserInputEnvelope
    set?: Enumerable<LaundryBalanceTopupWhereUniqueInput>
    disconnect?: Enumerable<LaundryBalanceTopupWhereUniqueInput>
    delete?: Enumerable<LaundryBalanceTopupWhereUniqueInput>
    connect?: Enumerable<LaundryBalanceTopupWhereUniqueInput>
    update?: Enumerable<LaundryBalanceTopupUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<LaundryBalanceTopupUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<LaundryBalanceTopupScalarWhereInput>
  }

  export type LaundryUserHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<LaundryUserHistoryCreateWithoutUserInput>, Enumerable<LaundryUserHistoryUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LaundryUserHistoryCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<LaundryUserHistoryUpsertWithWhereUniqueWithoutUserInput>
    createMany?: LaundryUserHistoryCreateManyUserInputEnvelope
    set?: Enumerable<LaundryUserHistoryWhereUniqueInput>
    disconnect?: Enumerable<LaundryUserHistoryWhereUniqueInput>
    delete?: Enumerable<LaundryUserHistoryWhereUniqueInput>
    connect?: Enumerable<LaundryUserHistoryWhereUniqueInput>
    update?: Enumerable<LaundryUserHistoryUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<LaundryUserHistoryUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<LaundryUserHistoryScalarWhereInput>
  }

  export type LaundryBalanceTopupUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<LaundryBalanceTopupCreateWithoutUserInput>, Enumerable<LaundryBalanceTopupUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LaundryBalanceTopupCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<LaundryBalanceTopupUpsertWithWhereUniqueWithoutUserInput>
    createMany?: LaundryBalanceTopupCreateManyUserInputEnvelope
    set?: Enumerable<LaundryBalanceTopupWhereUniqueInput>
    disconnect?: Enumerable<LaundryBalanceTopupWhereUniqueInput>
    delete?: Enumerable<LaundryBalanceTopupWhereUniqueInput>
    connect?: Enumerable<LaundryBalanceTopupWhereUniqueInput>
    update?: Enumerable<LaundryBalanceTopupUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<LaundryBalanceTopupUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<LaundryBalanceTopupScalarWhereInput>
  }

  export type LaundryUserCreateNestedOneWithoutLaundryUserHistoriesInput = {
    create?: XOR<LaundryUserCreateWithoutLaundryUserHistoriesInput, LaundryUserUncheckedCreateWithoutLaundryUserHistoriesInput>
    connectOrCreate?: LaundryUserCreateOrConnectWithoutLaundryUserHistoriesInput
    connect?: LaundryUserWhereUniqueInput
  }

  export type LaundryWashingMachineCreateNestedOneWithoutLaundryUserHistoriesInput = {
    create?: XOR<LaundryWashingMachineCreateWithoutLaundryUserHistoriesInput, LaundryWashingMachineUncheckedCreateWithoutLaundryUserHistoriesInput>
    connectOrCreate?: LaundryWashingMachineCreateOrConnectWithoutLaundryUserHistoriesInput
    connect?: LaundryWashingMachineWhereUniqueInput
  }

  export type LaundryProgramCreateNestedOneWithoutLaundryUserHistoriesInput = {
    create?: XOR<LaundryProgramCreateWithoutLaundryUserHistoriesInput, LaundryProgramUncheckedCreateWithoutLaundryUserHistoriesInput>
    connectOrCreate?: LaundryProgramCreateOrConnectWithoutLaundryUserHistoriesInput
    connect?: LaundryProgramWhereUniqueInput
  }

  export type LaundryUserUpdateOneRequiredWithoutLaundryUserHistoriesNestedInput = {
    create?: XOR<LaundryUserCreateWithoutLaundryUserHistoriesInput, LaundryUserUncheckedCreateWithoutLaundryUserHistoriesInput>
    connectOrCreate?: LaundryUserCreateOrConnectWithoutLaundryUserHistoriesInput
    upsert?: LaundryUserUpsertWithoutLaundryUserHistoriesInput
    connect?: LaundryUserWhereUniqueInput
    update?: XOR<LaundryUserUpdateWithoutLaundryUserHistoriesInput, LaundryUserUncheckedUpdateWithoutLaundryUserHistoriesInput>
  }

  export type LaundryWashingMachineUpdateOneRequiredWithoutLaundryUserHistoriesNestedInput = {
    create?: XOR<LaundryWashingMachineCreateWithoutLaundryUserHistoriesInput, LaundryWashingMachineUncheckedCreateWithoutLaundryUserHistoriesInput>
    connectOrCreate?: LaundryWashingMachineCreateOrConnectWithoutLaundryUserHistoriesInput
    upsert?: LaundryWashingMachineUpsertWithoutLaundryUserHistoriesInput
    connect?: LaundryWashingMachineWhereUniqueInput
    update?: XOR<LaundryWashingMachineUpdateWithoutLaundryUserHistoriesInput, LaundryWashingMachineUncheckedUpdateWithoutLaundryUserHistoriesInput>
  }

  export type LaundryProgramUpdateOneRequiredWithoutLaundryUserHistoriesNestedInput = {
    create?: XOR<LaundryProgramCreateWithoutLaundryUserHistoriesInput, LaundryProgramUncheckedCreateWithoutLaundryUserHistoriesInput>
    connectOrCreate?: LaundryProgramCreateOrConnectWithoutLaundryUserHistoriesInput
    upsert?: LaundryProgramUpsertWithoutLaundryUserHistoriesInput
    connect?: LaundryProgramWhereUniqueInput
    update?: XOR<LaundryProgramUpdateWithoutLaundryUserHistoriesInput, LaundryProgramUncheckedUpdateWithoutLaundryUserHistoriesInput>
  }

  export type LaundryUserCreateNestedOneWithoutLaundryBalanceTopupsInput = {
    create?: XOR<LaundryUserCreateWithoutLaundryBalanceTopupsInput, LaundryUserUncheckedCreateWithoutLaundryBalanceTopupsInput>
    connectOrCreate?: LaundryUserCreateOrConnectWithoutLaundryBalanceTopupsInput
    connect?: LaundryUserWhereUniqueInput
  }

  export type LaundryUserUpdateOneRequiredWithoutLaundryBalanceTopupsNestedInput = {
    create?: XOR<LaundryUserCreateWithoutLaundryBalanceTopupsInput, LaundryUserUncheckedCreateWithoutLaundryBalanceTopupsInput>
    connectOrCreate?: LaundryUserCreateOrConnectWithoutLaundryBalanceTopupsInput
    upsert?: LaundryUserUpsertWithoutLaundryBalanceTopupsInput
    connect?: LaundryUserWhereUniqueInput
    update?: XOR<LaundryUserUpdateWithoutLaundryBalanceTopupsInput, LaundryUserUncheckedUpdateWithoutLaundryBalanceTopupsInput>
  }

  export type LibraryCategoryToBookCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<LibraryCategoryToBookCreateWithoutCategoryInput>, Enumerable<LibraryCategoryToBookUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<LibraryCategoryToBookCreateOrConnectWithoutCategoryInput>
    createMany?: LibraryCategoryToBookCreateManyCategoryInputEnvelope
    connect?: Enumerable<LibraryCategoryToBookWhereUniqueInput>
  }

  export type LibraryCategoryToBookUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<LibraryCategoryToBookCreateWithoutCategoryInput>, Enumerable<LibraryCategoryToBookUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<LibraryCategoryToBookCreateOrConnectWithoutCategoryInput>
    createMany?: LibraryCategoryToBookCreateManyCategoryInputEnvelope
    connect?: Enumerable<LibraryCategoryToBookWhereUniqueInput>
  }

  export type LibraryCategoryToBookUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<LibraryCategoryToBookCreateWithoutCategoryInput>, Enumerable<LibraryCategoryToBookUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<LibraryCategoryToBookCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<LibraryCategoryToBookUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: LibraryCategoryToBookCreateManyCategoryInputEnvelope
    set?: Enumerable<LibraryCategoryToBookWhereUniqueInput>
    disconnect?: Enumerable<LibraryCategoryToBookWhereUniqueInput>
    delete?: Enumerable<LibraryCategoryToBookWhereUniqueInput>
    connect?: Enumerable<LibraryCategoryToBookWhereUniqueInput>
    update?: Enumerable<LibraryCategoryToBookUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<LibraryCategoryToBookUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<LibraryCategoryToBookScalarWhereInput>
  }

  export type LibraryCategoryToBookUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<LibraryCategoryToBookCreateWithoutCategoryInput>, Enumerable<LibraryCategoryToBookUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<LibraryCategoryToBookCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<LibraryCategoryToBookUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: LibraryCategoryToBookCreateManyCategoryInputEnvelope
    set?: Enumerable<LibraryCategoryToBookWhereUniqueInput>
    disconnect?: Enumerable<LibraryCategoryToBookWhereUniqueInput>
    delete?: Enumerable<LibraryCategoryToBookWhereUniqueInput>
    connect?: Enumerable<LibraryCategoryToBookWhereUniqueInput>
    update?: Enumerable<LibraryCategoryToBookUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<LibraryCategoryToBookUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<LibraryCategoryToBookScalarWhereInput>
  }

  export type LibraryCategoryToBookCreateNestedManyWithoutBookInput = {
    create?: XOR<Enumerable<LibraryCategoryToBookCreateWithoutBookInput>, Enumerable<LibraryCategoryToBookUncheckedCreateWithoutBookInput>>
    connectOrCreate?: Enumerable<LibraryCategoryToBookCreateOrConnectWithoutBookInput>
    createMany?: LibraryCategoryToBookCreateManyBookInputEnvelope
    connect?: Enumerable<LibraryCategoryToBookWhereUniqueInput>
  }

  export type LibraryBookToAuthorCreateNestedManyWithoutBookInput = {
    create?: XOR<Enumerable<LibraryBookToAuthorCreateWithoutBookInput>, Enumerable<LibraryBookToAuthorUncheckedCreateWithoutBookInput>>
    connectOrCreate?: Enumerable<LibraryBookToAuthorCreateOrConnectWithoutBookInput>
    createMany?: LibraryBookToAuthorCreateManyBookInputEnvelope
    connect?: Enumerable<LibraryBookToAuthorWhereUniqueInput>
  }

  export type LibraryBookCopyCreateNestedManyWithoutBookInput = {
    create?: XOR<Enumerable<LibraryBookCopyCreateWithoutBookInput>, Enumerable<LibraryBookCopyUncheckedCreateWithoutBookInput>>
    connectOrCreate?: Enumerable<LibraryBookCopyCreateOrConnectWithoutBookInput>
    createMany?: LibraryBookCopyCreateManyBookInputEnvelope
    connect?: Enumerable<LibraryBookCopyWhereUniqueInput>
  }

  export type LibraryCategoryToBookUncheckedCreateNestedManyWithoutBookInput = {
    create?: XOR<Enumerable<LibraryCategoryToBookCreateWithoutBookInput>, Enumerable<LibraryCategoryToBookUncheckedCreateWithoutBookInput>>
    connectOrCreate?: Enumerable<LibraryCategoryToBookCreateOrConnectWithoutBookInput>
    createMany?: LibraryCategoryToBookCreateManyBookInputEnvelope
    connect?: Enumerable<LibraryCategoryToBookWhereUniqueInput>
  }

  export type LibraryBookToAuthorUncheckedCreateNestedManyWithoutBookInput = {
    create?: XOR<Enumerable<LibraryBookToAuthorCreateWithoutBookInput>, Enumerable<LibraryBookToAuthorUncheckedCreateWithoutBookInput>>
    connectOrCreate?: Enumerable<LibraryBookToAuthorCreateOrConnectWithoutBookInput>
    createMany?: LibraryBookToAuthorCreateManyBookInputEnvelope
    connect?: Enumerable<LibraryBookToAuthorWhereUniqueInput>
  }

  export type LibraryBookCopyUncheckedCreateNestedManyWithoutBookInput = {
    create?: XOR<Enumerable<LibraryBookCopyCreateWithoutBookInput>, Enumerable<LibraryBookCopyUncheckedCreateWithoutBookInput>>
    connectOrCreate?: Enumerable<LibraryBookCopyCreateOrConnectWithoutBookInput>
    createMany?: LibraryBookCopyCreateManyBookInputEnvelope
    connect?: Enumerable<LibraryBookCopyWhereUniqueInput>
  }

  export type LibraryCategoryToBookUpdateManyWithoutBookNestedInput = {
    create?: XOR<Enumerable<LibraryCategoryToBookCreateWithoutBookInput>, Enumerable<LibraryCategoryToBookUncheckedCreateWithoutBookInput>>
    connectOrCreate?: Enumerable<LibraryCategoryToBookCreateOrConnectWithoutBookInput>
    upsert?: Enumerable<LibraryCategoryToBookUpsertWithWhereUniqueWithoutBookInput>
    createMany?: LibraryCategoryToBookCreateManyBookInputEnvelope
    set?: Enumerable<LibraryCategoryToBookWhereUniqueInput>
    disconnect?: Enumerable<LibraryCategoryToBookWhereUniqueInput>
    delete?: Enumerable<LibraryCategoryToBookWhereUniqueInput>
    connect?: Enumerable<LibraryCategoryToBookWhereUniqueInput>
    update?: Enumerable<LibraryCategoryToBookUpdateWithWhereUniqueWithoutBookInput>
    updateMany?: Enumerable<LibraryCategoryToBookUpdateManyWithWhereWithoutBookInput>
    deleteMany?: Enumerable<LibraryCategoryToBookScalarWhereInput>
  }

  export type LibraryBookToAuthorUpdateManyWithoutBookNestedInput = {
    create?: XOR<Enumerable<LibraryBookToAuthorCreateWithoutBookInput>, Enumerable<LibraryBookToAuthorUncheckedCreateWithoutBookInput>>
    connectOrCreate?: Enumerable<LibraryBookToAuthorCreateOrConnectWithoutBookInput>
    upsert?: Enumerable<LibraryBookToAuthorUpsertWithWhereUniqueWithoutBookInput>
    createMany?: LibraryBookToAuthorCreateManyBookInputEnvelope
    set?: Enumerable<LibraryBookToAuthorWhereUniqueInput>
    disconnect?: Enumerable<LibraryBookToAuthorWhereUniqueInput>
    delete?: Enumerable<LibraryBookToAuthorWhereUniqueInput>
    connect?: Enumerable<LibraryBookToAuthorWhereUniqueInput>
    update?: Enumerable<LibraryBookToAuthorUpdateWithWhereUniqueWithoutBookInput>
    updateMany?: Enumerable<LibraryBookToAuthorUpdateManyWithWhereWithoutBookInput>
    deleteMany?: Enumerable<LibraryBookToAuthorScalarWhereInput>
  }

  export type LibraryBookCopyUpdateManyWithoutBookNestedInput = {
    create?: XOR<Enumerable<LibraryBookCopyCreateWithoutBookInput>, Enumerable<LibraryBookCopyUncheckedCreateWithoutBookInput>>
    connectOrCreate?: Enumerable<LibraryBookCopyCreateOrConnectWithoutBookInput>
    upsert?: Enumerable<LibraryBookCopyUpsertWithWhereUniqueWithoutBookInput>
    createMany?: LibraryBookCopyCreateManyBookInputEnvelope
    set?: Enumerable<LibraryBookCopyWhereUniqueInput>
    disconnect?: Enumerable<LibraryBookCopyWhereUniqueInput>
    delete?: Enumerable<LibraryBookCopyWhereUniqueInput>
    connect?: Enumerable<LibraryBookCopyWhereUniqueInput>
    update?: Enumerable<LibraryBookCopyUpdateWithWhereUniqueWithoutBookInput>
    updateMany?: Enumerable<LibraryBookCopyUpdateManyWithWhereWithoutBookInput>
    deleteMany?: Enumerable<LibraryBookCopyScalarWhereInput>
  }

  export type LibraryCategoryToBookUncheckedUpdateManyWithoutBookNestedInput = {
    create?: XOR<Enumerable<LibraryCategoryToBookCreateWithoutBookInput>, Enumerable<LibraryCategoryToBookUncheckedCreateWithoutBookInput>>
    connectOrCreate?: Enumerable<LibraryCategoryToBookCreateOrConnectWithoutBookInput>
    upsert?: Enumerable<LibraryCategoryToBookUpsertWithWhereUniqueWithoutBookInput>
    createMany?: LibraryCategoryToBookCreateManyBookInputEnvelope
    set?: Enumerable<LibraryCategoryToBookWhereUniqueInput>
    disconnect?: Enumerable<LibraryCategoryToBookWhereUniqueInput>
    delete?: Enumerable<LibraryCategoryToBookWhereUniqueInput>
    connect?: Enumerable<LibraryCategoryToBookWhereUniqueInput>
    update?: Enumerable<LibraryCategoryToBookUpdateWithWhereUniqueWithoutBookInput>
    updateMany?: Enumerable<LibraryCategoryToBookUpdateManyWithWhereWithoutBookInput>
    deleteMany?: Enumerable<LibraryCategoryToBookScalarWhereInput>
  }

  export type LibraryBookToAuthorUncheckedUpdateManyWithoutBookNestedInput = {
    create?: XOR<Enumerable<LibraryBookToAuthorCreateWithoutBookInput>, Enumerable<LibraryBookToAuthorUncheckedCreateWithoutBookInput>>
    connectOrCreate?: Enumerable<LibraryBookToAuthorCreateOrConnectWithoutBookInput>
    upsert?: Enumerable<LibraryBookToAuthorUpsertWithWhereUniqueWithoutBookInput>
    createMany?: LibraryBookToAuthorCreateManyBookInputEnvelope
    set?: Enumerable<LibraryBookToAuthorWhereUniqueInput>
    disconnect?: Enumerable<LibraryBookToAuthorWhereUniqueInput>
    delete?: Enumerable<LibraryBookToAuthorWhereUniqueInput>
    connect?: Enumerable<LibraryBookToAuthorWhereUniqueInput>
    update?: Enumerable<LibraryBookToAuthorUpdateWithWhereUniqueWithoutBookInput>
    updateMany?: Enumerable<LibraryBookToAuthorUpdateManyWithWhereWithoutBookInput>
    deleteMany?: Enumerable<LibraryBookToAuthorScalarWhereInput>
  }

  export type LibraryBookCopyUncheckedUpdateManyWithoutBookNestedInput = {
    create?: XOR<Enumerable<LibraryBookCopyCreateWithoutBookInput>, Enumerable<LibraryBookCopyUncheckedCreateWithoutBookInput>>
    connectOrCreate?: Enumerable<LibraryBookCopyCreateOrConnectWithoutBookInput>
    upsert?: Enumerable<LibraryBookCopyUpsertWithWhereUniqueWithoutBookInput>
    createMany?: LibraryBookCopyCreateManyBookInputEnvelope
    set?: Enumerable<LibraryBookCopyWhereUniqueInput>
    disconnect?: Enumerable<LibraryBookCopyWhereUniqueInput>
    delete?: Enumerable<LibraryBookCopyWhereUniqueInput>
    connect?: Enumerable<LibraryBookCopyWhereUniqueInput>
    update?: Enumerable<LibraryBookCopyUpdateWithWhereUniqueWithoutBookInput>
    updateMany?: Enumerable<LibraryBookCopyUpdateManyWithWhereWithoutBookInput>
    deleteMany?: Enumerable<LibraryBookCopyScalarWhereInput>
  }

  export type LibraryBookCategoryCreateNestedOneWithoutLibraryCategoriesToBooksInput = {
    create?: XOR<LibraryBookCategoryCreateWithoutLibraryCategoriesToBooksInput, LibraryBookCategoryUncheckedCreateWithoutLibraryCategoriesToBooksInput>
    connectOrCreate?: LibraryBookCategoryCreateOrConnectWithoutLibraryCategoriesToBooksInput
    connect?: LibraryBookCategoryWhereUniqueInput
  }

  export type LibraryBookCreateNestedOneWithoutLibraryCategoriesToBooksInput = {
    create?: XOR<LibraryBookCreateWithoutLibraryCategoriesToBooksInput, LibraryBookUncheckedCreateWithoutLibraryCategoriesToBooksInput>
    connectOrCreate?: LibraryBookCreateOrConnectWithoutLibraryCategoriesToBooksInput
    connect?: LibraryBookWhereUniqueInput
  }

  export type LibraryBookCategoryUpdateOneRequiredWithoutLibraryCategoriesToBooksNestedInput = {
    create?: XOR<LibraryBookCategoryCreateWithoutLibraryCategoriesToBooksInput, LibraryBookCategoryUncheckedCreateWithoutLibraryCategoriesToBooksInput>
    connectOrCreate?: LibraryBookCategoryCreateOrConnectWithoutLibraryCategoriesToBooksInput
    upsert?: LibraryBookCategoryUpsertWithoutLibraryCategoriesToBooksInput
    connect?: LibraryBookCategoryWhereUniqueInput
    update?: XOR<LibraryBookCategoryUpdateWithoutLibraryCategoriesToBooksInput, LibraryBookCategoryUncheckedUpdateWithoutLibraryCategoriesToBooksInput>
  }

  export type LibraryBookUpdateOneRequiredWithoutLibraryCategoriesToBooksNestedInput = {
    create?: XOR<LibraryBookCreateWithoutLibraryCategoriesToBooksInput, LibraryBookUncheckedCreateWithoutLibraryCategoriesToBooksInput>
    connectOrCreate?: LibraryBookCreateOrConnectWithoutLibraryCategoriesToBooksInput
    upsert?: LibraryBookUpsertWithoutLibraryCategoriesToBooksInput
    connect?: LibraryBookWhereUniqueInput
    update?: XOR<LibraryBookUpdateWithoutLibraryCategoriesToBooksInput, LibraryBookUncheckedUpdateWithoutLibraryCategoriesToBooksInput>
  }

  export type LibraryBookToAuthorCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<LibraryBookToAuthorCreateWithoutAuthorInput>, Enumerable<LibraryBookToAuthorUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<LibraryBookToAuthorCreateOrConnectWithoutAuthorInput>
    createMany?: LibraryBookToAuthorCreateManyAuthorInputEnvelope
    connect?: Enumerable<LibraryBookToAuthorWhereUniqueInput>
  }

  export type LibraryBookToAuthorUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<LibraryBookToAuthorCreateWithoutAuthorInput>, Enumerable<LibraryBookToAuthorUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<LibraryBookToAuthorCreateOrConnectWithoutAuthorInput>
    createMany?: LibraryBookToAuthorCreateManyAuthorInputEnvelope
    connect?: Enumerable<LibraryBookToAuthorWhereUniqueInput>
  }

  export type LibraryBookToAuthorUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<Enumerable<LibraryBookToAuthorCreateWithoutAuthorInput>, Enumerable<LibraryBookToAuthorUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<LibraryBookToAuthorCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<LibraryBookToAuthorUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: LibraryBookToAuthorCreateManyAuthorInputEnvelope
    set?: Enumerable<LibraryBookToAuthorWhereUniqueInput>
    disconnect?: Enumerable<LibraryBookToAuthorWhereUniqueInput>
    delete?: Enumerable<LibraryBookToAuthorWhereUniqueInput>
    connect?: Enumerable<LibraryBookToAuthorWhereUniqueInput>
    update?: Enumerable<LibraryBookToAuthorUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<LibraryBookToAuthorUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<LibraryBookToAuthorScalarWhereInput>
  }

  export type LibraryBookToAuthorUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<Enumerable<LibraryBookToAuthorCreateWithoutAuthorInput>, Enumerable<LibraryBookToAuthorUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<LibraryBookToAuthorCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<LibraryBookToAuthorUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: LibraryBookToAuthorCreateManyAuthorInputEnvelope
    set?: Enumerable<LibraryBookToAuthorWhereUniqueInput>
    disconnect?: Enumerable<LibraryBookToAuthorWhereUniqueInput>
    delete?: Enumerable<LibraryBookToAuthorWhereUniqueInput>
    connect?: Enumerable<LibraryBookToAuthorWhereUniqueInput>
    update?: Enumerable<LibraryBookToAuthorUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<LibraryBookToAuthorUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<LibraryBookToAuthorScalarWhereInput>
  }

  export type LibraryBookCreateNestedOneWithoutLibraryBooksToAuthorsInput = {
    create?: XOR<LibraryBookCreateWithoutLibraryBooksToAuthorsInput, LibraryBookUncheckedCreateWithoutLibraryBooksToAuthorsInput>
    connectOrCreate?: LibraryBookCreateOrConnectWithoutLibraryBooksToAuthorsInput
    connect?: LibraryBookWhereUniqueInput
  }

  export type LibraryBookAuthorCreateNestedOneWithoutLibraryBooksToAuthorsInput = {
    create?: XOR<LibraryBookAuthorCreateWithoutLibraryBooksToAuthorsInput, LibraryBookAuthorUncheckedCreateWithoutLibraryBooksToAuthorsInput>
    connectOrCreate?: LibraryBookAuthorCreateOrConnectWithoutLibraryBooksToAuthorsInput
    connect?: LibraryBookAuthorWhereUniqueInput
  }

  export type LibraryBookUpdateOneRequiredWithoutLibraryBooksToAuthorsNestedInput = {
    create?: XOR<LibraryBookCreateWithoutLibraryBooksToAuthorsInput, LibraryBookUncheckedCreateWithoutLibraryBooksToAuthorsInput>
    connectOrCreate?: LibraryBookCreateOrConnectWithoutLibraryBooksToAuthorsInput
    upsert?: LibraryBookUpsertWithoutLibraryBooksToAuthorsInput
    connect?: LibraryBookWhereUniqueInput
    update?: XOR<LibraryBookUpdateWithoutLibraryBooksToAuthorsInput, LibraryBookUncheckedUpdateWithoutLibraryBooksToAuthorsInput>
  }

  export type LibraryBookAuthorUpdateOneRequiredWithoutLibraryBooksToAuthorsNestedInput = {
    create?: XOR<LibraryBookAuthorCreateWithoutLibraryBooksToAuthorsInput, LibraryBookAuthorUncheckedCreateWithoutLibraryBooksToAuthorsInput>
    connectOrCreate?: LibraryBookAuthorCreateOrConnectWithoutLibraryBooksToAuthorsInput
    upsert?: LibraryBookAuthorUpsertWithoutLibraryBooksToAuthorsInput
    connect?: LibraryBookAuthorWhereUniqueInput
    update?: XOR<LibraryBookAuthorUpdateWithoutLibraryBooksToAuthorsInput, LibraryBookAuthorUncheckedUpdateWithoutLibraryBooksToAuthorsInput>
  }

  export type LibraryStudentCreateNestedManyWithoutUniversityInput = {
    create?: XOR<Enumerable<LibraryStudentCreateWithoutUniversityInput>, Enumerable<LibraryStudentUncheckedCreateWithoutUniversityInput>>
    connectOrCreate?: Enumerable<LibraryStudentCreateOrConnectWithoutUniversityInput>
    createMany?: LibraryStudentCreateManyUniversityInputEnvelope
    connect?: Enumerable<LibraryStudentWhereUniqueInput>
  }

  export type LibraryBookCopyCreateNestedManyWithoutUniversityInput = {
    create?: XOR<Enumerable<LibraryBookCopyCreateWithoutUniversityInput>, Enumerable<LibraryBookCopyUncheckedCreateWithoutUniversityInput>>
    connectOrCreate?: Enumerable<LibraryBookCopyCreateOrConnectWithoutUniversityInput>
    createMany?: LibraryBookCopyCreateManyUniversityInputEnvelope
    connect?: Enumerable<LibraryBookCopyWhereUniqueInput>
  }

  export type LibraryBorrowingHistoryCreateNestedManyWithoutBorrowedFromInput = {
    create?: XOR<Enumerable<LibraryBorrowingHistoryCreateWithoutBorrowedFromInput>, Enumerable<LibraryBorrowingHistoryUncheckedCreateWithoutBorrowedFromInput>>
    connectOrCreate?: Enumerable<LibraryBorrowingHistoryCreateOrConnectWithoutBorrowedFromInput>
    createMany?: LibraryBorrowingHistoryCreateManyBorrowedFromInputEnvelope
    connect?: Enumerable<LibraryBorrowingHistoryWhereUniqueInput>
  }

  export type LibraryRequestCreateNestedManyWithoutFromInput = {
    create?: XOR<Enumerable<LibraryRequestCreateWithoutFromInput>, Enumerable<LibraryRequestUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<LibraryRequestCreateOrConnectWithoutFromInput>
    createMany?: LibraryRequestCreateManyFromInputEnvelope
    connect?: Enumerable<LibraryRequestWhereUniqueInput>
  }

  export type LibraryRequestCreateNestedManyWithoutToInput = {
    create?: XOR<Enumerable<LibraryRequestCreateWithoutToInput>, Enumerable<LibraryRequestUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<LibraryRequestCreateOrConnectWithoutToInput>
    createMany?: LibraryRequestCreateManyToInputEnvelope
    connect?: Enumerable<LibraryRequestWhereUniqueInput>
  }

  export type LibraryStudentUncheckedCreateNestedManyWithoutUniversityInput = {
    create?: XOR<Enumerable<LibraryStudentCreateWithoutUniversityInput>, Enumerable<LibraryStudentUncheckedCreateWithoutUniversityInput>>
    connectOrCreate?: Enumerable<LibraryStudentCreateOrConnectWithoutUniversityInput>
    createMany?: LibraryStudentCreateManyUniversityInputEnvelope
    connect?: Enumerable<LibraryStudentWhereUniqueInput>
  }

  export type LibraryBookCopyUncheckedCreateNestedManyWithoutUniversityInput = {
    create?: XOR<Enumerable<LibraryBookCopyCreateWithoutUniversityInput>, Enumerable<LibraryBookCopyUncheckedCreateWithoutUniversityInput>>
    connectOrCreate?: Enumerable<LibraryBookCopyCreateOrConnectWithoutUniversityInput>
    createMany?: LibraryBookCopyCreateManyUniversityInputEnvelope
    connect?: Enumerable<LibraryBookCopyWhereUniqueInput>
  }

  export type LibraryBorrowingHistoryUncheckedCreateNestedManyWithoutBorrowedFromInput = {
    create?: XOR<Enumerable<LibraryBorrowingHistoryCreateWithoutBorrowedFromInput>, Enumerable<LibraryBorrowingHistoryUncheckedCreateWithoutBorrowedFromInput>>
    connectOrCreate?: Enumerable<LibraryBorrowingHistoryCreateOrConnectWithoutBorrowedFromInput>
    createMany?: LibraryBorrowingHistoryCreateManyBorrowedFromInputEnvelope
    connect?: Enumerable<LibraryBorrowingHistoryWhereUniqueInput>
  }

  export type LibraryRequestUncheckedCreateNestedManyWithoutFromInput = {
    create?: XOR<Enumerable<LibraryRequestCreateWithoutFromInput>, Enumerable<LibraryRequestUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<LibraryRequestCreateOrConnectWithoutFromInput>
    createMany?: LibraryRequestCreateManyFromInputEnvelope
    connect?: Enumerable<LibraryRequestWhereUniqueInput>
  }

  export type LibraryRequestUncheckedCreateNestedManyWithoutToInput = {
    create?: XOR<Enumerable<LibraryRequestCreateWithoutToInput>, Enumerable<LibraryRequestUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<LibraryRequestCreateOrConnectWithoutToInput>
    createMany?: LibraryRequestCreateManyToInputEnvelope
    connect?: Enumerable<LibraryRequestWhereUniqueInput>
  }

  export type LibraryStudentUpdateManyWithoutUniversityNestedInput = {
    create?: XOR<Enumerable<LibraryStudentCreateWithoutUniversityInput>, Enumerable<LibraryStudentUncheckedCreateWithoutUniversityInput>>
    connectOrCreate?: Enumerable<LibraryStudentCreateOrConnectWithoutUniversityInput>
    upsert?: Enumerable<LibraryStudentUpsertWithWhereUniqueWithoutUniversityInput>
    createMany?: LibraryStudentCreateManyUniversityInputEnvelope
    set?: Enumerable<LibraryStudentWhereUniqueInput>
    disconnect?: Enumerable<LibraryStudentWhereUniqueInput>
    delete?: Enumerable<LibraryStudentWhereUniqueInput>
    connect?: Enumerable<LibraryStudentWhereUniqueInput>
    update?: Enumerable<LibraryStudentUpdateWithWhereUniqueWithoutUniversityInput>
    updateMany?: Enumerable<LibraryStudentUpdateManyWithWhereWithoutUniversityInput>
    deleteMany?: Enumerable<LibraryStudentScalarWhereInput>
  }

  export type LibraryBookCopyUpdateManyWithoutUniversityNestedInput = {
    create?: XOR<Enumerable<LibraryBookCopyCreateWithoutUniversityInput>, Enumerable<LibraryBookCopyUncheckedCreateWithoutUniversityInput>>
    connectOrCreate?: Enumerable<LibraryBookCopyCreateOrConnectWithoutUniversityInput>
    upsert?: Enumerable<LibraryBookCopyUpsertWithWhereUniqueWithoutUniversityInput>
    createMany?: LibraryBookCopyCreateManyUniversityInputEnvelope
    set?: Enumerable<LibraryBookCopyWhereUniqueInput>
    disconnect?: Enumerable<LibraryBookCopyWhereUniqueInput>
    delete?: Enumerable<LibraryBookCopyWhereUniqueInput>
    connect?: Enumerable<LibraryBookCopyWhereUniqueInput>
    update?: Enumerable<LibraryBookCopyUpdateWithWhereUniqueWithoutUniversityInput>
    updateMany?: Enumerable<LibraryBookCopyUpdateManyWithWhereWithoutUniversityInput>
    deleteMany?: Enumerable<LibraryBookCopyScalarWhereInput>
  }

  export type LibraryBorrowingHistoryUpdateManyWithoutBorrowedFromNestedInput = {
    create?: XOR<Enumerable<LibraryBorrowingHistoryCreateWithoutBorrowedFromInput>, Enumerable<LibraryBorrowingHistoryUncheckedCreateWithoutBorrowedFromInput>>
    connectOrCreate?: Enumerable<LibraryBorrowingHistoryCreateOrConnectWithoutBorrowedFromInput>
    upsert?: Enumerable<LibraryBorrowingHistoryUpsertWithWhereUniqueWithoutBorrowedFromInput>
    createMany?: LibraryBorrowingHistoryCreateManyBorrowedFromInputEnvelope
    set?: Enumerable<LibraryBorrowingHistoryWhereUniqueInput>
    disconnect?: Enumerable<LibraryBorrowingHistoryWhereUniqueInput>
    delete?: Enumerable<LibraryBorrowingHistoryWhereUniqueInput>
    connect?: Enumerable<LibraryBorrowingHistoryWhereUniqueInput>
    update?: Enumerable<LibraryBorrowingHistoryUpdateWithWhereUniqueWithoutBorrowedFromInput>
    updateMany?: Enumerable<LibraryBorrowingHistoryUpdateManyWithWhereWithoutBorrowedFromInput>
    deleteMany?: Enumerable<LibraryBorrowingHistoryScalarWhereInput>
  }

  export type LibraryRequestUpdateManyWithoutFromNestedInput = {
    create?: XOR<Enumerable<LibraryRequestCreateWithoutFromInput>, Enumerable<LibraryRequestUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<LibraryRequestCreateOrConnectWithoutFromInput>
    upsert?: Enumerable<LibraryRequestUpsertWithWhereUniqueWithoutFromInput>
    createMany?: LibraryRequestCreateManyFromInputEnvelope
    set?: Enumerable<LibraryRequestWhereUniqueInput>
    disconnect?: Enumerable<LibraryRequestWhereUniqueInput>
    delete?: Enumerable<LibraryRequestWhereUniqueInput>
    connect?: Enumerable<LibraryRequestWhereUniqueInput>
    update?: Enumerable<LibraryRequestUpdateWithWhereUniqueWithoutFromInput>
    updateMany?: Enumerable<LibraryRequestUpdateManyWithWhereWithoutFromInput>
    deleteMany?: Enumerable<LibraryRequestScalarWhereInput>
  }

  export type LibraryRequestUpdateManyWithoutToNestedInput = {
    create?: XOR<Enumerable<LibraryRequestCreateWithoutToInput>, Enumerable<LibraryRequestUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<LibraryRequestCreateOrConnectWithoutToInput>
    upsert?: Enumerable<LibraryRequestUpsertWithWhereUniqueWithoutToInput>
    createMany?: LibraryRequestCreateManyToInputEnvelope
    set?: Enumerable<LibraryRequestWhereUniqueInput>
    disconnect?: Enumerable<LibraryRequestWhereUniqueInput>
    delete?: Enumerable<LibraryRequestWhereUniqueInput>
    connect?: Enumerable<LibraryRequestWhereUniqueInput>
    update?: Enumerable<LibraryRequestUpdateWithWhereUniqueWithoutToInput>
    updateMany?: Enumerable<LibraryRequestUpdateManyWithWhereWithoutToInput>
    deleteMany?: Enumerable<LibraryRequestScalarWhereInput>
  }

  export type LibraryStudentUncheckedUpdateManyWithoutUniversityNestedInput = {
    create?: XOR<Enumerable<LibraryStudentCreateWithoutUniversityInput>, Enumerable<LibraryStudentUncheckedCreateWithoutUniversityInput>>
    connectOrCreate?: Enumerable<LibraryStudentCreateOrConnectWithoutUniversityInput>
    upsert?: Enumerable<LibraryStudentUpsertWithWhereUniqueWithoutUniversityInput>
    createMany?: LibraryStudentCreateManyUniversityInputEnvelope
    set?: Enumerable<LibraryStudentWhereUniqueInput>
    disconnect?: Enumerable<LibraryStudentWhereUniqueInput>
    delete?: Enumerable<LibraryStudentWhereUniqueInput>
    connect?: Enumerable<LibraryStudentWhereUniqueInput>
    update?: Enumerable<LibraryStudentUpdateWithWhereUniqueWithoutUniversityInput>
    updateMany?: Enumerable<LibraryStudentUpdateManyWithWhereWithoutUniversityInput>
    deleteMany?: Enumerable<LibraryStudentScalarWhereInput>
  }

  export type LibraryBookCopyUncheckedUpdateManyWithoutUniversityNestedInput = {
    create?: XOR<Enumerable<LibraryBookCopyCreateWithoutUniversityInput>, Enumerable<LibraryBookCopyUncheckedCreateWithoutUniversityInput>>
    connectOrCreate?: Enumerable<LibraryBookCopyCreateOrConnectWithoutUniversityInput>
    upsert?: Enumerable<LibraryBookCopyUpsertWithWhereUniqueWithoutUniversityInput>
    createMany?: LibraryBookCopyCreateManyUniversityInputEnvelope
    set?: Enumerable<LibraryBookCopyWhereUniqueInput>
    disconnect?: Enumerable<LibraryBookCopyWhereUniqueInput>
    delete?: Enumerable<LibraryBookCopyWhereUniqueInput>
    connect?: Enumerable<LibraryBookCopyWhereUniqueInput>
    update?: Enumerable<LibraryBookCopyUpdateWithWhereUniqueWithoutUniversityInput>
    updateMany?: Enumerable<LibraryBookCopyUpdateManyWithWhereWithoutUniversityInput>
    deleteMany?: Enumerable<LibraryBookCopyScalarWhereInput>
  }

  export type LibraryBorrowingHistoryUncheckedUpdateManyWithoutBorrowedFromNestedInput = {
    create?: XOR<Enumerable<LibraryBorrowingHistoryCreateWithoutBorrowedFromInput>, Enumerable<LibraryBorrowingHistoryUncheckedCreateWithoutBorrowedFromInput>>
    connectOrCreate?: Enumerable<LibraryBorrowingHistoryCreateOrConnectWithoutBorrowedFromInput>
    upsert?: Enumerable<LibraryBorrowingHistoryUpsertWithWhereUniqueWithoutBorrowedFromInput>
    createMany?: LibraryBorrowingHistoryCreateManyBorrowedFromInputEnvelope
    set?: Enumerable<LibraryBorrowingHistoryWhereUniqueInput>
    disconnect?: Enumerable<LibraryBorrowingHistoryWhereUniqueInput>
    delete?: Enumerable<LibraryBorrowingHistoryWhereUniqueInput>
    connect?: Enumerable<LibraryBorrowingHistoryWhereUniqueInput>
    update?: Enumerable<LibraryBorrowingHistoryUpdateWithWhereUniqueWithoutBorrowedFromInput>
    updateMany?: Enumerable<LibraryBorrowingHistoryUpdateManyWithWhereWithoutBorrowedFromInput>
    deleteMany?: Enumerable<LibraryBorrowingHistoryScalarWhereInput>
  }

  export type LibraryRequestUncheckedUpdateManyWithoutFromNestedInput = {
    create?: XOR<Enumerable<LibraryRequestCreateWithoutFromInput>, Enumerable<LibraryRequestUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<LibraryRequestCreateOrConnectWithoutFromInput>
    upsert?: Enumerable<LibraryRequestUpsertWithWhereUniqueWithoutFromInput>
    createMany?: LibraryRequestCreateManyFromInputEnvelope
    set?: Enumerable<LibraryRequestWhereUniqueInput>
    disconnect?: Enumerable<LibraryRequestWhereUniqueInput>
    delete?: Enumerable<LibraryRequestWhereUniqueInput>
    connect?: Enumerable<LibraryRequestWhereUniqueInput>
    update?: Enumerable<LibraryRequestUpdateWithWhereUniqueWithoutFromInput>
    updateMany?: Enumerable<LibraryRequestUpdateManyWithWhereWithoutFromInput>
    deleteMany?: Enumerable<LibraryRequestScalarWhereInput>
  }

  export type LibraryRequestUncheckedUpdateManyWithoutToNestedInput = {
    create?: XOR<Enumerable<LibraryRequestCreateWithoutToInput>, Enumerable<LibraryRequestUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<LibraryRequestCreateOrConnectWithoutToInput>
    upsert?: Enumerable<LibraryRequestUpsertWithWhereUniqueWithoutToInput>
    createMany?: LibraryRequestCreateManyToInputEnvelope
    set?: Enumerable<LibraryRequestWhereUniqueInput>
    disconnect?: Enumerable<LibraryRequestWhereUniqueInput>
    delete?: Enumerable<LibraryRequestWhereUniqueInput>
    connect?: Enumerable<LibraryRequestWhereUniqueInput>
    update?: Enumerable<LibraryRequestUpdateWithWhereUniqueWithoutToInput>
    updateMany?: Enumerable<LibraryRequestUpdateManyWithWhereWithoutToInput>
    deleteMany?: Enumerable<LibraryRequestScalarWhereInput>
  }

  export type LibraryUniversityCreateNestedOneWithoutLibraryStudentaInput = {
    create?: XOR<LibraryUniversityCreateWithoutLibraryStudentaInput, LibraryUniversityUncheckedCreateWithoutLibraryStudentaInput>
    connectOrCreate?: LibraryUniversityCreateOrConnectWithoutLibraryStudentaInput
    connect?: LibraryUniversityWhereUniqueInput
  }

  export type LibraryBookCopyCreateNestedManyWithoutBorrowedByInput = {
    create?: XOR<Enumerable<LibraryBookCopyCreateWithoutBorrowedByInput>, Enumerable<LibraryBookCopyUncheckedCreateWithoutBorrowedByInput>>
    connectOrCreate?: Enumerable<LibraryBookCopyCreateOrConnectWithoutBorrowedByInput>
    createMany?: LibraryBookCopyCreateManyBorrowedByInputEnvelope
    connect?: Enumerable<LibraryBookCopyWhereUniqueInput>
  }

  export type LibraryBorrowingHistoryCreateNestedManyWithoutStudentInput = {
    create?: XOR<Enumerable<LibraryBorrowingHistoryCreateWithoutStudentInput>, Enumerable<LibraryBorrowingHistoryUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<LibraryBorrowingHistoryCreateOrConnectWithoutStudentInput>
    createMany?: LibraryBorrowingHistoryCreateManyStudentInputEnvelope
    connect?: Enumerable<LibraryBorrowingHistoryWhereUniqueInput>
  }

  export type LibraryRequestCreateNestedManyWithoutStudentInput = {
    create?: XOR<Enumerable<LibraryRequestCreateWithoutStudentInput>, Enumerable<LibraryRequestUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<LibraryRequestCreateOrConnectWithoutStudentInput>
    createMany?: LibraryRequestCreateManyStudentInputEnvelope
    connect?: Enumerable<LibraryRequestWhereUniqueInput>
  }

  export type LibraryBookCopyUncheckedCreateNestedManyWithoutBorrowedByInput = {
    create?: XOR<Enumerable<LibraryBookCopyCreateWithoutBorrowedByInput>, Enumerable<LibraryBookCopyUncheckedCreateWithoutBorrowedByInput>>
    connectOrCreate?: Enumerable<LibraryBookCopyCreateOrConnectWithoutBorrowedByInput>
    createMany?: LibraryBookCopyCreateManyBorrowedByInputEnvelope
    connect?: Enumerable<LibraryBookCopyWhereUniqueInput>
  }

  export type LibraryBorrowingHistoryUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<Enumerable<LibraryBorrowingHistoryCreateWithoutStudentInput>, Enumerable<LibraryBorrowingHistoryUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<LibraryBorrowingHistoryCreateOrConnectWithoutStudentInput>
    createMany?: LibraryBorrowingHistoryCreateManyStudentInputEnvelope
    connect?: Enumerable<LibraryBorrowingHistoryWhereUniqueInput>
  }

  export type LibraryRequestUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<Enumerable<LibraryRequestCreateWithoutStudentInput>, Enumerable<LibraryRequestUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<LibraryRequestCreateOrConnectWithoutStudentInput>
    createMany?: LibraryRequestCreateManyStudentInputEnvelope
    connect?: Enumerable<LibraryRequestWhereUniqueInput>
  }

  export type LibraryUniversityUpdateOneRequiredWithoutLibraryStudentaNestedInput = {
    create?: XOR<LibraryUniversityCreateWithoutLibraryStudentaInput, LibraryUniversityUncheckedCreateWithoutLibraryStudentaInput>
    connectOrCreate?: LibraryUniversityCreateOrConnectWithoutLibraryStudentaInput
    upsert?: LibraryUniversityUpsertWithoutLibraryStudentaInput
    connect?: LibraryUniversityWhereUniqueInput
    update?: XOR<LibraryUniversityUpdateWithoutLibraryStudentaInput, LibraryUniversityUncheckedUpdateWithoutLibraryStudentaInput>
  }

  export type LibraryBookCopyUpdateManyWithoutBorrowedByNestedInput = {
    create?: XOR<Enumerable<LibraryBookCopyCreateWithoutBorrowedByInput>, Enumerable<LibraryBookCopyUncheckedCreateWithoutBorrowedByInput>>
    connectOrCreate?: Enumerable<LibraryBookCopyCreateOrConnectWithoutBorrowedByInput>
    upsert?: Enumerable<LibraryBookCopyUpsertWithWhereUniqueWithoutBorrowedByInput>
    createMany?: LibraryBookCopyCreateManyBorrowedByInputEnvelope
    set?: Enumerable<LibraryBookCopyWhereUniqueInput>
    disconnect?: Enumerable<LibraryBookCopyWhereUniqueInput>
    delete?: Enumerable<LibraryBookCopyWhereUniqueInput>
    connect?: Enumerable<LibraryBookCopyWhereUniqueInput>
    update?: Enumerable<LibraryBookCopyUpdateWithWhereUniqueWithoutBorrowedByInput>
    updateMany?: Enumerable<LibraryBookCopyUpdateManyWithWhereWithoutBorrowedByInput>
    deleteMany?: Enumerable<LibraryBookCopyScalarWhereInput>
  }

  export type LibraryBorrowingHistoryUpdateManyWithoutStudentNestedInput = {
    create?: XOR<Enumerable<LibraryBorrowingHistoryCreateWithoutStudentInput>, Enumerable<LibraryBorrowingHistoryUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<LibraryBorrowingHistoryCreateOrConnectWithoutStudentInput>
    upsert?: Enumerable<LibraryBorrowingHistoryUpsertWithWhereUniqueWithoutStudentInput>
    createMany?: LibraryBorrowingHistoryCreateManyStudentInputEnvelope
    set?: Enumerable<LibraryBorrowingHistoryWhereUniqueInput>
    disconnect?: Enumerable<LibraryBorrowingHistoryWhereUniqueInput>
    delete?: Enumerable<LibraryBorrowingHistoryWhereUniqueInput>
    connect?: Enumerable<LibraryBorrowingHistoryWhereUniqueInput>
    update?: Enumerable<LibraryBorrowingHistoryUpdateWithWhereUniqueWithoutStudentInput>
    updateMany?: Enumerable<LibraryBorrowingHistoryUpdateManyWithWhereWithoutStudentInput>
    deleteMany?: Enumerable<LibraryBorrowingHistoryScalarWhereInput>
  }

  export type LibraryRequestUpdateManyWithoutStudentNestedInput = {
    create?: XOR<Enumerable<LibraryRequestCreateWithoutStudentInput>, Enumerable<LibraryRequestUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<LibraryRequestCreateOrConnectWithoutStudentInput>
    upsert?: Enumerable<LibraryRequestUpsertWithWhereUniqueWithoutStudentInput>
    createMany?: LibraryRequestCreateManyStudentInputEnvelope
    set?: Enumerable<LibraryRequestWhereUniqueInput>
    disconnect?: Enumerable<LibraryRequestWhereUniqueInput>
    delete?: Enumerable<LibraryRequestWhereUniqueInput>
    connect?: Enumerable<LibraryRequestWhereUniqueInput>
    update?: Enumerable<LibraryRequestUpdateWithWhereUniqueWithoutStudentInput>
    updateMany?: Enumerable<LibraryRequestUpdateManyWithWhereWithoutStudentInput>
    deleteMany?: Enumerable<LibraryRequestScalarWhereInput>
  }

  export type LibraryBookCopyUncheckedUpdateManyWithoutBorrowedByNestedInput = {
    create?: XOR<Enumerable<LibraryBookCopyCreateWithoutBorrowedByInput>, Enumerable<LibraryBookCopyUncheckedCreateWithoutBorrowedByInput>>
    connectOrCreate?: Enumerable<LibraryBookCopyCreateOrConnectWithoutBorrowedByInput>
    upsert?: Enumerable<LibraryBookCopyUpsertWithWhereUniqueWithoutBorrowedByInput>
    createMany?: LibraryBookCopyCreateManyBorrowedByInputEnvelope
    set?: Enumerable<LibraryBookCopyWhereUniqueInput>
    disconnect?: Enumerable<LibraryBookCopyWhereUniqueInput>
    delete?: Enumerable<LibraryBookCopyWhereUniqueInput>
    connect?: Enumerable<LibraryBookCopyWhereUniqueInput>
    update?: Enumerable<LibraryBookCopyUpdateWithWhereUniqueWithoutBorrowedByInput>
    updateMany?: Enumerable<LibraryBookCopyUpdateManyWithWhereWithoutBorrowedByInput>
    deleteMany?: Enumerable<LibraryBookCopyScalarWhereInput>
  }

  export type LibraryBorrowingHistoryUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<Enumerable<LibraryBorrowingHistoryCreateWithoutStudentInput>, Enumerable<LibraryBorrowingHistoryUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<LibraryBorrowingHistoryCreateOrConnectWithoutStudentInput>
    upsert?: Enumerable<LibraryBorrowingHistoryUpsertWithWhereUniqueWithoutStudentInput>
    createMany?: LibraryBorrowingHistoryCreateManyStudentInputEnvelope
    set?: Enumerable<LibraryBorrowingHistoryWhereUniqueInput>
    disconnect?: Enumerable<LibraryBorrowingHistoryWhereUniqueInput>
    delete?: Enumerable<LibraryBorrowingHistoryWhereUniqueInput>
    connect?: Enumerable<LibraryBorrowingHistoryWhereUniqueInput>
    update?: Enumerable<LibraryBorrowingHistoryUpdateWithWhereUniqueWithoutStudentInput>
    updateMany?: Enumerable<LibraryBorrowingHistoryUpdateManyWithWhereWithoutStudentInput>
    deleteMany?: Enumerable<LibraryBorrowingHistoryScalarWhereInput>
  }

  export type LibraryRequestUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<Enumerable<LibraryRequestCreateWithoutStudentInput>, Enumerable<LibraryRequestUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<LibraryRequestCreateOrConnectWithoutStudentInput>
    upsert?: Enumerable<LibraryRequestUpsertWithWhereUniqueWithoutStudentInput>
    createMany?: LibraryRequestCreateManyStudentInputEnvelope
    set?: Enumerable<LibraryRequestWhereUniqueInput>
    disconnect?: Enumerable<LibraryRequestWhereUniqueInput>
    delete?: Enumerable<LibraryRequestWhereUniqueInput>
    connect?: Enumerable<LibraryRequestWhereUniqueInput>
    update?: Enumerable<LibraryRequestUpdateWithWhereUniqueWithoutStudentInput>
    updateMany?: Enumerable<LibraryRequestUpdateManyWithWhereWithoutStudentInput>
    deleteMany?: Enumerable<LibraryRequestScalarWhereInput>
  }

  export type LibraryBookCreateNestedOneWithoutLibraryBookCopiesInput = {
    create?: XOR<LibraryBookCreateWithoutLibraryBookCopiesInput, LibraryBookUncheckedCreateWithoutLibraryBookCopiesInput>
    connectOrCreate?: LibraryBookCreateOrConnectWithoutLibraryBookCopiesInput
    connect?: LibraryBookWhereUniqueInput
  }

  export type LibraryUniversityCreateNestedOneWithoutLibraryBookCopiesInput = {
    create?: XOR<LibraryUniversityCreateWithoutLibraryBookCopiesInput, LibraryUniversityUncheckedCreateWithoutLibraryBookCopiesInput>
    connectOrCreate?: LibraryUniversityCreateOrConnectWithoutLibraryBookCopiesInput
    connect?: LibraryUniversityWhereUniqueInput
  }

  export type LibraryStudentCreateNestedOneWithoutLibraryBookCopiesInput = {
    create?: XOR<LibraryStudentCreateWithoutLibraryBookCopiesInput, LibraryStudentUncheckedCreateWithoutLibraryBookCopiesInput>
    connectOrCreate?: LibraryStudentCreateOrConnectWithoutLibraryBookCopiesInput
    connect?: LibraryStudentWhereUniqueInput
  }

  export type LibraryBorrowingHistoryCreateNestedManyWithoutCopyInput = {
    create?: XOR<Enumerable<LibraryBorrowingHistoryCreateWithoutCopyInput>, Enumerable<LibraryBorrowingHistoryUncheckedCreateWithoutCopyInput>>
    connectOrCreate?: Enumerable<LibraryBorrowingHistoryCreateOrConnectWithoutCopyInput>
    createMany?: LibraryBorrowingHistoryCreateManyCopyInputEnvelope
    connect?: Enumerable<LibraryBorrowingHistoryWhereUniqueInput>
  }

  export type LibraryRequestCreateNestedManyWithoutCopyInput = {
    create?: XOR<Enumerable<LibraryRequestCreateWithoutCopyInput>, Enumerable<LibraryRequestUncheckedCreateWithoutCopyInput>>
    connectOrCreate?: Enumerable<LibraryRequestCreateOrConnectWithoutCopyInput>
    createMany?: LibraryRequestCreateManyCopyInputEnvelope
    connect?: Enumerable<LibraryRequestWhereUniqueInput>
  }

  export type LibraryBorrowingHistoryUncheckedCreateNestedManyWithoutCopyInput = {
    create?: XOR<Enumerable<LibraryBorrowingHistoryCreateWithoutCopyInput>, Enumerable<LibraryBorrowingHistoryUncheckedCreateWithoutCopyInput>>
    connectOrCreate?: Enumerable<LibraryBorrowingHistoryCreateOrConnectWithoutCopyInput>
    createMany?: LibraryBorrowingHistoryCreateManyCopyInputEnvelope
    connect?: Enumerable<LibraryBorrowingHistoryWhereUniqueInput>
  }

  export type LibraryRequestUncheckedCreateNestedManyWithoutCopyInput = {
    create?: XOR<Enumerable<LibraryRequestCreateWithoutCopyInput>, Enumerable<LibraryRequestUncheckedCreateWithoutCopyInput>>
    connectOrCreate?: Enumerable<LibraryRequestCreateOrConnectWithoutCopyInput>
    createMany?: LibraryRequestCreateManyCopyInputEnvelope
    connect?: Enumerable<LibraryRequestWhereUniqueInput>
  }

  export type LibraryBookUpdateOneRequiredWithoutLibraryBookCopiesNestedInput = {
    create?: XOR<LibraryBookCreateWithoutLibraryBookCopiesInput, LibraryBookUncheckedCreateWithoutLibraryBookCopiesInput>
    connectOrCreate?: LibraryBookCreateOrConnectWithoutLibraryBookCopiesInput
    upsert?: LibraryBookUpsertWithoutLibraryBookCopiesInput
    connect?: LibraryBookWhereUniqueInput
    update?: XOR<LibraryBookUpdateWithoutLibraryBookCopiesInput, LibraryBookUncheckedUpdateWithoutLibraryBookCopiesInput>
  }

  export type LibraryUniversityUpdateOneRequiredWithoutLibraryBookCopiesNestedInput = {
    create?: XOR<LibraryUniversityCreateWithoutLibraryBookCopiesInput, LibraryUniversityUncheckedCreateWithoutLibraryBookCopiesInput>
    connectOrCreate?: LibraryUniversityCreateOrConnectWithoutLibraryBookCopiesInput
    upsert?: LibraryUniversityUpsertWithoutLibraryBookCopiesInput
    connect?: LibraryUniversityWhereUniqueInput
    update?: XOR<LibraryUniversityUpdateWithoutLibraryBookCopiesInput, LibraryUniversityUncheckedUpdateWithoutLibraryBookCopiesInput>
  }

  export type LibraryStudentUpdateOneRequiredWithoutLibraryBookCopiesNestedInput = {
    create?: XOR<LibraryStudentCreateWithoutLibraryBookCopiesInput, LibraryStudentUncheckedCreateWithoutLibraryBookCopiesInput>
    connectOrCreate?: LibraryStudentCreateOrConnectWithoutLibraryBookCopiesInput
    upsert?: LibraryStudentUpsertWithoutLibraryBookCopiesInput
    connect?: LibraryStudentWhereUniqueInput
    update?: XOR<LibraryStudentUpdateWithoutLibraryBookCopiesInput, LibraryStudentUncheckedUpdateWithoutLibraryBookCopiesInput>
  }

  export type LibraryBorrowingHistoryUpdateManyWithoutCopyNestedInput = {
    create?: XOR<Enumerable<LibraryBorrowingHistoryCreateWithoutCopyInput>, Enumerable<LibraryBorrowingHistoryUncheckedCreateWithoutCopyInput>>
    connectOrCreate?: Enumerable<LibraryBorrowingHistoryCreateOrConnectWithoutCopyInput>
    upsert?: Enumerable<LibraryBorrowingHistoryUpsertWithWhereUniqueWithoutCopyInput>
    createMany?: LibraryBorrowingHistoryCreateManyCopyInputEnvelope
    set?: Enumerable<LibraryBorrowingHistoryWhereUniqueInput>
    disconnect?: Enumerable<LibraryBorrowingHistoryWhereUniqueInput>
    delete?: Enumerable<LibraryBorrowingHistoryWhereUniqueInput>
    connect?: Enumerable<LibraryBorrowingHistoryWhereUniqueInput>
    update?: Enumerable<LibraryBorrowingHistoryUpdateWithWhereUniqueWithoutCopyInput>
    updateMany?: Enumerable<LibraryBorrowingHistoryUpdateManyWithWhereWithoutCopyInput>
    deleteMany?: Enumerable<LibraryBorrowingHistoryScalarWhereInput>
  }

  export type LibraryRequestUpdateManyWithoutCopyNestedInput = {
    create?: XOR<Enumerable<LibraryRequestCreateWithoutCopyInput>, Enumerable<LibraryRequestUncheckedCreateWithoutCopyInput>>
    connectOrCreate?: Enumerable<LibraryRequestCreateOrConnectWithoutCopyInput>
    upsert?: Enumerable<LibraryRequestUpsertWithWhereUniqueWithoutCopyInput>
    createMany?: LibraryRequestCreateManyCopyInputEnvelope
    set?: Enumerable<LibraryRequestWhereUniqueInput>
    disconnect?: Enumerable<LibraryRequestWhereUniqueInput>
    delete?: Enumerable<LibraryRequestWhereUniqueInput>
    connect?: Enumerable<LibraryRequestWhereUniqueInput>
    update?: Enumerable<LibraryRequestUpdateWithWhereUniqueWithoutCopyInput>
    updateMany?: Enumerable<LibraryRequestUpdateManyWithWhereWithoutCopyInput>
    deleteMany?: Enumerable<LibraryRequestScalarWhereInput>
  }

  export type LibraryBorrowingHistoryUncheckedUpdateManyWithoutCopyNestedInput = {
    create?: XOR<Enumerable<LibraryBorrowingHistoryCreateWithoutCopyInput>, Enumerable<LibraryBorrowingHistoryUncheckedCreateWithoutCopyInput>>
    connectOrCreate?: Enumerable<LibraryBorrowingHistoryCreateOrConnectWithoutCopyInput>
    upsert?: Enumerable<LibraryBorrowingHistoryUpsertWithWhereUniqueWithoutCopyInput>
    createMany?: LibraryBorrowingHistoryCreateManyCopyInputEnvelope
    set?: Enumerable<LibraryBorrowingHistoryWhereUniqueInput>
    disconnect?: Enumerable<LibraryBorrowingHistoryWhereUniqueInput>
    delete?: Enumerable<LibraryBorrowingHistoryWhereUniqueInput>
    connect?: Enumerable<LibraryBorrowingHistoryWhereUniqueInput>
    update?: Enumerable<LibraryBorrowingHistoryUpdateWithWhereUniqueWithoutCopyInput>
    updateMany?: Enumerable<LibraryBorrowingHistoryUpdateManyWithWhereWithoutCopyInput>
    deleteMany?: Enumerable<LibraryBorrowingHistoryScalarWhereInput>
  }

  export type LibraryRequestUncheckedUpdateManyWithoutCopyNestedInput = {
    create?: XOR<Enumerable<LibraryRequestCreateWithoutCopyInput>, Enumerable<LibraryRequestUncheckedCreateWithoutCopyInput>>
    connectOrCreate?: Enumerable<LibraryRequestCreateOrConnectWithoutCopyInput>
    upsert?: Enumerable<LibraryRequestUpsertWithWhereUniqueWithoutCopyInput>
    createMany?: LibraryRequestCreateManyCopyInputEnvelope
    set?: Enumerable<LibraryRequestWhereUniqueInput>
    disconnect?: Enumerable<LibraryRequestWhereUniqueInput>
    delete?: Enumerable<LibraryRequestWhereUniqueInput>
    connect?: Enumerable<LibraryRequestWhereUniqueInput>
    update?: Enumerable<LibraryRequestUpdateWithWhereUniqueWithoutCopyInput>
    updateMany?: Enumerable<LibraryRequestUpdateManyWithWhereWithoutCopyInput>
    deleteMany?: Enumerable<LibraryRequestScalarWhereInput>
  }

  export type LibraryStudentCreateNestedOneWithoutLibraryBorrowingHistoriesInput = {
    create?: XOR<LibraryStudentCreateWithoutLibraryBorrowingHistoriesInput, LibraryStudentUncheckedCreateWithoutLibraryBorrowingHistoriesInput>
    connectOrCreate?: LibraryStudentCreateOrConnectWithoutLibraryBorrowingHistoriesInput
    connect?: LibraryStudentWhereUniqueInput
  }

  export type LibraryBookCopyCreateNestedOneWithoutLibraryBorrowingHistoriesInput = {
    create?: XOR<LibraryBookCopyCreateWithoutLibraryBorrowingHistoriesInput, LibraryBookCopyUncheckedCreateWithoutLibraryBorrowingHistoriesInput>
    connectOrCreate?: LibraryBookCopyCreateOrConnectWithoutLibraryBorrowingHistoriesInput
    connect?: LibraryBookCopyWhereUniqueInput
  }

  export type LibraryUniversityCreateNestedOneWithoutLibraryBorrowingHistoriesInput = {
    create?: XOR<LibraryUniversityCreateWithoutLibraryBorrowingHistoriesInput, LibraryUniversityUncheckedCreateWithoutLibraryBorrowingHistoriesInput>
    connectOrCreate?: LibraryUniversityCreateOrConnectWithoutLibraryBorrowingHistoriesInput
    connect?: LibraryUniversityWhereUniqueInput
  }

  export type LibraryStudentUpdateOneRequiredWithoutLibraryBorrowingHistoriesNestedInput = {
    create?: XOR<LibraryStudentCreateWithoutLibraryBorrowingHistoriesInput, LibraryStudentUncheckedCreateWithoutLibraryBorrowingHistoriesInput>
    connectOrCreate?: LibraryStudentCreateOrConnectWithoutLibraryBorrowingHistoriesInput
    upsert?: LibraryStudentUpsertWithoutLibraryBorrowingHistoriesInput
    connect?: LibraryStudentWhereUniqueInput
    update?: XOR<LibraryStudentUpdateWithoutLibraryBorrowingHistoriesInput, LibraryStudentUncheckedUpdateWithoutLibraryBorrowingHistoriesInput>
  }

  export type LibraryBookCopyUpdateOneRequiredWithoutLibraryBorrowingHistoriesNestedInput = {
    create?: XOR<LibraryBookCopyCreateWithoutLibraryBorrowingHistoriesInput, LibraryBookCopyUncheckedCreateWithoutLibraryBorrowingHistoriesInput>
    connectOrCreate?: LibraryBookCopyCreateOrConnectWithoutLibraryBorrowingHistoriesInput
    upsert?: LibraryBookCopyUpsertWithoutLibraryBorrowingHistoriesInput
    connect?: LibraryBookCopyWhereUniqueInput
    update?: XOR<LibraryBookCopyUpdateWithoutLibraryBorrowingHistoriesInput, LibraryBookCopyUncheckedUpdateWithoutLibraryBorrowingHistoriesInput>
  }

  export type LibraryUniversityUpdateOneRequiredWithoutLibraryBorrowingHistoriesNestedInput = {
    create?: XOR<LibraryUniversityCreateWithoutLibraryBorrowingHistoriesInput, LibraryUniversityUncheckedCreateWithoutLibraryBorrowingHistoriesInput>
    connectOrCreate?: LibraryUniversityCreateOrConnectWithoutLibraryBorrowingHistoriesInput
    upsert?: LibraryUniversityUpsertWithoutLibraryBorrowingHistoriesInput
    connect?: LibraryUniversityWhereUniqueInput
    update?: XOR<LibraryUniversityUpdateWithoutLibraryBorrowingHistoriesInput, LibraryUniversityUncheckedUpdateWithoutLibraryBorrowingHistoriesInput>
  }

  export type LibraryStudentCreateNestedOneWithoutLibraryRequestsInput = {
    create?: XOR<LibraryStudentCreateWithoutLibraryRequestsInput, LibraryStudentUncheckedCreateWithoutLibraryRequestsInput>
    connectOrCreate?: LibraryStudentCreateOrConnectWithoutLibraryRequestsInput
    connect?: LibraryStudentWhereUniqueInput
  }

  export type LibraryBookCopyCreateNestedOneWithoutLibraryRequestsInput = {
    create?: XOR<LibraryBookCopyCreateWithoutLibraryRequestsInput, LibraryBookCopyUncheckedCreateWithoutLibraryRequestsInput>
    connectOrCreate?: LibraryBookCopyCreateOrConnectWithoutLibraryRequestsInput
    connect?: LibraryBookCopyWhereUniqueInput
  }

  export type LibraryUniversityCreateNestedOneWithoutFromLibraryRequestsInput = {
    create?: XOR<LibraryUniversityCreateWithoutFromLibraryRequestsInput, LibraryUniversityUncheckedCreateWithoutFromLibraryRequestsInput>
    connectOrCreate?: LibraryUniversityCreateOrConnectWithoutFromLibraryRequestsInput
    connect?: LibraryUniversityWhereUniqueInput
  }

  export type LibraryUniversityCreateNestedOneWithoutToLibraryRequestsInput = {
    create?: XOR<LibraryUniversityCreateWithoutToLibraryRequestsInput, LibraryUniversityUncheckedCreateWithoutToLibraryRequestsInput>
    connectOrCreate?: LibraryUniversityCreateOrConnectWithoutToLibraryRequestsInput
    connect?: LibraryUniversityWhereUniqueInput
  }

  export type LibraryStudentUpdateOneRequiredWithoutLibraryRequestsNestedInput = {
    create?: XOR<LibraryStudentCreateWithoutLibraryRequestsInput, LibraryStudentUncheckedCreateWithoutLibraryRequestsInput>
    connectOrCreate?: LibraryStudentCreateOrConnectWithoutLibraryRequestsInput
    upsert?: LibraryStudentUpsertWithoutLibraryRequestsInput
    connect?: LibraryStudentWhereUniqueInput
    update?: XOR<LibraryStudentUpdateWithoutLibraryRequestsInput, LibraryStudentUncheckedUpdateWithoutLibraryRequestsInput>
  }

  export type LibraryBookCopyUpdateOneRequiredWithoutLibraryRequestsNestedInput = {
    create?: XOR<LibraryBookCopyCreateWithoutLibraryRequestsInput, LibraryBookCopyUncheckedCreateWithoutLibraryRequestsInput>
    connectOrCreate?: LibraryBookCopyCreateOrConnectWithoutLibraryRequestsInput
    upsert?: LibraryBookCopyUpsertWithoutLibraryRequestsInput
    connect?: LibraryBookCopyWhereUniqueInput
    update?: XOR<LibraryBookCopyUpdateWithoutLibraryRequestsInput, LibraryBookCopyUncheckedUpdateWithoutLibraryRequestsInput>
  }

  export type LibraryUniversityUpdateOneRequiredWithoutFromLibraryRequestsNestedInput = {
    create?: XOR<LibraryUniversityCreateWithoutFromLibraryRequestsInput, LibraryUniversityUncheckedCreateWithoutFromLibraryRequestsInput>
    connectOrCreate?: LibraryUniversityCreateOrConnectWithoutFromLibraryRequestsInput
    upsert?: LibraryUniversityUpsertWithoutFromLibraryRequestsInput
    connect?: LibraryUniversityWhereUniqueInput
    update?: XOR<LibraryUniversityUpdateWithoutFromLibraryRequestsInput, LibraryUniversityUncheckedUpdateWithoutFromLibraryRequestsInput>
  }

  export type LibraryUniversityUpdateOneRequiredWithoutToLibraryRequestsNestedInput = {
    create?: XOR<LibraryUniversityCreateWithoutToLibraryRequestsInput, LibraryUniversityUncheckedCreateWithoutToLibraryRequestsInput>
    connectOrCreate?: LibraryUniversityCreateOrConnectWithoutToLibraryRequestsInput
    upsert?: LibraryUniversityUpsertWithoutToLibraryRequestsInput
    connect?: LibraryUniversityWhereUniqueInput
    update?: XOR<LibraryUniversityUpdateWithoutToLibraryRequestsInput, LibraryUniversityUncheckedUpdateWithoutToLibraryRequestsInput>
  }

  export type QuizQuestionCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<QuizQuestionCreateWithoutCategoryInput>, Enumerable<QuizQuestionUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<QuizQuestionCreateOrConnectWithoutCategoryInput>
    createMany?: QuizQuestionCreateManyCategoryInputEnvelope
    connect?: Enumerable<QuizQuestionWhereUniqueInput>
  }

  export type QuizRoundCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<QuizRoundCreateWithoutCategoryInput>, Enumerable<QuizRoundUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<QuizRoundCreateOrConnectWithoutCategoryInput>
    createMany?: QuizRoundCreateManyCategoryInputEnvelope
    connect?: Enumerable<QuizRoundWhereUniqueInput>
  }

  export type QuizQuestionUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<QuizQuestionCreateWithoutCategoryInput>, Enumerable<QuizQuestionUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<QuizQuestionCreateOrConnectWithoutCategoryInput>
    createMany?: QuizQuestionCreateManyCategoryInputEnvelope
    connect?: Enumerable<QuizQuestionWhereUniqueInput>
  }

  export type QuizRoundUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<QuizRoundCreateWithoutCategoryInput>, Enumerable<QuizRoundUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<QuizRoundCreateOrConnectWithoutCategoryInput>
    createMany?: QuizRoundCreateManyCategoryInputEnvelope
    connect?: Enumerable<QuizRoundWhereUniqueInput>
  }

  export type QuizQuestionUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<QuizQuestionCreateWithoutCategoryInput>, Enumerable<QuizQuestionUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<QuizQuestionCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<QuizQuestionUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: QuizQuestionCreateManyCategoryInputEnvelope
    set?: Enumerable<QuizQuestionWhereUniqueInput>
    disconnect?: Enumerable<QuizQuestionWhereUniqueInput>
    delete?: Enumerable<QuizQuestionWhereUniqueInput>
    connect?: Enumerable<QuizQuestionWhereUniqueInput>
    update?: Enumerable<QuizQuestionUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<QuizQuestionUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<QuizQuestionScalarWhereInput>
  }

  export type QuizRoundUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<QuizRoundCreateWithoutCategoryInput>, Enumerable<QuizRoundUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<QuizRoundCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<QuizRoundUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: QuizRoundCreateManyCategoryInputEnvelope
    set?: Enumerable<QuizRoundWhereUniqueInput>
    disconnect?: Enumerable<QuizRoundWhereUniqueInput>
    delete?: Enumerable<QuizRoundWhereUniqueInput>
    connect?: Enumerable<QuizRoundWhereUniqueInput>
    update?: Enumerable<QuizRoundUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<QuizRoundUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<QuizRoundScalarWhereInput>
  }

  export type QuizQuestionUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<QuizQuestionCreateWithoutCategoryInput>, Enumerable<QuizQuestionUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<QuizQuestionCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<QuizQuestionUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: QuizQuestionCreateManyCategoryInputEnvelope
    set?: Enumerable<QuizQuestionWhereUniqueInput>
    disconnect?: Enumerable<QuizQuestionWhereUniqueInput>
    delete?: Enumerable<QuizQuestionWhereUniqueInput>
    connect?: Enumerable<QuizQuestionWhereUniqueInput>
    update?: Enumerable<QuizQuestionUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<QuizQuestionUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<QuizQuestionScalarWhereInput>
  }

  export type QuizRoundUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<QuizRoundCreateWithoutCategoryInput>, Enumerable<QuizRoundUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<QuizRoundCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<QuizRoundUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: QuizRoundCreateManyCategoryInputEnvelope
    set?: Enumerable<QuizRoundWhereUniqueInput>
    disconnect?: Enumerable<QuizRoundWhereUniqueInput>
    delete?: Enumerable<QuizRoundWhereUniqueInput>
    connect?: Enumerable<QuizRoundWhereUniqueInput>
    update?: Enumerable<QuizRoundUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<QuizRoundUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<QuizRoundScalarWhereInput>
  }

  export type QuizCategoryCreateNestedOneWithoutQuizQuestionInput = {
    create?: XOR<QuizCategoryCreateWithoutQuizQuestionInput, QuizCategoryUncheckedCreateWithoutQuizQuestionInput>
    connectOrCreate?: QuizCategoryCreateOrConnectWithoutQuizQuestionInput
    connect?: QuizCategoryWhereUniqueInput
  }

  export type QuizChoiceCreateNestedManyWithoutQuestionInput = {
    create?: XOR<Enumerable<QuizChoiceCreateWithoutQuestionInput>, Enumerable<QuizChoiceUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<QuizChoiceCreateOrConnectWithoutQuestionInput>
    createMany?: QuizChoiceCreateManyQuestionInputEnvelope
    connect?: Enumerable<QuizChoiceWhereUniqueInput>
  }

  export type QuizRecordCreateNestedManyWithoutQuestionInput = {
    create?: XOR<Enumerable<QuizRecordCreateWithoutQuestionInput>, Enumerable<QuizRecordUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<QuizRecordCreateOrConnectWithoutQuestionInput>
    createMany?: QuizRecordCreateManyQuestionInputEnvelope
    connect?: Enumerable<QuizRecordWhereUniqueInput>
  }

  export type QuizChoiceUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<Enumerable<QuizChoiceCreateWithoutQuestionInput>, Enumerable<QuizChoiceUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<QuizChoiceCreateOrConnectWithoutQuestionInput>
    createMany?: QuizChoiceCreateManyQuestionInputEnvelope
    connect?: Enumerable<QuizChoiceWhereUniqueInput>
  }

  export type QuizRecordUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<Enumerable<QuizRecordCreateWithoutQuestionInput>, Enumerable<QuizRecordUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<QuizRecordCreateOrConnectWithoutQuestionInput>
    createMany?: QuizRecordCreateManyQuestionInputEnvelope
    connect?: Enumerable<QuizRecordWhereUniqueInput>
  }

  export type QuizCategoryUpdateOneWithoutQuizQuestionNestedInput = {
    create?: XOR<QuizCategoryCreateWithoutQuizQuestionInput, QuizCategoryUncheckedCreateWithoutQuizQuestionInput>
    connectOrCreate?: QuizCategoryCreateOrConnectWithoutQuizQuestionInput
    upsert?: QuizCategoryUpsertWithoutQuizQuestionInput
    disconnect?: boolean
    delete?: boolean
    connect?: QuizCategoryWhereUniqueInput
    update?: XOR<QuizCategoryUpdateWithoutQuizQuestionInput, QuizCategoryUncheckedUpdateWithoutQuizQuestionInput>
  }

  export type QuizChoiceUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<Enumerable<QuizChoiceCreateWithoutQuestionInput>, Enumerable<QuizChoiceUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<QuizChoiceCreateOrConnectWithoutQuestionInput>
    upsert?: Enumerable<QuizChoiceUpsertWithWhereUniqueWithoutQuestionInput>
    createMany?: QuizChoiceCreateManyQuestionInputEnvelope
    set?: Enumerable<QuizChoiceWhereUniqueInput>
    disconnect?: Enumerable<QuizChoiceWhereUniqueInput>
    delete?: Enumerable<QuizChoiceWhereUniqueInput>
    connect?: Enumerable<QuizChoiceWhereUniqueInput>
    update?: Enumerable<QuizChoiceUpdateWithWhereUniqueWithoutQuestionInput>
    updateMany?: Enumerable<QuizChoiceUpdateManyWithWhereWithoutQuestionInput>
    deleteMany?: Enumerable<QuizChoiceScalarWhereInput>
  }

  export type QuizRecordUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<Enumerable<QuizRecordCreateWithoutQuestionInput>, Enumerable<QuizRecordUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<QuizRecordCreateOrConnectWithoutQuestionInput>
    upsert?: Enumerable<QuizRecordUpsertWithWhereUniqueWithoutQuestionInput>
    createMany?: QuizRecordCreateManyQuestionInputEnvelope
    set?: Enumerable<QuizRecordWhereUniqueInput>
    disconnect?: Enumerable<QuizRecordWhereUniqueInput>
    delete?: Enumerable<QuizRecordWhereUniqueInput>
    connect?: Enumerable<QuizRecordWhereUniqueInput>
    update?: Enumerable<QuizRecordUpdateWithWhereUniqueWithoutQuestionInput>
    updateMany?: Enumerable<QuizRecordUpdateManyWithWhereWithoutQuestionInput>
    deleteMany?: Enumerable<QuizRecordScalarWhereInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type QuizChoiceUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<Enumerable<QuizChoiceCreateWithoutQuestionInput>, Enumerable<QuizChoiceUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<QuizChoiceCreateOrConnectWithoutQuestionInput>
    upsert?: Enumerable<QuizChoiceUpsertWithWhereUniqueWithoutQuestionInput>
    createMany?: QuizChoiceCreateManyQuestionInputEnvelope
    set?: Enumerable<QuizChoiceWhereUniqueInput>
    disconnect?: Enumerable<QuizChoiceWhereUniqueInput>
    delete?: Enumerable<QuizChoiceWhereUniqueInput>
    connect?: Enumerable<QuizChoiceWhereUniqueInput>
    update?: Enumerable<QuizChoiceUpdateWithWhereUniqueWithoutQuestionInput>
    updateMany?: Enumerable<QuizChoiceUpdateManyWithWhereWithoutQuestionInput>
    deleteMany?: Enumerable<QuizChoiceScalarWhereInput>
  }

  export type QuizRecordUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<Enumerable<QuizRecordCreateWithoutQuestionInput>, Enumerable<QuizRecordUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<QuizRecordCreateOrConnectWithoutQuestionInput>
    upsert?: Enumerable<QuizRecordUpsertWithWhereUniqueWithoutQuestionInput>
    createMany?: QuizRecordCreateManyQuestionInputEnvelope
    set?: Enumerable<QuizRecordWhereUniqueInput>
    disconnect?: Enumerable<QuizRecordWhereUniqueInput>
    delete?: Enumerable<QuizRecordWhereUniqueInput>
    connect?: Enumerable<QuizRecordWhereUniqueInput>
    update?: Enumerable<QuizRecordUpdateWithWhereUniqueWithoutQuestionInput>
    updateMany?: Enumerable<QuizRecordUpdateManyWithWhereWithoutQuestionInput>
    deleteMany?: Enumerable<QuizRecordScalarWhereInput>
  }

  export type QuizQuestionCreateNestedOneWithoutQuizChoicesInput = {
    create?: XOR<QuizQuestionCreateWithoutQuizChoicesInput, QuizQuestionUncheckedCreateWithoutQuizChoicesInput>
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutQuizChoicesInput
    connect?: QuizQuestionWhereUniqueInput
  }

  export type QuizRecordCreateNestedManyWithoutPlayerChoiceInput = {
    create?: XOR<Enumerable<QuizRecordCreateWithoutPlayerChoiceInput>, Enumerable<QuizRecordUncheckedCreateWithoutPlayerChoiceInput>>
    connectOrCreate?: Enumerable<QuizRecordCreateOrConnectWithoutPlayerChoiceInput>
    createMany?: QuizRecordCreateManyPlayerChoiceInputEnvelope
    connect?: Enumerable<QuizRecordWhereUniqueInput>
  }

  export type QuizRecordUncheckedCreateNestedManyWithoutPlayerChoiceInput = {
    create?: XOR<Enumerable<QuizRecordCreateWithoutPlayerChoiceInput>, Enumerable<QuizRecordUncheckedCreateWithoutPlayerChoiceInput>>
    connectOrCreate?: Enumerable<QuizRecordCreateOrConnectWithoutPlayerChoiceInput>
    createMany?: QuizRecordCreateManyPlayerChoiceInputEnvelope
    connect?: Enumerable<QuizRecordWhereUniqueInput>
  }

  export type QuizQuestionUpdateOneWithoutQuizChoicesNestedInput = {
    create?: XOR<QuizQuestionCreateWithoutQuizChoicesInput, QuizQuestionUncheckedCreateWithoutQuizChoicesInput>
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutQuizChoicesInput
    upsert?: QuizQuestionUpsertWithoutQuizChoicesInput
    disconnect?: boolean
    delete?: boolean
    connect?: QuizQuestionWhereUniqueInput
    update?: XOR<QuizQuestionUpdateWithoutQuizChoicesInput, QuizQuestionUncheckedUpdateWithoutQuizChoicesInput>
  }

  export type QuizRecordUpdateManyWithoutPlayerChoiceNestedInput = {
    create?: XOR<Enumerable<QuizRecordCreateWithoutPlayerChoiceInput>, Enumerable<QuizRecordUncheckedCreateWithoutPlayerChoiceInput>>
    connectOrCreate?: Enumerable<QuizRecordCreateOrConnectWithoutPlayerChoiceInput>
    upsert?: Enumerable<QuizRecordUpsertWithWhereUniqueWithoutPlayerChoiceInput>
    createMany?: QuizRecordCreateManyPlayerChoiceInputEnvelope
    set?: Enumerable<QuizRecordWhereUniqueInput>
    disconnect?: Enumerable<QuizRecordWhereUniqueInput>
    delete?: Enumerable<QuizRecordWhereUniqueInput>
    connect?: Enumerable<QuizRecordWhereUniqueInput>
    update?: Enumerable<QuizRecordUpdateWithWhereUniqueWithoutPlayerChoiceInput>
    updateMany?: Enumerable<QuizRecordUpdateManyWithWhereWithoutPlayerChoiceInput>
    deleteMany?: Enumerable<QuizRecordScalarWhereInput>
  }

  export type QuizRecordUncheckedUpdateManyWithoutPlayerChoiceNestedInput = {
    create?: XOR<Enumerable<QuizRecordCreateWithoutPlayerChoiceInput>, Enumerable<QuizRecordUncheckedCreateWithoutPlayerChoiceInput>>
    connectOrCreate?: Enumerable<QuizRecordCreateOrConnectWithoutPlayerChoiceInput>
    upsert?: Enumerable<QuizRecordUpsertWithWhereUniqueWithoutPlayerChoiceInput>
    createMany?: QuizRecordCreateManyPlayerChoiceInputEnvelope
    set?: Enumerable<QuizRecordWhereUniqueInput>
    disconnect?: Enumerable<QuizRecordWhereUniqueInput>
    delete?: Enumerable<QuizRecordWhereUniqueInput>
    connect?: Enumerable<QuizRecordWhereUniqueInput>
    update?: Enumerable<QuizRecordUpdateWithWhereUniqueWithoutPlayerChoiceInput>
    updateMany?: Enumerable<QuizRecordUpdateManyWithWhereWithoutPlayerChoiceInput>
    deleteMany?: Enumerable<QuizRecordScalarWhereInput>
  }

  export type QuizCategoryCreateNestedOneWithoutQuizRoundInput = {
    create?: XOR<QuizCategoryCreateWithoutQuizRoundInput, QuizCategoryUncheckedCreateWithoutQuizRoundInput>
    connectOrCreate?: QuizCategoryCreateOrConnectWithoutQuizRoundInput
    connect?: QuizCategoryWhereUniqueInput
  }

  export type QuizRecordCreateNestedManyWithoutRoundInput = {
    create?: XOR<Enumerable<QuizRecordCreateWithoutRoundInput>, Enumerable<QuizRecordUncheckedCreateWithoutRoundInput>>
    connectOrCreate?: Enumerable<QuizRecordCreateOrConnectWithoutRoundInput>
    createMany?: QuizRecordCreateManyRoundInputEnvelope
    connect?: Enumerable<QuizRecordWhereUniqueInput>
  }

  export type QuizRecordUncheckedCreateNestedManyWithoutRoundInput = {
    create?: XOR<Enumerable<QuizRecordCreateWithoutRoundInput>, Enumerable<QuizRecordUncheckedCreateWithoutRoundInput>>
    connectOrCreate?: Enumerable<QuizRecordCreateOrConnectWithoutRoundInput>
    createMany?: QuizRecordCreateManyRoundInputEnvelope
    connect?: Enumerable<QuizRecordWhereUniqueInput>
  }

  export type QuizCategoryUpdateOneWithoutQuizRoundNestedInput = {
    create?: XOR<QuizCategoryCreateWithoutQuizRoundInput, QuizCategoryUncheckedCreateWithoutQuizRoundInput>
    connectOrCreate?: QuizCategoryCreateOrConnectWithoutQuizRoundInput
    upsert?: QuizCategoryUpsertWithoutQuizRoundInput
    disconnect?: boolean
    delete?: boolean
    connect?: QuizCategoryWhereUniqueInput
    update?: XOR<QuizCategoryUpdateWithoutQuizRoundInput, QuizCategoryUncheckedUpdateWithoutQuizRoundInput>
  }

  export type QuizRecordUpdateManyWithoutRoundNestedInput = {
    create?: XOR<Enumerable<QuizRecordCreateWithoutRoundInput>, Enumerable<QuizRecordUncheckedCreateWithoutRoundInput>>
    connectOrCreate?: Enumerable<QuizRecordCreateOrConnectWithoutRoundInput>
    upsert?: Enumerable<QuizRecordUpsertWithWhereUniqueWithoutRoundInput>
    createMany?: QuizRecordCreateManyRoundInputEnvelope
    set?: Enumerable<QuizRecordWhereUniqueInput>
    disconnect?: Enumerable<QuizRecordWhereUniqueInput>
    delete?: Enumerable<QuizRecordWhereUniqueInput>
    connect?: Enumerable<QuizRecordWhereUniqueInput>
    update?: Enumerable<QuizRecordUpdateWithWhereUniqueWithoutRoundInput>
    updateMany?: Enumerable<QuizRecordUpdateManyWithWhereWithoutRoundInput>
    deleteMany?: Enumerable<QuizRecordScalarWhereInput>
  }

  export type QuizRecordUncheckedUpdateManyWithoutRoundNestedInput = {
    create?: XOR<Enumerable<QuizRecordCreateWithoutRoundInput>, Enumerable<QuizRecordUncheckedCreateWithoutRoundInput>>
    connectOrCreate?: Enumerable<QuizRecordCreateOrConnectWithoutRoundInput>
    upsert?: Enumerable<QuizRecordUpsertWithWhereUniqueWithoutRoundInput>
    createMany?: QuizRecordCreateManyRoundInputEnvelope
    set?: Enumerable<QuizRecordWhereUniqueInput>
    disconnect?: Enumerable<QuizRecordWhereUniqueInput>
    delete?: Enumerable<QuizRecordWhereUniqueInput>
    connect?: Enumerable<QuizRecordWhereUniqueInput>
    update?: Enumerable<QuizRecordUpdateWithWhereUniqueWithoutRoundInput>
    updateMany?: Enumerable<QuizRecordUpdateManyWithWhereWithoutRoundInput>
    deleteMany?: Enumerable<QuizRecordScalarWhereInput>
  }

  export type QuizRoundCreateNestedOneWithoutQuizRecordsInput = {
    create?: XOR<QuizRoundCreateWithoutQuizRecordsInput, QuizRoundUncheckedCreateWithoutQuizRecordsInput>
    connectOrCreate?: QuizRoundCreateOrConnectWithoutQuizRecordsInput
    connect?: QuizRoundWhereUniqueInput
  }

  export type QuizChoiceCreateNestedOneWithoutQuizRecordsInput = {
    create?: XOR<QuizChoiceCreateWithoutQuizRecordsInput, QuizChoiceUncheckedCreateWithoutQuizRecordsInput>
    connectOrCreate?: QuizChoiceCreateOrConnectWithoutQuizRecordsInput
    connect?: QuizChoiceWhereUniqueInput
  }

  export type QuizQuestionCreateNestedOneWithoutQuizRecordsInput = {
    create?: XOR<QuizQuestionCreateWithoutQuizRecordsInput, QuizQuestionUncheckedCreateWithoutQuizRecordsInput>
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutQuizRecordsInput
    connect?: QuizQuestionWhereUniqueInput
  }

  export type QuizRoundUpdateOneWithoutQuizRecordsNestedInput = {
    create?: XOR<QuizRoundCreateWithoutQuizRecordsInput, QuizRoundUncheckedCreateWithoutQuizRecordsInput>
    connectOrCreate?: QuizRoundCreateOrConnectWithoutQuizRecordsInput
    upsert?: QuizRoundUpsertWithoutQuizRecordsInput
    disconnect?: boolean
    delete?: boolean
    connect?: QuizRoundWhereUniqueInput
    update?: XOR<QuizRoundUpdateWithoutQuizRecordsInput, QuizRoundUncheckedUpdateWithoutQuizRecordsInput>
  }

  export type QuizChoiceUpdateOneWithoutQuizRecordsNestedInput = {
    create?: XOR<QuizChoiceCreateWithoutQuizRecordsInput, QuizChoiceUncheckedCreateWithoutQuizRecordsInput>
    connectOrCreate?: QuizChoiceCreateOrConnectWithoutQuizRecordsInput
    upsert?: QuizChoiceUpsertWithoutQuizRecordsInput
    disconnect?: boolean
    delete?: boolean
    connect?: QuizChoiceWhereUniqueInput
    update?: XOR<QuizChoiceUpdateWithoutQuizRecordsInput, QuizChoiceUncheckedUpdateWithoutQuizRecordsInput>
  }

  export type QuizQuestionUpdateOneWithoutQuizRecordsNestedInput = {
    create?: XOR<QuizQuestionCreateWithoutQuizRecordsInput, QuizQuestionUncheckedCreateWithoutQuizRecordsInput>
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutQuizRecordsInput
    upsert?: QuizQuestionUpsertWithoutQuizRecordsInput
    disconnect?: boolean
    delete?: boolean
    connect?: QuizQuestionWhereUniqueInput
    update?: XOR<QuizQuestionUpdateWithoutQuizRecordsInput, QuizQuestionUncheckedUpdateWithoutQuizRecordsInput>
  }

  export type TwitterPostCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TwitterPostCreateWithoutUserInput>, Enumerable<TwitterPostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TwitterPostCreateOrConnectWithoutUserInput>
    createMany?: TwitterPostCreateManyUserInputEnvelope
    connect?: Enumerable<TwitterPostWhereUniqueInput>
  }

  export type TwitterDirectMessageCreateNestedManyWithoutFromInput = {
    create?: XOR<Enumerable<TwitterDirectMessageCreateWithoutFromInput>, Enumerable<TwitterDirectMessageUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<TwitterDirectMessageCreateOrConnectWithoutFromInput>
    createMany?: TwitterDirectMessageCreateManyFromInputEnvelope
    connect?: Enumerable<TwitterDirectMessageWhereUniqueInput>
  }

  export type TwitterCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TwitterCommentCreateWithoutUserInput>, Enumerable<TwitterCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TwitterCommentCreateOrConnectWithoutUserInput>
    createMany?: TwitterCommentCreateManyUserInputEnvelope
    connect?: Enumerable<TwitterCommentWhereUniqueInput>
  }

  export type TwitterDirectMessageCreateNestedManyWithoutToInput = {
    create?: XOR<Enumerable<TwitterDirectMessageCreateWithoutToInput>, Enumerable<TwitterDirectMessageUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<TwitterDirectMessageCreateOrConnectWithoutToInput>
    createMany?: TwitterDirectMessageCreateManyToInputEnvelope
    connect?: Enumerable<TwitterDirectMessageWhereUniqueInput>
  }

  export type TwitterUserRelationCreateNestedManyWithoutFromInput = {
    create?: XOR<Enumerable<TwitterUserRelationCreateWithoutFromInput>, Enumerable<TwitterUserRelationUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<TwitterUserRelationCreateOrConnectWithoutFromInput>
    createMany?: TwitterUserRelationCreateManyFromInputEnvelope
    connect?: Enumerable<TwitterUserRelationWhereUniqueInput>
  }

  export type TwitterUserRelationCreateNestedManyWithoutToInput = {
    create?: XOR<Enumerable<TwitterUserRelationCreateWithoutToInput>, Enumerable<TwitterUserRelationUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<TwitterUserRelationCreateOrConnectWithoutToInput>
    createMany?: TwitterUserRelationCreateManyToInputEnvelope
    connect?: Enumerable<TwitterUserRelationWhereUniqueInput>
  }

  export type TwitterPostUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TwitterPostCreateWithoutUserInput>, Enumerable<TwitterPostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TwitterPostCreateOrConnectWithoutUserInput>
    createMany?: TwitterPostCreateManyUserInputEnvelope
    connect?: Enumerable<TwitterPostWhereUniqueInput>
  }

  export type TwitterDirectMessageUncheckedCreateNestedManyWithoutFromInput = {
    create?: XOR<Enumerable<TwitterDirectMessageCreateWithoutFromInput>, Enumerable<TwitterDirectMessageUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<TwitterDirectMessageCreateOrConnectWithoutFromInput>
    createMany?: TwitterDirectMessageCreateManyFromInputEnvelope
    connect?: Enumerable<TwitterDirectMessageWhereUniqueInput>
  }

  export type TwitterCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TwitterCommentCreateWithoutUserInput>, Enumerable<TwitterCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TwitterCommentCreateOrConnectWithoutUserInput>
    createMany?: TwitterCommentCreateManyUserInputEnvelope
    connect?: Enumerable<TwitterCommentWhereUniqueInput>
  }

  export type TwitterDirectMessageUncheckedCreateNestedManyWithoutToInput = {
    create?: XOR<Enumerable<TwitterDirectMessageCreateWithoutToInput>, Enumerable<TwitterDirectMessageUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<TwitterDirectMessageCreateOrConnectWithoutToInput>
    createMany?: TwitterDirectMessageCreateManyToInputEnvelope
    connect?: Enumerable<TwitterDirectMessageWhereUniqueInput>
  }

  export type TwitterUserRelationUncheckedCreateNestedManyWithoutFromInput = {
    create?: XOR<Enumerable<TwitterUserRelationCreateWithoutFromInput>, Enumerable<TwitterUserRelationUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<TwitterUserRelationCreateOrConnectWithoutFromInput>
    createMany?: TwitterUserRelationCreateManyFromInputEnvelope
    connect?: Enumerable<TwitterUserRelationWhereUniqueInput>
  }

  export type TwitterUserRelationUncheckedCreateNestedManyWithoutToInput = {
    create?: XOR<Enumerable<TwitterUserRelationCreateWithoutToInput>, Enumerable<TwitterUserRelationUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<TwitterUserRelationCreateOrConnectWithoutToInput>
    createMany?: TwitterUserRelationCreateManyToInputEnvelope
    connect?: Enumerable<TwitterUserRelationWhereUniqueInput>
  }

  export type TwitterPostUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<TwitterPostCreateWithoutUserInput>, Enumerable<TwitterPostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TwitterPostCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TwitterPostUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TwitterPostCreateManyUserInputEnvelope
    set?: Enumerable<TwitterPostWhereUniqueInput>
    disconnect?: Enumerable<TwitterPostWhereUniqueInput>
    delete?: Enumerable<TwitterPostWhereUniqueInput>
    connect?: Enumerable<TwitterPostWhereUniqueInput>
    update?: Enumerable<TwitterPostUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TwitterPostUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TwitterPostScalarWhereInput>
  }

  export type TwitterDirectMessageUpdateManyWithoutFromNestedInput = {
    create?: XOR<Enumerable<TwitterDirectMessageCreateWithoutFromInput>, Enumerable<TwitterDirectMessageUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<TwitterDirectMessageCreateOrConnectWithoutFromInput>
    upsert?: Enumerable<TwitterDirectMessageUpsertWithWhereUniqueWithoutFromInput>
    createMany?: TwitterDirectMessageCreateManyFromInputEnvelope
    set?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    disconnect?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    delete?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    connect?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    update?: Enumerable<TwitterDirectMessageUpdateWithWhereUniqueWithoutFromInput>
    updateMany?: Enumerable<TwitterDirectMessageUpdateManyWithWhereWithoutFromInput>
    deleteMany?: Enumerable<TwitterDirectMessageScalarWhereInput>
  }

  export type TwitterCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<TwitterCommentCreateWithoutUserInput>, Enumerable<TwitterCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TwitterCommentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TwitterCommentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TwitterCommentCreateManyUserInputEnvelope
    set?: Enumerable<TwitterCommentWhereUniqueInput>
    disconnect?: Enumerable<TwitterCommentWhereUniqueInput>
    delete?: Enumerable<TwitterCommentWhereUniqueInput>
    connect?: Enumerable<TwitterCommentWhereUniqueInput>
    update?: Enumerable<TwitterCommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TwitterCommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TwitterCommentScalarWhereInput>
  }

  export type TwitterDirectMessageUpdateManyWithoutToNestedInput = {
    create?: XOR<Enumerable<TwitterDirectMessageCreateWithoutToInput>, Enumerable<TwitterDirectMessageUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<TwitterDirectMessageCreateOrConnectWithoutToInput>
    upsert?: Enumerable<TwitterDirectMessageUpsertWithWhereUniqueWithoutToInput>
    createMany?: TwitterDirectMessageCreateManyToInputEnvelope
    set?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    disconnect?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    delete?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    connect?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    update?: Enumerable<TwitterDirectMessageUpdateWithWhereUniqueWithoutToInput>
    updateMany?: Enumerable<TwitterDirectMessageUpdateManyWithWhereWithoutToInput>
    deleteMany?: Enumerable<TwitterDirectMessageScalarWhereInput>
  }

  export type TwitterUserRelationUpdateManyWithoutFromNestedInput = {
    create?: XOR<Enumerable<TwitterUserRelationCreateWithoutFromInput>, Enumerable<TwitterUserRelationUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<TwitterUserRelationCreateOrConnectWithoutFromInput>
    upsert?: Enumerable<TwitterUserRelationUpsertWithWhereUniqueWithoutFromInput>
    createMany?: TwitterUserRelationCreateManyFromInputEnvelope
    set?: Enumerable<TwitterUserRelationWhereUniqueInput>
    disconnect?: Enumerable<TwitterUserRelationWhereUniqueInput>
    delete?: Enumerable<TwitterUserRelationWhereUniqueInput>
    connect?: Enumerable<TwitterUserRelationWhereUniqueInput>
    update?: Enumerable<TwitterUserRelationUpdateWithWhereUniqueWithoutFromInput>
    updateMany?: Enumerable<TwitterUserRelationUpdateManyWithWhereWithoutFromInput>
    deleteMany?: Enumerable<TwitterUserRelationScalarWhereInput>
  }

  export type TwitterUserRelationUpdateManyWithoutToNestedInput = {
    create?: XOR<Enumerable<TwitterUserRelationCreateWithoutToInput>, Enumerable<TwitterUserRelationUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<TwitterUserRelationCreateOrConnectWithoutToInput>
    upsert?: Enumerable<TwitterUserRelationUpsertWithWhereUniqueWithoutToInput>
    createMany?: TwitterUserRelationCreateManyToInputEnvelope
    set?: Enumerable<TwitterUserRelationWhereUniqueInput>
    disconnect?: Enumerable<TwitterUserRelationWhereUniqueInput>
    delete?: Enumerable<TwitterUserRelationWhereUniqueInput>
    connect?: Enumerable<TwitterUserRelationWhereUniqueInput>
    update?: Enumerable<TwitterUserRelationUpdateWithWhereUniqueWithoutToInput>
    updateMany?: Enumerable<TwitterUserRelationUpdateManyWithWhereWithoutToInput>
    deleteMany?: Enumerable<TwitterUserRelationScalarWhereInput>
  }

  export type TwitterPostUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<TwitterPostCreateWithoutUserInput>, Enumerable<TwitterPostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TwitterPostCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TwitterPostUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TwitterPostCreateManyUserInputEnvelope
    set?: Enumerable<TwitterPostWhereUniqueInput>
    disconnect?: Enumerable<TwitterPostWhereUniqueInput>
    delete?: Enumerable<TwitterPostWhereUniqueInput>
    connect?: Enumerable<TwitterPostWhereUniqueInput>
    update?: Enumerable<TwitterPostUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TwitterPostUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TwitterPostScalarWhereInput>
  }

  export type TwitterDirectMessageUncheckedUpdateManyWithoutFromNestedInput = {
    create?: XOR<Enumerable<TwitterDirectMessageCreateWithoutFromInput>, Enumerable<TwitterDirectMessageUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<TwitterDirectMessageCreateOrConnectWithoutFromInput>
    upsert?: Enumerable<TwitterDirectMessageUpsertWithWhereUniqueWithoutFromInput>
    createMany?: TwitterDirectMessageCreateManyFromInputEnvelope
    set?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    disconnect?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    delete?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    connect?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    update?: Enumerable<TwitterDirectMessageUpdateWithWhereUniqueWithoutFromInput>
    updateMany?: Enumerable<TwitterDirectMessageUpdateManyWithWhereWithoutFromInput>
    deleteMany?: Enumerable<TwitterDirectMessageScalarWhereInput>
  }

  export type TwitterCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<TwitterCommentCreateWithoutUserInput>, Enumerable<TwitterCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TwitterCommentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TwitterCommentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TwitterCommentCreateManyUserInputEnvelope
    set?: Enumerable<TwitterCommentWhereUniqueInput>
    disconnect?: Enumerable<TwitterCommentWhereUniqueInput>
    delete?: Enumerable<TwitterCommentWhereUniqueInput>
    connect?: Enumerable<TwitterCommentWhereUniqueInput>
    update?: Enumerable<TwitterCommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TwitterCommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TwitterCommentScalarWhereInput>
  }

  export type TwitterDirectMessageUncheckedUpdateManyWithoutToNestedInput = {
    create?: XOR<Enumerable<TwitterDirectMessageCreateWithoutToInput>, Enumerable<TwitterDirectMessageUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<TwitterDirectMessageCreateOrConnectWithoutToInput>
    upsert?: Enumerable<TwitterDirectMessageUpsertWithWhereUniqueWithoutToInput>
    createMany?: TwitterDirectMessageCreateManyToInputEnvelope
    set?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    disconnect?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    delete?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    connect?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    update?: Enumerable<TwitterDirectMessageUpdateWithWhereUniqueWithoutToInput>
    updateMany?: Enumerable<TwitterDirectMessageUpdateManyWithWhereWithoutToInput>
    deleteMany?: Enumerable<TwitterDirectMessageScalarWhereInput>
  }

  export type TwitterUserRelationUncheckedUpdateManyWithoutFromNestedInput = {
    create?: XOR<Enumerable<TwitterUserRelationCreateWithoutFromInput>, Enumerable<TwitterUserRelationUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<TwitterUserRelationCreateOrConnectWithoutFromInput>
    upsert?: Enumerable<TwitterUserRelationUpsertWithWhereUniqueWithoutFromInput>
    createMany?: TwitterUserRelationCreateManyFromInputEnvelope
    set?: Enumerable<TwitterUserRelationWhereUniqueInput>
    disconnect?: Enumerable<TwitterUserRelationWhereUniqueInput>
    delete?: Enumerable<TwitterUserRelationWhereUniqueInput>
    connect?: Enumerable<TwitterUserRelationWhereUniqueInput>
    update?: Enumerable<TwitterUserRelationUpdateWithWhereUniqueWithoutFromInput>
    updateMany?: Enumerable<TwitterUserRelationUpdateManyWithWhereWithoutFromInput>
    deleteMany?: Enumerable<TwitterUserRelationScalarWhereInput>
  }

  export type TwitterUserRelationUncheckedUpdateManyWithoutToNestedInput = {
    create?: XOR<Enumerable<TwitterUserRelationCreateWithoutToInput>, Enumerable<TwitterUserRelationUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<TwitterUserRelationCreateOrConnectWithoutToInput>
    upsert?: Enumerable<TwitterUserRelationUpsertWithWhereUniqueWithoutToInput>
    createMany?: TwitterUserRelationCreateManyToInputEnvelope
    set?: Enumerable<TwitterUserRelationWhereUniqueInput>
    disconnect?: Enumerable<TwitterUserRelationWhereUniqueInput>
    delete?: Enumerable<TwitterUserRelationWhereUniqueInput>
    connect?: Enumerable<TwitterUserRelationWhereUniqueInput>
    update?: Enumerable<TwitterUserRelationUpdateWithWhereUniqueWithoutToInput>
    updateMany?: Enumerable<TwitterUserRelationUpdateManyWithWhereWithoutToInput>
    deleteMany?: Enumerable<TwitterUserRelationScalarWhereInput>
  }

  export type TwitterUserCreateNestedOneWithoutPostsInput = {
    create?: XOR<TwitterUserCreateWithoutPostsInput, TwitterUserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: TwitterUserCreateOrConnectWithoutPostsInput
    connect?: TwitterUserWhereUniqueInput
  }

  export type TwitterPostToHashtagCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<TwitterPostToHashtagCreateWithoutPostInput>, Enumerable<TwitterPostToHashtagUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<TwitterPostToHashtagCreateOrConnectWithoutPostInput>
    createMany?: TwitterPostToHashtagCreateManyPostInputEnvelope
    connect?: Enumerable<TwitterPostToHashtagWhereUniqueInput>
  }

  export type TwitterCommentCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<TwitterCommentCreateWithoutPostInput>, Enumerable<TwitterCommentUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<TwitterCommentCreateOrConnectWithoutPostInput>
    createMany?: TwitterCommentCreateManyPostInputEnvelope
    connect?: Enumerable<TwitterCommentWhereUniqueInput>
  }

  export type TwitterPostToHashtagUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<TwitterPostToHashtagCreateWithoutPostInput>, Enumerable<TwitterPostToHashtagUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<TwitterPostToHashtagCreateOrConnectWithoutPostInput>
    createMany?: TwitterPostToHashtagCreateManyPostInputEnvelope
    connect?: Enumerable<TwitterPostToHashtagWhereUniqueInput>
  }

  export type TwitterCommentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<TwitterCommentCreateWithoutPostInput>, Enumerable<TwitterCommentUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<TwitterCommentCreateOrConnectWithoutPostInput>
    createMany?: TwitterCommentCreateManyPostInputEnvelope
    connect?: Enumerable<TwitterCommentWhereUniqueInput>
  }

  export type TwitterUserUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<TwitterUserCreateWithoutPostsInput, TwitterUserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: TwitterUserCreateOrConnectWithoutPostsInput
    upsert?: TwitterUserUpsertWithoutPostsInput
    connect?: TwitterUserWhereUniqueInput
    update?: XOR<TwitterUserUpdateWithoutPostsInput, TwitterUserUncheckedUpdateWithoutPostsInput>
  }

  export type TwitterPostToHashtagUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<TwitterPostToHashtagCreateWithoutPostInput>, Enumerable<TwitterPostToHashtagUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<TwitterPostToHashtagCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<TwitterPostToHashtagUpsertWithWhereUniqueWithoutPostInput>
    createMany?: TwitterPostToHashtagCreateManyPostInputEnvelope
    set?: Enumerable<TwitterPostToHashtagWhereUniqueInput>
    disconnect?: Enumerable<TwitterPostToHashtagWhereUniqueInput>
    delete?: Enumerable<TwitterPostToHashtagWhereUniqueInput>
    connect?: Enumerable<TwitterPostToHashtagWhereUniqueInput>
    update?: Enumerable<TwitterPostToHashtagUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<TwitterPostToHashtagUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<TwitterPostToHashtagScalarWhereInput>
  }

  export type TwitterCommentUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<TwitterCommentCreateWithoutPostInput>, Enumerable<TwitterCommentUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<TwitterCommentCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<TwitterCommentUpsertWithWhereUniqueWithoutPostInput>
    createMany?: TwitterCommentCreateManyPostInputEnvelope
    set?: Enumerable<TwitterCommentWhereUniqueInput>
    disconnect?: Enumerable<TwitterCommentWhereUniqueInput>
    delete?: Enumerable<TwitterCommentWhereUniqueInput>
    connect?: Enumerable<TwitterCommentWhereUniqueInput>
    update?: Enumerable<TwitterCommentUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<TwitterCommentUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<TwitterCommentScalarWhereInput>
  }

  export type TwitterPostToHashtagUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<TwitterPostToHashtagCreateWithoutPostInput>, Enumerable<TwitterPostToHashtagUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<TwitterPostToHashtagCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<TwitterPostToHashtagUpsertWithWhereUniqueWithoutPostInput>
    createMany?: TwitterPostToHashtagCreateManyPostInputEnvelope
    set?: Enumerable<TwitterPostToHashtagWhereUniqueInput>
    disconnect?: Enumerable<TwitterPostToHashtagWhereUniqueInput>
    delete?: Enumerable<TwitterPostToHashtagWhereUniqueInput>
    connect?: Enumerable<TwitterPostToHashtagWhereUniqueInput>
    update?: Enumerable<TwitterPostToHashtagUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<TwitterPostToHashtagUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<TwitterPostToHashtagScalarWhereInput>
  }

  export type TwitterCommentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<TwitterCommentCreateWithoutPostInput>, Enumerable<TwitterCommentUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<TwitterCommentCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<TwitterCommentUpsertWithWhereUniqueWithoutPostInput>
    createMany?: TwitterCommentCreateManyPostInputEnvelope
    set?: Enumerable<TwitterCommentWhereUniqueInput>
    disconnect?: Enumerable<TwitterCommentWhereUniqueInput>
    delete?: Enumerable<TwitterCommentWhereUniqueInput>
    connect?: Enumerable<TwitterCommentWhereUniqueInput>
    update?: Enumerable<TwitterCommentUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<TwitterCommentUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<TwitterCommentScalarWhereInput>
  }

  export type TwitterPostToHashtagCreateNestedManyWithoutHashtagInput = {
    create?: XOR<Enumerable<TwitterPostToHashtagCreateWithoutHashtagInput>, Enumerable<TwitterPostToHashtagUncheckedCreateWithoutHashtagInput>>
    connectOrCreate?: Enumerable<TwitterPostToHashtagCreateOrConnectWithoutHashtagInput>
    createMany?: TwitterPostToHashtagCreateManyHashtagInputEnvelope
    connect?: Enumerable<TwitterPostToHashtagWhereUniqueInput>
  }

  export type TwitterPostToHashtagUncheckedCreateNestedManyWithoutHashtagInput = {
    create?: XOR<Enumerable<TwitterPostToHashtagCreateWithoutHashtagInput>, Enumerable<TwitterPostToHashtagUncheckedCreateWithoutHashtagInput>>
    connectOrCreate?: Enumerable<TwitterPostToHashtagCreateOrConnectWithoutHashtagInput>
    createMany?: TwitterPostToHashtagCreateManyHashtagInputEnvelope
    connect?: Enumerable<TwitterPostToHashtagWhereUniqueInput>
  }

  export type TwitterPostToHashtagUpdateManyWithoutHashtagNestedInput = {
    create?: XOR<Enumerable<TwitterPostToHashtagCreateWithoutHashtagInput>, Enumerable<TwitterPostToHashtagUncheckedCreateWithoutHashtagInput>>
    connectOrCreate?: Enumerable<TwitterPostToHashtagCreateOrConnectWithoutHashtagInput>
    upsert?: Enumerable<TwitterPostToHashtagUpsertWithWhereUniqueWithoutHashtagInput>
    createMany?: TwitterPostToHashtagCreateManyHashtagInputEnvelope
    set?: Enumerable<TwitterPostToHashtagWhereUniqueInput>
    disconnect?: Enumerable<TwitterPostToHashtagWhereUniqueInput>
    delete?: Enumerable<TwitterPostToHashtagWhereUniqueInput>
    connect?: Enumerable<TwitterPostToHashtagWhereUniqueInput>
    update?: Enumerable<TwitterPostToHashtagUpdateWithWhereUniqueWithoutHashtagInput>
    updateMany?: Enumerable<TwitterPostToHashtagUpdateManyWithWhereWithoutHashtagInput>
    deleteMany?: Enumerable<TwitterPostToHashtagScalarWhereInput>
  }

  export type TwitterPostToHashtagUncheckedUpdateManyWithoutHashtagNestedInput = {
    create?: XOR<Enumerable<TwitterPostToHashtagCreateWithoutHashtagInput>, Enumerable<TwitterPostToHashtagUncheckedCreateWithoutHashtagInput>>
    connectOrCreate?: Enumerable<TwitterPostToHashtagCreateOrConnectWithoutHashtagInput>
    upsert?: Enumerable<TwitterPostToHashtagUpsertWithWhereUniqueWithoutHashtagInput>
    createMany?: TwitterPostToHashtagCreateManyHashtagInputEnvelope
    set?: Enumerable<TwitterPostToHashtagWhereUniqueInput>
    disconnect?: Enumerable<TwitterPostToHashtagWhereUniqueInput>
    delete?: Enumerable<TwitterPostToHashtagWhereUniqueInput>
    connect?: Enumerable<TwitterPostToHashtagWhereUniqueInput>
    update?: Enumerable<TwitterPostToHashtagUpdateWithWhereUniqueWithoutHashtagInput>
    updateMany?: Enumerable<TwitterPostToHashtagUpdateManyWithWhereWithoutHashtagInput>
    deleteMany?: Enumerable<TwitterPostToHashtagScalarWhereInput>
  }

  export type TwitterPostCreateNestedOneWithoutPostToHashtagsInput = {
    create?: XOR<TwitterPostCreateWithoutPostToHashtagsInput, TwitterPostUncheckedCreateWithoutPostToHashtagsInput>
    connectOrCreate?: TwitterPostCreateOrConnectWithoutPostToHashtagsInput
    connect?: TwitterPostWhereUniqueInput
  }

  export type TwitterHashtagCreateNestedOneWithoutPostsToHashtagsInput = {
    create?: XOR<TwitterHashtagCreateWithoutPostsToHashtagsInput, TwitterHashtagUncheckedCreateWithoutPostsToHashtagsInput>
    connectOrCreate?: TwitterHashtagCreateOrConnectWithoutPostsToHashtagsInput
    connect?: TwitterHashtagWhereUniqueInput
  }

  export type TwitterPostUpdateOneRequiredWithoutPostToHashtagsNestedInput = {
    create?: XOR<TwitterPostCreateWithoutPostToHashtagsInput, TwitterPostUncheckedCreateWithoutPostToHashtagsInput>
    connectOrCreate?: TwitterPostCreateOrConnectWithoutPostToHashtagsInput
    upsert?: TwitterPostUpsertWithoutPostToHashtagsInput
    connect?: TwitterPostWhereUniqueInput
    update?: XOR<TwitterPostUpdateWithoutPostToHashtagsInput, TwitterPostUncheckedUpdateWithoutPostToHashtagsInput>
  }

  export type TwitterHashtagUpdateOneRequiredWithoutPostsToHashtagsNestedInput = {
    create?: XOR<TwitterHashtagCreateWithoutPostsToHashtagsInput, TwitterHashtagUncheckedCreateWithoutPostsToHashtagsInput>
    connectOrCreate?: TwitterHashtagCreateOrConnectWithoutPostsToHashtagsInput
    upsert?: TwitterHashtagUpsertWithoutPostsToHashtagsInput
    connect?: TwitterHashtagWhereUniqueInput
    update?: XOR<TwitterHashtagUpdateWithoutPostsToHashtagsInput, TwitterHashtagUncheckedUpdateWithoutPostsToHashtagsInput>
  }

  export type TwitterUserCreateNestedOneWithoutFromDirectMessagesInput = {
    create?: XOR<TwitterUserCreateWithoutFromDirectMessagesInput, TwitterUserUncheckedCreateWithoutFromDirectMessagesInput>
    connectOrCreate?: TwitterUserCreateOrConnectWithoutFromDirectMessagesInput
    connect?: TwitterUserWhereUniqueInput
  }

  export type TwitterUserCreateNestedOneWithoutToDirectMessagesInput = {
    create?: XOR<TwitterUserCreateWithoutToDirectMessagesInput, TwitterUserUncheckedCreateWithoutToDirectMessagesInput>
    connectOrCreate?: TwitterUserCreateOrConnectWithoutToDirectMessagesInput
    connect?: TwitterUserWhereUniqueInput
  }

  export type TwitterUserUpdateOneRequiredWithoutFromDirectMessagesNestedInput = {
    create?: XOR<TwitterUserCreateWithoutFromDirectMessagesInput, TwitterUserUncheckedCreateWithoutFromDirectMessagesInput>
    connectOrCreate?: TwitterUserCreateOrConnectWithoutFromDirectMessagesInput
    upsert?: TwitterUserUpsertWithoutFromDirectMessagesInput
    connect?: TwitterUserWhereUniqueInput
    update?: XOR<TwitterUserUpdateWithoutFromDirectMessagesInput, TwitterUserUncheckedUpdateWithoutFromDirectMessagesInput>
  }

  export type TwitterUserUpdateOneRequiredWithoutToDirectMessagesNestedInput = {
    create?: XOR<TwitterUserCreateWithoutToDirectMessagesInput, TwitterUserUncheckedCreateWithoutToDirectMessagesInput>
    connectOrCreate?: TwitterUserCreateOrConnectWithoutToDirectMessagesInput
    upsert?: TwitterUserUpsertWithoutToDirectMessagesInput
    connect?: TwitterUserWhereUniqueInput
    update?: XOR<TwitterUserUpdateWithoutToDirectMessagesInput, TwitterUserUncheckedUpdateWithoutToDirectMessagesInput>
  }

  export type TwitterUserCreateNestedOneWithoutFollowingUserRelationsInput = {
    create?: XOR<TwitterUserCreateWithoutFollowingUserRelationsInput, TwitterUserUncheckedCreateWithoutFollowingUserRelationsInput>
    connectOrCreate?: TwitterUserCreateOrConnectWithoutFollowingUserRelationsInput
    connect?: TwitterUserWhereUniqueInput
  }

  export type TwitterUserCreateNestedOneWithoutFollowerUserRelationsInput = {
    create?: XOR<TwitterUserCreateWithoutFollowerUserRelationsInput, TwitterUserUncheckedCreateWithoutFollowerUserRelationsInput>
    connectOrCreate?: TwitterUserCreateOrConnectWithoutFollowerUserRelationsInput
    connect?: TwitterUserWhereUniqueInput
  }

  export type TwitterUserUpdateOneRequiredWithoutFollowingUserRelationsNestedInput = {
    create?: XOR<TwitterUserCreateWithoutFollowingUserRelationsInput, TwitterUserUncheckedCreateWithoutFollowingUserRelationsInput>
    connectOrCreate?: TwitterUserCreateOrConnectWithoutFollowingUserRelationsInput
    upsert?: TwitterUserUpsertWithoutFollowingUserRelationsInput
    connect?: TwitterUserWhereUniqueInput
    update?: XOR<TwitterUserUpdateWithoutFollowingUserRelationsInput, TwitterUserUncheckedUpdateWithoutFollowingUserRelationsInput>
  }

  export type TwitterUserUpdateOneRequiredWithoutFollowerUserRelationsNestedInput = {
    create?: XOR<TwitterUserCreateWithoutFollowerUserRelationsInput, TwitterUserUncheckedCreateWithoutFollowerUserRelationsInput>
    connectOrCreate?: TwitterUserCreateOrConnectWithoutFollowerUserRelationsInput
    upsert?: TwitterUserUpsertWithoutFollowerUserRelationsInput
    connect?: TwitterUserWhereUniqueInput
    update?: XOR<TwitterUserUpdateWithoutFollowerUserRelationsInput, TwitterUserUncheckedUpdateWithoutFollowerUserRelationsInput>
  }

  export type TwitterPostCreateNestedOneWithoutCommentsInput = {
    create?: XOR<TwitterPostCreateWithoutCommentsInput, TwitterPostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TwitterPostCreateOrConnectWithoutCommentsInput
    connect?: TwitterPostWhereUniqueInput
  }

  export type TwitterUserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<TwitterUserCreateWithoutCommentsInput, TwitterUserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TwitterUserCreateOrConnectWithoutCommentsInput
    connect?: TwitterUserWhereUniqueInput
  }

  export type TwitterPostUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<TwitterPostCreateWithoutCommentsInput, TwitterPostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TwitterPostCreateOrConnectWithoutCommentsInput
    upsert?: TwitterPostUpsertWithoutCommentsInput
    connect?: TwitterPostWhereUniqueInput
    update?: XOR<TwitterPostUpdateWithoutCommentsInput, TwitterPostUncheckedUpdateWithoutCommentsInput>
  }

  export type TwitterUserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<TwitterUserCreateWithoutCommentsInput, TwitterUserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TwitterUserCreateOrConnectWithoutCommentsInput
    upsert?: TwitterUserUpsertWithoutCommentsInput
    connect?: TwitterUserWhereUniqueInput
    update?: XOR<TwitterUserUpdateWithoutCommentsInput, TwitterUserUncheckedUpdateWithoutCommentsInput>
  }

  export type YoutubeUserToChannelCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<YoutubeUserToChannelCreateWithoutUserInput>, Enumerable<YoutubeUserToChannelUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YoutubeUserToChannelCreateOrConnectWithoutUserInput>
    createMany?: YoutubeUserToChannelCreateManyUserInputEnvelope
    connect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
  }

  export type YoutubeSubscriptionCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<YoutubeSubscriptionCreateWithoutUserInput>, Enumerable<YoutubeSubscriptionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YoutubeSubscriptionCreateOrConnectWithoutUserInput>
    createMany?: YoutubeSubscriptionCreateManyUserInputEnvelope
    connect?: Enumerable<YoutubeSubscriptionWhereUniqueInput>
  }

  export type YoutubeReactionCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<YoutubeReactionCreateWithoutUserInput>, Enumerable<YoutubeReactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YoutubeReactionCreateOrConnectWithoutUserInput>
    createMany?: YoutubeReactionCreateManyUserInputEnvelope
    connect?: Enumerable<YoutubeReactionWhereUniqueInput>
  }

  export type YoutubeCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<YoutubeCommentCreateWithoutUserInput>, Enumerable<YoutubeCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YoutubeCommentCreateOrConnectWithoutUserInput>
    createMany?: YoutubeCommentCreateManyUserInputEnvelope
    connect?: Enumerable<YoutubeCommentWhereUniqueInput>
  }

  export type YoutubeCommentReactionCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<YoutubeCommentReactionCreateWithoutUserInput>, Enumerable<YoutubeCommentReactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YoutubeCommentReactionCreateOrConnectWithoutUserInput>
    createMany?: YoutubeCommentReactionCreateManyUserInputEnvelope
    connect?: Enumerable<YoutubeCommentReactionWhereUniqueInput>
  }

  export type YoutubeUserToChannelUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<YoutubeUserToChannelCreateWithoutUserInput>, Enumerable<YoutubeUserToChannelUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YoutubeUserToChannelCreateOrConnectWithoutUserInput>
    createMany?: YoutubeUserToChannelCreateManyUserInputEnvelope
    connect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
  }

  export type YoutubeSubscriptionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<YoutubeSubscriptionCreateWithoutUserInput>, Enumerable<YoutubeSubscriptionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YoutubeSubscriptionCreateOrConnectWithoutUserInput>
    createMany?: YoutubeSubscriptionCreateManyUserInputEnvelope
    connect?: Enumerable<YoutubeSubscriptionWhereUniqueInput>
  }

  export type YoutubeReactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<YoutubeReactionCreateWithoutUserInput>, Enumerable<YoutubeReactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YoutubeReactionCreateOrConnectWithoutUserInput>
    createMany?: YoutubeReactionCreateManyUserInputEnvelope
    connect?: Enumerable<YoutubeReactionWhereUniqueInput>
  }

  export type YoutubeCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<YoutubeCommentCreateWithoutUserInput>, Enumerable<YoutubeCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YoutubeCommentCreateOrConnectWithoutUserInput>
    createMany?: YoutubeCommentCreateManyUserInputEnvelope
    connect?: Enumerable<YoutubeCommentWhereUniqueInput>
  }

  export type YoutubeCommentReactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<YoutubeCommentReactionCreateWithoutUserInput>, Enumerable<YoutubeCommentReactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YoutubeCommentReactionCreateOrConnectWithoutUserInput>
    createMany?: YoutubeCommentReactionCreateManyUserInputEnvelope
    connect?: Enumerable<YoutubeCommentReactionWhereUniqueInput>
  }

  export type YoutubeUserToChannelUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<YoutubeUserToChannelCreateWithoutUserInput>, Enumerable<YoutubeUserToChannelUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YoutubeUserToChannelCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<YoutubeUserToChannelUpsertWithWhereUniqueWithoutUserInput>
    createMany?: YoutubeUserToChannelCreateManyUserInputEnvelope
    set?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    disconnect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    delete?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    connect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    update?: Enumerable<YoutubeUserToChannelUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<YoutubeUserToChannelUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<YoutubeUserToChannelScalarWhereInput>
  }

  export type YoutubeSubscriptionUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<YoutubeSubscriptionCreateWithoutUserInput>, Enumerable<YoutubeSubscriptionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YoutubeSubscriptionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<YoutubeSubscriptionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: YoutubeSubscriptionCreateManyUserInputEnvelope
    set?: Enumerable<YoutubeSubscriptionWhereUniqueInput>
    disconnect?: Enumerable<YoutubeSubscriptionWhereUniqueInput>
    delete?: Enumerable<YoutubeSubscriptionWhereUniqueInput>
    connect?: Enumerable<YoutubeSubscriptionWhereUniqueInput>
    update?: Enumerable<YoutubeSubscriptionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<YoutubeSubscriptionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<YoutubeSubscriptionScalarWhereInput>
  }

  export type YoutubeReactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<YoutubeReactionCreateWithoutUserInput>, Enumerable<YoutubeReactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YoutubeReactionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<YoutubeReactionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: YoutubeReactionCreateManyUserInputEnvelope
    set?: Enumerable<YoutubeReactionWhereUniqueInput>
    disconnect?: Enumerable<YoutubeReactionWhereUniqueInput>
    delete?: Enumerable<YoutubeReactionWhereUniqueInput>
    connect?: Enumerable<YoutubeReactionWhereUniqueInput>
    update?: Enumerable<YoutubeReactionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<YoutubeReactionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<YoutubeReactionScalarWhereInput>
  }

  export type YoutubeCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<YoutubeCommentCreateWithoutUserInput>, Enumerable<YoutubeCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YoutubeCommentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<YoutubeCommentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: YoutubeCommentCreateManyUserInputEnvelope
    set?: Enumerable<YoutubeCommentWhereUniqueInput>
    disconnect?: Enumerable<YoutubeCommentWhereUniqueInput>
    delete?: Enumerable<YoutubeCommentWhereUniqueInput>
    connect?: Enumerable<YoutubeCommentWhereUniqueInput>
    update?: Enumerable<YoutubeCommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<YoutubeCommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<YoutubeCommentScalarWhereInput>
  }

  export type YoutubeCommentReactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<YoutubeCommentReactionCreateWithoutUserInput>, Enumerable<YoutubeCommentReactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YoutubeCommentReactionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<YoutubeCommentReactionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: YoutubeCommentReactionCreateManyUserInputEnvelope
    set?: Enumerable<YoutubeCommentReactionWhereUniqueInput>
    disconnect?: Enumerable<YoutubeCommentReactionWhereUniqueInput>
    delete?: Enumerable<YoutubeCommentReactionWhereUniqueInput>
    connect?: Enumerable<YoutubeCommentReactionWhereUniqueInput>
    update?: Enumerable<YoutubeCommentReactionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<YoutubeCommentReactionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<YoutubeCommentReactionScalarWhereInput>
  }

  export type YoutubeUserToChannelUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<YoutubeUserToChannelCreateWithoutUserInput>, Enumerable<YoutubeUserToChannelUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YoutubeUserToChannelCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<YoutubeUserToChannelUpsertWithWhereUniqueWithoutUserInput>
    createMany?: YoutubeUserToChannelCreateManyUserInputEnvelope
    set?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    disconnect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    delete?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    connect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    update?: Enumerable<YoutubeUserToChannelUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<YoutubeUserToChannelUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<YoutubeUserToChannelScalarWhereInput>
  }

  export type YoutubeSubscriptionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<YoutubeSubscriptionCreateWithoutUserInput>, Enumerable<YoutubeSubscriptionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YoutubeSubscriptionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<YoutubeSubscriptionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: YoutubeSubscriptionCreateManyUserInputEnvelope
    set?: Enumerable<YoutubeSubscriptionWhereUniqueInput>
    disconnect?: Enumerable<YoutubeSubscriptionWhereUniqueInput>
    delete?: Enumerable<YoutubeSubscriptionWhereUniqueInput>
    connect?: Enumerable<YoutubeSubscriptionWhereUniqueInput>
    update?: Enumerable<YoutubeSubscriptionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<YoutubeSubscriptionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<YoutubeSubscriptionScalarWhereInput>
  }

  export type YoutubeReactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<YoutubeReactionCreateWithoutUserInput>, Enumerable<YoutubeReactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YoutubeReactionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<YoutubeReactionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: YoutubeReactionCreateManyUserInputEnvelope
    set?: Enumerable<YoutubeReactionWhereUniqueInput>
    disconnect?: Enumerable<YoutubeReactionWhereUniqueInput>
    delete?: Enumerable<YoutubeReactionWhereUniqueInput>
    connect?: Enumerable<YoutubeReactionWhereUniqueInput>
    update?: Enumerable<YoutubeReactionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<YoutubeReactionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<YoutubeReactionScalarWhereInput>
  }

  export type YoutubeCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<YoutubeCommentCreateWithoutUserInput>, Enumerable<YoutubeCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YoutubeCommentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<YoutubeCommentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: YoutubeCommentCreateManyUserInputEnvelope
    set?: Enumerable<YoutubeCommentWhereUniqueInput>
    disconnect?: Enumerable<YoutubeCommentWhereUniqueInput>
    delete?: Enumerable<YoutubeCommentWhereUniqueInput>
    connect?: Enumerable<YoutubeCommentWhereUniqueInput>
    update?: Enumerable<YoutubeCommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<YoutubeCommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<YoutubeCommentScalarWhereInput>
  }

  export type YoutubeCommentReactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<YoutubeCommentReactionCreateWithoutUserInput>, Enumerable<YoutubeCommentReactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YoutubeCommentReactionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<YoutubeCommentReactionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: YoutubeCommentReactionCreateManyUserInputEnvelope
    set?: Enumerable<YoutubeCommentReactionWhereUniqueInput>
    disconnect?: Enumerable<YoutubeCommentReactionWhereUniqueInput>
    delete?: Enumerable<YoutubeCommentReactionWhereUniqueInput>
    connect?: Enumerable<YoutubeCommentReactionWhereUniqueInput>
    update?: Enumerable<YoutubeCommentReactionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<YoutubeCommentReactionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<YoutubeCommentReactionScalarWhereInput>
  }

  export type YoutubeUserToChannelCreateNestedManyWithoutChannelInput = {
    create?: XOR<Enumerable<YoutubeUserToChannelCreateWithoutChannelInput>, Enumerable<YoutubeUserToChannelUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<YoutubeUserToChannelCreateOrConnectWithoutChannelInput>
    createMany?: YoutubeUserToChannelCreateManyChannelInputEnvelope
    connect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
  }

  export type YoutubeVideoCreateNestedManyWithoutChannelInput = {
    create?: XOR<Enumerable<YoutubeVideoCreateWithoutChannelInput>, Enumerable<YoutubeVideoUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<YoutubeVideoCreateOrConnectWithoutChannelInput>
    createMany?: YoutubeVideoCreateManyChannelInputEnvelope
    connect?: Enumerable<YoutubeVideoWhereUniqueInput>
  }

  export type YoutubeSubscriptionCreateNestedManyWithoutChannelInput = {
    create?: XOR<Enumerable<YoutubeSubscriptionCreateWithoutChannelInput>, Enumerable<YoutubeSubscriptionUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<YoutubeSubscriptionCreateOrConnectWithoutChannelInput>
    createMany?: YoutubeSubscriptionCreateManyChannelInputEnvelope
    connect?: Enumerable<YoutubeSubscriptionWhereUniqueInput>
  }

  export type YoutubeUserToChannelUncheckedCreateNestedManyWithoutChannelInput = {
    create?: XOR<Enumerable<YoutubeUserToChannelCreateWithoutChannelInput>, Enumerable<YoutubeUserToChannelUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<YoutubeUserToChannelCreateOrConnectWithoutChannelInput>
    createMany?: YoutubeUserToChannelCreateManyChannelInputEnvelope
    connect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
  }

  export type YoutubeVideoUncheckedCreateNestedManyWithoutChannelInput = {
    create?: XOR<Enumerable<YoutubeVideoCreateWithoutChannelInput>, Enumerable<YoutubeVideoUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<YoutubeVideoCreateOrConnectWithoutChannelInput>
    createMany?: YoutubeVideoCreateManyChannelInputEnvelope
    connect?: Enumerable<YoutubeVideoWhereUniqueInput>
  }

  export type YoutubeSubscriptionUncheckedCreateNestedManyWithoutChannelInput = {
    create?: XOR<Enumerable<YoutubeSubscriptionCreateWithoutChannelInput>, Enumerable<YoutubeSubscriptionUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<YoutubeSubscriptionCreateOrConnectWithoutChannelInput>
    createMany?: YoutubeSubscriptionCreateManyChannelInputEnvelope
    connect?: Enumerable<YoutubeSubscriptionWhereUniqueInput>
  }

  export type YoutubeUserToChannelUpdateManyWithoutChannelNestedInput = {
    create?: XOR<Enumerable<YoutubeUserToChannelCreateWithoutChannelInput>, Enumerable<YoutubeUserToChannelUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<YoutubeUserToChannelCreateOrConnectWithoutChannelInput>
    upsert?: Enumerable<YoutubeUserToChannelUpsertWithWhereUniqueWithoutChannelInput>
    createMany?: YoutubeUserToChannelCreateManyChannelInputEnvelope
    set?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    disconnect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    delete?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    connect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    update?: Enumerable<YoutubeUserToChannelUpdateWithWhereUniqueWithoutChannelInput>
    updateMany?: Enumerable<YoutubeUserToChannelUpdateManyWithWhereWithoutChannelInput>
    deleteMany?: Enumerable<YoutubeUserToChannelScalarWhereInput>
  }

  export type YoutubeVideoUpdateManyWithoutChannelNestedInput = {
    create?: XOR<Enumerable<YoutubeVideoCreateWithoutChannelInput>, Enumerable<YoutubeVideoUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<YoutubeVideoCreateOrConnectWithoutChannelInput>
    upsert?: Enumerable<YoutubeVideoUpsertWithWhereUniqueWithoutChannelInput>
    createMany?: YoutubeVideoCreateManyChannelInputEnvelope
    set?: Enumerable<YoutubeVideoWhereUniqueInput>
    disconnect?: Enumerable<YoutubeVideoWhereUniqueInput>
    delete?: Enumerable<YoutubeVideoWhereUniqueInput>
    connect?: Enumerable<YoutubeVideoWhereUniqueInput>
    update?: Enumerable<YoutubeVideoUpdateWithWhereUniqueWithoutChannelInput>
    updateMany?: Enumerable<YoutubeVideoUpdateManyWithWhereWithoutChannelInput>
    deleteMany?: Enumerable<YoutubeVideoScalarWhereInput>
  }

  export type YoutubeSubscriptionUpdateManyWithoutChannelNestedInput = {
    create?: XOR<Enumerable<YoutubeSubscriptionCreateWithoutChannelInput>, Enumerable<YoutubeSubscriptionUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<YoutubeSubscriptionCreateOrConnectWithoutChannelInput>
    upsert?: Enumerable<YoutubeSubscriptionUpsertWithWhereUniqueWithoutChannelInput>
    createMany?: YoutubeSubscriptionCreateManyChannelInputEnvelope
    set?: Enumerable<YoutubeSubscriptionWhereUniqueInput>
    disconnect?: Enumerable<YoutubeSubscriptionWhereUniqueInput>
    delete?: Enumerable<YoutubeSubscriptionWhereUniqueInput>
    connect?: Enumerable<YoutubeSubscriptionWhereUniqueInput>
    update?: Enumerable<YoutubeSubscriptionUpdateWithWhereUniqueWithoutChannelInput>
    updateMany?: Enumerable<YoutubeSubscriptionUpdateManyWithWhereWithoutChannelInput>
    deleteMany?: Enumerable<YoutubeSubscriptionScalarWhereInput>
  }

  export type YoutubeUserToChannelUncheckedUpdateManyWithoutChannelNestedInput = {
    create?: XOR<Enumerable<YoutubeUserToChannelCreateWithoutChannelInput>, Enumerable<YoutubeUserToChannelUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<YoutubeUserToChannelCreateOrConnectWithoutChannelInput>
    upsert?: Enumerable<YoutubeUserToChannelUpsertWithWhereUniqueWithoutChannelInput>
    createMany?: YoutubeUserToChannelCreateManyChannelInputEnvelope
    set?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    disconnect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    delete?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    connect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    update?: Enumerable<YoutubeUserToChannelUpdateWithWhereUniqueWithoutChannelInput>
    updateMany?: Enumerable<YoutubeUserToChannelUpdateManyWithWhereWithoutChannelInput>
    deleteMany?: Enumerable<YoutubeUserToChannelScalarWhereInput>
  }

  export type YoutubeVideoUncheckedUpdateManyWithoutChannelNestedInput = {
    create?: XOR<Enumerable<YoutubeVideoCreateWithoutChannelInput>, Enumerable<YoutubeVideoUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<YoutubeVideoCreateOrConnectWithoutChannelInput>
    upsert?: Enumerable<YoutubeVideoUpsertWithWhereUniqueWithoutChannelInput>
    createMany?: YoutubeVideoCreateManyChannelInputEnvelope
    set?: Enumerable<YoutubeVideoWhereUniqueInput>
    disconnect?: Enumerable<YoutubeVideoWhereUniqueInput>
    delete?: Enumerable<YoutubeVideoWhereUniqueInput>
    connect?: Enumerable<YoutubeVideoWhereUniqueInput>
    update?: Enumerable<YoutubeVideoUpdateWithWhereUniqueWithoutChannelInput>
    updateMany?: Enumerable<YoutubeVideoUpdateManyWithWhereWithoutChannelInput>
    deleteMany?: Enumerable<YoutubeVideoScalarWhereInput>
  }

  export type YoutubeSubscriptionUncheckedUpdateManyWithoutChannelNestedInput = {
    create?: XOR<Enumerable<YoutubeSubscriptionCreateWithoutChannelInput>, Enumerable<YoutubeSubscriptionUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<YoutubeSubscriptionCreateOrConnectWithoutChannelInput>
    upsert?: Enumerable<YoutubeSubscriptionUpsertWithWhereUniqueWithoutChannelInput>
    createMany?: YoutubeSubscriptionCreateManyChannelInputEnvelope
    set?: Enumerable<YoutubeSubscriptionWhereUniqueInput>
    disconnect?: Enumerable<YoutubeSubscriptionWhereUniqueInput>
    delete?: Enumerable<YoutubeSubscriptionWhereUniqueInput>
    connect?: Enumerable<YoutubeSubscriptionWhereUniqueInput>
    update?: Enumerable<YoutubeSubscriptionUpdateWithWhereUniqueWithoutChannelInput>
    updateMany?: Enumerable<YoutubeSubscriptionUpdateManyWithWhereWithoutChannelInput>
    deleteMany?: Enumerable<YoutubeSubscriptionScalarWhereInput>
  }

  export type YoutubeUserCreateNestedOneWithoutYoutubeSubscriptionsInput = {
    create?: XOR<YoutubeUserCreateWithoutYoutubeSubscriptionsInput, YoutubeUserUncheckedCreateWithoutYoutubeSubscriptionsInput>
    connectOrCreate?: YoutubeUserCreateOrConnectWithoutYoutubeSubscriptionsInput
    connect?: YoutubeUserWhereUniqueInput
  }

  export type YoutubeChannelCreateNestedOneWithoutYoutubeSubscriptionsInput = {
    create?: XOR<YoutubeChannelCreateWithoutYoutubeSubscriptionsInput, YoutubeChannelUncheckedCreateWithoutYoutubeSubscriptionsInput>
    connectOrCreate?: YoutubeChannelCreateOrConnectWithoutYoutubeSubscriptionsInput
    connect?: YoutubeChannelWhereUniqueInput
  }

  export type YoutubeUserUpdateOneRequiredWithoutYoutubeSubscriptionsNestedInput = {
    create?: XOR<YoutubeUserCreateWithoutYoutubeSubscriptionsInput, YoutubeUserUncheckedCreateWithoutYoutubeSubscriptionsInput>
    connectOrCreate?: YoutubeUserCreateOrConnectWithoutYoutubeSubscriptionsInput
    upsert?: YoutubeUserUpsertWithoutYoutubeSubscriptionsInput
    connect?: YoutubeUserWhereUniqueInput
    update?: XOR<YoutubeUserUpdateWithoutYoutubeSubscriptionsInput, YoutubeUserUncheckedUpdateWithoutYoutubeSubscriptionsInput>
  }

  export type YoutubeChannelUpdateOneRequiredWithoutYoutubeSubscriptionsNestedInput = {
    create?: XOR<YoutubeChannelCreateWithoutYoutubeSubscriptionsInput, YoutubeChannelUncheckedCreateWithoutYoutubeSubscriptionsInput>
    connectOrCreate?: YoutubeChannelCreateOrConnectWithoutYoutubeSubscriptionsInput
    upsert?: YoutubeChannelUpsertWithoutYoutubeSubscriptionsInput
    connect?: YoutubeChannelWhereUniqueInput
    update?: XOR<YoutubeChannelUpdateWithoutYoutubeSubscriptionsInput, YoutubeChannelUncheckedUpdateWithoutYoutubeSubscriptionsInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type YoutubeUserCreateNestedOneWithoutYoutubeUsersToChannelsInput = {
    create?: XOR<YoutubeUserCreateWithoutYoutubeUsersToChannelsInput, YoutubeUserUncheckedCreateWithoutYoutubeUsersToChannelsInput>
    connectOrCreate?: YoutubeUserCreateOrConnectWithoutYoutubeUsersToChannelsInput
    connect?: YoutubeUserWhereUniqueInput
  }

  export type YoutubeChannelCreateNestedOneWithoutYoutubeUsersToChannelsInput = {
    create?: XOR<YoutubeChannelCreateWithoutYoutubeUsersToChannelsInput, YoutubeChannelUncheckedCreateWithoutYoutubeUsersToChannelsInput>
    connectOrCreate?: YoutubeChannelCreateOrConnectWithoutYoutubeUsersToChannelsInput
    connect?: YoutubeChannelWhereUniqueInput
  }

  export type YoutubeUserUpdateOneRequiredWithoutYoutubeUsersToChannelsNestedInput = {
    create?: XOR<YoutubeUserCreateWithoutYoutubeUsersToChannelsInput, YoutubeUserUncheckedCreateWithoutYoutubeUsersToChannelsInput>
    connectOrCreate?: YoutubeUserCreateOrConnectWithoutYoutubeUsersToChannelsInput
    upsert?: YoutubeUserUpsertWithoutYoutubeUsersToChannelsInput
    connect?: YoutubeUserWhereUniqueInput
    update?: XOR<YoutubeUserUpdateWithoutYoutubeUsersToChannelsInput, YoutubeUserUncheckedUpdateWithoutYoutubeUsersToChannelsInput>
  }

  export type YoutubeChannelUpdateOneRequiredWithoutYoutubeUsersToChannelsNestedInput = {
    create?: XOR<YoutubeChannelCreateWithoutYoutubeUsersToChannelsInput, YoutubeChannelUncheckedCreateWithoutYoutubeUsersToChannelsInput>
    connectOrCreate?: YoutubeChannelCreateOrConnectWithoutYoutubeUsersToChannelsInput
    upsert?: YoutubeChannelUpsertWithoutYoutubeUsersToChannelsInput
    connect?: YoutubeChannelWhereUniqueInput
    update?: XOR<YoutubeChannelUpdateWithoutYoutubeUsersToChannelsInput, YoutubeChannelUncheckedUpdateWithoutYoutubeUsersToChannelsInput>
  }

  export type EnumRoleEnumFieldUpdateOperationsInput = {
    set?: RoleEnum
  }

  export type YoutubeChannelCreateNestedOneWithoutYoutubeVideosInput = {
    create?: XOR<YoutubeChannelCreateWithoutYoutubeVideosInput, YoutubeChannelUncheckedCreateWithoutYoutubeVideosInput>
    connectOrCreate?: YoutubeChannelCreateOrConnectWithoutYoutubeVideosInput
    connect?: YoutubeChannelWhereUniqueInput
  }

  export type YoutubeCommentCreateNestedManyWithoutVideoInput = {
    create?: XOR<Enumerable<YoutubeCommentCreateWithoutVideoInput>, Enumerable<YoutubeCommentUncheckedCreateWithoutVideoInput>>
    connectOrCreate?: Enumerable<YoutubeCommentCreateOrConnectWithoutVideoInput>
    createMany?: YoutubeCommentCreateManyVideoInputEnvelope
    connect?: Enumerable<YoutubeCommentWhereUniqueInput>
  }

  export type YoutubeReactionCreateNestedManyWithoutVideoInput = {
    create?: XOR<Enumerable<YoutubeReactionCreateWithoutVideoInput>, Enumerable<YoutubeReactionUncheckedCreateWithoutVideoInput>>
    connectOrCreate?: Enumerable<YoutubeReactionCreateOrConnectWithoutVideoInput>
    createMany?: YoutubeReactionCreateManyVideoInputEnvelope
    connect?: Enumerable<YoutubeReactionWhereUniqueInput>
  }

  export type YoutubeCommentUncheckedCreateNestedManyWithoutVideoInput = {
    create?: XOR<Enumerable<YoutubeCommentCreateWithoutVideoInput>, Enumerable<YoutubeCommentUncheckedCreateWithoutVideoInput>>
    connectOrCreate?: Enumerable<YoutubeCommentCreateOrConnectWithoutVideoInput>
    createMany?: YoutubeCommentCreateManyVideoInputEnvelope
    connect?: Enumerable<YoutubeCommentWhereUniqueInput>
  }

  export type YoutubeReactionUncheckedCreateNestedManyWithoutVideoInput = {
    create?: XOR<Enumerable<YoutubeReactionCreateWithoutVideoInput>, Enumerable<YoutubeReactionUncheckedCreateWithoutVideoInput>>
    connectOrCreate?: Enumerable<YoutubeReactionCreateOrConnectWithoutVideoInput>
    createMany?: YoutubeReactionCreateManyVideoInputEnvelope
    connect?: Enumerable<YoutubeReactionWhereUniqueInput>
  }

  export type YoutubeChannelUpdateOneRequiredWithoutYoutubeVideosNestedInput = {
    create?: XOR<YoutubeChannelCreateWithoutYoutubeVideosInput, YoutubeChannelUncheckedCreateWithoutYoutubeVideosInput>
    connectOrCreate?: YoutubeChannelCreateOrConnectWithoutYoutubeVideosInput
    upsert?: YoutubeChannelUpsertWithoutYoutubeVideosInput
    connect?: YoutubeChannelWhereUniqueInput
    update?: XOR<YoutubeChannelUpdateWithoutYoutubeVideosInput, YoutubeChannelUncheckedUpdateWithoutYoutubeVideosInput>
  }

  export type YoutubeCommentUpdateManyWithoutVideoNestedInput = {
    create?: XOR<Enumerable<YoutubeCommentCreateWithoutVideoInput>, Enumerable<YoutubeCommentUncheckedCreateWithoutVideoInput>>
    connectOrCreate?: Enumerable<YoutubeCommentCreateOrConnectWithoutVideoInput>
    upsert?: Enumerable<YoutubeCommentUpsertWithWhereUniqueWithoutVideoInput>
    createMany?: YoutubeCommentCreateManyVideoInputEnvelope
    set?: Enumerable<YoutubeCommentWhereUniqueInput>
    disconnect?: Enumerable<YoutubeCommentWhereUniqueInput>
    delete?: Enumerable<YoutubeCommentWhereUniqueInput>
    connect?: Enumerable<YoutubeCommentWhereUniqueInput>
    update?: Enumerable<YoutubeCommentUpdateWithWhereUniqueWithoutVideoInput>
    updateMany?: Enumerable<YoutubeCommentUpdateManyWithWhereWithoutVideoInput>
    deleteMany?: Enumerable<YoutubeCommentScalarWhereInput>
  }

  export type YoutubeReactionUpdateManyWithoutVideoNestedInput = {
    create?: XOR<Enumerable<YoutubeReactionCreateWithoutVideoInput>, Enumerable<YoutubeReactionUncheckedCreateWithoutVideoInput>>
    connectOrCreate?: Enumerable<YoutubeReactionCreateOrConnectWithoutVideoInput>
    upsert?: Enumerable<YoutubeReactionUpsertWithWhereUniqueWithoutVideoInput>
    createMany?: YoutubeReactionCreateManyVideoInputEnvelope
    set?: Enumerable<YoutubeReactionWhereUniqueInput>
    disconnect?: Enumerable<YoutubeReactionWhereUniqueInput>
    delete?: Enumerable<YoutubeReactionWhereUniqueInput>
    connect?: Enumerable<YoutubeReactionWhereUniqueInput>
    update?: Enumerable<YoutubeReactionUpdateWithWhereUniqueWithoutVideoInput>
    updateMany?: Enumerable<YoutubeReactionUpdateManyWithWhereWithoutVideoInput>
    deleteMany?: Enumerable<YoutubeReactionScalarWhereInput>
  }

  export type YoutubeCommentUncheckedUpdateManyWithoutVideoNestedInput = {
    create?: XOR<Enumerable<YoutubeCommentCreateWithoutVideoInput>, Enumerable<YoutubeCommentUncheckedCreateWithoutVideoInput>>
    connectOrCreate?: Enumerable<YoutubeCommentCreateOrConnectWithoutVideoInput>
    upsert?: Enumerable<YoutubeCommentUpsertWithWhereUniqueWithoutVideoInput>
    createMany?: YoutubeCommentCreateManyVideoInputEnvelope
    set?: Enumerable<YoutubeCommentWhereUniqueInput>
    disconnect?: Enumerable<YoutubeCommentWhereUniqueInput>
    delete?: Enumerable<YoutubeCommentWhereUniqueInput>
    connect?: Enumerable<YoutubeCommentWhereUniqueInput>
    update?: Enumerable<YoutubeCommentUpdateWithWhereUniqueWithoutVideoInput>
    updateMany?: Enumerable<YoutubeCommentUpdateManyWithWhereWithoutVideoInput>
    deleteMany?: Enumerable<YoutubeCommentScalarWhereInput>
  }

  export type YoutubeReactionUncheckedUpdateManyWithoutVideoNestedInput = {
    create?: XOR<Enumerable<YoutubeReactionCreateWithoutVideoInput>, Enumerable<YoutubeReactionUncheckedCreateWithoutVideoInput>>
    connectOrCreate?: Enumerable<YoutubeReactionCreateOrConnectWithoutVideoInput>
    upsert?: Enumerable<YoutubeReactionUpsertWithWhereUniqueWithoutVideoInput>
    createMany?: YoutubeReactionCreateManyVideoInputEnvelope
    set?: Enumerable<YoutubeReactionWhereUniqueInput>
    disconnect?: Enumerable<YoutubeReactionWhereUniqueInput>
    delete?: Enumerable<YoutubeReactionWhereUniqueInput>
    connect?: Enumerable<YoutubeReactionWhereUniqueInput>
    update?: Enumerable<YoutubeReactionUpdateWithWhereUniqueWithoutVideoInput>
    updateMany?: Enumerable<YoutubeReactionUpdateManyWithWhereWithoutVideoInput>
    deleteMany?: Enumerable<YoutubeReactionScalarWhereInput>
  }

  export type YoutubeUserCreateNestedOneWithoutYoutubeReactionInput = {
    create?: XOR<YoutubeUserCreateWithoutYoutubeReactionInput, YoutubeUserUncheckedCreateWithoutYoutubeReactionInput>
    connectOrCreate?: YoutubeUserCreateOrConnectWithoutYoutubeReactionInput
    connect?: YoutubeUserWhereUniqueInput
  }

  export type YoutubeVideoCreateNestedOneWithoutYoutubeReactionsInput = {
    create?: XOR<YoutubeVideoCreateWithoutYoutubeReactionsInput, YoutubeVideoUncheckedCreateWithoutYoutubeReactionsInput>
    connectOrCreate?: YoutubeVideoCreateOrConnectWithoutYoutubeReactionsInput
    connect?: YoutubeVideoWhereUniqueInput
  }

  export type YoutubeUserUpdateOneRequiredWithoutYoutubeReactionNestedInput = {
    create?: XOR<YoutubeUserCreateWithoutYoutubeReactionInput, YoutubeUserUncheckedCreateWithoutYoutubeReactionInput>
    connectOrCreate?: YoutubeUserCreateOrConnectWithoutYoutubeReactionInput
    upsert?: YoutubeUserUpsertWithoutYoutubeReactionInput
    connect?: YoutubeUserWhereUniqueInput
    update?: XOR<YoutubeUserUpdateWithoutYoutubeReactionInput, YoutubeUserUncheckedUpdateWithoutYoutubeReactionInput>
  }

  export type YoutubeVideoUpdateOneRequiredWithoutYoutubeReactionsNestedInput = {
    create?: XOR<YoutubeVideoCreateWithoutYoutubeReactionsInput, YoutubeVideoUncheckedCreateWithoutYoutubeReactionsInput>
    connectOrCreate?: YoutubeVideoCreateOrConnectWithoutYoutubeReactionsInput
    upsert?: YoutubeVideoUpsertWithoutYoutubeReactionsInput
    connect?: YoutubeVideoWhereUniqueInput
    update?: XOR<YoutubeVideoUpdateWithoutYoutubeReactionsInput, YoutubeVideoUncheckedUpdateWithoutYoutubeReactionsInput>
  }

  export type EnumReactionEnumFieldUpdateOperationsInput = {
    set?: ReactionEnum
  }

  export type YoutubeUserCreateNestedOneWithoutYoutubeCommentInput = {
    create?: XOR<YoutubeUserCreateWithoutYoutubeCommentInput, YoutubeUserUncheckedCreateWithoutYoutubeCommentInput>
    connectOrCreate?: YoutubeUserCreateOrConnectWithoutYoutubeCommentInput
    connect?: YoutubeUserWhereUniqueInput
  }

  export type YoutubeVideoCreateNestedOneWithoutYoutubeCommentsInput = {
    create?: XOR<YoutubeVideoCreateWithoutYoutubeCommentsInput, YoutubeVideoUncheckedCreateWithoutYoutubeCommentsInput>
    connectOrCreate?: YoutubeVideoCreateOrConnectWithoutYoutubeCommentsInput
    connect?: YoutubeVideoWhereUniqueInput
  }

  export type YoutubeCommentReactionCreateNestedManyWithoutCommentInput = {
    create?: XOR<Enumerable<YoutubeCommentReactionCreateWithoutCommentInput>, Enumerable<YoutubeCommentReactionUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<YoutubeCommentReactionCreateOrConnectWithoutCommentInput>
    createMany?: YoutubeCommentReactionCreateManyCommentInputEnvelope
    connect?: Enumerable<YoutubeCommentReactionWhereUniqueInput>
  }

  export type YoutubeCommentReactionUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<Enumerable<YoutubeCommentReactionCreateWithoutCommentInput>, Enumerable<YoutubeCommentReactionUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<YoutubeCommentReactionCreateOrConnectWithoutCommentInput>
    createMany?: YoutubeCommentReactionCreateManyCommentInputEnvelope
    connect?: Enumerable<YoutubeCommentReactionWhereUniqueInput>
  }

  export type YoutubeUserUpdateOneRequiredWithoutYoutubeCommentNestedInput = {
    create?: XOR<YoutubeUserCreateWithoutYoutubeCommentInput, YoutubeUserUncheckedCreateWithoutYoutubeCommentInput>
    connectOrCreate?: YoutubeUserCreateOrConnectWithoutYoutubeCommentInput
    upsert?: YoutubeUserUpsertWithoutYoutubeCommentInput
    connect?: YoutubeUserWhereUniqueInput
    update?: XOR<YoutubeUserUpdateWithoutYoutubeCommentInput, YoutubeUserUncheckedUpdateWithoutYoutubeCommentInput>
  }

  export type YoutubeVideoUpdateOneRequiredWithoutYoutubeCommentsNestedInput = {
    create?: XOR<YoutubeVideoCreateWithoutYoutubeCommentsInput, YoutubeVideoUncheckedCreateWithoutYoutubeCommentsInput>
    connectOrCreate?: YoutubeVideoCreateOrConnectWithoutYoutubeCommentsInput
    upsert?: YoutubeVideoUpsertWithoutYoutubeCommentsInput
    connect?: YoutubeVideoWhereUniqueInput
    update?: XOR<YoutubeVideoUpdateWithoutYoutubeCommentsInput, YoutubeVideoUncheckedUpdateWithoutYoutubeCommentsInput>
  }

  export type YoutubeCommentReactionUpdateManyWithoutCommentNestedInput = {
    create?: XOR<Enumerable<YoutubeCommentReactionCreateWithoutCommentInput>, Enumerable<YoutubeCommentReactionUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<YoutubeCommentReactionCreateOrConnectWithoutCommentInput>
    upsert?: Enumerable<YoutubeCommentReactionUpsertWithWhereUniqueWithoutCommentInput>
    createMany?: YoutubeCommentReactionCreateManyCommentInputEnvelope
    set?: Enumerable<YoutubeCommentReactionWhereUniqueInput>
    disconnect?: Enumerable<YoutubeCommentReactionWhereUniqueInput>
    delete?: Enumerable<YoutubeCommentReactionWhereUniqueInput>
    connect?: Enumerable<YoutubeCommentReactionWhereUniqueInput>
    update?: Enumerable<YoutubeCommentReactionUpdateWithWhereUniqueWithoutCommentInput>
    updateMany?: Enumerable<YoutubeCommentReactionUpdateManyWithWhereWithoutCommentInput>
    deleteMany?: Enumerable<YoutubeCommentReactionScalarWhereInput>
  }

  export type YoutubeCommentReactionUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<Enumerable<YoutubeCommentReactionCreateWithoutCommentInput>, Enumerable<YoutubeCommentReactionUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<YoutubeCommentReactionCreateOrConnectWithoutCommentInput>
    upsert?: Enumerable<YoutubeCommentReactionUpsertWithWhereUniqueWithoutCommentInput>
    createMany?: YoutubeCommentReactionCreateManyCommentInputEnvelope
    set?: Enumerable<YoutubeCommentReactionWhereUniqueInput>
    disconnect?: Enumerable<YoutubeCommentReactionWhereUniqueInput>
    delete?: Enumerable<YoutubeCommentReactionWhereUniqueInput>
    connect?: Enumerable<YoutubeCommentReactionWhereUniqueInput>
    update?: Enumerable<YoutubeCommentReactionUpdateWithWhereUniqueWithoutCommentInput>
    updateMany?: Enumerable<YoutubeCommentReactionUpdateManyWithWhereWithoutCommentInput>
    deleteMany?: Enumerable<YoutubeCommentReactionScalarWhereInput>
  }

  export type YoutubeUserCreateNestedOneWithoutYoutubeCommentReactionInput = {
    create?: XOR<YoutubeUserCreateWithoutYoutubeCommentReactionInput, YoutubeUserUncheckedCreateWithoutYoutubeCommentReactionInput>
    connectOrCreate?: YoutubeUserCreateOrConnectWithoutYoutubeCommentReactionInput
    connect?: YoutubeUserWhereUniqueInput
  }

  export type YoutubeCommentCreateNestedOneWithoutYoutubeCommentReactionsInput = {
    create?: XOR<YoutubeCommentCreateWithoutYoutubeCommentReactionsInput, YoutubeCommentUncheckedCreateWithoutYoutubeCommentReactionsInput>
    connectOrCreate?: YoutubeCommentCreateOrConnectWithoutYoutubeCommentReactionsInput
    connect?: YoutubeCommentWhereUniqueInput
  }

  export type YoutubeUserUpdateOneRequiredWithoutYoutubeCommentReactionNestedInput = {
    create?: XOR<YoutubeUserCreateWithoutYoutubeCommentReactionInput, YoutubeUserUncheckedCreateWithoutYoutubeCommentReactionInput>
    connectOrCreate?: YoutubeUserCreateOrConnectWithoutYoutubeCommentReactionInput
    upsert?: YoutubeUserUpsertWithoutYoutubeCommentReactionInput
    connect?: YoutubeUserWhereUniqueInput
    update?: XOR<YoutubeUserUpdateWithoutYoutubeCommentReactionInput, YoutubeUserUncheckedUpdateWithoutYoutubeCommentReactionInput>
  }

  export type YoutubeCommentUpdateOneRequiredWithoutYoutubeCommentReactionsNestedInput = {
    create?: XOR<YoutubeCommentCreateWithoutYoutubeCommentReactionsInput, YoutubeCommentUncheckedCreateWithoutYoutubeCommentReactionsInput>
    connectOrCreate?: YoutubeCommentCreateOrConnectWithoutYoutubeCommentReactionsInput
    upsert?: YoutubeCommentUpsertWithoutYoutubeCommentReactionsInput
    connect?: YoutubeCommentWhereUniqueInput
    update?: XOR<YoutubeCommentUpdateWithoutYoutubeCommentReactionsInput, YoutubeCommentUncheckedUpdateWithoutYoutubeCommentReactionsInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedEnumRoleEnumFilter = {
    equals?: RoleEnum
    in?: Enumerable<RoleEnum>
    notIn?: Enumerable<RoleEnum>
    not?: NestedEnumRoleEnumFilter | RoleEnum
  }

  export type NestedEnumRoleEnumWithAggregatesFilter = {
    equals?: RoleEnum
    in?: Enumerable<RoleEnum>
    notIn?: Enumerable<RoleEnum>
    not?: NestedEnumRoleEnumWithAggregatesFilter | RoleEnum
    _count?: NestedIntFilter
    _min?: NestedEnumRoleEnumFilter
    _max?: NestedEnumRoleEnumFilter
  }

  export type NestedEnumReactionEnumFilter = {
    equals?: ReactionEnum
    in?: Enumerable<ReactionEnum>
    notIn?: Enumerable<ReactionEnum>
    not?: NestedEnumReactionEnumFilter | ReactionEnum
  }

  export type NestedEnumReactionEnumWithAggregatesFilter = {
    equals?: ReactionEnum
    in?: Enumerable<ReactionEnum>
    notIn?: Enumerable<ReactionEnum>
    not?: NestedEnumReactionEnumWithAggregatesFilter | ReactionEnum
    _count?: NestedIntFilter
    _min?: NestedEnumReactionEnumFilter
    _max?: NestedEnumReactionEnumFilter
  }

  export type BinKitchenMenuCreateWithoutCategoryInput = {
    name: string
    image: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: BinKitchenOrderItemCreateNestedManyWithoutMenuInput
  }

  export type BinKitchenMenuUncheckedCreateWithoutCategoryInput = {
    id?: number
    name: string
    image: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: BinKitchenOrderItemUncheckedCreateNestedManyWithoutMenuInput
  }

  export type BinKitchenMenuCreateOrConnectWithoutCategoryInput = {
    where: BinKitchenMenuWhereUniqueInput
    create: XOR<BinKitchenMenuCreateWithoutCategoryInput, BinKitchenMenuUncheckedCreateWithoutCategoryInput>
  }

  export type BinKitchenMenuCreateManyCategoryInputEnvelope = {
    data: Enumerable<BinKitchenMenuCreateManyCategoryInput>
    skipDuplicates?: boolean
  }

  export type BinKitchenMenuUpsertWithWhereUniqueWithoutCategoryInput = {
    where: BinKitchenMenuWhereUniqueInput
    update: XOR<BinKitchenMenuUpdateWithoutCategoryInput, BinKitchenMenuUncheckedUpdateWithoutCategoryInput>
    create: XOR<BinKitchenMenuCreateWithoutCategoryInput, BinKitchenMenuUncheckedCreateWithoutCategoryInput>
  }

  export type BinKitchenMenuUpdateWithWhereUniqueWithoutCategoryInput = {
    where: BinKitchenMenuWhereUniqueInput
    data: XOR<BinKitchenMenuUpdateWithoutCategoryInput, BinKitchenMenuUncheckedUpdateWithoutCategoryInput>
  }

  export type BinKitchenMenuUpdateManyWithWhereWithoutCategoryInput = {
    where: BinKitchenMenuScalarWhereInput
    data: XOR<BinKitchenMenuUpdateManyMutationInput, BinKitchenMenuUncheckedUpdateManyWithoutMenusInput>
  }

  export type BinKitchenMenuScalarWhereInput = {
    AND?: Enumerable<BinKitchenMenuScalarWhereInput>
    OR?: Enumerable<BinKitchenMenuScalarWhereInput>
    NOT?: Enumerable<BinKitchenMenuScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    image?: StringFilter | string
    price?: FloatFilter | number
    categoryName?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type BinKitchenCategoryCreateWithoutMenusInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinKitchenCategoryUncheckedCreateWithoutMenusInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinKitchenCategoryCreateOrConnectWithoutMenusInput = {
    where: BinKitchenCategoryWhereUniqueInput
    create: XOR<BinKitchenCategoryCreateWithoutMenusInput, BinKitchenCategoryUncheckedCreateWithoutMenusInput>
  }

  export type BinKitchenOrderItemCreateWithoutMenuInput = {
    order: BinKitchenOrderCreateNestedOneWithoutItemsInput
    quantity: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinKitchenOrderItemUncheckedCreateWithoutMenuInput = {
    id?: number
    quantity: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderId: number
  }

  export type BinKitchenOrderItemCreateOrConnectWithoutMenuInput = {
    where: BinKitchenOrderItemWhereUniqueInput
    create: XOR<BinKitchenOrderItemCreateWithoutMenuInput, BinKitchenOrderItemUncheckedCreateWithoutMenuInput>
  }

  export type BinKitchenOrderItemCreateManyMenuInputEnvelope = {
    data: Enumerable<BinKitchenOrderItemCreateManyMenuInput>
    skipDuplicates?: boolean
  }

  export type BinKitchenCategoryUpsertWithoutMenusInput = {
    update: XOR<BinKitchenCategoryUpdateWithoutMenusInput, BinKitchenCategoryUncheckedUpdateWithoutMenusInput>
    create: XOR<BinKitchenCategoryCreateWithoutMenusInput, BinKitchenCategoryUncheckedCreateWithoutMenusInput>
  }

  export type BinKitchenCategoryUpdateWithoutMenusInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinKitchenCategoryUncheckedUpdateWithoutMenusInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinKitchenOrderItemUpsertWithWhereUniqueWithoutMenuInput = {
    where: BinKitchenOrderItemWhereUniqueInput
    update: XOR<BinKitchenOrderItemUpdateWithoutMenuInput, BinKitchenOrderItemUncheckedUpdateWithoutMenuInput>
    create: XOR<BinKitchenOrderItemCreateWithoutMenuInput, BinKitchenOrderItemUncheckedCreateWithoutMenuInput>
  }

  export type BinKitchenOrderItemUpdateWithWhereUniqueWithoutMenuInput = {
    where: BinKitchenOrderItemWhereUniqueInput
    data: XOR<BinKitchenOrderItemUpdateWithoutMenuInput, BinKitchenOrderItemUncheckedUpdateWithoutMenuInput>
  }

  export type BinKitchenOrderItemUpdateManyWithWhereWithoutMenuInput = {
    where: BinKitchenOrderItemScalarWhereInput
    data: XOR<BinKitchenOrderItemUpdateManyMutationInput, BinKitchenOrderItemUncheckedUpdateManyWithoutItemsInput>
  }

  export type BinKitchenOrderItemScalarWhereInput = {
    AND?: Enumerable<BinKitchenOrderItemScalarWhereInput>
    OR?: Enumerable<BinKitchenOrderItemScalarWhereInput>
    NOT?: Enumerable<BinKitchenOrderItemScalarWhereInput>
    id?: IntFilter | number
    quantity?: IntFilter | number
    totalPrice?: FloatFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    menuId?: IntFilter | number
    orderId?: IntFilter | number
  }

  export type BinKitchenOrderItemCreateWithoutOrderInput = {
    menu: BinKitchenMenuCreateNestedOneWithoutItemsInput
    quantity: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinKitchenOrderItemUncheckedCreateWithoutOrderInput = {
    id?: number
    quantity: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
    menuId: number
  }

  export type BinKitchenOrderItemCreateOrConnectWithoutOrderInput = {
    where: BinKitchenOrderItemWhereUniqueInput
    create: XOR<BinKitchenOrderItemCreateWithoutOrderInput, BinKitchenOrderItemUncheckedCreateWithoutOrderInput>
  }

  export type BinKitchenOrderItemCreateManyOrderInputEnvelope = {
    data: Enumerable<BinKitchenOrderItemCreateManyOrderInput>
    skipDuplicates?: boolean
  }

  export type BinKitchenOrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: BinKitchenOrderItemWhereUniqueInput
    update: XOR<BinKitchenOrderItemUpdateWithoutOrderInput, BinKitchenOrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<BinKitchenOrderItemCreateWithoutOrderInput, BinKitchenOrderItemUncheckedCreateWithoutOrderInput>
  }

  export type BinKitchenOrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: BinKitchenOrderItemWhereUniqueInput
    data: XOR<BinKitchenOrderItemUpdateWithoutOrderInput, BinKitchenOrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type BinKitchenOrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: BinKitchenOrderItemScalarWhereInput
    data: XOR<BinKitchenOrderItemUpdateManyMutationInput, BinKitchenOrderItemUncheckedUpdateManyWithoutItemsInput>
  }

  export type BinKitchenMenuCreateWithoutItemsInput = {
    name: string
    image: string
    price: number
    category?: BinKitchenCategoryCreateNestedOneWithoutMenusInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinKitchenMenuUncheckedCreateWithoutItemsInput = {
    id?: number
    name: string
    image: string
    price: number
    categoryName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinKitchenMenuCreateOrConnectWithoutItemsInput = {
    where: BinKitchenMenuWhereUniqueInput
    create: XOR<BinKitchenMenuCreateWithoutItemsInput, BinKitchenMenuUncheckedCreateWithoutItemsInput>
  }

  export type BinKitchenOrderCreateWithoutItemsInput = {
    tableId: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinKitchenOrderUncheckedCreateWithoutItemsInput = {
    id?: number
    tableId: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinKitchenOrderCreateOrConnectWithoutItemsInput = {
    where: BinKitchenOrderWhereUniqueInput
    create: XOR<BinKitchenOrderCreateWithoutItemsInput, BinKitchenOrderUncheckedCreateWithoutItemsInput>
  }

  export type BinKitchenMenuUpsertWithoutItemsInput = {
    update: XOR<BinKitchenMenuUpdateWithoutItemsInput, BinKitchenMenuUncheckedUpdateWithoutItemsInput>
    create: XOR<BinKitchenMenuCreateWithoutItemsInput, BinKitchenMenuUncheckedCreateWithoutItemsInput>
  }

  export type BinKitchenMenuUpdateWithoutItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    category?: BinKitchenCategoryUpdateOneWithoutMenusNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinKitchenMenuUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    categoryName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinKitchenOrderUpsertWithoutItemsInput = {
    update: XOR<BinKitchenOrderUpdateWithoutItemsInput, BinKitchenOrderUncheckedUpdateWithoutItemsInput>
    create: XOR<BinKitchenOrderCreateWithoutItemsInput, BinKitchenOrderUncheckedCreateWithoutItemsInput>
  }

  export type BinKitchenOrderUpdateWithoutItemsInput = {
    tableId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinKitchenOrderUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tableId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryWashingMachineCreateWithoutBranchInput = {
    brand: string
    variant: string
    size: number
    machineType: string
    yearManufactured: number
    insuranceExpiryYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryWashingMachinesToPrograms?: LaundryWashingMachineToProgramCreateNestedManyWithoutMachineInput
    laundryMaintainances?: LaundryMaintainanceCreateNestedManyWithoutMachineInput
    laundryUserHistories?: LaundryUserHistoryCreateNestedManyWithoutMachineInput
  }

  export type LaundryWashingMachineUncheckedCreateWithoutBranchInput = {
    id?: number
    brand: string
    variant: string
    size: number
    machineType: string
    yearManufactured: number
    insuranceExpiryYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryWashingMachinesToPrograms?: LaundryWashingMachineToProgramUncheckedCreateNestedManyWithoutMachineInput
    laundryMaintainances?: LaundryMaintainanceUncheckedCreateNestedManyWithoutMachineInput
    laundryUserHistories?: LaundryUserHistoryUncheckedCreateNestedManyWithoutMachineInput
  }

  export type LaundryWashingMachineCreateOrConnectWithoutBranchInput = {
    where: LaundryWashingMachineWhereUniqueInput
    create: XOR<LaundryWashingMachineCreateWithoutBranchInput, LaundryWashingMachineUncheckedCreateWithoutBranchInput>
  }

  export type LaundryWashingMachineCreateManyBranchInputEnvelope = {
    data: Enumerable<LaundryWashingMachineCreateManyBranchInput>
    skipDuplicates?: boolean
  }

  export type LaundryWashingMachineUpsertWithWhereUniqueWithoutBranchInput = {
    where: LaundryWashingMachineWhereUniqueInput
    update: XOR<LaundryWashingMachineUpdateWithoutBranchInput, LaundryWashingMachineUncheckedUpdateWithoutBranchInput>
    create: XOR<LaundryWashingMachineCreateWithoutBranchInput, LaundryWashingMachineUncheckedCreateWithoutBranchInput>
  }

  export type LaundryWashingMachineUpdateWithWhereUniqueWithoutBranchInput = {
    where: LaundryWashingMachineWhereUniqueInput
    data: XOR<LaundryWashingMachineUpdateWithoutBranchInput, LaundryWashingMachineUncheckedUpdateWithoutBranchInput>
  }

  export type LaundryWashingMachineUpdateManyWithWhereWithoutBranchInput = {
    where: LaundryWashingMachineScalarWhereInput
    data: XOR<LaundryWashingMachineUpdateManyMutationInput, LaundryWashingMachineUncheckedUpdateManyWithoutLaundryWashingMachinesInput>
  }

  export type LaundryWashingMachineScalarWhereInput = {
    AND?: Enumerable<LaundryWashingMachineScalarWhereInput>
    OR?: Enumerable<LaundryWashingMachineScalarWhereInput>
    NOT?: Enumerable<LaundryWashingMachineScalarWhereInput>
    id?: IntFilter | number
    brand?: StringFilter | string
    variant?: StringFilter | string
    size?: IntFilter | number
    machineType?: StringFilter | string
    yearManufactured?: IntFilter | number
    insuranceExpiryYear?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    laundryBranchId?: IntFilter | number
  }

  export type LaundryBranchCreateWithoutLaundryWashingMachinesInput = {
    name: string
    machineAmount: number
    owner: string
    tel: number
    location: string
    areaSize: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryBranchUncheckedCreateWithoutLaundryWashingMachinesInput = {
    id?: number
    name: string
    machineAmount: number
    owner: string
    tel: number
    location: string
    areaSize: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryBranchCreateOrConnectWithoutLaundryWashingMachinesInput = {
    where: LaundryBranchWhereUniqueInput
    create: XOR<LaundryBranchCreateWithoutLaundryWashingMachinesInput, LaundryBranchUncheckedCreateWithoutLaundryWashingMachinesInput>
  }

  export type LaundryWashingMachineToProgramCreateWithoutMachineInput = {
    program: LaundryProgramCreateNestedOneWithoutLaundryWashingMachinesToProgramsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryWashingMachineToProgramUncheckedCreateWithoutMachineInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryProgramId: number
  }

  export type LaundryWashingMachineToProgramCreateOrConnectWithoutMachineInput = {
    where: LaundryWashingMachineToProgramWhereUniqueInput
    create: XOR<LaundryWashingMachineToProgramCreateWithoutMachineInput, LaundryWashingMachineToProgramUncheckedCreateWithoutMachineInput>
  }

  export type LaundryWashingMachineToProgramCreateManyMachineInputEnvelope = {
    data: Enumerable<LaundryWashingMachineToProgramCreateManyMachineInput>
    skipDuplicates?: boolean
  }

  export type LaundryMaintainanceCreateWithoutMachineInput = {
    round: number
    date: number
    damageLevel: number
    description: string
    technicianName: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryMaintainanceUncheckedCreateWithoutMachineInput = {
    id?: number
    round: number
    date: number
    damageLevel: number
    description: string
    technicianName: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryMaintainanceCreateOrConnectWithoutMachineInput = {
    where: LaundryMaintainanceWhereUniqueInput
    create: XOR<LaundryMaintainanceCreateWithoutMachineInput, LaundryMaintainanceUncheckedCreateWithoutMachineInput>
  }

  export type LaundryMaintainanceCreateManyMachineInputEnvelope = {
    data: Enumerable<LaundryMaintainanceCreateManyMachineInput>
    skipDuplicates?: boolean
  }

  export type LaundryUserHistoryCreateWithoutMachineInput = {
    user: LaundryUserCreateNestedOneWithoutLaundryUserHistoriesInput
    washNumber: number
    program: LaundryProgramCreateNestedOneWithoutLaundryUserHistoriesInput
    date: number
    duration: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryUserHistoryUncheckedCreateWithoutMachineInput = {
    id?: number
    washNumber: number
    date: number
    duration: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryUserId: number
    laundryProgramId: number
  }

  export type LaundryUserHistoryCreateOrConnectWithoutMachineInput = {
    where: LaundryUserHistoryWhereUniqueInput
    create: XOR<LaundryUserHistoryCreateWithoutMachineInput, LaundryUserHistoryUncheckedCreateWithoutMachineInput>
  }

  export type LaundryUserHistoryCreateManyMachineInputEnvelope = {
    data: Enumerable<LaundryUserHistoryCreateManyMachineInput>
    skipDuplicates?: boolean
  }

  export type LaundryBranchUpsertWithoutLaundryWashingMachinesInput = {
    update: XOR<LaundryBranchUpdateWithoutLaundryWashingMachinesInput, LaundryBranchUncheckedUpdateWithoutLaundryWashingMachinesInput>
    create: XOR<LaundryBranchCreateWithoutLaundryWashingMachinesInput, LaundryBranchUncheckedCreateWithoutLaundryWashingMachinesInput>
  }

  export type LaundryBranchUpdateWithoutLaundryWashingMachinesInput = {
    name?: StringFieldUpdateOperationsInput | string
    machineAmount?: IntFieldUpdateOperationsInput | number
    owner?: StringFieldUpdateOperationsInput | string
    tel?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    areaSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryBranchUncheckedUpdateWithoutLaundryWashingMachinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    machineAmount?: IntFieldUpdateOperationsInput | number
    owner?: StringFieldUpdateOperationsInput | string
    tel?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    areaSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryWashingMachineToProgramUpsertWithWhereUniqueWithoutMachineInput = {
    where: LaundryWashingMachineToProgramWhereUniqueInput
    update: XOR<LaundryWashingMachineToProgramUpdateWithoutMachineInput, LaundryWashingMachineToProgramUncheckedUpdateWithoutMachineInput>
    create: XOR<LaundryWashingMachineToProgramCreateWithoutMachineInput, LaundryWashingMachineToProgramUncheckedCreateWithoutMachineInput>
  }

  export type LaundryWashingMachineToProgramUpdateWithWhereUniqueWithoutMachineInput = {
    where: LaundryWashingMachineToProgramWhereUniqueInput
    data: XOR<LaundryWashingMachineToProgramUpdateWithoutMachineInput, LaundryWashingMachineToProgramUncheckedUpdateWithoutMachineInput>
  }

  export type LaundryWashingMachineToProgramUpdateManyWithWhereWithoutMachineInput = {
    where: LaundryWashingMachineToProgramScalarWhereInput
    data: XOR<LaundryWashingMachineToProgramUpdateManyMutationInput, LaundryWashingMachineToProgramUncheckedUpdateManyWithoutLaundryWashingMachinesToProgramsInput>
  }

  export type LaundryWashingMachineToProgramScalarWhereInput = {
    AND?: Enumerable<LaundryWashingMachineToProgramScalarWhereInput>
    OR?: Enumerable<LaundryWashingMachineToProgramScalarWhereInput>
    NOT?: Enumerable<LaundryWashingMachineToProgramScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    laundryWashingMachineId?: IntFilter | number
    laundryProgramId?: IntFilter | number
  }

  export type LaundryMaintainanceUpsertWithWhereUniqueWithoutMachineInput = {
    where: LaundryMaintainanceWhereUniqueInput
    update: XOR<LaundryMaintainanceUpdateWithoutMachineInput, LaundryMaintainanceUncheckedUpdateWithoutMachineInput>
    create: XOR<LaundryMaintainanceCreateWithoutMachineInput, LaundryMaintainanceUncheckedCreateWithoutMachineInput>
  }

  export type LaundryMaintainanceUpdateWithWhereUniqueWithoutMachineInput = {
    where: LaundryMaintainanceWhereUniqueInput
    data: XOR<LaundryMaintainanceUpdateWithoutMachineInput, LaundryMaintainanceUncheckedUpdateWithoutMachineInput>
  }

  export type LaundryMaintainanceUpdateManyWithWhereWithoutMachineInput = {
    where: LaundryMaintainanceScalarWhereInput
    data: XOR<LaundryMaintainanceUpdateManyMutationInput, LaundryMaintainanceUncheckedUpdateManyWithoutLaundryMaintainancesInput>
  }

  export type LaundryMaintainanceScalarWhereInput = {
    AND?: Enumerable<LaundryMaintainanceScalarWhereInput>
    OR?: Enumerable<LaundryMaintainanceScalarWhereInput>
    NOT?: Enumerable<LaundryMaintainanceScalarWhereInput>
    id?: IntFilter | number
    round?: IntFilter | number
    date?: IntFilter | number
    damageLevel?: IntFilter | number
    description?: StringFilter | string
    technicianName?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    laundryWashingMachineId?: IntFilter | number
  }

  export type LaundryUserHistoryUpsertWithWhereUniqueWithoutMachineInput = {
    where: LaundryUserHistoryWhereUniqueInput
    update: XOR<LaundryUserHistoryUpdateWithoutMachineInput, LaundryUserHistoryUncheckedUpdateWithoutMachineInput>
    create: XOR<LaundryUserHistoryCreateWithoutMachineInput, LaundryUserHistoryUncheckedCreateWithoutMachineInput>
  }

  export type LaundryUserHistoryUpdateWithWhereUniqueWithoutMachineInput = {
    where: LaundryUserHistoryWhereUniqueInput
    data: XOR<LaundryUserHistoryUpdateWithoutMachineInput, LaundryUserHistoryUncheckedUpdateWithoutMachineInput>
  }

  export type LaundryUserHistoryUpdateManyWithWhereWithoutMachineInput = {
    where: LaundryUserHistoryScalarWhereInput
    data: XOR<LaundryUserHistoryUpdateManyMutationInput, LaundryUserHistoryUncheckedUpdateManyWithoutLaundryUserHistoriesInput>
  }

  export type LaundryUserHistoryScalarWhereInput = {
    AND?: Enumerable<LaundryUserHistoryScalarWhereInput>
    OR?: Enumerable<LaundryUserHistoryScalarWhereInput>
    NOT?: Enumerable<LaundryUserHistoryScalarWhereInput>
    id?: IntFilter | number
    washNumber?: IntFilter | number
    date?: IntFilter | number
    duration?: IntFilter | number
    price?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    laundryUserId?: IntFilter | number
    laundryWashingMachineId?: IntFilter | number
    laundryProgramId?: IntFilter | number
  }

  export type LaundryWashingMachineToProgramCreateWithoutProgramInput = {
    machine: LaundryWashingMachineCreateNestedOneWithoutLaundryWashingMachinesToProgramsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryWashingMachineToProgramUncheckedCreateWithoutProgramInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryWashingMachineId: number
  }

  export type LaundryWashingMachineToProgramCreateOrConnectWithoutProgramInput = {
    where: LaundryWashingMachineToProgramWhereUniqueInput
    create: XOR<LaundryWashingMachineToProgramCreateWithoutProgramInput, LaundryWashingMachineToProgramUncheckedCreateWithoutProgramInput>
  }

  export type LaundryWashingMachineToProgramCreateManyProgramInputEnvelope = {
    data: Enumerable<LaundryWashingMachineToProgramCreateManyProgramInput>
    skipDuplicates?: boolean
  }

  export type LaundryUserHistoryCreateWithoutProgramInput = {
    user: LaundryUserCreateNestedOneWithoutLaundryUserHistoriesInput
    washNumber: number
    machine: LaundryWashingMachineCreateNestedOneWithoutLaundryUserHistoriesInput
    date: number
    duration: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryUserHistoryUncheckedCreateWithoutProgramInput = {
    id?: number
    washNumber: number
    date: number
    duration: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryUserId: number
    laundryWashingMachineId: number
  }

  export type LaundryUserHistoryCreateOrConnectWithoutProgramInput = {
    where: LaundryUserHistoryWhereUniqueInput
    create: XOR<LaundryUserHistoryCreateWithoutProgramInput, LaundryUserHistoryUncheckedCreateWithoutProgramInput>
  }

  export type LaundryUserHistoryCreateManyProgramInputEnvelope = {
    data: Enumerable<LaundryUserHistoryCreateManyProgramInput>
    skipDuplicates?: boolean
  }

  export type LaundryWashingMachineToProgramUpsertWithWhereUniqueWithoutProgramInput = {
    where: LaundryWashingMachineToProgramWhereUniqueInput
    update: XOR<LaundryWashingMachineToProgramUpdateWithoutProgramInput, LaundryWashingMachineToProgramUncheckedUpdateWithoutProgramInput>
    create: XOR<LaundryWashingMachineToProgramCreateWithoutProgramInput, LaundryWashingMachineToProgramUncheckedCreateWithoutProgramInput>
  }

  export type LaundryWashingMachineToProgramUpdateWithWhereUniqueWithoutProgramInput = {
    where: LaundryWashingMachineToProgramWhereUniqueInput
    data: XOR<LaundryWashingMachineToProgramUpdateWithoutProgramInput, LaundryWashingMachineToProgramUncheckedUpdateWithoutProgramInput>
  }

  export type LaundryWashingMachineToProgramUpdateManyWithWhereWithoutProgramInput = {
    where: LaundryWashingMachineToProgramScalarWhereInput
    data: XOR<LaundryWashingMachineToProgramUpdateManyMutationInput, LaundryWashingMachineToProgramUncheckedUpdateManyWithoutLaundryWashingMachinesToProgramsInput>
  }

  export type LaundryUserHistoryUpsertWithWhereUniqueWithoutProgramInput = {
    where: LaundryUserHistoryWhereUniqueInput
    update: XOR<LaundryUserHistoryUpdateWithoutProgramInput, LaundryUserHistoryUncheckedUpdateWithoutProgramInput>
    create: XOR<LaundryUserHistoryCreateWithoutProgramInput, LaundryUserHistoryUncheckedCreateWithoutProgramInput>
  }

  export type LaundryUserHistoryUpdateWithWhereUniqueWithoutProgramInput = {
    where: LaundryUserHistoryWhereUniqueInput
    data: XOR<LaundryUserHistoryUpdateWithoutProgramInput, LaundryUserHistoryUncheckedUpdateWithoutProgramInput>
  }

  export type LaundryUserHistoryUpdateManyWithWhereWithoutProgramInput = {
    where: LaundryUserHistoryScalarWhereInput
    data: XOR<LaundryUserHistoryUpdateManyMutationInput, LaundryUserHistoryUncheckedUpdateManyWithoutLaundryUserHistoriesInput>
  }

  export type LaundryWashingMachineCreateWithoutLaundryWashingMachinesToProgramsInput = {
    branch: LaundryBranchCreateNestedOneWithoutLaundryWashingMachinesInput
    brand: string
    variant: string
    size: number
    machineType: string
    yearManufactured: number
    insuranceExpiryYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryMaintainances?: LaundryMaintainanceCreateNestedManyWithoutMachineInput
    laundryUserHistories?: LaundryUserHistoryCreateNestedManyWithoutMachineInput
  }

  export type LaundryWashingMachineUncheckedCreateWithoutLaundryWashingMachinesToProgramsInput = {
    id?: number
    brand: string
    variant: string
    size: number
    machineType: string
    yearManufactured: number
    insuranceExpiryYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryBranchId: number
    laundryMaintainances?: LaundryMaintainanceUncheckedCreateNestedManyWithoutMachineInput
    laundryUserHistories?: LaundryUserHistoryUncheckedCreateNestedManyWithoutMachineInput
  }

  export type LaundryWashingMachineCreateOrConnectWithoutLaundryWashingMachinesToProgramsInput = {
    where: LaundryWashingMachineWhereUniqueInput
    create: XOR<LaundryWashingMachineCreateWithoutLaundryWashingMachinesToProgramsInput, LaundryWashingMachineUncheckedCreateWithoutLaundryWashingMachinesToProgramsInput>
  }

  export type LaundryProgramCreateWithoutLaundryWashingMachinesToProgramsInput = {
    name: string
    price: number
    duration: number
    weight: number
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryUserHistories?: LaundryUserHistoryCreateNestedManyWithoutProgramInput
  }

  export type LaundryProgramUncheckedCreateWithoutLaundryWashingMachinesToProgramsInput = {
    id?: number
    name: string
    price: number
    duration: number
    weight: number
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryUserHistories?: LaundryUserHistoryUncheckedCreateNestedManyWithoutProgramInput
  }

  export type LaundryProgramCreateOrConnectWithoutLaundryWashingMachinesToProgramsInput = {
    where: LaundryProgramWhereUniqueInput
    create: XOR<LaundryProgramCreateWithoutLaundryWashingMachinesToProgramsInput, LaundryProgramUncheckedCreateWithoutLaundryWashingMachinesToProgramsInput>
  }

  export type LaundryWashingMachineUpsertWithoutLaundryWashingMachinesToProgramsInput = {
    update: XOR<LaundryWashingMachineUpdateWithoutLaundryWashingMachinesToProgramsInput, LaundryWashingMachineUncheckedUpdateWithoutLaundryWashingMachinesToProgramsInput>
    create: XOR<LaundryWashingMachineCreateWithoutLaundryWashingMachinesToProgramsInput, LaundryWashingMachineUncheckedCreateWithoutLaundryWashingMachinesToProgramsInput>
  }

  export type LaundryWashingMachineUpdateWithoutLaundryWashingMachinesToProgramsInput = {
    branch?: LaundryBranchUpdateOneRequiredWithoutLaundryWashingMachinesNestedInput
    brand?: StringFieldUpdateOperationsInput | string
    variant?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    machineType?: StringFieldUpdateOperationsInput | string
    yearManufactured?: IntFieldUpdateOperationsInput | number
    insuranceExpiryYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryMaintainances?: LaundryMaintainanceUpdateManyWithoutMachineNestedInput
    laundryUserHistories?: LaundryUserHistoryUpdateManyWithoutMachineNestedInput
  }

  export type LaundryWashingMachineUncheckedUpdateWithoutLaundryWashingMachinesToProgramsInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand?: StringFieldUpdateOperationsInput | string
    variant?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    machineType?: StringFieldUpdateOperationsInput | string
    yearManufactured?: IntFieldUpdateOperationsInput | number
    insuranceExpiryYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryBranchId?: IntFieldUpdateOperationsInput | number
    laundryMaintainances?: LaundryMaintainanceUncheckedUpdateManyWithoutMachineNestedInput
    laundryUserHistories?: LaundryUserHistoryUncheckedUpdateManyWithoutMachineNestedInput
  }

  export type LaundryProgramUpsertWithoutLaundryWashingMachinesToProgramsInput = {
    update: XOR<LaundryProgramUpdateWithoutLaundryWashingMachinesToProgramsInput, LaundryProgramUncheckedUpdateWithoutLaundryWashingMachinesToProgramsInput>
    create: XOR<LaundryProgramCreateWithoutLaundryWashingMachinesToProgramsInput, LaundryProgramUncheckedCreateWithoutLaundryWashingMachinesToProgramsInput>
  }

  export type LaundryProgramUpdateWithoutLaundryWashingMachinesToProgramsInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    weight?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryUserHistories?: LaundryUserHistoryUpdateManyWithoutProgramNestedInput
  }

  export type LaundryProgramUncheckedUpdateWithoutLaundryWashingMachinesToProgramsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    weight?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryUserHistories?: LaundryUserHistoryUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type LaundryWashingMachineCreateWithoutLaundryMaintainancesInput = {
    branch: LaundryBranchCreateNestedOneWithoutLaundryWashingMachinesInput
    brand: string
    variant: string
    size: number
    machineType: string
    yearManufactured: number
    insuranceExpiryYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryWashingMachinesToPrograms?: LaundryWashingMachineToProgramCreateNestedManyWithoutMachineInput
    laundryUserHistories?: LaundryUserHistoryCreateNestedManyWithoutMachineInput
  }

  export type LaundryWashingMachineUncheckedCreateWithoutLaundryMaintainancesInput = {
    id?: number
    brand: string
    variant: string
    size: number
    machineType: string
    yearManufactured: number
    insuranceExpiryYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryBranchId: number
    laundryWashingMachinesToPrograms?: LaundryWashingMachineToProgramUncheckedCreateNestedManyWithoutMachineInput
    laundryUserHistories?: LaundryUserHistoryUncheckedCreateNestedManyWithoutMachineInput
  }

  export type LaundryWashingMachineCreateOrConnectWithoutLaundryMaintainancesInput = {
    where: LaundryWashingMachineWhereUniqueInput
    create: XOR<LaundryWashingMachineCreateWithoutLaundryMaintainancesInput, LaundryWashingMachineUncheckedCreateWithoutLaundryMaintainancesInput>
  }

  export type LaundryWashingMachineUpsertWithoutLaundryMaintainancesInput = {
    update: XOR<LaundryWashingMachineUpdateWithoutLaundryMaintainancesInput, LaundryWashingMachineUncheckedUpdateWithoutLaundryMaintainancesInput>
    create: XOR<LaundryWashingMachineCreateWithoutLaundryMaintainancesInput, LaundryWashingMachineUncheckedCreateWithoutLaundryMaintainancesInput>
  }

  export type LaundryWashingMachineUpdateWithoutLaundryMaintainancesInput = {
    branch?: LaundryBranchUpdateOneRequiredWithoutLaundryWashingMachinesNestedInput
    brand?: StringFieldUpdateOperationsInput | string
    variant?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    machineType?: StringFieldUpdateOperationsInput | string
    yearManufactured?: IntFieldUpdateOperationsInput | number
    insuranceExpiryYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryWashingMachinesToPrograms?: LaundryWashingMachineToProgramUpdateManyWithoutMachineNestedInput
    laundryUserHistories?: LaundryUserHistoryUpdateManyWithoutMachineNestedInput
  }

  export type LaundryWashingMachineUncheckedUpdateWithoutLaundryMaintainancesInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand?: StringFieldUpdateOperationsInput | string
    variant?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    machineType?: StringFieldUpdateOperationsInput | string
    yearManufactured?: IntFieldUpdateOperationsInput | number
    insuranceExpiryYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryBranchId?: IntFieldUpdateOperationsInput | number
    laundryWashingMachinesToPrograms?: LaundryWashingMachineToProgramUncheckedUpdateManyWithoutMachineNestedInput
    laundryUserHistories?: LaundryUserHistoryUncheckedUpdateManyWithoutMachineNestedInput
  }

  export type LaundryUserHistoryCreateWithoutUserInput = {
    washNumber: number
    machine: LaundryWashingMachineCreateNestedOneWithoutLaundryUserHistoriesInput
    program: LaundryProgramCreateNestedOneWithoutLaundryUserHistoriesInput
    date: number
    duration: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryUserHistoryUncheckedCreateWithoutUserInput = {
    id?: number
    washNumber: number
    date: number
    duration: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryWashingMachineId: number
    laundryProgramId: number
  }

  export type LaundryUserHistoryCreateOrConnectWithoutUserInput = {
    where: LaundryUserHistoryWhereUniqueInput
    create: XOR<LaundryUserHistoryCreateWithoutUserInput, LaundryUserHistoryUncheckedCreateWithoutUserInput>
  }

  export type LaundryUserHistoryCreateManyUserInputEnvelope = {
    data: Enumerable<LaundryUserHistoryCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type LaundryBalanceTopupCreateWithoutUserInput = {
    topUpRound: number
    topUpAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryBalanceTopupUncheckedCreateWithoutUserInput = {
    id?: number
    topUpRound: number
    topUpAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryBalanceTopupCreateOrConnectWithoutUserInput = {
    where: LaundryBalanceTopupWhereUniqueInput
    create: XOR<LaundryBalanceTopupCreateWithoutUserInput, LaundryBalanceTopupUncheckedCreateWithoutUserInput>
  }

  export type LaundryBalanceTopupCreateManyUserInputEnvelope = {
    data: Enumerable<LaundryBalanceTopupCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type LaundryUserHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: LaundryUserHistoryWhereUniqueInput
    update: XOR<LaundryUserHistoryUpdateWithoutUserInput, LaundryUserHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<LaundryUserHistoryCreateWithoutUserInput, LaundryUserHistoryUncheckedCreateWithoutUserInput>
  }

  export type LaundryUserHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: LaundryUserHistoryWhereUniqueInput
    data: XOR<LaundryUserHistoryUpdateWithoutUserInput, LaundryUserHistoryUncheckedUpdateWithoutUserInput>
  }

  export type LaundryUserHistoryUpdateManyWithWhereWithoutUserInput = {
    where: LaundryUserHistoryScalarWhereInput
    data: XOR<LaundryUserHistoryUpdateManyMutationInput, LaundryUserHistoryUncheckedUpdateManyWithoutLaundryUserHistoriesInput>
  }

  export type LaundryBalanceTopupUpsertWithWhereUniqueWithoutUserInput = {
    where: LaundryBalanceTopupWhereUniqueInput
    update: XOR<LaundryBalanceTopupUpdateWithoutUserInput, LaundryBalanceTopupUncheckedUpdateWithoutUserInput>
    create: XOR<LaundryBalanceTopupCreateWithoutUserInput, LaundryBalanceTopupUncheckedCreateWithoutUserInput>
  }

  export type LaundryBalanceTopupUpdateWithWhereUniqueWithoutUserInput = {
    where: LaundryBalanceTopupWhereUniqueInput
    data: XOR<LaundryBalanceTopupUpdateWithoutUserInput, LaundryBalanceTopupUncheckedUpdateWithoutUserInput>
  }

  export type LaundryBalanceTopupUpdateManyWithWhereWithoutUserInput = {
    where: LaundryBalanceTopupScalarWhereInput
    data: XOR<LaundryBalanceTopupUpdateManyMutationInput, LaundryBalanceTopupUncheckedUpdateManyWithoutLaundryBalanceTopupsInput>
  }

  export type LaundryBalanceTopupScalarWhereInput = {
    AND?: Enumerable<LaundryBalanceTopupScalarWhereInput>
    OR?: Enumerable<LaundryBalanceTopupScalarWhereInput>
    NOT?: Enumerable<LaundryBalanceTopupScalarWhereInput>
    id?: IntFilter | number
    topUpRound?: IntFilter | number
    topUpAmount?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    laundryUserId?: IntFilter | number
  }

  export type LaundryUserCreateWithoutLaundryUserHistoriesInput = {
    name: string
    tel: number
    balance: number
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryBalanceTopups?: LaundryBalanceTopupCreateNestedManyWithoutUserInput
  }

  export type LaundryUserUncheckedCreateWithoutLaundryUserHistoriesInput = {
    id?: number
    name: string
    tel: number
    balance: number
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryBalanceTopups?: LaundryBalanceTopupUncheckedCreateNestedManyWithoutUserInput
  }

  export type LaundryUserCreateOrConnectWithoutLaundryUserHistoriesInput = {
    where: LaundryUserWhereUniqueInput
    create: XOR<LaundryUserCreateWithoutLaundryUserHistoriesInput, LaundryUserUncheckedCreateWithoutLaundryUserHistoriesInput>
  }

  export type LaundryWashingMachineCreateWithoutLaundryUserHistoriesInput = {
    branch: LaundryBranchCreateNestedOneWithoutLaundryWashingMachinesInput
    brand: string
    variant: string
    size: number
    machineType: string
    yearManufactured: number
    insuranceExpiryYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryWashingMachinesToPrograms?: LaundryWashingMachineToProgramCreateNestedManyWithoutMachineInput
    laundryMaintainances?: LaundryMaintainanceCreateNestedManyWithoutMachineInput
  }

  export type LaundryWashingMachineUncheckedCreateWithoutLaundryUserHistoriesInput = {
    id?: number
    brand: string
    variant: string
    size: number
    machineType: string
    yearManufactured: number
    insuranceExpiryYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryBranchId: number
    laundryWashingMachinesToPrograms?: LaundryWashingMachineToProgramUncheckedCreateNestedManyWithoutMachineInput
    laundryMaintainances?: LaundryMaintainanceUncheckedCreateNestedManyWithoutMachineInput
  }

  export type LaundryWashingMachineCreateOrConnectWithoutLaundryUserHistoriesInput = {
    where: LaundryWashingMachineWhereUniqueInput
    create: XOR<LaundryWashingMachineCreateWithoutLaundryUserHistoriesInput, LaundryWashingMachineUncheckedCreateWithoutLaundryUserHistoriesInput>
  }

  export type LaundryProgramCreateWithoutLaundryUserHistoriesInput = {
    name: string
    price: number
    duration: number
    weight: number
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryWashingMachinesToPrograms?: LaundryWashingMachineToProgramCreateNestedManyWithoutProgramInput
  }

  export type LaundryProgramUncheckedCreateWithoutLaundryUserHistoriesInput = {
    id?: number
    name: string
    price: number
    duration: number
    weight: number
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryWashingMachinesToPrograms?: LaundryWashingMachineToProgramUncheckedCreateNestedManyWithoutProgramInput
  }

  export type LaundryProgramCreateOrConnectWithoutLaundryUserHistoriesInput = {
    where: LaundryProgramWhereUniqueInput
    create: XOR<LaundryProgramCreateWithoutLaundryUserHistoriesInput, LaundryProgramUncheckedCreateWithoutLaundryUserHistoriesInput>
  }

  export type LaundryUserUpsertWithoutLaundryUserHistoriesInput = {
    update: XOR<LaundryUserUpdateWithoutLaundryUserHistoriesInput, LaundryUserUncheckedUpdateWithoutLaundryUserHistoriesInput>
    create: XOR<LaundryUserCreateWithoutLaundryUserHistoriesInput, LaundryUserUncheckedCreateWithoutLaundryUserHistoriesInput>
  }

  export type LaundryUserUpdateWithoutLaundryUserHistoriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    tel?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryBalanceTopups?: LaundryBalanceTopupUpdateManyWithoutUserNestedInput
  }

  export type LaundryUserUncheckedUpdateWithoutLaundryUserHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tel?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryBalanceTopups?: LaundryBalanceTopupUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LaundryWashingMachineUpsertWithoutLaundryUserHistoriesInput = {
    update: XOR<LaundryWashingMachineUpdateWithoutLaundryUserHistoriesInput, LaundryWashingMachineUncheckedUpdateWithoutLaundryUserHistoriesInput>
    create: XOR<LaundryWashingMachineCreateWithoutLaundryUserHistoriesInput, LaundryWashingMachineUncheckedCreateWithoutLaundryUserHistoriesInput>
  }

  export type LaundryWashingMachineUpdateWithoutLaundryUserHistoriesInput = {
    branch?: LaundryBranchUpdateOneRequiredWithoutLaundryWashingMachinesNestedInput
    brand?: StringFieldUpdateOperationsInput | string
    variant?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    machineType?: StringFieldUpdateOperationsInput | string
    yearManufactured?: IntFieldUpdateOperationsInput | number
    insuranceExpiryYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryWashingMachinesToPrograms?: LaundryWashingMachineToProgramUpdateManyWithoutMachineNestedInput
    laundryMaintainances?: LaundryMaintainanceUpdateManyWithoutMachineNestedInput
  }

  export type LaundryWashingMachineUncheckedUpdateWithoutLaundryUserHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand?: StringFieldUpdateOperationsInput | string
    variant?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    machineType?: StringFieldUpdateOperationsInput | string
    yearManufactured?: IntFieldUpdateOperationsInput | number
    insuranceExpiryYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryBranchId?: IntFieldUpdateOperationsInput | number
    laundryWashingMachinesToPrograms?: LaundryWashingMachineToProgramUncheckedUpdateManyWithoutMachineNestedInput
    laundryMaintainances?: LaundryMaintainanceUncheckedUpdateManyWithoutMachineNestedInput
  }

  export type LaundryProgramUpsertWithoutLaundryUserHistoriesInput = {
    update: XOR<LaundryProgramUpdateWithoutLaundryUserHistoriesInput, LaundryProgramUncheckedUpdateWithoutLaundryUserHistoriesInput>
    create: XOR<LaundryProgramCreateWithoutLaundryUserHistoriesInput, LaundryProgramUncheckedCreateWithoutLaundryUserHistoriesInput>
  }

  export type LaundryProgramUpdateWithoutLaundryUserHistoriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    weight?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryWashingMachinesToPrograms?: LaundryWashingMachineToProgramUpdateManyWithoutProgramNestedInput
  }

  export type LaundryProgramUncheckedUpdateWithoutLaundryUserHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    weight?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryWashingMachinesToPrograms?: LaundryWashingMachineToProgramUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type LaundryUserCreateWithoutLaundryBalanceTopupsInput = {
    name: string
    tel: number
    balance: number
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryUserHistories?: LaundryUserHistoryCreateNestedManyWithoutUserInput
  }

  export type LaundryUserUncheckedCreateWithoutLaundryBalanceTopupsInput = {
    id?: number
    name: string
    tel: number
    balance: number
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryUserHistories?: LaundryUserHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type LaundryUserCreateOrConnectWithoutLaundryBalanceTopupsInput = {
    where: LaundryUserWhereUniqueInput
    create: XOR<LaundryUserCreateWithoutLaundryBalanceTopupsInput, LaundryUserUncheckedCreateWithoutLaundryBalanceTopupsInput>
  }

  export type LaundryUserUpsertWithoutLaundryBalanceTopupsInput = {
    update: XOR<LaundryUserUpdateWithoutLaundryBalanceTopupsInput, LaundryUserUncheckedUpdateWithoutLaundryBalanceTopupsInput>
    create: XOR<LaundryUserCreateWithoutLaundryBalanceTopupsInput, LaundryUserUncheckedCreateWithoutLaundryBalanceTopupsInput>
  }

  export type LaundryUserUpdateWithoutLaundryBalanceTopupsInput = {
    name?: StringFieldUpdateOperationsInput | string
    tel?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryUserHistories?: LaundryUserHistoryUpdateManyWithoutUserNestedInput
  }

  export type LaundryUserUncheckedUpdateWithoutLaundryBalanceTopupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tel?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryUserHistories?: LaundryUserHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LibraryCategoryToBookCreateWithoutCategoryInput = {
    book: LibraryBookCreateNestedOneWithoutLibraryCategoriesToBooksInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryCategoryToBookUncheckedCreateWithoutCategoryInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryBookId: number
  }

  export type LibraryCategoryToBookCreateOrConnectWithoutCategoryInput = {
    where: LibraryCategoryToBookWhereUniqueInput
    create: XOR<LibraryCategoryToBookCreateWithoutCategoryInput, LibraryCategoryToBookUncheckedCreateWithoutCategoryInput>
  }

  export type LibraryCategoryToBookCreateManyCategoryInputEnvelope = {
    data: Enumerable<LibraryCategoryToBookCreateManyCategoryInput>
    skipDuplicates?: boolean
  }

  export type LibraryCategoryToBookUpsertWithWhereUniqueWithoutCategoryInput = {
    where: LibraryCategoryToBookWhereUniqueInput
    update: XOR<LibraryCategoryToBookUpdateWithoutCategoryInput, LibraryCategoryToBookUncheckedUpdateWithoutCategoryInput>
    create: XOR<LibraryCategoryToBookCreateWithoutCategoryInput, LibraryCategoryToBookUncheckedCreateWithoutCategoryInput>
  }

  export type LibraryCategoryToBookUpdateWithWhereUniqueWithoutCategoryInput = {
    where: LibraryCategoryToBookWhereUniqueInput
    data: XOR<LibraryCategoryToBookUpdateWithoutCategoryInput, LibraryCategoryToBookUncheckedUpdateWithoutCategoryInput>
  }

  export type LibraryCategoryToBookUpdateManyWithWhereWithoutCategoryInput = {
    where: LibraryCategoryToBookScalarWhereInput
    data: XOR<LibraryCategoryToBookUpdateManyMutationInput, LibraryCategoryToBookUncheckedUpdateManyWithoutLibraryCategoriesToBooksInput>
  }

  export type LibraryCategoryToBookScalarWhereInput = {
    AND?: Enumerable<LibraryCategoryToBookScalarWhereInput>
    OR?: Enumerable<LibraryCategoryToBookScalarWhereInput>
    NOT?: Enumerable<LibraryCategoryToBookScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    libraryBookCategoryId?: IntFilter | number
    libraryBookId?: IntFilter | number
  }

  export type LibraryCategoryToBookCreateWithoutBookInput = {
    category: LibraryBookCategoryCreateNestedOneWithoutLibraryCategoriesToBooksInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryCategoryToBookUncheckedCreateWithoutBookInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryBookCategoryId: number
  }

  export type LibraryCategoryToBookCreateOrConnectWithoutBookInput = {
    where: LibraryCategoryToBookWhereUniqueInput
    create: XOR<LibraryCategoryToBookCreateWithoutBookInput, LibraryCategoryToBookUncheckedCreateWithoutBookInput>
  }

  export type LibraryCategoryToBookCreateManyBookInputEnvelope = {
    data: Enumerable<LibraryCategoryToBookCreateManyBookInput>
    skipDuplicates?: boolean
  }

  export type LibraryBookToAuthorCreateWithoutBookInput = {
    author: LibraryBookAuthorCreateNestedOneWithoutLibraryBooksToAuthorsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBookToAuthorUncheckedCreateWithoutBookInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryBookAuthorId: number
  }

  export type LibraryBookToAuthorCreateOrConnectWithoutBookInput = {
    where: LibraryBookToAuthorWhereUniqueInput
    create: XOR<LibraryBookToAuthorCreateWithoutBookInput, LibraryBookToAuthorUncheckedCreateWithoutBookInput>
  }

  export type LibraryBookToAuthorCreateManyBookInputEnvelope = {
    data: Enumerable<LibraryBookToAuthorCreateManyBookInput>
    skipDuplicates?: boolean
  }

  export type LibraryBookCopyCreateWithoutBookInput = {
    status: string
    university: LibraryUniversityCreateNestedOneWithoutLibraryBookCopiesInput
    borrowedBy: LibraryStudentCreateNestedOneWithoutLibraryBookCopiesInput
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryBorrowingHistories?: LibraryBorrowingHistoryCreateNestedManyWithoutCopyInput
    libraryRequests?: LibraryRequestCreateNestedManyWithoutCopyInput
  }

  export type LibraryBookCopyUncheckedCreateWithoutBookInput = {
    id?: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryUniversityId: number
    libraryStudentId: number
    libraryBorrowingHistories?: LibraryBorrowingHistoryUncheckedCreateNestedManyWithoutCopyInput
    libraryRequests?: LibraryRequestUncheckedCreateNestedManyWithoutCopyInput
  }

  export type LibraryBookCopyCreateOrConnectWithoutBookInput = {
    where: LibraryBookCopyWhereUniqueInput
    create: XOR<LibraryBookCopyCreateWithoutBookInput, LibraryBookCopyUncheckedCreateWithoutBookInput>
  }

  export type LibraryBookCopyCreateManyBookInputEnvelope = {
    data: Enumerable<LibraryBookCopyCreateManyBookInput>
    skipDuplicates?: boolean
  }

  export type LibraryCategoryToBookUpsertWithWhereUniqueWithoutBookInput = {
    where: LibraryCategoryToBookWhereUniqueInput
    update: XOR<LibraryCategoryToBookUpdateWithoutBookInput, LibraryCategoryToBookUncheckedUpdateWithoutBookInput>
    create: XOR<LibraryCategoryToBookCreateWithoutBookInput, LibraryCategoryToBookUncheckedCreateWithoutBookInput>
  }

  export type LibraryCategoryToBookUpdateWithWhereUniqueWithoutBookInput = {
    where: LibraryCategoryToBookWhereUniqueInput
    data: XOR<LibraryCategoryToBookUpdateWithoutBookInput, LibraryCategoryToBookUncheckedUpdateWithoutBookInput>
  }

  export type LibraryCategoryToBookUpdateManyWithWhereWithoutBookInput = {
    where: LibraryCategoryToBookScalarWhereInput
    data: XOR<LibraryCategoryToBookUpdateManyMutationInput, LibraryCategoryToBookUncheckedUpdateManyWithoutLibraryCategoriesToBooksInput>
  }

  export type LibraryBookToAuthorUpsertWithWhereUniqueWithoutBookInput = {
    where: LibraryBookToAuthorWhereUniqueInput
    update: XOR<LibraryBookToAuthorUpdateWithoutBookInput, LibraryBookToAuthorUncheckedUpdateWithoutBookInput>
    create: XOR<LibraryBookToAuthorCreateWithoutBookInput, LibraryBookToAuthorUncheckedCreateWithoutBookInput>
  }

  export type LibraryBookToAuthorUpdateWithWhereUniqueWithoutBookInput = {
    where: LibraryBookToAuthorWhereUniqueInput
    data: XOR<LibraryBookToAuthorUpdateWithoutBookInput, LibraryBookToAuthorUncheckedUpdateWithoutBookInput>
  }

  export type LibraryBookToAuthorUpdateManyWithWhereWithoutBookInput = {
    where: LibraryBookToAuthorScalarWhereInput
    data: XOR<LibraryBookToAuthorUpdateManyMutationInput, LibraryBookToAuthorUncheckedUpdateManyWithoutLibraryBooksToAuthorsInput>
  }

  export type LibraryBookToAuthorScalarWhereInput = {
    AND?: Enumerable<LibraryBookToAuthorScalarWhereInput>
    OR?: Enumerable<LibraryBookToAuthorScalarWhereInput>
    NOT?: Enumerable<LibraryBookToAuthorScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    libraryBookId?: IntFilter | number
    libraryBookAuthorId?: IntFilter | number
  }

  export type LibraryBookCopyUpsertWithWhereUniqueWithoutBookInput = {
    where: LibraryBookCopyWhereUniqueInput
    update: XOR<LibraryBookCopyUpdateWithoutBookInput, LibraryBookCopyUncheckedUpdateWithoutBookInput>
    create: XOR<LibraryBookCopyCreateWithoutBookInput, LibraryBookCopyUncheckedCreateWithoutBookInput>
  }

  export type LibraryBookCopyUpdateWithWhereUniqueWithoutBookInput = {
    where: LibraryBookCopyWhereUniqueInput
    data: XOR<LibraryBookCopyUpdateWithoutBookInput, LibraryBookCopyUncheckedUpdateWithoutBookInput>
  }

  export type LibraryBookCopyUpdateManyWithWhereWithoutBookInput = {
    where: LibraryBookCopyScalarWhereInput
    data: XOR<LibraryBookCopyUpdateManyMutationInput, LibraryBookCopyUncheckedUpdateManyWithoutLibraryBookCopiesInput>
  }

  export type LibraryBookCopyScalarWhereInput = {
    AND?: Enumerable<LibraryBookCopyScalarWhereInput>
    OR?: Enumerable<LibraryBookCopyScalarWhereInput>
    NOT?: Enumerable<LibraryBookCopyScalarWhereInput>
    id?: IntFilter | number
    status?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    libraryBookId?: IntFilter | number
    libraryUniversityId?: IntFilter | number
    libraryStudentId?: IntFilter | number
  }

  export type LibraryBookCategoryCreateWithoutLibraryCategoriesToBooksInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBookCategoryUncheckedCreateWithoutLibraryCategoriesToBooksInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBookCategoryCreateOrConnectWithoutLibraryCategoriesToBooksInput = {
    where: LibraryBookCategoryWhereUniqueInput
    create: XOR<LibraryBookCategoryCreateWithoutLibraryCategoriesToBooksInput, LibraryBookCategoryUncheckedCreateWithoutLibraryCategoriesToBooksInput>
  }

  export type LibraryBookCreateWithoutLibraryCategoriesToBooksInput = {
    name: string
    ISBN: number
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryBooksToAuthors?: LibraryBookToAuthorCreateNestedManyWithoutBookInput
    libraryBookCopies?: LibraryBookCopyCreateNestedManyWithoutBookInput
  }

  export type LibraryBookUncheckedCreateWithoutLibraryCategoriesToBooksInput = {
    id?: number
    name: string
    ISBN: number
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryBooksToAuthors?: LibraryBookToAuthorUncheckedCreateNestedManyWithoutBookInput
    libraryBookCopies?: LibraryBookCopyUncheckedCreateNestedManyWithoutBookInput
  }

  export type LibraryBookCreateOrConnectWithoutLibraryCategoriesToBooksInput = {
    where: LibraryBookWhereUniqueInput
    create: XOR<LibraryBookCreateWithoutLibraryCategoriesToBooksInput, LibraryBookUncheckedCreateWithoutLibraryCategoriesToBooksInput>
  }

  export type LibraryBookCategoryUpsertWithoutLibraryCategoriesToBooksInput = {
    update: XOR<LibraryBookCategoryUpdateWithoutLibraryCategoriesToBooksInput, LibraryBookCategoryUncheckedUpdateWithoutLibraryCategoriesToBooksInput>
    create: XOR<LibraryBookCategoryCreateWithoutLibraryCategoriesToBooksInput, LibraryBookCategoryUncheckedCreateWithoutLibraryCategoriesToBooksInput>
  }

  export type LibraryBookCategoryUpdateWithoutLibraryCategoriesToBooksInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookCategoryUncheckedUpdateWithoutLibraryCategoriesToBooksInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookUpsertWithoutLibraryCategoriesToBooksInput = {
    update: XOR<LibraryBookUpdateWithoutLibraryCategoriesToBooksInput, LibraryBookUncheckedUpdateWithoutLibraryCategoriesToBooksInput>
    create: XOR<LibraryBookCreateWithoutLibraryCategoriesToBooksInput, LibraryBookUncheckedCreateWithoutLibraryCategoriesToBooksInput>
  }

  export type LibraryBookUpdateWithoutLibraryCategoriesToBooksInput = {
    name?: StringFieldUpdateOperationsInput | string
    ISBN?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryBooksToAuthors?: LibraryBookToAuthorUpdateManyWithoutBookNestedInput
    libraryBookCopies?: LibraryBookCopyUpdateManyWithoutBookNestedInput
  }

  export type LibraryBookUncheckedUpdateWithoutLibraryCategoriesToBooksInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    ISBN?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryBooksToAuthors?: LibraryBookToAuthorUncheckedUpdateManyWithoutBookNestedInput
    libraryBookCopies?: LibraryBookCopyUncheckedUpdateManyWithoutBookNestedInput
  }

  export type LibraryBookToAuthorCreateWithoutAuthorInput = {
    book: LibraryBookCreateNestedOneWithoutLibraryBooksToAuthorsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBookToAuthorUncheckedCreateWithoutAuthorInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryBookId: number
  }

  export type LibraryBookToAuthorCreateOrConnectWithoutAuthorInput = {
    where: LibraryBookToAuthorWhereUniqueInput
    create: XOR<LibraryBookToAuthorCreateWithoutAuthorInput, LibraryBookToAuthorUncheckedCreateWithoutAuthorInput>
  }

  export type LibraryBookToAuthorCreateManyAuthorInputEnvelope = {
    data: Enumerable<LibraryBookToAuthorCreateManyAuthorInput>
    skipDuplicates?: boolean
  }

  export type LibraryBookToAuthorUpsertWithWhereUniqueWithoutAuthorInput = {
    where: LibraryBookToAuthorWhereUniqueInput
    update: XOR<LibraryBookToAuthorUpdateWithoutAuthorInput, LibraryBookToAuthorUncheckedUpdateWithoutAuthorInput>
    create: XOR<LibraryBookToAuthorCreateWithoutAuthorInput, LibraryBookToAuthorUncheckedCreateWithoutAuthorInput>
  }

  export type LibraryBookToAuthorUpdateWithWhereUniqueWithoutAuthorInput = {
    where: LibraryBookToAuthorWhereUniqueInput
    data: XOR<LibraryBookToAuthorUpdateWithoutAuthorInput, LibraryBookToAuthorUncheckedUpdateWithoutAuthorInput>
  }

  export type LibraryBookToAuthorUpdateManyWithWhereWithoutAuthorInput = {
    where: LibraryBookToAuthorScalarWhereInput
    data: XOR<LibraryBookToAuthorUpdateManyMutationInput, LibraryBookToAuthorUncheckedUpdateManyWithoutLibraryBooksToAuthorsInput>
  }

  export type LibraryBookCreateWithoutLibraryBooksToAuthorsInput = {
    name: string
    ISBN: number
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryCategoriesToBooks?: LibraryCategoryToBookCreateNestedManyWithoutBookInput
    libraryBookCopies?: LibraryBookCopyCreateNestedManyWithoutBookInput
  }

  export type LibraryBookUncheckedCreateWithoutLibraryBooksToAuthorsInput = {
    id?: number
    name: string
    ISBN: number
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryCategoriesToBooks?: LibraryCategoryToBookUncheckedCreateNestedManyWithoutBookInput
    libraryBookCopies?: LibraryBookCopyUncheckedCreateNestedManyWithoutBookInput
  }

  export type LibraryBookCreateOrConnectWithoutLibraryBooksToAuthorsInput = {
    where: LibraryBookWhereUniqueInput
    create: XOR<LibraryBookCreateWithoutLibraryBooksToAuthorsInput, LibraryBookUncheckedCreateWithoutLibraryBooksToAuthorsInput>
  }

  export type LibraryBookAuthorCreateWithoutLibraryBooksToAuthorsInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBookAuthorUncheckedCreateWithoutLibraryBooksToAuthorsInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBookAuthorCreateOrConnectWithoutLibraryBooksToAuthorsInput = {
    where: LibraryBookAuthorWhereUniqueInput
    create: XOR<LibraryBookAuthorCreateWithoutLibraryBooksToAuthorsInput, LibraryBookAuthorUncheckedCreateWithoutLibraryBooksToAuthorsInput>
  }

  export type LibraryBookUpsertWithoutLibraryBooksToAuthorsInput = {
    update: XOR<LibraryBookUpdateWithoutLibraryBooksToAuthorsInput, LibraryBookUncheckedUpdateWithoutLibraryBooksToAuthorsInput>
    create: XOR<LibraryBookCreateWithoutLibraryBooksToAuthorsInput, LibraryBookUncheckedCreateWithoutLibraryBooksToAuthorsInput>
  }

  export type LibraryBookUpdateWithoutLibraryBooksToAuthorsInput = {
    name?: StringFieldUpdateOperationsInput | string
    ISBN?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryCategoriesToBooks?: LibraryCategoryToBookUpdateManyWithoutBookNestedInput
    libraryBookCopies?: LibraryBookCopyUpdateManyWithoutBookNestedInput
  }

  export type LibraryBookUncheckedUpdateWithoutLibraryBooksToAuthorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    ISBN?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryCategoriesToBooks?: LibraryCategoryToBookUncheckedUpdateManyWithoutBookNestedInput
    libraryBookCopies?: LibraryBookCopyUncheckedUpdateManyWithoutBookNestedInput
  }

  export type LibraryBookAuthorUpsertWithoutLibraryBooksToAuthorsInput = {
    update: XOR<LibraryBookAuthorUpdateWithoutLibraryBooksToAuthorsInput, LibraryBookAuthorUncheckedUpdateWithoutLibraryBooksToAuthorsInput>
    create: XOR<LibraryBookAuthorCreateWithoutLibraryBooksToAuthorsInput, LibraryBookAuthorUncheckedCreateWithoutLibraryBooksToAuthorsInput>
  }

  export type LibraryBookAuthorUpdateWithoutLibraryBooksToAuthorsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookAuthorUncheckedUpdateWithoutLibraryBooksToAuthorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryStudentCreateWithoutUniversityInput = {
    studentId: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryBookCopies?: LibraryBookCopyCreateNestedManyWithoutBorrowedByInput
    libraryBorrowingHistories?: LibraryBorrowingHistoryCreateNestedManyWithoutStudentInput
    libraryRequests?: LibraryRequestCreateNestedManyWithoutStudentInput
  }

  export type LibraryStudentUncheckedCreateWithoutUniversityInput = {
    id?: number
    studentId: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryBookCopies?: LibraryBookCopyUncheckedCreateNestedManyWithoutBorrowedByInput
    libraryBorrowingHistories?: LibraryBorrowingHistoryUncheckedCreateNestedManyWithoutStudentInput
    libraryRequests?: LibraryRequestUncheckedCreateNestedManyWithoutStudentInput
  }

  export type LibraryStudentCreateOrConnectWithoutUniversityInput = {
    where: LibraryStudentWhereUniqueInput
    create: XOR<LibraryStudentCreateWithoutUniversityInput, LibraryStudentUncheckedCreateWithoutUniversityInput>
  }

  export type LibraryStudentCreateManyUniversityInputEnvelope = {
    data: Enumerable<LibraryStudentCreateManyUniversityInput>
    skipDuplicates?: boolean
  }

  export type LibraryBookCopyCreateWithoutUniversityInput = {
    book: LibraryBookCreateNestedOneWithoutLibraryBookCopiesInput
    status: string
    borrowedBy: LibraryStudentCreateNestedOneWithoutLibraryBookCopiesInput
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryBorrowingHistories?: LibraryBorrowingHistoryCreateNestedManyWithoutCopyInput
    libraryRequests?: LibraryRequestCreateNestedManyWithoutCopyInput
  }

  export type LibraryBookCopyUncheckedCreateWithoutUniversityInput = {
    id?: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryBookId: number
    libraryStudentId: number
    libraryBorrowingHistories?: LibraryBorrowingHistoryUncheckedCreateNestedManyWithoutCopyInput
    libraryRequests?: LibraryRequestUncheckedCreateNestedManyWithoutCopyInput
  }

  export type LibraryBookCopyCreateOrConnectWithoutUniversityInput = {
    where: LibraryBookCopyWhereUniqueInput
    create: XOR<LibraryBookCopyCreateWithoutUniversityInput, LibraryBookCopyUncheckedCreateWithoutUniversityInput>
  }

  export type LibraryBookCopyCreateManyUniversityInputEnvelope = {
    data: Enumerable<LibraryBookCopyCreateManyUniversityInput>
    skipDuplicates?: boolean
  }

  export type LibraryBorrowingHistoryCreateWithoutBorrowedFromInput = {
    student: LibraryStudentCreateNestedOneWithoutLibraryBorrowingHistoriesInput
    copy: LibraryBookCopyCreateNestedOneWithoutLibraryBorrowingHistoriesInput
    borrowDate: number
    returnDate: number
    actualReturnDate: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBorrowingHistoryUncheckedCreateWithoutBorrowedFromInput = {
    id?: number
    borrowDate: number
    returnDate: number
    actualReturnDate: number
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryStudentId: number
    libraryBookCopyId: number
  }

  export type LibraryBorrowingHistoryCreateOrConnectWithoutBorrowedFromInput = {
    where: LibraryBorrowingHistoryWhereUniqueInput
    create: XOR<LibraryBorrowingHistoryCreateWithoutBorrowedFromInput, LibraryBorrowingHistoryUncheckedCreateWithoutBorrowedFromInput>
  }

  export type LibraryBorrowingHistoryCreateManyBorrowedFromInputEnvelope = {
    data: Enumerable<LibraryBorrowingHistoryCreateManyBorrowedFromInput>
    skipDuplicates?: boolean
  }

  export type LibraryRequestCreateWithoutFromInput = {
    student: LibraryStudentCreateNestedOneWithoutLibraryRequestsInput
    copy: LibraryBookCopyCreateNestedOneWithoutLibraryRequestsInput
    to: LibraryUniversityCreateNestedOneWithoutToLibraryRequestsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryRequestUncheckedCreateWithoutFromInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryStudentId: number
    libraryBookCopyId: number
    toLibraryUniversityId: number
  }

  export type LibraryRequestCreateOrConnectWithoutFromInput = {
    where: LibraryRequestWhereUniqueInput
    create: XOR<LibraryRequestCreateWithoutFromInput, LibraryRequestUncheckedCreateWithoutFromInput>
  }

  export type LibraryRequestCreateManyFromInputEnvelope = {
    data: Enumerable<LibraryRequestCreateManyFromInput>
    skipDuplicates?: boolean
  }

  export type LibraryRequestCreateWithoutToInput = {
    student: LibraryStudentCreateNestedOneWithoutLibraryRequestsInput
    copy: LibraryBookCopyCreateNestedOneWithoutLibraryRequestsInput
    from: LibraryUniversityCreateNestedOneWithoutFromLibraryRequestsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryRequestUncheckedCreateWithoutToInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryStudentId: number
    libraryBookCopyId: number
    fromLibraryUniversityId: number
  }

  export type LibraryRequestCreateOrConnectWithoutToInput = {
    where: LibraryRequestWhereUniqueInput
    create: XOR<LibraryRequestCreateWithoutToInput, LibraryRequestUncheckedCreateWithoutToInput>
  }

  export type LibraryRequestCreateManyToInputEnvelope = {
    data: Enumerable<LibraryRequestCreateManyToInput>
    skipDuplicates?: boolean
  }

  export type LibraryStudentUpsertWithWhereUniqueWithoutUniversityInput = {
    where: LibraryStudentWhereUniqueInput
    update: XOR<LibraryStudentUpdateWithoutUniversityInput, LibraryStudentUncheckedUpdateWithoutUniversityInput>
    create: XOR<LibraryStudentCreateWithoutUniversityInput, LibraryStudentUncheckedCreateWithoutUniversityInput>
  }

  export type LibraryStudentUpdateWithWhereUniqueWithoutUniversityInput = {
    where: LibraryStudentWhereUniqueInput
    data: XOR<LibraryStudentUpdateWithoutUniversityInput, LibraryStudentUncheckedUpdateWithoutUniversityInput>
  }

  export type LibraryStudentUpdateManyWithWhereWithoutUniversityInput = {
    where: LibraryStudentScalarWhereInput
    data: XOR<LibraryStudentUpdateManyMutationInput, LibraryStudentUncheckedUpdateManyWithoutLibraryStudentaInput>
  }

  export type LibraryStudentScalarWhereInput = {
    AND?: Enumerable<LibraryStudentScalarWhereInput>
    OR?: Enumerable<LibraryStudentScalarWhereInput>
    NOT?: Enumerable<LibraryStudentScalarWhereInput>
    id?: IntFilter | number
    studentId?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    libraryUniversityId?: IntFilter | number
  }

  export type LibraryBookCopyUpsertWithWhereUniqueWithoutUniversityInput = {
    where: LibraryBookCopyWhereUniqueInput
    update: XOR<LibraryBookCopyUpdateWithoutUniversityInput, LibraryBookCopyUncheckedUpdateWithoutUniversityInput>
    create: XOR<LibraryBookCopyCreateWithoutUniversityInput, LibraryBookCopyUncheckedCreateWithoutUniversityInput>
  }

  export type LibraryBookCopyUpdateWithWhereUniqueWithoutUniversityInput = {
    where: LibraryBookCopyWhereUniqueInput
    data: XOR<LibraryBookCopyUpdateWithoutUniversityInput, LibraryBookCopyUncheckedUpdateWithoutUniversityInput>
  }

  export type LibraryBookCopyUpdateManyWithWhereWithoutUniversityInput = {
    where: LibraryBookCopyScalarWhereInput
    data: XOR<LibraryBookCopyUpdateManyMutationInput, LibraryBookCopyUncheckedUpdateManyWithoutLibraryBookCopiesInput>
  }

  export type LibraryBorrowingHistoryUpsertWithWhereUniqueWithoutBorrowedFromInput = {
    where: LibraryBorrowingHistoryWhereUniqueInput
    update: XOR<LibraryBorrowingHistoryUpdateWithoutBorrowedFromInput, LibraryBorrowingHistoryUncheckedUpdateWithoutBorrowedFromInput>
    create: XOR<LibraryBorrowingHistoryCreateWithoutBorrowedFromInput, LibraryBorrowingHistoryUncheckedCreateWithoutBorrowedFromInput>
  }

  export type LibraryBorrowingHistoryUpdateWithWhereUniqueWithoutBorrowedFromInput = {
    where: LibraryBorrowingHistoryWhereUniqueInput
    data: XOR<LibraryBorrowingHistoryUpdateWithoutBorrowedFromInput, LibraryBorrowingHistoryUncheckedUpdateWithoutBorrowedFromInput>
  }

  export type LibraryBorrowingHistoryUpdateManyWithWhereWithoutBorrowedFromInput = {
    where: LibraryBorrowingHistoryScalarWhereInput
    data: XOR<LibraryBorrowingHistoryUpdateManyMutationInput, LibraryBorrowingHistoryUncheckedUpdateManyWithoutLibraryBorrowingHistoriesInput>
  }

  export type LibraryBorrowingHistoryScalarWhereInput = {
    AND?: Enumerable<LibraryBorrowingHistoryScalarWhereInput>
    OR?: Enumerable<LibraryBorrowingHistoryScalarWhereInput>
    NOT?: Enumerable<LibraryBorrowingHistoryScalarWhereInput>
    id?: IntFilter | number
    borrowDate?: IntFilter | number
    returnDate?: IntFilter | number
    actualReturnDate?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    libraryStudentId?: IntFilter | number
    libraryBookCopyId?: IntFilter | number
    libraryUniversityId?: IntFilter | number
  }

  export type LibraryRequestUpsertWithWhereUniqueWithoutFromInput = {
    where: LibraryRequestWhereUniqueInput
    update: XOR<LibraryRequestUpdateWithoutFromInput, LibraryRequestUncheckedUpdateWithoutFromInput>
    create: XOR<LibraryRequestCreateWithoutFromInput, LibraryRequestUncheckedCreateWithoutFromInput>
  }

  export type LibraryRequestUpdateWithWhereUniqueWithoutFromInput = {
    where: LibraryRequestWhereUniqueInput
    data: XOR<LibraryRequestUpdateWithoutFromInput, LibraryRequestUncheckedUpdateWithoutFromInput>
  }

  export type LibraryRequestUpdateManyWithWhereWithoutFromInput = {
    where: LibraryRequestScalarWhereInput
    data: XOR<LibraryRequestUpdateManyMutationInput, LibraryRequestUncheckedUpdateManyWithoutFromLibraryRequestsInput>
  }

  export type LibraryRequestScalarWhereInput = {
    AND?: Enumerable<LibraryRequestScalarWhereInput>
    OR?: Enumerable<LibraryRequestScalarWhereInput>
    NOT?: Enumerable<LibraryRequestScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    libraryStudentId?: IntFilter | number
    libraryBookCopyId?: IntFilter | number
    fromLibraryUniversityId?: IntFilter | number
    toLibraryUniversityId?: IntFilter | number
  }

  export type LibraryRequestUpsertWithWhereUniqueWithoutToInput = {
    where: LibraryRequestWhereUniqueInput
    update: XOR<LibraryRequestUpdateWithoutToInput, LibraryRequestUncheckedUpdateWithoutToInput>
    create: XOR<LibraryRequestCreateWithoutToInput, LibraryRequestUncheckedCreateWithoutToInput>
  }

  export type LibraryRequestUpdateWithWhereUniqueWithoutToInput = {
    where: LibraryRequestWhereUniqueInput
    data: XOR<LibraryRequestUpdateWithoutToInput, LibraryRequestUncheckedUpdateWithoutToInput>
  }

  export type LibraryRequestUpdateManyWithWhereWithoutToInput = {
    where: LibraryRequestScalarWhereInput
    data: XOR<LibraryRequestUpdateManyMutationInput, LibraryRequestUncheckedUpdateManyWithoutToLibraryRequestsInput>
  }

  export type LibraryUniversityCreateWithoutLibraryStudentaInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryBookCopies?: LibraryBookCopyCreateNestedManyWithoutUniversityInput
    libraryBorrowingHistories?: LibraryBorrowingHistoryCreateNestedManyWithoutBorrowedFromInput
    fromLibraryRequests?: LibraryRequestCreateNestedManyWithoutFromInput
    toLibraryRequests?: LibraryRequestCreateNestedManyWithoutToInput
  }

  export type LibraryUniversityUncheckedCreateWithoutLibraryStudentaInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryBookCopies?: LibraryBookCopyUncheckedCreateNestedManyWithoutUniversityInput
    libraryBorrowingHistories?: LibraryBorrowingHistoryUncheckedCreateNestedManyWithoutBorrowedFromInput
    fromLibraryRequests?: LibraryRequestUncheckedCreateNestedManyWithoutFromInput
    toLibraryRequests?: LibraryRequestUncheckedCreateNestedManyWithoutToInput
  }

  export type LibraryUniversityCreateOrConnectWithoutLibraryStudentaInput = {
    where: LibraryUniversityWhereUniqueInput
    create: XOR<LibraryUniversityCreateWithoutLibraryStudentaInput, LibraryUniversityUncheckedCreateWithoutLibraryStudentaInput>
  }

  export type LibraryBookCopyCreateWithoutBorrowedByInput = {
    book: LibraryBookCreateNestedOneWithoutLibraryBookCopiesInput
    status: string
    university: LibraryUniversityCreateNestedOneWithoutLibraryBookCopiesInput
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryBorrowingHistories?: LibraryBorrowingHistoryCreateNestedManyWithoutCopyInput
    libraryRequests?: LibraryRequestCreateNestedManyWithoutCopyInput
  }

  export type LibraryBookCopyUncheckedCreateWithoutBorrowedByInput = {
    id?: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryBookId: number
    libraryUniversityId: number
    libraryBorrowingHistories?: LibraryBorrowingHistoryUncheckedCreateNestedManyWithoutCopyInput
    libraryRequests?: LibraryRequestUncheckedCreateNestedManyWithoutCopyInput
  }

  export type LibraryBookCopyCreateOrConnectWithoutBorrowedByInput = {
    where: LibraryBookCopyWhereUniqueInput
    create: XOR<LibraryBookCopyCreateWithoutBorrowedByInput, LibraryBookCopyUncheckedCreateWithoutBorrowedByInput>
  }

  export type LibraryBookCopyCreateManyBorrowedByInputEnvelope = {
    data: Enumerable<LibraryBookCopyCreateManyBorrowedByInput>
    skipDuplicates?: boolean
  }

  export type LibraryBorrowingHistoryCreateWithoutStudentInput = {
    copy: LibraryBookCopyCreateNestedOneWithoutLibraryBorrowingHistoriesInput
    borrowDate: number
    returnDate: number
    actualReturnDate: number
    borrowedFrom: LibraryUniversityCreateNestedOneWithoutLibraryBorrowingHistoriesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBorrowingHistoryUncheckedCreateWithoutStudentInput = {
    id?: number
    borrowDate: number
    returnDate: number
    actualReturnDate: number
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryBookCopyId: number
    libraryUniversityId: number
  }

  export type LibraryBorrowingHistoryCreateOrConnectWithoutStudentInput = {
    where: LibraryBorrowingHistoryWhereUniqueInput
    create: XOR<LibraryBorrowingHistoryCreateWithoutStudentInput, LibraryBorrowingHistoryUncheckedCreateWithoutStudentInput>
  }

  export type LibraryBorrowingHistoryCreateManyStudentInputEnvelope = {
    data: Enumerable<LibraryBorrowingHistoryCreateManyStudentInput>
    skipDuplicates?: boolean
  }

  export type LibraryRequestCreateWithoutStudentInput = {
    copy: LibraryBookCopyCreateNestedOneWithoutLibraryRequestsInput
    from: LibraryUniversityCreateNestedOneWithoutFromLibraryRequestsInput
    to: LibraryUniversityCreateNestedOneWithoutToLibraryRequestsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryRequestUncheckedCreateWithoutStudentInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryBookCopyId: number
    fromLibraryUniversityId: number
    toLibraryUniversityId: number
  }

  export type LibraryRequestCreateOrConnectWithoutStudentInput = {
    where: LibraryRequestWhereUniqueInput
    create: XOR<LibraryRequestCreateWithoutStudentInput, LibraryRequestUncheckedCreateWithoutStudentInput>
  }

  export type LibraryRequestCreateManyStudentInputEnvelope = {
    data: Enumerable<LibraryRequestCreateManyStudentInput>
    skipDuplicates?: boolean
  }

  export type LibraryUniversityUpsertWithoutLibraryStudentaInput = {
    update: XOR<LibraryUniversityUpdateWithoutLibraryStudentaInput, LibraryUniversityUncheckedUpdateWithoutLibraryStudentaInput>
    create: XOR<LibraryUniversityCreateWithoutLibraryStudentaInput, LibraryUniversityUncheckedCreateWithoutLibraryStudentaInput>
  }

  export type LibraryUniversityUpdateWithoutLibraryStudentaInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryBookCopies?: LibraryBookCopyUpdateManyWithoutUniversityNestedInput
    libraryBorrowingHistories?: LibraryBorrowingHistoryUpdateManyWithoutBorrowedFromNestedInput
    fromLibraryRequests?: LibraryRequestUpdateManyWithoutFromNestedInput
    toLibraryRequests?: LibraryRequestUpdateManyWithoutToNestedInput
  }

  export type LibraryUniversityUncheckedUpdateWithoutLibraryStudentaInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryBookCopies?: LibraryBookCopyUncheckedUpdateManyWithoutUniversityNestedInput
    libraryBorrowingHistories?: LibraryBorrowingHistoryUncheckedUpdateManyWithoutBorrowedFromNestedInput
    fromLibraryRequests?: LibraryRequestUncheckedUpdateManyWithoutFromNestedInput
    toLibraryRequests?: LibraryRequestUncheckedUpdateManyWithoutToNestedInput
  }

  export type LibraryBookCopyUpsertWithWhereUniqueWithoutBorrowedByInput = {
    where: LibraryBookCopyWhereUniqueInput
    update: XOR<LibraryBookCopyUpdateWithoutBorrowedByInput, LibraryBookCopyUncheckedUpdateWithoutBorrowedByInput>
    create: XOR<LibraryBookCopyCreateWithoutBorrowedByInput, LibraryBookCopyUncheckedCreateWithoutBorrowedByInput>
  }

  export type LibraryBookCopyUpdateWithWhereUniqueWithoutBorrowedByInput = {
    where: LibraryBookCopyWhereUniqueInput
    data: XOR<LibraryBookCopyUpdateWithoutBorrowedByInput, LibraryBookCopyUncheckedUpdateWithoutBorrowedByInput>
  }

  export type LibraryBookCopyUpdateManyWithWhereWithoutBorrowedByInput = {
    where: LibraryBookCopyScalarWhereInput
    data: XOR<LibraryBookCopyUpdateManyMutationInput, LibraryBookCopyUncheckedUpdateManyWithoutLibraryBookCopiesInput>
  }

  export type LibraryBorrowingHistoryUpsertWithWhereUniqueWithoutStudentInput = {
    where: LibraryBorrowingHistoryWhereUniqueInput
    update: XOR<LibraryBorrowingHistoryUpdateWithoutStudentInput, LibraryBorrowingHistoryUncheckedUpdateWithoutStudentInput>
    create: XOR<LibraryBorrowingHistoryCreateWithoutStudentInput, LibraryBorrowingHistoryUncheckedCreateWithoutStudentInput>
  }

  export type LibraryBorrowingHistoryUpdateWithWhereUniqueWithoutStudentInput = {
    where: LibraryBorrowingHistoryWhereUniqueInput
    data: XOR<LibraryBorrowingHistoryUpdateWithoutStudentInput, LibraryBorrowingHistoryUncheckedUpdateWithoutStudentInput>
  }

  export type LibraryBorrowingHistoryUpdateManyWithWhereWithoutStudentInput = {
    where: LibraryBorrowingHistoryScalarWhereInput
    data: XOR<LibraryBorrowingHistoryUpdateManyMutationInput, LibraryBorrowingHistoryUncheckedUpdateManyWithoutLibraryBorrowingHistoriesInput>
  }

  export type LibraryRequestUpsertWithWhereUniqueWithoutStudentInput = {
    where: LibraryRequestWhereUniqueInput
    update: XOR<LibraryRequestUpdateWithoutStudentInput, LibraryRequestUncheckedUpdateWithoutStudentInput>
    create: XOR<LibraryRequestCreateWithoutStudentInput, LibraryRequestUncheckedCreateWithoutStudentInput>
  }

  export type LibraryRequestUpdateWithWhereUniqueWithoutStudentInput = {
    where: LibraryRequestWhereUniqueInput
    data: XOR<LibraryRequestUpdateWithoutStudentInput, LibraryRequestUncheckedUpdateWithoutStudentInput>
  }

  export type LibraryRequestUpdateManyWithWhereWithoutStudentInput = {
    where: LibraryRequestScalarWhereInput
    data: XOR<LibraryRequestUpdateManyMutationInput, LibraryRequestUncheckedUpdateManyWithoutLibraryRequestsInput>
  }

  export type LibraryBookCreateWithoutLibraryBookCopiesInput = {
    name: string
    ISBN: number
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryCategoriesToBooks?: LibraryCategoryToBookCreateNestedManyWithoutBookInput
    libraryBooksToAuthors?: LibraryBookToAuthorCreateNestedManyWithoutBookInput
  }

  export type LibraryBookUncheckedCreateWithoutLibraryBookCopiesInput = {
    id?: number
    name: string
    ISBN: number
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryCategoriesToBooks?: LibraryCategoryToBookUncheckedCreateNestedManyWithoutBookInput
    libraryBooksToAuthors?: LibraryBookToAuthorUncheckedCreateNestedManyWithoutBookInput
  }

  export type LibraryBookCreateOrConnectWithoutLibraryBookCopiesInput = {
    where: LibraryBookWhereUniqueInput
    create: XOR<LibraryBookCreateWithoutLibraryBookCopiesInput, LibraryBookUncheckedCreateWithoutLibraryBookCopiesInput>
  }

  export type LibraryUniversityCreateWithoutLibraryBookCopiesInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryStudenta?: LibraryStudentCreateNestedManyWithoutUniversityInput
    libraryBorrowingHistories?: LibraryBorrowingHistoryCreateNestedManyWithoutBorrowedFromInput
    fromLibraryRequests?: LibraryRequestCreateNestedManyWithoutFromInput
    toLibraryRequests?: LibraryRequestCreateNestedManyWithoutToInput
  }

  export type LibraryUniversityUncheckedCreateWithoutLibraryBookCopiesInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryStudenta?: LibraryStudentUncheckedCreateNestedManyWithoutUniversityInput
    libraryBorrowingHistories?: LibraryBorrowingHistoryUncheckedCreateNestedManyWithoutBorrowedFromInput
    fromLibraryRequests?: LibraryRequestUncheckedCreateNestedManyWithoutFromInput
    toLibraryRequests?: LibraryRequestUncheckedCreateNestedManyWithoutToInput
  }

  export type LibraryUniversityCreateOrConnectWithoutLibraryBookCopiesInput = {
    where: LibraryUniversityWhereUniqueInput
    create: XOR<LibraryUniversityCreateWithoutLibraryBookCopiesInput, LibraryUniversityUncheckedCreateWithoutLibraryBookCopiesInput>
  }

  export type LibraryStudentCreateWithoutLibraryBookCopiesInput = {
    studentId: number
    name: string
    university: LibraryUniversityCreateNestedOneWithoutLibraryStudentaInput
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryBorrowingHistories?: LibraryBorrowingHistoryCreateNestedManyWithoutStudentInput
    libraryRequests?: LibraryRequestCreateNestedManyWithoutStudentInput
  }

  export type LibraryStudentUncheckedCreateWithoutLibraryBookCopiesInput = {
    id?: number
    studentId: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryUniversityId: number
    libraryBorrowingHistories?: LibraryBorrowingHistoryUncheckedCreateNestedManyWithoutStudentInput
    libraryRequests?: LibraryRequestUncheckedCreateNestedManyWithoutStudentInput
  }

  export type LibraryStudentCreateOrConnectWithoutLibraryBookCopiesInput = {
    where: LibraryStudentWhereUniqueInput
    create: XOR<LibraryStudentCreateWithoutLibraryBookCopiesInput, LibraryStudentUncheckedCreateWithoutLibraryBookCopiesInput>
  }

  export type LibraryBorrowingHistoryCreateWithoutCopyInput = {
    student: LibraryStudentCreateNestedOneWithoutLibraryBorrowingHistoriesInput
    borrowDate: number
    returnDate: number
    actualReturnDate: number
    borrowedFrom: LibraryUniversityCreateNestedOneWithoutLibraryBorrowingHistoriesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBorrowingHistoryUncheckedCreateWithoutCopyInput = {
    id?: number
    borrowDate: number
    returnDate: number
    actualReturnDate: number
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryStudentId: number
    libraryUniversityId: number
  }

  export type LibraryBorrowingHistoryCreateOrConnectWithoutCopyInput = {
    where: LibraryBorrowingHistoryWhereUniqueInput
    create: XOR<LibraryBorrowingHistoryCreateWithoutCopyInput, LibraryBorrowingHistoryUncheckedCreateWithoutCopyInput>
  }

  export type LibraryBorrowingHistoryCreateManyCopyInputEnvelope = {
    data: Enumerable<LibraryBorrowingHistoryCreateManyCopyInput>
    skipDuplicates?: boolean
  }

  export type LibraryRequestCreateWithoutCopyInput = {
    student: LibraryStudentCreateNestedOneWithoutLibraryRequestsInput
    from: LibraryUniversityCreateNestedOneWithoutFromLibraryRequestsInput
    to: LibraryUniversityCreateNestedOneWithoutToLibraryRequestsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryRequestUncheckedCreateWithoutCopyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryStudentId: number
    fromLibraryUniversityId: number
    toLibraryUniversityId: number
  }

  export type LibraryRequestCreateOrConnectWithoutCopyInput = {
    where: LibraryRequestWhereUniqueInput
    create: XOR<LibraryRequestCreateWithoutCopyInput, LibraryRequestUncheckedCreateWithoutCopyInput>
  }

  export type LibraryRequestCreateManyCopyInputEnvelope = {
    data: Enumerable<LibraryRequestCreateManyCopyInput>
    skipDuplicates?: boolean
  }

  export type LibraryBookUpsertWithoutLibraryBookCopiesInput = {
    update: XOR<LibraryBookUpdateWithoutLibraryBookCopiesInput, LibraryBookUncheckedUpdateWithoutLibraryBookCopiesInput>
    create: XOR<LibraryBookCreateWithoutLibraryBookCopiesInput, LibraryBookUncheckedCreateWithoutLibraryBookCopiesInput>
  }

  export type LibraryBookUpdateWithoutLibraryBookCopiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    ISBN?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryCategoriesToBooks?: LibraryCategoryToBookUpdateManyWithoutBookNestedInput
    libraryBooksToAuthors?: LibraryBookToAuthorUpdateManyWithoutBookNestedInput
  }

  export type LibraryBookUncheckedUpdateWithoutLibraryBookCopiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    ISBN?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryCategoriesToBooks?: LibraryCategoryToBookUncheckedUpdateManyWithoutBookNestedInput
    libraryBooksToAuthors?: LibraryBookToAuthorUncheckedUpdateManyWithoutBookNestedInput
  }

  export type LibraryUniversityUpsertWithoutLibraryBookCopiesInput = {
    update: XOR<LibraryUniversityUpdateWithoutLibraryBookCopiesInput, LibraryUniversityUncheckedUpdateWithoutLibraryBookCopiesInput>
    create: XOR<LibraryUniversityCreateWithoutLibraryBookCopiesInput, LibraryUniversityUncheckedCreateWithoutLibraryBookCopiesInput>
  }

  export type LibraryUniversityUpdateWithoutLibraryBookCopiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryStudenta?: LibraryStudentUpdateManyWithoutUniversityNestedInput
    libraryBorrowingHistories?: LibraryBorrowingHistoryUpdateManyWithoutBorrowedFromNestedInput
    fromLibraryRequests?: LibraryRequestUpdateManyWithoutFromNestedInput
    toLibraryRequests?: LibraryRequestUpdateManyWithoutToNestedInput
  }

  export type LibraryUniversityUncheckedUpdateWithoutLibraryBookCopiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryStudenta?: LibraryStudentUncheckedUpdateManyWithoutUniversityNestedInput
    libraryBorrowingHistories?: LibraryBorrowingHistoryUncheckedUpdateManyWithoutBorrowedFromNestedInput
    fromLibraryRequests?: LibraryRequestUncheckedUpdateManyWithoutFromNestedInput
    toLibraryRequests?: LibraryRequestUncheckedUpdateManyWithoutToNestedInput
  }

  export type LibraryStudentUpsertWithoutLibraryBookCopiesInput = {
    update: XOR<LibraryStudentUpdateWithoutLibraryBookCopiesInput, LibraryStudentUncheckedUpdateWithoutLibraryBookCopiesInput>
    create: XOR<LibraryStudentCreateWithoutLibraryBookCopiesInput, LibraryStudentUncheckedCreateWithoutLibraryBookCopiesInput>
  }

  export type LibraryStudentUpdateWithoutLibraryBookCopiesInput = {
    studentId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    university?: LibraryUniversityUpdateOneRequiredWithoutLibraryStudentaNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryBorrowingHistories?: LibraryBorrowingHistoryUpdateManyWithoutStudentNestedInput
    libraryRequests?: LibraryRequestUpdateManyWithoutStudentNestedInput
  }

  export type LibraryStudentUncheckedUpdateWithoutLibraryBookCopiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryUniversityId?: IntFieldUpdateOperationsInput | number
    libraryBorrowingHistories?: LibraryBorrowingHistoryUncheckedUpdateManyWithoutStudentNestedInput
    libraryRequests?: LibraryRequestUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type LibraryBorrowingHistoryUpsertWithWhereUniqueWithoutCopyInput = {
    where: LibraryBorrowingHistoryWhereUniqueInput
    update: XOR<LibraryBorrowingHistoryUpdateWithoutCopyInput, LibraryBorrowingHistoryUncheckedUpdateWithoutCopyInput>
    create: XOR<LibraryBorrowingHistoryCreateWithoutCopyInput, LibraryBorrowingHistoryUncheckedCreateWithoutCopyInput>
  }

  export type LibraryBorrowingHistoryUpdateWithWhereUniqueWithoutCopyInput = {
    where: LibraryBorrowingHistoryWhereUniqueInput
    data: XOR<LibraryBorrowingHistoryUpdateWithoutCopyInput, LibraryBorrowingHistoryUncheckedUpdateWithoutCopyInput>
  }

  export type LibraryBorrowingHistoryUpdateManyWithWhereWithoutCopyInput = {
    where: LibraryBorrowingHistoryScalarWhereInput
    data: XOR<LibraryBorrowingHistoryUpdateManyMutationInput, LibraryBorrowingHistoryUncheckedUpdateManyWithoutLibraryBorrowingHistoriesInput>
  }

  export type LibraryRequestUpsertWithWhereUniqueWithoutCopyInput = {
    where: LibraryRequestWhereUniqueInput
    update: XOR<LibraryRequestUpdateWithoutCopyInput, LibraryRequestUncheckedUpdateWithoutCopyInput>
    create: XOR<LibraryRequestCreateWithoutCopyInput, LibraryRequestUncheckedCreateWithoutCopyInput>
  }

  export type LibraryRequestUpdateWithWhereUniqueWithoutCopyInput = {
    where: LibraryRequestWhereUniqueInput
    data: XOR<LibraryRequestUpdateWithoutCopyInput, LibraryRequestUncheckedUpdateWithoutCopyInput>
  }

  export type LibraryRequestUpdateManyWithWhereWithoutCopyInput = {
    where: LibraryRequestScalarWhereInput
    data: XOR<LibraryRequestUpdateManyMutationInput, LibraryRequestUncheckedUpdateManyWithoutLibraryRequestsInput>
  }

  export type LibraryStudentCreateWithoutLibraryBorrowingHistoriesInput = {
    studentId: number
    name: string
    university: LibraryUniversityCreateNestedOneWithoutLibraryStudentaInput
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryBookCopies?: LibraryBookCopyCreateNestedManyWithoutBorrowedByInput
    libraryRequests?: LibraryRequestCreateNestedManyWithoutStudentInput
  }

  export type LibraryStudentUncheckedCreateWithoutLibraryBorrowingHistoriesInput = {
    id?: number
    studentId: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryUniversityId: number
    libraryBookCopies?: LibraryBookCopyUncheckedCreateNestedManyWithoutBorrowedByInput
    libraryRequests?: LibraryRequestUncheckedCreateNestedManyWithoutStudentInput
  }

  export type LibraryStudentCreateOrConnectWithoutLibraryBorrowingHistoriesInput = {
    where: LibraryStudentWhereUniqueInput
    create: XOR<LibraryStudentCreateWithoutLibraryBorrowingHistoriesInput, LibraryStudentUncheckedCreateWithoutLibraryBorrowingHistoriesInput>
  }

  export type LibraryBookCopyCreateWithoutLibraryBorrowingHistoriesInput = {
    book: LibraryBookCreateNestedOneWithoutLibraryBookCopiesInput
    status: string
    university: LibraryUniversityCreateNestedOneWithoutLibraryBookCopiesInput
    borrowedBy: LibraryStudentCreateNestedOneWithoutLibraryBookCopiesInput
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryRequests?: LibraryRequestCreateNestedManyWithoutCopyInput
  }

  export type LibraryBookCopyUncheckedCreateWithoutLibraryBorrowingHistoriesInput = {
    id?: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryBookId: number
    libraryUniversityId: number
    libraryStudentId: number
    libraryRequests?: LibraryRequestUncheckedCreateNestedManyWithoutCopyInput
  }

  export type LibraryBookCopyCreateOrConnectWithoutLibraryBorrowingHistoriesInput = {
    where: LibraryBookCopyWhereUniqueInput
    create: XOR<LibraryBookCopyCreateWithoutLibraryBorrowingHistoriesInput, LibraryBookCopyUncheckedCreateWithoutLibraryBorrowingHistoriesInput>
  }

  export type LibraryUniversityCreateWithoutLibraryBorrowingHistoriesInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryStudenta?: LibraryStudentCreateNestedManyWithoutUniversityInput
    libraryBookCopies?: LibraryBookCopyCreateNestedManyWithoutUniversityInput
    fromLibraryRequests?: LibraryRequestCreateNestedManyWithoutFromInput
    toLibraryRequests?: LibraryRequestCreateNestedManyWithoutToInput
  }

  export type LibraryUniversityUncheckedCreateWithoutLibraryBorrowingHistoriesInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryStudenta?: LibraryStudentUncheckedCreateNestedManyWithoutUniversityInput
    libraryBookCopies?: LibraryBookCopyUncheckedCreateNestedManyWithoutUniversityInput
    fromLibraryRequests?: LibraryRequestUncheckedCreateNestedManyWithoutFromInput
    toLibraryRequests?: LibraryRequestUncheckedCreateNestedManyWithoutToInput
  }

  export type LibraryUniversityCreateOrConnectWithoutLibraryBorrowingHistoriesInput = {
    where: LibraryUniversityWhereUniqueInput
    create: XOR<LibraryUniversityCreateWithoutLibraryBorrowingHistoriesInput, LibraryUniversityUncheckedCreateWithoutLibraryBorrowingHistoriesInput>
  }

  export type LibraryStudentUpsertWithoutLibraryBorrowingHistoriesInput = {
    update: XOR<LibraryStudentUpdateWithoutLibraryBorrowingHistoriesInput, LibraryStudentUncheckedUpdateWithoutLibraryBorrowingHistoriesInput>
    create: XOR<LibraryStudentCreateWithoutLibraryBorrowingHistoriesInput, LibraryStudentUncheckedCreateWithoutLibraryBorrowingHistoriesInput>
  }

  export type LibraryStudentUpdateWithoutLibraryBorrowingHistoriesInput = {
    studentId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    university?: LibraryUniversityUpdateOneRequiredWithoutLibraryStudentaNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryBookCopies?: LibraryBookCopyUpdateManyWithoutBorrowedByNestedInput
    libraryRequests?: LibraryRequestUpdateManyWithoutStudentNestedInput
  }

  export type LibraryStudentUncheckedUpdateWithoutLibraryBorrowingHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryUniversityId?: IntFieldUpdateOperationsInput | number
    libraryBookCopies?: LibraryBookCopyUncheckedUpdateManyWithoutBorrowedByNestedInput
    libraryRequests?: LibraryRequestUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type LibraryBookCopyUpsertWithoutLibraryBorrowingHistoriesInput = {
    update: XOR<LibraryBookCopyUpdateWithoutLibraryBorrowingHistoriesInput, LibraryBookCopyUncheckedUpdateWithoutLibraryBorrowingHistoriesInput>
    create: XOR<LibraryBookCopyCreateWithoutLibraryBorrowingHistoriesInput, LibraryBookCopyUncheckedCreateWithoutLibraryBorrowingHistoriesInput>
  }

  export type LibraryBookCopyUpdateWithoutLibraryBorrowingHistoriesInput = {
    book?: LibraryBookUpdateOneRequiredWithoutLibraryBookCopiesNestedInput
    status?: StringFieldUpdateOperationsInput | string
    university?: LibraryUniversityUpdateOneRequiredWithoutLibraryBookCopiesNestedInput
    borrowedBy?: LibraryStudentUpdateOneRequiredWithoutLibraryBookCopiesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryRequests?: LibraryRequestUpdateManyWithoutCopyNestedInput
  }

  export type LibraryBookCopyUncheckedUpdateWithoutLibraryBorrowingHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryBookId?: IntFieldUpdateOperationsInput | number
    libraryUniversityId?: IntFieldUpdateOperationsInput | number
    libraryStudentId?: IntFieldUpdateOperationsInput | number
    libraryRequests?: LibraryRequestUncheckedUpdateManyWithoutCopyNestedInput
  }

  export type LibraryUniversityUpsertWithoutLibraryBorrowingHistoriesInput = {
    update: XOR<LibraryUniversityUpdateWithoutLibraryBorrowingHistoriesInput, LibraryUniversityUncheckedUpdateWithoutLibraryBorrowingHistoriesInput>
    create: XOR<LibraryUniversityCreateWithoutLibraryBorrowingHistoriesInput, LibraryUniversityUncheckedCreateWithoutLibraryBorrowingHistoriesInput>
  }

  export type LibraryUniversityUpdateWithoutLibraryBorrowingHistoriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryStudenta?: LibraryStudentUpdateManyWithoutUniversityNestedInput
    libraryBookCopies?: LibraryBookCopyUpdateManyWithoutUniversityNestedInput
    fromLibraryRequests?: LibraryRequestUpdateManyWithoutFromNestedInput
    toLibraryRequests?: LibraryRequestUpdateManyWithoutToNestedInput
  }

  export type LibraryUniversityUncheckedUpdateWithoutLibraryBorrowingHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryStudenta?: LibraryStudentUncheckedUpdateManyWithoutUniversityNestedInput
    libraryBookCopies?: LibraryBookCopyUncheckedUpdateManyWithoutUniversityNestedInput
    fromLibraryRequests?: LibraryRequestUncheckedUpdateManyWithoutFromNestedInput
    toLibraryRequests?: LibraryRequestUncheckedUpdateManyWithoutToNestedInput
  }

  export type LibraryStudentCreateWithoutLibraryRequestsInput = {
    studentId: number
    name: string
    university: LibraryUniversityCreateNestedOneWithoutLibraryStudentaInput
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryBookCopies?: LibraryBookCopyCreateNestedManyWithoutBorrowedByInput
    libraryBorrowingHistories?: LibraryBorrowingHistoryCreateNestedManyWithoutStudentInput
  }

  export type LibraryStudentUncheckedCreateWithoutLibraryRequestsInput = {
    id?: number
    studentId: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryUniversityId: number
    libraryBookCopies?: LibraryBookCopyUncheckedCreateNestedManyWithoutBorrowedByInput
    libraryBorrowingHistories?: LibraryBorrowingHistoryUncheckedCreateNestedManyWithoutStudentInput
  }

  export type LibraryStudentCreateOrConnectWithoutLibraryRequestsInput = {
    where: LibraryStudentWhereUniqueInput
    create: XOR<LibraryStudentCreateWithoutLibraryRequestsInput, LibraryStudentUncheckedCreateWithoutLibraryRequestsInput>
  }

  export type LibraryBookCopyCreateWithoutLibraryRequestsInput = {
    book: LibraryBookCreateNestedOneWithoutLibraryBookCopiesInput
    status: string
    university: LibraryUniversityCreateNestedOneWithoutLibraryBookCopiesInput
    borrowedBy: LibraryStudentCreateNestedOneWithoutLibraryBookCopiesInput
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryBorrowingHistories?: LibraryBorrowingHistoryCreateNestedManyWithoutCopyInput
  }

  export type LibraryBookCopyUncheckedCreateWithoutLibraryRequestsInput = {
    id?: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryBookId: number
    libraryUniversityId: number
    libraryStudentId: number
    libraryBorrowingHistories?: LibraryBorrowingHistoryUncheckedCreateNestedManyWithoutCopyInput
  }

  export type LibraryBookCopyCreateOrConnectWithoutLibraryRequestsInput = {
    where: LibraryBookCopyWhereUniqueInput
    create: XOR<LibraryBookCopyCreateWithoutLibraryRequestsInput, LibraryBookCopyUncheckedCreateWithoutLibraryRequestsInput>
  }

  export type LibraryUniversityCreateWithoutFromLibraryRequestsInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryStudenta?: LibraryStudentCreateNestedManyWithoutUniversityInput
    libraryBookCopies?: LibraryBookCopyCreateNestedManyWithoutUniversityInput
    libraryBorrowingHistories?: LibraryBorrowingHistoryCreateNestedManyWithoutBorrowedFromInput
    toLibraryRequests?: LibraryRequestCreateNestedManyWithoutToInput
  }

  export type LibraryUniversityUncheckedCreateWithoutFromLibraryRequestsInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryStudenta?: LibraryStudentUncheckedCreateNestedManyWithoutUniversityInput
    libraryBookCopies?: LibraryBookCopyUncheckedCreateNestedManyWithoutUniversityInput
    libraryBorrowingHistories?: LibraryBorrowingHistoryUncheckedCreateNestedManyWithoutBorrowedFromInput
    toLibraryRequests?: LibraryRequestUncheckedCreateNestedManyWithoutToInput
  }

  export type LibraryUniversityCreateOrConnectWithoutFromLibraryRequestsInput = {
    where: LibraryUniversityWhereUniqueInput
    create: XOR<LibraryUniversityCreateWithoutFromLibraryRequestsInput, LibraryUniversityUncheckedCreateWithoutFromLibraryRequestsInput>
  }

  export type LibraryUniversityCreateWithoutToLibraryRequestsInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryStudenta?: LibraryStudentCreateNestedManyWithoutUniversityInput
    libraryBookCopies?: LibraryBookCopyCreateNestedManyWithoutUniversityInput
    libraryBorrowingHistories?: LibraryBorrowingHistoryCreateNestedManyWithoutBorrowedFromInput
    fromLibraryRequests?: LibraryRequestCreateNestedManyWithoutFromInput
  }

  export type LibraryUniversityUncheckedCreateWithoutToLibraryRequestsInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryStudenta?: LibraryStudentUncheckedCreateNestedManyWithoutUniversityInput
    libraryBookCopies?: LibraryBookCopyUncheckedCreateNestedManyWithoutUniversityInput
    libraryBorrowingHistories?: LibraryBorrowingHistoryUncheckedCreateNestedManyWithoutBorrowedFromInput
    fromLibraryRequests?: LibraryRequestUncheckedCreateNestedManyWithoutFromInput
  }

  export type LibraryUniversityCreateOrConnectWithoutToLibraryRequestsInput = {
    where: LibraryUniversityWhereUniqueInput
    create: XOR<LibraryUniversityCreateWithoutToLibraryRequestsInput, LibraryUniversityUncheckedCreateWithoutToLibraryRequestsInput>
  }

  export type LibraryStudentUpsertWithoutLibraryRequestsInput = {
    update: XOR<LibraryStudentUpdateWithoutLibraryRequestsInput, LibraryStudentUncheckedUpdateWithoutLibraryRequestsInput>
    create: XOR<LibraryStudentCreateWithoutLibraryRequestsInput, LibraryStudentUncheckedCreateWithoutLibraryRequestsInput>
  }

  export type LibraryStudentUpdateWithoutLibraryRequestsInput = {
    studentId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    university?: LibraryUniversityUpdateOneRequiredWithoutLibraryStudentaNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryBookCopies?: LibraryBookCopyUpdateManyWithoutBorrowedByNestedInput
    libraryBorrowingHistories?: LibraryBorrowingHistoryUpdateManyWithoutStudentNestedInput
  }

  export type LibraryStudentUncheckedUpdateWithoutLibraryRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryUniversityId?: IntFieldUpdateOperationsInput | number
    libraryBookCopies?: LibraryBookCopyUncheckedUpdateManyWithoutBorrowedByNestedInput
    libraryBorrowingHistories?: LibraryBorrowingHistoryUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type LibraryBookCopyUpsertWithoutLibraryRequestsInput = {
    update: XOR<LibraryBookCopyUpdateWithoutLibraryRequestsInput, LibraryBookCopyUncheckedUpdateWithoutLibraryRequestsInput>
    create: XOR<LibraryBookCopyCreateWithoutLibraryRequestsInput, LibraryBookCopyUncheckedCreateWithoutLibraryRequestsInput>
  }

  export type LibraryBookCopyUpdateWithoutLibraryRequestsInput = {
    book?: LibraryBookUpdateOneRequiredWithoutLibraryBookCopiesNestedInput
    status?: StringFieldUpdateOperationsInput | string
    university?: LibraryUniversityUpdateOneRequiredWithoutLibraryBookCopiesNestedInput
    borrowedBy?: LibraryStudentUpdateOneRequiredWithoutLibraryBookCopiesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryBorrowingHistories?: LibraryBorrowingHistoryUpdateManyWithoutCopyNestedInput
  }

  export type LibraryBookCopyUncheckedUpdateWithoutLibraryRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryBookId?: IntFieldUpdateOperationsInput | number
    libraryUniversityId?: IntFieldUpdateOperationsInput | number
    libraryStudentId?: IntFieldUpdateOperationsInput | number
    libraryBorrowingHistories?: LibraryBorrowingHistoryUncheckedUpdateManyWithoutCopyNestedInput
  }

  export type LibraryUniversityUpsertWithoutFromLibraryRequestsInput = {
    update: XOR<LibraryUniversityUpdateWithoutFromLibraryRequestsInput, LibraryUniversityUncheckedUpdateWithoutFromLibraryRequestsInput>
    create: XOR<LibraryUniversityCreateWithoutFromLibraryRequestsInput, LibraryUniversityUncheckedCreateWithoutFromLibraryRequestsInput>
  }

  export type LibraryUniversityUpdateWithoutFromLibraryRequestsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryStudenta?: LibraryStudentUpdateManyWithoutUniversityNestedInput
    libraryBookCopies?: LibraryBookCopyUpdateManyWithoutUniversityNestedInput
    libraryBorrowingHistories?: LibraryBorrowingHistoryUpdateManyWithoutBorrowedFromNestedInput
    toLibraryRequests?: LibraryRequestUpdateManyWithoutToNestedInput
  }

  export type LibraryUniversityUncheckedUpdateWithoutFromLibraryRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryStudenta?: LibraryStudentUncheckedUpdateManyWithoutUniversityNestedInput
    libraryBookCopies?: LibraryBookCopyUncheckedUpdateManyWithoutUniversityNestedInput
    libraryBorrowingHistories?: LibraryBorrowingHistoryUncheckedUpdateManyWithoutBorrowedFromNestedInput
    toLibraryRequests?: LibraryRequestUncheckedUpdateManyWithoutToNestedInput
  }

  export type LibraryUniversityUpsertWithoutToLibraryRequestsInput = {
    update: XOR<LibraryUniversityUpdateWithoutToLibraryRequestsInput, LibraryUniversityUncheckedUpdateWithoutToLibraryRequestsInput>
    create: XOR<LibraryUniversityCreateWithoutToLibraryRequestsInput, LibraryUniversityUncheckedCreateWithoutToLibraryRequestsInput>
  }

  export type LibraryUniversityUpdateWithoutToLibraryRequestsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryStudenta?: LibraryStudentUpdateManyWithoutUniversityNestedInput
    libraryBookCopies?: LibraryBookCopyUpdateManyWithoutUniversityNestedInput
    libraryBorrowingHistories?: LibraryBorrowingHistoryUpdateManyWithoutBorrowedFromNestedInput
    fromLibraryRequests?: LibraryRequestUpdateManyWithoutFromNestedInput
  }

  export type LibraryUniversityUncheckedUpdateWithoutToLibraryRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryStudenta?: LibraryStudentUncheckedUpdateManyWithoutUniversityNestedInput
    libraryBookCopies?: LibraryBookCopyUncheckedUpdateManyWithoutUniversityNestedInput
    libraryBorrowingHistories?: LibraryBorrowingHistoryUncheckedUpdateManyWithoutBorrowedFromNestedInput
    fromLibraryRequests?: LibraryRequestUncheckedUpdateManyWithoutFromNestedInput
  }

  export type QuizQuestionCreateWithoutCategoryInput = {
    name: string
    answerId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    quizChoices?: QuizChoiceCreateNestedManyWithoutQuestionInput
    quizRecords?: QuizRecordCreateNestedManyWithoutQuestionInput
  }

  export type QuizQuestionUncheckedCreateWithoutCategoryInput = {
    id?: number
    name: string
    answerId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    quizChoices?: QuizChoiceUncheckedCreateNestedManyWithoutQuestionInput
    quizRecords?: QuizRecordUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuizQuestionCreateOrConnectWithoutCategoryInput = {
    where: QuizQuestionWhereUniqueInput
    create: XOR<QuizQuestionCreateWithoutCategoryInput, QuizQuestionUncheckedCreateWithoutCategoryInput>
  }

  export type QuizQuestionCreateManyCategoryInputEnvelope = {
    data: Enumerable<QuizQuestionCreateManyCategoryInput>
    skipDuplicates?: boolean
  }

  export type QuizRoundCreateWithoutCategoryInput = {
    name: string
    totalScore: string
    createdAt?: Date | string
    updatedAt?: Date | string
    quizRecords?: QuizRecordCreateNestedManyWithoutRoundInput
  }

  export type QuizRoundUncheckedCreateWithoutCategoryInput = {
    id?: number
    name: string
    totalScore: string
    createdAt?: Date | string
    updatedAt?: Date | string
    quizRecords?: QuizRecordUncheckedCreateNestedManyWithoutRoundInput
  }

  export type QuizRoundCreateOrConnectWithoutCategoryInput = {
    where: QuizRoundWhereUniqueInput
    create: XOR<QuizRoundCreateWithoutCategoryInput, QuizRoundUncheckedCreateWithoutCategoryInput>
  }

  export type QuizRoundCreateManyCategoryInputEnvelope = {
    data: Enumerable<QuizRoundCreateManyCategoryInput>
    skipDuplicates?: boolean
  }

  export type QuizQuestionUpsertWithWhereUniqueWithoutCategoryInput = {
    where: QuizQuestionWhereUniqueInput
    update: XOR<QuizQuestionUpdateWithoutCategoryInput, QuizQuestionUncheckedUpdateWithoutCategoryInput>
    create: XOR<QuizQuestionCreateWithoutCategoryInput, QuizQuestionUncheckedCreateWithoutCategoryInput>
  }

  export type QuizQuestionUpdateWithWhereUniqueWithoutCategoryInput = {
    where: QuizQuestionWhereUniqueInput
    data: XOR<QuizQuestionUpdateWithoutCategoryInput, QuizQuestionUncheckedUpdateWithoutCategoryInput>
  }

  export type QuizQuestionUpdateManyWithWhereWithoutCategoryInput = {
    where: QuizQuestionScalarWhereInput
    data: XOR<QuizQuestionUpdateManyMutationInput, QuizQuestionUncheckedUpdateManyWithoutQuizQuestionInput>
  }

  export type QuizQuestionScalarWhereInput = {
    AND?: Enumerable<QuizQuestionScalarWhereInput>
    OR?: Enumerable<QuizQuestionScalarWhereInput>
    NOT?: Enumerable<QuizQuestionScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    answerId?: IntFilter | number
    quizCategoryId?: IntNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type QuizRoundUpsertWithWhereUniqueWithoutCategoryInput = {
    where: QuizRoundWhereUniqueInput
    update: XOR<QuizRoundUpdateWithoutCategoryInput, QuizRoundUncheckedUpdateWithoutCategoryInput>
    create: XOR<QuizRoundCreateWithoutCategoryInput, QuizRoundUncheckedCreateWithoutCategoryInput>
  }

  export type QuizRoundUpdateWithWhereUniqueWithoutCategoryInput = {
    where: QuizRoundWhereUniqueInput
    data: XOR<QuizRoundUpdateWithoutCategoryInput, QuizRoundUncheckedUpdateWithoutCategoryInput>
  }

  export type QuizRoundUpdateManyWithWhereWithoutCategoryInput = {
    where: QuizRoundScalarWhereInput
    data: XOR<QuizRoundUpdateManyMutationInput, QuizRoundUncheckedUpdateManyWithoutQuizRoundInput>
  }

  export type QuizRoundScalarWhereInput = {
    AND?: Enumerable<QuizRoundScalarWhereInput>
    OR?: Enumerable<QuizRoundScalarWhereInput>
    NOT?: Enumerable<QuizRoundScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    totalScore?: StringFilter | string
    quizCategoryId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type QuizCategoryCreateWithoutQuizQuestionInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    QuizRound?: QuizRoundCreateNestedManyWithoutCategoryInput
  }

  export type QuizCategoryUncheckedCreateWithoutQuizQuestionInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    QuizRound?: QuizRoundUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type QuizCategoryCreateOrConnectWithoutQuizQuestionInput = {
    where: QuizCategoryWhereUniqueInput
    create: XOR<QuizCategoryCreateWithoutQuizQuestionInput, QuizCategoryUncheckedCreateWithoutQuizQuestionInput>
  }

  export type QuizChoiceCreateWithoutQuestionInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    quizRecords?: QuizRecordCreateNestedManyWithoutPlayerChoiceInput
  }

  export type QuizChoiceUncheckedCreateWithoutQuestionInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    quizRecords?: QuizRecordUncheckedCreateNestedManyWithoutPlayerChoiceInput
  }

  export type QuizChoiceCreateOrConnectWithoutQuestionInput = {
    where: QuizChoiceWhereUniqueInput
    create: XOR<QuizChoiceCreateWithoutQuestionInput, QuizChoiceUncheckedCreateWithoutQuestionInput>
  }

  export type QuizChoiceCreateManyQuestionInputEnvelope = {
    data: Enumerable<QuizChoiceCreateManyQuestionInput>
    skipDuplicates?: boolean
  }

  export type QuizRecordCreateWithoutQuestionInput = {
    round?: QuizRoundCreateNestedOneWithoutQuizRecordsInput
    playerChoice?: QuizChoiceCreateNestedOneWithoutQuizRecordsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizRecordUncheckedCreateWithoutQuestionInput = {
    id?: number
    quizRoundId: number
    quizChoiceId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizRecordCreateOrConnectWithoutQuestionInput = {
    where: QuizRecordWhereUniqueInput
    create: XOR<QuizRecordCreateWithoutQuestionInput, QuizRecordUncheckedCreateWithoutQuestionInput>
  }

  export type QuizRecordCreateManyQuestionInputEnvelope = {
    data: Enumerable<QuizRecordCreateManyQuestionInput>
    skipDuplicates?: boolean
  }

  export type QuizCategoryUpsertWithoutQuizQuestionInput = {
    update: XOR<QuizCategoryUpdateWithoutQuizQuestionInput, QuizCategoryUncheckedUpdateWithoutQuizQuestionInput>
    create: XOR<QuizCategoryCreateWithoutQuizQuestionInput, QuizCategoryUncheckedCreateWithoutQuizQuestionInput>
  }

  export type QuizCategoryUpdateWithoutQuizQuestionInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    QuizRound?: QuizRoundUpdateManyWithoutCategoryNestedInput
  }

  export type QuizCategoryUncheckedUpdateWithoutQuizQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    QuizRound?: QuizRoundUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type QuizChoiceUpsertWithWhereUniqueWithoutQuestionInput = {
    where: QuizChoiceWhereUniqueInput
    update: XOR<QuizChoiceUpdateWithoutQuestionInput, QuizChoiceUncheckedUpdateWithoutQuestionInput>
    create: XOR<QuizChoiceCreateWithoutQuestionInput, QuizChoiceUncheckedCreateWithoutQuestionInput>
  }

  export type QuizChoiceUpdateWithWhereUniqueWithoutQuestionInput = {
    where: QuizChoiceWhereUniqueInput
    data: XOR<QuizChoiceUpdateWithoutQuestionInput, QuizChoiceUncheckedUpdateWithoutQuestionInput>
  }

  export type QuizChoiceUpdateManyWithWhereWithoutQuestionInput = {
    where: QuizChoiceScalarWhereInput
    data: XOR<QuizChoiceUpdateManyMutationInput, QuizChoiceUncheckedUpdateManyWithoutQuizChoicesInput>
  }

  export type QuizChoiceScalarWhereInput = {
    AND?: Enumerable<QuizChoiceScalarWhereInput>
    OR?: Enumerable<QuizChoiceScalarWhereInput>
    NOT?: Enumerable<QuizChoiceScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    quizQuestionId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type QuizRecordUpsertWithWhereUniqueWithoutQuestionInput = {
    where: QuizRecordWhereUniqueInput
    update: XOR<QuizRecordUpdateWithoutQuestionInput, QuizRecordUncheckedUpdateWithoutQuestionInput>
    create: XOR<QuizRecordCreateWithoutQuestionInput, QuizRecordUncheckedCreateWithoutQuestionInput>
  }

  export type QuizRecordUpdateWithWhereUniqueWithoutQuestionInput = {
    where: QuizRecordWhereUniqueInput
    data: XOR<QuizRecordUpdateWithoutQuestionInput, QuizRecordUncheckedUpdateWithoutQuestionInput>
  }

  export type QuizRecordUpdateManyWithWhereWithoutQuestionInput = {
    where: QuizRecordScalarWhereInput
    data: XOR<QuizRecordUpdateManyMutationInput, QuizRecordUncheckedUpdateManyWithoutQuizRecordsInput>
  }

  export type QuizRecordScalarWhereInput = {
    AND?: Enumerable<QuizRecordScalarWhereInput>
    OR?: Enumerable<QuizRecordScalarWhereInput>
    NOT?: Enumerable<QuizRecordScalarWhereInput>
    id?: IntFilter | number
    quizRoundId?: IntFilter | number
    quizChoiceId?: IntFilter | number
    quizQuestionId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type QuizQuestionCreateWithoutQuizChoicesInput = {
    name: string
    answerId: number
    category?: QuizCategoryCreateNestedOneWithoutQuizQuestionInput
    createdAt?: Date | string
    updatedAt?: Date | string
    quizRecords?: QuizRecordCreateNestedManyWithoutQuestionInput
  }

  export type QuizQuestionUncheckedCreateWithoutQuizChoicesInput = {
    id?: number
    name: string
    answerId: number
    quizCategoryId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quizRecords?: QuizRecordUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuizQuestionCreateOrConnectWithoutQuizChoicesInput = {
    where: QuizQuestionWhereUniqueInput
    create: XOR<QuizQuestionCreateWithoutQuizChoicesInput, QuizQuestionUncheckedCreateWithoutQuizChoicesInput>
  }

  export type QuizRecordCreateWithoutPlayerChoiceInput = {
    round?: QuizRoundCreateNestedOneWithoutQuizRecordsInput
    question?: QuizQuestionCreateNestedOneWithoutQuizRecordsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizRecordUncheckedCreateWithoutPlayerChoiceInput = {
    id?: number
    quizRoundId: number
    quizQuestionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizRecordCreateOrConnectWithoutPlayerChoiceInput = {
    where: QuizRecordWhereUniqueInput
    create: XOR<QuizRecordCreateWithoutPlayerChoiceInput, QuizRecordUncheckedCreateWithoutPlayerChoiceInput>
  }

  export type QuizRecordCreateManyPlayerChoiceInputEnvelope = {
    data: Enumerable<QuizRecordCreateManyPlayerChoiceInput>
    skipDuplicates?: boolean
  }

  export type QuizQuestionUpsertWithoutQuizChoicesInput = {
    update: XOR<QuizQuestionUpdateWithoutQuizChoicesInput, QuizQuestionUncheckedUpdateWithoutQuizChoicesInput>
    create: XOR<QuizQuestionCreateWithoutQuizChoicesInput, QuizQuestionUncheckedCreateWithoutQuizChoicesInput>
  }

  export type QuizQuestionUpdateWithoutQuizChoicesInput = {
    name?: StringFieldUpdateOperationsInput | string
    answerId?: IntFieldUpdateOperationsInput | number
    category?: QuizCategoryUpdateOneWithoutQuizQuestionNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizRecords?: QuizRecordUpdateManyWithoutQuestionNestedInput
  }

  export type QuizQuestionUncheckedUpdateWithoutQuizChoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    answerId?: IntFieldUpdateOperationsInput | number
    quizCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizRecords?: QuizRecordUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuizRecordUpsertWithWhereUniqueWithoutPlayerChoiceInput = {
    where: QuizRecordWhereUniqueInput
    update: XOR<QuizRecordUpdateWithoutPlayerChoiceInput, QuizRecordUncheckedUpdateWithoutPlayerChoiceInput>
    create: XOR<QuizRecordCreateWithoutPlayerChoiceInput, QuizRecordUncheckedCreateWithoutPlayerChoiceInput>
  }

  export type QuizRecordUpdateWithWhereUniqueWithoutPlayerChoiceInput = {
    where: QuizRecordWhereUniqueInput
    data: XOR<QuizRecordUpdateWithoutPlayerChoiceInput, QuizRecordUncheckedUpdateWithoutPlayerChoiceInput>
  }

  export type QuizRecordUpdateManyWithWhereWithoutPlayerChoiceInput = {
    where: QuizRecordScalarWhereInput
    data: XOR<QuizRecordUpdateManyMutationInput, QuizRecordUncheckedUpdateManyWithoutQuizRecordsInput>
  }

  export type QuizCategoryCreateWithoutQuizRoundInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    QuizQuestion?: QuizQuestionCreateNestedManyWithoutCategoryInput
  }

  export type QuizCategoryUncheckedCreateWithoutQuizRoundInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    QuizQuestion?: QuizQuestionUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type QuizCategoryCreateOrConnectWithoutQuizRoundInput = {
    where: QuizCategoryWhereUniqueInput
    create: XOR<QuizCategoryCreateWithoutQuizRoundInput, QuizCategoryUncheckedCreateWithoutQuizRoundInput>
  }

  export type QuizRecordCreateWithoutRoundInput = {
    playerChoice?: QuizChoiceCreateNestedOneWithoutQuizRecordsInput
    question?: QuizQuestionCreateNestedOneWithoutQuizRecordsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizRecordUncheckedCreateWithoutRoundInput = {
    id?: number
    quizChoiceId: number
    quizQuestionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizRecordCreateOrConnectWithoutRoundInput = {
    where: QuizRecordWhereUniqueInput
    create: XOR<QuizRecordCreateWithoutRoundInput, QuizRecordUncheckedCreateWithoutRoundInput>
  }

  export type QuizRecordCreateManyRoundInputEnvelope = {
    data: Enumerable<QuizRecordCreateManyRoundInput>
    skipDuplicates?: boolean
  }

  export type QuizCategoryUpsertWithoutQuizRoundInput = {
    update: XOR<QuizCategoryUpdateWithoutQuizRoundInput, QuizCategoryUncheckedUpdateWithoutQuizRoundInput>
    create: XOR<QuizCategoryCreateWithoutQuizRoundInput, QuizCategoryUncheckedCreateWithoutQuizRoundInput>
  }

  export type QuizCategoryUpdateWithoutQuizRoundInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    QuizQuestion?: QuizQuestionUpdateManyWithoutCategoryNestedInput
  }

  export type QuizCategoryUncheckedUpdateWithoutQuizRoundInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    QuizQuestion?: QuizQuestionUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type QuizRecordUpsertWithWhereUniqueWithoutRoundInput = {
    where: QuizRecordWhereUniqueInput
    update: XOR<QuizRecordUpdateWithoutRoundInput, QuizRecordUncheckedUpdateWithoutRoundInput>
    create: XOR<QuizRecordCreateWithoutRoundInput, QuizRecordUncheckedCreateWithoutRoundInput>
  }

  export type QuizRecordUpdateWithWhereUniqueWithoutRoundInput = {
    where: QuizRecordWhereUniqueInput
    data: XOR<QuizRecordUpdateWithoutRoundInput, QuizRecordUncheckedUpdateWithoutRoundInput>
  }

  export type QuizRecordUpdateManyWithWhereWithoutRoundInput = {
    where: QuizRecordScalarWhereInput
    data: XOR<QuizRecordUpdateManyMutationInput, QuizRecordUncheckedUpdateManyWithoutQuizRecordsInput>
  }

  export type QuizRoundCreateWithoutQuizRecordsInput = {
    name: string
    totalScore: string
    category?: QuizCategoryCreateNestedOneWithoutQuizRoundInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizRoundUncheckedCreateWithoutQuizRecordsInput = {
    id?: number
    name: string
    totalScore: string
    quizCategoryId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizRoundCreateOrConnectWithoutQuizRecordsInput = {
    where: QuizRoundWhereUniqueInput
    create: XOR<QuizRoundCreateWithoutQuizRecordsInput, QuizRoundUncheckedCreateWithoutQuizRecordsInput>
  }

  export type QuizChoiceCreateWithoutQuizRecordsInput = {
    name: string
    question?: QuizQuestionCreateNestedOneWithoutQuizChoicesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizChoiceUncheckedCreateWithoutQuizRecordsInput = {
    id?: number
    name: string
    quizQuestionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizChoiceCreateOrConnectWithoutQuizRecordsInput = {
    where: QuizChoiceWhereUniqueInput
    create: XOR<QuizChoiceCreateWithoutQuizRecordsInput, QuizChoiceUncheckedCreateWithoutQuizRecordsInput>
  }

  export type QuizQuestionCreateWithoutQuizRecordsInput = {
    name: string
    answerId: number
    category?: QuizCategoryCreateNestedOneWithoutQuizQuestionInput
    createdAt?: Date | string
    updatedAt?: Date | string
    quizChoices?: QuizChoiceCreateNestedManyWithoutQuestionInput
  }

  export type QuizQuestionUncheckedCreateWithoutQuizRecordsInput = {
    id?: number
    name: string
    answerId: number
    quizCategoryId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quizChoices?: QuizChoiceUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuizQuestionCreateOrConnectWithoutQuizRecordsInput = {
    where: QuizQuestionWhereUniqueInput
    create: XOR<QuizQuestionCreateWithoutQuizRecordsInput, QuizQuestionUncheckedCreateWithoutQuizRecordsInput>
  }

  export type QuizRoundUpsertWithoutQuizRecordsInput = {
    update: XOR<QuizRoundUpdateWithoutQuizRecordsInput, QuizRoundUncheckedUpdateWithoutQuizRecordsInput>
    create: XOR<QuizRoundCreateWithoutQuizRecordsInput, QuizRoundUncheckedCreateWithoutQuizRecordsInput>
  }

  export type QuizRoundUpdateWithoutQuizRecordsInput = {
    name?: StringFieldUpdateOperationsInput | string
    totalScore?: StringFieldUpdateOperationsInput | string
    category?: QuizCategoryUpdateOneWithoutQuizRoundNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizRoundUncheckedUpdateWithoutQuizRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    totalScore?: StringFieldUpdateOperationsInput | string
    quizCategoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizChoiceUpsertWithoutQuizRecordsInput = {
    update: XOR<QuizChoiceUpdateWithoutQuizRecordsInput, QuizChoiceUncheckedUpdateWithoutQuizRecordsInput>
    create: XOR<QuizChoiceCreateWithoutQuizRecordsInput, QuizChoiceUncheckedCreateWithoutQuizRecordsInput>
  }

  export type QuizChoiceUpdateWithoutQuizRecordsInput = {
    name?: StringFieldUpdateOperationsInput | string
    question?: QuizQuestionUpdateOneWithoutQuizChoicesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizChoiceUncheckedUpdateWithoutQuizRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    quizQuestionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizQuestionUpsertWithoutQuizRecordsInput = {
    update: XOR<QuizQuestionUpdateWithoutQuizRecordsInput, QuizQuestionUncheckedUpdateWithoutQuizRecordsInput>
    create: XOR<QuizQuestionCreateWithoutQuizRecordsInput, QuizQuestionUncheckedCreateWithoutQuizRecordsInput>
  }

  export type QuizQuestionUpdateWithoutQuizRecordsInput = {
    name?: StringFieldUpdateOperationsInput | string
    answerId?: IntFieldUpdateOperationsInput | number
    category?: QuizCategoryUpdateOneWithoutQuizQuestionNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizChoices?: QuizChoiceUpdateManyWithoutQuestionNestedInput
  }

  export type QuizQuestionUncheckedUpdateWithoutQuizRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    answerId?: IntFieldUpdateOperationsInput | number
    quizCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizChoices?: QuizChoiceUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type TwitterPostCreateWithoutUserInput = {
    post: string
    createdAt?: Date | string
    updatedAt?: Date | string
    postToHashtags?: TwitterPostToHashtagCreateNestedManyWithoutPostInput
    comments?: TwitterCommentCreateNestedManyWithoutPostInput
  }

  export type TwitterPostUncheckedCreateWithoutUserInput = {
    id?: number
    post: string
    createdAt?: Date | string
    updatedAt?: Date | string
    postToHashtags?: TwitterPostToHashtagUncheckedCreateNestedManyWithoutPostInput
    comments?: TwitterCommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type TwitterPostCreateOrConnectWithoutUserInput = {
    where: TwitterPostWhereUniqueInput
    create: XOR<TwitterPostCreateWithoutUserInput, TwitterPostUncheckedCreateWithoutUserInput>
  }

  export type TwitterPostCreateManyUserInputEnvelope = {
    data: Enumerable<TwitterPostCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type TwitterDirectMessageCreateWithoutFromInput = {
    message: string
    to: TwitterUserCreateNestedOneWithoutToDirectMessagesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterDirectMessageUncheckedCreateWithoutFromInput = {
    id?: number
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    followerUserId: number
  }

  export type TwitterDirectMessageCreateOrConnectWithoutFromInput = {
    where: TwitterDirectMessageWhereUniqueInput
    create: XOR<TwitterDirectMessageCreateWithoutFromInput, TwitterDirectMessageUncheckedCreateWithoutFromInput>
  }

  export type TwitterDirectMessageCreateManyFromInputEnvelope = {
    data: Enumerable<TwitterDirectMessageCreateManyFromInput>
    skipDuplicates?: boolean
  }

  export type TwitterCommentCreateWithoutUserInput = {
    post: TwitterPostCreateNestedOneWithoutCommentsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterCommentUncheckedCreateWithoutUserInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    twitterPostId: number
  }

  export type TwitterCommentCreateOrConnectWithoutUserInput = {
    where: TwitterCommentWhereUniqueInput
    create: XOR<TwitterCommentCreateWithoutUserInput, TwitterCommentUncheckedCreateWithoutUserInput>
  }

  export type TwitterCommentCreateManyUserInputEnvelope = {
    data: Enumerable<TwitterCommentCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type TwitterDirectMessageCreateWithoutToInput = {
    message: string
    from: TwitterUserCreateNestedOneWithoutFromDirectMessagesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterDirectMessageUncheckedCreateWithoutToInput = {
    id?: number
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    followingUserId: number
  }

  export type TwitterDirectMessageCreateOrConnectWithoutToInput = {
    where: TwitterDirectMessageWhereUniqueInput
    create: XOR<TwitterDirectMessageCreateWithoutToInput, TwitterDirectMessageUncheckedCreateWithoutToInput>
  }

  export type TwitterDirectMessageCreateManyToInputEnvelope = {
    data: Enumerable<TwitterDirectMessageCreateManyToInput>
    skipDuplicates?: boolean
  }

  export type TwitterUserRelationCreateWithoutFromInput = {
    to: TwitterUserCreateNestedOneWithoutFollowerUserRelationsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterUserRelationUncheckedCreateWithoutFromInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    toUserId: number
  }

  export type TwitterUserRelationCreateOrConnectWithoutFromInput = {
    where: TwitterUserRelationWhereUniqueInput
    create: XOR<TwitterUserRelationCreateWithoutFromInput, TwitterUserRelationUncheckedCreateWithoutFromInput>
  }

  export type TwitterUserRelationCreateManyFromInputEnvelope = {
    data: Enumerable<TwitterUserRelationCreateManyFromInput>
    skipDuplicates?: boolean
  }

  export type TwitterUserRelationCreateWithoutToInput = {
    from: TwitterUserCreateNestedOneWithoutFollowingUserRelationsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterUserRelationUncheckedCreateWithoutToInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    fromUserId: number
  }

  export type TwitterUserRelationCreateOrConnectWithoutToInput = {
    where: TwitterUserRelationWhereUniqueInput
    create: XOR<TwitterUserRelationCreateWithoutToInput, TwitterUserRelationUncheckedCreateWithoutToInput>
  }

  export type TwitterUserRelationCreateManyToInputEnvelope = {
    data: Enumerable<TwitterUserRelationCreateManyToInput>
    skipDuplicates?: boolean
  }

  export type TwitterPostUpsertWithWhereUniqueWithoutUserInput = {
    where: TwitterPostWhereUniqueInput
    update: XOR<TwitterPostUpdateWithoutUserInput, TwitterPostUncheckedUpdateWithoutUserInput>
    create: XOR<TwitterPostCreateWithoutUserInput, TwitterPostUncheckedCreateWithoutUserInput>
  }

  export type TwitterPostUpdateWithWhereUniqueWithoutUserInput = {
    where: TwitterPostWhereUniqueInput
    data: XOR<TwitterPostUpdateWithoutUserInput, TwitterPostUncheckedUpdateWithoutUserInput>
  }

  export type TwitterPostUpdateManyWithWhereWithoutUserInput = {
    where: TwitterPostScalarWhereInput
    data: XOR<TwitterPostUpdateManyMutationInput, TwitterPostUncheckedUpdateManyWithoutPostsInput>
  }

  export type TwitterPostScalarWhereInput = {
    AND?: Enumerable<TwitterPostScalarWhereInput>
    OR?: Enumerable<TwitterPostScalarWhereInput>
    NOT?: Enumerable<TwitterPostScalarWhereInput>
    id?: IntFilter | number
    post?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    twitterUserId?: IntFilter | number
  }

  export type TwitterDirectMessageUpsertWithWhereUniqueWithoutFromInput = {
    where: TwitterDirectMessageWhereUniqueInput
    update: XOR<TwitterDirectMessageUpdateWithoutFromInput, TwitterDirectMessageUncheckedUpdateWithoutFromInput>
    create: XOR<TwitterDirectMessageCreateWithoutFromInput, TwitterDirectMessageUncheckedCreateWithoutFromInput>
  }

  export type TwitterDirectMessageUpdateWithWhereUniqueWithoutFromInput = {
    where: TwitterDirectMessageWhereUniqueInput
    data: XOR<TwitterDirectMessageUpdateWithoutFromInput, TwitterDirectMessageUncheckedUpdateWithoutFromInput>
  }

  export type TwitterDirectMessageUpdateManyWithWhereWithoutFromInput = {
    where: TwitterDirectMessageScalarWhereInput
    data: XOR<TwitterDirectMessageUpdateManyMutationInput, TwitterDirectMessageUncheckedUpdateManyWithoutFromDirectMessagesInput>
  }

  export type TwitterDirectMessageScalarWhereInput = {
    AND?: Enumerable<TwitterDirectMessageScalarWhereInput>
    OR?: Enumerable<TwitterDirectMessageScalarWhereInput>
    NOT?: Enumerable<TwitterDirectMessageScalarWhereInput>
    id?: IntFilter | number
    message?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    followingUserId?: IntFilter | number
    followerUserId?: IntFilter | number
  }

  export type TwitterCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: TwitterCommentWhereUniqueInput
    update: XOR<TwitterCommentUpdateWithoutUserInput, TwitterCommentUncheckedUpdateWithoutUserInput>
    create: XOR<TwitterCommentCreateWithoutUserInput, TwitterCommentUncheckedCreateWithoutUserInput>
  }

  export type TwitterCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: TwitterCommentWhereUniqueInput
    data: XOR<TwitterCommentUpdateWithoutUserInput, TwitterCommentUncheckedUpdateWithoutUserInput>
  }

  export type TwitterCommentUpdateManyWithWhereWithoutUserInput = {
    where: TwitterCommentScalarWhereInput
    data: XOR<TwitterCommentUpdateManyMutationInput, TwitterCommentUncheckedUpdateManyWithoutCommentsInput>
  }

  export type TwitterCommentScalarWhereInput = {
    AND?: Enumerable<TwitterCommentScalarWhereInput>
    OR?: Enumerable<TwitterCommentScalarWhereInput>
    NOT?: Enumerable<TwitterCommentScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    twitterPostId?: IntFilter | number
    twitterUserId?: IntFilter | number
  }

  export type TwitterDirectMessageUpsertWithWhereUniqueWithoutToInput = {
    where: TwitterDirectMessageWhereUniqueInput
    update: XOR<TwitterDirectMessageUpdateWithoutToInput, TwitterDirectMessageUncheckedUpdateWithoutToInput>
    create: XOR<TwitterDirectMessageCreateWithoutToInput, TwitterDirectMessageUncheckedCreateWithoutToInput>
  }

  export type TwitterDirectMessageUpdateWithWhereUniqueWithoutToInput = {
    where: TwitterDirectMessageWhereUniqueInput
    data: XOR<TwitterDirectMessageUpdateWithoutToInput, TwitterDirectMessageUncheckedUpdateWithoutToInput>
  }

  export type TwitterDirectMessageUpdateManyWithWhereWithoutToInput = {
    where: TwitterDirectMessageScalarWhereInput
    data: XOR<TwitterDirectMessageUpdateManyMutationInput, TwitterDirectMessageUncheckedUpdateManyWithoutToDirectMessagesInput>
  }

  export type TwitterUserRelationUpsertWithWhereUniqueWithoutFromInput = {
    where: TwitterUserRelationWhereUniqueInput
    update: XOR<TwitterUserRelationUpdateWithoutFromInput, TwitterUserRelationUncheckedUpdateWithoutFromInput>
    create: XOR<TwitterUserRelationCreateWithoutFromInput, TwitterUserRelationUncheckedCreateWithoutFromInput>
  }

  export type TwitterUserRelationUpdateWithWhereUniqueWithoutFromInput = {
    where: TwitterUserRelationWhereUniqueInput
    data: XOR<TwitterUserRelationUpdateWithoutFromInput, TwitterUserRelationUncheckedUpdateWithoutFromInput>
  }

  export type TwitterUserRelationUpdateManyWithWhereWithoutFromInput = {
    where: TwitterUserRelationScalarWhereInput
    data: XOR<TwitterUserRelationUpdateManyMutationInput, TwitterUserRelationUncheckedUpdateManyWithoutFollowingUserRelationsInput>
  }

  export type TwitterUserRelationScalarWhereInput = {
    AND?: Enumerable<TwitterUserRelationScalarWhereInput>
    OR?: Enumerable<TwitterUserRelationScalarWhereInput>
    NOT?: Enumerable<TwitterUserRelationScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    fromUserId?: IntFilter | number
    toUserId?: IntFilter | number
  }

  export type TwitterUserRelationUpsertWithWhereUniqueWithoutToInput = {
    where: TwitterUserRelationWhereUniqueInput
    update: XOR<TwitterUserRelationUpdateWithoutToInput, TwitterUserRelationUncheckedUpdateWithoutToInput>
    create: XOR<TwitterUserRelationCreateWithoutToInput, TwitterUserRelationUncheckedCreateWithoutToInput>
  }

  export type TwitterUserRelationUpdateWithWhereUniqueWithoutToInput = {
    where: TwitterUserRelationWhereUniqueInput
    data: XOR<TwitterUserRelationUpdateWithoutToInput, TwitterUserRelationUncheckedUpdateWithoutToInput>
  }

  export type TwitterUserRelationUpdateManyWithWhereWithoutToInput = {
    where: TwitterUserRelationScalarWhereInput
    data: XOR<TwitterUserRelationUpdateManyMutationInput, TwitterUserRelationUncheckedUpdateManyWithoutFollowerUserRelationsInput>
  }

  export type TwitterUserCreateWithoutPostsInput = {
    name: string
    image: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fromDirectMessages?: TwitterDirectMessageCreateNestedManyWithoutFromInput
    comments?: TwitterCommentCreateNestedManyWithoutUserInput
    toDirectMessages?: TwitterDirectMessageCreateNestedManyWithoutToInput
    followingUserRelations?: TwitterUserRelationCreateNestedManyWithoutFromInput
    followerUserRelations?: TwitterUserRelationCreateNestedManyWithoutToInput
  }

  export type TwitterUserUncheckedCreateWithoutPostsInput = {
    id?: number
    name: string
    image: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fromDirectMessages?: TwitterDirectMessageUncheckedCreateNestedManyWithoutFromInput
    comments?: TwitterCommentUncheckedCreateNestedManyWithoutUserInput
    toDirectMessages?: TwitterDirectMessageUncheckedCreateNestedManyWithoutToInput
    followingUserRelations?: TwitterUserRelationUncheckedCreateNestedManyWithoutFromInput
    followerUserRelations?: TwitterUserRelationUncheckedCreateNestedManyWithoutToInput
  }

  export type TwitterUserCreateOrConnectWithoutPostsInput = {
    where: TwitterUserWhereUniqueInput
    create: XOR<TwitterUserCreateWithoutPostsInput, TwitterUserUncheckedCreateWithoutPostsInput>
  }

  export type TwitterPostToHashtagCreateWithoutPostInput = {
    hashtag: TwitterHashtagCreateNestedOneWithoutPostsToHashtagsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterPostToHashtagUncheckedCreateWithoutPostInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    twitterHashtagId: number
  }

  export type TwitterPostToHashtagCreateOrConnectWithoutPostInput = {
    where: TwitterPostToHashtagWhereUniqueInput
    create: XOR<TwitterPostToHashtagCreateWithoutPostInput, TwitterPostToHashtagUncheckedCreateWithoutPostInput>
  }

  export type TwitterPostToHashtagCreateManyPostInputEnvelope = {
    data: Enumerable<TwitterPostToHashtagCreateManyPostInput>
    skipDuplicates?: boolean
  }

  export type TwitterCommentCreateWithoutPostInput = {
    user: TwitterUserCreateNestedOneWithoutCommentsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterCommentUncheckedCreateWithoutPostInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    twitterUserId: number
  }

  export type TwitterCommentCreateOrConnectWithoutPostInput = {
    where: TwitterCommentWhereUniqueInput
    create: XOR<TwitterCommentCreateWithoutPostInput, TwitterCommentUncheckedCreateWithoutPostInput>
  }

  export type TwitterCommentCreateManyPostInputEnvelope = {
    data: Enumerable<TwitterCommentCreateManyPostInput>
    skipDuplicates?: boolean
  }

  export type TwitterUserUpsertWithoutPostsInput = {
    update: XOR<TwitterUserUpdateWithoutPostsInput, TwitterUserUncheckedUpdateWithoutPostsInput>
    create: XOR<TwitterUserCreateWithoutPostsInput, TwitterUserUncheckedCreateWithoutPostsInput>
  }

  export type TwitterUserUpdateWithoutPostsInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromDirectMessages?: TwitterDirectMessageUpdateManyWithoutFromNestedInput
    comments?: TwitterCommentUpdateManyWithoutUserNestedInput
    toDirectMessages?: TwitterDirectMessageUpdateManyWithoutToNestedInput
    followingUserRelations?: TwitterUserRelationUpdateManyWithoutFromNestedInput
    followerUserRelations?: TwitterUserRelationUpdateManyWithoutToNestedInput
  }

  export type TwitterUserUncheckedUpdateWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromDirectMessages?: TwitterDirectMessageUncheckedUpdateManyWithoutFromNestedInput
    comments?: TwitterCommentUncheckedUpdateManyWithoutUserNestedInput
    toDirectMessages?: TwitterDirectMessageUncheckedUpdateManyWithoutToNestedInput
    followingUserRelations?: TwitterUserRelationUncheckedUpdateManyWithoutFromNestedInput
    followerUserRelations?: TwitterUserRelationUncheckedUpdateManyWithoutToNestedInput
  }

  export type TwitterPostToHashtagUpsertWithWhereUniqueWithoutPostInput = {
    where: TwitterPostToHashtagWhereUniqueInput
    update: XOR<TwitterPostToHashtagUpdateWithoutPostInput, TwitterPostToHashtagUncheckedUpdateWithoutPostInput>
    create: XOR<TwitterPostToHashtagCreateWithoutPostInput, TwitterPostToHashtagUncheckedCreateWithoutPostInput>
  }

  export type TwitterPostToHashtagUpdateWithWhereUniqueWithoutPostInput = {
    where: TwitterPostToHashtagWhereUniqueInput
    data: XOR<TwitterPostToHashtagUpdateWithoutPostInput, TwitterPostToHashtagUncheckedUpdateWithoutPostInput>
  }

  export type TwitterPostToHashtagUpdateManyWithWhereWithoutPostInput = {
    where: TwitterPostToHashtagScalarWhereInput
    data: XOR<TwitterPostToHashtagUpdateManyMutationInput, TwitterPostToHashtagUncheckedUpdateManyWithoutPostToHashtagsInput>
  }

  export type TwitterPostToHashtagScalarWhereInput = {
    AND?: Enumerable<TwitterPostToHashtagScalarWhereInput>
    OR?: Enumerable<TwitterPostToHashtagScalarWhereInput>
    NOT?: Enumerable<TwitterPostToHashtagScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    twitterPostId?: IntFilter | number
    twitterHashtagId?: IntFilter | number
  }

  export type TwitterCommentUpsertWithWhereUniqueWithoutPostInput = {
    where: TwitterCommentWhereUniqueInput
    update: XOR<TwitterCommentUpdateWithoutPostInput, TwitterCommentUncheckedUpdateWithoutPostInput>
    create: XOR<TwitterCommentCreateWithoutPostInput, TwitterCommentUncheckedCreateWithoutPostInput>
  }

  export type TwitterCommentUpdateWithWhereUniqueWithoutPostInput = {
    where: TwitterCommentWhereUniqueInput
    data: XOR<TwitterCommentUpdateWithoutPostInput, TwitterCommentUncheckedUpdateWithoutPostInput>
  }

  export type TwitterCommentUpdateManyWithWhereWithoutPostInput = {
    where: TwitterCommentScalarWhereInput
    data: XOR<TwitterCommentUpdateManyMutationInput, TwitterCommentUncheckedUpdateManyWithoutCommentsInput>
  }

  export type TwitterPostToHashtagCreateWithoutHashtagInput = {
    post: TwitterPostCreateNestedOneWithoutPostToHashtagsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterPostToHashtagUncheckedCreateWithoutHashtagInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    twitterPostId: number
  }

  export type TwitterPostToHashtagCreateOrConnectWithoutHashtagInput = {
    where: TwitterPostToHashtagWhereUniqueInput
    create: XOR<TwitterPostToHashtagCreateWithoutHashtagInput, TwitterPostToHashtagUncheckedCreateWithoutHashtagInput>
  }

  export type TwitterPostToHashtagCreateManyHashtagInputEnvelope = {
    data: Enumerable<TwitterPostToHashtagCreateManyHashtagInput>
    skipDuplicates?: boolean
  }

  export type TwitterPostToHashtagUpsertWithWhereUniqueWithoutHashtagInput = {
    where: TwitterPostToHashtagWhereUniqueInput
    update: XOR<TwitterPostToHashtagUpdateWithoutHashtagInput, TwitterPostToHashtagUncheckedUpdateWithoutHashtagInput>
    create: XOR<TwitterPostToHashtagCreateWithoutHashtagInput, TwitterPostToHashtagUncheckedCreateWithoutHashtagInput>
  }

  export type TwitterPostToHashtagUpdateWithWhereUniqueWithoutHashtagInput = {
    where: TwitterPostToHashtagWhereUniqueInput
    data: XOR<TwitterPostToHashtagUpdateWithoutHashtagInput, TwitterPostToHashtagUncheckedUpdateWithoutHashtagInput>
  }

  export type TwitterPostToHashtagUpdateManyWithWhereWithoutHashtagInput = {
    where: TwitterPostToHashtagScalarWhereInput
    data: XOR<TwitterPostToHashtagUpdateManyMutationInput, TwitterPostToHashtagUncheckedUpdateManyWithoutPostsToHashtagsInput>
  }

  export type TwitterPostCreateWithoutPostToHashtagsInput = {
    user: TwitterUserCreateNestedOneWithoutPostsInput
    post: string
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: TwitterCommentCreateNestedManyWithoutPostInput
  }

  export type TwitterPostUncheckedCreateWithoutPostToHashtagsInput = {
    id?: number
    post: string
    createdAt?: Date | string
    updatedAt?: Date | string
    twitterUserId: number
    comments?: TwitterCommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type TwitterPostCreateOrConnectWithoutPostToHashtagsInput = {
    where: TwitterPostWhereUniqueInput
    create: XOR<TwitterPostCreateWithoutPostToHashtagsInput, TwitterPostUncheckedCreateWithoutPostToHashtagsInput>
  }

  export type TwitterHashtagCreateWithoutPostsToHashtagsInput = {
    hashtag: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterHashtagUncheckedCreateWithoutPostsToHashtagsInput = {
    id?: number
    hashtag: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterHashtagCreateOrConnectWithoutPostsToHashtagsInput = {
    where: TwitterHashtagWhereUniqueInput
    create: XOR<TwitterHashtagCreateWithoutPostsToHashtagsInput, TwitterHashtagUncheckedCreateWithoutPostsToHashtagsInput>
  }

  export type TwitterPostUpsertWithoutPostToHashtagsInput = {
    update: XOR<TwitterPostUpdateWithoutPostToHashtagsInput, TwitterPostUncheckedUpdateWithoutPostToHashtagsInput>
    create: XOR<TwitterPostCreateWithoutPostToHashtagsInput, TwitterPostUncheckedCreateWithoutPostToHashtagsInput>
  }

  export type TwitterPostUpdateWithoutPostToHashtagsInput = {
    user?: TwitterUserUpdateOneRequiredWithoutPostsNestedInput
    post?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: TwitterCommentUpdateManyWithoutPostNestedInput
  }

  export type TwitterPostUncheckedUpdateWithoutPostToHashtagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    post?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twitterUserId?: IntFieldUpdateOperationsInput | number
    comments?: TwitterCommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type TwitterHashtagUpsertWithoutPostsToHashtagsInput = {
    update: XOR<TwitterHashtagUpdateWithoutPostsToHashtagsInput, TwitterHashtagUncheckedUpdateWithoutPostsToHashtagsInput>
    create: XOR<TwitterHashtagCreateWithoutPostsToHashtagsInput, TwitterHashtagUncheckedCreateWithoutPostsToHashtagsInput>
  }

  export type TwitterHashtagUpdateWithoutPostsToHashtagsInput = {
    hashtag?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterHashtagUncheckedUpdateWithoutPostsToHashtagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    hashtag?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterUserCreateWithoutFromDirectMessagesInput = {
    name: string
    image: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: TwitterPostCreateNestedManyWithoutUserInput
    comments?: TwitterCommentCreateNestedManyWithoutUserInput
    toDirectMessages?: TwitterDirectMessageCreateNestedManyWithoutToInput
    followingUserRelations?: TwitterUserRelationCreateNestedManyWithoutFromInput
    followerUserRelations?: TwitterUserRelationCreateNestedManyWithoutToInput
  }

  export type TwitterUserUncheckedCreateWithoutFromDirectMessagesInput = {
    id?: number
    name: string
    image: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: TwitterPostUncheckedCreateNestedManyWithoutUserInput
    comments?: TwitterCommentUncheckedCreateNestedManyWithoutUserInput
    toDirectMessages?: TwitterDirectMessageUncheckedCreateNestedManyWithoutToInput
    followingUserRelations?: TwitterUserRelationUncheckedCreateNestedManyWithoutFromInput
    followerUserRelations?: TwitterUserRelationUncheckedCreateNestedManyWithoutToInput
  }

  export type TwitterUserCreateOrConnectWithoutFromDirectMessagesInput = {
    where: TwitterUserWhereUniqueInput
    create: XOR<TwitterUserCreateWithoutFromDirectMessagesInput, TwitterUserUncheckedCreateWithoutFromDirectMessagesInput>
  }

  export type TwitterUserCreateWithoutToDirectMessagesInput = {
    name: string
    image: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: TwitterPostCreateNestedManyWithoutUserInput
    fromDirectMessages?: TwitterDirectMessageCreateNestedManyWithoutFromInput
    comments?: TwitterCommentCreateNestedManyWithoutUserInput
    followingUserRelations?: TwitterUserRelationCreateNestedManyWithoutFromInput
    followerUserRelations?: TwitterUserRelationCreateNestedManyWithoutToInput
  }

  export type TwitterUserUncheckedCreateWithoutToDirectMessagesInput = {
    id?: number
    name: string
    image: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: TwitterPostUncheckedCreateNestedManyWithoutUserInput
    fromDirectMessages?: TwitterDirectMessageUncheckedCreateNestedManyWithoutFromInput
    comments?: TwitterCommentUncheckedCreateNestedManyWithoutUserInput
    followingUserRelations?: TwitterUserRelationUncheckedCreateNestedManyWithoutFromInput
    followerUserRelations?: TwitterUserRelationUncheckedCreateNestedManyWithoutToInput
  }

  export type TwitterUserCreateOrConnectWithoutToDirectMessagesInput = {
    where: TwitterUserWhereUniqueInput
    create: XOR<TwitterUserCreateWithoutToDirectMessagesInput, TwitterUserUncheckedCreateWithoutToDirectMessagesInput>
  }

  export type TwitterUserUpsertWithoutFromDirectMessagesInput = {
    update: XOR<TwitterUserUpdateWithoutFromDirectMessagesInput, TwitterUserUncheckedUpdateWithoutFromDirectMessagesInput>
    create: XOR<TwitterUserCreateWithoutFromDirectMessagesInput, TwitterUserUncheckedCreateWithoutFromDirectMessagesInput>
  }

  export type TwitterUserUpdateWithoutFromDirectMessagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: TwitterPostUpdateManyWithoutUserNestedInput
    comments?: TwitterCommentUpdateManyWithoutUserNestedInput
    toDirectMessages?: TwitterDirectMessageUpdateManyWithoutToNestedInput
    followingUserRelations?: TwitterUserRelationUpdateManyWithoutFromNestedInput
    followerUserRelations?: TwitterUserRelationUpdateManyWithoutToNestedInput
  }

  export type TwitterUserUncheckedUpdateWithoutFromDirectMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: TwitterPostUncheckedUpdateManyWithoutUserNestedInput
    comments?: TwitterCommentUncheckedUpdateManyWithoutUserNestedInput
    toDirectMessages?: TwitterDirectMessageUncheckedUpdateManyWithoutToNestedInput
    followingUserRelations?: TwitterUserRelationUncheckedUpdateManyWithoutFromNestedInput
    followerUserRelations?: TwitterUserRelationUncheckedUpdateManyWithoutToNestedInput
  }

  export type TwitterUserUpsertWithoutToDirectMessagesInput = {
    update: XOR<TwitterUserUpdateWithoutToDirectMessagesInput, TwitterUserUncheckedUpdateWithoutToDirectMessagesInput>
    create: XOR<TwitterUserCreateWithoutToDirectMessagesInput, TwitterUserUncheckedCreateWithoutToDirectMessagesInput>
  }

  export type TwitterUserUpdateWithoutToDirectMessagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: TwitterPostUpdateManyWithoutUserNestedInput
    fromDirectMessages?: TwitterDirectMessageUpdateManyWithoutFromNestedInput
    comments?: TwitterCommentUpdateManyWithoutUserNestedInput
    followingUserRelations?: TwitterUserRelationUpdateManyWithoutFromNestedInput
    followerUserRelations?: TwitterUserRelationUpdateManyWithoutToNestedInput
  }

  export type TwitterUserUncheckedUpdateWithoutToDirectMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: TwitterPostUncheckedUpdateManyWithoutUserNestedInput
    fromDirectMessages?: TwitterDirectMessageUncheckedUpdateManyWithoutFromNestedInput
    comments?: TwitterCommentUncheckedUpdateManyWithoutUserNestedInput
    followingUserRelations?: TwitterUserRelationUncheckedUpdateManyWithoutFromNestedInput
    followerUserRelations?: TwitterUserRelationUncheckedUpdateManyWithoutToNestedInput
  }

  export type TwitterUserCreateWithoutFollowingUserRelationsInput = {
    name: string
    image: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: TwitterPostCreateNestedManyWithoutUserInput
    fromDirectMessages?: TwitterDirectMessageCreateNestedManyWithoutFromInput
    comments?: TwitterCommentCreateNestedManyWithoutUserInput
    toDirectMessages?: TwitterDirectMessageCreateNestedManyWithoutToInput
    followerUserRelations?: TwitterUserRelationCreateNestedManyWithoutToInput
  }

  export type TwitterUserUncheckedCreateWithoutFollowingUserRelationsInput = {
    id?: number
    name: string
    image: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: TwitterPostUncheckedCreateNestedManyWithoutUserInput
    fromDirectMessages?: TwitterDirectMessageUncheckedCreateNestedManyWithoutFromInput
    comments?: TwitterCommentUncheckedCreateNestedManyWithoutUserInput
    toDirectMessages?: TwitterDirectMessageUncheckedCreateNestedManyWithoutToInput
    followerUserRelations?: TwitterUserRelationUncheckedCreateNestedManyWithoutToInput
  }

  export type TwitterUserCreateOrConnectWithoutFollowingUserRelationsInput = {
    where: TwitterUserWhereUniqueInput
    create: XOR<TwitterUserCreateWithoutFollowingUserRelationsInput, TwitterUserUncheckedCreateWithoutFollowingUserRelationsInput>
  }

  export type TwitterUserCreateWithoutFollowerUserRelationsInput = {
    name: string
    image: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: TwitterPostCreateNestedManyWithoutUserInput
    fromDirectMessages?: TwitterDirectMessageCreateNestedManyWithoutFromInput
    comments?: TwitterCommentCreateNestedManyWithoutUserInput
    toDirectMessages?: TwitterDirectMessageCreateNestedManyWithoutToInput
    followingUserRelations?: TwitterUserRelationCreateNestedManyWithoutFromInput
  }

  export type TwitterUserUncheckedCreateWithoutFollowerUserRelationsInput = {
    id?: number
    name: string
    image: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: TwitterPostUncheckedCreateNestedManyWithoutUserInput
    fromDirectMessages?: TwitterDirectMessageUncheckedCreateNestedManyWithoutFromInput
    comments?: TwitterCommentUncheckedCreateNestedManyWithoutUserInput
    toDirectMessages?: TwitterDirectMessageUncheckedCreateNestedManyWithoutToInput
    followingUserRelations?: TwitterUserRelationUncheckedCreateNestedManyWithoutFromInput
  }

  export type TwitterUserCreateOrConnectWithoutFollowerUserRelationsInput = {
    where: TwitterUserWhereUniqueInput
    create: XOR<TwitterUserCreateWithoutFollowerUserRelationsInput, TwitterUserUncheckedCreateWithoutFollowerUserRelationsInput>
  }

  export type TwitterUserUpsertWithoutFollowingUserRelationsInput = {
    update: XOR<TwitterUserUpdateWithoutFollowingUserRelationsInput, TwitterUserUncheckedUpdateWithoutFollowingUserRelationsInput>
    create: XOR<TwitterUserCreateWithoutFollowingUserRelationsInput, TwitterUserUncheckedCreateWithoutFollowingUserRelationsInput>
  }

  export type TwitterUserUpdateWithoutFollowingUserRelationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: TwitterPostUpdateManyWithoutUserNestedInput
    fromDirectMessages?: TwitterDirectMessageUpdateManyWithoutFromNestedInput
    comments?: TwitterCommentUpdateManyWithoutUserNestedInput
    toDirectMessages?: TwitterDirectMessageUpdateManyWithoutToNestedInput
    followerUserRelations?: TwitterUserRelationUpdateManyWithoutToNestedInput
  }

  export type TwitterUserUncheckedUpdateWithoutFollowingUserRelationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: TwitterPostUncheckedUpdateManyWithoutUserNestedInput
    fromDirectMessages?: TwitterDirectMessageUncheckedUpdateManyWithoutFromNestedInput
    comments?: TwitterCommentUncheckedUpdateManyWithoutUserNestedInput
    toDirectMessages?: TwitterDirectMessageUncheckedUpdateManyWithoutToNestedInput
    followerUserRelations?: TwitterUserRelationUncheckedUpdateManyWithoutToNestedInput
  }

  export type TwitterUserUpsertWithoutFollowerUserRelationsInput = {
    update: XOR<TwitterUserUpdateWithoutFollowerUserRelationsInput, TwitterUserUncheckedUpdateWithoutFollowerUserRelationsInput>
    create: XOR<TwitterUserCreateWithoutFollowerUserRelationsInput, TwitterUserUncheckedCreateWithoutFollowerUserRelationsInput>
  }

  export type TwitterUserUpdateWithoutFollowerUserRelationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: TwitterPostUpdateManyWithoutUserNestedInput
    fromDirectMessages?: TwitterDirectMessageUpdateManyWithoutFromNestedInput
    comments?: TwitterCommentUpdateManyWithoutUserNestedInput
    toDirectMessages?: TwitterDirectMessageUpdateManyWithoutToNestedInput
    followingUserRelations?: TwitterUserRelationUpdateManyWithoutFromNestedInput
  }

  export type TwitterUserUncheckedUpdateWithoutFollowerUserRelationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: TwitterPostUncheckedUpdateManyWithoutUserNestedInput
    fromDirectMessages?: TwitterDirectMessageUncheckedUpdateManyWithoutFromNestedInput
    comments?: TwitterCommentUncheckedUpdateManyWithoutUserNestedInput
    toDirectMessages?: TwitterDirectMessageUncheckedUpdateManyWithoutToNestedInput
    followingUserRelations?: TwitterUserRelationUncheckedUpdateManyWithoutFromNestedInput
  }

  export type TwitterPostCreateWithoutCommentsInput = {
    user: TwitterUserCreateNestedOneWithoutPostsInput
    post: string
    createdAt?: Date | string
    updatedAt?: Date | string
    postToHashtags?: TwitterPostToHashtagCreateNestedManyWithoutPostInput
  }

  export type TwitterPostUncheckedCreateWithoutCommentsInput = {
    id?: number
    post: string
    createdAt?: Date | string
    updatedAt?: Date | string
    twitterUserId: number
    postToHashtags?: TwitterPostToHashtagUncheckedCreateNestedManyWithoutPostInput
  }

  export type TwitterPostCreateOrConnectWithoutCommentsInput = {
    where: TwitterPostWhereUniqueInput
    create: XOR<TwitterPostCreateWithoutCommentsInput, TwitterPostUncheckedCreateWithoutCommentsInput>
  }

  export type TwitterUserCreateWithoutCommentsInput = {
    name: string
    image: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: TwitterPostCreateNestedManyWithoutUserInput
    fromDirectMessages?: TwitterDirectMessageCreateNestedManyWithoutFromInput
    toDirectMessages?: TwitterDirectMessageCreateNestedManyWithoutToInput
    followingUserRelations?: TwitterUserRelationCreateNestedManyWithoutFromInput
    followerUserRelations?: TwitterUserRelationCreateNestedManyWithoutToInput
  }

  export type TwitterUserUncheckedCreateWithoutCommentsInput = {
    id?: number
    name: string
    image: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: TwitterPostUncheckedCreateNestedManyWithoutUserInput
    fromDirectMessages?: TwitterDirectMessageUncheckedCreateNestedManyWithoutFromInput
    toDirectMessages?: TwitterDirectMessageUncheckedCreateNestedManyWithoutToInput
    followingUserRelations?: TwitterUserRelationUncheckedCreateNestedManyWithoutFromInput
    followerUserRelations?: TwitterUserRelationUncheckedCreateNestedManyWithoutToInput
  }

  export type TwitterUserCreateOrConnectWithoutCommentsInput = {
    where: TwitterUserWhereUniqueInput
    create: XOR<TwitterUserCreateWithoutCommentsInput, TwitterUserUncheckedCreateWithoutCommentsInput>
  }

  export type TwitterPostUpsertWithoutCommentsInput = {
    update: XOR<TwitterPostUpdateWithoutCommentsInput, TwitterPostUncheckedUpdateWithoutCommentsInput>
    create: XOR<TwitterPostCreateWithoutCommentsInput, TwitterPostUncheckedCreateWithoutCommentsInput>
  }

  export type TwitterPostUpdateWithoutCommentsInput = {
    user?: TwitterUserUpdateOneRequiredWithoutPostsNestedInput
    post?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postToHashtags?: TwitterPostToHashtagUpdateManyWithoutPostNestedInput
  }

  export type TwitterPostUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    post?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twitterUserId?: IntFieldUpdateOperationsInput | number
    postToHashtags?: TwitterPostToHashtagUncheckedUpdateManyWithoutPostNestedInput
  }

  export type TwitterUserUpsertWithoutCommentsInput = {
    update: XOR<TwitterUserUpdateWithoutCommentsInput, TwitterUserUncheckedUpdateWithoutCommentsInput>
    create: XOR<TwitterUserCreateWithoutCommentsInput, TwitterUserUncheckedCreateWithoutCommentsInput>
  }

  export type TwitterUserUpdateWithoutCommentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: TwitterPostUpdateManyWithoutUserNestedInput
    fromDirectMessages?: TwitterDirectMessageUpdateManyWithoutFromNestedInput
    toDirectMessages?: TwitterDirectMessageUpdateManyWithoutToNestedInput
    followingUserRelations?: TwitterUserRelationUpdateManyWithoutFromNestedInput
    followerUserRelations?: TwitterUserRelationUpdateManyWithoutToNestedInput
  }

  export type TwitterUserUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: TwitterPostUncheckedUpdateManyWithoutUserNestedInput
    fromDirectMessages?: TwitterDirectMessageUncheckedUpdateManyWithoutFromNestedInput
    toDirectMessages?: TwitterDirectMessageUncheckedUpdateManyWithoutToNestedInput
    followingUserRelations?: TwitterUserRelationUncheckedUpdateManyWithoutFromNestedInput
    followerUserRelations?: TwitterUserRelationUncheckedUpdateManyWithoutToNestedInput
  }

  export type YoutubeUserToChannelCreateWithoutUserInput = {
    channel: YoutubeChannelCreateNestedOneWithoutYoutubeUsersToChannelsInput
    description: string
    role: RoleEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeUserToChannelUncheckedCreateWithoutUserInput = {
    id?: number
    description: string
    role: RoleEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeChannelId: number
  }

  export type YoutubeUserToChannelCreateOrConnectWithoutUserInput = {
    where: YoutubeUserToChannelWhereUniqueInput
    create: XOR<YoutubeUserToChannelCreateWithoutUserInput, YoutubeUserToChannelUncheckedCreateWithoutUserInput>
  }

  export type YoutubeUserToChannelCreateManyUserInputEnvelope = {
    data: Enumerable<YoutubeUserToChannelCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type YoutubeSubscriptionCreateWithoutUserInput = {
    channel: YoutubeChannelCreateNestedOneWithoutYoutubeSubscriptionsInput
    membership: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeSubscriptionUncheckedCreateWithoutUserInput = {
    id?: number
    membership: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeChannelId: number
  }

  export type YoutubeSubscriptionCreateOrConnectWithoutUserInput = {
    where: YoutubeSubscriptionWhereUniqueInput
    create: XOR<YoutubeSubscriptionCreateWithoutUserInput, YoutubeSubscriptionUncheckedCreateWithoutUserInput>
  }

  export type YoutubeSubscriptionCreateManyUserInputEnvelope = {
    data: Enumerable<YoutubeSubscriptionCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type YoutubeReactionCreateWithoutUserInput = {
    video: YoutubeVideoCreateNestedOneWithoutYoutubeReactionsInput
    reaction: ReactionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeChannelId: number
    youtubeCommentId: number
  }

  export type YoutubeReactionUncheckedCreateWithoutUserInput = {
    id?: number
    reaction: ReactionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeChannelId: number
    youtubeVideoId: number
    youtubeCommentId: number
  }

  export type YoutubeReactionCreateOrConnectWithoutUserInput = {
    where: YoutubeReactionWhereUniqueInput
    create: XOR<YoutubeReactionCreateWithoutUserInput, YoutubeReactionUncheckedCreateWithoutUserInput>
  }

  export type YoutubeReactionCreateManyUserInputEnvelope = {
    data: Enumerable<YoutubeReactionCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type YoutubeCommentCreateWithoutUserInput = {
    comment: string
    video: YoutubeVideoCreateNestedOneWithoutYoutubeCommentsInput
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeCommentReactions?: YoutubeCommentReactionCreateNestedManyWithoutCommentInput
  }

  export type YoutubeCommentUncheckedCreateWithoutUserInput = {
    id?: number
    comment: string
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeVideoId: number
    youtubeCommentReactions?: YoutubeCommentReactionUncheckedCreateNestedManyWithoutCommentInput
  }

  export type YoutubeCommentCreateOrConnectWithoutUserInput = {
    where: YoutubeCommentWhereUniqueInput
    create: XOR<YoutubeCommentCreateWithoutUserInput, YoutubeCommentUncheckedCreateWithoutUserInput>
  }

  export type YoutubeCommentCreateManyUserInputEnvelope = {
    data: Enumerable<YoutubeCommentCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type YoutubeCommentReactionCreateWithoutUserInput = {
    comment: YoutubeCommentCreateNestedOneWithoutYoutubeCommentReactionsInput
    reaction: ReactionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeChannelId: number
    youtubeVideoId: number
  }

  export type YoutubeCommentReactionUncheckedCreateWithoutUserInput = {
    id?: number
    reaction: ReactionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeChannelId: number
    youtubeVideoId: number
    youtubeCommentId: number
  }

  export type YoutubeCommentReactionCreateOrConnectWithoutUserInput = {
    where: YoutubeCommentReactionWhereUniqueInput
    create: XOR<YoutubeCommentReactionCreateWithoutUserInput, YoutubeCommentReactionUncheckedCreateWithoutUserInput>
  }

  export type YoutubeCommentReactionCreateManyUserInputEnvelope = {
    data: Enumerable<YoutubeCommentReactionCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type YoutubeUserToChannelUpsertWithWhereUniqueWithoutUserInput = {
    where: YoutubeUserToChannelWhereUniqueInput
    update: XOR<YoutubeUserToChannelUpdateWithoutUserInput, YoutubeUserToChannelUncheckedUpdateWithoutUserInput>
    create: XOR<YoutubeUserToChannelCreateWithoutUserInput, YoutubeUserToChannelUncheckedCreateWithoutUserInput>
  }

  export type YoutubeUserToChannelUpdateWithWhereUniqueWithoutUserInput = {
    where: YoutubeUserToChannelWhereUniqueInput
    data: XOR<YoutubeUserToChannelUpdateWithoutUserInput, YoutubeUserToChannelUncheckedUpdateWithoutUserInput>
  }

  export type YoutubeUserToChannelUpdateManyWithWhereWithoutUserInput = {
    where: YoutubeUserToChannelScalarWhereInput
    data: XOR<YoutubeUserToChannelUpdateManyMutationInput, YoutubeUserToChannelUncheckedUpdateManyWithoutYoutubeUsersToChannelsInput>
  }

  export type YoutubeUserToChannelScalarWhereInput = {
    AND?: Enumerable<YoutubeUserToChannelScalarWhereInput>
    OR?: Enumerable<YoutubeUserToChannelScalarWhereInput>
    NOT?: Enumerable<YoutubeUserToChannelScalarWhereInput>
    id?: IntFilter | number
    description?: StringFilter | string
    role?: EnumRoleEnumFilter | RoleEnum
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    youtubeUserId?: IntFilter | number
    youtubeChannelId?: IntFilter | number
  }

  export type YoutubeSubscriptionUpsertWithWhereUniqueWithoutUserInput = {
    where: YoutubeSubscriptionWhereUniqueInput
    update: XOR<YoutubeSubscriptionUpdateWithoutUserInput, YoutubeSubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<YoutubeSubscriptionCreateWithoutUserInput, YoutubeSubscriptionUncheckedCreateWithoutUserInput>
  }

  export type YoutubeSubscriptionUpdateWithWhereUniqueWithoutUserInput = {
    where: YoutubeSubscriptionWhereUniqueInput
    data: XOR<YoutubeSubscriptionUpdateWithoutUserInput, YoutubeSubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type YoutubeSubscriptionUpdateManyWithWhereWithoutUserInput = {
    where: YoutubeSubscriptionScalarWhereInput
    data: XOR<YoutubeSubscriptionUpdateManyMutationInput, YoutubeSubscriptionUncheckedUpdateManyWithoutYoutubeSubscriptionsInput>
  }

  export type YoutubeSubscriptionScalarWhereInput = {
    AND?: Enumerable<YoutubeSubscriptionScalarWhereInput>
    OR?: Enumerable<YoutubeSubscriptionScalarWhereInput>
    NOT?: Enumerable<YoutubeSubscriptionScalarWhereInput>
    id?: IntFilter | number
    membership?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    youtubeUserId?: IntFilter | number
    youtubeChannelId?: IntFilter | number
  }

  export type YoutubeReactionUpsertWithWhereUniqueWithoutUserInput = {
    where: YoutubeReactionWhereUniqueInput
    update: XOR<YoutubeReactionUpdateWithoutUserInput, YoutubeReactionUncheckedUpdateWithoutUserInput>
    create: XOR<YoutubeReactionCreateWithoutUserInput, YoutubeReactionUncheckedCreateWithoutUserInput>
  }

  export type YoutubeReactionUpdateWithWhereUniqueWithoutUserInput = {
    where: YoutubeReactionWhereUniqueInput
    data: XOR<YoutubeReactionUpdateWithoutUserInput, YoutubeReactionUncheckedUpdateWithoutUserInput>
  }

  export type YoutubeReactionUpdateManyWithWhereWithoutUserInput = {
    where: YoutubeReactionScalarWhereInput
    data: XOR<YoutubeReactionUpdateManyMutationInput, YoutubeReactionUncheckedUpdateManyWithoutYoutubeReactionInput>
  }

  export type YoutubeReactionScalarWhereInput = {
    AND?: Enumerable<YoutubeReactionScalarWhereInput>
    OR?: Enumerable<YoutubeReactionScalarWhereInput>
    NOT?: Enumerable<YoutubeReactionScalarWhereInput>
    id?: IntFilter | number
    reaction?: EnumReactionEnumFilter | ReactionEnum
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    youtubeUserId?: IntFilter | number
    youtubeChannelId?: IntFilter | number
    youtubeVideoId?: IntFilter | number
    youtubeCommentId?: IntFilter | number
  }

  export type YoutubeCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: YoutubeCommentWhereUniqueInput
    update: XOR<YoutubeCommentUpdateWithoutUserInput, YoutubeCommentUncheckedUpdateWithoutUserInput>
    create: XOR<YoutubeCommentCreateWithoutUserInput, YoutubeCommentUncheckedCreateWithoutUserInput>
  }

  export type YoutubeCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: YoutubeCommentWhereUniqueInput
    data: XOR<YoutubeCommentUpdateWithoutUserInput, YoutubeCommentUncheckedUpdateWithoutUserInput>
  }

  export type YoutubeCommentUpdateManyWithWhereWithoutUserInput = {
    where: YoutubeCommentScalarWhereInput
    data: XOR<YoutubeCommentUpdateManyMutationInput, YoutubeCommentUncheckedUpdateManyWithoutYoutubeCommentInput>
  }

  export type YoutubeCommentScalarWhereInput = {
    AND?: Enumerable<YoutubeCommentScalarWhereInput>
    OR?: Enumerable<YoutubeCommentScalarWhereInput>
    NOT?: Enumerable<YoutubeCommentScalarWhereInput>
    id?: IntFilter | number
    comment?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    youtubeVideoId?: IntFilter | number
    youtubeUserId?: IntFilter | number
  }

  export type YoutubeCommentReactionUpsertWithWhereUniqueWithoutUserInput = {
    where: YoutubeCommentReactionWhereUniqueInput
    update: XOR<YoutubeCommentReactionUpdateWithoutUserInput, YoutubeCommentReactionUncheckedUpdateWithoutUserInput>
    create: XOR<YoutubeCommentReactionCreateWithoutUserInput, YoutubeCommentReactionUncheckedCreateWithoutUserInput>
  }

  export type YoutubeCommentReactionUpdateWithWhereUniqueWithoutUserInput = {
    where: YoutubeCommentReactionWhereUniqueInput
    data: XOR<YoutubeCommentReactionUpdateWithoutUserInput, YoutubeCommentReactionUncheckedUpdateWithoutUserInput>
  }

  export type YoutubeCommentReactionUpdateManyWithWhereWithoutUserInput = {
    where: YoutubeCommentReactionScalarWhereInput
    data: XOR<YoutubeCommentReactionUpdateManyMutationInput, YoutubeCommentReactionUncheckedUpdateManyWithoutYoutubeCommentReactionInput>
  }

  export type YoutubeCommentReactionScalarWhereInput = {
    AND?: Enumerable<YoutubeCommentReactionScalarWhereInput>
    OR?: Enumerable<YoutubeCommentReactionScalarWhereInput>
    NOT?: Enumerable<YoutubeCommentReactionScalarWhereInput>
    id?: IntFilter | number
    reaction?: EnumReactionEnumFilter | ReactionEnum
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    youtubeUserId?: IntFilter | number
    youtubeChannelId?: IntFilter | number
    youtubeVideoId?: IntFilter | number
    youtubeCommentId?: IntFilter | number
  }

  export type YoutubeUserToChannelCreateWithoutChannelInput = {
    user: YoutubeUserCreateNestedOneWithoutYoutubeUsersToChannelsInput
    description: string
    role: RoleEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeUserToChannelUncheckedCreateWithoutChannelInput = {
    id?: number
    description: string
    role: RoleEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeUserId: number
  }

  export type YoutubeUserToChannelCreateOrConnectWithoutChannelInput = {
    where: YoutubeUserToChannelWhereUniqueInput
    create: XOR<YoutubeUserToChannelCreateWithoutChannelInput, YoutubeUserToChannelUncheckedCreateWithoutChannelInput>
  }

  export type YoutubeUserToChannelCreateManyChannelInputEnvelope = {
    data: Enumerable<YoutubeUserToChannelCreateManyChannelInput>
    skipDuplicates?: boolean
  }

  export type YoutubeVideoCreateWithoutChannelInput = {
    name: string
    videoUrl: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeComments?: YoutubeCommentCreateNestedManyWithoutVideoInput
    youtubeReactions?: YoutubeReactionCreateNestedManyWithoutVideoInput
  }

  export type YoutubeVideoUncheckedCreateWithoutChannelInput = {
    id?: number
    name: string
    videoUrl: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeComments?: YoutubeCommentUncheckedCreateNestedManyWithoutVideoInput
    youtubeReactions?: YoutubeReactionUncheckedCreateNestedManyWithoutVideoInput
  }

  export type YoutubeVideoCreateOrConnectWithoutChannelInput = {
    where: YoutubeVideoWhereUniqueInput
    create: XOR<YoutubeVideoCreateWithoutChannelInput, YoutubeVideoUncheckedCreateWithoutChannelInput>
  }

  export type YoutubeVideoCreateManyChannelInputEnvelope = {
    data: Enumerable<YoutubeVideoCreateManyChannelInput>
    skipDuplicates?: boolean
  }

  export type YoutubeSubscriptionCreateWithoutChannelInput = {
    user: YoutubeUserCreateNestedOneWithoutYoutubeSubscriptionsInput
    membership: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeSubscriptionUncheckedCreateWithoutChannelInput = {
    id?: number
    membership: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeUserId: number
  }

  export type YoutubeSubscriptionCreateOrConnectWithoutChannelInput = {
    where: YoutubeSubscriptionWhereUniqueInput
    create: XOR<YoutubeSubscriptionCreateWithoutChannelInput, YoutubeSubscriptionUncheckedCreateWithoutChannelInput>
  }

  export type YoutubeSubscriptionCreateManyChannelInputEnvelope = {
    data: Enumerable<YoutubeSubscriptionCreateManyChannelInput>
    skipDuplicates?: boolean
  }

  export type YoutubeUserToChannelUpsertWithWhereUniqueWithoutChannelInput = {
    where: YoutubeUserToChannelWhereUniqueInput
    update: XOR<YoutubeUserToChannelUpdateWithoutChannelInput, YoutubeUserToChannelUncheckedUpdateWithoutChannelInput>
    create: XOR<YoutubeUserToChannelCreateWithoutChannelInput, YoutubeUserToChannelUncheckedCreateWithoutChannelInput>
  }

  export type YoutubeUserToChannelUpdateWithWhereUniqueWithoutChannelInput = {
    where: YoutubeUserToChannelWhereUniqueInput
    data: XOR<YoutubeUserToChannelUpdateWithoutChannelInput, YoutubeUserToChannelUncheckedUpdateWithoutChannelInput>
  }

  export type YoutubeUserToChannelUpdateManyWithWhereWithoutChannelInput = {
    where: YoutubeUserToChannelScalarWhereInput
    data: XOR<YoutubeUserToChannelUpdateManyMutationInput, YoutubeUserToChannelUncheckedUpdateManyWithoutYoutubeUsersToChannelsInput>
  }

  export type YoutubeVideoUpsertWithWhereUniqueWithoutChannelInput = {
    where: YoutubeVideoWhereUniqueInput
    update: XOR<YoutubeVideoUpdateWithoutChannelInput, YoutubeVideoUncheckedUpdateWithoutChannelInput>
    create: XOR<YoutubeVideoCreateWithoutChannelInput, YoutubeVideoUncheckedCreateWithoutChannelInput>
  }

  export type YoutubeVideoUpdateWithWhereUniqueWithoutChannelInput = {
    where: YoutubeVideoWhereUniqueInput
    data: XOR<YoutubeVideoUpdateWithoutChannelInput, YoutubeVideoUncheckedUpdateWithoutChannelInput>
  }

  export type YoutubeVideoUpdateManyWithWhereWithoutChannelInput = {
    where: YoutubeVideoScalarWhereInput
    data: XOR<YoutubeVideoUpdateManyMutationInput, YoutubeVideoUncheckedUpdateManyWithoutYoutubeVideosInput>
  }

  export type YoutubeVideoScalarWhereInput = {
    AND?: Enumerable<YoutubeVideoScalarWhereInput>
    OR?: Enumerable<YoutubeVideoScalarWhereInput>
    NOT?: Enumerable<YoutubeVideoScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    videoUrl?: StringFilter | string
    description?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    youtubeChannelId?: IntFilter | number
  }

  export type YoutubeSubscriptionUpsertWithWhereUniqueWithoutChannelInput = {
    where: YoutubeSubscriptionWhereUniqueInput
    update: XOR<YoutubeSubscriptionUpdateWithoutChannelInput, YoutubeSubscriptionUncheckedUpdateWithoutChannelInput>
    create: XOR<YoutubeSubscriptionCreateWithoutChannelInput, YoutubeSubscriptionUncheckedCreateWithoutChannelInput>
  }

  export type YoutubeSubscriptionUpdateWithWhereUniqueWithoutChannelInput = {
    where: YoutubeSubscriptionWhereUniqueInput
    data: XOR<YoutubeSubscriptionUpdateWithoutChannelInput, YoutubeSubscriptionUncheckedUpdateWithoutChannelInput>
  }

  export type YoutubeSubscriptionUpdateManyWithWhereWithoutChannelInput = {
    where: YoutubeSubscriptionScalarWhereInput
    data: XOR<YoutubeSubscriptionUpdateManyMutationInput, YoutubeSubscriptionUncheckedUpdateManyWithoutYoutubeSubscriptionsInput>
  }

  export type YoutubeUserCreateWithoutYoutubeSubscriptionsInput = {
    name: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeUsersToChannels?: YoutubeUserToChannelCreateNestedManyWithoutUserInput
    YoutubeReaction?: YoutubeReactionCreateNestedManyWithoutUserInput
    YoutubeComment?: YoutubeCommentCreateNestedManyWithoutUserInput
    YoutubeCommentReaction?: YoutubeCommentReactionCreateNestedManyWithoutUserInput
  }

  export type YoutubeUserUncheckedCreateWithoutYoutubeSubscriptionsInput = {
    id?: number
    name: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeUsersToChannels?: YoutubeUserToChannelUncheckedCreateNestedManyWithoutUserInput
    YoutubeReaction?: YoutubeReactionUncheckedCreateNestedManyWithoutUserInput
    YoutubeComment?: YoutubeCommentUncheckedCreateNestedManyWithoutUserInput
    YoutubeCommentReaction?: YoutubeCommentReactionUncheckedCreateNestedManyWithoutUserInput
  }

  export type YoutubeUserCreateOrConnectWithoutYoutubeSubscriptionsInput = {
    where: YoutubeUserWhereUniqueInput
    create: XOR<YoutubeUserCreateWithoutYoutubeSubscriptionsInput, YoutubeUserUncheckedCreateWithoutYoutubeSubscriptionsInput>
  }

  export type YoutubeChannelCreateWithoutYoutubeSubscriptionsInput = {
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeUsersToChannels?: YoutubeUserToChannelCreateNestedManyWithoutChannelInput
    youtubeVideos?: YoutubeVideoCreateNestedManyWithoutChannelInput
  }

  export type YoutubeChannelUncheckedCreateWithoutYoutubeSubscriptionsInput = {
    id?: number
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeUsersToChannels?: YoutubeUserToChannelUncheckedCreateNestedManyWithoutChannelInput
    youtubeVideos?: YoutubeVideoUncheckedCreateNestedManyWithoutChannelInput
  }

  export type YoutubeChannelCreateOrConnectWithoutYoutubeSubscriptionsInput = {
    where: YoutubeChannelWhereUniqueInput
    create: XOR<YoutubeChannelCreateWithoutYoutubeSubscriptionsInput, YoutubeChannelUncheckedCreateWithoutYoutubeSubscriptionsInput>
  }

  export type YoutubeUserUpsertWithoutYoutubeSubscriptionsInput = {
    update: XOR<YoutubeUserUpdateWithoutYoutubeSubscriptionsInput, YoutubeUserUncheckedUpdateWithoutYoutubeSubscriptionsInput>
    create: XOR<YoutubeUserCreateWithoutYoutubeSubscriptionsInput, YoutubeUserUncheckedCreateWithoutYoutubeSubscriptionsInput>
  }

  export type YoutubeUserUpdateWithoutYoutubeSubscriptionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeUsersToChannels?: YoutubeUserToChannelUpdateManyWithoutUserNestedInput
    YoutubeReaction?: YoutubeReactionUpdateManyWithoutUserNestedInput
    YoutubeComment?: YoutubeCommentUpdateManyWithoutUserNestedInput
    YoutubeCommentReaction?: YoutubeCommentReactionUpdateManyWithoutUserNestedInput
  }

  export type YoutubeUserUncheckedUpdateWithoutYoutubeSubscriptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeUsersToChannels?: YoutubeUserToChannelUncheckedUpdateManyWithoutUserNestedInput
    YoutubeReaction?: YoutubeReactionUncheckedUpdateManyWithoutUserNestedInput
    YoutubeComment?: YoutubeCommentUncheckedUpdateManyWithoutUserNestedInput
    YoutubeCommentReaction?: YoutubeCommentReactionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type YoutubeChannelUpsertWithoutYoutubeSubscriptionsInput = {
    update: XOR<YoutubeChannelUpdateWithoutYoutubeSubscriptionsInput, YoutubeChannelUncheckedUpdateWithoutYoutubeSubscriptionsInput>
    create: XOR<YoutubeChannelCreateWithoutYoutubeSubscriptionsInput, YoutubeChannelUncheckedCreateWithoutYoutubeSubscriptionsInput>
  }

  export type YoutubeChannelUpdateWithoutYoutubeSubscriptionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeUsersToChannels?: YoutubeUserToChannelUpdateManyWithoutChannelNestedInput
    youtubeVideos?: YoutubeVideoUpdateManyWithoutChannelNestedInput
  }

  export type YoutubeChannelUncheckedUpdateWithoutYoutubeSubscriptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeUsersToChannels?: YoutubeUserToChannelUncheckedUpdateManyWithoutChannelNestedInput
    youtubeVideos?: YoutubeVideoUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type YoutubeUserCreateWithoutYoutubeUsersToChannelsInput = {
    name: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeSubscriptions?: YoutubeSubscriptionCreateNestedManyWithoutUserInput
    YoutubeReaction?: YoutubeReactionCreateNestedManyWithoutUserInput
    YoutubeComment?: YoutubeCommentCreateNestedManyWithoutUserInput
    YoutubeCommentReaction?: YoutubeCommentReactionCreateNestedManyWithoutUserInput
  }

  export type YoutubeUserUncheckedCreateWithoutYoutubeUsersToChannelsInput = {
    id?: number
    name: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeSubscriptions?: YoutubeSubscriptionUncheckedCreateNestedManyWithoutUserInput
    YoutubeReaction?: YoutubeReactionUncheckedCreateNestedManyWithoutUserInput
    YoutubeComment?: YoutubeCommentUncheckedCreateNestedManyWithoutUserInput
    YoutubeCommentReaction?: YoutubeCommentReactionUncheckedCreateNestedManyWithoutUserInput
  }

  export type YoutubeUserCreateOrConnectWithoutYoutubeUsersToChannelsInput = {
    where: YoutubeUserWhereUniqueInput
    create: XOR<YoutubeUserCreateWithoutYoutubeUsersToChannelsInput, YoutubeUserUncheckedCreateWithoutYoutubeUsersToChannelsInput>
  }

  export type YoutubeChannelCreateWithoutYoutubeUsersToChannelsInput = {
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeVideos?: YoutubeVideoCreateNestedManyWithoutChannelInput
    youtubeSubscriptions?: YoutubeSubscriptionCreateNestedManyWithoutChannelInput
  }

  export type YoutubeChannelUncheckedCreateWithoutYoutubeUsersToChannelsInput = {
    id?: number
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeVideos?: YoutubeVideoUncheckedCreateNestedManyWithoutChannelInput
    youtubeSubscriptions?: YoutubeSubscriptionUncheckedCreateNestedManyWithoutChannelInput
  }

  export type YoutubeChannelCreateOrConnectWithoutYoutubeUsersToChannelsInput = {
    where: YoutubeChannelWhereUniqueInput
    create: XOR<YoutubeChannelCreateWithoutYoutubeUsersToChannelsInput, YoutubeChannelUncheckedCreateWithoutYoutubeUsersToChannelsInput>
  }

  export type YoutubeUserUpsertWithoutYoutubeUsersToChannelsInput = {
    update: XOR<YoutubeUserUpdateWithoutYoutubeUsersToChannelsInput, YoutubeUserUncheckedUpdateWithoutYoutubeUsersToChannelsInput>
    create: XOR<YoutubeUserCreateWithoutYoutubeUsersToChannelsInput, YoutubeUserUncheckedCreateWithoutYoutubeUsersToChannelsInput>
  }

  export type YoutubeUserUpdateWithoutYoutubeUsersToChannelsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeSubscriptions?: YoutubeSubscriptionUpdateManyWithoutUserNestedInput
    YoutubeReaction?: YoutubeReactionUpdateManyWithoutUserNestedInput
    YoutubeComment?: YoutubeCommentUpdateManyWithoutUserNestedInput
    YoutubeCommentReaction?: YoutubeCommentReactionUpdateManyWithoutUserNestedInput
  }

  export type YoutubeUserUncheckedUpdateWithoutYoutubeUsersToChannelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeSubscriptions?: YoutubeSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    YoutubeReaction?: YoutubeReactionUncheckedUpdateManyWithoutUserNestedInput
    YoutubeComment?: YoutubeCommentUncheckedUpdateManyWithoutUserNestedInput
    YoutubeCommentReaction?: YoutubeCommentReactionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type YoutubeChannelUpsertWithoutYoutubeUsersToChannelsInput = {
    update: XOR<YoutubeChannelUpdateWithoutYoutubeUsersToChannelsInput, YoutubeChannelUncheckedUpdateWithoutYoutubeUsersToChannelsInput>
    create: XOR<YoutubeChannelCreateWithoutYoutubeUsersToChannelsInput, YoutubeChannelUncheckedCreateWithoutYoutubeUsersToChannelsInput>
  }

  export type YoutubeChannelUpdateWithoutYoutubeUsersToChannelsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeVideos?: YoutubeVideoUpdateManyWithoutChannelNestedInput
    youtubeSubscriptions?: YoutubeSubscriptionUpdateManyWithoutChannelNestedInput
  }

  export type YoutubeChannelUncheckedUpdateWithoutYoutubeUsersToChannelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeVideos?: YoutubeVideoUncheckedUpdateManyWithoutChannelNestedInput
    youtubeSubscriptions?: YoutubeSubscriptionUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type YoutubeChannelCreateWithoutYoutubeVideosInput = {
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeUsersToChannels?: YoutubeUserToChannelCreateNestedManyWithoutChannelInput
    youtubeSubscriptions?: YoutubeSubscriptionCreateNestedManyWithoutChannelInput
  }

  export type YoutubeChannelUncheckedCreateWithoutYoutubeVideosInput = {
    id?: number
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeUsersToChannels?: YoutubeUserToChannelUncheckedCreateNestedManyWithoutChannelInput
    youtubeSubscriptions?: YoutubeSubscriptionUncheckedCreateNestedManyWithoutChannelInput
  }

  export type YoutubeChannelCreateOrConnectWithoutYoutubeVideosInput = {
    where: YoutubeChannelWhereUniqueInput
    create: XOR<YoutubeChannelCreateWithoutYoutubeVideosInput, YoutubeChannelUncheckedCreateWithoutYoutubeVideosInput>
  }

  export type YoutubeCommentCreateWithoutVideoInput = {
    comment: string
    user: YoutubeUserCreateNestedOneWithoutYoutubeCommentInput
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeCommentReactions?: YoutubeCommentReactionCreateNestedManyWithoutCommentInput
  }

  export type YoutubeCommentUncheckedCreateWithoutVideoInput = {
    id?: number
    comment: string
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeUserId: number
    youtubeCommentReactions?: YoutubeCommentReactionUncheckedCreateNestedManyWithoutCommentInput
  }

  export type YoutubeCommentCreateOrConnectWithoutVideoInput = {
    where: YoutubeCommentWhereUniqueInput
    create: XOR<YoutubeCommentCreateWithoutVideoInput, YoutubeCommentUncheckedCreateWithoutVideoInput>
  }

  export type YoutubeCommentCreateManyVideoInputEnvelope = {
    data: Enumerable<YoutubeCommentCreateManyVideoInput>
    skipDuplicates?: boolean
  }

  export type YoutubeReactionCreateWithoutVideoInput = {
    user: YoutubeUserCreateNestedOneWithoutYoutubeReactionInput
    reaction: ReactionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeChannelId: number
    youtubeCommentId: number
  }

  export type YoutubeReactionUncheckedCreateWithoutVideoInput = {
    id?: number
    reaction: ReactionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeUserId: number
    youtubeChannelId: number
    youtubeCommentId: number
  }

  export type YoutubeReactionCreateOrConnectWithoutVideoInput = {
    where: YoutubeReactionWhereUniqueInput
    create: XOR<YoutubeReactionCreateWithoutVideoInput, YoutubeReactionUncheckedCreateWithoutVideoInput>
  }

  export type YoutubeReactionCreateManyVideoInputEnvelope = {
    data: Enumerable<YoutubeReactionCreateManyVideoInput>
    skipDuplicates?: boolean
  }

  export type YoutubeChannelUpsertWithoutYoutubeVideosInput = {
    update: XOR<YoutubeChannelUpdateWithoutYoutubeVideosInput, YoutubeChannelUncheckedUpdateWithoutYoutubeVideosInput>
    create: XOR<YoutubeChannelCreateWithoutYoutubeVideosInput, YoutubeChannelUncheckedCreateWithoutYoutubeVideosInput>
  }

  export type YoutubeChannelUpdateWithoutYoutubeVideosInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeUsersToChannels?: YoutubeUserToChannelUpdateManyWithoutChannelNestedInput
    youtubeSubscriptions?: YoutubeSubscriptionUpdateManyWithoutChannelNestedInput
  }

  export type YoutubeChannelUncheckedUpdateWithoutYoutubeVideosInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeUsersToChannels?: YoutubeUserToChannelUncheckedUpdateManyWithoutChannelNestedInput
    youtubeSubscriptions?: YoutubeSubscriptionUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type YoutubeCommentUpsertWithWhereUniqueWithoutVideoInput = {
    where: YoutubeCommentWhereUniqueInput
    update: XOR<YoutubeCommentUpdateWithoutVideoInput, YoutubeCommentUncheckedUpdateWithoutVideoInput>
    create: XOR<YoutubeCommentCreateWithoutVideoInput, YoutubeCommentUncheckedCreateWithoutVideoInput>
  }

  export type YoutubeCommentUpdateWithWhereUniqueWithoutVideoInput = {
    where: YoutubeCommentWhereUniqueInput
    data: XOR<YoutubeCommentUpdateWithoutVideoInput, YoutubeCommentUncheckedUpdateWithoutVideoInput>
  }

  export type YoutubeCommentUpdateManyWithWhereWithoutVideoInput = {
    where: YoutubeCommentScalarWhereInput
    data: XOR<YoutubeCommentUpdateManyMutationInput, YoutubeCommentUncheckedUpdateManyWithoutYoutubeCommentsInput>
  }

  export type YoutubeReactionUpsertWithWhereUniqueWithoutVideoInput = {
    where: YoutubeReactionWhereUniqueInput
    update: XOR<YoutubeReactionUpdateWithoutVideoInput, YoutubeReactionUncheckedUpdateWithoutVideoInput>
    create: XOR<YoutubeReactionCreateWithoutVideoInput, YoutubeReactionUncheckedCreateWithoutVideoInput>
  }

  export type YoutubeReactionUpdateWithWhereUniqueWithoutVideoInput = {
    where: YoutubeReactionWhereUniqueInput
    data: XOR<YoutubeReactionUpdateWithoutVideoInput, YoutubeReactionUncheckedUpdateWithoutVideoInput>
  }

  export type YoutubeReactionUpdateManyWithWhereWithoutVideoInput = {
    where: YoutubeReactionScalarWhereInput
    data: XOR<YoutubeReactionUpdateManyMutationInput, YoutubeReactionUncheckedUpdateManyWithoutYoutubeReactionsInput>
  }

  export type YoutubeUserCreateWithoutYoutubeReactionInput = {
    name: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeUsersToChannels?: YoutubeUserToChannelCreateNestedManyWithoutUserInput
    youtubeSubscriptions?: YoutubeSubscriptionCreateNestedManyWithoutUserInput
    YoutubeComment?: YoutubeCommentCreateNestedManyWithoutUserInput
    YoutubeCommentReaction?: YoutubeCommentReactionCreateNestedManyWithoutUserInput
  }

  export type YoutubeUserUncheckedCreateWithoutYoutubeReactionInput = {
    id?: number
    name: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeUsersToChannels?: YoutubeUserToChannelUncheckedCreateNestedManyWithoutUserInput
    youtubeSubscriptions?: YoutubeSubscriptionUncheckedCreateNestedManyWithoutUserInput
    YoutubeComment?: YoutubeCommentUncheckedCreateNestedManyWithoutUserInput
    YoutubeCommentReaction?: YoutubeCommentReactionUncheckedCreateNestedManyWithoutUserInput
  }

  export type YoutubeUserCreateOrConnectWithoutYoutubeReactionInput = {
    where: YoutubeUserWhereUniqueInput
    create: XOR<YoutubeUserCreateWithoutYoutubeReactionInput, YoutubeUserUncheckedCreateWithoutYoutubeReactionInput>
  }

  export type YoutubeVideoCreateWithoutYoutubeReactionsInput = {
    name: string
    videoUrl: string
    description: string
    channel: YoutubeChannelCreateNestedOneWithoutYoutubeVideosInput
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeComments?: YoutubeCommentCreateNestedManyWithoutVideoInput
  }

  export type YoutubeVideoUncheckedCreateWithoutYoutubeReactionsInput = {
    id?: number
    name: string
    videoUrl: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeChannelId: number
    youtubeComments?: YoutubeCommentUncheckedCreateNestedManyWithoutVideoInput
  }

  export type YoutubeVideoCreateOrConnectWithoutYoutubeReactionsInput = {
    where: YoutubeVideoWhereUniqueInput
    create: XOR<YoutubeVideoCreateWithoutYoutubeReactionsInput, YoutubeVideoUncheckedCreateWithoutYoutubeReactionsInput>
  }

  export type YoutubeUserUpsertWithoutYoutubeReactionInput = {
    update: XOR<YoutubeUserUpdateWithoutYoutubeReactionInput, YoutubeUserUncheckedUpdateWithoutYoutubeReactionInput>
    create: XOR<YoutubeUserCreateWithoutYoutubeReactionInput, YoutubeUserUncheckedCreateWithoutYoutubeReactionInput>
  }

  export type YoutubeUserUpdateWithoutYoutubeReactionInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeUsersToChannels?: YoutubeUserToChannelUpdateManyWithoutUserNestedInput
    youtubeSubscriptions?: YoutubeSubscriptionUpdateManyWithoutUserNestedInput
    YoutubeComment?: YoutubeCommentUpdateManyWithoutUserNestedInput
    YoutubeCommentReaction?: YoutubeCommentReactionUpdateManyWithoutUserNestedInput
  }

  export type YoutubeUserUncheckedUpdateWithoutYoutubeReactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeUsersToChannels?: YoutubeUserToChannelUncheckedUpdateManyWithoutUserNestedInput
    youtubeSubscriptions?: YoutubeSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    YoutubeComment?: YoutubeCommentUncheckedUpdateManyWithoutUserNestedInput
    YoutubeCommentReaction?: YoutubeCommentReactionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type YoutubeVideoUpsertWithoutYoutubeReactionsInput = {
    update: XOR<YoutubeVideoUpdateWithoutYoutubeReactionsInput, YoutubeVideoUncheckedUpdateWithoutYoutubeReactionsInput>
    create: XOR<YoutubeVideoCreateWithoutYoutubeReactionsInput, YoutubeVideoUncheckedCreateWithoutYoutubeReactionsInput>
  }

  export type YoutubeVideoUpdateWithoutYoutubeReactionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    channel?: YoutubeChannelUpdateOneRequiredWithoutYoutubeVideosNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeComments?: YoutubeCommentUpdateManyWithoutVideoNestedInput
  }

  export type YoutubeVideoUncheckedUpdateWithoutYoutubeReactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeChannelId?: IntFieldUpdateOperationsInput | number
    youtubeComments?: YoutubeCommentUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type YoutubeUserCreateWithoutYoutubeCommentInput = {
    name: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeUsersToChannels?: YoutubeUserToChannelCreateNestedManyWithoutUserInput
    youtubeSubscriptions?: YoutubeSubscriptionCreateNestedManyWithoutUserInput
    YoutubeReaction?: YoutubeReactionCreateNestedManyWithoutUserInput
    YoutubeCommentReaction?: YoutubeCommentReactionCreateNestedManyWithoutUserInput
  }

  export type YoutubeUserUncheckedCreateWithoutYoutubeCommentInput = {
    id?: number
    name: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeUsersToChannels?: YoutubeUserToChannelUncheckedCreateNestedManyWithoutUserInput
    youtubeSubscriptions?: YoutubeSubscriptionUncheckedCreateNestedManyWithoutUserInput
    YoutubeReaction?: YoutubeReactionUncheckedCreateNestedManyWithoutUserInput
    YoutubeCommentReaction?: YoutubeCommentReactionUncheckedCreateNestedManyWithoutUserInput
  }

  export type YoutubeUserCreateOrConnectWithoutYoutubeCommentInput = {
    where: YoutubeUserWhereUniqueInput
    create: XOR<YoutubeUserCreateWithoutYoutubeCommentInput, YoutubeUserUncheckedCreateWithoutYoutubeCommentInput>
  }

  export type YoutubeVideoCreateWithoutYoutubeCommentsInput = {
    name: string
    videoUrl: string
    description: string
    channel: YoutubeChannelCreateNestedOneWithoutYoutubeVideosInput
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeReactions?: YoutubeReactionCreateNestedManyWithoutVideoInput
  }

  export type YoutubeVideoUncheckedCreateWithoutYoutubeCommentsInput = {
    id?: number
    name: string
    videoUrl: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeChannelId: number
    youtubeReactions?: YoutubeReactionUncheckedCreateNestedManyWithoutVideoInput
  }

  export type YoutubeVideoCreateOrConnectWithoutYoutubeCommentsInput = {
    where: YoutubeVideoWhereUniqueInput
    create: XOR<YoutubeVideoCreateWithoutYoutubeCommentsInput, YoutubeVideoUncheckedCreateWithoutYoutubeCommentsInput>
  }

  export type YoutubeCommentReactionCreateWithoutCommentInput = {
    user: YoutubeUserCreateNestedOneWithoutYoutubeCommentReactionInput
    reaction: ReactionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeChannelId: number
    youtubeVideoId: number
  }

  export type YoutubeCommentReactionUncheckedCreateWithoutCommentInput = {
    id?: number
    reaction: ReactionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeUserId: number
    youtubeChannelId: number
    youtubeVideoId: number
  }

  export type YoutubeCommentReactionCreateOrConnectWithoutCommentInput = {
    where: YoutubeCommentReactionWhereUniqueInput
    create: XOR<YoutubeCommentReactionCreateWithoutCommentInput, YoutubeCommentReactionUncheckedCreateWithoutCommentInput>
  }

  export type YoutubeCommentReactionCreateManyCommentInputEnvelope = {
    data: Enumerable<YoutubeCommentReactionCreateManyCommentInput>
    skipDuplicates?: boolean
  }

  export type YoutubeUserUpsertWithoutYoutubeCommentInput = {
    update: XOR<YoutubeUserUpdateWithoutYoutubeCommentInput, YoutubeUserUncheckedUpdateWithoutYoutubeCommentInput>
    create: XOR<YoutubeUserCreateWithoutYoutubeCommentInput, YoutubeUserUncheckedCreateWithoutYoutubeCommentInput>
  }

  export type YoutubeUserUpdateWithoutYoutubeCommentInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeUsersToChannels?: YoutubeUserToChannelUpdateManyWithoutUserNestedInput
    youtubeSubscriptions?: YoutubeSubscriptionUpdateManyWithoutUserNestedInput
    YoutubeReaction?: YoutubeReactionUpdateManyWithoutUserNestedInput
    YoutubeCommentReaction?: YoutubeCommentReactionUpdateManyWithoutUserNestedInput
  }

  export type YoutubeUserUncheckedUpdateWithoutYoutubeCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeUsersToChannels?: YoutubeUserToChannelUncheckedUpdateManyWithoutUserNestedInput
    youtubeSubscriptions?: YoutubeSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    YoutubeReaction?: YoutubeReactionUncheckedUpdateManyWithoutUserNestedInput
    YoutubeCommentReaction?: YoutubeCommentReactionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type YoutubeVideoUpsertWithoutYoutubeCommentsInput = {
    update: XOR<YoutubeVideoUpdateWithoutYoutubeCommentsInput, YoutubeVideoUncheckedUpdateWithoutYoutubeCommentsInput>
    create: XOR<YoutubeVideoCreateWithoutYoutubeCommentsInput, YoutubeVideoUncheckedCreateWithoutYoutubeCommentsInput>
  }

  export type YoutubeVideoUpdateWithoutYoutubeCommentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    channel?: YoutubeChannelUpdateOneRequiredWithoutYoutubeVideosNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeReactions?: YoutubeReactionUpdateManyWithoutVideoNestedInput
  }

  export type YoutubeVideoUncheckedUpdateWithoutYoutubeCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeChannelId?: IntFieldUpdateOperationsInput | number
    youtubeReactions?: YoutubeReactionUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type YoutubeCommentReactionUpsertWithWhereUniqueWithoutCommentInput = {
    where: YoutubeCommentReactionWhereUniqueInput
    update: XOR<YoutubeCommentReactionUpdateWithoutCommentInput, YoutubeCommentReactionUncheckedUpdateWithoutCommentInput>
    create: XOR<YoutubeCommentReactionCreateWithoutCommentInput, YoutubeCommentReactionUncheckedCreateWithoutCommentInput>
  }

  export type YoutubeCommentReactionUpdateWithWhereUniqueWithoutCommentInput = {
    where: YoutubeCommentReactionWhereUniqueInput
    data: XOR<YoutubeCommentReactionUpdateWithoutCommentInput, YoutubeCommentReactionUncheckedUpdateWithoutCommentInput>
  }

  export type YoutubeCommentReactionUpdateManyWithWhereWithoutCommentInput = {
    where: YoutubeCommentReactionScalarWhereInput
    data: XOR<YoutubeCommentReactionUpdateManyMutationInput, YoutubeCommentReactionUncheckedUpdateManyWithoutYoutubeCommentReactionsInput>
  }

  export type YoutubeUserCreateWithoutYoutubeCommentReactionInput = {
    name: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeUsersToChannels?: YoutubeUserToChannelCreateNestedManyWithoutUserInput
    youtubeSubscriptions?: YoutubeSubscriptionCreateNestedManyWithoutUserInput
    YoutubeReaction?: YoutubeReactionCreateNestedManyWithoutUserInput
    YoutubeComment?: YoutubeCommentCreateNestedManyWithoutUserInput
  }

  export type YoutubeUserUncheckedCreateWithoutYoutubeCommentReactionInput = {
    id?: number
    name: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeUsersToChannels?: YoutubeUserToChannelUncheckedCreateNestedManyWithoutUserInput
    youtubeSubscriptions?: YoutubeSubscriptionUncheckedCreateNestedManyWithoutUserInput
    YoutubeReaction?: YoutubeReactionUncheckedCreateNestedManyWithoutUserInput
    YoutubeComment?: YoutubeCommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type YoutubeUserCreateOrConnectWithoutYoutubeCommentReactionInput = {
    where: YoutubeUserWhereUniqueInput
    create: XOR<YoutubeUserCreateWithoutYoutubeCommentReactionInput, YoutubeUserUncheckedCreateWithoutYoutubeCommentReactionInput>
  }

  export type YoutubeCommentCreateWithoutYoutubeCommentReactionsInput = {
    comment: string
    user: YoutubeUserCreateNestedOneWithoutYoutubeCommentInput
    video: YoutubeVideoCreateNestedOneWithoutYoutubeCommentsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeCommentUncheckedCreateWithoutYoutubeCommentReactionsInput = {
    id?: number
    comment: string
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeVideoId: number
    youtubeUserId: number
  }

  export type YoutubeCommentCreateOrConnectWithoutYoutubeCommentReactionsInput = {
    where: YoutubeCommentWhereUniqueInput
    create: XOR<YoutubeCommentCreateWithoutYoutubeCommentReactionsInput, YoutubeCommentUncheckedCreateWithoutYoutubeCommentReactionsInput>
  }

  export type YoutubeUserUpsertWithoutYoutubeCommentReactionInput = {
    update: XOR<YoutubeUserUpdateWithoutYoutubeCommentReactionInput, YoutubeUserUncheckedUpdateWithoutYoutubeCommentReactionInput>
    create: XOR<YoutubeUserCreateWithoutYoutubeCommentReactionInput, YoutubeUserUncheckedCreateWithoutYoutubeCommentReactionInput>
  }

  export type YoutubeUserUpdateWithoutYoutubeCommentReactionInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeUsersToChannels?: YoutubeUserToChannelUpdateManyWithoutUserNestedInput
    youtubeSubscriptions?: YoutubeSubscriptionUpdateManyWithoutUserNestedInput
    YoutubeReaction?: YoutubeReactionUpdateManyWithoutUserNestedInput
    YoutubeComment?: YoutubeCommentUpdateManyWithoutUserNestedInput
  }

  export type YoutubeUserUncheckedUpdateWithoutYoutubeCommentReactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeUsersToChannels?: YoutubeUserToChannelUncheckedUpdateManyWithoutUserNestedInput
    youtubeSubscriptions?: YoutubeSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    YoutubeReaction?: YoutubeReactionUncheckedUpdateManyWithoutUserNestedInput
    YoutubeComment?: YoutubeCommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type YoutubeCommentUpsertWithoutYoutubeCommentReactionsInput = {
    update: XOR<YoutubeCommentUpdateWithoutYoutubeCommentReactionsInput, YoutubeCommentUncheckedUpdateWithoutYoutubeCommentReactionsInput>
    create: XOR<YoutubeCommentCreateWithoutYoutubeCommentReactionsInput, YoutubeCommentUncheckedCreateWithoutYoutubeCommentReactionsInput>
  }

  export type YoutubeCommentUpdateWithoutYoutubeCommentReactionsInput = {
    comment?: StringFieldUpdateOperationsInput | string
    user?: YoutubeUserUpdateOneRequiredWithoutYoutubeCommentNestedInput
    video?: YoutubeVideoUpdateOneRequiredWithoutYoutubeCommentsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeCommentUncheckedUpdateWithoutYoutubeCommentReactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeVideoId?: IntFieldUpdateOperationsInput | number
    youtubeUserId?: IntFieldUpdateOperationsInput | number
  }

  export type BinKitchenMenuCreateManyCategoryInput = {
    id?: number
    name: string
    image: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinKitchenMenuUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: BinKitchenOrderItemUpdateManyWithoutMenuNestedInput
  }

  export type BinKitchenMenuUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: BinKitchenOrderItemUncheckedUpdateManyWithoutMenuNestedInput
  }

  export type BinKitchenMenuUncheckedUpdateManyWithoutMenusInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinKitchenOrderItemCreateManyMenuInput = {
    id?: number
    quantity: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderId: number
  }

  export type BinKitchenOrderItemUpdateWithoutMenuInput = {
    order?: BinKitchenOrderUpdateOneRequiredWithoutItemsNestedInput
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinKitchenOrderItemUncheckedUpdateWithoutMenuInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: IntFieldUpdateOperationsInput | number
  }

  export type BinKitchenOrderItemUncheckedUpdateManyWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: IntFieldUpdateOperationsInput | number
  }

  export type BinKitchenOrderItemCreateManyOrderInput = {
    id?: number
    quantity: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
    menuId: number
  }

  export type BinKitchenOrderItemUpdateWithoutOrderInput = {
    menu?: BinKitchenMenuUpdateOneRequiredWithoutItemsNestedInput
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinKitchenOrderItemUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menuId?: IntFieldUpdateOperationsInput | number
  }

  export type LaundryWashingMachineCreateManyBranchInput = {
    id?: number
    brand: string
    variant: string
    size: number
    machineType: string
    yearManufactured: number
    insuranceExpiryYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryWashingMachineUpdateWithoutBranchInput = {
    brand?: StringFieldUpdateOperationsInput | string
    variant?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    machineType?: StringFieldUpdateOperationsInput | string
    yearManufactured?: IntFieldUpdateOperationsInput | number
    insuranceExpiryYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryWashingMachinesToPrograms?: LaundryWashingMachineToProgramUpdateManyWithoutMachineNestedInput
    laundryMaintainances?: LaundryMaintainanceUpdateManyWithoutMachineNestedInput
    laundryUserHistories?: LaundryUserHistoryUpdateManyWithoutMachineNestedInput
  }

  export type LaundryWashingMachineUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand?: StringFieldUpdateOperationsInput | string
    variant?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    machineType?: StringFieldUpdateOperationsInput | string
    yearManufactured?: IntFieldUpdateOperationsInput | number
    insuranceExpiryYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryWashingMachinesToPrograms?: LaundryWashingMachineToProgramUncheckedUpdateManyWithoutMachineNestedInput
    laundryMaintainances?: LaundryMaintainanceUncheckedUpdateManyWithoutMachineNestedInput
    laundryUserHistories?: LaundryUserHistoryUncheckedUpdateManyWithoutMachineNestedInput
  }

  export type LaundryWashingMachineUncheckedUpdateManyWithoutLaundryWashingMachinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand?: StringFieldUpdateOperationsInput | string
    variant?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    machineType?: StringFieldUpdateOperationsInput | string
    yearManufactured?: IntFieldUpdateOperationsInput | number
    insuranceExpiryYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryWashingMachineToProgramCreateManyMachineInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryProgramId: number
  }

  export type LaundryMaintainanceCreateManyMachineInput = {
    id?: number
    round: number
    date: number
    damageLevel: number
    description: string
    technicianName: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryUserHistoryCreateManyMachineInput = {
    id?: number
    washNumber: number
    date: number
    duration: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryUserId: number
    laundryProgramId: number
  }

  export type LaundryWashingMachineToProgramUpdateWithoutMachineInput = {
    program?: LaundryProgramUpdateOneRequiredWithoutLaundryWashingMachinesToProgramsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryWashingMachineToProgramUncheckedUpdateWithoutMachineInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryProgramId?: IntFieldUpdateOperationsInput | number
  }

  export type LaundryWashingMachineToProgramUncheckedUpdateManyWithoutLaundryWashingMachinesToProgramsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryProgramId?: IntFieldUpdateOperationsInput | number
  }

  export type LaundryMaintainanceUpdateWithoutMachineInput = {
    round?: IntFieldUpdateOperationsInput | number
    date?: IntFieldUpdateOperationsInput | number
    damageLevel?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    technicianName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryMaintainanceUncheckedUpdateWithoutMachineInput = {
    id?: IntFieldUpdateOperationsInput | number
    round?: IntFieldUpdateOperationsInput | number
    date?: IntFieldUpdateOperationsInput | number
    damageLevel?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    technicianName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryMaintainanceUncheckedUpdateManyWithoutLaundryMaintainancesInput = {
    id?: IntFieldUpdateOperationsInput | number
    round?: IntFieldUpdateOperationsInput | number
    date?: IntFieldUpdateOperationsInput | number
    damageLevel?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    technicianName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryUserHistoryUpdateWithoutMachineInput = {
    user?: LaundryUserUpdateOneRequiredWithoutLaundryUserHistoriesNestedInput
    washNumber?: IntFieldUpdateOperationsInput | number
    program?: LaundryProgramUpdateOneRequiredWithoutLaundryUserHistoriesNestedInput
    date?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryUserHistoryUncheckedUpdateWithoutMachineInput = {
    id?: IntFieldUpdateOperationsInput | number
    washNumber?: IntFieldUpdateOperationsInput | number
    date?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryUserId?: IntFieldUpdateOperationsInput | number
    laundryProgramId?: IntFieldUpdateOperationsInput | number
  }

  export type LaundryUserHistoryUncheckedUpdateManyWithoutLaundryUserHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    washNumber?: IntFieldUpdateOperationsInput | number
    date?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryUserId?: IntFieldUpdateOperationsInput | number
    laundryProgramId?: IntFieldUpdateOperationsInput | number
  }

  export type LaundryWashingMachineToProgramCreateManyProgramInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryWashingMachineId: number
  }

  export type LaundryUserHistoryCreateManyProgramInput = {
    id?: number
    washNumber: number
    date: number
    duration: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryUserId: number
    laundryWashingMachineId: number
  }

  export type LaundryWashingMachineToProgramUpdateWithoutProgramInput = {
    machine?: LaundryWashingMachineUpdateOneRequiredWithoutLaundryWashingMachinesToProgramsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryWashingMachineToProgramUncheckedUpdateWithoutProgramInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryWashingMachineId?: IntFieldUpdateOperationsInput | number
  }

  export type LaundryUserHistoryUpdateWithoutProgramInput = {
    user?: LaundryUserUpdateOneRequiredWithoutLaundryUserHistoriesNestedInput
    washNumber?: IntFieldUpdateOperationsInput | number
    machine?: LaundryWashingMachineUpdateOneRequiredWithoutLaundryUserHistoriesNestedInput
    date?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryUserHistoryUncheckedUpdateWithoutProgramInput = {
    id?: IntFieldUpdateOperationsInput | number
    washNumber?: IntFieldUpdateOperationsInput | number
    date?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryUserId?: IntFieldUpdateOperationsInput | number
    laundryWashingMachineId?: IntFieldUpdateOperationsInput | number
  }

  export type LaundryUserHistoryCreateManyUserInput = {
    id?: number
    washNumber: number
    date: number
    duration: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    laundryWashingMachineId: number
    laundryProgramId: number
  }

  export type LaundryBalanceTopupCreateManyUserInput = {
    id?: number
    topUpRound: number
    topUpAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryUserHistoryUpdateWithoutUserInput = {
    washNumber?: IntFieldUpdateOperationsInput | number
    machine?: LaundryWashingMachineUpdateOneRequiredWithoutLaundryUserHistoriesNestedInput
    program?: LaundryProgramUpdateOneRequiredWithoutLaundryUserHistoriesNestedInput
    date?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryUserHistoryUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    washNumber?: IntFieldUpdateOperationsInput | number
    date?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laundryWashingMachineId?: IntFieldUpdateOperationsInput | number
    laundryProgramId?: IntFieldUpdateOperationsInput | number
  }

  export type LaundryBalanceTopupUpdateWithoutUserInput = {
    topUpRound?: IntFieldUpdateOperationsInput | number
    topUpAmount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryBalanceTopupUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    topUpRound?: IntFieldUpdateOperationsInput | number
    topUpAmount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryBalanceTopupUncheckedUpdateManyWithoutLaundryBalanceTopupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    topUpRound?: IntFieldUpdateOperationsInput | number
    topUpAmount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryCategoryToBookCreateManyCategoryInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryBookId: number
  }

  export type LibraryCategoryToBookUpdateWithoutCategoryInput = {
    book?: LibraryBookUpdateOneRequiredWithoutLibraryCategoriesToBooksNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryCategoryToBookUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryBookId?: IntFieldUpdateOperationsInput | number
  }

  export type LibraryCategoryToBookUncheckedUpdateManyWithoutLibraryCategoriesToBooksInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryBookId?: IntFieldUpdateOperationsInput | number
  }

  export type LibraryCategoryToBookCreateManyBookInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryBookCategoryId: number
  }

  export type LibraryBookToAuthorCreateManyBookInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryBookAuthorId: number
  }

  export type LibraryBookCopyCreateManyBookInput = {
    id?: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryUniversityId: number
    libraryStudentId: number
  }

  export type LibraryCategoryToBookUpdateWithoutBookInput = {
    category?: LibraryBookCategoryUpdateOneRequiredWithoutLibraryCategoriesToBooksNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryCategoryToBookUncheckedUpdateWithoutBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryBookCategoryId?: IntFieldUpdateOperationsInput | number
  }

  export type LibraryBookToAuthorUpdateWithoutBookInput = {
    author?: LibraryBookAuthorUpdateOneRequiredWithoutLibraryBooksToAuthorsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookToAuthorUncheckedUpdateWithoutBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryBookAuthorId?: IntFieldUpdateOperationsInput | number
  }

  export type LibraryBookToAuthorUncheckedUpdateManyWithoutLibraryBooksToAuthorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryBookAuthorId?: IntFieldUpdateOperationsInput | number
  }

  export type LibraryBookCopyUpdateWithoutBookInput = {
    status?: StringFieldUpdateOperationsInput | string
    university?: LibraryUniversityUpdateOneRequiredWithoutLibraryBookCopiesNestedInput
    borrowedBy?: LibraryStudentUpdateOneRequiredWithoutLibraryBookCopiesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryBorrowingHistories?: LibraryBorrowingHistoryUpdateManyWithoutCopyNestedInput
    libraryRequests?: LibraryRequestUpdateManyWithoutCopyNestedInput
  }

  export type LibraryBookCopyUncheckedUpdateWithoutBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryUniversityId?: IntFieldUpdateOperationsInput | number
    libraryStudentId?: IntFieldUpdateOperationsInput | number
    libraryBorrowingHistories?: LibraryBorrowingHistoryUncheckedUpdateManyWithoutCopyNestedInput
    libraryRequests?: LibraryRequestUncheckedUpdateManyWithoutCopyNestedInput
  }

  export type LibraryBookCopyUncheckedUpdateManyWithoutLibraryBookCopiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryUniversityId?: IntFieldUpdateOperationsInput | number
    libraryStudentId?: IntFieldUpdateOperationsInput | number
  }

  export type LibraryBookToAuthorCreateManyAuthorInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryBookId: number
  }

  export type LibraryBookToAuthorUpdateWithoutAuthorInput = {
    book?: LibraryBookUpdateOneRequiredWithoutLibraryBooksToAuthorsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookToAuthorUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryBookId?: IntFieldUpdateOperationsInput | number
  }

  export type LibraryStudentCreateManyUniversityInput = {
    id?: number
    studentId: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBookCopyCreateManyUniversityInput = {
    id?: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryBookId: number
    libraryStudentId: number
  }

  export type LibraryBorrowingHistoryCreateManyBorrowedFromInput = {
    id?: number
    borrowDate: number
    returnDate: number
    actualReturnDate: number
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryStudentId: number
    libraryBookCopyId: number
  }

  export type LibraryRequestCreateManyFromInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryStudentId: number
    libraryBookCopyId: number
    toLibraryUniversityId: number
  }

  export type LibraryRequestCreateManyToInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryStudentId: number
    libraryBookCopyId: number
    fromLibraryUniversityId: number
  }

  export type LibraryStudentUpdateWithoutUniversityInput = {
    studentId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryBookCopies?: LibraryBookCopyUpdateManyWithoutBorrowedByNestedInput
    libraryBorrowingHistories?: LibraryBorrowingHistoryUpdateManyWithoutStudentNestedInput
    libraryRequests?: LibraryRequestUpdateManyWithoutStudentNestedInput
  }

  export type LibraryStudentUncheckedUpdateWithoutUniversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryBookCopies?: LibraryBookCopyUncheckedUpdateManyWithoutBorrowedByNestedInput
    libraryBorrowingHistories?: LibraryBorrowingHistoryUncheckedUpdateManyWithoutStudentNestedInput
    libraryRequests?: LibraryRequestUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type LibraryStudentUncheckedUpdateManyWithoutLibraryStudentaInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookCopyUpdateWithoutUniversityInput = {
    book?: LibraryBookUpdateOneRequiredWithoutLibraryBookCopiesNestedInput
    status?: StringFieldUpdateOperationsInput | string
    borrowedBy?: LibraryStudentUpdateOneRequiredWithoutLibraryBookCopiesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryBorrowingHistories?: LibraryBorrowingHistoryUpdateManyWithoutCopyNestedInput
    libraryRequests?: LibraryRequestUpdateManyWithoutCopyNestedInput
  }

  export type LibraryBookCopyUncheckedUpdateWithoutUniversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryBookId?: IntFieldUpdateOperationsInput | number
    libraryStudentId?: IntFieldUpdateOperationsInput | number
    libraryBorrowingHistories?: LibraryBorrowingHistoryUncheckedUpdateManyWithoutCopyNestedInput
    libraryRequests?: LibraryRequestUncheckedUpdateManyWithoutCopyNestedInput
  }

  export type LibraryBorrowingHistoryUpdateWithoutBorrowedFromInput = {
    student?: LibraryStudentUpdateOneRequiredWithoutLibraryBorrowingHistoriesNestedInput
    copy?: LibraryBookCopyUpdateOneRequiredWithoutLibraryBorrowingHistoriesNestedInput
    borrowDate?: IntFieldUpdateOperationsInput | number
    returnDate?: IntFieldUpdateOperationsInput | number
    actualReturnDate?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBorrowingHistoryUncheckedUpdateWithoutBorrowedFromInput = {
    id?: IntFieldUpdateOperationsInput | number
    borrowDate?: IntFieldUpdateOperationsInput | number
    returnDate?: IntFieldUpdateOperationsInput | number
    actualReturnDate?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryStudentId?: IntFieldUpdateOperationsInput | number
    libraryBookCopyId?: IntFieldUpdateOperationsInput | number
  }

  export type LibraryBorrowingHistoryUncheckedUpdateManyWithoutLibraryBorrowingHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    borrowDate?: IntFieldUpdateOperationsInput | number
    returnDate?: IntFieldUpdateOperationsInput | number
    actualReturnDate?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryStudentId?: IntFieldUpdateOperationsInput | number
    libraryBookCopyId?: IntFieldUpdateOperationsInput | number
  }

  export type LibraryRequestUpdateWithoutFromInput = {
    student?: LibraryStudentUpdateOneRequiredWithoutLibraryRequestsNestedInput
    copy?: LibraryBookCopyUpdateOneRequiredWithoutLibraryRequestsNestedInput
    to?: LibraryUniversityUpdateOneRequiredWithoutToLibraryRequestsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryRequestUncheckedUpdateWithoutFromInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryStudentId?: IntFieldUpdateOperationsInput | number
    libraryBookCopyId?: IntFieldUpdateOperationsInput | number
    toLibraryUniversityId?: IntFieldUpdateOperationsInput | number
  }

  export type LibraryRequestUncheckedUpdateManyWithoutFromLibraryRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryStudentId?: IntFieldUpdateOperationsInput | number
    libraryBookCopyId?: IntFieldUpdateOperationsInput | number
    toLibraryUniversityId?: IntFieldUpdateOperationsInput | number
  }

  export type LibraryRequestUpdateWithoutToInput = {
    student?: LibraryStudentUpdateOneRequiredWithoutLibraryRequestsNestedInput
    copy?: LibraryBookCopyUpdateOneRequiredWithoutLibraryRequestsNestedInput
    from?: LibraryUniversityUpdateOneRequiredWithoutFromLibraryRequestsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryRequestUncheckedUpdateWithoutToInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryStudentId?: IntFieldUpdateOperationsInput | number
    libraryBookCopyId?: IntFieldUpdateOperationsInput | number
    fromLibraryUniversityId?: IntFieldUpdateOperationsInput | number
  }

  export type LibraryRequestUncheckedUpdateManyWithoutToLibraryRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryStudentId?: IntFieldUpdateOperationsInput | number
    libraryBookCopyId?: IntFieldUpdateOperationsInput | number
    fromLibraryUniversityId?: IntFieldUpdateOperationsInput | number
  }

  export type LibraryBookCopyCreateManyBorrowedByInput = {
    id?: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryBookId: number
    libraryUniversityId: number
  }

  export type LibraryBorrowingHistoryCreateManyStudentInput = {
    id?: number
    borrowDate: number
    returnDate: number
    actualReturnDate: number
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryBookCopyId: number
    libraryUniversityId: number
  }

  export type LibraryRequestCreateManyStudentInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryBookCopyId: number
    fromLibraryUniversityId: number
    toLibraryUniversityId: number
  }

  export type LibraryBookCopyUpdateWithoutBorrowedByInput = {
    book?: LibraryBookUpdateOneRequiredWithoutLibraryBookCopiesNestedInput
    status?: StringFieldUpdateOperationsInput | string
    university?: LibraryUniversityUpdateOneRequiredWithoutLibraryBookCopiesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryBorrowingHistories?: LibraryBorrowingHistoryUpdateManyWithoutCopyNestedInput
    libraryRequests?: LibraryRequestUpdateManyWithoutCopyNestedInput
  }

  export type LibraryBookCopyUncheckedUpdateWithoutBorrowedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryBookId?: IntFieldUpdateOperationsInput | number
    libraryUniversityId?: IntFieldUpdateOperationsInput | number
    libraryBorrowingHistories?: LibraryBorrowingHistoryUncheckedUpdateManyWithoutCopyNestedInput
    libraryRequests?: LibraryRequestUncheckedUpdateManyWithoutCopyNestedInput
  }

  export type LibraryBorrowingHistoryUpdateWithoutStudentInput = {
    copy?: LibraryBookCopyUpdateOneRequiredWithoutLibraryBorrowingHistoriesNestedInput
    borrowDate?: IntFieldUpdateOperationsInput | number
    returnDate?: IntFieldUpdateOperationsInput | number
    actualReturnDate?: IntFieldUpdateOperationsInput | number
    borrowedFrom?: LibraryUniversityUpdateOneRequiredWithoutLibraryBorrowingHistoriesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBorrowingHistoryUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    borrowDate?: IntFieldUpdateOperationsInput | number
    returnDate?: IntFieldUpdateOperationsInput | number
    actualReturnDate?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryBookCopyId?: IntFieldUpdateOperationsInput | number
    libraryUniversityId?: IntFieldUpdateOperationsInput | number
  }

  export type LibraryRequestUpdateWithoutStudentInput = {
    copy?: LibraryBookCopyUpdateOneRequiredWithoutLibraryRequestsNestedInput
    from?: LibraryUniversityUpdateOneRequiredWithoutFromLibraryRequestsNestedInput
    to?: LibraryUniversityUpdateOneRequiredWithoutToLibraryRequestsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryRequestUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryBookCopyId?: IntFieldUpdateOperationsInput | number
    fromLibraryUniversityId?: IntFieldUpdateOperationsInput | number
    toLibraryUniversityId?: IntFieldUpdateOperationsInput | number
  }

  export type LibraryRequestUncheckedUpdateManyWithoutLibraryRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryBookCopyId?: IntFieldUpdateOperationsInput | number
    fromLibraryUniversityId?: IntFieldUpdateOperationsInput | number
    toLibraryUniversityId?: IntFieldUpdateOperationsInput | number
  }

  export type LibraryBorrowingHistoryCreateManyCopyInput = {
    id?: number
    borrowDate: number
    returnDate: number
    actualReturnDate: number
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryStudentId: number
    libraryUniversityId: number
  }

  export type LibraryRequestCreateManyCopyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryStudentId: number
    fromLibraryUniversityId: number
    toLibraryUniversityId: number
  }

  export type LibraryBorrowingHistoryUpdateWithoutCopyInput = {
    student?: LibraryStudentUpdateOneRequiredWithoutLibraryBorrowingHistoriesNestedInput
    borrowDate?: IntFieldUpdateOperationsInput | number
    returnDate?: IntFieldUpdateOperationsInput | number
    actualReturnDate?: IntFieldUpdateOperationsInput | number
    borrowedFrom?: LibraryUniversityUpdateOneRequiredWithoutLibraryBorrowingHistoriesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBorrowingHistoryUncheckedUpdateWithoutCopyInput = {
    id?: IntFieldUpdateOperationsInput | number
    borrowDate?: IntFieldUpdateOperationsInput | number
    returnDate?: IntFieldUpdateOperationsInput | number
    actualReturnDate?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryStudentId?: IntFieldUpdateOperationsInput | number
    libraryUniversityId?: IntFieldUpdateOperationsInput | number
  }

  export type LibraryRequestUpdateWithoutCopyInput = {
    student?: LibraryStudentUpdateOneRequiredWithoutLibraryRequestsNestedInput
    from?: LibraryUniversityUpdateOneRequiredWithoutFromLibraryRequestsNestedInput
    to?: LibraryUniversityUpdateOneRequiredWithoutToLibraryRequestsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryRequestUncheckedUpdateWithoutCopyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryStudentId?: IntFieldUpdateOperationsInput | number
    fromLibraryUniversityId?: IntFieldUpdateOperationsInput | number
    toLibraryUniversityId?: IntFieldUpdateOperationsInput | number
  }

  export type QuizQuestionCreateManyCategoryInput = {
    id?: number
    name: string
    answerId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizRoundCreateManyCategoryInput = {
    id?: number
    name: string
    totalScore: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizQuestionUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    answerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizChoices?: QuizChoiceUpdateManyWithoutQuestionNestedInput
    quizRecords?: QuizRecordUpdateManyWithoutQuestionNestedInput
  }

  export type QuizQuestionUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    answerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizChoices?: QuizChoiceUncheckedUpdateManyWithoutQuestionNestedInput
    quizRecords?: QuizRecordUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuizQuestionUncheckedUpdateManyWithoutQuizQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    answerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizRoundUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    totalScore?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizRecords?: QuizRecordUpdateManyWithoutRoundNestedInput
  }

  export type QuizRoundUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    totalScore?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizRecords?: QuizRecordUncheckedUpdateManyWithoutRoundNestedInput
  }

  export type QuizRoundUncheckedUpdateManyWithoutQuizRoundInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    totalScore?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizChoiceCreateManyQuestionInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizRecordCreateManyQuestionInput = {
    id?: number
    quizRoundId: number
    quizChoiceId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizChoiceUpdateWithoutQuestionInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizRecords?: QuizRecordUpdateManyWithoutPlayerChoiceNestedInput
  }

  export type QuizChoiceUncheckedUpdateWithoutQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizRecords?: QuizRecordUncheckedUpdateManyWithoutPlayerChoiceNestedInput
  }

  export type QuizChoiceUncheckedUpdateManyWithoutQuizChoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizRecordUpdateWithoutQuestionInput = {
    round?: QuizRoundUpdateOneWithoutQuizRecordsNestedInput
    playerChoice?: QuizChoiceUpdateOneWithoutQuizRecordsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizRecordUncheckedUpdateWithoutQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizRoundId?: IntFieldUpdateOperationsInput | number
    quizChoiceId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizRecordUncheckedUpdateManyWithoutQuizRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizRoundId?: IntFieldUpdateOperationsInput | number
    quizChoiceId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizRecordCreateManyPlayerChoiceInput = {
    id?: number
    quizRoundId: number
    quizQuestionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizRecordUpdateWithoutPlayerChoiceInput = {
    round?: QuizRoundUpdateOneWithoutQuizRecordsNestedInput
    question?: QuizQuestionUpdateOneWithoutQuizRecordsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizRecordUncheckedUpdateWithoutPlayerChoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizRoundId?: IntFieldUpdateOperationsInput | number
    quizQuestionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizRecordCreateManyRoundInput = {
    id?: number
    quizChoiceId: number
    quizQuestionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizRecordUpdateWithoutRoundInput = {
    playerChoice?: QuizChoiceUpdateOneWithoutQuizRecordsNestedInput
    question?: QuizQuestionUpdateOneWithoutQuizRecordsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizRecordUncheckedUpdateWithoutRoundInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizChoiceId?: IntFieldUpdateOperationsInput | number
    quizQuestionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterPostCreateManyUserInput = {
    id?: number
    post: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterDirectMessageCreateManyFromInput = {
    id?: number
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    followerUserId: number
  }

  export type TwitterCommentCreateManyUserInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    twitterPostId: number
  }

  export type TwitterDirectMessageCreateManyToInput = {
    id?: number
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    followingUserId: number
  }

  export type TwitterUserRelationCreateManyFromInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    toUserId: number
  }

  export type TwitterUserRelationCreateManyToInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    fromUserId: number
  }

  export type TwitterPostUpdateWithoutUserInput = {
    post?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postToHashtags?: TwitterPostToHashtagUpdateManyWithoutPostNestedInput
    comments?: TwitterCommentUpdateManyWithoutPostNestedInput
  }

  export type TwitterPostUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    post?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postToHashtags?: TwitterPostToHashtagUncheckedUpdateManyWithoutPostNestedInput
    comments?: TwitterCommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type TwitterPostUncheckedUpdateManyWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    post?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterDirectMessageUpdateWithoutFromInput = {
    message?: StringFieldUpdateOperationsInput | string
    to?: TwitterUserUpdateOneRequiredWithoutToDirectMessagesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterDirectMessageUncheckedUpdateWithoutFromInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followerUserId?: IntFieldUpdateOperationsInput | number
  }

  export type TwitterDirectMessageUncheckedUpdateManyWithoutFromDirectMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followerUserId?: IntFieldUpdateOperationsInput | number
  }

  export type TwitterCommentUpdateWithoutUserInput = {
    post?: TwitterPostUpdateOneRequiredWithoutCommentsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterCommentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twitterPostId?: IntFieldUpdateOperationsInput | number
  }

  export type TwitterCommentUncheckedUpdateManyWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twitterPostId?: IntFieldUpdateOperationsInput | number
  }

  export type TwitterDirectMessageUpdateWithoutToInput = {
    message?: StringFieldUpdateOperationsInput | string
    from?: TwitterUserUpdateOneRequiredWithoutFromDirectMessagesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterDirectMessageUncheckedUpdateWithoutToInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followingUserId?: IntFieldUpdateOperationsInput | number
  }

  export type TwitterDirectMessageUncheckedUpdateManyWithoutToDirectMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followingUserId?: IntFieldUpdateOperationsInput | number
  }

  export type TwitterUserRelationUpdateWithoutFromInput = {
    to?: TwitterUserUpdateOneRequiredWithoutFollowerUserRelationsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterUserRelationUncheckedUpdateWithoutFromInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    toUserId?: IntFieldUpdateOperationsInput | number
  }

  export type TwitterUserRelationUncheckedUpdateManyWithoutFollowingUserRelationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    toUserId?: IntFieldUpdateOperationsInput | number
  }

  export type TwitterUserRelationUpdateWithoutToInput = {
    from?: TwitterUserUpdateOneRequiredWithoutFollowingUserRelationsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterUserRelationUncheckedUpdateWithoutToInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromUserId?: IntFieldUpdateOperationsInput | number
  }

  export type TwitterUserRelationUncheckedUpdateManyWithoutFollowerUserRelationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromUserId?: IntFieldUpdateOperationsInput | number
  }

  export type TwitterPostToHashtagCreateManyPostInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    twitterHashtagId: number
  }

  export type TwitterCommentCreateManyPostInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    twitterUserId: number
  }

  export type TwitterPostToHashtagUpdateWithoutPostInput = {
    hashtag?: TwitterHashtagUpdateOneRequiredWithoutPostsToHashtagsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterPostToHashtagUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twitterHashtagId?: IntFieldUpdateOperationsInput | number
  }

  export type TwitterPostToHashtagUncheckedUpdateManyWithoutPostToHashtagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twitterHashtagId?: IntFieldUpdateOperationsInput | number
  }

  export type TwitterCommentUpdateWithoutPostInput = {
    user?: TwitterUserUpdateOneRequiredWithoutCommentsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterCommentUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twitterUserId?: IntFieldUpdateOperationsInput | number
  }

  export type TwitterPostToHashtagCreateManyHashtagInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    twitterPostId: number
  }

  export type TwitterPostToHashtagUpdateWithoutHashtagInput = {
    post?: TwitterPostUpdateOneRequiredWithoutPostToHashtagsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterPostToHashtagUncheckedUpdateWithoutHashtagInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twitterPostId?: IntFieldUpdateOperationsInput | number
  }

  export type TwitterPostToHashtagUncheckedUpdateManyWithoutPostsToHashtagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twitterPostId?: IntFieldUpdateOperationsInput | number
  }

  export type YoutubeUserToChannelCreateManyUserInput = {
    id?: number
    description: string
    role: RoleEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeChannelId: number
  }

  export type YoutubeSubscriptionCreateManyUserInput = {
    id?: number
    membership: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeChannelId: number
  }

  export type YoutubeReactionCreateManyUserInput = {
    id?: number
    reaction: ReactionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeChannelId: number
    youtubeVideoId: number
    youtubeCommentId: number
  }

  export type YoutubeCommentCreateManyUserInput = {
    id?: number
    comment: string
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeVideoId: number
  }

  export type YoutubeCommentReactionCreateManyUserInput = {
    id?: number
    reaction: ReactionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeChannelId: number
    youtubeVideoId: number
    youtubeCommentId: number
  }

  export type YoutubeUserToChannelUpdateWithoutUserInput = {
    channel?: YoutubeChannelUpdateOneRequiredWithoutYoutubeUsersToChannelsNestedInput
    description?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleEnumFieldUpdateOperationsInput | RoleEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeUserToChannelUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleEnumFieldUpdateOperationsInput | RoleEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeChannelId?: IntFieldUpdateOperationsInput | number
  }

  export type YoutubeUserToChannelUncheckedUpdateManyWithoutYoutubeUsersToChannelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleEnumFieldUpdateOperationsInput | RoleEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeChannelId?: IntFieldUpdateOperationsInput | number
  }

  export type YoutubeSubscriptionUpdateWithoutUserInput = {
    channel?: YoutubeChannelUpdateOneRequiredWithoutYoutubeSubscriptionsNestedInput
    membership?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeSubscriptionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    membership?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeChannelId?: IntFieldUpdateOperationsInput | number
  }

  export type YoutubeSubscriptionUncheckedUpdateManyWithoutYoutubeSubscriptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    membership?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeChannelId?: IntFieldUpdateOperationsInput | number
  }

  export type YoutubeReactionUpdateWithoutUserInput = {
    video?: YoutubeVideoUpdateOneRequiredWithoutYoutubeReactionsNestedInput
    reaction?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeChannelId?: IntFieldUpdateOperationsInput | number
    youtubeCommentId?: IntFieldUpdateOperationsInput | number
  }

  export type YoutubeReactionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    reaction?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeChannelId?: IntFieldUpdateOperationsInput | number
    youtubeVideoId?: IntFieldUpdateOperationsInput | number
    youtubeCommentId?: IntFieldUpdateOperationsInput | number
  }

  export type YoutubeReactionUncheckedUpdateManyWithoutYoutubeReactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    reaction?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeChannelId?: IntFieldUpdateOperationsInput | number
    youtubeVideoId?: IntFieldUpdateOperationsInput | number
    youtubeCommentId?: IntFieldUpdateOperationsInput | number
  }

  export type YoutubeCommentUpdateWithoutUserInput = {
    comment?: StringFieldUpdateOperationsInput | string
    video?: YoutubeVideoUpdateOneRequiredWithoutYoutubeCommentsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeCommentReactions?: YoutubeCommentReactionUpdateManyWithoutCommentNestedInput
  }

  export type YoutubeCommentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeVideoId?: IntFieldUpdateOperationsInput | number
    youtubeCommentReactions?: YoutubeCommentReactionUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type YoutubeCommentUncheckedUpdateManyWithoutYoutubeCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeVideoId?: IntFieldUpdateOperationsInput | number
  }

  export type YoutubeCommentReactionUpdateWithoutUserInput = {
    comment?: YoutubeCommentUpdateOneRequiredWithoutYoutubeCommentReactionsNestedInput
    reaction?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeChannelId?: IntFieldUpdateOperationsInput | number
    youtubeVideoId?: IntFieldUpdateOperationsInput | number
  }

  export type YoutubeCommentReactionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    reaction?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeChannelId?: IntFieldUpdateOperationsInput | number
    youtubeVideoId?: IntFieldUpdateOperationsInput | number
    youtubeCommentId?: IntFieldUpdateOperationsInput | number
  }

  export type YoutubeCommentReactionUncheckedUpdateManyWithoutYoutubeCommentReactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    reaction?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeChannelId?: IntFieldUpdateOperationsInput | number
    youtubeVideoId?: IntFieldUpdateOperationsInput | number
    youtubeCommentId?: IntFieldUpdateOperationsInput | number
  }

  export type YoutubeUserToChannelCreateManyChannelInput = {
    id?: number
    description: string
    role: RoleEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeUserId: number
  }

  export type YoutubeVideoCreateManyChannelInput = {
    id?: number
    name: string
    videoUrl: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeSubscriptionCreateManyChannelInput = {
    id?: number
    membership: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeUserId: number
  }

  export type YoutubeUserToChannelUpdateWithoutChannelInput = {
    user?: YoutubeUserUpdateOneRequiredWithoutYoutubeUsersToChannelsNestedInput
    description?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleEnumFieldUpdateOperationsInput | RoleEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeUserToChannelUncheckedUpdateWithoutChannelInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleEnumFieldUpdateOperationsInput | RoleEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeUserId?: IntFieldUpdateOperationsInput | number
  }

  export type YoutubeVideoUpdateWithoutChannelInput = {
    name?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeComments?: YoutubeCommentUpdateManyWithoutVideoNestedInput
    youtubeReactions?: YoutubeReactionUpdateManyWithoutVideoNestedInput
  }

  export type YoutubeVideoUncheckedUpdateWithoutChannelInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeComments?: YoutubeCommentUncheckedUpdateManyWithoutVideoNestedInput
    youtubeReactions?: YoutubeReactionUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type YoutubeVideoUncheckedUpdateManyWithoutYoutubeVideosInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeSubscriptionUpdateWithoutChannelInput = {
    user?: YoutubeUserUpdateOneRequiredWithoutYoutubeSubscriptionsNestedInput
    membership?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeSubscriptionUncheckedUpdateWithoutChannelInput = {
    id?: IntFieldUpdateOperationsInput | number
    membership?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeUserId?: IntFieldUpdateOperationsInput | number
  }

  export type YoutubeCommentCreateManyVideoInput = {
    id?: number
    comment: string
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeUserId: number
  }

  export type YoutubeReactionCreateManyVideoInput = {
    id?: number
    reaction: ReactionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeUserId: number
    youtubeChannelId: number
    youtubeCommentId: number
  }

  export type YoutubeCommentUpdateWithoutVideoInput = {
    comment?: StringFieldUpdateOperationsInput | string
    user?: YoutubeUserUpdateOneRequiredWithoutYoutubeCommentNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeCommentReactions?: YoutubeCommentReactionUpdateManyWithoutCommentNestedInput
  }

  export type YoutubeCommentUncheckedUpdateWithoutVideoInput = {
    id?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeUserId?: IntFieldUpdateOperationsInput | number
    youtubeCommentReactions?: YoutubeCommentReactionUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type YoutubeCommentUncheckedUpdateManyWithoutYoutubeCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeUserId?: IntFieldUpdateOperationsInput | number
  }

  export type YoutubeReactionUpdateWithoutVideoInput = {
    user?: YoutubeUserUpdateOneRequiredWithoutYoutubeReactionNestedInput
    reaction?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeChannelId?: IntFieldUpdateOperationsInput | number
    youtubeCommentId?: IntFieldUpdateOperationsInput | number
  }

  export type YoutubeReactionUncheckedUpdateWithoutVideoInput = {
    id?: IntFieldUpdateOperationsInput | number
    reaction?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeUserId?: IntFieldUpdateOperationsInput | number
    youtubeChannelId?: IntFieldUpdateOperationsInput | number
    youtubeCommentId?: IntFieldUpdateOperationsInput | number
  }

  export type YoutubeReactionUncheckedUpdateManyWithoutYoutubeReactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    reaction?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeUserId?: IntFieldUpdateOperationsInput | number
    youtubeChannelId?: IntFieldUpdateOperationsInput | number
    youtubeCommentId?: IntFieldUpdateOperationsInput | number
  }

  export type YoutubeCommentReactionCreateManyCommentInput = {
    id?: number
    reaction: ReactionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    youtubeUserId: number
    youtubeChannelId: number
    youtubeVideoId: number
  }

  export type YoutubeCommentReactionUpdateWithoutCommentInput = {
    user?: YoutubeUserUpdateOneRequiredWithoutYoutubeCommentReactionNestedInput
    reaction?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeChannelId?: IntFieldUpdateOperationsInput | number
    youtubeVideoId?: IntFieldUpdateOperationsInput | number
  }

  export type YoutubeCommentReactionUncheckedUpdateWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    reaction?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeUserId?: IntFieldUpdateOperationsInput | number
    youtubeChannelId?: IntFieldUpdateOperationsInput | number
    youtubeVideoId?: IntFieldUpdateOperationsInput | number
  }

  export type YoutubeCommentReactionUncheckedUpdateManyWithoutYoutubeCommentReactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    reaction?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeUserId?: IntFieldUpdateOperationsInput | number
    youtubeChannelId?: IntFieldUpdateOperationsInput | number
    youtubeVideoId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}