
/**
 * Client
**/

import * as runtime from './runtime/library';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model BKReserveUser
 * 
 */
export type BKReserveUser = {
  id: number
  universityId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model BKRequest
 * 
 */
export type BKRequest = {
  id: number
  reserveUserId: number
  copyId: number
  fromUniversityId: number
  toUniversityId: number
  requestDate: Date
  status: RequestStatusEnum
  planRecievedDate: Date
  createdAt: Date
  updatedAt: Date
}

/**
 * Model BKBorrowingHistory
 * 
 */
export type BKBorrowingHistory = {
  id: number
  reserveUserId: number
  copyId: number
  fromUniversityId: number
  borrowDate: Date
  returnDate: Date
  actualReturnDate: Date
  createdAt: Date
  updatedAt: Date
}

/**
 * Model BKCopy
 * 
 */
export type BKCopy = {
  id: number
  status: CopyStatusEnum
  titleId: number
  reserveUserId: number | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model BKUniversity
 * 
 */
export type BKUniversity = {
  id: number
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model BKTitle
 * 
 */
export type BKTitle = {
  id: number
  name: string
  ISBN: number
  copyQty: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model UniversityToTitle
 * 
 */
export type UniversityToTitle = {
  id: number
  universityId: number
  titleId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model BKCategory
 * 
 */
export type BKCategory = {
  id: number
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model TitleToCategory
 * 
 */
export type TitleToCategory = {
  id: number
  titleId: number
  categoryId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model BKAuthor
 * 
 */
export type BKAuthor = {
  id: number
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model TitleToAuthor
 * 
 */
export type TitleToAuthor = {
  id: number
  titleId: number
  authorId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model FbUser
 * 
 */
export type FbUser = {
  id: number
  name: string
  image: string
  location: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model FbPost
 * 
 */
export type FbPost = {
  id: number
  caption: string
  userId: number
  createdAt: Date
  updatedAt: Date
  wallId: number
}

/**
 * Model FbPostImage
 * 
 */
export type FbPostImage = {
  id: number
  image: string
  postId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model FbPostVideo
 * 
 */
export type FbPostVideo = {
  id: number
  video: string
  postId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model FbHashtag
 * 
 */
export type FbHashtag = {
  id: number
  hashtag: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model FbPostOnHashtag
 * 
 */
export type FbPostOnHashtag = {
  id: number
  postId: number
  hashtagId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model FbLike
 * 
 */
export type FbLike = {
  id: number
  userId: number
  postId: number
  commentId: number
  shareId: number
  likeType: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model FbShare
 * 
 */
export type FbShare = {
  id: number
  userId: number
  postId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Fbfriend
 * 
 */
export type Fbfriend = {
  id: number
  acceptId: number
  requestId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model FbMessenger
 * 
 */
export type FbMessenger = {
  id: number
  fromuserId: number
  toUserId: number
  text: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model FbComment
 * 
 */
export type FbComment = {
  id: number
  text: string
  userId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model FbGroup
 * 
 */
export type FbGroup = {
  id: number
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model GroupToUser
 * 
 */
export type GroupToUser = {
  id: number
  userId: number
  groupId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model FbWall
 * 
 */
export type FbWall = {
  id: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model FbDestinationUser
 * 
 */
export type FbDestinationUser = {
  id: number
  fbWallId: number
  shareId: number
  groupId: number
}

/**
 * Model KorKitchenCategory
 * 
 */
export type KorKitchenCategory = {
  id: number
  name: string
  createAt: Date
  updateAt: Date
}

/**
 * Model KorKitchenMenu
 * 
 */
export type KorKitchenMenu = {
  id: number
  name: string
  image: string
  price: number
  categoryName: string | null
  createAt: Date
  updateAt: Date
}

/**
 * Model KorKitchenOrder
 * 
 */
export type KorKitchenOrder = {
  id: number
  status: string
  tableId: number
  createAt: Date
  updateAt: Date
}

/**
 * Model KorKitchenOrderItem
 * 
 */
export type KorKitchenOrderItem = {
  id: number
  menuId: number
  orderId: number | null
  quantity: number
  totalPrice: number
  creatAt: Date
  updatedAt: Date
}

/**
 * Model TodoList
 * 
 */
export type TodoList = {
  id: number
  task: string
  status: string
  note: string | null
  createAt: Date
  updateAt: Date
}

/**
 * Model TestModel
 * 
 */
export type TestModel = {
  id: number
  firstname: string
  Surname: string
}

/**
 * Model TriviaCategory
 * 
 */
export type TriviaCategory = {
  id: number
  name: string
}

/**
 * Model TriviaQuestion
 * 
 */
export type TriviaQuestion = {
  id: number
  categoryId: number
  name: string
  answerID: number
}

/**
 * Model TriviaChoice
 * 
 */
export type TriviaChoice = {
  id: number
  quizId: number
  name: string
}

/**
 * Model TriviaRoundQuestion
 * 
 */
export type TriviaRoundQuestion = {
  id: number
  quizId: number
  choiceId: number
  quizResult: boolean
  roundId: number | null
}

/**
 * Model TriviaRound
 * 
 */
export type TriviaRound = {
  id: number
  user: string
  categoryId: number
  totalResult: number
  createAt: Date
}

/**
 * Model TwitterUser
 * 
 */
export type TwitterUser = {
  id: number
  name: string
  Image: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model TwitterFollow
 * 
 */
export type TwitterFollow = {
  id: number
  fromUserId: number
  toUserId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model TwitterPost
 * 
 */
export type TwitterPost = {
  id: number
  caption: string
  userId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model TwitterDirectMessage
 * 
 */
export type TwitterDirectMessage = {
  id: number
  fromUserId: number
  toUserId: number
  text: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model TwitterHashtag
 * 
 */
export type TwitterHashtag = {
  id: number
  hashtag: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model TwitterComment
 * 
 */
export type TwitterComment = {
  id: number
  text: string
  userId: number
  postId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model TwitterPostOnHashtag
 * 
 */
export type TwitterPostOnHashtag = {
  id: number
  postId: number
  hashtagId: number
}

/**
 * Model WSUser
 * 
 */
export type WSUser = {
  id: number
  name: string
  tel: number
  myWallet: number
  createdAt: Date
  updateAt: Date
}

/**
 * Model WSTopupHistory
 * 
 */
export type WSTopupHistory = {
  id: number
  userId: number
  topup: number
  createdAt: Date
  updateAt: Date
}

/**
 * Model WSUsingHistory
 * 
 */
export type WSUsingHistory = {
  id: number
  userId: number
  price: number
  createdAt: Date
  updateAt: Date
  usingStartAt: Date
  finishingAt: Date
  wSMachineId: number
  wSProgramId: number
}

/**
 * Model WSShop
 * 
 */
export type WSShop = {
  id: number
  branch: string
  owner: string
  tel: number
  location: string
  area: string
  createdAt: Date
  updateAt: Date
}

/**
 * Model WSMachine
 * 
 */
export type WSMachine = {
  id: number
  shopId: number
  brandname: string
  size: string
  type: string
  model: string
  producedDate: string
  insuranceExpiredDate: string
  createdAt: Date
  updateAt: Date
}

/**
 * Model WSProgram
 * 
 */
export type WSProgram = {
  id: number
  name: string
  createdAt: Date
  updateAt: Date
  activeProgramId: number
}

/**
 * Model MachineToProgram
 * 
 */
export type MachineToProgram = {
  id: number
  machineId: number
  programId: number
  createdAt: Date
  updateAt: Date
}

/**
 * Model WSProgramDetail
 * 
 */
export type WSProgramDetail = {
  id: number
  programId: number
  price: number
  duration: number
  weight: number
  createdAt: Date
  updateAt: Date
}

/**
 * Model WSMaintain
 * 
 */
export type WSMaintain = {
  id: number
  checker: string
  item: string
  status: string
  machineId: number
  createdAt: Date
  updateAt: Date
}

/**
 * Model YTUser
 * 
 */
export type YTUser = {
  id: number
  user: string
  email: string
  avatar: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model YTChannel
 * 
 */
export type YTChannel = {
  id: number
  channelName: string
  description: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model UserToChannel
 * 
 */
export type UserToChannel = {
  id: number
  userId: number
  channelId: number
  role: YTRoleEnum
  createdAt: Date
  updatedAt: Date
}

/**
 * Model YTVideo
 * 
 */
export type YTVideo = {
  id: number
  name: string
  file: string
  logo: string
  createdAt: Date
  updatedAt: Date
  channelId: number
}

/**
 * Model YTLike
 * 
 */
export type YTLike = {
  id: number
  type: string
  videoId: number
  commentId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model YTComment
 * 
 */
export type YTComment = {
  id: number
  text: string
  userId: number
  commentTo: number | null
  videoId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model YTSubscribe
 * 
 */
export type YTSubscribe = {
  id: number
  userId: number
  channelId: number
  member: boolean
  createdAt: Date
  updatedAt: Date
}

/**
 * Model YTShare
 * 
 */
export type YTShare = {
  id: number
  userId: number
  videoId: number
  createdAt: Date
  updatedAt: Date
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const CopyStatusEnum: {
  INSTOCK: 'INSTOCK',
  RESERVED: 'RESERVED'
};

export type CopyStatusEnum = (typeof CopyStatusEnum)[keyof typeof CopyStatusEnum]


export const RequestStatusEnum: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED'
};

export type RequestStatusEnum = (typeof RequestStatusEnum)[keyof typeof RequestStatusEnum]


export const YTRoleEnum: {
  ADMIN: 'ADMIN',
  EDITOR: 'EDITOR',
  CREATOR: 'CREATOR'
};

export type YTRoleEnum = (typeof YTRoleEnum)[keyof typeof YTRoleEnum]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more BKReserveUsers
 * const bKReserveUsers = await prisma.bKReserveUser.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more BKReserveUsers
   * const bKReserveUsers = await prisma.bKReserveUser.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.bKReserveUser`: Exposes CRUD operations for the **BKReserveUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BKReserveUsers
    * const bKReserveUsers = await prisma.bKReserveUser.findMany()
    * ```
    */
  get bKReserveUser(): Prisma.BKReserveUserDelegate<GlobalReject>;

  /**
   * `prisma.bKRequest`: Exposes CRUD operations for the **BKRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BKRequests
    * const bKRequests = await prisma.bKRequest.findMany()
    * ```
    */
  get bKRequest(): Prisma.BKRequestDelegate<GlobalReject>;

  /**
   * `prisma.bKBorrowingHistory`: Exposes CRUD operations for the **BKBorrowingHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BKBorrowingHistories
    * const bKBorrowingHistories = await prisma.bKBorrowingHistory.findMany()
    * ```
    */
  get bKBorrowingHistory(): Prisma.BKBorrowingHistoryDelegate<GlobalReject>;

  /**
   * `prisma.bKCopy`: Exposes CRUD operations for the **BKCopy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BKCopies
    * const bKCopies = await prisma.bKCopy.findMany()
    * ```
    */
  get bKCopy(): Prisma.BKCopyDelegate<GlobalReject>;

  /**
   * `prisma.bKUniversity`: Exposes CRUD operations for the **BKUniversity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BKUniversities
    * const bKUniversities = await prisma.bKUniversity.findMany()
    * ```
    */
  get bKUniversity(): Prisma.BKUniversityDelegate<GlobalReject>;

  /**
   * `prisma.bKTitle`: Exposes CRUD operations for the **BKTitle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BKTitles
    * const bKTitles = await prisma.bKTitle.findMany()
    * ```
    */
  get bKTitle(): Prisma.BKTitleDelegate<GlobalReject>;

  /**
   * `prisma.universityToTitle`: Exposes CRUD operations for the **UniversityToTitle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UniversityToTitles
    * const universityToTitles = await prisma.universityToTitle.findMany()
    * ```
    */
  get universityToTitle(): Prisma.UniversityToTitleDelegate<GlobalReject>;

  /**
   * `prisma.bKCategory`: Exposes CRUD operations for the **BKCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BKCategories
    * const bKCategories = await prisma.bKCategory.findMany()
    * ```
    */
  get bKCategory(): Prisma.BKCategoryDelegate<GlobalReject>;

  /**
   * `prisma.titleToCategory`: Exposes CRUD operations for the **TitleToCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TitleToCategories
    * const titleToCategories = await prisma.titleToCategory.findMany()
    * ```
    */
  get titleToCategory(): Prisma.TitleToCategoryDelegate<GlobalReject>;

  /**
   * `prisma.bKAuthor`: Exposes CRUD operations for the **BKAuthor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BKAuthors
    * const bKAuthors = await prisma.bKAuthor.findMany()
    * ```
    */
  get bKAuthor(): Prisma.BKAuthorDelegate<GlobalReject>;

  /**
   * `prisma.titleToAuthor`: Exposes CRUD operations for the **TitleToAuthor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TitleToAuthors
    * const titleToAuthors = await prisma.titleToAuthor.findMany()
    * ```
    */
  get titleToAuthor(): Prisma.TitleToAuthorDelegate<GlobalReject>;

  /**
   * `prisma.fbUser`: Exposes CRUD operations for the **FbUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FbUsers
    * const fbUsers = await prisma.fbUser.findMany()
    * ```
    */
  get fbUser(): Prisma.FbUserDelegate<GlobalReject>;

  /**
   * `prisma.fbPost`: Exposes CRUD operations for the **FbPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FbPosts
    * const fbPosts = await prisma.fbPost.findMany()
    * ```
    */
  get fbPost(): Prisma.FbPostDelegate<GlobalReject>;

  /**
   * `prisma.fbPostImage`: Exposes CRUD operations for the **FbPostImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FbPostImages
    * const fbPostImages = await prisma.fbPostImage.findMany()
    * ```
    */
  get fbPostImage(): Prisma.FbPostImageDelegate<GlobalReject>;

  /**
   * `prisma.fbPostVideo`: Exposes CRUD operations for the **FbPostVideo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FbPostVideos
    * const fbPostVideos = await prisma.fbPostVideo.findMany()
    * ```
    */
  get fbPostVideo(): Prisma.FbPostVideoDelegate<GlobalReject>;

  /**
   * `prisma.fbHashtag`: Exposes CRUD operations for the **FbHashtag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FbHashtags
    * const fbHashtags = await prisma.fbHashtag.findMany()
    * ```
    */
  get fbHashtag(): Prisma.FbHashtagDelegate<GlobalReject>;

  /**
   * `prisma.fbPostOnHashtag`: Exposes CRUD operations for the **FbPostOnHashtag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FbPostOnHashtags
    * const fbPostOnHashtags = await prisma.fbPostOnHashtag.findMany()
    * ```
    */
  get fbPostOnHashtag(): Prisma.FbPostOnHashtagDelegate<GlobalReject>;

  /**
   * `prisma.fbLike`: Exposes CRUD operations for the **FbLike** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FbLikes
    * const fbLikes = await prisma.fbLike.findMany()
    * ```
    */
  get fbLike(): Prisma.FbLikeDelegate<GlobalReject>;

  /**
   * `prisma.fbShare`: Exposes CRUD operations for the **FbShare** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FbShares
    * const fbShares = await prisma.fbShare.findMany()
    * ```
    */
  get fbShare(): Prisma.FbShareDelegate<GlobalReject>;

  /**
   * `prisma.fbfriend`: Exposes CRUD operations for the **Fbfriend** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fbfriends
    * const fbfriends = await prisma.fbfriend.findMany()
    * ```
    */
  get fbfriend(): Prisma.FbfriendDelegate<GlobalReject>;

  /**
   * `prisma.fbMessenger`: Exposes CRUD operations for the **FbMessenger** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FbMessengers
    * const fbMessengers = await prisma.fbMessenger.findMany()
    * ```
    */
  get fbMessenger(): Prisma.FbMessengerDelegate<GlobalReject>;

  /**
   * `prisma.fbComment`: Exposes CRUD operations for the **FbComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FbComments
    * const fbComments = await prisma.fbComment.findMany()
    * ```
    */
  get fbComment(): Prisma.FbCommentDelegate<GlobalReject>;

  /**
   * `prisma.fbGroup`: Exposes CRUD operations for the **FbGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FbGroups
    * const fbGroups = await prisma.fbGroup.findMany()
    * ```
    */
  get fbGroup(): Prisma.FbGroupDelegate<GlobalReject>;

  /**
   * `prisma.groupToUser`: Exposes CRUD operations for the **GroupToUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GroupToUsers
    * const groupToUsers = await prisma.groupToUser.findMany()
    * ```
    */
  get groupToUser(): Prisma.GroupToUserDelegate<GlobalReject>;

  /**
   * `prisma.fbWall`: Exposes CRUD operations for the **FbWall** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FbWalls
    * const fbWalls = await prisma.fbWall.findMany()
    * ```
    */
  get fbWall(): Prisma.FbWallDelegate<GlobalReject>;

  /**
   * `prisma.fbDestinationUser`: Exposes CRUD operations for the **FbDestinationUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FbDestinationUsers
    * const fbDestinationUsers = await prisma.fbDestinationUser.findMany()
    * ```
    */
  get fbDestinationUser(): Prisma.FbDestinationUserDelegate<GlobalReject>;

  /**
   * `prisma.korKitchenCategory`: Exposes CRUD operations for the **KorKitchenCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KorKitchenCategories
    * const korKitchenCategories = await prisma.korKitchenCategory.findMany()
    * ```
    */
  get korKitchenCategory(): Prisma.KorKitchenCategoryDelegate<GlobalReject>;

  /**
   * `prisma.korKitchenMenu`: Exposes CRUD operations for the **KorKitchenMenu** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KorKitchenMenus
    * const korKitchenMenus = await prisma.korKitchenMenu.findMany()
    * ```
    */
  get korKitchenMenu(): Prisma.KorKitchenMenuDelegate<GlobalReject>;

  /**
   * `prisma.korKitchenOrder`: Exposes CRUD operations for the **KorKitchenOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KorKitchenOrders
    * const korKitchenOrders = await prisma.korKitchenOrder.findMany()
    * ```
    */
  get korKitchenOrder(): Prisma.KorKitchenOrderDelegate<GlobalReject>;

  /**
   * `prisma.korKitchenOrderItem`: Exposes CRUD operations for the **KorKitchenOrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KorKitchenOrderItems
    * const korKitchenOrderItems = await prisma.korKitchenOrderItem.findMany()
    * ```
    */
  get korKitchenOrderItem(): Prisma.KorKitchenOrderItemDelegate<GlobalReject>;

  /**
   * `prisma.todoList`: Exposes CRUD operations for the **TodoList** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TodoLists
    * const todoLists = await prisma.todoList.findMany()
    * ```
    */
  get todoList(): Prisma.TodoListDelegate<GlobalReject>;

  /**
   * `prisma.testModel`: Exposes CRUD operations for the **TestModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TestModels
    * const testModels = await prisma.testModel.findMany()
    * ```
    */
  get testModel(): Prisma.TestModelDelegate<GlobalReject>;

  /**
   * `prisma.triviaCategory`: Exposes CRUD operations for the **TriviaCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TriviaCategories
    * const triviaCategories = await prisma.triviaCategory.findMany()
    * ```
    */
  get triviaCategory(): Prisma.TriviaCategoryDelegate<GlobalReject>;

  /**
   * `prisma.triviaQuestion`: Exposes CRUD operations for the **TriviaQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TriviaQuestions
    * const triviaQuestions = await prisma.triviaQuestion.findMany()
    * ```
    */
  get triviaQuestion(): Prisma.TriviaQuestionDelegate<GlobalReject>;

  /**
   * `prisma.triviaChoice`: Exposes CRUD operations for the **TriviaChoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TriviaChoices
    * const triviaChoices = await prisma.triviaChoice.findMany()
    * ```
    */
  get triviaChoice(): Prisma.TriviaChoiceDelegate<GlobalReject>;

  /**
   * `prisma.triviaRoundQuestion`: Exposes CRUD operations for the **TriviaRoundQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TriviaRoundQuestions
    * const triviaRoundQuestions = await prisma.triviaRoundQuestion.findMany()
    * ```
    */
  get triviaRoundQuestion(): Prisma.TriviaRoundQuestionDelegate<GlobalReject>;

  /**
   * `prisma.triviaRound`: Exposes CRUD operations for the **TriviaRound** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TriviaRounds
    * const triviaRounds = await prisma.triviaRound.findMany()
    * ```
    */
  get triviaRound(): Prisma.TriviaRoundDelegate<GlobalReject>;

  /**
   * `prisma.twitterUser`: Exposes CRUD operations for the **TwitterUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TwitterUsers
    * const twitterUsers = await prisma.twitterUser.findMany()
    * ```
    */
  get twitterUser(): Prisma.TwitterUserDelegate<GlobalReject>;

  /**
   * `prisma.twitterFollow`: Exposes CRUD operations for the **TwitterFollow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TwitterFollows
    * const twitterFollows = await prisma.twitterFollow.findMany()
    * ```
    */
  get twitterFollow(): Prisma.TwitterFollowDelegate<GlobalReject>;

  /**
   * `prisma.twitterPost`: Exposes CRUD operations for the **TwitterPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TwitterPosts
    * const twitterPosts = await prisma.twitterPost.findMany()
    * ```
    */
  get twitterPost(): Prisma.TwitterPostDelegate<GlobalReject>;

  /**
   * `prisma.twitterDirectMessage`: Exposes CRUD operations for the **TwitterDirectMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TwitterDirectMessages
    * const twitterDirectMessages = await prisma.twitterDirectMessage.findMany()
    * ```
    */
  get twitterDirectMessage(): Prisma.TwitterDirectMessageDelegate<GlobalReject>;

  /**
   * `prisma.twitterHashtag`: Exposes CRUD operations for the **TwitterHashtag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TwitterHashtags
    * const twitterHashtags = await prisma.twitterHashtag.findMany()
    * ```
    */
  get twitterHashtag(): Prisma.TwitterHashtagDelegate<GlobalReject>;

  /**
   * `prisma.twitterComment`: Exposes CRUD operations for the **TwitterComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TwitterComments
    * const twitterComments = await prisma.twitterComment.findMany()
    * ```
    */
  get twitterComment(): Prisma.TwitterCommentDelegate<GlobalReject>;

  /**
   * `prisma.twitterPostOnHashtag`: Exposes CRUD operations for the **TwitterPostOnHashtag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TwitterPostOnHashtags
    * const twitterPostOnHashtags = await prisma.twitterPostOnHashtag.findMany()
    * ```
    */
  get twitterPostOnHashtag(): Prisma.TwitterPostOnHashtagDelegate<GlobalReject>;

  /**
   * `prisma.wSUser`: Exposes CRUD operations for the **WSUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WSUsers
    * const wSUsers = await prisma.wSUser.findMany()
    * ```
    */
  get wSUser(): Prisma.WSUserDelegate<GlobalReject>;

  /**
   * `prisma.wSTopupHistory`: Exposes CRUD operations for the **WSTopupHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WSTopupHistories
    * const wSTopupHistories = await prisma.wSTopupHistory.findMany()
    * ```
    */
  get wSTopupHistory(): Prisma.WSTopupHistoryDelegate<GlobalReject>;

  /**
   * `prisma.wSUsingHistory`: Exposes CRUD operations for the **WSUsingHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WSUsingHistories
    * const wSUsingHistories = await prisma.wSUsingHistory.findMany()
    * ```
    */
  get wSUsingHistory(): Prisma.WSUsingHistoryDelegate<GlobalReject>;

  /**
   * `prisma.wSShop`: Exposes CRUD operations for the **WSShop** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WSShops
    * const wSShops = await prisma.wSShop.findMany()
    * ```
    */
  get wSShop(): Prisma.WSShopDelegate<GlobalReject>;

  /**
   * `prisma.wSMachine`: Exposes CRUD operations for the **WSMachine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WSMachines
    * const wSMachines = await prisma.wSMachine.findMany()
    * ```
    */
  get wSMachine(): Prisma.WSMachineDelegate<GlobalReject>;

  /**
   * `prisma.wSProgram`: Exposes CRUD operations for the **WSProgram** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WSPrograms
    * const wSPrograms = await prisma.wSProgram.findMany()
    * ```
    */
  get wSProgram(): Prisma.WSProgramDelegate<GlobalReject>;

  /**
   * `prisma.machineToProgram`: Exposes CRUD operations for the **MachineToProgram** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MachineToPrograms
    * const machineToPrograms = await prisma.machineToProgram.findMany()
    * ```
    */
  get machineToProgram(): Prisma.MachineToProgramDelegate<GlobalReject>;

  /**
   * `prisma.wSProgramDetail`: Exposes CRUD operations for the **WSProgramDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WSProgramDetails
    * const wSProgramDetails = await prisma.wSProgramDetail.findMany()
    * ```
    */
  get wSProgramDetail(): Prisma.WSProgramDetailDelegate<GlobalReject>;

  /**
   * `prisma.wSMaintain`: Exposes CRUD operations for the **WSMaintain** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WSMaintains
    * const wSMaintains = await prisma.wSMaintain.findMany()
    * ```
    */
  get wSMaintain(): Prisma.WSMaintainDelegate<GlobalReject>;

  /**
   * `prisma.yTUser`: Exposes CRUD operations for the **YTUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YTUsers
    * const yTUsers = await prisma.yTUser.findMany()
    * ```
    */
  get yTUser(): Prisma.YTUserDelegate<GlobalReject>;

  /**
   * `prisma.yTChannel`: Exposes CRUD operations for the **YTChannel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YTChannels
    * const yTChannels = await prisma.yTChannel.findMany()
    * ```
    */
  get yTChannel(): Prisma.YTChannelDelegate<GlobalReject>;

  /**
   * `prisma.userToChannel`: Exposes CRUD operations for the **UserToChannel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserToChannels
    * const userToChannels = await prisma.userToChannel.findMany()
    * ```
    */
  get userToChannel(): Prisma.UserToChannelDelegate<GlobalReject>;

  /**
   * `prisma.yTVideo`: Exposes CRUD operations for the **YTVideo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YTVideos
    * const yTVideos = await prisma.yTVideo.findMany()
    * ```
    */
  get yTVideo(): Prisma.YTVideoDelegate<GlobalReject>;

  /**
   * `prisma.yTLike`: Exposes CRUD operations for the **YTLike** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YTLikes
    * const yTLikes = await prisma.yTLike.findMany()
    * ```
    */
  get yTLike(): Prisma.YTLikeDelegate<GlobalReject>;

  /**
   * `prisma.yTComment`: Exposes CRUD operations for the **YTComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YTComments
    * const yTComments = await prisma.yTComment.findMany()
    * ```
    */
  get yTComment(): Prisma.YTCommentDelegate<GlobalReject>;

  /**
   * `prisma.yTSubscribe`: Exposes CRUD operations for the **YTSubscribe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YTSubscribes
    * const yTSubscribes = await prisma.yTSubscribe.findMany()
    * ```
    */
  get yTSubscribe(): Prisma.YTSubscribeDelegate<GlobalReject>;

  /**
   * `prisma.yTShare`: Exposes CRUD operations for the **YTShare** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YTShares
    * const yTShares = await prisma.yTShare.findMany()
    * ```
    */
  get yTShare(): Prisma.YTShareDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.10.1
   * Query Engine version: aead147aa326ccb985dcfed5b065b4fdabd44b19
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    BKReserveUser: 'BKReserveUser',
    BKRequest: 'BKRequest',
    BKBorrowingHistory: 'BKBorrowingHistory',
    BKCopy: 'BKCopy',
    BKUniversity: 'BKUniversity',
    BKTitle: 'BKTitle',
    UniversityToTitle: 'UniversityToTitle',
    BKCategory: 'BKCategory',
    TitleToCategory: 'TitleToCategory',
    BKAuthor: 'BKAuthor',
    TitleToAuthor: 'TitleToAuthor',
    FbUser: 'FbUser',
    FbPost: 'FbPost',
    FbPostImage: 'FbPostImage',
    FbPostVideo: 'FbPostVideo',
    FbHashtag: 'FbHashtag',
    FbPostOnHashtag: 'FbPostOnHashtag',
    FbLike: 'FbLike',
    FbShare: 'FbShare',
    Fbfriend: 'Fbfriend',
    FbMessenger: 'FbMessenger',
    FbComment: 'FbComment',
    FbGroup: 'FbGroup',
    GroupToUser: 'GroupToUser',
    FbWall: 'FbWall',
    FbDestinationUser: 'FbDestinationUser',
    KorKitchenCategory: 'KorKitchenCategory',
    KorKitchenMenu: 'KorKitchenMenu',
    KorKitchenOrder: 'KorKitchenOrder',
    KorKitchenOrderItem: 'KorKitchenOrderItem',
    TodoList: 'TodoList',
    TestModel: 'TestModel',
    TriviaCategory: 'TriviaCategory',
    TriviaQuestion: 'TriviaQuestion',
    TriviaChoice: 'TriviaChoice',
    TriviaRoundQuestion: 'TriviaRoundQuestion',
    TriviaRound: 'TriviaRound',
    TwitterUser: 'TwitterUser',
    TwitterFollow: 'TwitterFollow',
    TwitterPost: 'TwitterPost',
    TwitterDirectMessage: 'TwitterDirectMessage',
    TwitterHashtag: 'TwitterHashtag',
    TwitterComment: 'TwitterComment',
    TwitterPostOnHashtag: 'TwitterPostOnHashtag',
    WSUser: 'WSUser',
    WSTopupHistory: 'WSTopupHistory',
    WSUsingHistory: 'WSUsingHistory',
    WSShop: 'WSShop',
    WSMachine: 'WSMachine',
    WSProgram: 'WSProgram',
    MachineToProgram: 'MachineToProgram',
    WSProgramDetail: 'WSProgramDetail',
    WSMaintain: 'WSMaintain',
    YTUser: 'YTUser',
    YTChannel: 'YTChannel',
    UserToChannel: 'UserToChannel',
    YTVideo: 'YTVideo',
    YTLike: 'YTLike',
    YTComment: 'YTComment',
    YTSubscribe: 'YTSubscribe',
    YTShare: 'YTShare'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BKReserveUserCountOutputType
   */


  export type BKReserveUserCountOutputType = {
    requests: number
    BKBorrowingHistory: number
    BKCopy: number
  }

  export type BKReserveUserCountOutputTypeSelect = {
    requests?: boolean
    BKBorrowingHistory?: boolean
    BKCopy?: boolean
  }

  export type BKReserveUserCountOutputTypeGetPayload<S extends boolean | null | undefined | BKReserveUserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BKReserveUserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (BKReserveUserCountOutputTypeArgs)
    ? BKReserveUserCountOutputType 
    : S extends { select: any } & (BKReserveUserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof BKReserveUserCountOutputType ? BKReserveUserCountOutputType[P] : never
  } 
      : BKReserveUserCountOutputType




  // Custom InputTypes

  /**
   * BKReserveUserCountOutputType without action
   */
  export type BKReserveUserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BKReserveUserCountOutputType
     */
    select?: BKReserveUserCountOutputTypeSelect | null
  }



  /**
   * Count Type BKCopyCountOutputType
   */


  export type BKCopyCountOutputType = {
    requests: number
    BKBorrowingHistory: number
  }

  export type BKCopyCountOutputTypeSelect = {
    requests?: boolean
    BKBorrowingHistory?: boolean
  }

  export type BKCopyCountOutputTypeGetPayload<S extends boolean | null | undefined | BKCopyCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BKCopyCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (BKCopyCountOutputTypeArgs)
    ? BKCopyCountOutputType 
    : S extends { select: any } & (BKCopyCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof BKCopyCountOutputType ? BKCopyCountOutputType[P] : never
  } 
      : BKCopyCountOutputType




  // Custom InputTypes

  /**
   * BKCopyCountOutputType without action
   */
  export type BKCopyCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BKCopyCountOutputType
     */
    select?: BKCopyCountOutputTypeSelect | null
  }



  /**
   * Count Type BKUniversityCountOutputType
   */


  export type BKUniversityCountOutputType = {
    universityToTitles: number
    reserveUsers: number
    fromRequest: number
    toRequest: number
    BKBorrowingHistory: number
  }

  export type BKUniversityCountOutputTypeSelect = {
    universityToTitles?: boolean
    reserveUsers?: boolean
    fromRequest?: boolean
    toRequest?: boolean
    BKBorrowingHistory?: boolean
  }

  export type BKUniversityCountOutputTypeGetPayload<S extends boolean | null | undefined | BKUniversityCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BKUniversityCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (BKUniversityCountOutputTypeArgs)
    ? BKUniversityCountOutputType 
    : S extends { select: any } & (BKUniversityCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof BKUniversityCountOutputType ? BKUniversityCountOutputType[P] : never
  } 
      : BKUniversityCountOutputType




  // Custom InputTypes

  /**
   * BKUniversityCountOutputType without action
   */
  export type BKUniversityCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BKUniversityCountOutputType
     */
    select?: BKUniversityCountOutputTypeSelect | null
  }



  /**
   * Count Type BKTitleCountOutputType
   */


  export type BKTitleCountOutputType = {
    titleToCategories: number
    titleToAuthors: number
    universityToTitles: number
    copies: number
  }

  export type BKTitleCountOutputTypeSelect = {
    titleToCategories?: boolean
    titleToAuthors?: boolean
    universityToTitles?: boolean
    copies?: boolean
  }

  export type BKTitleCountOutputTypeGetPayload<S extends boolean | null | undefined | BKTitleCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BKTitleCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (BKTitleCountOutputTypeArgs)
    ? BKTitleCountOutputType 
    : S extends { select: any } & (BKTitleCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof BKTitleCountOutputType ? BKTitleCountOutputType[P] : never
  } 
      : BKTitleCountOutputType




  // Custom InputTypes

  /**
   * BKTitleCountOutputType without action
   */
  export type BKTitleCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BKTitleCountOutputType
     */
    select?: BKTitleCountOutputTypeSelect | null
  }



  /**
   * Count Type BKCategoryCountOutputType
   */


  export type BKCategoryCountOutputType = {
    titleToCategories: number
  }

  export type BKCategoryCountOutputTypeSelect = {
    titleToCategories?: boolean
  }

  export type BKCategoryCountOutputTypeGetPayload<S extends boolean | null | undefined | BKCategoryCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BKCategoryCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (BKCategoryCountOutputTypeArgs)
    ? BKCategoryCountOutputType 
    : S extends { select: any } & (BKCategoryCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof BKCategoryCountOutputType ? BKCategoryCountOutputType[P] : never
  } 
      : BKCategoryCountOutputType




  // Custom InputTypes

  /**
   * BKCategoryCountOutputType without action
   */
  export type BKCategoryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BKCategoryCountOutputType
     */
    select?: BKCategoryCountOutputTypeSelect | null
  }



  /**
   * Count Type BKAuthorCountOutputType
   */


  export type BKAuthorCountOutputType = {
    titleToAuthors: number
  }

  export type BKAuthorCountOutputTypeSelect = {
    titleToAuthors?: boolean
  }

  export type BKAuthorCountOutputTypeGetPayload<S extends boolean | null | undefined | BKAuthorCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BKAuthorCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (BKAuthorCountOutputTypeArgs)
    ? BKAuthorCountOutputType 
    : S extends { select: any } & (BKAuthorCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof BKAuthorCountOutputType ? BKAuthorCountOutputType[P] : never
  } 
      : BKAuthorCountOutputType




  // Custom InputTypes

  /**
   * BKAuthorCountOutputType without action
   */
  export type BKAuthorCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BKAuthorCountOutputType
     */
    select?: BKAuthorCountOutputTypeSelect | null
  }



  /**
   * Count Type FbUserCountOutputType
   */


  export type FbUserCountOutputType = {
    posts: number
    acceptFbFriends: number
    requestFbFriends: number
    likes: number
    fromMessengers: number
    toMessengers: number
    shares: number
    comments: number
    groupToUsers: number
  }

  export type FbUserCountOutputTypeSelect = {
    posts?: boolean
    acceptFbFriends?: boolean
    requestFbFriends?: boolean
    likes?: boolean
    fromMessengers?: boolean
    toMessengers?: boolean
    shares?: boolean
    comments?: boolean
    groupToUsers?: boolean
  }

  export type FbUserCountOutputTypeGetPayload<S extends boolean | null | undefined | FbUserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FbUserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (FbUserCountOutputTypeArgs)
    ? FbUserCountOutputType 
    : S extends { select: any } & (FbUserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof FbUserCountOutputType ? FbUserCountOutputType[P] : never
  } 
      : FbUserCountOutputType




  // Custom InputTypes

  /**
   * FbUserCountOutputType without action
   */
  export type FbUserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the FbUserCountOutputType
     */
    select?: FbUserCountOutputTypeSelect | null
  }



  /**
   * Count Type FbPostCountOutputType
   */


  export type FbPostCountOutputType = {
    postImages: number
    postVideoes: number
    postOnHashtags: number
    shares: number
    likes: number
  }

  export type FbPostCountOutputTypeSelect = {
    postImages?: boolean
    postVideoes?: boolean
    postOnHashtags?: boolean
    shares?: boolean
    likes?: boolean
  }

  export type FbPostCountOutputTypeGetPayload<S extends boolean | null | undefined | FbPostCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FbPostCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (FbPostCountOutputTypeArgs)
    ? FbPostCountOutputType 
    : S extends { select: any } & (FbPostCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof FbPostCountOutputType ? FbPostCountOutputType[P] : never
  } 
      : FbPostCountOutputType




  // Custom InputTypes

  /**
   * FbPostCountOutputType without action
   */
  export type FbPostCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the FbPostCountOutputType
     */
    select?: FbPostCountOutputTypeSelect | null
  }



  /**
   * Count Type FbHashtagCountOutputType
   */


  export type FbHashtagCountOutputType = {
    postOnHashtags: number
  }

  export type FbHashtagCountOutputTypeSelect = {
    postOnHashtags?: boolean
  }

  export type FbHashtagCountOutputTypeGetPayload<S extends boolean | null | undefined | FbHashtagCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FbHashtagCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (FbHashtagCountOutputTypeArgs)
    ? FbHashtagCountOutputType 
    : S extends { select: any } & (FbHashtagCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof FbHashtagCountOutputType ? FbHashtagCountOutputType[P] : never
  } 
      : FbHashtagCountOutputType




  // Custom InputTypes

  /**
   * FbHashtagCountOutputType without action
   */
  export type FbHashtagCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the FbHashtagCountOutputType
     */
    select?: FbHashtagCountOutputTypeSelect | null
  }



  /**
   * Count Type FbShareCountOutputType
   */


  export type FbShareCountOutputType = {
    likes: number
    destinationUsers: number
  }

  export type FbShareCountOutputTypeSelect = {
    likes?: boolean
    destinationUsers?: boolean
  }

  export type FbShareCountOutputTypeGetPayload<S extends boolean | null | undefined | FbShareCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FbShareCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (FbShareCountOutputTypeArgs)
    ? FbShareCountOutputType 
    : S extends { select: any } & (FbShareCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof FbShareCountOutputType ? FbShareCountOutputType[P] : never
  } 
      : FbShareCountOutputType




  // Custom InputTypes

  /**
   * FbShareCountOutputType without action
   */
  export type FbShareCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the FbShareCountOutputType
     */
    select?: FbShareCountOutputTypeSelect | null
  }



  /**
   * Count Type FbCommentCountOutputType
   */


  export type FbCommentCountOutputType = {
    likes: number
  }

  export type FbCommentCountOutputTypeSelect = {
    likes?: boolean
  }

  export type FbCommentCountOutputTypeGetPayload<S extends boolean | null | undefined | FbCommentCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FbCommentCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (FbCommentCountOutputTypeArgs)
    ? FbCommentCountOutputType 
    : S extends { select: any } & (FbCommentCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof FbCommentCountOutputType ? FbCommentCountOutputType[P] : never
  } 
      : FbCommentCountOutputType




  // Custom InputTypes

  /**
   * FbCommentCountOutputType without action
   */
  export type FbCommentCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the FbCommentCountOutputType
     */
    select?: FbCommentCountOutputTypeSelect | null
  }



  /**
   * Count Type FbGroupCountOutputType
   */


  export type FbGroupCountOutputType = {
    groupToUsers: number
    destinationUsers: number
  }

  export type FbGroupCountOutputTypeSelect = {
    groupToUsers?: boolean
    destinationUsers?: boolean
  }

  export type FbGroupCountOutputTypeGetPayload<S extends boolean | null | undefined | FbGroupCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FbGroupCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (FbGroupCountOutputTypeArgs)
    ? FbGroupCountOutputType 
    : S extends { select: any } & (FbGroupCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof FbGroupCountOutputType ? FbGroupCountOutputType[P] : never
  } 
      : FbGroupCountOutputType




  // Custom InputTypes

  /**
   * FbGroupCountOutputType without action
   */
  export type FbGroupCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the FbGroupCountOutputType
     */
    select?: FbGroupCountOutputTypeSelect | null
  }



  /**
   * Count Type FbWallCountOutputType
   */


  export type FbWallCountOutputType = {
    posts: number
    destinationUsers: number
  }

  export type FbWallCountOutputTypeSelect = {
    posts?: boolean
    destinationUsers?: boolean
  }

  export type FbWallCountOutputTypeGetPayload<S extends boolean | null | undefined | FbWallCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FbWallCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (FbWallCountOutputTypeArgs)
    ? FbWallCountOutputType 
    : S extends { select: any } & (FbWallCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof FbWallCountOutputType ? FbWallCountOutputType[P] : never
  } 
      : FbWallCountOutputType




  // Custom InputTypes

  /**
   * FbWallCountOutputType without action
   */
  export type FbWallCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the FbWallCountOutputType
     */
    select?: FbWallCountOutputTypeSelect | null
  }



  /**
   * Count Type KorKitchenCategoryCountOutputType
   */


  export type KorKitchenCategoryCountOutputType = {
    menu: number
  }

  export type KorKitchenCategoryCountOutputTypeSelect = {
    menu?: boolean
  }

  export type KorKitchenCategoryCountOutputTypeGetPayload<S extends boolean | null | undefined | KorKitchenCategoryCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? KorKitchenCategoryCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (KorKitchenCategoryCountOutputTypeArgs)
    ? KorKitchenCategoryCountOutputType 
    : S extends { select: any } & (KorKitchenCategoryCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof KorKitchenCategoryCountOutputType ? KorKitchenCategoryCountOutputType[P] : never
  } 
      : KorKitchenCategoryCountOutputType




  // Custom InputTypes

  /**
   * KorKitchenCategoryCountOutputType without action
   */
  export type KorKitchenCategoryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the KorKitchenCategoryCountOutputType
     */
    select?: KorKitchenCategoryCountOutputTypeSelect | null
  }



  /**
   * Count Type KorKitchenMenuCountOutputType
   */


  export type KorKitchenMenuCountOutputType = {
    orderItems: number
  }

  export type KorKitchenMenuCountOutputTypeSelect = {
    orderItems?: boolean
  }

  export type KorKitchenMenuCountOutputTypeGetPayload<S extends boolean | null | undefined | KorKitchenMenuCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? KorKitchenMenuCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (KorKitchenMenuCountOutputTypeArgs)
    ? KorKitchenMenuCountOutputType 
    : S extends { select: any } & (KorKitchenMenuCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof KorKitchenMenuCountOutputType ? KorKitchenMenuCountOutputType[P] : never
  } 
      : KorKitchenMenuCountOutputType




  // Custom InputTypes

  /**
   * KorKitchenMenuCountOutputType without action
   */
  export type KorKitchenMenuCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the KorKitchenMenuCountOutputType
     */
    select?: KorKitchenMenuCountOutputTypeSelect | null
  }



  /**
   * Count Type KorKitchenOrderCountOutputType
   */


  export type KorKitchenOrderCountOutputType = {
    items: number
  }

  export type KorKitchenOrderCountOutputTypeSelect = {
    items?: boolean
  }

  export type KorKitchenOrderCountOutputTypeGetPayload<S extends boolean | null | undefined | KorKitchenOrderCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? KorKitchenOrderCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (KorKitchenOrderCountOutputTypeArgs)
    ? KorKitchenOrderCountOutputType 
    : S extends { select: any } & (KorKitchenOrderCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof KorKitchenOrderCountOutputType ? KorKitchenOrderCountOutputType[P] : never
  } 
      : KorKitchenOrderCountOutputType




  // Custom InputTypes

  /**
   * KorKitchenOrderCountOutputType without action
   */
  export type KorKitchenOrderCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the KorKitchenOrderCountOutputType
     */
    select?: KorKitchenOrderCountOutputTypeSelect | null
  }



  /**
   * Count Type TriviaCategoryCountOutputType
   */


  export type TriviaCategoryCountOutputType = {
    questions: number
    rounds: number
  }

  export type TriviaCategoryCountOutputTypeSelect = {
    questions?: boolean
    rounds?: boolean
  }

  export type TriviaCategoryCountOutputTypeGetPayload<S extends boolean | null | undefined | TriviaCategoryCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TriviaCategoryCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TriviaCategoryCountOutputTypeArgs)
    ? TriviaCategoryCountOutputType 
    : S extends { select: any } & (TriviaCategoryCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TriviaCategoryCountOutputType ? TriviaCategoryCountOutputType[P] : never
  } 
      : TriviaCategoryCountOutputType




  // Custom InputTypes

  /**
   * TriviaCategoryCountOutputType without action
   */
  export type TriviaCategoryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TriviaCategoryCountOutputType
     */
    select?: TriviaCategoryCountOutputTypeSelect | null
  }



  /**
   * Count Type TriviaQuestionCountOutputType
   */


  export type TriviaQuestionCountOutputType = {
    choices: number
    roundQuestions: number
  }

  export type TriviaQuestionCountOutputTypeSelect = {
    choices?: boolean
    roundQuestions?: boolean
  }

  export type TriviaQuestionCountOutputTypeGetPayload<S extends boolean | null | undefined | TriviaQuestionCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TriviaQuestionCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TriviaQuestionCountOutputTypeArgs)
    ? TriviaQuestionCountOutputType 
    : S extends { select: any } & (TriviaQuestionCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TriviaQuestionCountOutputType ? TriviaQuestionCountOutputType[P] : never
  } 
      : TriviaQuestionCountOutputType




  // Custom InputTypes

  /**
   * TriviaQuestionCountOutputType without action
   */
  export type TriviaQuestionCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TriviaQuestionCountOutputType
     */
    select?: TriviaQuestionCountOutputTypeSelect | null
  }



  /**
   * Count Type TriviaChoiceCountOutputType
   */


  export type TriviaChoiceCountOutputType = {
    roundQuestions: number
  }

  export type TriviaChoiceCountOutputTypeSelect = {
    roundQuestions?: boolean
  }

  export type TriviaChoiceCountOutputTypeGetPayload<S extends boolean | null | undefined | TriviaChoiceCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TriviaChoiceCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TriviaChoiceCountOutputTypeArgs)
    ? TriviaChoiceCountOutputType 
    : S extends { select: any } & (TriviaChoiceCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TriviaChoiceCountOutputType ? TriviaChoiceCountOutputType[P] : never
  } 
      : TriviaChoiceCountOutputType




  // Custom InputTypes

  /**
   * TriviaChoiceCountOutputType without action
   */
  export type TriviaChoiceCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TriviaChoiceCountOutputType
     */
    select?: TriviaChoiceCountOutputTypeSelect | null
  }



  /**
   * Count Type TriviaRoundCountOutputType
   */


  export type TriviaRoundCountOutputType = {
    questions: number
  }

  export type TriviaRoundCountOutputTypeSelect = {
    questions?: boolean
  }

  export type TriviaRoundCountOutputTypeGetPayload<S extends boolean | null | undefined | TriviaRoundCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TriviaRoundCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TriviaRoundCountOutputTypeArgs)
    ? TriviaRoundCountOutputType 
    : S extends { select: any } & (TriviaRoundCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TriviaRoundCountOutputType ? TriviaRoundCountOutputType[P] : never
  } 
      : TriviaRoundCountOutputType




  // Custom InputTypes

  /**
   * TriviaRoundCountOutputType without action
   */
  export type TriviaRoundCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TriviaRoundCountOutputType
     */
    select?: TriviaRoundCountOutputTypeSelect | null
  }



  /**
   * Count Type TwitterUserCountOutputType
   */


  export type TwitterUserCountOutputType = {
    fromFollowing: number
    toFollowing: number
    posts: number
    fromDirectMessage: number
    toDirectMessage: number
    comments: number
  }

  export type TwitterUserCountOutputTypeSelect = {
    fromFollowing?: boolean
    toFollowing?: boolean
    posts?: boolean
    fromDirectMessage?: boolean
    toDirectMessage?: boolean
    comments?: boolean
  }

  export type TwitterUserCountOutputTypeGetPayload<S extends boolean | null | undefined | TwitterUserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TwitterUserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TwitterUserCountOutputTypeArgs)
    ? TwitterUserCountOutputType 
    : S extends { select: any } & (TwitterUserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TwitterUserCountOutputType ? TwitterUserCountOutputType[P] : never
  } 
      : TwitterUserCountOutputType




  // Custom InputTypes

  /**
   * TwitterUserCountOutputType without action
   */
  export type TwitterUserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TwitterUserCountOutputType
     */
    select?: TwitterUserCountOutputTypeSelect | null
  }



  /**
   * Count Type TwitterPostCountOutputType
   */


  export type TwitterPostCountOutputType = {
    comments: number
    postOnHashtags: number
  }

  export type TwitterPostCountOutputTypeSelect = {
    comments?: boolean
    postOnHashtags?: boolean
  }

  export type TwitterPostCountOutputTypeGetPayload<S extends boolean | null | undefined | TwitterPostCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TwitterPostCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TwitterPostCountOutputTypeArgs)
    ? TwitterPostCountOutputType 
    : S extends { select: any } & (TwitterPostCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TwitterPostCountOutputType ? TwitterPostCountOutputType[P] : never
  } 
      : TwitterPostCountOutputType




  // Custom InputTypes

  /**
   * TwitterPostCountOutputType without action
   */
  export type TwitterPostCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TwitterPostCountOutputType
     */
    select?: TwitterPostCountOutputTypeSelect | null
  }



  /**
   * Count Type TwitterHashtagCountOutputType
   */


  export type TwitterHashtagCountOutputType = {
    postOnHashtag: number
  }

  export type TwitterHashtagCountOutputTypeSelect = {
    postOnHashtag?: boolean
  }

  export type TwitterHashtagCountOutputTypeGetPayload<S extends boolean | null | undefined | TwitterHashtagCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TwitterHashtagCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TwitterHashtagCountOutputTypeArgs)
    ? TwitterHashtagCountOutputType 
    : S extends { select: any } & (TwitterHashtagCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TwitterHashtagCountOutputType ? TwitterHashtagCountOutputType[P] : never
  } 
      : TwitterHashtagCountOutputType




  // Custom InputTypes

  /**
   * TwitterHashtagCountOutputType without action
   */
  export type TwitterHashtagCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TwitterHashtagCountOutputType
     */
    select?: TwitterHashtagCountOutputTypeSelect | null
  }



  /**
   * Count Type WSUserCountOutputType
   */


  export type WSUserCountOutputType = {
    topupHistories: number
    usingHistories: number
  }

  export type WSUserCountOutputTypeSelect = {
    topupHistories?: boolean
    usingHistories?: boolean
  }

  export type WSUserCountOutputTypeGetPayload<S extends boolean | null | undefined | WSUserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? WSUserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (WSUserCountOutputTypeArgs)
    ? WSUserCountOutputType 
    : S extends { select: any } & (WSUserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof WSUserCountOutputType ? WSUserCountOutputType[P] : never
  } 
      : WSUserCountOutputType




  // Custom InputTypes

  /**
   * WSUserCountOutputType without action
   */
  export type WSUserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the WSUserCountOutputType
     */
    select?: WSUserCountOutputTypeSelect | null
  }



  /**
   * Count Type WSShopCountOutputType
   */


  export type WSShopCountOutputType = {
    machines: number
  }

  export type WSShopCountOutputTypeSelect = {
    machines?: boolean
  }

  export type WSShopCountOutputTypeGetPayload<S extends boolean | null | undefined | WSShopCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? WSShopCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (WSShopCountOutputTypeArgs)
    ? WSShopCountOutputType 
    : S extends { select: any } & (WSShopCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof WSShopCountOutputType ? WSShopCountOutputType[P] : never
  } 
      : WSShopCountOutputType




  // Custom InputTypes

  /**
   * WSShopCountOutputType without action
   */
  export type WSShopCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the WSShopCountOutputType
     */
    select?: WSShopCountOutputTypeSelect | null
  }



  /**
   * Count Type WSMachineCountOutputType
   */


  export type WSMachineCountOutputType = {
    machineToPrograms: number
    maintains: number
    usingHistories: number
  }

  export type WSMachineCountOutputTypeSelect = {
    machineToPrograms?: boolean
    maintains?: boolean
    usingHistories?: boolean
  }

  export type WSMachineCountOutputTypeGetPayload<S extends boolean | null | undefined | WSMachineCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? WSMachineCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (WSMachineCountOutputTypeArgs)
    ? WSMachineCountOutputType 
    : S extends { select: any } & (WSMachineCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof WSMachineCountOutputType ? WSMachineCountOutputType[P] : never
  } 
      : WSMachineCountOutputType




  // Custom InputTypes

  /**
   * WSMachineCountOutputType without action
   */
  export type WSMachineCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the WSMachineCountOutputType
     */
    select?: WSMachineCountOutputTypeSelect | null
  }



  /**
   * Count Type WSProgramCountOutputType
   */


  export type WSProgramCountOutputType = {
    machineToPrograms: number
    programLists: number
    usingHistories: number
  }

  export type WSProgramCountOutputTypeSelect = {
    machineToPrograms?: boolean
    programLists?: boolean
    usingHistories?: boolean
  }

  export type WSProgramCountOutputTypeGetPayload<S extends boolean | null | undefined | WSProgramCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? WSProgramCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (WSProgramCountOutputTypeArgs)
    ? WSProgramCountOutputType 
    : S extends { select: any } & (WSProgramCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof WSProgramCountOutputType ? WSProgramCountOutputType[P] : never
  } 
      : WSProgramCountOutputType




  // Custom InputTypes

  /**
   * WSProgramCountOutputType without action
   */
  export type WSProgramCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the WSProgramCountOutputType
     */
    select?: WSProgramCountOutputTypeSelect | null
  }



  /**
   * Count Type WSProgramDetailCountOutputType
   */


  export type WSProgramDetailCountOutputType = {
    programs: number
  }

  export type WSProgramDetailCountOutputTypeSelect = {
    programs?: boolean
  }

  export type WSProgramDetailCountOutputTypeGetPayload<S extends boolean | null | undefined | WSProgramDetailCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? WSProgramDetailCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (WSProgramDetailCountOutputTypeArgs)
    ? WSProgramDetailCountOutputType 
    : S extends { select: any } & (WSProgramDetailCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof WSProgramDetailCountOutputType ? WSProgramDetailCountOutputType[P] : never
  } 
      : WSProgramDetailCountOutputType




  // Custom InputTypes

  /**
   * WSProgramDetailCountOutputType without action
   */
  export type WSProgramDetailCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the WSProgramDetailCountOutputType
     */
    select?: WSProgramDetailCountOutputTypeSelect | null
  }



  /**
   * Count Type YTUserCountOutputType
   */


  export type YTUserCountOutputType = {
    userToChannels: number
    comments: number
    subscribes: number
    shares: number
  }

  export type YTUserCountOutputTypeSelect = {
    userToChannels?: boolean
    comments?: boolean
    subscribes?: boolean
    shares?: boolean
  }

  export type YTUserCountOutputTypeGetPayload<S extends boolean | null | undefined | YTUserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YTUserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (YTUserCountOutputTypeArgs)
    ? YTUserCountOutputType 
    : S extends { select: any } & (YTUserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof YTUserCountOutputType ? YTUserCountOutputType[P] : never
  } 
      : YTUserCountOutputType




  // Custom InputTypes

  /**
   * YTUserCountOutputType without action
   */
  export type YTUserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the YTUserCountOutputType
     */
    select?: YTUserCountOutputTypeSelect | null
  }



  /**
   * Count Type YTChannelCountOutputType
   */


  export type YTChannelCountOutputType = {
    userToChannels: number
    videos: number
    subscribes: number
  }

  export type YTChannelCountOutputTypeSelect = {
    userToChannels?: boolean
    videos?: boolean
    subscribes?: boolean
  }

  export type YTChannelCountOutputTypeGetPayload<S extends boolean | null | undefined | YTChannelCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YTChannelCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (YTChannelCountOutputTypeArgs)
    ? YTChannelCountOutputType 
    : S extends { select: any } & (YTChannelCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof YTChannelCountOutputType ? YTChannelCountOutputType[P] : never
  } 
      : YTChannelCountOutputType




  // Custom InputTypes

  /**
   * YTChannelCountOutputType without action
   */
  export type YTChannelCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the YTChannelCountOutputType
     */
    select?: YTChannelCountOutputTypeSelect | null
  }



  /**
   * Count Type YTVideoCountOutputType
   */


  export type YTVideoCountOutputType = {
    likes: number
    comments: number
    shares: number
  }

  export type YTVideoCountOutputTypeSelect = {
    likes?: boolean
    comments?: boolean
    shares?: boolean
  }

  export type YTVideoCountOutputTypeGetPayload<S extends boolean | null | undefined | YTVideoCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YTVideoCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (YTVideoCountOutputTypeArgs)
    ? YTVideoCountOutputType 
    : S extends { select: any } & (YTVideoCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof YTVideoCountOutputType ? YTVideoCountOutputType[P] : never
  } 
      : YTVideoCountOutputType




  // Custom InputTypes

  /**
   * YTVideoCountOutputType without action
   */
  export type YTVideoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the YTVideoCountOutputType
     */
    select?: YTVideoCountOutputTypeSelect | null
  }



  /**
   * Count Type YTCommentCountOutputType
   */


  export type YTCommentCountOutputType = {
    likes: number
  }

  export type YTCommentCountOutputTypeSelect = {
    likes?: boolean
  }

  export type YTCommentCountOutputTypeGetPayload<S extends boolean | null | undefined | YTCommentCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YTCommentCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (YTCommentCountOutputTypeArgs)
    ? YTCommentCountOutputType 
    : S extends { select: any } & (YTCommentCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof YTCommentCountOutputType ? YTCommentCountOutputType[P] : never
  } 
      : YTCommentCountOutputType




  // Custom InputTypes

  /**
   * YTCommentCountOutputType without action
   */
  export type YTCommentCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the YTCommentCountOutputType
     */
    select?: YTCommentCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model BKReserveUser
   */


  export type AggregateBKReserveUser = {
    _count: BKReserveUserCountAggregateOutputType | null
    _avg: BKReserveUserAvgAggregateOutputType | null
    _sum: BKReserveUserSumAggregateOutputType | null
    _min: BKReserveUserMinAggregateOutputType | null
    _max: BKReserveUserMaxAggregateOutputType | null
  }

  export type BKReserveUserAvgAggregateOutputType = {
    id: number | null
    universityId: number | null
  }

  export type BKReserveUserSumAggregateOutputType = {
    id: number | null
    universityId: number | null
  }

  export type BKReserveUserMinAggregateOutputType = {
    id: number | null
    universityId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BKReserveUserMaxAggregateOutputType = {
    id: number | null
    universityId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BKReserveUserCountAggregateOutputType = {
    id: number
    universityId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BKReserveUserAvgAggregateInputType = {
    id?: true
    universityId?: true
  }

  export type BKReserveUserSumAggregateInputType = {
    id?: true
    universityId?: true
  }

  export type BKReserveUserMinAggregateInputType = {
    id?: true
    universityId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BKReserveUserMaxAggregateInputType = {
    id?: true
    universityId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BKReserveUserCountAggregateInputType = {
    id?: true
    universityId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BKReserveUserAggregateArgs = {
    /**
     * Filter which BKReserveUser to aggregate.
     */
    where?: BKReserveUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BKReserveUsers to fetch.
     */
    orderBy?: Enumerable<BKReserveUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BKReserveUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BKReserveUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BKReserveUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BKReserveUsers
    **/
    _count?: true | BKReserveUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BKReserveUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BKReserveUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BKReserveUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BKReserveUserMaxAggregateInputType
  }

  export type GetBKReserveUserAggregateType<T extends BKReserveUserAggregateArgs> = {
        [P in keyof T & keyof AggregateBKReserveUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBKReserveUser[P]>
      : GetScalarType<T[P], AggregateBKReserveUser[P]>
  }




  export type BKReserveUserGroupByArgs = {
    where?: BKReserveUserWhereInput
    orderBy?: Enumerable<BKReserveUserOrderByWithAggregationInput>
    by: BKReserveUserScalarFieldEnum[]
    having?: BKReserveUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BKReserveUserCountAggregateInputType | true
    _avg?: BKReserveUserAvgAggregateInputType
    _sum?: BKReserveUserSumAggregateInputType
    _min?: BKReserveUserMinAggregateInputType
    _max?: BKReserveUserMaxAggregateInputType
  }


  export type BKReserveUserGroupByOutputType = {
    id: number
    universityId: number
    createdAt: Date
    updatedAt: Date
    _count: BKReserveUserCountAggregateOutputType | null
    _avg: BKReserveUserAvgAggregateOutputType | null
    _sum: BKReserveUserSumAggregateOutputType | null
    _min: BKReserveUserMinAggregateOutputType | null
    _max: BKReserveUserMaxAggregateOutputType | null
  }

  type GetBKReserveUserGroupByPayload<T extends BKReserveUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BKReserveUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BKReserveUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BKReserveUserGroupByOutputType[P]>
            : GetScalarType<T[P], BKReserveUserGroupByOutputType[P]>
        }
      >
    >


  export type BKReserveUserSelect = {
    id?: boolean
    university?: boolean | BKUniversityArgs
    universityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    requests?: boolean | BKReserveUser$requestsArgs
    BKBorrowingHistory?: boolean | BKReserveUser$BKBorrowingHistoryArgs
    BKCopy?: boolean | BKReserveUser$BKCopyArgs
    _count?: boolean | BKReserveUserCountOutputTypeArgs
  }


  export type BKReserveUserInclude = {
    university?: boolean | BKUniversityArgs
    requests?: boolean | BKReserveUser$requestsArgs
    BKBorrowingHistory?: boolean | BKReserveUser$BKBorrowingHistoryArgs
    BKCopy?: boolean | BKReserveUser$BKCopyArgs
    _count?: boolean | BKReserveUserCountOutputTypeArgs
  }

  export type BKReserveUserGetPayload<S extends boolean | null | undefined | BKReserveUserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BKReserveUser :
    S extends undefined ? never :
    S extends { include: any } & (BKReserveUserArgs | BKReserveUserFindManyArgs)
    ? BKReserveUser  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'university' ? BKUniversityGetPayload<S['include'][P]> :
        P extends 'requests' ? Array < BKRequestGetPayload<S['include'][P]>>  :
        P extends 'BKBorrowingHistory' ? Array < BKBorrowingHistoryGetPayload<S['include'][P]>>  :
        P extends 'BKCopy' ? Array < BKCopyGetPayload<S['include'][P]>>  :
        P extends '_count' ? BKReserveUserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BKReserveUserArgs | BKReserveUserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'university' ? BKUniversityGetPayload<S['select'][P]> :
        P extends 'requests' ? Array < BKRequestGetPayload<S['select'][P]>>  :
        P extends 'BKBorrowingHistory' ? Array < BKBorrowingHistoryGetPayload<S['select'][P]>>  :
        P extends 'BKCopy' ? Array < BKCopyGetPayload<S['select'][P]>>  :
        P extends '_count' ? BKReserveUserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof BKReserveUser ? BKReserveUser[P] : never
  } 
      : BKReserveUser


  type BKReserveUserCountArgs = 
    Omit<BKReserveUserFindManyArgs, 'select' | 'include'> & {
      select?: BKReserveUserCountAggregateInputType | true
    }

  export interface BKReserveUserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one BKReserveUser that matches the filter.
     * @param {BKReserveUserFindUniqueArgs} args - Arguments to find a BKReserveUser
     * @example
     * // Get one BKReserveUser
     * const bKReserveUser = await prisma.bKReserveUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BKReserveUserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BKReserveUserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BKReserveUser'> extends True ? Prisma__BKReserveUserClient<BKReserveUserGetPayload<T>> : Prisma__BKReserveUserClient<BKReserveUserGetPayload<T> | null, null>

    /**
     * Find one BKReserveUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BKReserveUserFindUniqueOrThrowArgs} args - Arguments to find a BKReserveUser
     * @example
     * // Get one BKReserveUser
     * const bKReserveUser = await prisma.bKReserveUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BKReserveUserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BKReserveUserFindUniqueOrThrowArgs>
    ): Prisma__BKReserveUserClient<BKReserveUserGetPayload<T>>

    /**
     * Find the first BKReserveUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKReserveUserFindFirstArgs} args - Arguments to find a BKReserveUser
     * @example
     * // Get one BKReserveUser
     * const bKReserveUser = await prisma.bKReserveUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BKReserveUserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BKReserveUserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BKReserveUser'> extends True ? Prisma__BKReserveUserClient<BKReserveUserGetPayload<T>> : Prisma__BKReserveUserClient<BKReserveUserGetPayload<T> | null, null>

    /**
     * Find the first BKReserveUser that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKReserveUserFindFirstOrThrowArgs} args - Arguments to find a BKReserveUser
     * @example
     * // Get one BKReserveUser
     * const bKReserveUser = await prisma.bKReserveUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BKReserveUserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BKReserveUserFindFirstOrThrowArgs>
    ): Prisma__BKReserveUserClient<BKReserveUserGetPayload<T>>

    /**
     * Find zero or more BKReserveUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKReserveUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BKReserveUsers
     * const bKReserveUsers = await prisma.bKReserveUser.findMany()
     * 
     * // Get first 10 BKReserveUsers
     * const bKReserveUsers = await prisma.bKReserveUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bKReserveUserWithIdOnly = await prisma.bKReserveUser.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BKReserveUserFindManyArgs>(
      args?: SelectSubset<T, BKReserveUserFindManyArgs>
    ): Prisma.PrismaPromise<Array<BKReserveUserGetPayload<T>>>

    /**
     * Create a BKReserveUser.
     * @param {BKReserveUserCreateArgs} args - Arguments to create a BKReserveUser.
     * @example
     * // Create one BKReserveUser
     * const BKReserveUser = await prisma.bKReserveUser.create({
     *   data: {
     *     // ... data to create a BKReserveUser
     *   }
     * })
     * 
    **/
    create<T extends BKReserveUserCreateArgs>(
      args: SelectSubset<T, BKReserveUserCreateArgs>
    ): Prisma__BKReserveUserClient<BKReserveUserGetPayload<T>>

    /**
     * Create many BKReserveUsers.
     *     @param {BKReserveUserCreateManyArgs} args - Arguments to create many BKReserveUsers.
     *     @example
     *     // Create many BKReserveUsers
     *     const bKReserveUser = await prisma.bKReserveUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BKReserveUserCreateManyArgs>(
      args?: SelectSubset<T, BKReserveUserCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BKReserveUser.
     * @param {BKReserveUserDeleteArgs} args - Arguments to delete one BKReserveUser.
     * @example
     * // Delete one BKReserveUser
     * const BKReserveUser = await prisma.bKReserveUser.delete({
     *   where: {
     *     // ... filter to delete one BKReserveUser
     *   }
     * })
     * 
    **/
    delete<T extends BKReserveUserDeleteArgs>(
      args: SelectSubset<T, BKReserveUserDeleteArgs>
    ): Prisma__BKReserveUserClient<BKReserveUserGetPayload<T>>

    /**
     * Update one BKReserveUser.
     * @param {BKReserveUserUpdateArgs} args - Arguments to update one BKReserveUser.
     * @example
     * // Update one BKReserveUser
     * const bKReserveUser = await prisma.bKReserveUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BKReserveUserUpdateArgs>(
      args: SelectSubset<T, BKReserveUserUpdateArgs>
    ): Prisma__BKReserveUserClient<BKReserveUserGetPayload<T>>

    /**
     * Delete zero or more BKReserveUsers.
     * @param {BKReserveUserDeleteManyArgs} args - Arguments to filter BKReserveUsers to delete.
     * @example
     * // Delete a few BKReserveUsers
     * const { count } = await prisma.bKReserveUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BKReserveUserDeleteManyArgs>(
      args?: SelectSubset<T, BKReserveUserDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BKReserveUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKReserveUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BKReserveUsers
     * const bKReserveUser = await prisma.bKReserveUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BKReserveUserUpdateManyArgs>(
      args: SelectSubset<T, BKReserveUserUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BKReserveUser.
     * @param {BKReserveUserUpsertArgs} args - Arguments to update or create a BKReserveUser.
     * @example
     * // Update or create a BKReserveUser
     * const bKReserveUser = await prisma.bKReserveUser.upsert({
     *   create: {
     *     // ... data to create a BKReserveUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BKReserveUser we want to update
     *   }
     * })
    **/
    upsert<T extends BKReserveUserUpsertArgs>(
      args: SelectSubset<T, BKReserveUserUpsertArgs>
    ): Prisma__BKReserveUserClient<BKReserveUserGetPayload<T>>

    /**
     * Count the number of BKReserveUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKReserveUserCountArgs} args - Arguments to filter BKReserveUsers to count.
     * @example
     * // Count the number of BKReserveUsers
     * const count = await prisma.bKReserveUser.count({
     *   where: {
     *     // ... the filter for the BKReserveUsers we want to count
     *   }
     * })
    **/
    count<T extends BKReserveUserCountArgs>(
      args?: Subset<T, BKReserveUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BKReserveUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BKReserveUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKReserveUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BKReserveUserAggregateArgs>(args: Subset<T, BKReserveUserAggregateArgs>): Prisma.PrismaPromise<GetBKReserveUserAggregateType<T>>

    /**
     * Group by BKReserveUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKReserveUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BKReserveUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BKReserveUserGroupByArgs['orderBy'] }
        : { orderBy?: BKReserveUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BKReserveUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBKReserveUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BKReserveUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BKReserveUserClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    university<T extends BKUniversityArgs= {}>(args?: Subset<T, BKUniversityArgs>): Prisma__BKUniversityClient<BKUniversityGetPayload<T> | Null>;

    requests<T extends BKReserveUser$requestsArgs= {}>(args?: Subset<T, BKReserveUser$requestsArgs>): Prisma.PrismaPromise<Array<BKRequestGetPayload<T>>| Null>;

    BKBorrowingHistory<T extends BKReserveUser$BKBorrowingHistoryArgs= {}>(args?: Subset<T, BKReserveUser$BKBorrowingHistoryArgs>): Prisma.PrismaPromise<Array<BKBorrowingHistoryGetPayload<T>>| Null>;

    BKCopy<T extends BKReserveUser$BKCopyArgs= {}>(args?: Subset<T, BKReserveUser$BKCopyArgs>): Prisma.PrismaPromise<Array<BKCopyGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BKReserveUser base type for findUnique actions
   */
  export type BKReserveUserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BKReserveUser
     */
    select?: BKReserveUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKReserveUserInclude | null
    /**
     * Filter, which BKReserveUser to fetch.
     */
    where: BKReserveUserWhereUniqueInput
  }

  /**
   * BKReserveUser findUnique
   */
  export interface BKReserveUserFindUniqueArgs extends BKReserveUserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BKReserveUser findUniqueOrThrow
   */
  export type BKReserveUserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BKReserveUser
     */
    select?: BKReserveUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKReserveUserInclude | null
    /**
     * Filter, which BKReserveUser to fetch.
     */
    where: BKReserveUserWhereUniqueInput
  }


  /**
   * BKReserveUser base type for findFirst actions
   */
  export type BKReserveUserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BKReserveUser
     */
    select?: BKReserveUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKReserveUserInclude | null
    /**
     * Filter, which BKReserveUser to fetch.
     */
    where?: BKReserveUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BKReserveUsers to fetch.
     */
    orderBy?: Enumerable<BKReserveUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BKReserveUsers.
     */
    cursor?: BKReserveUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BKReserveUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BKReserveUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BKReserveUsers.
     */
    distinct?: Enumerable<BKReserveUserScalarFieldEnum>
  }

  /**
   * BKReserveUser findFirst
   */
  export interface BKReserveUserFindFirstArgs extends BKReserveUserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BKReserveUser findFirstOrThrow
   */
  export type BKReserveUserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BKReserveUser
     */
    select?: BKReserveUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKReserveUserInclude | null
    /**
     * Filter, which BKReserveUser to fetch.
     */
    where?: BKReserveUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BKReserveUsers to fetch.
     */
    orderBy?: Enumerable<BKReserveUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BKReserveUsers.
     */
    cursor?: BKReserveUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BKReserveUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BKReserveUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BKReserveUsers.
     */
    distinct?: Enumerable<BKReserveUserScalarFieldEnum>
  }


  /**
   * BKReserveUser findMany
   */
  export type BKReserveUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the BKReserveUser
     */
    select?: BKReserveUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKReserveUserInclude | null
    /**
     * Filter, which BKReserveUsers to fetch.
     */
    where?: BKReserveUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BKReserveUsers to fetch.
     */
    orderBy?: Enumerable<BKReserveUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BKReserveUsers.
     */
    cursor?: BKReserveUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BKReserveUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BKReserveUsers.
     */
    skip?: number
    distinct?: Enumerable<BKReserveUserScalarFieldEnum>
  }


  /**
   * BKReserveUser create
   */
  export type BKReserveUserCreateArgs = {
    /**
     * Select specific fields to fetch from the BKReserveUser
     */
    select?: BKReserveUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKReserveUserInclude | null
    /**
     * The data needed to create a BKReserveUser.
     */
    data: XOR<BKReserveUserCreateInput, BKReserveUserUncheckedCreateInput>
  }


  /**
   * BKReserveUser createMany
   */
  export type BKReserveUserCreateManyArgs = {
    /**
     * The data used to create many BKReserveUsers.
     */
    data: Enumerable<BKReserveUserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BKReserveUser update
   */
  export type BKReserveUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the BKReserveUser
     */
    select?: BKReserveUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKReserveUserInclude | null
    /**
     * The data needed to update a BKReserveUser.
     */
    data: XOR<BKReserveUserUpdateInput, BKReserveUserUncheckedUpdateInput>
    /**
     * Choose, which BKReserveUser to update.
     */
    where: BKReserveUserWhereUniqueInput
  }


  /**
   * BKReserveUser updateMany
   */
  export type BKReserveUserUpdateManyArgs = {
    /**
     * The data used to update BKReserveUsers.
     */
    data: XOR<BKReserveUserUpdateManyMutationInput, BKReserveUserUncheckedUpdateManyInput>
    /**
     * Filter which BKReserveUsers to update
     */
    where?: BKReserveUserWhereInput
  }


  /**
   * BKReserveUser upsert
   */
  export type BKReserveUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the BKReserveUser
     */
    select?: BKReserveUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKReserveUserInclude | null
    /**
     * The filter to search for the BKReserveUser to update in case it exists.
     */
    where: BKReserveUserWhereUniqueInput
    /**
     * In case the BKReserveUser found by the `where` argument doesn't exist, create a new BKReserveUser with this data.
     */
    create: XOR<BKReserveUserCreateInput, BKReserveUserUncheckedCreateInput>
    /**
     * In case the BKReserveUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BKReserveUserUpdateInput, BKReserveUserUncheckedUpdateInput>
  }


  /**
   * BKReserveUser delete
   */
  export type BKReserveUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the BKReserveUser
     */
    select?: BKReserveUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKReserveUserInclude | null
    /**
     * Filter which BKReserveUser to delete.
     */
    where: BKReserveUserWhereUniqueInput
  }


  /**
   * BKReserveUser deleteMany
   */
  export type BKReserveUserDeleteManyArgs = {
    /**
     * Filter which BKReserveUsers to delete
     */
    where?: BKReserveUserWhereInput
  }


  /**
   * BKReserveUser.requests
   */
  export type BKReserveUser$requestsArgs = {
    /**
     * Select specific fields to fetch from the BKRequest
     */
    select?: BKRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKRequestInclude | null
    where?: BKRequestWhereInput
    orderBy?: Enumerable<BKRequestOrderByWithRelationInput>
    cursor?: BKRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BKRequestScalarFieldEnum>
  }


  /**
   * BKReserveUser.BKBorrowingHistory
   */
  export type BKReserveUser$BKBorrowingHistoryArgs = {
    /**
     * Select specific fields to fetch from the BKBorrowingHistory
     */
    select?: BKBorrowingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKBorrowingHistoryInclude | null
    where?: BKBorrowingHistoryWhereInput
    orderBy?: Enumerable<BKBorrowingHistoryOrderByWithRelationInput>
    cursor?: BKBorrowingHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BKBorrowingHistoryScalarFieldEnum>
  }


  /**
   * BKReserveUser.BKCopy
   */
  export type BKReserveUser$BKCopyArgs = {
    /**
     * Select specific fields to fetch from the BKCopy
     */
    select?: BKCopySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKCopyInclude | null
    where?: BKCopyWhereInput
    orderBy?: Enumerable<BKCopyOrderByWithRelationInput>
    cursor?: BKCopyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BKCopyScalarFieldEnum>
  }


  /**
   * BKReserveUser without action
   */
  export type BKReserveUserArgs = {
    /**
     * Select specific fields to fetch from the BKReserveUser
     */
    select?: BKReserveUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKReserveUserInclude | null
  }



  /**
   * Model BKRequest
   */


  export type AggregateBKRequest = {
    _count: BKRequestCountAggregateOutputType | null
    _avg: BKRequestAvgAggregateOutputType | null
    _sum: BKRequestSumAggregateOutputType | null
    _min: BKRequestMinAggregateOutputType | null
    _max: BKRequestMaxAggregateOutputType | null
  }

  export type BKRequestAvgAggregateOutputType = {
    id: number | null
    reserveUserId: number | null
    copyId: number | null
    fromUniversityId: number | null
    toUniversityId: number | null
  }

  export type BKRequestSumAggregateOutputType = {
    id: number | null
    reserveUserId: number | null
    copyId: number | null
    fromUniversityId: number | null
    toUniversityId: number | null
  }

  export type BKRequestMinAggregateOutputType = {
    id: number | null
    reserveUserId: number | null
    copyId: number | null
    fromUniversityId: number | null
    toUniversityId: number | null
    requestDate: Date | null
    status: RequestStatusEnum | null
    planRecievedDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BKRequestMaxAggregateOutputType = {
    id: number | null
    reserveUserId: number | null
    copyId: number | null
    fromUniversityId: number | null
    toUniversityId: number | null
    requestDate: Date | null
    status: RequestStatusEnum | null
    planRecievedDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BKRequestCountAggregateOutputType = {
    id: number
    reserveUserId: number
    copyId: number
    fromUniversityId: number
    toUniversityId: number
    requestDate: number
    status: number
    planRecievedDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BKRequestAvgAggregateInputType = {
    id?: true
    reserveUserId?: true
    copyId?: true
    fromUniversityId?: true
    toUniversityId?: true
  }

  export type BKRequestSumAggregateInputType = {
    id?: true
    reserveUserId?: true
    copyId?: true
    fromUniversityId?: true
    toUniversityId?: true
  }

  export type BKRequestMinAggregateInputType = {
    id?: true
    reserveUserId?: true
    copyId?: true
    fromUniversityId?: true
    toUniversityId?: true
    requestDate?: true
    status?: true
    planRecievedDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BKRequestMaxAggregateInputType = {
    id?: true
    reserveUserId?: true
    copyId?: true
    fromUniversityId?: true
    toUniversityId?: true
    requestDate?: true
    status?: true
    planRecievedDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BKRequestCountAggregateInputType = {
    id?: true
    reserveUserId?: true
    copyId?: true
    fromUniversityId?: true
    toUniversityId?: true
    requestDate?: true
    status?: true
    planRecievedDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BKRequestAggregateArgs = {
    /**
     * Filter which BKRequest to aggregate.
     */
    where?: BKRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BKRequests to fetch.
     */
    orderBy?: Enumerable<BKRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BKRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BKRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BKRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BKRequests
    **/
    _count?: true | BKRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BKRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BKRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BKRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BKRequestMaxAggregateInputType
  }

  export type GetBKRequestAggregateType<T extends BKRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateBKRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBKRequest[P]>
      : GetScalarType<T[P], AggregateBKRequest[P]>
  }




  export type BKRequestGroupByArgs = {
    where?: BKRequestWhereInput
    orderBy?: Enumerable<BKRequestOrderByWithAggregationInput>
    by: BKRequestScalarFieldEnum[]
    having?: BKRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BKRequestCountAggregateInputType | true
    _avg?: BKRequestAvgAggregateInputType
    _sum?: BKRequestSumAggregateInputType
    _min?: BKRequestMinAggregateInputType
    _max?: BKRequestMaxAggregateInputType
  }


  export type BKRequestGroupByOutputType = {
    id: number
    reserveUserId: number
    copyId: number
    fromUniversityId: number
    toUniversityId: number
    requestDate: Date
    status: RequestStatusEnum
    planRecievedDate: Date
    createdAt: Date
    updatedAt: Date
    _count: BKRequestCountAggregateOutputType | null
    _avg: BKRequestAvgAggregateOutputType | null
    _sum: BKRequestSumAggregateOutputType | null
    _min: BKRequestMinAggregateOutputType | null
    _max: BKRequestMaxAggregateOutputType | null
  }

  type GetBKRequestGroupByPayload<T extends BKRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BKRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BKRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BKRequestGroupByOutputType[P]>
            : GetScalarType<T[P], BKRequestGroupByOutputType[P]>
        }
      >
    >


  export type BKRequestSelect = {
    id?: boolean
    user?: boolean | BKReserveUserArgs
    reserveUserId?: boolean
    copy?: boolean | BKCopyArgs
    copyId?: boolean
    from?: boolean | BKUniversityArgs
    fromUniversityId?: boolean
    to?: boolean | BKUniversityArgs
    toUniversityId?: boolean
    requestDate?: boolean
    status?: boolean
    planRecievedDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type BKRequestInclude = {
    user?: boolean | BKReserveUserArgs
    copy?: boolean | BKCopyArgs
    from?: boolean | BKUniversityArgs
    to?: boolean | BKUniversityArgs
  }

  export type BKRequestGetPayload<S extends boolean | null | undefined | BKRequestArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BKRequest :
    S extends undefined ? never :
    S extends { include: any } & (BKRequestArgs | BKRequestFindManyArgs)
    ? BKRequest  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? BKReserveUserGetPayload<S['include'][P]> :
        P extends 'copy' ? BKCopyGetPayload<S['include'][P]> :
        P extends 'from' ? BKUniversityGetPayload<S['include'][P]> :
        P extends 'to' ? BKUniversityGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BKRequestArgs | BKRequestFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? BKReserveUserGetPayload<S['select'][P]> :
        P extends 'copy' ? BKCopyGetPayload<S['select'][P]> :
        P extends 'from' ? BKUniversityGetPayload<S['select'][P]> :
        P extends 'to' ? BKUniversityGetPayload<S['select'][P]> :  P extends keyof BKRequest ? BKRequest[P] : never
  } 
      : BKRequest


  type BKRequestCountArgs = 
    Omit<BKRequestFindManyArgs, 'select' | 'include'> & {
      select?: BKRequestCountAggregateInputType | true
    }

  export interface BKRequestDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one BKRequest that matches the filter.
     * @param {BKRequestFindUniqueArgs} args - Arguments to find a BKRequest
     * @example
     * // Get one BKRequest
     * const bKRequest = await prisma.bKRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BKRequestFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BKRequestFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BKRequest'> extends True ? Prisma__BKRequestClient<BKRequestGetPayload<T>> : Prisma__BKRequestClient<BKRequestGetPayload<T> | null, null>

    /**
     * Find one BKRequest that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BKRequestFindUniqueOrThrowArgs} args - Arguments to find a BKRequest
     * @example
     * // Get one BKRequest
     * const bKRequest = await prisma.bKRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BKRequestFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BKRequestFindUniqueOrThrowArgs>
    ): Prisma__BKRequestClient<BKRequestGetPayload<T>>

    /**
     * Find the first BKRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKRequestFindFirstArgs} args - Arguments to find a BKRequest
     * @example
     * // Get one BKRequest
     * const bKRequest = await prisma.bKRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BKRequestFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BKRequestFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BKRequest'> extends True ? Prisma__BKRequestClient<BKRequestGetPayload<T>> : Prisma__BKRequestClient<BKRequestGetPayload<T> | null, null>

    /**
     * Find the first BKRequest that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKRequestFindFirstOrThrowArgs} args - Arguments to find a BKRequest
     * @example
     * // Get one BKRequest
     * const bKRequest = await prisma.bKRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BKRequestFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BKRequestFindFirstOrThrowArgs>
    ): Prisma__BKRequestClient<BKRequestGetPayload<T>>

    /**
     * Find zero or more BKRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKRequestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BKRequests
     * const bKRequests = await prisma.bKRequest.findMany()
     * 
     * // Get first 10 BKRequests
     * const bKRequests = await prisma.bKRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bKRequestWithIdOnly = await prisma.bKRequest.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BKRequestFindManyArgs>(
      args?: SelectSubset<T, BKRequestFindManyArgs>
    ): Prisma.PrismaPromise<Array<BKRequestGetPayload<T>>>

    /**
     * Create a BKRequest.
     * @param {BKRequestCreateArgs} args - Arguments to create a BKRequest.
     * @example
     * // Create one BKRequest
     * const BKRequest = await prisma.bKRequest.create({
     *   data: {
     *     // ... data to create a BKRequest
     *   }
     * })
     * 
    **/
    create<T extends BKRequestCreateArgs>(
      args: SelectSubset<T, BKRequestCreateArgs>
    ): Prisma__BKRequestClient<BKRequestGetPayload<T>>

    /**
     * Create many BKRequests.
     *     @param {BKRequestCreateManyArgs} args - Arguments to create many BKRequests.
     *     @example
     *     // Create many BKRequests
     *     const bKRequest = await prisma.bKRequest.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BKRequestCreateManyArgs>(
      args?: SelectSubset<T, BKRequestCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BKRequest.
     * @param {BKRequestDeleteArgs} args - Arguments to delete one BKRequest.
     * @example
     * // Delete one BKRequest
     * const BKRequest = await prisma.bKRequest.delete({
     *   where: {
     *     // ... filter to delete one BKRequest
     *   }
     * })
     * 
    **/
    delete<T extends BKRequestDeleteArgs>(
      args: SelectSubset<T, BKRequestDeleteArgs>
    ): Prisma__BKRequestClient<BKRequestGetPayload<T>>

    /**
     * Update one BKRequest.
     * @param {BKRequestUpdateArgs} args - Arguments to update one BKRequest.
     * @example
     * // Update one BKRequest
     * const bKRequest = await prisma.bKRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BKRequestUpdateArgs>(
      args: SelectSubset<T, BKRequestUpdateArgs>
    ): Prisma__BKRequestClient<BKRequestGetPayload<T>>

    /**
     * Delete zero or more BKRequests.
     * @param {BKRequestDeleteManyArgs} args - Arguments to filter BKRequests to delete.
     * @example
     * // Delete a few BKRequests
     * const { count } = await prisma.bKRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BKRequestDeleteManyArgs>(
      args?: SelectSubset<T, BKRequestDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BKRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BKRequests
     * const bKRequest = await prisma.bKRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BKRequestUpdateManyArgs>(
      args: SelectSubset<T, BKRequestUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BKRequest.
     * @param {BKRequestUpsertArgs} args - Arguments to update or create a BKRequest.
     * @example
     * // Update or create a BKRequest
     * const bKRequest = await prisma.bKRequest.upsert({
     *   create: {
     *     // ... data to create a BKRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BKRequest we want to update
     *   }
     * })
    **/
    upsert<T extends BKRequestUpsertArgs>(
      args: SelectSubset<T, BKRequestUpsertArgs>
    ): Prisma__BKRequestClient<BKRequestGetPayload<T>>

    /**
     * Count the number of BKRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKRequestCountArgs} args - Arguments to filter BKRequests to count.
     * @example
     * // Count the number of BKRequests
     * const count = await prisma.bKRequest.count({
     *   where: {
     *     // ... the filter for the BKRequests we want to count
     *   }
     * })
    **/
    count<T extends BKRequestCountArgs>(
      args?: Subset<T, BKRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BKRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BKRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BKRequestAggregateArgs>(args: Subset<T, BKRequestAggregateArgs>): Prisma.PrismaPromise<GetBKRequestAggregateType<T>>

    /**
     * Group by BKRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BKRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BKRequestGroupByArgs['orderBy'] }
        : { orderBy?: BKRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BKRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBKRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BKRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BKRequestClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends BKReserveUserArgs= {}>(args?: Subset<T, BKReserveUserArgs>): Prisma__BKReserveUserClient<BKReserveUserGetPayload<T> | Null>;

    copy<T extends BKCopyArgs= {}>(args?: Subset<T, BKCopyArgs>): Prisma__BKCopyClient<BKCopyGetPayload<T> | Null>;

    from<T extends BKUniversityArgs= {}>(args?: Subset<T, BKUniversityArgs>): Prisma__BKUniversityClient<BKUniversityGetPayload<T> | Null>;

    to<T extends BKUniversityArgs= {}>(args?: Subset<T, BKUniversityArgs>): Prisma__BKUniversityClient<BKUniversityGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BKRequest base type for findUnique actions
   */
  export type BKRequestFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BKRequest
     */
    select?: BKRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKRequestInclude | null
    /**
     * Filter, which BKRequest to fetch.
     */
    where: BKRequestWhereUniqueInput
  }

  /**
   * BKRequest findUnique
   */
  export interface BKRequestFindUniqueArgs extends BKRequestFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BKRequest findUniqueOrThrow
   */
  export type BKRequestFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BKRequest
     */
    select?: BKRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKRequestInclude | null
    /**
     * Filter, which BKRequest to fetch.
     */
    where: BKRequestWhereUniqueInput
  }


  /**
   * BKRequest base type for findFirst actions
   */
  export type BKRequestFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BKRequest
     */
    select?: BKRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKRequestInclude | null
    /**
     * Filter, which BKRequest to fetch.
     */
    where?: BKRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BKRequests to fetch.
     */
    orderBy?: Enumerable<BKRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BKRequests.
     */
    cursor?: BKRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BKRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BKRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BKRequests.
     */
    distinct?: Enumerable<BKRequestScalarFieldEnum>
  }

  /**
   * BKRequest findFirst
   */
  export interface BKRequestFindFirstArgs extends BKRequestFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BKRequest findFirstOrThrow
   */
  export type BKRequestFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BKRequest
     */
    select?: BKRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKRequestInclude | null
    /**
     * Filter, which BKRequest to fetch.
     */
    where?: BKRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BKRequests to fetch.
     */
    orderBy?: Enumerable<BKRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BKRequests.
     */
    cursor?: BKRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BKRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BKRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BKRequests.
     */
    distinct?: Enumerable<BKRequestScalarFieldEnum>
  }


  /**
   * BKRequest findMany
   */
  export type BKRequestFindManyArgs = {
    /**
     * Select specific fields to fetch from the BKRequest
     */
    select?: BKRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKRequestInclude | null
    /**
     * Filter, which BKRequests to fetch.
     */
    where?: BKRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BKRequests to fetch.
     */
    orderBy?: Enumerable<BKRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BKRequests.
     */
    cursor?: BKRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BKRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BKRequests.
     */
    skip?: number
    distinct?: Enumerable<BKRequestScalarFieldEnum>
  }


  /**
   * BKRequest create
   */
  export type BKRequestCreateArgs = {
    /**
     * Select specific fields to fetch from the BKRequest
     */
    select?: BKRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKRequestInclude | null
    /**
     * The data needed to create a BKRequest.
     */
    data: XOR<BKRequestCreateInput, BKRequestUncheckedCreateInput>
  }


  /**
   * BKRequest createMany
   */
  export type BKRequestCreateManyArgs = {
    /**
     * The data used to create many BKRequests.
     */
    data: Enumerable<BKRequestCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BKRequest update
   */
  export type BKRequestUpdateArgs = {
    /**
     * Select specific fields to fetch from the BKRequest
     */
    select?: BKRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKRequestInclude | null
    /**
     * The data needed to update a BKRequest.
     */
    data: XOR<BKRequestUpdateInput, BKRequestUncheckedUpdateInput>
    /**
     * Choose, which BKRequest to update.
     */
    where: BKRequestWhereUniqueInput
  }


  /**
   * BKRequest updateMany
   */
  export type BKRequestUpdateManyArgs = {
    /**
     * The data used to update BKRequests.
     */
    data: XOR<BKRequestUpdateManyMutationInput, BKRequestUncheckedUpdateManyInput>
    /**
     * Filter which BKRequests to update
     */
    where?: BKRequestWhereInput
  }


  /**
   * BKRequest upsert
   */
  export type BKRequestUpsertArgs = {
    /**
     * Select specific fields to fetch from the BKRequest
     */
    select?: BKRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKRequestInclude | null
    /**
     * The filter to search for the BKRequest to update in case it exists.
     */
    where: BKRequestWhereUniqueInput
    /**
     * In case the BKRequest found by the `where` argument doesn't exist, create a new BKRequest with this data.
     */
    create: XOR<BKRequestCreateInput, BKRequestUncheckedCreateInput>
    /**
     * In case the BKRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BKRequestUpdateInput, BKRequestUncheckedUpdateInput>
  }


  /**
   * BKRequest delete
   */
  export type BKRequestDeleteArgs = {
    /**
     * Select specific fields to fetch from the BKRequest
     */
    select?: BKRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKRequestInclude | null
    /**
     * Filter which BKRequest to delete.
     */
    where: BKRequestWhereUniqueInput
  }


  /**
   * BKRequest deleteMany
   */
  export type BKRequestDeleteManyArgs = {
    /**
     * Filter which BKRequests to delete
     */
    where?: BKRequestWhereInput
  }


  /**
   * BKRequest without action
   */
  export type BKRequestArgs = {
    /**
     * Select specific fields to fetch from the BKRequest
     */
    select?: BKRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKRequestInclude | null
  }



  /**
   * Model BKBorrowingHistory
   */


  export type AggregateBKBorrowingHistory = {
    _count: BKBorrowingHistoryCountAggregateOutputType | null
    _avg: BKBorrowingHistoryAvgAggregateOutputType | null
    _sum: BKBorrowingHistorySumAggregateOutputType | null
    _min: BKBorrowingHistoryMinAggregateOutputType | null
    _max: BKBorrowingHistoryMaxAggregateOutputType | null
  }

  export type BKBorrowingHistoryAvgAggregateOutputType = {
    id: number | null
    reserveUserId: number | null
    copyId: number | null
    fromUniversityId: number | null
  }

  export type BKBorrowingHistorySumAggregateOutputType = {
    id: number | null
    reserveUserId: number | null
    copyId: number | null
    fromUniversityId: number | null
  }

  export type BKBorrowingHistoryMinAggregateOutputType = {
    id: number | null
    reserveUserId: number | null
    copyId: number | null
    fromUniversityId: number | null
    borrowDate: Date | null
    returnDate: Date | null
    actualReturnDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BKBorrowingHistoryMaxAggregateOutputType = {
    id: number | null
    reserveUserId: number | null
    copyId: number | null
    fromUniversityId: number | null
    borrowDate: Date | null
    returnDate: Date | null
    actualReturnDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BKBorrowingHistoryCountAggregateOutputType = {
    id: number
    reserveUserId: number
    copyId: number
    fromUniversityId: number
    borrowDate: number
    returnDate: number
    actualReturnDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BKBorrowingHistoryAvgAggregateInputType = {
    id?: true
    reserveUserId?: true
    copyId?: true
    fromUniversityId?: true
  }

  export type BKBorrowingHistorySumAggregateInputType = {
    id?: true
    reserveUserId?: true
    copyId?: true
    fromUniversityId?: true
  }

  export type BKBorrowingHistoryMinAggregateInputType = {
    id?: true
    reserveUserId?: true
    copyId?: true
    fromUniversityId?: true
    borrowDate?: true
    returnDate?: true
    actualReturnDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BKBorrowingHistoryMaxAggregateInputType = {
    id?: true
    reserveUserId?: true
    copyId?: true
    fromUniversityId?: true
    borrowDate?: true
    returnDate?: true
    actualReturnDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BKBorrowingHistoryCountAggregateInputType = {
    id?: true
    reserveUserId?: true
    copyId?: true
    fromUniversityId?: true
    borrowDate?: true
    returnDate?: true
    actualReturnDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BKBorrowingHistoryAggregateArgs = {
    /**
     * Filter which BKBorrowingHistory to aggregate.
     */
    where?: BKBorrowingHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BKBorrowingHistories to fetch.
     */
    orderBy?: Enumerable<BKBorrowingHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BKBorrowingHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BKBorrowingHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BKBorrowingHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BKBorrowingHistories
    **/
    _count?: true | BKBorrowingHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BKBorrowingHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BKBorrowingHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BKBorrowingHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BKBorrowingHistoryMaxAggregateInputType
  }

  export type GetBKBorrowingHistoryAggregateType<T extends BKBorrowingHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateBKBorrowingHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBKBorrowingHistory[P]>
      : GetScalarType<T[P], AggregateBKBorrowingHistory[P]>
  }




  export type BKBorrowingHistoryGroupByArgs = {
    where?: BKBorrowingHistoryWhereInput
    orderBy?: Enumerable<BKBorrowingHistoryOrderByWithAggregationInput>
    by: BKBorrowingHistoryScalarFieldEnum[]
    having?: BKBorrowingHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BKBorrowingHistoryCountAggregateInputType | true
    _avg?: BKBorrowingHistoryAvgAggregateInputType
    _sum?: BKBorrowingHistorySumAggregateInputType
    _min?: BKBorrowingHistoryMinAggregateInputType
    _max?: BKBorrowingHistoryMaxAggregateInputType
  }


  export type BKBorrowingHistoryGroupByOutputType = {
    id: number
    reserveUserId: number
    copyId: number
    fromUniversityId: number
    borrowDate: Date
    returnDate: Date
    actualReturnDate: Date
    createdAt: Date
    updatedAt: Date
    _count: BKBorrowingHistoryCountAggregateOutputType | null
    _avg: BKBorrowingHistoryAvgAggregateOutputType | null
    _sum: BKBorrowingHistorySumAggregateOutputType | null
    _min: BKBorrowingHistoryMinAggregateOutputType | null
    _max: BKBorrowingHistoryMaxAggregateOutputType | null
  }

  type GetBKBorrowingHistoryGroupByPayload<T extends BKBorrowingHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BKBorrowingHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BKBorrowingHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BKBorrowingHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], BKBorrowingHistoryGroupByOutputType[P]>
        }
      >
    >


  export type BKBorrowingHistorySelect = {
    id?: boolean
    user?: boolean | BKReserveUserArgs
    reserveUserId?: boolean
    copy?: boolean | BKCopyArgs
    copyId?: boolean
    from?: boolean | BKUniversityArgs
    fromUniversityId?: boolean
    borrowDate?: boolean
    returnDate?: boolean
    actualReturnDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type BKBorrowingHistoryInclude = {
    user?: boolean | BKReserveUserArgs
    copy?: boolean | BKCopyArgs
    from?: boolean | BKUniversityArgs
  }

  export type BKBorrowingHistoryGetPayload<S extends boolean | null | undefined | BKBorrowingHistoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BKBorrowingHistory :
    S extends undefined ? never :
    S extends { include: any } & (BKBorrowingHistoryArgs | BKBorrowingHistoryFindManyArgs)
    ? BKBorrowingHistory  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? BKReserveUserGetPayload<S['include'][P]> :
        P extends 'copy' ? BKCopyGetPayload<S['include'][P]> :
        P extends 'from' ? BKUniversityGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BKBorrowingHistoryArgs | BKBorrowingHistoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? BKReserveUserGetPayload<S['select'][P]> :
        P extends 'copy' ? BKCopyGetPayload<S['select'][P]> :
        P extends 'from' ? BKUniversityGetPayload<S['select'][P]> :  P extends keyof BKBorrowingHistory ? BKBorrowingHistory[P] : never
  } 
      : BKBorrowingHistory


  type BKBorrowingHistoryCountArgs = 
    Omit<BKBorrowingHistoryFindManyArgs, 'select' | 'include'> & {
      select?: BKBorrowingHistoryCountAggregateInputType | true
    }

  export interface BKBorrowingHistoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one BKBorrowingHistory that matches the filter.
     * @param {BKBorrowingHistoryFindUniqueArgs} args - Arguments to find a BKBorrowingHistory
     * @example
     * // Get one BKBorrowingHistory
     * const bKBorrowingHistory = await prisma.bKBorrowingHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BKBorrowingHistoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BKBorrowingHistoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BKBorrowingHistory'> extends True ? Prisma__BKBorrowingHistoryClient<BKBorrowingHistoryGetPayload<T>> : Prisma__BKBorrowingHistoryClient<BKBorrowingHistoryGetPayload<T> | null, null>

    /**
     * Find one BKBorrowingHistory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BKBorrowingHistoryFindUniqueOrThrowArgs} args - Arguments to find a BKBorrowingHistory
     * @example
     * // Get one BKBorrowingHistory
     * const bKBorrowingHistory = await prisma.bKBorrowingHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BKBorrowingHistoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BKBorrowingHistoryFindUniqueOrThrowArgs>
    ): Prisma__BKBorrowingHistoryClient<BKBorrowingHistoryGetPayload<T>>

    /**
     * Find the first BKBorrowingHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKBorrowingHistoryFindFirstArgs} args - Arguments to find a BKBorrowingHistory
     * @example
     * // Get one BKBorrowingHistory
     * const bKBorrowingHistory = await prisma.bKBorrowingHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BKBorrowingHistoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BKBorrowingHistoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BKBorrowingHistory'> extends True ? Prisma__BKBorrowingHistoryClient<BKBorrowingHistoryGetPayload<T>> : Prisma__BKBorrowingHistoryClient<BKBorrowingHistoryGetPayload<T> | null, null>

    /**
     * Find the first BKBorrowingHistory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKBorrowingHistoryFindFirstOrThrowArgs} args - Arguments to find a BKBorrowingHistory
     * @example
     * // Get one BKBorrowingHistory
     * const bKBorrowingHistory = await prisma.bKBorrowingHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BKBorrowingHistoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BKBorrowingHistoryFindFirstOrThrowArgs>
    ): Prisma__BKBorrowingHistoryClient<BKBorrowingHistoryGetPayload<T>>

    /**
     * Find zero or more BKBorrowingHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKBorrowingHistoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BKBorrowingHistories
     * const bKBorrowingHistories = await prisma.bKBorrowingHistory.findMany()
     * 
     * // Get first 10 BKBorrowingHistories
     * const bKBorrowingHistories = await prisma.bKBorrowingHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bKBorrowingHistoryWithIdOnly = await prisma.bKBorrowingHistory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BKBorrowingHistoryFindManyArgs>(
      args?: SelectSubset<T, BKBorrowingHistoryFindManyArgs>
    ): Prisma.PrismaPromise<Array<BKBorrowingHistoryGetPayload<T>>>

    /**
     * Create a BKBorrowingHistory.
     * @param {BKBorrowingHistoryCreateArgs} args - Arguments to create a BKBorrowingHistory.
     * @example
     * // Create one BKBorrowingHistory
     * const BKBorrowingHistory = await prisma.bKBorrowingHistory.create({
     *   data: {
     *     // ... data to create a BKBorrowingHistory
     *   }
     * })
     * 
    **/
    create<T extends BKBorrowingHistoryCreateArgs>(
      args: SelectSubset<T, BKBorrowingHistoryCreateArgs>
    ): Prisma__BKBorrowingHistoryClient<BKBorrowingHistoryGetPayload<T>>

    /**
     * Create many BKBorrowingHistories.
     *     @param {BKBorrowingHistoryCreateManyArgs} args - Arguments to create many BKBorrowingHistories.
     *     @example
     *     // Create many BKBorrowingHistories
     *     const bKBorrowingHistory = await prisma.bKBorrowingHistory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BKBorrowingHistoryCreateManyArgs>(
      args?: SelectSubset<T, BKBorrowingHistoryCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BKBorrowingHistory.
     * @param {BKBorrowingHistoryDeleteArgs} args - Arguments to delete one BKBorrowingHistory.
     * @example
     * // Delete one BKBorrowingHistory
     * const BKBorrowingHistory = await prisma.bKBorrowingHistory.delete({
     *   where: {
     *     // ... filter to delete one BKBorrowingHistory
     *   }
     * })
     * 
    **/
    delete<T extends BKBorrowingHistoryDeleteArgs>(
      args: SelectSubset<T, BKBorrowingHistoryDeleteArgs>
    ): Prisma__BKBorrowingHistoryClient<BKBorrowingHistoryGetPayload<T>>

    /**
     * Update one BKBorrowingHistory.
     * @param {BKBorrowingHistoryUpdateArgs} args - Arguments to update one BKBorrowingHistory.
     * @example
     * // Update one BKBorrowingHistory
     * const bKBorrowingHistory = await prisma.bKBorrowingHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BKBorrowingHistoryUpdateArgs>(
      args: SelectSubset<T, BKBorrowingHistoryUpdateArgs>
    ): Prisma__BKBorrowingHistoryClient<BKBorrowingHistoryGetPayload<T>>

    /**
     * Delete zero or more BKBorrowingHistories.
     * @param {BKBorrowingHistoryDeleteManyArgs} args - Arguments to filter BKBorrowingHistories to delete.
     * @example
     * // Delete a few BKBorrowingHistories
     * const { count } = await prisma.bKBorrowingHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BKBorrowingHistoryDeleteManyArgs>(
      args?: SelectSubset<T, BKBorrowingHistoryDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BKBorrowingHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKBorrowingHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BKBorrowingHistories
     * const bKBorrowingHistory = await prisma.bKBorrowingHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BKBorrowingHistoryUpdateManyArgs>(
      args: SelectSubset<T, BKBorrowingHistoryUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BKBorrowingHistory.
     * @param {BKBorrowingHistoryUpsertArgs} args - Arguments to update or create a BKBorrowingHistory.
     * @example
     * // Update or create a BKBorrowingHistory
     * const bKBorrowingHistory = await prisma.bKBorrowingHistory.upsert({
     *   create: {
     *     // ... data to create a BKBorrowingHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BKBorrowingHistory we want to update
     *   }
     * })
    **/
    upsert<T extends BKBorrowingHistoryUpsertArgs>(
      args: SelectSubset<T, BKBorrowingHistoryUpsertArgs>
    ): Prisma__BKBorrowingHistoryClient<BKBorrowingHistoryGetPayload<T>>

    /**
     * Count the number of BKBorrowingHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKBorrowingHistoryCountArgs} args - Arguments to filter BKBorrowingHistories to count.
     * @example
     * // Count the number of BKBorrowingHistories
     * const count = await prisma.bKBorrowingHistory.count({
     *   where: {
     *     // ... the filter for the BKBorrowingHistories we want to count
     *   }
     * })
    **/
    count<T extends BKBorrowingHistoryCountArgs>(
      args?: Subset<T, BKBorrowingHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BKBorrowingHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BKBorrowingHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKBorrowingHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BKBorrowingHistoryAggregateArgs>(args: Subset<T, BKBorrowingHistoryAggregateArgs>): Prisma.PrismaPromise<GetBKBorrowingHistoryAggregateType<T>>

    /**
     * Group by BKBorrowingHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKBorrowingHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BKBorrowingHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BKBorrowingHistoryGroupByArgs['orderBy'] }
        : { orderBy?: BKBorrowingHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BKBorrowingHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBKBorrowingHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BKBorrowingHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BKBorrowingHistoryClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends BKReserveUserArgs= {}>(args?: Subset<T, BKReserveUserArgs>): Prisma__BKReserveUserClient<BKReserveUserGetPayload<T> | Null>;

    copy<T extends BKCopyArgs= {}>(args?: Subset<T, BKCopyArgs>): Prisma__BKCopyClient<BKCopyGetPayload<T> | Null>;

    from<T extends BKUniversityArgs= {}>(args?: Subset<T, BKUniversityArgs>): Prisma__BKUniversityClient<BKUniversityGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BKBorrowingHistory base type for findUnique actions
   */
  export type BKBorrowingHistoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BKBorrowingHistory
     */
    select?: BKBorrowingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKBorrowingHistoryInclude | null
    /**
     * Filter, which BKBorrowingHistory to fetch.
     */
    where: BKBorrowingHistoryWhereUniqueInput
  }

  /**
   * BKBorrowingHistory findUnique
   */
  export interface BKBorrowingHistoryFindUniqueArgs extends BKBorrowingHistoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BKBorrowingHistory findUniqueOrThrow
   */
  export type BKBorrowingHistoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BKBorrowingHistory
     */
    select?: BKBorrowingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKBorrowingHistoryInclude | null
    /**
     * Filter, which BKBorrowingHistory to fetch.
     */
    where: BKBorrowingHistoryWhereUniqueInput
  }


  /**
   * BKBorrowingHistory base type for findFirst actions
   */
  export type BKBorrowingHistoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BKBorrowingHistory
     */
    select?: BKBorrowingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKBorrowingHistoryInclude | null
    /**
     * Filter, which BKBorrowingHistory to fetch.
     */
    where?: BKBorrowingHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BKBorrowingHistories to fetch.
     */
    orderBy?: Enumerable<BKBorrowingHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BKBorrowingHistories.
     */
    cursor?: BKBorrowingHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BKBorrowingHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BKBorrowingHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BKBorrowingHistories.
     */
    distinct?: Enumerable<BKBorrowingHistoryScalarFieldEnum>
  }

  /**
   * BKBorrowingHistory findFirst
   */
  export interface BKBorrowingHistoryFindFirstArgs extends BKBorrowingHistoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BKBorrowingHistory findFirstOrThrow
   */
  export type BKBorrowingHistoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BKBorrowingHistory
     */
    select?: BKBorrowingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKBorrowingHistoryInclude | null
    /**
     * Filter, which BKBorrowingHistory to fetch.
     */
    where?: BKBorrowingHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BKBorrowingHistories to fetch.
     */
    orderBy?: Enumerable<BKBorrowingHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BKBorrowingHistories.
     */
    cursor?: BKBorrowingHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BKBorrowingHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BKBorrowingHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BKBorrowingHistories.
     */
    distinct?: Enumerable<BKBorrowingHistoryScalarFieldEnum>
  }


  /**
   * BKBorrowingHistory findMany
   */
  export type BKBorrowingHistoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the BKBorrowingHistory
     */
    select?: BKBorrowingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKBorrowingHistoryInclude | null
    /**
     * Filter, which BKBorrowingHistories to fetch.
     */
    where?: BKBorrowingHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BKBorrowingHistories to fetch.
     */
    orderBy?: Enumerable<BKBorrowingHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BKBorrowingHistories.
     */
    cursor?: BKBorrowingHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BKBorrowingHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BKBorrowingHistories.
     */
    skip?: number
    distinct?: Enumerable<BKBorrowingHistoryScalarFieldEnum>
  }


  /**
   * BKBorrowingHistory create
   */
  export type BKBorrowingHistoryCreateArgs = {
    /**
     * Select specific fields to fetch from the BKBorrowingHistory
     */
    select?: BKBorrowingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKBorrowingHistoryInclude | null
    /**
     * The data needed to create a BKBorrowingHistory.
     */
    data: XOR<BKBorrowingHistoryCreateInput, BKBorrowingHistoryUncheckedCreateInput>
  }


  /**
   * BKBorrowingHistory createMany
   */
  export type BKBorrowingHistoryCreateManyArgs = {
    /**
     * The data used to create many BKBorrowingHistories.
     */
    data: Enumerable<BKBorrowingHistoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BKBorrowingHistory update
   */
  export type BKBorrowingHistoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the BKBorrowingHistory
     */
    select?: BKBorrowingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKBorrowingHistoryInclude | null
    /**
     * The data needed to update a BKBorrowingHistory.
     */
    data: XOR<BKBorrowingHistoryUpdateInput, BKBorrowingHistoryUncheckedUpdateInput>
    /**
     * Choose, which BKBorrowingHistory to update.
     */
    where: BKBorrowingHistoryWhereUniqueInput
  }


  /**
   * BKBorrowingHistory updateMany
   */
  export type BKBorrowingHistoryUpdateManyArgs = {
    /**
     * The data used to update BKBorrowingHistories.
     */
    data: XOR<BKBorrowingHistoryUpdateManyMutationInput, BKBorrowingHistoryUncheckedUpdateManyInput>
    /**
     * Filter which BKBorrowingHistories to update
     */
    where?: BKBorrowingHistoryWhereInput
  }


  /**
   * BKBorrowingHistory upsert
   */
  export type BKBorrowingHistoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the BKBorrowingHistory
     */
    select?: BKBorrowingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKBorrowingHistoryInclude | null
    /**
     * The filter to search for the BKBorrowingHistory to update in case it exists.
     */
    where: BKBorrowingHistoryWhereUniqueInput
    /**
     * In case the BKBorrowingHistory found by the `where` argument doesn't exist, create a new BKBorrowingHistory with this data.
     */
    create: XOR<BKBorrowingHistoryCreateInput, BKBorrowingHistoryUncheckedCreateInput>
    /**
     * In case the BKBorrowingHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BKBorrowingHistoryUpdateInput, BKBorrowingHistoryUncheckedUpdateInput>
  }


  /**
   * BKBorrowingHistory delete
   */
  export type BKBorrowingHistoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the BKBorrowingHistory
     */
    select?: BKBorrowingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKBorrowingHistoryInclude | null
    /**
     * Filter which BKBorrowingHistory to delete.
     */
    where: BKBorrowingHistoryWhereUniqueInput
  }


  /**
   * BKBorrowingHistory deleteMany
   */
  export type BKBorrowingHistoryDeleteManyArgs = {
    /**
     * Filter which BKBorrowingHistories to delete
     */
    where?: BKBorrowingHistoryWhereInput
  }


  /**
   * BKBorrowingHistory without action
   */
  export type BKBorrowingHistoryArgs = {
    /**
     * Select specific fields to fetch from the BKBorrowingHistory
     */
    select?: BKBorrowingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKBorrowingHistoryInclude | null
  }



  /**
   * Model BKCopy
   */


  export type AggregateBKCopy = {
    _count: BKCopyCountAggregateOutputType | null
    _avg: BKCopyAvgAggregateOutputType | null
    _sum: BKCopySumAggregateOutputType | null
    _min: BKCopyMinAggregateOutputType | null
    _max: BKCopyMaxAggregateOutputType | null
  }

  export type BKCopyAvgAggregateOutputType = {
    id: number | null
    titleId: number | null
    reserveUserId: number | null
  }

  export type BKCopySumAggregateOutputType = {
    id: number | null
    titleId: number | null
    reserveUserId: number | null
  }

  export type BKCopyMinAggregateOutputType = {
    id: number | null
    status: CopyStatusEnum | null
    titleId: number | null
    reserveUserId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BKCopyMaxAggregateOutputType = {
    id: number | null
    status: CopyStatusEnum | null
    titleId: number | null
    reserveUserId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BKCopyCountAggregateOutputType = {
    id: number
    status: number
    titleId: number
    reserveUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BKCopyAvgAggregateInputType = {
    id?: true
    titleId?: true
    reserveUserId?: true
  }

  export type BKCopySumAggregateInputType = {
    id?: true
    titleId?: true
    reserveUserId?: true
  }

  export type BKCopyMinAggregateInputType = {
    id?: true
    status?: true
    titleId?: true
    reserveUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BKCopyMaxAggregateInputType = {
    id?: true
    status?: true
    titleId?: true
    reserveUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BKCopyCountAggregateInputType = {
    id?: true
    status?: true
    titleId?: true
    reserveUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BKCopyAggregateArgs = {
    /**
     * Filter which BKCopy to aggregate.
     */
    where?: BKCopyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BKCopies to fetch.
     */
    orderBy?: Enumerable<BKCopyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BKCopyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BKCopies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BKCopies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BKCopies
    **/
    _count?: true | BKCopyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BKCopyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BKCopySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BKCopyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BKCopyMaxAggregateInputType
  }

  export type GetBKCopyAggregateType<T extends BKCopyAggregateArgs> = {
        [P in keyof T & keyof AggregateBKCopy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBKCopy[P]>
      : GetScalarType<T[P], AggregateBKCopy[P]>
  }




  export type BKCopyGroupByArgs = {
    where?: BKCopyWhereInput
    orderBy?: Enumerable<BKCopyOrderByWithAggregationInput>
    by: BKCopyScalarFieldEnum[]
    having?: BKCopyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BKCopyCountAggregateInputType | true
    _avg?: BKCopyAvgAggregateInputType
    _sum?: BKCopySumAggregateInputType
    _min?: BKCopyMinAggregateInputType
    _max?: BKCopyMaxAggregateInputType
  }


  export type BKCopyGroupByOutputType = {
    id: number
    status: CopyStatusEnum
    titleId: number
    reserveUserId: number | null
    createdAt: Date
    updatedAt: Date
    _count: BKCopyCountAggregateOutputType | null
    _avg: BKCopyAvgAggregateOutputType | null
    _sum: BKCopySumAggregateOutputType | null
    _min: BKCopyMinAggregateOutputType | null
    _max: BKCopyMaxAggregateOutputType | null
  }

  type GetBKCopyGroupByPayload<T extends BKCopyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BKCopyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BKCopyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BKCopyGroupByOutputType[P]>
            : GetScalarType<T[P], BKCopyGroupByOutputType[P]>
        }
      >
    >


  export type BKCopySelect = {
    id?: boolean
    status?: boolean
    title?: boolean | BKTitleArgs
    titleId?: boolean
    user?: boolean | BKReserveUserArgs
    reserveUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    requests?: boolean | BKCopy$requestsArgs
    BKBorrowingHistory?: boolean | BKCopy$BKBorrowingHistoryArgs
    _count?: boolean | BKCopyCountOutputTypeArgs
  }


  export type BKCopyInclude = {
    title?: boolean | BKTitleArgs
    user?: boolean | BKReserveUserArgs
    requests?: boolean | BKCopy$requestsArgs
    BKBorrowingHistory?: boolean | BKCopy$BKBorrowingHistoryArgs
    _count?: boolean | BKCopyCountOutputTypeArgs
  }

  export type BKCopyGetPayload<S extends boolean | null | undefined | BKCopyArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BKCopy :
    S extends undefined ? never :
    S extends { include: any } & (BKCopyArgs | BKCopyFindManyArgs)
    ? BKCopy  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'title' ? BKTitleGetPayload<S['include'][P]> :
        P extends 'user' ? BKReserveUserGetPayload<S['include'][P]> | null :
        P extends 'requests' ? Array < BKRequestGetPayload<S['include'][P]>>  :
        P extends 'BKBorrowingHistory' ? Array < BKBorrowingHistoryGetPayload<S['include'][P]>>  :
        P extends '_count' ? BKCopyCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BKCopyArgs | BKCopyFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'title' ? BKTitleGetPayload<S['select'][P]> :
        P extends 'user' ? BKReserveUserGetPayload<S['select'][P]> | null :
        P extends 'requests' ? Array < BKRequestGetPayload<S['select'][P]>>  :
        P extends 'BKBorrowingHistory' ? Array < BKBorrowingHistoryGetPayload<S['select'][P]>>  :
        P extends '_count' ? BKCopyCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof BKCopy ? BKCopy[P] : never
  } 
      : BKCopy


  type BKCopyCountArgs = 
    Omit<BKCopyFindManyArgs, 'select' | 'include'> & {
      select?: BKCopyCountAggregateInputType | true
    }

  export interface BKCopyDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one BKCopy that matches the filter.
     * @param {BKCopyFindUniqueArgs} args - Arguments to find a BKCopy
     * @example
     * // Get one BKCopy
     * const bKCopy = await prisma.bKCopy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BKCopyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BKCopyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BKCopy'> extends True ? Prisma__BKCopyClient<BKCopyGetPayload<T>> : Prisma__BKCopyClient<BKCopyGetPayload<T> | null, null>

    /**
     * Find one BKCopy that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BKCopyFindUniqueOrThrowArgs} args - Arguments to find a BKCopy
     * @example
     * // Get one BKCopy
     * const bKCopy = await prisma.bKCopy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BKCopyFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BKCopyFindUniqueOrThrowArgs>
    ): Prisma__BKCopyClient<BKCopyGetPayload<T>>

    /**
     * Find the first BKCopy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKCopyFindFirstArgs} args - Arguments to find a BKCopy
     * @example
     * // Get one BKCopy
     * const bKCopy = await prisma.bKCopy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BKCopyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BKCopyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BKCopy'> extends True ? Prisma__BKCopyClient<BKCopyGetPayload<T>> : Prisma__BKCopyClient<BKCopyGetPayload<T> | null, null>

    /**
     * Find the first BKCopy that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKCopyFindFirstOrThrowArgs} args - Arguments to find a BKCopy
     * @example
     * // Get one BKCopy
     * const bKCopy = await prisma.bKCopy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BKCopyFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BKCopyFindFirstOrThrowArgs>
    ): Prisma__BKCopyClient<BKCopyGetPayload<T>>

    /**
     * Find zero or more BKCopies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKCopyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BKCopies
     * const bKCopies = await prisma.bKCopy.findMany()
     * 
     * // Get first 10 BKCopies
     * const bKCopies = await prisma.bKCopy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bKCopyWithIdOnly = await prisma.bKCopy.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BKCopyFindManyArgs>(
      args?: SelectSubset<T, BKCopyFindManyArgs>
    ): Prisma.PrismaPromise<Array<BKCopyGetPayload<T>>>

    /**
     * Create a BKCopy.
     * @param {BKCopyCreateArgs} args - Arguments to create a BKCopy.
     * @example
     * // Create one BKCopy
     * const BKCopy = await prisma.bKCopy.create({
     *   data: {
     *     // ... data to create a BKCopy
     *   }
     * })
     * 
    **/
    create<T extends BKCopyCreateArgs>(
      args: SelectSubset<T, BKCopyCreateArgs>
    ): Prisma__BKCopyClient<BKCopyGetPayload<T>>

    /**
     * Create many BKCopies.
     *     @param {BKCopyCreateManyArgs} args - Arguments to create many BKCopies.
     *     @example
     *     // Create many BKCopies
     *     const bKCopy = await prisma.bKCopy.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BKCopyCreateManyArgs>(
      args?: SelectSubset<T, BKCopyCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BKCopy.
     * @param {BKCopyDeleteArgs} args - Arguments to delete one BKCopy.
     * @example
     * // Delete one BKCopy
     * const BKCopy = await prisma.bKCopy.delete({
     *   where: {
     *     // ... filter to delete one BKCopy
     *   }
     * })
     * 
    **/
    delete<T extends BKCopyDeleteArgs>(
      args: SelectSubset<T, BKCopyDeleteArgs>
    ): Prisma__BKCopyClient<BKCopyGetPayload<T>>

    /**
     * Update one BKCopy.
     * @param {BKCopyUpdateArgs} args - Arguments to update one BKCopy.
     * @example
     * // Update one BKCopy
     * const bKCopy = await prisma.bKCopy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BKCopyUpdateArgs>(
      args: SelectSubset<T, BKCopyUpdateArgs>
    ): Prisma__BKCopyClient<BKCopyGetPayload<T>>

    /**
     * Delete zero or more BKCopies.
     * @param {BKCopyDeleteManyArgs} args - Arguments to filter BKCopies to delete.
     * @example
     * // Delete a few BKCopies
     * const { count } = await prisma.bKCopy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BKCopyDeleteManyArgs>(
      args?: SelectSubset<T, BKCopyDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BKCopies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKCopyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BKCopies
     * const bKCopy = await prisma.bKCopy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BKCopyUpdateManyArgs>(
      args: SelectSubset<T, BKCopyUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BKCopy.
     * @param {BKCopyUpsertArgs} args - Arguments to update or create a BKCopy.
     * @example
     * // Update or create a BKCopy
     * const bKCopy = await prisma.bKCopy.upsert({
     *   create: {
     *     // ... data to create a BKCopy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BKCopy we want to update
     *   }
     * })
    **/
    upsert<T extends BKCopyUpsertArgs>(
      args: SelectSubset<T, BKCopyUpsertArgs>
    ): Prisma__BKCopyClient<BKCopyGetPayload<T>>

    /**
     * Count the number of BKCopies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKCopyCountArgs} args - Arguments to filter BKCopies to count.
     * @example
     * // Count the number of BKCopies
     * const count = await prisma.bKCopy.count({
     *   where: {
     *     // ... the filter for the BKCopies we want to count
     *   }
     * })
    **/
    count<T extends BKCopyCountArgs>(
      args?: Subset<T, BKCopyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BKCopyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BKCopy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKCopyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BKCopyAggregateArgs>(args: Subset<T, BKCopyAggregateArgs>): Prisma.PrismaPromise<GetBKCopyAggregateType<T>>

    /**
     * Group by BKCopy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKCopyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BKCopyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BKCopyGroupByArgs['orderBy'] }
        : { orderBy?: BKCopyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BKCopyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBKCopyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BKCopy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BKCopyClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    title<T extends BKTitleArgs= {}>(args?: Subset<T, BKTitleArgs>): Prisma__BKTitleClient<BKTitleGetPayload<T> | Null>;

    user<T extends BKReserveUserArgs= {}>(args?: Subset<T, BKReserveUserArgs>): Prisma__BKReserveUserClient<BKReserveUserGetPayload<T> | Null>;

    requests<T extends BKCopy$requestsArgs= {}>(args?: Subset<T, BKCopy$requestsArgs>): Prisma.PrismaPromise<Array<BKRequestGetPayload<T>>| Null>;

    BKBorrowingHistory<T extends BKCopy$BKBorrowingHistoryArgs= {}>(args?: Subset<T, BKCopy$BKBorrowingHistoryArgs>): Prisma.PrismaPromise<Array<BKBorrowingHistoryGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BKCopy base type for findUnique actions
   */
  export type BKCopyFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BKCopy
     */
    select?: BKCopySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKCopyInclude | null
    /**
     * Filter, which BKCopy to fetch.
     */
    where: BKCopyWhereUniqueInput
  }

  /**
   * BKCopy findUnique
   */
  export interface BKCopyFindUniqueArgs extends BKCopyFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BKCopy findUniqueOrThrow
   */
  export type BKCopyFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BKCopy
     */
    select?: BKCopySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKCopyInclude | null
    /**
     * Filter, which BKCopy to fetch.
     */
    where: BKCopyWhereUniqueInput
  }


  /**
   * BKCopy base type for findFirst actions
   */
  export type BKCopyFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BKCopy
     */
    select?: BKCopySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKCopyInclude | null
    /**
     * Filter, which BKCopy to fetch.
     */
    where?: BKCopyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BKCopies to fetch.
     */
    orderBy?: Enumerable<BKCopyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BKCopies.
     */
    cursor?: BKCopyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BKCopies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BKCopies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BKCopies.
     */
    distinct?: Enumerable<BKCopyScalarFieldEnum>
  }

  /**
   * BKCopy findFirst
   */
  export interface BKCopyFindFirstArgs extends BKCopyFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BKCopy findFirstOrThrow
   */
  export type BKCopyFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BKCopy
     */
    select?: BKCopySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKCopyInclude | null
    /**
     * Filter, which BKCopy to fetch.
     */
    where?: BKCopyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BKCopies to fetch.
     */
    orderBy?: Enumerable<BKCopyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BKCopies.
     */
    cursor?: BKCopyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BKCopies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BKCopies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BKCopies.
     */
    distinct?: Enumerable<BKCopyScalarFieldEnum>
  }


  /**
   * BKCopy findMany
   */
  export type BKCopyFindManyArgs = {
    /**
     * Select specific fields to fetch from the BKCopy
     */
    select?: BKCopySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKCopyInclude | null
    /**
     * Filter, which BKCopies to fetch.
     */
    where?: BKCopyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BKCopies to fetch.
     */
    orderBy?: Enumerable<BKCopyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BKCopies.
     */
    cursor?: BKCopyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BKCopies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BKCopies.
     */
    skip?: number
    distinct?: Enumerable<BKCopyScalarFieldEnum>
  }


  /**
   * BKCopy create
   */
  export type BKCopyCreateArgs = {
    /**
     * Select specific fields to fetch from the BKCopy
     */
    select?: BKCopySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKCopyInclude | null
    /**
     * The data needed to create a BKCopy.
     */
    data: XOR<BKCopyCreateInput, BKCopyUncheckedCreateInput>
  }


  /**
   * BKCopy createMany
   */
  export type BKCopyCreateManyArgs = {
    /**
     * The data used to create many BKCopies.
     */
    data: Enumerable<BKCopyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BKCopy update
   */
  export type BKCopyUpdateArgs = {
    /**
     * Select specific fields to fetch from the BKCopy
     */
    select?: BKCopySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKCopyInclude | null
    /**
     * The data needed to update a BKCopy.
     */
    data: XOR<BKCopyUpdateInput, BKCopyUncheckedUpdateInput>
    /**
     * Choose, which BKCopy to update.
     */
    where: BKCopyWhereUniqueInput
  }


  /**
   * BKCopy updateMany
   */
  export type BKCopyUpdateManyArgs = {
    /**
     * The data used to update BKCopies.
     */
    data: XOR<BKCopyUpdateManyMutationInput, BKCopyUncheckedUpdateManyInput>
    /**
     * Filter which BKCopies to update
     */
    where?: BKCopyWhereInput
  }


  /**
   * BKCopy upsert
   */
  export type BKCopyUpsertArgs = {
    /**
     * Select specific fields to fetch from the BKCopy
     */
    select?: BKCopySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKCopyInclude | null
    /**
     * The filter to search for the BKCopy to update in case it exists.
     */
    where: BKCopyWhereUniqueInput
    /**
     * In case the BKCopy found by the `where` argument doesn't exist, create a new BKCopy with this data.
     */
    create: XOR<BKCopyCreateInput, BKCopyUncheckedCreateInput>
    /**
     * In case the BKCopy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BKCopyUpdateInput, BKCopyUncheckedUpdateInput>
  }


  /**
   * BKCopy delete
   */
  export type BKCopyDeleteArgs = {
    /**
     * Select specific fields to fetch from the BKCopy
     */
    select?: BKCopySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKCopyInclude | null
    /**
     * Filter which BKCopy to delete.
     */
    where: BKCopyWhereUniqueInput
  }


  /**
   * BKCopy deleteMany
   */
  export type BKCopyDeleteManyArgs = {
    /**
     * Filter which BKCopies to delete
     */
    where?: BKCopyWhereInput
  }


  /**
   * BKCopy.requests
   */
  export type BKCopy$requestsArgs = {
    /**
     * Select specific fields to fetch from the BKRequest
     */
    select?: BKRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKRequestInclude | null
    where?: BKRequestWhereInput
    orderBy?: Enumerable<BKRequestOrderByWithRelationInput>
    cursor?: BKRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BKRequestScalarFieldEnum>
  }


  /**
   * BKCopy.BKBorrowingHistory
   */
  export type BKCopy$BKBorrowingHistoryArgs = {
    /**
     * Select specific fields to fetch from the BKBorrowingHistory
     */
    select?: BKBorrowingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKBorrowingHistoryInclude | null
    where?: BKBorrowingHistoryWhereInput
    orderBy?: Enumerable<BKBorrowingHistoryOrderByWithRelationInput>
    cursor?: BKBorrowingHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BKBorrowingHistoryScalarFieldEnum>
  }


  /**
   * BKCopy without action
   */
  export type BKCopyArgs = {
    /**
     * Select specific fields to fetch from the BKCopy
     */
    select?: BKCopySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKCopyInclude | null
  }



  /**
   * Model BKUniversity
   */


  export type AggregateBKUniversity = {
    _count: BKUniversityCountAggregateOutputType | null
    _avg: BKUniversityAvgAggregateOutputType | null
    _sum: BKUniversitySumAggregateOutputType | null
    _min: BKUniversityMinAggregateOutputType | null
    _max: BKUniversityMaxAggregateOutputType | null
  }

  export type BKUniversityAvgAggregateOutputType = {
    id: number | null
  }

  export type BKUniversitySumAggregateOutputType = {
    id: number | null
  }

  export type BKUniversityMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BKUniversityMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BKUniversityCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BKUniversityAvgAggregateInputType = {
    id?: true
  }

  export type BKUniversitySumAggregateInputType = {
    id?: true
  }

  export type BKUniversityMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BKUniversityMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BKUniversityCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BKUniversityAggregateArgs = {
    /**
     * Filter which BKUniversity to aggregate.
     */
    where?: BKUniversityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BKUniversities to fetch.
     */
    orderBy?: Enumerable<BKUniversityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BKUniversityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BKUniversities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BKUniversities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BKUniversities
    **/
    _count?: true | BKUniversityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BKUniversityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BKUniversitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BKUniversityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BKUniversityMaxAggregateInputType
  }

  export type GetBKUniversityAggregateType<T extends BKUniversityAggregateArgs> = {
        [P in keyof T & keyof AggregateBKUniversity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBKUniversity[P]>
      : GetScalarType<T[P], AggregateBKUniversity[P]>
  }




  export type BKUniversityGroupByArgs = {
    where?: BKUniversityWhereInput
    orderBy?: Enumerable<BKUniversityOrderByWithAggregationInput>
    by: BKUniversityScalarFieldEnum[]
    having?: BKUniversityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BKUniversityCountAggregateInputType | true
    _avg?: BKUniversityAvgAggregateInputType
    _sum?: BKUniversitySumAggregateInputType
    _min?: BKUniversityMinAggregateInputType
    _max?: BKUniversityMaxAggregateInputType
  }


  export type BKUniversityGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: BKUniversityCountAggregateOutputType | null
    _avg: BKUniversityAvgAggregateOutputType | null
    _sum: BKUniversitySumAggregateOutputType | null
    _min: BKUniversityMinAggregateOutputType | null
    _max: BKUniversityMaxAggregateOutputType | null
  }

  type GetBKUniversityGroupByPayload<T extends BKUniversityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BKUniversityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BKUniversityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BKUniversityGroupByOutputType[P]>
            : GetScalarType<T[P], BKUniversityGroupByOutputType[P]>
        }
      >
    >


  export type BKUniversitySelect = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    universityToTitles?: boolean | BKUniversity$universityToTitlesArgs
    reserveUsers?: boolean | BKUniversity$reserveUsersArgs
    fromRequest?: boolean | BKUniversity$fromRequestArgs
    toRequest?: boolean | BKUniversity$toRequestArgs
    BKBorrowingHistory?: boolean | BKUniversity$BKBorrowingHistoryArgs
    _count?: boolean | BKUniversityCountOutputTypeArgs
  }


  export type BKUniversityInclude = {
    universityToTitles?: boolean | BKUniversity$universityToTitlesArgs
    reserveUsers?: boolean | BKUniversity$reserveUsersArgs
    fromRequest?: boolean | BKUniversity$fromRequestArgs
    toRequest?: boolean | BKUniversity$toRequestArgs
    BKBorrowingHistory?: boolean | BKUniversity$BKBorrowingHistoryArgs
    _count?: boolean | BKUniversityCountOutputTypeArgs
  }

  export type BKUniversityGetPayload<S extends boolean | null | undefined | BKUniversityArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BKUniversity :
    S extends undefined ? never :
    S extends { include: any } & (BKUniversityArgs | BKUniversityFindManyArgs)
    ? BKUniversity  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'universityToTitles' ? Array < UniversityToTitleGetPayload<S['include'][P]>>  :
        P extends 'reserveUsers' ? Array < BKReserveUserGetPayload<S['include'][P]>>  :
        P extends 'fromRequest' ? Array < BKRequestGetPayload<S['include'][P]>>  :
        P extends 'toRequest' ? Array < BKRequestGetPayload<S['include'][P]>>  :
        P extends 'BKBorrowingHistory' ? Array < BKBorrowingHistoryGetPayload<S['include'][P]>>  :
        P extends '_count' ? BKUniversityCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BKUniversityArgs | BKUniversityFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'universityToTitles' ? Array < UniversityToTitleGetPayload<S['select'][P]>>  :
        P extends 'reserveUsers' ? Array < BKReserveUserGetPayload<S['select'][P]>>  :
        P extends 'fromRequest' ? Array < BKRequestGetPayload<S['select'][P]>>  :
        P extends 'toRequest' ? Array < BKRequestGetPayload<S['select'][P]>>  :
        P extends 'BKBorrowingHistory' ? Array < BKBorrowingHistoryGetPayload<S['select'][P]>>  :
        P extends '_count' ? BKUniversityCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof BKUniversity ? BKUniversity[P] : never
  } 
      : BKUniversity


  type BKUniversityCountArgs = 
    Omit<BKUniversityFindManyArgs, 'select' | 'include'> & {
      select?: BKUniversityCountAggregateInputType | true
    }

  export interface BKUniversityDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one BKUniversity that matches the filter.
     * @param {BKUniversityFindUniqueArgs} args - Arguments to find a BKUniversity
     * @example
     * // Get one BKUniversity
     * const bKUniversity = await prisma.bKUniversity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BKUniversityFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BKUniversityFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BKUniversity'> extends True ? Prisma__BKUniversityClient<BKUniversityGetPayload<T>> : Prisma__BKUniversityClient<BKUniversityGetPayload<T> | null, null>

    /**
     * Find one BKUniversity that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BKUniversityFindUniqueOrThrowArgs} args - Arguments to find a BKUniversity
     * @example
     * // Get one BKUniversity
     * const bKUniversity = await prisma.bKUniversity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BKUniversityFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BKUniversityFindUniqueOrThrowArgs>
    ): Prisma__BKUniversityClient<BKUniversityGetPayload<T>>

    /**
     * Find the first BKUniversity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKUniversityFindFirstArgs} args - Arguments to find a BKUniversity
     * @example
     * // Get one BKUniversity
     * const bKUniversity = await prisma.bKUniversity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BKUniversityFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BKUniversityFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BKUniversity'> extends True ? Prisma__BKUniversityClient<BKUniversityGetPayload<T>> : Prisma__BKUniversityClient<BKUniversityGetPayload<T> | null, null>

    /**
     * Find the first BKUniversity that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKUniversityFindFirstOrThrowArgs} args - Arguments to find a BKUniversity
     * @example
     * // Get one BKUniversity
     * const bKUniversity = await prisma.bKUniversity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BKUniversityFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BKUniversityFindFirstOrThrowArgs>
    ): Prisma__BKUniversityClient<BKUniversityGetPayload<T>>

    /**
     * Find zero or more BKUniversities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKUniversityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BKUniversities
     * const bKUniversities = await prisma.bKUniversity.findMany()
     * 
     * // Get first 10 BKUniversities
     * const bKUniversities = await prisma.bKUniversity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bKUniversityWithIdOnly = await prisma.bKUniversity.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BKUniversityFindManyArgs>(
      args?: SelectSubset<T, BKUniversityFindManyArgs>
    ): Prisma.PrismaPromise<Array<BKUniversityGetPayload<T>>>

    /**
     * Create a BKUniversity.
     * @param {BKUniversityCreateArgs} args - Arguments to create a BKUniversity.
     * @example
     * // Create one BKUniversity
     * const BKUniversity = await prisma.bKUniversity.create({
     *   data: {
     *     // ... data to create a BKUniversity
     *   }
     * })
     * 
    **/
    create<T extends BKUniversityCreateArgs>(
      args: SelectSubset<T, BKUniversityCreateArgs>
    ): Prisma__BKUniversityClient<BKUniversityGetPayload<T>>

    /**
     * Create many BKUniversities.
     *     @param {BKUniversityCreateManyArgs} args - Arguments to create many BKUniversities.
     *     @example
     *     // Create many BKUniversities
     *     const bKUniversity = await prisma.bKUniversity.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BKUniversityCreateManyArgs>(
      args?: SelectSubset<T, BKUniversityCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BKUniversity.
     * @param {BKUniversityDeleteArgs} args - Arguments to delete one BKUniversity.
     * @example
     * // Delete one BKUniversity
     * const BKUniversity = await prisma.bKUniversity.delete({
     *   where: {
     *     // ... filter to delete one BKUniversity
     *   }
     * })
     * 
    **/
    delete<T extends BKUniversityDeleteArgs>(
      args: SelectSubset<T, BKUniversityDeleteArgs>
    ): Prisma__BKUniversityClient<BKUniversityGetPayload<T>>

    /**
     * Update one BKUniversity.
     * @param {BKUniversityUpdateArgs} args - Arguments to update one BKUniversity.
     * @example
     * // Update one BKUniversity
     * const bKUniversity = await prisma.bKUniversity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BKUniversityUpdateArgs>(
      args: SelectSubset<T, BKUniversityUpdateArgs>
    ): Prisma__BKUniversityClient<BKUniversityGetPayload<T>>

    /**
     * Delete zero or more BKUniversities.
     * @param {BKUniversityDeleteManyArgs} args - Arguments to filter BKUniversities to delete.
     * @example
     * // Delete a few BKUniversities
     * const { count } = await prisma.bKUniversity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BKUniversityDeleteManyArgs>(
      args?: SelectSubset<T, BKUniversityDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BKUniversities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKUniversityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BKUniversities
     * const bKUniversity = await prisma.bKUniversity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BKUniversityUpdateManyArgs>(
      args: SelectSubset<T, BKUniversityUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BKUniversity.
     * @param {BKUniversityUpsertArgs} args - Arguments to update or create a BKUniversity.
     * @example
     * // Update or create a BKUniversity
     * const bKUniversity = await prisma.bKUniversity.upsert({
     *   create: {
     *     // ... data to create a BKUniversity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BKUniversity we want to update
     *   }
     * })
    **/
    upsert<T extends BKUniversityUpsertArgs>(
      args: SelectSubset<T, BKUniversityUpsertArgs>
    ): Prisma__BKUniversityClient<BKUniversityGetPayload<T>>

    /**
     * Count the number of BKUniversities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKUniversityCountArgs} args - Arguments to filter BKUniversities to count.
     * @example
     * // Count the number of BKUniversities
     * const count = await prisma.bKUniversity.count({
     *   where: {
     *     // ... the filter for the BKUniversities we want to count
     *   }
     * })
    **/
    count<T extends BKUniversityCountArgs>(
      args?: Subset<T, BKUniversityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BKUniversityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BKUniversity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKUniversityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BKUniversityAggregateArgs>(args: Subset<T, BKUniversityAggregateArgs>): Prisma.PrismaPromise<GetBKUniversityAggregateType<T>>

    /**
     * Group by BKUniversity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKUniversityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BKUniversityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BKUniversityGroupByArgs['orderBy'] }
        : { orderBy?: BKUniversityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BKUniversityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBKUniversityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BKUniversity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BKUniversityClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    universityToTitles<T extends BKUniversity$universityToTitlesArgs= {}>(args?: Subset<T, BKUniversity$universityToTitlesArgs>): Prisma.PrismaPromise<Array<UniversityToTitleGetPayload<T>>| Null>;

    reserveUsers<T extends BKUniversity$reserveUsersArgs= {}>(args?: Subset<T, BKUniversity$reserveUsersArgs>): Prisma.PrismaPromise<Array<BKReserveUserGetPayload<T>>| Null>;

    fromRequest<T extends BKUniversity$fromRequestArgs= {}>(args?: Subset<T, BKUniversity$fromRequestArgs>): Prisma.PrismaPromise<Array<BKRequestGetPayload<T>>| Null>;

    toRequest<T extends BKUniversity$toRequestArgs= {}>(args?: Subset<T, BKUniversity$toRequestArgs>): Prisma.PrismaPromise<Array<BKRequestGetPayload<T>>| Null>;

    BKBorrowingHistory<T extends BKUniversity$BKBorrowingHistoryArgs= {}>(args?: Subset<T, BKUniversity$BKBorrowingHistoryArgs>): Prisma.PrismaPromise<Array<BKBorrowingHistoryGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BKUniversity base type for findUnique actions
   */
  export type BKUniversityFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BKUniversity
     */
    select?: BKUniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKUniversityInclude | null
    /**
     * Filter, which BKUniversity to fetch.
     */
    where: BKUniversityWhereUniqueInput
  }

  /**
   * BKUniversity findUnique
   */
  export interface BKUniversityFindUniqueArgs extends BKUniversityFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BKUniversity findUniqueOrThrow
   */
  export type BKUniversityFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BKUniversity
     */
    select?: BKUniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKUniversityInclude | null
    /**
     * Filter, which BKUniversity to fetch.
     */
    where: BKUniversityWhereUniqueInput
  }


  /**
   * BKUniversity base type for findFirst actions
   */
  export type BKUniversityFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BKUniversity
     */
    select?: BKUniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKUniversityInclude | null
    /**
     * Filter, which BKUniversity to fetch.
     */
    where?: BKUniversityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BKUniversities to fetch.
     */
    orderBy?: Enumerable<BKUniversityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BKUniversities.
     */
    cursor?: BKUniversityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BKUniversities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BKUniversities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BKUniversities.
     */
    distinct?: Enumerable<BKUniversityScalarFieldEnum>
  }

  /**
   * BKUniversity findFirst
   */
  export interface BKUniversityFindFirstArgs extends BKUniversityFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BKUniversity findFirstOrThrow
   */
  export type BKUniversityFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BKUniversity
     */
    select?: BKUniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKUniversityInclude | null
    /**
     * Filter, which BKUniversity to fetch.
     */
    where?: BKUniversityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BKUniversities to fetch.
     */
    orderBy?: Enumerable<BKUniversityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BKUniversities.
     */
    cursor?: BKUniversityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BKUniversities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BKUniversities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BKUniversities.
     */
    distinct?: Enumerable<BKUniversityScalarFieldEnum>
  }


  /**
   * BKUniversity findMany
   */
  export type BKUniversityFindManyArgs = {
    /**
     * Select specific fields to fetch from the BKUniversity
     */
    select?: BKUniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKUniversityInclude | null
    /**
     * Filter, which BKUniversities to fetch.
     */
    where?: BKUniversityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BKUniversities to fetch.
     */
    orderBy?: Enumerable<BKUniversityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BKUniversities.
     */
    cursor?: BKUniversityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BKUniversities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BKUniversities.
     */
    skip?: number
    distinct?: Enumerable<BKUniversityScalarFieldEnum>
  }


  /**
   * BKUniversity create
   */
  export type BKUniversityCreateArgs = {
    /**
     * Select specific fields to fetch from the BKUniversity
     */
    select?: BKUniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKUniversityInclude | null
    /**
     * The data needed to create a BKUniversity.
     */
    data: XOR<BKUniversityCreateInput, BKUniversityUncheckedCreateInput>
  }


  /**
   * BKUniversity createMany
   */
  export type BKUniversityCreateManyArgs = {
    /**
     * The data used to create many BKUniversities.
     */
    data: Enumerable<BKUniversityCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BKUniversity update
   */
  export type BKUniversityUpdateArgs = {
    /**
     * Select specific fields to fetch from the BKUniversity
     */
    select?: BKUniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKUniversityInclude | null
    /**
     * The data needed to update a BKUniversity.
     */
    data: XOR<BKUniversityUpdateInput, BKUniversityUncheckedUpdateInput>
    /**
     * Choose, which BKUniversity to update.
     */
    where: BKUniversityWhereUniqueInput
  }


  /**
   * BKUniversity updateMany
   */
  export type BKUniversityUpdateManyArgs = {
    /**
     * The data used to update BKUniversities.
     */
    data: XOR<BKUniversityUpdateManyMutationInput, BKUniversityUncheckedUpdateManyInput>
    /**
     * Filter which BKUniversities to update
     */
    where?: BKUniversityWhereInput
  }


  /**
   * BKUniversity upsert
   */
  export type BKUniversityUpsertArgs = {
    /**
     * Select specific fields to fetch from the BKUniversity
     */
    select?: BKUniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKUniversityInclude | null
    /**
     * The filter to search for the BKUniversity to update in case it exists.
     */
    where: BKUniversityWhereUniqueInput
    /**
     * In case the BKUniversity found by the `where` argument doesn't exist, create a new BKUniversity with this data.
     */
    create: XOR<BKUniversityCreateInput, BKUniversityUncheckedCreateInput>
    /**
     * In case the BKUniversity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BKUniversityUpdateInput, BKUniversityUncheckedUpdateInput>
  }


  /**
   * BKUniversity delete
   */
  export type BKUniversityDeleteArgs = {
    /**
     * Select specific fields to fetch from the BKUniversity
     */
    select?: BKUniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKUniversityInclude | null
    /**
     * Filter which BKUniversity to delete.
     */
    where: BKUniversityWhereUniqueInput
  }


  /**
   * BKUniversity deleteMany
   */
  export type BKUniversityDeleteManyArgs = {
    /**
     * Filter which BKUniversities to delete
     */
    where?: BKUniversityWhereInput
  }


  /**
   * BKUniversity.universityToTitles
   */
  export type BKUniversity$universityToTitlesArgs = {
    /**
     * Select specific fields to fetch from the UniversityToTitle
     */
    select?: UniversityToTitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UniversityToTitleInclude | null
    where?: UniversityToTitleWhereInput
    orderBy?: Enumerable<UniversityToTitleOrderByWithRelationInput>
    cursor?: UniversityToTitleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UniversityToTitleScalarFieldEnum>
  }


  /**
   * BKUniversity.reserveUsers
   */
  export type BKUniversity$reserveUsersArgs = {
    /**
     * Select specific fields to fetch from the BKReserveUser
     */
    select?: BKReserveUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKReserveUserInclude | null
    where?: BKReserveUserWhereInput
    orderBy?: Enumerable<BKReserveUserOrderByWithRelationInput>
    cursor?: BKReserveUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BKReserveUserScalarFieldEnum>
  }


  /**
   * BKUniversity.fromRequest
   */
  export type BKUniversity$fromRequestArgs = {
    /**
     * Select specific fields to fetch from the BKRequest
     */
    select?: BKRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKRequestInclude | null
    where?: BKRequestWhereInput
    orderBy?: Enumerable<BKRequestOrderByWithRelationInput>
    cursor?: BKRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BKRequestScalarFieldEnum>
  }


  /**
   * BKUniversity.toRequest
   */
  export type BKUniversity$toRequestArgs = {
    /**
     * Select specific fields to fetch from the BKRequest
     */
    select?: BKRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKRequestInclude | null
    where?: BKRequestWhereInput
    orderBy?: Enumerable<BKRequestOrderByWithRelationInput>
    cursor?: BKRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BKRequestScalarFieldEnum>
  }


  /**
   * BKUniversity.BKBorrowingHistory
   */
  export type BKUniversity$BKBorrowingHistoryArgs = {
    /**
     * Select specific fields to fetch from the BKBorrowingHistory
     */
    select?: BKBorrowingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKBorrowingHistoryInclude | null
    where?: BKBorrowingHistoryWhereInput
    orderBy?: Enumerable<BKBorrowingHistoryOrderByWithRelationInput>
    cursor?: BKBorrowingHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BKBorrowingHistoryScalarFieldEnum>
  }


  /**
   * BKUniversity without action
   */
  export type BKUniversityArgs = {
    /**
     * Select specific fields to fetch from the BKUniversity
     */
    select?: BKUniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKUniversityInclude | null
  }



  /**
   * Model BKTitle
   */


  export type AggregateBKTitle = {
    _count: BKTitleCountAggregateOutputType | null
    _avg: BKTitleAvgAggregateOutputType | null
    _sum: BKTitleSumAggregateOutputType | null
    _min: BKTitleMinAggregateOutputType | null
    _max: BKTitleMaxAggregateOutputType | null
  }

  export type BKTitleAvgAggregateOutputType = {
    id: number | null
    ISBN: number | null
    copyQty: number | null
  }

  export type BKTitleSumAggregateOutputType = {
    id: number | null
    ISBN: number | null
    copyQty: number | null
  }

  export type BKTitleMinAggregateOutputType = {
    id: number | null
    name: string | null
    ISBN: number | null
    copyQty: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BKTitleMaxAggregateOutputType = {
    id: number | null
    name: string | null
    ISBN: number | null
    copyQty: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BKTitleCountAggregateOutputType = {
    id: number
    name: number
    ISBN: number
    copyQty: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BKTitleAvgAggregateInputType = {
    id?: true
    ISBN?: true
    copyQty?: true
  }

  export type BKTitleSumAggregateInputType = {
    id?: true
    ISBN?: true
    copyQty?: true
  }

  export type BKTitleMinAggregateInputType = {
    id?: true
    name?: true
    ISBN?: true
    copyQty?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BKTitleMaxAggregateInputType = {
    id?: true
    name?: true
    ISBN?: true
    copyQty?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BKTitleCountAggregateInputType = {
    id?: true
    name?: true
    ISBN?: true
    copyQty?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BKTitleAggregateArgs = {
    /**
     * Filter which BKTitle to aggregate.
     */
    where?: BKTitleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BKTitles to fetch.
     */
    orderBy?: Enumerable<BKTitleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BKTitleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BKTitles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BKTitles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BKTitles
    **/
    _count?: true | BKTitleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BKTitleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BKTitleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BKTitleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BKTitleMaxAggregateInputType
  }

  export type GetBKTitleAggregateType<T extends BKTitleAggregateArgs> = {
        [P in keyof T & keyof AggregateBKTitle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBKTitle[P]>
      : GetScalarType<T[P], AggregateBKTitle[P]>
  }




  export type BKTitleGroupByArgs = {
    where?: BKTitleWhereInput
    orderBy?: Enumerable<BKTitleOrderByWithAggregationInput>
    by: BKTitleScalarFieldEnum[]
    having?: BKTitleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BKTitleCountAggregateInputType | true
    _avg?: BKTitleAvgAggregateInputType
    _sum?: BKTitleSumAggregateInputType
    _min?: BKTitleMinAggregateInputType
    _max?: BKTitleMaxAggregateInputType
  }


  export type BKTitleGroupByOutputType = {
    id: number
    name: string
    ISBN: number
    copyQty: number
    createdAt: Date
    updatedAt: Date
    _count: BKTitleCountAggregateOutputType | null
    _avg: BKTitleAvgAggregateOutputType | null
    _sum: BKTitleSumAggregateOutputType | null
    _min: BKTitleMinAggregateOutputType | null
    _max: BKTitleMaxAggregateOutputType | null
  }

  type GetBKTitleGroupByPayload<T extends BKTitleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BKTitleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BKTitleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BKTitleGroupByOutputType[P]>
            : GetScalarType<T[P], BKTitleGroupByOutputType[P]>
        }
      >
    >


  export type BKTitleSelect = {
    id?: boolean
    name?: boolean
    ISBN?: boolean
    copyQty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    titleToCategories?: boolean | BKTitle$titleToCategoriesArgs
    titleToAuthors?: boolean | BKTitle$titleToAuthorsArgs
    universityToTitles?: boolean | BKTitle$universityToTitlesArgs
    copies?: boolean | BKTitle$copiesArgs
    _count?: boolean | BKTitleCountOutputTypeArgs
  }


  export type BKTitleInclude = {
    titleToCategories?: boolean | BKTitle$titleToCategoriesArgs
    titleToAuthors?: boolean | BKTitle$titleToAuthorsArgs
    universityToTitles?: boolean | BKTitle$universityToTitlesArgs
    copies?: boolean | BKTitle$copiesArgs
    _count?: boolean | BKTitleCountOutputTypeArgs
  }

  export type BKTitleGetPayload<S extends boolean | null | undefined | BKTitleArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BKTitle :
    S extends undefined ? never :
    S extends { include: any } & (BKTitleArgs | BKTitleFindManyArgs)
    ? BKTitle  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'titleToCategories' ? Array < TitleToCategoryGetPayload<S['include'][P]>>  :
        P extends 'titleToAuthors' ? Array < TitleToAuthorGetPayload<S['include'][P]>>  :
        P extends 'universityToTitles' ? Array < UniversityToTitleGetPayload<S['include'][P]>>  :
        P extends 'copies' ? Array < BKCopyGetPayload<S['include'][P]>>  :
        P extends '_count' ? BKTitleCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BKTitleArgs | BKTitleFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'titleToCategories' ? Array < TitleToCategoryGetPayload<S['select'][P]>>  :
        P extends 'titleToAuthors' ? Array < TitleToAuthorGetPayload<S['select'][P]>>  :
        P extends 'universityToTitles' ? Array < UniversityToTitleGetPayload<S['select'][P]>>  :
        P extends 'copies' ? Array < BKCopyGetPayload<S['select'][P]>>  :
        P extends '_count' ? BKTitleCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof BKTitle ? BKTitle[P] : never
  } 
      : BKTitle


  type BKTitleCountArgs = 
    Omit<BKTitleFindManyArgs, 'select' | 'include'> & {
      select?: BKTitleCountAggregateInputType | true
    }

  export interface BKTitleDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one BKTitle that matches the filter.
     * @param {BKTitleFindUniqueArgs} args - Arguments to find a BKTitle
     * @example
     * // Get one BKTitle
     * const bKTitle = await prisma.bKTitle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BKTitleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BKTitleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BKTitle'> extends True ? Prisma__BKTitleClient<BKTitleGetPayload<T>> : Prisma__BKTitleClient<BKTitleGetPayload<T> | null, null>

    /**
     * Find one BKTitle that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BKTitleFindUniqueOrThrowArgs} args - Arguments to find a BKTitle
     * @example
     * // Get one BKTitle
     * const bKTitle = await prisma.bKTitle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BKTitleFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BKTitleFindUniqueOrThrowArgs>
    ): Prisma__BKTitleClient<BKTitleGetPayload<T>>

    /**
     * Find the first BKTitle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKTitleFindFirstArgs} args - Arguments to find a BKTitle
     * @example
     * // Get one BKTitle
     * const bKTitle = await prisma.bKTitle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BKTitleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BKTitleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BKTitle'> extends True ? Prisma__BKTitleClient<BKTitleGetPayload<T>> : Prisma__BKTitleClient<BKTitleGetPayload<T> | null, null>

    /**
     * Find the first BKTitle that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKTitleFindFirstOrThrowArgs} args - Arguments to find a BKTitle
     * @example
     * // Get one BKTitle
     * const bKTitle = await prisma.bKTitle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BKTitleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BKTitleFindFirstOrThrowArgs>
    ): Prisma__BKTitleClient<BKTitleGetPayload<T>>

    /**
     * Find zero or more BKTitles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKTitleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BKTitles
     * const bKTitles = await prisma.bKTitle.findMany()
     * 
     * // Get first 10 BKTitles
     * const bKTitles = await prisma.bKTitle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bKTitleWithIdOnly = await prisma.bKTitle.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BKTitleFindManyArgs>(
      args?: SelectSubset<T, BKTitleFindManyArgs>
    ): Prisma.PrismaPromise<Array<BKTitleGetPayload<T>>>

    /**
     * Create a BKTitle.
     * @param {BKTitleCreateArgs} args - Arguments to create a BKTitle.
     * @example
     * // Create one BKTitle
     * const BKTitle = await prisma.bKTitle.create({
     *   data: {
     *     // ... data to create a BKTitle
     *   }
     * })
     * 
    **/
    create<T extends BKTitleCreateArgs>(
      args: SelectSubset<T, BKTitleCreateArgs>
    ): Prisma__BKTitleClient<BKTitleGetPayload<T>>

    /**
     * Create many BKTitles.
     *     @param {BKTitleCreateManyArgs} args - Arguments to create many BKTitles.
     *     @example
     *     // Create many BKTitles
     *     const bKTitle = await prisma.bKTitle.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BKTitleCreateManyArgs>(
      args?: SelectSubset<T, BKTitleCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BKTitle.
     * @param {BKTitleDeleteArgs} args - Arguments to delete one BKTitle.
     * @example
     * // Delete one BKTitle
     * const BKTitle = await prisma.bKTitle.delete({
     *   where: {
     *     // ... filter to delete one BKTitle
     *   }
     * })
     * 
    **/
    delete<T extends BKTitleDeleteArgs>(
      args: SelectSubset<T, BKTitleDeleteArgs>
    ): Prisma__BKTitleClient<BKTitleGetPayload<T>>

    /**
     * Update one BKTitle.
     * @param {BKTitleUpdateArgs} args - Arguments to update one BKTitle.
     * @example
     * // Update one BKTitle
     * const bKTitle = await prisma.bKTitle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BKTitleUpdateArgs>(
      args: SelectSubset<T, BKTitleUpdateArgs>
    ): Prisma__BKTitleClient<BKTitleGetPayload<T>>

    /**
     * Delete zero or more BKTitles.
     * @param {BKTitleDeleteManyArgs} args - Arguments to filter BKTitles to delete.
     * @example
     * // Delete a few BKTitles
     * const { count } = await prisma.bKTitle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BKTitleDeleteManyArgs>(
      args?: SelectSubset<T, BKTitleDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BKTitles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKTitleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BKTitles
     * const bKTitle = await prisma.bKTitle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BKTitleUpdateManyArgs>(
      args: SelectSubset<T, BKTitleUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BKTitle.
     * @param {BKTitleUpsertArgs} args - Arguments to update or create a BKTitle.
     * @example
     * // Update or create a BKTitle
     * const bKTitle = await prisma.bKTitle.upsert({
     *   create: {
     *     // ... data to create a BKTitle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BKTitle we want to update
     *   }
     * })
    **/
    upsert<T extends BKTitleUpsertArgs>(
      args: SelectSubset<T, BKTitleUpsertArgs>
    ): Prisma__BKTitleClient<BKTitleGetPayload<T>>

    /**
     * Count the number of BKTitles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKTitleCountArgs} args - Arguments to filter BKTitles to count.
     * @example
     * // Count the number of BKTitles
     * const count = await prisma.bKTitle.count({
     *   where: {
     *     // ... the filter for the BKTitles we want to count
     *   }
     * })
    **/
    count<T extends BKTitleCountArgs>(
      args?: Subset<T, BKTitleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BKTitleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BKTitle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKTitleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BKTitleAggregateArgs>(args: Subset<T, BKTitleAggregateArgs>): Prisma.PrismaPromise<GetBKTitleAggregateType<T>>

    /**
     * Group by BKTitle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKTitleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BKTitleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BKTitleGroupByArgs['orderBy'] }
        : { orderBy?: BKTitleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BKTitleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBKTitleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BKTitle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BKTitleClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    titleToCategories<T extends BKTitle$titleToCategoriesArgs= {}>(args?: Subset<T, BKTitle$titleToCategoriesArgs>): Prisma.PrismaPromise<Array<TitleToCategoryGetPayload<T>>| Null>;

    titleToAuthors<T extends BKTitle$titleToAuthorsArgs= {}>(args?: Subset<T, BKTitle$titleToAuthorsArgs>): Prisma.PrismaPromise<Array<TitleToAuthorGetPayload<T>>| Null>;

    universityToTitles<T extends BKTitle$universityToTitlesArgs= {}>(args?: Subset<T, BKTitle$universityToTitlesArgs>): Prisma.PrismaPromise<Array<UniversityToTitleGetPayload<T>>| Null>;

    copies<T extends BKTitle$copiesArgs= {}>(args?: Subset<T, BKTitle$copiesArgs>): Prisma.PrismaPromise<Array<BKCopyGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BKTitle base type for findUnique actions
   */
  export type BKTitleFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BKTitle
     */
    select?: BKTitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKTitleInclude | null
    /**
     * Filter, which BKTitle to fetch.
     */
    where: BKTitleWhereUniqueInput
  }

  /**
   * BKTitle findUnique
   */
  export interface BKTitleFindUniqueArgs extends BKTitleFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BKTitle findUniqueOrThrow
   */
  export type BKTitleFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BKTitle
     */
    select?: BKTitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKTitleInclude | null
    /**
     * Filter, which BKTitle to fetch.
     */
    where: BKTitleWhereUniqueInput
  }


  /**
   * BKTitle base type for findFirst actions
   */
  export type BKTitleFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BKTitle
     */
    select?: BKTitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKTitleInclude | null
    /**
     * Filter, which BKTitle to fetch.
     */
    where?: BKTitleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BKTitles to fetch.
     */
    orderBy?: Enumerable<BKTitleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BKTitles.
     */
    cursor?: BKTitleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BKTitles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BKTitles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BKTitles.
     */
    distinct?: Enumerable<BKTitleScalarFieldEnum>
  }

  /**
   * BKTitle findFirst
   */
  export interface BKTitleFindFirstArgs extends BKTitleFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BKTitle findFirstOrThrow
   */
  export type BKTitleFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BKTitle
     */
    select?: BKTitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKTitleInclude | null
    /**
     * Filter, which BKTitle to fetch.
     */
    where?: BKTitleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BKTitles to fetch.
     */
    orderBy?: Enumerable<BKTitleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BKTitles.
     */
    cursor?: BKTitleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BKTitles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BKTitles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BKTitles.
     */
    distinct?: Enumerable<BKTitleScalarFieldEnum>
  }


  /**
   * BKTitle findMany
   */
  export type BKTitleFindManyArgs = {
    /**
     * Select specific fields to fetch from the BKTitle
     */
    select?: BKTitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKTitleInclude | null
    /**
     * Filter, which BKTitles to fetch.
     */
    where?: BKTitleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BKTitles to fetch.
     */
    orderBy?: Enumerable<BKTitleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BKTitles.
     */
    cursor?: BKTitleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BKTitles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BKTitles.
     */
    skip?: number
    distinct?: Enumerable<BKTitleScalarFieldEnum>
  }


  /**
   * BKTitle create
   */
  export type BKTitleCreateArgs = {
    /**
     * Select specific fields to fetch from the BKTitle
     */
    select?: BKTitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKTitleInclude | null
    /**
     * The data needed to create a BKTitle.
     */
    data: XOR<BKTitleCreateInput, BKTitleUncheckedCreateInput>
  }


  /**
   * BKTitle createMany
   */
  export type BKTitleCreateManyArgs = {
    /**
     * The data used to create many BKTitles.
     */
    data: Enumerable<BKTitleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BKTitle update
   */
  export type BKTitleUpdateArgs = {
    /**
     * Select specific fields to fetch from the BKTitle
     */
    select?: BKTitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKTitleInclude | null
    /**
     * The data needed to update a BKTitle.
     */
    data: XOR<BKTitleUpdateInput, BKTitleUncheckedUpdateInput>
    /**
     * Choose, which BKTitle to update.
     */
    where: BKTitleWhereUniqueInput
  }


  /**
   * BKTitle updateMany
   */
  export type BKTitleUpdateManyArgs = {
    /**
     * The data used to update BKTitles.
     */
    data: XOR<BKTitleUpdateManyMutationInput, BKTitleUncheckedUpdateManyInput>
    /**
     * Filter which BKTitles to update
     */
    where?: BKTitleWhereInput
  }


  /**
   * BKTitle upsert
   */
  export type BKTitleUpsertArgs = {
    /**
     * Select specific fields to fetch from the BKTitle
     */
    select?: BKTitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKTitleInclude | null
    /**
     * The filter to search for the BKTitle to update in case it exists.
     */
    where: BKTitleWhereUniqueInput
    /**
     * In case the BKTitle found by the `where` argument doesn't exist, create a new BKTitle with this data.
     */
    create: XOR<BKTitleCreateInput, BKTitleUncheckedCreateInput>
    /**
     * In case the BKTitle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BKTitleUpdateInput, BKTitleUncheckedUpdateInput>
  }


  /**
   * BKTitle delete
   */
  export type BKTitleDeleteArgs = {
    /**
     * Select specific fields to fetch from the BKTitle
     */
    select?: BKTitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKTitleInclude | null
    /**
     * Filter which BKTitle to delete.
     */
    where: BKTitleWhereUniqueInput
  }


  /**
   * BKTitle deleteMany
   */
  export type BKTitleDeleteManyArgs = {
    /**
     * Filter which BKTitles to delete
     */
    where?: BKTitleWhereInput
  }


  /**
   * BKTitle.titleToCategories
   */
  export type BKTitle$titleToCategoriesArgs = {
    /**
     * Select specific fields to fetch from the TitleToCategory
     */
    select?: TitleToCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TitleToCategoryInclude | null
    where?: TitleToCategoryWhereInput
    orderBy?: Enumerable<TitleToCategoryOrderByWithRelationInput>
    cursor?: TitleToCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TitleToCategoryScalarFieldEnum>
  }


  /**
   * BKTitle.titleToAuthors
   */
  export type BKTitle$titleToAuthorsArgs = {
    /**
     * Select specific fields to fetch from the TitleToAuthor
     */
    select?: TitleToAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TitleToAuthorInclude | null
    where?: TitleToAuthorWhereInput
    orderBy?: Enumerable<TitleToAuthorOrderByWithRelationInput>
    cursor?: TitleToAuthorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TitleToAuthorScalarFieldEnum>
  }


  /**
   * BKTitle.universityToTitles
   */
  export type BKTitle$universityToTitlesArgs = {
    /**
     * Select specific fields to fetch from the UniversityToTitle
     */
    select?: UniversityToTitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UniversityToTitleInclude | null
    where?: UniversityToTitleWhereInput
    orderBy?: Enumerable<UniversityToTitleOrderByWithRelationInput>
    cursor?: UniversityToTitleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UniversityToTitleScalarFieldEnum>
  }


  /**
   * BKTitle.copies
   */
  export type BKTitle$copiesArgs = {
    /**
     * Select specific fields to fetch from the BKCopy
     */
    select?: BKCopySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKCopyInclude | null
    where?: BKCopyWhereInput
    orderBy?: Enumerable<BKCopyOrderByWithRelationInput>
    cursor?: BKCopyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BKCopyScalarFieldEnum>
  }


  /**
   * BKTitle without action
   */
  export type BKTitleArgs = {
    /**
     * Select specific fields to fetch from the BKTitle
     */
    select?: BKTitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKTitleInclude | null
  }



  /**
   * Model UniversityToTitle
   */


  export type AggregateUniversityToTitle = {
    _count: UniversityToTitleCountAggregateOutputType | null
    _avg: UniversityToTitleAvgAggregateOutputType | null
    _sum: UniversityToTitleSumAggregateOutputType | null
    _min: UniversityToTitleMinAggregateOutputType | null
    _max: UniversityToTitleMaxAggregateOutputType | null
  }

  export type UniversityToTitleAvgAggregateOutputType = {
    id: number | null
    universityId: number | null
    titleId: number | null
  }

  export type UniversityToTitleSumAggregateOutputType = {
    id: number | null
    universityId: number | null
    titleId: number | null
  }

  export type UniversityToTitleMinAggregateOutputType = {
    id: number | null
    universityId: number | null
    titleId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UniversityToTitleMaxAggregateOutputType = {
    id: number | null
    universityId: number | null
    titleId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UniversityToTitleCountAggregateOutputType = {
    id: number
    universityId: number
    titleId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UniversityToTitleAvgAggregateInputType = {
    id?: true
    universityId?: true
    titleId?: true
  }

  export type UniversityToTitleSumAggregateInputType = {
    id?: true
    universityId?: true
    titleId?: true
  }

  export type UniversityToTitleMinAggregateInputType = {
    id?: true
    universityId?: true
    titleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UniversityToTitleMaxAggregateInputType = {
    id?: true
    universityId?: true
    titleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UniversityToTitleCountAggregateInputType = {
    id?: true
    universityId?: true
    titleId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UniversityToTitleAggregateArgs = {
    /**
     * Filter which UniversityToTitle to aggregate.
     */
    where?: UniversityToTitleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UniversityToTitles to fetch.
     */
    orderBy?: Enumerable<UniversityToTitleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UniversityToTitleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UniversityToTitles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UniversityToTitles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UniversityToTitles
    **/
    _count?: true | UniversityToTitleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UniversityToTitleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UniversityToTitleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UniversityToTitleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UniversityToTitleMaxAggregateInputType
  }

  export type GetUniversityToTitleAggregateType<T extends UniversityToTitleAggregateArgs> = {
        [P in keyof T & keyof AggregateUniversityToTitle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUniversityToTitle[P]>
      : GetScalarType<T[P], AggregateUniversityToTitle[P]>
  }




  export type UniversityToTitleGroupByArgs = {
    where?: UniversityToTitleWhereInput
    orderBy?: Enumerable<UniversityToTitleOrderByWithAggregationInput>
    by: UniversityToTitleScalarFieldEnum[]
    having?: UniversityToTitleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UniversityToTitleCountAggregateInputType | true
    _avg?: UniversityToTitleAvgAggregateInputType
    _sum?: UniversityToTitleSumAggregateInputType
    _min?: UniversityToTitleMinAggregateInputType
    _max?: UniversityToTitleMaxAggregateInputType
  }


  export type UniversityToTitleGroupByOutputType = {
    id: number
    universityId: number
    titleId: number
    createdAt: Date
    updatedAt: Date
    _count: UniversityToTitleCountAggregateOutputType | null
    _avg: UniversityToTitleAvgAggregateOutputType | null
    _sum: UniversityToTitleSumAggregateOutputType | null
    _min: UniversityToTitleMinAggregateOutputType | null
    _max: UniversityToTitleMaxAggregateOutputType | null
  }

  type GetUniversityToTitleGroupByPayload<T extends UniversityToTitleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UniversityToTitleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UniversityToTitleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UniversityToTitleGroupByOutputType[P]>
            : GetScalarType<T[P], UniversityToTitleGroupByOutputType[P]>
        }
      >
    >


  export type UniversityToTitleSelect = {
    id?: boolean
    university?: boolean | BKUniversityArgs
    universityId?: boolean
    title?: boolean | BKTitleArgs
    titleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type UniversityToTitleInclude = {
    university?: boolean | BKUniversityArgs
    title?: boolean | BKTitleArgs
  }

  export type UniversityToTitleGetPayload<S extends boolean | null | undefined | UniversityToTitleArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UniversityToTitle :
    S extends undefined ? never :
    S extends { include: any } & (UniversityToTitleArgs | UniversityToTitleFindManyArgs)
    ? UniversityToTitle  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'university' ? BKUniversityGetPayload<S['include'][P]> :
        P extends 'title' ? BKTitleGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UniversityToTitleArgs | UniversityToTitleFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'university' ? BKUniversityGetPayload<S['select'][P]> :
        P extends 'title' ? BKTitleGetPayload<S['select'][P]> :  P extends keyof UniversityToTitle ? UniversityToTitle[P] : never
  } 
      : UniversityToTitle


  type UniversityToTitleCountArgs = 
    Omit<UniversityToTitleFindManyArgs, 'select' | 'include'> & {
      select?: UniversityToTitleCountAggregateInputType | true
    }

  export interface UniversityToTitleDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one UniversityToTitle that matches the filter.
     * @param {UniversityToTitleFindUniqueArgs} args - Arguments to find a UniversityToTitle
     * @example
     * // Get one UniversityToTitle
     * const universityToTitle = await prisma.universityToTitle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UniversityToTitleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UniversityToTitleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UniversityToTitle'> extends True ? Prisma__UniversityToTitleClient<UniversityToTitleGetPayload<T>> : Prisma__UniversityToTitleClient<UniversityToTitleGetPayload<T> | null, null>

    /**
     * Find one UniversityToTitle that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UniversityToTitleFindUniqueOrThrowArgs} args - Arguments to find a UniversityToTitle
     * @example
     * // Get one UniversityToTitle
     * const universityToTitle = await prisma.universityToTitle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UniversityToTitleFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UniversityToTitleFindUniqueOrThrowArgs>
    ): Prisma__UniversityToTitleClient<UniversityToTitleGetPayload<T>>

    /**
     * Find the first UniversityToTitle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityToTitleFindFirstArgs} args - Arguments to find a UniversityToTitle
     * @example
     * // Get one UniversityToTitle
     * const universityToTitle = await prisma.universityToTitle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UniversityToTitleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UniversityToTitleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UniversityToTitle'> extends True ? Prisma__UniversityToTitleClient<UniversityToTitleGetPayload<T>> : Prisma__UniversityToTitleClient<UniversityToTitleGetPayload<T> | null, null>

    /**
     * Find the first UniversityToTitle that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityToTitleFindFirstOrThrowArgs} args - Arguments to find a UniversityToTitle
     * @example
     * // Get one UniversityToTitle
     * const universityToTitle = await prisma.universityToTitle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UniversityToTitleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UniversityToTitleFindFirstOrThrowArgs>
    ): Prisma__UniversityToTitleClient<UniversityToTitleGetPayload<T>>

    /**
     * Find zero or more UniversityToTitles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityToTitleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UniversityToTitles
     * const universityToTitles = await prisma.universityToTitle.findMany()
     * 
     * // Get first 10 UniversityToTitles
     * const universityToTitles = await prisma.universityToTitle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const universityToTitleWithIdOnly = await prisma.universityToTitle.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UniversityToTitleFindManyArgs>(
      args?: SelectSubset<T, UniversityToTitleFindManyArgs>
    ): Prisma.PrismaPromise<Array<UniversityToTitleGetPayload<T>>>

    /**
     * Create a UniversityToTitle.
     * @param {UniversityToTitleCreateArgs} args - Arguments to create a UniversityToTitle.
     * @example
     * // Create one UniversityToTitle
     * const UniversityToTitle = await prisma.universityToTitle.create({
     *   data: {
     *     // ... data to create a UniversityToTitle
     *   }
     * })
     * 
    **/
    create<T extends UniversityToTitleCreateArgs>(
      args: SelectSubset<T, UniversityToTitleCreateArgs>
    ): Prisma__UniversityToTitleClient<UniversityToTitleGetPayload<T>>

    /**
     * Create many UniversityToTitles.
     *     @param {UniversityToTitleCreateManyArgs} args - Arguments to create many UniversityToTitles.
     *     @example
     *     // Create many UniversityToTitles
     *     const universityToTitle = await prisma.universityToTitle.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UniversityToTitleCreateManyArgs>(
      args?: SelectSubset<T, UniversityToTitleCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UniversityToTitle.
     * @param {UniversityToTitleDeleteArgs} args - Arguments to delete one UniversityToTitle.
     * @example
     * // Delete one UniversityToTitle
     * const UniversityToTitle = await prisma.universityToTitle.delete({
     *   where: {
     *     // ... filter to delete one UniversityToTitle
     *   }
     * })
     * 
    **/
    delete<T extends UniversityToTitleDeleteArgs>(
      args: SelectSubset<T, UniversityToTitleDeleteArgs>
    ): Prisma__UniversityToTitleClient<UniversityToTitleGetPayload<T>>

    /**
     * Update one UniversityToTitle.
     * @param {UniversityToTitleUpdateArgs} args - Arguments to update one UniversityToTitle.
     * @example
     * // Update one UniversityToTitle
     * const universityToTitle = await prisma.universityToTitle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UniversityToTitleUpdateArgs>(
      args: SelectSubset<T, UniversityToTitleUpdateArgs>
    ): Prisma__UniversityToTitleClient<UniversityToTitleGetPayload<T>>

    /**
     * Delete zero or more UniversityToTitles.
     * @param {UniversityToTitleDeleteManyArgs} args - Arguments to filter UniversityToTitles to delete.
     * @example
     * // Delete a few UniversityToTitles
     * const { count } = await prisma.universityToTitle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UniversityToTitleDeleteManyArgs>(
      args?: SelectSubset<T, UniversityToTitleDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UniversityToTitles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityToTitleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UniversityToTitles
     * const universityToTitle = await prisma.universityToTitle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UniversityToTitleUpdateManyArgs>(
      args: SelectSubset<T, UniversityToTitleUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UniversityToTitle.
     * @param {UniversityToTitleUpsertArgs} args - Arguments to update or create a UniversityToTitle.
     * @example
     * // Update or create a UniversityToTitle
     * const universityToTitle = await prisma.universityToTitle.upsert({
     *   create: {
     *     // ... data to create a UniversityToTitle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UniversityToTitle we want to update
     *   }
     * })
    **/
    upsert<T extends UniversityToTitleUpsertArgs>(
      args: SelectSubset<T, UniversityToTitleUpsertArgs>
    ): Prisma__UniversityToTitleClient<UniversityToTitleGetPayload<T>>

    /**
     * Count the number of UniversityToTitles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityToTitleCountArgs} args - Arguments to filter UniversityToTitles to count.
     * @example
     * // Count the number of UniversityToTitles
     * const count = await prisma.universityToTitle.count({
     *   where: {
     *     // ... the filter for the UniversityToTitles we want to count
     *   }
     * })
    **/
    count<T extends UniversityToTitleCountArgs>(
      args?: Subset<T, UniversityToTitleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UniversityToTitleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UniversityToTitle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityToTitleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UniversityToTitleAggregateArgs>(args: Subset<T, UniversityToTitleAggregateArgs>): Prisma.PrismaPromise<GetUniversityToTitleAggregateType<T>>

    /**
     * Group by UniversityToTitle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityToTitleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UniversityToTitleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UniversityToTitleGroupByArgs['orderBy'] }
        : { orderBy?: UniversityToTitleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UniversityToTitleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUniversityToTitleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UniversityToTitle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UniversityToTitleClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    university<T extends BKUniversityArgs= {}>(args?: Subset<T, BKUniversityArgs>): Prisma__BKUniversityClient<BKUniversityGetPayload<T> | Null>;

    title<T extends BKTitleArgs= {}>(args?: Subset<T, BKTitleArgs>): Prisma__BKTitleClient<BKTitleGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UniversityToTitle base type for findUnique actions
   */
  export type UniversityToTitleFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the UniversityToTitle
     */
    select?: UniversityToTitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UniversityToTitleInclude | null
    /**
     * Filter, which UniversityToTitle to fetch.
     */
    where: UniversityToTitleWhereUniqueInput
  }

  /**
   * UniversityToTitle findUnique
   */
  export interface UniversityToTitleFindUniqueArgs extends UniversityToTitleFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UniversityToTitle findUniqueOrThrow
   */
  export type UniversityToTitleFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UniversityToTitle
     */
    select?: UniversityToTitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UniversityToTitleInclude | null
    /**
     * Filter, which UniversityToTitle to fetch.
     */
    where: UniversityToTitleWhereUniqueInput
  }


  /**
   * UniversityToTitle base type for findFirst actions
   */
  export type UniversityToTitleFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the UniversityToTitle
     */
    select?: UniversityToTitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UniversityToTitleInclude | null
    /**
     * Filter, which UniversityToTitle to fetch.
     */
    where?: UniversityToTitleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UniversityToTitles to fetch.
     */
    orderBy?: Enumerable<UniversityToTitleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UniversityToTitles.
     */
    cursor?: UniversityToTitleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UniversityToTitles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UniversityToTitles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UniversityToTitles.
     */
    distinct?: Enumerable<UniversityToTitleScalarFieldEnum>
  }

  /**
   * UniversityToTitle findFirst
   */
  export interface UniversityToTitleFindFirstArgs extends UniversityToTitleFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UniversityToTitle findFirstOrThrow
   */
  export type UniversityToTitleFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UniversityToTitle
     */
    select?: UniversityToTitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UniversityToTitleInclude | null
    /**
     * Filter, which UniversityToTitle to fetch.
     */
    where?: UniversityToTitleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UniversityToTitles to fetch.
     */
    orderBy?: Enumerable<UniversityToTitleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UniversityToTitles.
     */
    cursor?: UniversityToTitleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UniversityToTitles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UniversityToTitles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UniversityToTitles.
     */
    distinct?: Enumerable<UniversityToTitleScalarFieldEnum>
  }


  /**
   * UniversityToTitle findMany
   */
  export type UniversityToTitleFindManyArgs = {
    /**
     * Select specific fields to fetch from the UniversityToTitle
     */
    select?: UniversityToTitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UniversityToTitleInclude | null
    /**
     * Filter, which UniversityToTitles to fetch.
     */
    where?: UniversityToTitleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UniversityToTitles to fetch.
     */
    orderBy?: Enumerable<UniversityToTitleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UniversityToTitles.
     */
    cursor?: UniversityToTitleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UniversityToTitles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UniversityToTitles.
     */
    skip?: number
    distinct?: Enumerable<UniversityToTitleScalarFieldEnum>
  }


  /**
   * UniversityToTitle create
   */
  export type UniversityToTitleCreateArgs = {
    /**
     * Select specific fields to fetch from the UniversityToTitle
     */
    select?: UniversityToTitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UniversityToTitleInclude | null
    /**
     * The data needed to create a UniversityToTitle.
     */
    data: XOR<UniversityToTitleCreateInput, UniversityToTitleUncheckedCreateInput>
  }


  /**
   * UniversityToTitle createMany
   */
  export type UniversityToTitleCreateManyArgs = {
    /**
     * The data used to create many UniversityToTitles.
     */
    data: Enumerable<UniversityToTitleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UniversityToTitle update
   */
  export type UniversityToTitleUpdateArgs = {
    /**
     * Select specific fields to fetch from the UniversityToTitle
     */
    select?: UniversityToTitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UniversityToTitleInclude | null
    /**
     * The data needed to update a UniversityToTitle.
     */
    data: XOR<UniversityToTitleUpdateInput, UniversityToTitleUncheckedUpdateInput>
    /**
     * Choose, which UniversityToTitle to update.
     */
    where: UniversityToTitleWhereUniqueInput
  }


  /**
   * UniversityToTitle updateMany
   */
  export type UniversityToTitleUpdateManyArgs = {
    /**
     * The data used to update UniversityToTitles.
     */
    data: XOR<UniversityToTitleUpdateManyMutationInput, UniversityToTitleUncheckedUpdateManyInput>
    /**
     * Filter which UniversityToTitles to update
     */
    where?: UniversityToTitleWhereInput
  }


  /**
   * UniversityToTitle upsert
   */
  export type UniversityToTitleUpsertArgs = {
    /**
     * Select specific fields to fetch from the UniversityToTitle
     */
    select?: UniversityToTitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UniversityToTitleInclude | null
    /**
     * The filter to search for the UniversityToTitle to update in case it exists.
     */
    where: UniversityToTitleWhereUniqueInput
    /**
     * In case the UniversityToTitle found by the `where` argument doesn't exist, create a new UniversityToTitle with this data.
     */
    create: XOR<UniversityToTitleCreateInput, UniversityToTitleUncheckedCreateInput>
    /**
     * In case the UniversityToTitle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UniversityToTitleUpdateInput, UniversityToTitleUncheckedUpdateInput>
  }


  /**
   * UniversityToTitle delete
   */
  export type UniversityToTitleDeleteArgs = {
    /**
     * Select specific fields to fetch from the UniversityToTitle
     */
    select?: UniversityToTitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UniversityToTitleInclude | null
    /**
     * Filter which UniversityToTitle to delete.
     */
    where: UniversityToTitleWhereUniqueInput
  }


  /**
   * UniversityToTitle deleteMany
   */
  export type UniversityToTitleDeleteManyArgs = {
    /**
     * Filter which UniversityToTitles to delete
     */
    where?: UniversityToTitleWhereInput
  }


  /**
   * UniversityToTitle without action
   */
  export type UniversityToTitleArgs = {
    /**
     * Select specific fields to fetch from the UniversityToTitle
     */
    select?: UniversityToTitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UniversityToTitleInclude | null
  }



  /**
   * Model BKCategory
   */


  export type AggregateBKCategory = {
    _count: BKCategoryCountAggregateOutputType | null
    _avg: BKCategoryAvgAggregateOutputType | null
    _sum: BKCategorySumAggregateOutputType | null
    _min: BKCategoryMinAggregateOutputType | null
    _max: BKCategoryMaxAggregateOutputType | null
  }

  export type BKCategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type BKCategorySumAggregateOutputType = {
    id: number | null
  }

  export type BKCategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BKCategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BKCategoryCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BKCategoryAvgAggregateInputType = {
    id?: true
  }

  export type BKCategorySumAggregateInputType = {
    id?: true
  }

  export type BKCategoryMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BKCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BKCategoryCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BKCategoryAggregateArgs = {
    /**
     * Filter which BKCategory to aggregate.
     */
    where?: BKCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BKCategories to fetch.
     */
    orderBy?: Enumerable<BKCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BKCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BKCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BKCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BKCategories
    **/
    _count?: true | BKCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BKCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BKCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BKCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BKCategoryMaxAggregateInputType
  }

  export type GetBKCategoryAggregateType<T extends BKCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateBKCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBKCategory[P]>
      : GetScalarType<T[P], AggregateBKCategory[P]>
  }




  export type BKCategoryGroupByArgs = {
    where?: BKCategoryWhereInput
    orderBy?: Enumerable<BKCategoryOrderByWithAggregationInput>
    by: BKCategoryScalarFieldEnum[]
    having?: BKCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BKCategoryCountAggregateInputType | true
    _avg?: BKCategoryAvgAggregateInputType
    _sum?: BKCategorySumAggregateInputType
    _min?: BKCategoryMinAggregateInputType
    _max?: BKCategoryMaxAggregateInputType
  }


  export type BKCategoryGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: BKCategoryCountAggregateOutputType | null
    _avg: BKCategoryAvgAggregateOutputType | null
    _sum: BKCategorySumAggregateOutputType | null
    _min: BKCategoryMinAggregateOutputType | null
    _max: BKCategoryMaxAggregateOutputType | null
  }

  type GetBKCategoryGroupByPayload<T extends BKCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BKCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BKCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BKCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], BKCategoryGroupByOutputType[P]>
        }
      >
    >


  export type BKCategorySelect = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    titleToCategories?: boolean | BKCategory$titleToCategoriesArgs
    _count?: boolean | BKCategoryCountOutputTypeArgs
  }


  export type BKCategoryInclude = {
    titleToCategories?: boolean | BKCategory$titleToCategoriesArgs
    _count?: boolean | BKCategoryCountOutputTypeArgs
  }

  export type BKCategoryGetPayload<S extends boolean | null | undefined | BKCategoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BKCategory :
    S extends undefined ? never :
    S extends { include: any } & (BKCategoryArgs | BKCategoryFindManyArgs)
    ? BKCategory  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'titleToCategories' ? Array < TitleToCategoryGetPayload<S['include'][P]>>  :
        P extends '_count' ? BKCategoryCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BKCategoryArgs | BKCategoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'titleToCategories' ? Array < TitleToCategoryGetPayload<S['select'][P]>>  :
        P extends '_count' ? BKCategoryCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof BKCategory ? BKCategory[P] : never
  } 
      : BKCategory


  type BKCategoryCountArgs = 
    Omit<BKCategoryFindManyArgs, 'select' | 'include'> & {
      select?: BKCategoryCountAggregateInputType | true
    }

  export interface BKCategoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one BKCategory that matches the filter.
     * @param {BKCategoryFindUniqueArgs} args - Arguments to find a BKCategory
     * @example
     * // Get one BKCategory
     * const bKCategory = await prisma.bKCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BKCategoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BKCategoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BKCategory'> extends True ? Prisma__BKCategoryClient<BKCategoryGetPayload<T>> : Prisma__BKCategoryClient<BKCategoryGetPayload<T> | null, null>

    /**
     * Find one BKCategory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BKCategoryFindUniqueOrThrowArgs} args - Arguments to find a BKCategory
     * @example
     * // Get one BKCategory
     * const bKCategory = await prisma.bKCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BKCategoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BKCategoryFindUniqueOrThrowArgs>
    ): Prisma__BKCategoryClient<BKCategoryGetPayload<T>>

    /**
     * Find the first BKCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKCategoryFindFirstArgs} args - Arguments to find a BKCategory
     * @example
     * // Get one BKCategory
     * const bKCategory = await prisma.bKCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BKCategoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BKCategoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BKCategory'> extends True ? Prisma__BKCategoryClient<BKCategoryGetPayload<T>> : Prisma__BKCategoryClient<BKCategoryGetPayload<T> | null, null>

    /**
     * Find the first BKCategory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKCategoryFindFirstOrThrowArgs} args - Arguments to find a BKCategory
     * @example
     * // Get one BKCategory
     * const bKCategory = await prisma.bKCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BKCategoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BKCategoryFindFirstOrThrowArgs>
    ): Prisma__BKCategoryClient<BKCategoryGetPayload<T>>

    /**
     * Find zero or more BKCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKCategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BKCategories
     * const bKCategories = await prisma.bKCategory.findMany()
     * 
     * // Get first 10 BKCategories
     * const bKCategories = await prisma.bKCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bKCategoryWithIdOnly = await prisma.bKCategory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BKCategoryFindManyArgs>(
      args?: SelectSubset<T, BKCategoryFindManyArgs>
    ): Prisma.PrismaPromise<Array<BKCategoryGetPayload<T>>>

    /**
     * Create a BKCategory.
     * @param {BKCategoryCreateArgs} args - Arguments to create a BKCategory.
     * @example
     * // Create one BKCategory
     * const BKCategory = await prisma.bKCategory.create({
     *   data: {
     *     // ... data to create a BKCategory
     *   }
     * })
     * 
    **/
    create<T extends BKCategoryCreateArgs>(
      args: SelectSubset<T, BKCategoryCreateArgs>
    ): Prisma__BKCategoryClient<BKCategoryGetPayload<T>>

    /**
     * Create many BKCategories.
     *     @param {BKCategoryCreateManyArgs} args - Arguments to create many BKCategories.
     *     @example
     *     // Create many BKCategories
     *     const bKCategory = await prisma.bKCategory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BKCategoryCreateManyArgs>(
      args?: SelectSubset<T, BKCategoryCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BKCategory.
     * @param {BKCategoryDeleteArgs} args - Arguments to delete one BKCategory.
     * @example
     * // Delete one BKCategory
     * const BKCategory = await prisma.bKCategory.delete({
     *   where: {
     *     // ... filter to delete one BKCategory
     *   }
     * })
     * 
    **/
    delete<T extends BKCategoryDeleteArgs>(
      args: SelectSubset<T, BKCategoryDeleteArgs>
    ): Prisma__BKCategoryClient<BKCategoryGetPayload<T>>

    /**
     * Update one BKCategory.
     * @param {BKCategoryUpdateArgs} args - Arguments to update one BKCategory.
     * @example
     * // Update one BKCategory
     * const bKCategory = await prisma.bKCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BKCategoryUpdateArgs>(
      args: SelectSubset<T, BKCategoryUpdateArgs>
    ): Prisma__BKCategoryClient<BKCategoryGetPayload<T>>

    /**
     * Delete zero or more BKCategories.
     * @param {BKCategoryDeleteManyArgs} args - Arguments to filter BKCategories to delete.
     * @example
     * // Delete a few BKCategories
     * const { count } = await prisma.bKCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BKCategoryDeleteManyArgs>(
      args?: SelectSubset<T, BKCategoryDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BKCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BKCategories
     * const bKCategory = await prisma.bKCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BKCategoryUpdateManyArgs>(
      args: SelectSubset<T, BKCategoryUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BKCategory.
     * @param {BKCategoryUpsertArgs} args - Arguments to update or create a BKCategory.
     * @example
     * // Update or create a BKCategory
     * const bKCategory = await prisma.bKCategory.upsert({
     *   create: {
     *     // ... data to create a BKCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BKCategory we want to update
     *   }
     * })
    **/
    upsert<T extends BKCategoryUpsertArgs>(
      args: SelectSubset<T, BKCategoryUpsertArgs>
    ): Prisma__BKCategoryClient<BKCategoryGetPayload<T>>

    /**
     * Count the number of BKCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKCategoryCountArgs} args - Arguments to filter BKCategories to count.
     * @example
     * // Count the number of BKCategories
     * const count = await prisma.bKCategory.count({
     *   where: {
     *     // ... the filter for the BKCategories we want to count
     *   }
     * })
    **/
    count<T extends BKCategoryCountArgs>(
      args?: Subset<T, BKCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BKCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BKCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BKCategoryAggregateArgs>(args: Subset<T, BKCategoryAggregateArgs>): Prisma.PrismaPromise<GetBKCategoryAggregateType<T>>

    /**
     * Group by BKCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BKCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BKCategoryGroupByArgs['orderBy'] }
        : { orderBy?: BKCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BKCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBKCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BKCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BKCategoryClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    titleToCategories<T extends BKCategory$titleToCategoriesArgs= {}>(args?: Subset<T, BKCategory$titleToCategoriesArgs>): Prisma.PrismaPromise<Array<TitleToCategoryGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BKCategory base type for findUnique actions
   */
  export type BKCategoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BKCategory
     */
    select?: BKCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKCategoryInclude | null
    /**
     * Filter, which BKCategory to fetch.
     */
    where: BKCategoryWhereUniqueInput
  }

  /**
   * BKCategory findUnique
   */
  export interface BKCategoryFindUniqueArgs extends BKCategoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BKCategory findUniqueOrThrow
   */
  export type BKCategoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BKCategory
     */
    select?: BKCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKCategoryInclude | null
    /**
     * Filter, which BKCategory to fetch.
     */
    where: BKCategoryWhereUniqueInput
  }


  /**
   * BKCategory base type for findFirst actions
   */
  export type BKCategoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BKCategory
     */
    select?: BKCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKCategoryInclude | null
    /**
     * Filter, which BKCategory to fetch.
     */
    where?: BKCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BKCategories to fetch.
     */
    orderBy?: Enumerable<BKCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BKCategories.
     */
    cursor?: BKCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BKCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BKCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BKCategories.
     */
    distinct?: Enumerable<BKCategoryScalarFieldEnum>
  }

  /**
   * BKCategory findFirst
   */
  export interface BKCategoryFindFirstArgs extends BKCategoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BKCategory findFirstOrThrow
   */
  export type BKCategoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BKCategory
     */
    select?: BKCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKCategoryInclude | null
    /**
     * Filter, which BKCategory to fetch.
     */
    where?: BKCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BKCategories to fetch.
     */
    orderBy?: Enumerable<BKCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BKCategories.
     */
    cursor?: BKCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BKCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BKCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BKCategories.
     */
    distinct?: Enumerable<BKCategoryScalarFieldEnum>
  }


  /**
   * BKCategory findMany
   */
  export type BKCategoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the BKCategory
     */
    select?: BKCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKCategoryInclude | null
    /**
     * Filter, which BKCategories to fetch.
     */
    where?: BKCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BKCategories to fetch.
     */
    orderBy?: Enumerable<BKCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BKCategories.
     */
    cursor?: BKCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BKCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BKCategories.
     */
    skip?: number
    distinct?: Enumerable<BKCategoryScalarFieldEnum>
  }


  /**
   * BKCategory create
   */
  export type BKCategoryCreateArgs = {
    /**
     * Select specific fields to fetch from the BKCategory
     */
    select?: BKCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKCategoryInclude | null
    /**
     * The data needed to create a BKCategory.
     */
    data: XOR<BKCategoryCreateInput, BKCategoryUncheckedCreateInput>
  }


  /**
   * BKCategory createMany
   */
  export type BKCategoryCreateManyArgs = {
    /**
     * The data used to create many BKCategories.
     */
    data: Enumerable<BKCategoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BKCategory update
   */
  export type BKCategoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the BKCategory
     */
    select?: BKCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKCategoryInclude | null
    /**
     * The data needed to update a BKCategory.
     */
    data: XOR<BKCategoryUpdateInput, BKCategoryUncheckedUpdateInput>
    /**
     * Choose, which BKCategory to update.
     */
    where: BKCategoryWhereUniqueInput
  }


  /**
   * BKCategory updateMany
   */
  export type BKCategoryUpdateManyArgs = {
    /**
     * The data used to update BKCategories.
     */
    data: XOR<BKCategoryUpdateManyMutationInput, BKCategoryUncheckedUpdateManyInput>
    /**
     * Filter which BKCategories to update
     */
    where?: BKCategoryWhereInput
  }


  /**
   * BKCategory upsert
   */
  export type BKCategoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the BKCategory
     */
    select?: BKCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKCategoryInclude | null
    /**
     * The filter to search for the BKCategory to update in case it exists.
     */
    where: BKCategoryWhereUniqueInput
    /**
     * In case the BKCategory found by the `where` argument doesn't exist, create a new BKCategory with this data.
     */
    create: XOR<BKCategoryCreateInput, BKCategoryUncheckedCreateInput>
    /**
     * In case the BKCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BKCategoryUpdateInput, BKCategoryUncheckedUpdateInput>
  }


  /**
   * BKCategory delete
   */
  export type BKCategoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the BKCategory
     */
    select?: BKCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKCategoryInclude | null
    /**
     * Filter which BKCategory to delete.
     */
    where: BKCategoryWhereUniqueInput
  }


  /**
   * BKCategory deleteMany
   */
  export type BKCategoryDeleteManyArgs = {
    /**
     * Filter which BKCategories to delete
     */
    where?: BKCategoryWhereInput
  }


  /**
   * BKCategory.titleToCategories
   */
  export type BKCategory$titleToCategoriesArgs = {
    /**
     * Select specific fields to fetch from the TitleToCategory
     */
    select?: TitleToCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TitleToCategoryInclude | null
    where?: TitleToCategoryWhereInput
    orderBy?: Enumerable<TitleToCategoryOrderByWithRelationInput>
    cursor?: TitleToCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TitleToCategoryScalarFieldEnum>
  }


  /**
   * BKCategory without action
   */
  export type BKCategoryArgs = {
    /**
     * Select specific fields to fetch from the BKCategory
     */
    select?: BKCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKCategoryInclude | null
  }



  /**
   * Model TitleToCategory
   */


  export type AggregateTitleToCategory = {
    _count: TitleToCategoryCountAggregateOutputType | null
    _avg: TitleToCategoryAvgAggregateOutputType | null
    _sum: TitleToCategorySumAggregateOutputType | null
    _min: TitleToCategoryMinAggregateOutputType | null
    _max: TitleToCategoryMaxAggregateOutputType | null
  }

  export type TitleToCategoryAvgAggregateOutputType = {
    id: number | null
    titleId: number | null
    categoryId: number | null
  }

  export type TitleToCategorySumAggregateOutputType = {
    id: number | null
    titleId: number | null
    categoryId: number | null
  }

  export type TitleToCategoryMinAggregateOutputType = {
    id: number | null
    titleId: number | null
    categoryId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TitleToCategoryMaxAggregateOutputType = {
    id: number | null
    titleId: number | null
    categoryId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TitleToCategoryCountAggregateOutputType = {
    id: number
    titleId: number
    categoryId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TitleToCategoryAvgAggregateInputType = {
    id?: true
    titleId?: true
    categoryId?: true
  }

  export type TitleToCategorySumAggregateInputType = {
    id?: true
    titleId?: true
    categoryId?: true
  }

  export type TitleToCategoryMinAggregateInputType = {
    id?: true
    titleId?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TitleToCategoryMaxAggregateInputType = {
    id?: true
    titleId?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TitleToCategoryCountAggregateInputType = {
    id?: true
    titleId?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TitleToCategoryAggregateArgs = {
    /**
     * Filter which TitleToCategory to aggregate.
     */
    where?: TitleToCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TitleToCategories to fetch.
     */
    orderBy?: Enumerable<TitleToCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TitleToCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TitleToCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TitleToCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TitleToCategories
    **/
    _count?: true | TitleToCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TitleToCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TitleToCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TitleToCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TitleToCategoryMaxAggregateInputType
  }

  export type GetTitleToCategoryAggregateType<T extends TitleToCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateTitleToCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTitleToCategory[P]>
      : GetScalarType<T[P], AggregateTitleToCategory[P]>
  }




  export type TitleToCategoryGroupByArgs = {
    where?: TitleToCategoryWhereInput
    orderBy?: Enumerable<TitleToCategoryOrderByWithAggregationInput>
    by: TitleToCategoryScalarFieldEnum[]
    having?: TitleToCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TitleToCategoryCountAggregateInputType | true
    _avg?: TitleToCategoryAvgAggregateInputType
    _sum?: TitleToCategorySumAggregateInputType
    _min?: TitleToCategoryMinAggregateInputType
    _max?: TitleToCategoryMaxAggregateInputType
  }


  export type TitleToCategoryGroupByOutputType = {
    id: number
    titleId: number
    categoryId: number
    createdAt: Date
    updatedAt: Date
    _count: TitleToCategoryCountAggregateOutputType | null
    _avg: TitleToCategoryAvgAggregateOutputType | null
    _sum: TitleToCategorySumAggregateOutputType | null
    _min: TitleToCategoryMinAggregateOutputType | null
    _max: TitleToCategoryMaxAggregateOutputType | null
  }

  type GetTitleToCategoryGroupByPayload<T extends TitleToCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TitleToCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TitleToCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TitleToCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], TitleToCategoryGroupByOutputType[P]>
        }
      >
    >


  export type TitleToCategorySelect = {
    id?: boolean
    title?: boolean | BKTitleArgs
    titleId?: boolean
    category?: boolean | BKCategoryArgs
    categoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type TitleToCategoryInclude = {
    title?: boolean | BKTitleArgs
    category?: boolean | BKCategoryArgs
  }

  export type TitleToCategoryGetPayload<S extends boolean | null | undefined | TitleToCategoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TitleToCategory :
    S extends undefined ? never :
    S extends { include: any } & (TitleToCategoryArgs | TitleToCategoryFindManyArgs)
    ? TitleToCategory  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'title' ? BKTitleGetPayload<S['include'][P]> :
        P extends 'category' ? BKCategoryGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TitleToCategoryArgs | TitleToCategoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'title' ? BKTitleGetPayload<S['select'][P]> :
        P extends 'category' ? BKCategoryGetPayload<S['select'][P]> :  P extends keyof TitleToCategory ? TitleToCategory[P] : never
  } 
      : TitleToCategory


  type TitleToCategoryCountArgs = 
    Omit<TitleToCategoryFindManyArgs, 'select' | 'include'> & {
      select?: TitleToCategoryCountAggregateInputType | true
    }

  export interface TitleToCategoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TitleToCategory that matches the filter.
     * @param {TitleToCategoryFindUniqueArgs} args - Arguments to find a TitleToCategory
     * @example
     * // Get one TitleToCategory
     * const titleToCategory = await prisma.titleToCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TitleToCategoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TitleToCategoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TitleToCategory'> extends True ? Prisma__TitleToCategoryClient<TitleToCategoryGetPayload<T>> : Prisma__TitleToCategoryClient<TitleToCategoryGetPayload<T> | null, null>

    /**
     * Find one TitleToCategory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TitleToCategoryFindUniqueOrThrowArgs} args - Arguments to find a TitleToCategory
     * @example
     * // Get one TitleToCategory
     * const titleToCategory = await prisma.titleToCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TitleToCategoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TitleToCategoryFindUniqueOrThrowArgs>
    ): Prisma__TitleToCategoryClient<TitleToCategoryGetPayload<T>>

    /**
     * Find the first TitleToCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TitleToCategoryFindFirstArgs} args - Arguments to find a TitleToCategory
     * @example
     * // Get one TitleToCategory
     * const titleToCategory = await prisma.titleToCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TitleToCategoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TitleToCategoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TitleToCategory'> extends True ? Prisma__TitleToCategoryClient<TitleToCategoryGetPayload<T>> : Prisma__TitleToCategoryClient<TitleToCategoryGetPayload<T> | null, null>

    /**
     * Find the first TitleToCategory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TitleToCategoryFindFirstOrThrowArgs} args - Arguments to find a TitleToCategory
     * @example
     * // Get one TitleToCategory
     * const titleToCategory = await prisma.titleToCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TitleToCategoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TitleToCategoryFindFirstOrThrowArgs>
    ): Prisma__TitleToCategoryClient<TitleToCategoryGetPayload<T>>

    /**
     * Find zero or more TitleToCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TitleToCategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TitleToCategories
     * const titleToCategories = await prisma.titleToCategory.findMany()
     * 
     * // Get first 10 TitleToCategories
     * const titleToCategories = await prisma.titleToCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const titleToCategoryWithIdOnly = await prisma.titleToCategory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TitleToCategoryFindManyArgs>(
      args?: SelectSubset<T, TitleToCategoryFindManyArgs>
    ): Prisma.PrismaPromise<Array<TitleToCategoryGetPayload<T>>>

    /**
     * Create a TitleToCategory.
     * @param {TitleToCategoryCreateArgs} args - Arguments to create a TitleToCategory.
     * @example
     * // Create one TitleToCategory
     * const TitleToCategory = await prisma.titleToCategory.create({
     *   data: {
     *     // ... data to create a TitleToCategory
     *   }
     * })
     * 
    **/
    create<T extends TitleToCategoryCreateArgs>(
      args: SelectSubset<T, TitleToCategoryCreateArgs>
    ): Prisma__TitleToCategoryClient<TitleToCategoryGetPayload<T>>

    /**
     * Create many TitleToCategories.
     *     @param {TitleToCategoryCreateManyArgs} args - Arguments to create many TitleToCategories.
     *     @example
     *     // Create many TitleToCategories
     *     const titleToCategory = await prisma.titleToCategory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TitleToCategoryCreateManyArgs>(
      args?: SelectSubset<T, TitleToCategoryCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TitleToCategory.
     * @param {TitleToCategoryDeleteArgs} args - Arguments to delete one TitleToCategory.
     * @example
     * // Delete one TitleToCategory
     * const TitleToCategory = await prisma.titleToCategory.delete({
     *   where: {
     *     // ... filter to delete one TitleToCategory
     *   }
     * })
     * 
    **/
    delete<T extends TitleToCategoryDeleteArgs>(
      args: SelectSubset<T, TitleToCategoryDeleteArgs>
    ): Prisma__TitleToCategoryClient<TitleToCategoryGetPayload<T>>

    /**
     * Update one TitleToCategory.
     * @param {TitleToCategoryUpdateArgs} args - Arguments to update one TitleToCategory.
     * @example
     * // Update one TitleToCategory
     * const titleToCategory = await prisma.titleToCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TitleToCategoryUpdateArgs>(
      args: SelectSubset<T, TitleToCategoryUpdateArgs>
    ): Prisma__TitleToCategoryClient<TitleToCategoryGetPayload<T>>

    /**
     * Delete zero or more TitleToCategories.
     * @param {TitleToCategoryDeleteManyArgs} args - Arguments to filter TitleToCategories to delete.
     * @example
     * // Delete a few TitleToCategories
     * const { count } = await prisma.titleToCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TitleToCategoryDeleteManyArgs>(
      args?: SelectSubset<T, TitleToCategoryDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TitleToCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TitleToCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TitleToCategories
     * const titleToCategory = await prisma.titleToCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TitleToCategoryUpdateManyArgs>(
      args: SelectSubset<T, TitleToCategoryUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TitleToCategory.
     * @param {TitleToCategoryUpsertArgs} args - Arguments to update or create a TitleToCategory.
     * @example
     * // Update or create a TitleToCategory
     * const titleToCategory = await prisma.titleToCategory.upsert({
     *   create: {
     *     // ... data to create a TitleToCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TitleToCategory we want to update
     *   }
     * })
    **/
    upsert<T extends TitleToCategoryUpsertArgs>(
      args: SelectSubset<T, TitleToCategoryUpsertArgs>
    ): Prisma__TitleToCategoryClient<TitleToCategoryGetPayload<T>>

    /**
     * Count the number of TitleToCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TitleToCategoryCountArgs} args - Arguments to filter TitleToCategories to count.
     * @example
     * // Count the number of TitleToCategories
     * const count = await prisma.titleToCategory.count({
     *   where: {
     *     // ... the filter for the TitleToCategories we want to count
     *   }
     * })
    **/
    count<T extends TitleToCategoryCountArgs>(
      args?: Subset<T, TitleToCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TitleToCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TitleToCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TitleToCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TitleToCategoryAggregateArgs>(args: Subset<T, TitleToCategoryAggregateArgs>): Prisma.PrismaPromise<GetTitleToCategoryAggregateType<T>>

    /**
     * Group by TitleToCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TitleToCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TitleToCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TitleToCategoryGroupByArgs['orderBy'] }
        : { orderBy?: TitleToCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TitleToCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTitleToCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TitleToCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TitleToCategoryClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    title<T extends BKTitleArgs= {}>(args?: Subset<T, BKTitleArgs>): Prisma__BKTitleClient<BKTitleGetPayload<T> | Null>;

    category<T extends BKCategoryArgs= {}>(args?: Subset<T, BKCategoryArgs>): Prisma__BKCategoryClient<BKCategoryGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TitleToCategory base type for findUnique actions
   */
  export type TitleToCategoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TitleToCategory
     */
    select?: TitleToCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TitleToCategoryInclude | null
    /**
     * Filter, which TitleToCategory to fetch.
     */
    where: TitleToCategoryWhereUniqueInput
  }

  /**
   * TitleToCategory findUnique
   */
  export interface TitleToCategoryFindUniqueArgs extends TitleToCategoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TitleToCategory findUniqueOrThrow
   */
  export type TitleToCategoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TitleToCategory
     */
    select?: TitleToCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TitleToCategoryInclude | null
    /**
     * Filter, which TitleToCategory to fetch.
     */
    where: TitleToCategoryWhereUniqueInput
  }


  /**
   * TitleToCategory base type for findFirst actions
   */
  export type TitleToCategoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TitleToCategory
     */
    select?: TitleToCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TitleToCategoryInclude | null
    /**
     * Filter, which TitleToCategory to fetch.
     */
    where?: TitleToCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TitleToCategories to fetch.
     */
    orderBy?: Enumerable<TitleToCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TitleToCategories.
     */
    cursor?: TitleToCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TitleToCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TitleToCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TitleToCategories.
     */
    distinct?: Enumerable<TitleToCategoryScalarFieldEnum>
  }

  /**
   * TitleToCategory findFirst
   */
  export interface TitleToCategoryFindFirstArgs extends TitleToCategoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TitleToCategory findFirstOrThrow
   */
  export type TitleToCategoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TitleToCategory
     */
    select?: TitleToCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TitleToCategoryInclude | null
    /**
     * Filter, which TitleToCategory to fetch.
     */
    where?: TitleToCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TitleToCategories to fetch.
     */
    orderBy?: Enumerable<TitleToCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TitleToCategories.
     */
    cursor?: TitleToCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TitleToCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TitleToCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TitleToCategories.
     */
    distinct?: Enumerable<TitleToCategoryScalarFieldEnum>
  }


  /**
   * TitleToCategory findMany
   */
  export type TitleToCategoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the TitleToCategory
     */
    select?: TitleToCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TitleToCategoryInclude | null
    /**
     * Filter, which TitleToCategories to fetch.
     */
    where?: TitleToCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TitleToCategories to fetch.
     */
    orderBy?: Enumerable<TitleToCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TitleToCategories.
     */
    cursor?: TitleToCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TitleToCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TitleToCategories.
     */
    skip?: number
    distinct?: Enumerable<TitleToCategoryScalarFieldEnum>
  }


  /**
   * TitleToCategory create
   */
  export type TitleToCategoryCreateArgs = {
    /**
     * Select specific fields to fetch from the TitleToCategory
     */
    select?: TitleToCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TitleToCategoryInclude | null
    /**
     * The data needed to create a TitleToCategory.
     */
    data: XOR<TitleToCategoryCreateInput, TitleToCategoryUncheckedCreateInput>
  }


  /**
   * TitleToCategory createMany
   */
  export type TitleToCategoryCreateManyArgs = {
    /**
     * The data used to create many TitleToCategories.
     */
    data: Enumerable<TitleToCategoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TitleToCategory update
   */
  export type TitleToCategoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the TitleToCategory
     */
    select?: TitleToCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TitleToCategoryInclude | null
    /**
     * The data needed to update a TitleToCategory.
     */
    data: XOR<TitleToCategoryUpdateInput, TitleToCategoryUncheckedUpdateInput>
    /**
     * Choose, which TitleToCategory to update.
     */
    where: TitleToCategoryWhereUniqueInput
  }


  /**
   * TitleToCategory updateMany
   */
  export type TitleToCategoryUpdateManyArgs = {
    /**
     * The data used to update TitleToCategories.
     */
    data: XOR<TitleToCategoryUpdateManyMutationInput, TitleToCategoryUncheckedUpdateManyInput>
    /**
     * Filter which TitleToCategories to update
     */
    where?: TitleToCategoryWhereInput
  }


  /**
   * TitleToCategory upsert
   */
  export type TitleToCategoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the TitleToCategory
     */
    select?: TitleToCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TitleToCategoryInclude | null
    /**
     * The filter to search for the TitleToCategory to update in case it exists.
     */
    where: TitleToCategoryWhereUniqueInput
    /**
     * In case the TitleToCategory found by the `where` argument doesn't exist, create a new TitleToCategory with this data.
     */
    create: XOR<TitleToCategoryCreateInput, TitleToCategoryUncheckedCreateInput>
    /**
     * In case the TitleToCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TitleToCategoryUpdateInput, TitleToCategoryUncheckedUpdateInput>
  }


  /**
   * TitleToCategory delete
   */
  export type TitleToCategoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the TitleToCategory
     */
    select?: TitleToCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TitleToCategoryInclude | null
    /**
     * Filter which TitleToCategory to delete.
     */
    where: TitleToCategoryWhereUniqueInput
  }


  /**
   * TitleToCategory deleteMany
   */
  export type TitleToCategoryDeleteManyArgs = {
    /**
     * Filter which TitleToCategories to delete
     */
    where?: TitleToCategoryWhereInput
  }


  /**
   * TitleToCategory without action
   */
  export type TitleToCategoryArgs = {
    /**
     * Select specific fields to fetch from the TitleToCategory
     */
    select?: TitleToCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TitleToCategoryInclude | null
  }



  /**
   * Model BKAuthor
   */


  export type AggregateBKAuthor = {
    _count: BKAuthorCountAggregateOutputType | null
    _avg: BKAuthorAvgAggregateOutputType | null
    _sum: BKAuthorSumAggregateOutputType | null
    _min: BKAuthorMinAggregateOutputType | null
    _max: BKAuthorMaxAggregateOutputType | null
  }

  export type BKAuthorAvgAggregateOutputType = {
    id: number | null
  }

  export type BKAuthorSumAggregateOutputType = {
    id: number | null
  }

  export type BKAuthorMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BKAuthorMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BKAuthorCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BKAuthorAvgAggregateInputType = {
    id?: true
  }

  export type BKAuthorSumAggregateInputType = {
    id?: true
  }

  export type BKAuthorMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BKAuthorMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BKAuthorCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BKAuthorAggregateArgs = {
    /**
     * Filter which BKAuthor to aggregate.
     */
    where?: BKAuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BKAuthors to fetch.
     */
    orderBy?: Enumerable<BKAuthorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BKAuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BKAuthors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BKAuthors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BKAuthors
    **/
    _count?: true | BKAuthorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BKAuthorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BKAuthorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BKAuthorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BKAuthorMaxAggregateInputType
  }

  export type GetBKAuthorAggregateType<T extends BKAuthorAggregateArgs> = {
        [P in keyof T & keyof AggregateBKAuthor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBKAuthor[P]>
      : GetScalarType<T[P], AggregateBKAuthor[P]>
  }




  export type BKAuthorGroupByArgs = {
    where?: BKAuthorWhereInput
    orderBy?: Enumerable<BKAuthorOrderByWithAggregationInput>
    by: BKAuthorScalarFieldEnum[]
    having?: BKAuthorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BKAuthorCountAggregateInputType | true
    _avg?: BKAuthorAvgAggregateInputType
    _sum?: BKAuthorSumAggregateInputType
    _min?: BKAuthorMinAggregateInputType
    _max?: BKAuthorMaxAggregateInputType
  }


  export type BKAuthorGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: BKAuthorCountAggregateOutputType | null
    _avg: BKAuthorAvgAggregateOutputType | null
    _sum: BKAuthorSumAggregateOutputType | null
    _min: BKAuthorMinAggregateOutputType | null
    _max: BKAuthorMaxAggregateOutputType | null
  }

  type GetBKAuthorGroupByPayload<T extends BKAuthorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BKAuthorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BKAuthorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BKAuthorGroupByOutputType[P]>
            : GetScalarType<T[P], BKAuthorGroupByOutputType[P]>
        }
      >
    >


  export type BKAuthorSelect = {
    id?: boolean
    name?: boolean
    titleToAuthors?: boolean | BKAuthor$titleToAuthorsArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | BKAuthorCountOutputTypeArgs
  }


  export type BKAuthorInclude = {
    titleToAuthors?: boolean | BKAuthor$titleToAuthorsArgs
    _count?: boolean | BKAuthorCountOutputTypeArgs
  }

  export type BKAuthorGetPayload<S extends boolean | null | undefined | BKAuthorArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BKAuthor :
    S extends undefined ? never :
    S extends { include: any } & (BKAuthorArgs | BKAuthorFindManyArgs)
    ? BKAuthor  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'titleToAuthors' ? Array < TitleToAuthorGetPayload<S['include'][P]>>  :
        P extends '_count' ? BKAuthorCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BKAuthorArgs | BKAuthorFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'titleToAuthors' ? Array < TitleToAuthorGetPayload<S['select'][P]>>  :
        P extends '_count' ? BKAuthorCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof BKAuthor ? BKAuthor[P] : never
  } 
      : BKAuthor


  type BKAuthorCountArgs = 
    Omit<BKAuthorFindManyArgs, 'select' | 'include'> & {
      select?: BKAuthorCountAggregateInputType | true
    }

  export interface BKAuthorDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one BKAuthor that matches the filter.
     * @param {BKAuthorFindUniqueArgs} args - Arguments to find a BKAuthor
     * @example
     * // Get one BKAuthor
     * const bKAuthor = await prisma.bKAuthor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BKAuthorFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BKAuthorFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BKAuthor'> extends True ? Prisma__BKAuthorClient<BKAuthorGetPayload<T>> : Prisma__BKAuthorClient<BKAuthorGetPayload<T> | null, null>

    /**
     * Find one BKAuthor that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BKAuthorFindUniqueOrThrowArgs} args - Arguments to find a BKAuthor
     * @example
     * // Get one BKAuthor
     * const bKAuthor = await prisma.bKAuthor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BKAuthorFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BKAuthorFindUniqueOrThrowArgs>
    ): Prisma__BKAuthorClient<BKAuthorGetPayload<T>>

    /**
     * Find the first BKAuthor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKAuthorFindFirstArgs} args - Arguments to find a BKAuthor
     * @example
     * // Get one BKAuthor
     * const bKAuthor = await prisma.bKAuthor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BKAuthorFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BKAuthorFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BKAuthor'> extends True ? Prisma__BKAuthorClient<BKAuthorGetPayload<T>> : Prisma__BKAuthorClient<BKAuthorGetPayload<T> | null, null>

    /**
     * Find the first BKAuthor that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKAuthorFindFirstOrThrowArgs} args - Arguments to find a BKAuthor
     * @example
     * // Get one BKAuthor
     * const bKAuthor = await prisma.bKAuthor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BKAuthorFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BKAuthorFindFirstOrThrowArgs>
    ): Prisma__BKAuthorClient<BKAuthorGetPayload<T>>

    /**
     * Find zero or more BKAuthors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKAuthorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BKAuthors
     * const bKAuthors = await prisma.bKAuthor.findMany()
     * 
     * // Get first 10 BKAuthors
     * const bKAuthors = await prisma.bKAuthor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bKAuthorWithIdOnly = await prisma.bKAuthor.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BKAuthorFindManyArgs>(
      args?: SelectSubset<T, BKAuthorFindManyArgs>
    ): Prisma.PrismaPromise<Array<BKAuthorGetPayload<T>>>

    /**
     * Create a BKAuthor.
     * @param {BKAuthorCreateArgs} args - Arguments to create a BKAuthor.
     * @example
     * // Create one BKAuthor
     * const BKAuthor = await prisma.bKAuthor.create({
     *   data: {
     *     // ... data to create a BKAuthor
     *   }
     * })
     * 
    **/
    create<T extends BKAuthorCreateArgs>(
      args: SelectSubset<T, BKAuthorCreateArgs>
    ): Prisma__BKAuthorClient<BKAuthorGetPayload<T>>

    /**
     * Create many BKAuthors.
     *     @param {BKAuthorCreateManyArgs} args - Arguments to create many BKAuthors.
     *     @example
     *     // Create many BKAuthors
     *     const bKAuthor = await prisma.bKAuthor.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BKAuthorCreateManyArgs>(
      args?: SelectSubset<T, BKAuthorCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BKAuthor.
     * @param {BKAuthorDeleteArgs} args - Arguments to delete one BKAuthor.
     * @example
     * // Delete one BKAuthor
     * const BKAuthor = await prisma.bKAuthor.delete({
     *   where: {
     *     // ... filter to delete one BKAuthor
     *   }
     * })
     * 
    **/
    delete<T extends BKAuthorDeleteArgs>(
      args: SelectSubset<T, BKAuthorDeleteArgs>
    ): Prisma__BKAuthorClient<BKAuthorGetPayload<T>>

    /**
     * Update one BKAuthor.
     * @param {BKAuthorUpdateArgs} args - Arguments to update one BKAuthor.
     * @example
     * // Update one BKAuthor
     * const bKAuthor = await prisma.bKAuthor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BKAuthorUpdateArgs>(
      args: SelectSubset<T, BKAuthorUpdateArgs>
    ): Prisma__BKAuthorClient<BKAuthorGetPayload<T>>

    /**
     * Delete zero or more BKAuthors.
     * @param {BKAuthorDeleteManyArgs} args - Arguments to filter BKAuthors to delete.
     * @example
     * // Delete a few BKAuthors
     * const { count } = await prisma.bKAuthor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BKAuthorDeleteManyArgs>(
      args?: SelectSubset<T, BKAuthorDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BKAuthors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKAuthorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BKAuthors
     * const bKAuthor = await prisma.bKAuthor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BKAuthorUpdateManyArgs>(
      args: SelectSubset<T, BKAuthorUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BKAuthor.
     * @param {BKAuthorUpsertArgs} args - Arguments to update or create a BKAuthor.
     * @example
     * // Update or create a BKAuthor
     * const bKAuthor = await prisma.bKAuthor.upsert({
     *   create: {
     *     // ... data to create a BKAuthor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BKAuthor we want to update
     *   }
     * })
    **/
    upsert<T extends BKAuthorUpsertArgs>(
      args: SelectSubset<T, BKAuthorUpsertArgs>
    ): Prisma__BKAuthorClient<BKAuthorGetPayload<T>>

    /**
     * Count the number of BKAuthors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKAuthorCountArgs} args - Arguments to filter BKAuthors to count.
     * @example
     * // Count the number of BKAuthors
     * const count = await prisma.bKAuthor.count({
     *   where: {
     *     // ... the filter for the BKAuthors we want to count
     *   }
     * })
    **/
    count<T extends BKAuthorCountArgs>(
      args?: Subset<T, BKAuthorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BKAuthorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BKAuthor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKAuthorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BKAuthorAggregateArgs>(args: Subset<T, BKAuthorAggregateArgs>): Prisma.PrismaPromise<GetBKAuthorAggregateType<T>>

    /**
     * Group by BKAuthor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BKAuthorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BKAuthorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BKAuthorGroupByArgs['orderBy'] }
        : { orderBy?: BKAuthorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BKAuthorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBKAuthorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BKAuthor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BKAuthorClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    titleToAuthors<T extends BKAuthor$titleToAuthorsArgs= {}>(args?: Subset<T, BKAuthor$titleToAuthorsArgs>): Prisma.PrismaPromise<Array<TitleToAuthorGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BKAuthor base type for findUnique actions
   */
  export type BKAuthorFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BKAuthor
     */
    select?: BKAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKAuthorInclude | null
    /**
     * Filter, which BKAuthor to fetch.
     */
    where: BKAuthorWhereUniqueInput
  }

  /**
   * BKAuthor findUnique
   */
  export interface BKAuthorFindUniqueArgs extends BKAuthorFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BKAuthor findUniqueOrThrow
   */
  export type BKAuthorFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BKAuthor
     */
    select?: BKAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKAuthorInclude | null
    /**
     * Filter, which BKAuthor to fetch.
     */
    where: BKAuthorWhereUniqueInput
  }


  /**
   * BKAuthor base type for findFirst actions
   */
  export type BKAuthorFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BKAuthor
     */
    select?: BKAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKAuthorInclude | null
    /**
     * Filter, which BKAuthor to fetch.
     */
    where?: BKAuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BKAuthors to fetch.
     */
    orderBy?: Enumerable<BKAuthorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BKAuthors.
     */
    cursor?: BKAuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BKAuthors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BKAuthors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BKAuthors.
     */
    distinct?: Enumerable<BKAuthorScalarFieldEnum>
  }

  /**
   * BKAuthor findFirst
   */
  export interface BKAuthorFindFirstArgs extends BKAuthorFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BKAuthor findFirstOrThrow
   */
  export type BKAuthorFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BKAuthor
     */
    select?: BKAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKAuthorInclude | null
    /**
     * Filter, which BKAuthor to fetch.
     */
    where?: BKAuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BKAuthors to fetch.
     */
    orderBy?: Enumerable<BKAuthorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BKAuthors.
     */
    cursor?: BKAuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BKAuthors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BKAuthors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BKAuthors.
     */
    distinct?: Enumerable<BKAuthorScalarFieldEnum>
  }


  /**
   * BKAuthor findMany
   */
  export type BKAuthorFindManyArgs = {
    /**
     * Select specific fields to fetch from the BKAuthor
     */
    select?: BKAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKAuthorInclude | null
    /**
     * Filter, which BKAuthors to fetch.
     */
    where?: BKAuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BKAuthors to fetch.
     */
    orderBy?: Enumerable<BKAuthorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BKAuthors.
     */
    cursor?: BKAuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BKAuthors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BKAuthors.
     */
    skip?: number
    distinct?: Enumerable<BKAuthorScalarFieldEnum>
  }


  /**
   * BKAuthor create
   */
  export type BKAuthorCreateArgs = {
    /**
     * Select specific fields to fetch from the BKAuthor
     */
    select?: BKAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKAuthorInclude | null
    /**
     * The data needed to create a BKAuthor.
     */
    data: XOR<BKAuthorCreateInput, BKAuthorUncheckedCreateInput>
  }


  /**
   * BKAuthor createMany
   */
  export type BKAuthorCreateManyArgs = {
    /**
     * The data used to create many BKAuthors.
     */
    data: Enumerable<BKAuthorCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BKAuthor update
   */
  export type BKAuthorUpdateArgs = {
    /**
     * Select specific fields to fetch from the BKAuthor
     */
    select?: BKAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKAuthorInclude | null
    /**
     * The data needed to update a BKAuthor.
     */
    data: XOR<BKAuthorUpdateInput, BKAuthorUncheckedUpdateInput>
    /**
     * Choose, which BKAuthor to update.
     */
    where: BKAuthorWhereUniqueInput
  }


  /**
   * BKAuthor updateMany
   */
  export type BKAuthorUpdateManyArgs = {
    /**
     * The data used to update BKAuthors.
     */
    data: XOR<BKAuthorUpdateManyMutationInput, BKAuthorUncheckedUpdateManyInput>
    /**
     * Filter which BKAuthors to update
     */
    where?: BKAuthorWhereInput
  }


  /**
   * BKAuthor upsert
   */
  export type BKAuthorUpsertArgs = {
    /**
     * Select specific fields to fetch from the BKAuthor
     */
    select?: BKAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKAuthorInclude | null
    /**
     * The filter to search for the BKAuthor to update in case it exists.
     */
    where: BKAuthorWhereUniqueInput
    /**
     * In case the BKAuthor found by the `where` argument doesn't exist, create a new BKAuthor with this data.
     */
    create: XOR<BKAuthorCreateInput, BKAuthorUncheckedCreateInput>
    /**
     * In case the BKAuthor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BKAuthorUpdateInput, BKAuthorUncheckedUpdateInput>
  }


  /**
   * BKAuthor delete
   */
  export type BKAuthorDeleteArgs = {
    /**
     * Select specific fields to fetch from the BKAuthor
     */
    select?: BKAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKAuthorInclude | null
    /**
     * Filter which BKAuthor to delete.
     */
    where: BKAuthorWhereUniqueInput
  }


  /**
   * BKAuthor deleteMany
   */
  export type BKAuthorDeleteManyArgs = {
    /**
     * Filter which BKAuthors to delete
     */
    where?: BKAuthorWhereInput
  }


  /**
   * BKAuthor.titleToAuthors
   */
  export type BKAuthor$titleToAuthorsArgs = {
    /**
     * Select specific fields to fetch from the TitleToAuthor
     */
    select?: TitleToAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TitleToAuthorInclude | null
    where?: TitleToAuthorWhereInput
    orderBy?: Enumerable<TitleToAuthorOrderByWithRelationInput>
    cursor?: TitleToAuthorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TitleToAuthorScalarFieldEnum>
  }


  /**
   * BKAuthor without action
   */
  export type BKAuthorArgs = {
    /**
     * Select specific fields to fetch from the BKAuthor
     */
    select?: BKAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BKAuthorInclude | null
  }



  /**
   * Model TitleToAuthor
   */


  export type AggregateTitleToAuthor = {
    _count: TitleToAuthorCountAggregateOutputType | null
    _avg: TitleToAuthorAvgAggregateOutputType | null
    _sum: TitleToAuthorSumAggregateOutputType | null
    _min: TitleToAuthorMinAggregateOutputType | null
    _max: TitleToAuthorMaxAggregateOutputType | null
  }

  export type TitleToAuthorAvgAggregateOutputType = {
    id: number | null
    titleId: number | null
    authorId: number | null
  }

  export type TitleToAuthorSumAggregateOutputType = {
    id: number | null
    titleId: number | null
    authorId: number | null
  }

  export type TitleToAuthorMinAggregateOutputType = {
    id: number | null
    titleId: number | null
    authorId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TitleToAuthorMaxAggregateOutputType = {
    id: number | null
    titleId: number | null
    authorId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TitleToAuthorCountAggregateOutputType = {
    id: number
    titleId: number
    authorId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TitleToAuthorAvgAggregateInputType = {
    id?: true
    titleId?: true
    authorId?: true
  }

  export type TitleToAuthorSumAggregateInputType = {
    id?: true
    titleId?: true
    authorId?: true
  }

  export type TitleToAuthorMinAggregateInputType = {
    id?: true
    titleId?: true
    authorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TitleToAuthorMaxAggregateInputType = {
    id?: true
    titleId?: true
    authorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TitleToAuthorCountAggregateInputType = {
    id?: true
    titleId?: true
    authorId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TitleToAuthorAggregateArgs = {
    /**
     * Filter which TitleToAuthor to aggregate.
     */
    where?: TitleToAuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TitleToAuthors to fetch.
     */
    orderBy?: Enumerable<TitleToAuthorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TitleToAuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TitleToAuthors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TitleToAuthors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TitleToAuthors
    **/
    _count?: true | TitleToAuthorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TitleToAuthorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TitleToAuthorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TitleToAuthorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TitleToAuthorMaxAggregateInputType
  }

  export type GetTitleToAuthorAggregateType<T extends TitleToAuthorAggregateArgs> = {
        [P in keyof T & keyof AggregateTitleToAuthor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTitleToAuthor[P]>
      : GetScalarType<T[P], AggregateTitleToAuthor[P]>
  }




  export type TitleToAuthorGroupByArgs = {
    where?: TitleToAuthorWhereInput
    orderBy?: Enumerable<TitleToAuthorOrderByWithAggregationInput>
    by: TitleToAuthorScalarFieldEnum[]
    having?: TitleToAuthorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TitleToAuthorCountAggregateInputType | true
    _avg?: TitleToAuthorAvgAggregateInputType
    _sum?: TitleToAuthorSumAggregateInputType
    _min?: TitleToAuthorMinAggregateInputType
    _max?: TitleToAuthorMaxAggregateInputType
  }


  export type TitleToAuthorGroupByOutputType = {
    id: number
    titleId: number
    authorId: number
    createdAt: Date
    updatedAt: Date
    _count: TitleToAuthorCountAggregateOutputType | null
    _avg: TitleToAuthorAvgAggregateOutputType | null
    _sum: TitleToAuthorSumAggregateOutputType | null
    _min: TitleToAuthorMinAggregateOutputType | null
    _max: TitleToAuthorMaxAggregateOutputType | null
  }

  type GetTitleToAuthorGroupByPayload<T extends TitleToAuthorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TitleToAuthorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TitleToAuthorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TitleToAuthorGroupByOutputType[P]>
            : GetScalarType<T[P], TitleToAuthorGroupByOutputType[P]>
        }
      >
    >


  export type TitleToAuthorSelect = {
    id?: boolean
    title?: boolean | BKTitleArgs
    titleId?: boolean
    author?: boolean | BKAuthorArgs
    authorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type TitleToAuthorInclude = {
    title?: boolean | BKTitleArgs
    author?: boolean | BKAuthorArgs
  }

  export type TitleToAuthorGetPayload<S extends boolean | null | undefined | TitleToAuthorArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TitleToAuthor :
    S extends undefined ? never :
    S extends { include: any } & (TitleToAuthorArgs | TitleToAuthorFindManyArgs)
    ? TitleToAuthor  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'title' ? BKTitleGetPayload<S['include'][P]> :
        P extends 'author' ? BKAuthorGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TitleToAuthorArgs | TitleToAuthorFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'title' ? BKTitleGetPayload<S['select'][P]> :
        P extends 'author' ? BKAuthorGetPayload<S['select'][P]> :  P extends keyof TitleToAuthor ? TitleToAuthor[P] : never
  } 
      : TitleToAuthor


  type TitleToAuthorCountArgs = 
    Omit<TitleToAuthorFindManyArgs, 'select' | 'include'> & {
      select?: TitleToAuthorCountAggregateInputType | true
    }

  export interface TitleToAuthorDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TitleToAuthor that matches the filter.
     * @param {TitleToAuthorFindUniqueArgs} args - Arguments to find a TitleToAuthor
     * @example
     * // Get one TitleToAuthor
     * const titleToAuthor = await prisma.titleToAuthor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TitleToAuthorFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TitleToAuthorFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TitleToAuthor'> extends True ? Prisma__TitleToAuthorClient<TitleToAuthorGetPayload<T>> : Prisma__TitleToAuthorClient<TitleToAuthorGetPayload<T> | null, null>

    /**
     * Find one TitleToAuthor that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TitleToAuthorFindUniqueOrThrowArgs} args - Arguments to find a TitleToAuthor
     * @example
     * // Get one TitleToAuthor
     * const titleToAuthor = await prisma.titleToAuthor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TitleToAuthorFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TitleToAuthorFindUniqueOrThrowArgs>
    ): Prisma__TitleToAuthorClient<TitleToAuthorGetPayload<T>>

    /**
     * Find the first TitleToAuthor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TitleToAuthorFindFirstArgs} args - Arguments to find a TitleToAuthor
     * @example
     * // Get one TitleToAuthor
     * const titleToAuthor = await prisma.titleToAuthor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TitleToAuthorFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TitleToAuthorFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TitleToAuthor'> extends True ? Prisma__TitleToAuthorClient<TitleToAuthorGetPayload<T>> : Prisma__TitleToAuthorClient<TitleToAuthorGetPayload<T> | null, null>

    /**
     * Find the first TitleToAuthor that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TitleToAuthorFindFirstOrThrowArgs} args - Arguments to find a TitleToAuthor
     * @example
     * // Get one TitleToAuthor
     * const titleToAuthor = await prisma.titleToAuthor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TitleToAuthorFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TitleToAuthorFindFirstOrThrowArgs>
    ): Prisma__TitleToAuthorClient<TitleToAuthorGetPayload<T>>

    /**
     * Find zero or more TitleToAuthors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TitleToAuthorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TitleToAuthors
     * const titleToAuthors = await prisma.titleToAuthor.findMany()
     * 
     * // Get first 10 TitleToAuthors
     * const titleToAuthors = await prisma.titleToAuthor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const titleToAuthorWithIdOnly = await prisma.titleToAuthor.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TitleToAuthorFindManyArgs>(
      args?: SelectSubset<T, TitleToAuthorFindManyArgs>
    ): Prisma.PrismaPromise<Array<TitleToAuthorGetPayload<T>>>

    /**
     * Create a TitleToAuthor.
     * @param {TitleToAuthorCreateArgs} args - Arguments to create a TitleToAuthor.
     * @example
     * // Create one TitleToAuthor
     * const TitleToAuthor = await prisma.titleToAuthor.create({
     *   data: {
     *     // ... data to create a TitleToAuthor
     *   }
     * })
     * 
    **/
    create<T extends TitleToAuthorCreateArgs>(
      args: SelectSubset<T, TitleToAuthorCreateArgs>
    ): Prisma__TitleToAuthorClient<TitleToAuthorGetPayload<T>>

    /**
     * Create many TitleToAuthors.
     *     @param {TitleToAuthorCreateManyArgs} args - Arguments to create many TitleToAuthors.
     *     @example
     *     // Create many TitleToAuthors
     *     const titleToAuthor = await prisma.titleToAuthor.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TitleToAuthorCreateManyArgs>(
      args?: SelectSubset<T, TitleToAuthorCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TitleToAuthor.
     * @param {TitleToAuthorDeleteArgs} args - Arguments to delete one TitleToAuthor.
     * @example
     * // Delete one TitleToAuthor
     * const TitleToAuthor = await prisma.titleToAuthor.delete({
     *   where: {
     *     // ... filter to delete one TitleToAuthor
     *   }
     * })
     * 
    **/
    delete<T extends TitleToAuthorDeleteArgs>(
      args: SelectSubset<T, TitleToAuthorDeleteArgs>
    ): Prisma__TitleToAuthorClient<TitleToAuthorGetPayload<T>>

    /**
     * Update one TitleToAuthor.
     * @param {TitleToAuthorUpdateArgs} args - Arguments to update one TitleToAuthor.
     * @example
     * // Update one TitleToAuthor
     * const titleToAuthor = await prisma.titleToAuthor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TitleToAuthorUpdateArgs>(
      args: SelectSubset<T, TitleToAuthorUpdateArgs>
    ): Prisma__TitleToAuthorClient<TitleToAuthorGetPayload<T>>

    /**
     * Delete zero or more TitleToAuthors.
     * @param {TitleToAuthorDeleteManyArgs} args - Arguments to filter TitleToAuthors to delete.
     * @example
     * // Delete a few TitleToAuthors
     * const { count } = await prisma.titleToAuthor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TitleToAuthorDeleteManyArgs>(
      args?: SelectSubset<T, TitleToAuthorDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TitleToAuthors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TitleToAuthorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TitleToAuthors
     * const titleToAuthor = await prisma.titleToAuthor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TitleToAuthorUpdateManyArgs>(
      args: SelectSubset<T, TitleToAuthorUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TitleToAuthor.
     * @param {TitleToAuthorUpsertArgs} args - Arguments to update or create a TitleToAuthor.
     * @example
     * // Update or create a TitleToAuthor
     * const titleToAuthor = await prisma.titleToAuthor.upsert({
     *   create: {
     *     // ... data to create a TitleToAuthor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TitleToAuthor we want to update
     *   }
     * })
    **/
    upsert<T extends TitleToAuthorUpsertArgs>(
      args: SelectSubset<T, TitleToAuthorUpsertArgs>
    ): Prisma__TitleToAuthorClient<TitleToAuthorGetPayload<T>>

    /**
     * Count the number of TitleToAuthors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TitleToAuthorCountArgs} args - Arguments to filter TitleToAuthors to count.
     * @example
     * // Count the number of TitleToAuthors
     * const count = await prisma.titleToAuthor.count({
     *   where: {
     *     // ... the filter for the TitleToAuthors we want to count
     *   }
     * })
    **/
    count<T extends TitleToAuthorCountArgs>(
      args?: Subset<T, TitleToAuthorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TitleToAuthorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TitleToAuthor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TitleToAuthorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TitleToAuthorAggregateArgs>(args: Subset<T, TitleToAuthorAggregateArgs>): Prisma.PrismaPromise<GetTitleToAuthorAggregateType<T>>

    /**
     * Group by TitleToAuthor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TitleToAuthorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TitleToAuthorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TitleToAuthorGroupByArgs['orderBy'] }
        : { orderBy?: TitleToAuthorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TitleToAuthorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTitleToAuthorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TitleToAuthor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TitleToAuthorClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    title<T extends BKTitleArgs= {}>(args?: Subset<T, BKTitleArgs>): Prisma__BKTitleClient<BKTitleGetPayload<T> | Null>;

    author<T extends BKAuthorArgs= {}>(args?: Subset<T, BKAuthorArgs>): Prisma__BKAuthorClient<BKAuthorGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TitleToAuthor base type for findUnique actions
   */
  export type TitleToAuthorFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TitleToAuthor
     */
    select?: TitleToAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TitleToAuthorInclude | null
    /**
     * Filter, which TitleToAuthor to fetch.
     */
    where: TitleToAuthorWhereUniqueInput
  }

  /**
   * TitleToAuthor findUnique
   */
  export interface TitleToAuthorFindUniqueArgs extends TitleToAuthorFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TitleToAuthor findUniqueOrThrow
   */
  export type TitleToAuthorFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TitleToAuthor
     */
    select?: TitleToAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TitleToAuthorInclude | null
    /**
     * Filter, which TitleToAuthor to fetch.
     */
    where: TitleToAuthorWhereUniqueInput
  }


  /**
   * TitleToAuthor base type for findFirst actions
   */
  export type TitleToAuthorFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TitleToAuthor
     */
    select?: TitleToAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TitleToAuthorInclude | null
    /**
     * Filter, which TitleToAuthor to fetch.
     */
    where?: TitleToAuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TitleToAuthors to fetch.
     */
    orderBy?: Enumerable<TitleToAuthorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TitleToAuthors.
     */
    cursor?: TitleToAuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TitleToAuthors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TitleToAuthors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TitleToAuthors.
     */
    distinct?: Enumerable<TitleToAuthorScalarFieldEnum>
  }

  /**
   * TitleToAuthor findFirst
   */
  export interface TitleToAuthorFindFirstArgs extends TitleToAuthorFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TitleToAuthor findFirstOrThrow
   */
  export type TitleToAuthorFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TitleToAuthor
     */
    select?: TitleToAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TitleToAuthorInclude | null
    /**
     * Filter, which TitleToAuthor to fetch.
     */
    where?: TitleToAuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TitleToAuthors to fetch.
     */
    orderBy?: Enumerable<TitleToAuthorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TitleToAuthors.
     */
    cursor?: TitleToAuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TitleToAuthors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TitleToAuthors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TitleToAuthors.
     */
    distinct?: Enumerable<TitleToAuthorScalarFieldEnum>
  }


  /**
   * TitleToAuthor findMany
   */
  export type TitleToAuthorFindManyArgs = {
    /**
     * Select specific fields to fetch from the TitleToAuthor
     */
    select?: TitleToAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TitleToAuthorInclude | null
    /**
     * Filter, which TitleToAuthors to fetch.
     */
    where?: TitleToAuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TitleToAuthors to fetch.
     */
    orderBy?: Enumerable<TitleToAuthorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TitleToAuthors.
     */
    cursor?: TitleToAuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TitleToAuthors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TitleToAuthors.
     */
    skip?: number
    distinct?: Enumerable<TitleToAuthorScalarFieldEnum>
  }


  /**
   * TitleToAuthor create
   */
  export type TitleToAuthorCreateArgs = {
    /**
     * Select specific fields to fetch from the TitleToAuthor
     */
    select?: TitleToAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TitleToAuthorInclude | null
    /**
     * The data needed to create a TitleToAuthor.
     */
    data: XOR<TitleToAuthorCreateInput, TitleToAuthorUncheckedCreateInput>
  }


  /**
   * TitleToAuthor createMany
   */
  export type TitleToAuthorCreateManyArgs = {
    /**
     * The data used to create many TitleToAuthors.
     */
    data: Enumerable<TitleToAuthorCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TitleToAuthor update
   */
  export type TitleToAuthorUpdateArgs = {
    /**
     * Select specific fields to fetch from the TitleToAuthor
     */
    select?: TitleToAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TitleToAuthorInclude | null
    /**
     * The data needed to update a TitleToAuthor.
     */
    data: XOR<TitleToAuthorUpdateInput, TitleToAuthorUncheckedUpdateInput>
    /**
     * Choose, which TitleToAuthor to update.
     */
    where: TitleToAuthorWhereUniqueInput
  }


  /**
   * TitleToAuthor updateMany
   */
  export type TitleToAuthorUpdateManyArgs = {
    /**
     * The data used to update TitleToAuthors.
     */
    data: XOR<TitleToAuthorUpdateManyMutationInput, TitleToAuthorUncheckedUpdateManyInput>
    /**
     * Filter which TitleToAuthors to update
     */
    where?: TitleToAuthorWhereInput
  }


  /**
   * TitleToAuthor upsert
   */
  export type TitleToAuthorUpsertArgs = {
    /**
     * Select specific fields to fetch from the TitleToAuthor
     */
    select?: TitleToAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TitleToAuthorInclude | null
    /**
     * The filter to search for the TitleToAuthor to update in case it exists.
     */
    where: TitleToAuthorWhereUniqueInput
    /**
     * In case the TitleToAuthor found by the `where` argument doesn't exist, create a new TitleToAuthor with this data.
     */
    create: XOR<TitleToAuthorCreateInput, TitleToAuthorUncheckedCreateInput>
    /**
     * In case the TitleToAuthor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TitleToAuthorUpdateInput, TitleToAuthorUncheckedUpdateInput>
  }


  /**
   * TitleToAuthor delete
   */
  export type TitleToAuthorDeleteArgs = {
    /**
     * Select specific fields to fetch from the TitleToAuthor
     */
    select?: TitleToAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TitleToAuthorInclude | null
    /**
     * Filter which TitleToAuthor to delete.
     */
    where: TitleToAuthorWhereUniqueInput
  }


  /**
   * TitleToAuthor deleteMany
   */
  export type TitleToAuthorDeleteManyArgs = {
    /**
     * Filter which TitleToAuthors to delete
     */
    where?: TitleToAuthorWhereInput
  }


  /**
   * TitleToAuthor without action
   */
  export type TitleToAuthorArgs = {
    /**
     * Select specific fields to fetch from the TitleToAuthor
     */
    select?: TitleToAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TitleToAuthorInclude | null
  }



  /**
   * Model FbUser
   */


  export type AggregateFbUser = {
    _count: FbUserCountAggregateOutputType | null
    _avg: FbUserAvgAggregateOutputType | null
    _sum: FbUserSumAggregateOutputType | null
    _min: FbUserMinAggregateOutputType | null
    _max: FbUserMaxAggregateOutputType | null
  }

  export type FbUserAvgAggregateOutputType = {
    id: number | null
  }

  export type FbUserSumAggregateOutputType = {
    id: number | null
  }

  export type FbUserMinAggregateOutputType = {
    id: number | null
    name: string | null
    image: string | null
    location: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FbUserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    image: string | null
    location: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FbUserCountAggregateOutputType = {
    id: number
    name: number
    image: number
    location: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FbUserAvgAggregateInputType = {
    id?: true
  }

  export type FbUserSumAggregateInputType = {
    id?: true
  }

  export type FbUserMinAggregateInputType = {
    id?: true
    name?: true
    image?: true
    location?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FbUserMaxAggregateInputType = {
    id?: true
    name?: true
    image?: true
    location?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FbUserCountAggregateInputType = {
    id?: true
    name?: true
    image?: true
    location?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FbUserAggregateArgs = {
    /**
     * Filter which FbUser to aggregate.
     */
    where?: FbUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbUsers to fetch.
     */
    orderBy?: Enumerable<FbUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FbUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FbUsers
    **/
    _count?: true | FbUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FbUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FbUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FbUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FbUserMaxAggregateInputType
  }

  export type GetFbUserAggregateType<T extends FbUserAggregateArgs> = {
        [P in keyof T & keyof AggregateFbUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFbUser[P]>
      : GetScalarType<T[P], AggregateFbUser[P]>
  }




  export type FbUserGroupByArgs = {
    where?: FbUserWhereInput
    orderBy?: Enumerable<FbUserOrderByWithAggregationInput>
    by: FbUserScalarFieldEnum[]
    having?: FbUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FbUserCountAggregateInputType | true
    _avg?: FbUserAvgAggregateInputType
    _sum?: FbUserSumAggregateInputType
    _min?: FbUserMinAggregateInputType
    _max?: FbUserMaxAggregateInputType
  }


  export type FbUserGroupByOutputType = {
    id: number
    name: string
    image: string
    location: string
    createdAt: Date
    updatedAt: Date
    _count: FbUserCountAggregateOutputType | null
    _avg: FbUserAvgAggregateOutputType | null
    _sum: FbUserSumAggregateOutputType | null
    _min: FbUserMinAggregateOutputType | null
    _max: FbUserMaxAggregateOutputType | null
  }

  type GetFbUserGroupByPayload<T extends FbUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FbUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FbUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FbUserGroupByOutputType[P]>
            : GetScalarType<T[P], FbUserGroupByOutputType[P]>
        }
      >
    >


  export type FbUserSelect = {
    id?: boolean
    name?: boolean
    image?: boolean
    location?: boolean
    posts?: boolean | FbUser$postsArgs
    createdAt?: boolean
    updatedAt?: boolean
    acceptFbFriends?: boolean | FbUser$acceptFbFriendsArgs
    requestFbFriends?: boolean | FbUser$requestFbFriendsArgs
    likes?: boolean | FbUser$likesArgs
    fromMessengers?: boolean | FbUser$fromMessengersArgs
    toMessengers?: boolean | FbUser$toMessengersArgs
    shares?: boolean | FbUser$sharesArgs
    comments?: boolean | FbUser$commentsArgs
    groupToUsers?: boolean | FbUser$groupToUsersArgs
    _count?: boolean | FbUserCountOutputTypeArgs
  }


  export type FbUserInclude = {
    posts?: boolean | FbUser$postsArgs
    acceptFbFriends?: boolean | FbUser$acceptFbFriendsArgs
    requestFbFriends?: boolean | FbUser$requestFbFriendsArgs
    likes?: boolean | FbUser$likesArgs
    fromMessengers?: boolean | FbUser$fromMessengersArgs
    toMessengers?: boolean | FbUser$toMessengersArgs
    shares?: boolean | FbUser$sharesArgs
    comments?: boolean | FbUser$commentsArgs
    groupToUsers?: boolean | FbUser$groupToUsersArgs
    _count?: boolean | FbUserCountOutputTypeArgs
  }

  export type FbUserGetPayload<S extends boolean | null | undefined | FbUserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FbUser :
    S extends undefined ? never :
    S extends { include: any } & (FbUserArgs | FbUserFindManyArgs)
    ? FbUser  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'posts' ? Array < FbPostGetPayload<S['include'][P]>>  :
        P extends 'acceptFbFriends' ? Array < FbfriendGetPayload<S['include'][P]>>  :
        P extends 'requestFbFriends' ? Array < FbfriendGetPayload<S['include'][P]>>  :
        P extends 'likes' ? Array < FbLikeGetPayload<S['include'][P]>>  :
        P extends 'fromMessengers' ? Array < FbMessengerGetPayload<S['include'][P]>>  :
        P extends 'toMessengers' ? Array < FbMessengerGetPayload<S['include'][P]>>  :
        P extends 'shares' ? Array < FbShareGetPayload<S['include'][P]>>  :
        P extends 'comments' ? Array < FbCommentGetPayload<S['include'][P]>>  :
        P extends 'groupToUsers' ? Array < GroupToUserGetPayload<S['include'][P]>>  :
        P extends '_count' ? FbUserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FbUserArgs | FbUserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'posts' ? Array < FbPostGetPayload<S['select'][P]>>  :
        P extends 'acceptFbFriends' ? Array < FbfriendGetPayload<S['select'][P]>>  :
        P extends 'requestFbFriends' ? Array < FbfriendGetPayload<S['select'][P]>>  :
        P extends 'likes' ? Array < FbLikeGetPayload<S['select'][P]>>  :
        P extends 'fromMessengers' ? Array < FbMessengerGetPayload<S['select'][P]>>  :
        P extends 'toMessengers' ? Array < FbMessengerGetPayload<S['select'][P]>>  :
        P extends 'shares' ? Array < FbShareGetPayload<S['select'][P]>>  :
        P extends 'comments' ? Array < FbCommentGetPayload<S['select'][P]>>  :
        P extends 'groupToUsers' ? Array < GroupToUserGetPayload<S['select'][P]>>  :
        P extends '_count' ? FbUserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof FbUser ? FbUser[P] : never
  } 
      : FbUser


  type FbUserCountArgs = 
    Omit<FbUserFindManyArgs, 'select' | 'include'> & {
      select?: FbUserCountAggregateInputType | true
    }

  export interface FbUserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one FbUser that matches the filter.
     * @param {FbUserFindUniqueArgs} args - Arguments to find a FbUser
     * @example
     * // Get one FbUser
     * const fbUser = await prisma.fbUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FbUserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FbUserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FbUser'> extends True ? Prisma__FbUserClient<FbUserGetPayload<T>> : Prisma__FbUserClient<FbUserGetPayload<T> | null, null>

    /**
     * Find one FbUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FbUserFindUniqueOrThrowArgs} args - Arguments to find a FbUser
     * @example
     * // Get one FbUser
     * const fbUser = await prisma.fbUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FbUserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FbUserFindUniqueOrThrowArgs>
    ): Prisma__FbUserClient<FbUserGetPayload<T>>

    /**
     * Find the first FbUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbUserFindFirstArgs} args - Arguments to find a FbUser
     * @example
     * // Get one FbUser
     * const fbUser = await prisma.fbUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FbUserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FbUserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FbUser'> extends True ? Prisma__FbUserClient<FbUserGetPayload<T>> : Prisma__FbUserClient<FbUserGetPayload<T> | null, null>

    /**
     * Find the first FbUser that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbUserFindFirstOrThrowArgs} args - Arguments to find a FbUser
     * @example
     * // Get one FbUser
     * const fbUser = await prisma.fbUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FbUserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FbUserFindFirstOrThrowArgs>
    ): Prisma__FbUserClient<FbUserGetPayload<T>>

    /**
     * Find zero or more FbUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FbUsers
     * const fbUsers = await prisma.fbUser.findMany()
     * 
     * // Get first 10 FbUsers
     * const fbUsers = await prisma.fbUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fbUserWithIdOnly = await prisma.fbUser.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FbUserFindManyArgs>(
      args?: SelectSubset<T, FbUserFindManyArgs>
    ): Prisma.PrismaPromise<Array<FbUserGetPayload<T>>>

    /**
     * Create a FbUser.
     * @param {FbUserCreateArgs} args - Arguments to create a FbUser.
     * @example
     * // Create one FbUser
     * const FbUser = await prisma.fbUser.create({
     *   data: {
     *     // ... data to create a FbUser
     *   }
     * })
     * 
    **/
    create<T extends FbUserCreateArgs>(
      args: SelectSubset<T, FbUserCreateArgs>
    ): Prisma__FbUserClient<FbUserGetPayload<T>>

    /**
     * Create many FbUsers.
     *     @param {FbUserCreateManyArgs} args - Arguments to create many FbUsers.
     *     @example
     *     // Create many FbUsers
     *     const fbUser = await prisma.fbUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FbUserCreateManyArgs>(
      args?: SelectSubset<T, FbUserCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FbUser.
     * @param {FbUserDeleteArgs} args - Arguments to delete one FbUser.
     * @example
     * // Delete one FbUser
     * const FbUser = await prisma.fbUser.delete({
     *   where: {
     *     // ... filter to delete one FbUser
     *   }
     * })
     * 
    **/
    delete<T extends FbUserDeleteArgs>(
      args: SelectSubset<T, FbUserDeleteArgs>
    ): Prisma__FbUserClient<FbUserGetPayload<T>>

    /**
     * Update one FbUser.
     * @param {FbUserUpdateArgs} args - Arguments to update one FbUser.
     * @example
     * // Update one FbUser
     * const fbUser = await prisma.fbUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FbUserUpdateArgs>(
      args: SelectSubset<T, FbUserUpdateArgs>
    ): Prisma__FbUserClient<FbUserGetPayload<T>>

    /**
     * Delete zero or more FbUsers.
     * @param {FbUserDeleteManyArgs} args - Arguments to filter FbUsers to delete.
     * @example
     * // Delete a few FbUsers
     * const { count } = await prisma.fbUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FbUserDeleteManyArgs>(
      args?: SelectSubset<T, FbUserDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FbUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FbUsers
     * const fbUser = await prisma.fbUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FbUserUpdateManyArgs>(
      args: SelectSubset<T, FbUserUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FbUser.
     * @param {FbUserUpsertArgs} args - Arguments to update or create a FbUser.
     * @example
     * // Update or create a FbUser
     * const fbUser = await prisma.fbUser.upsert({
     *   create: {
     *     // ... data to create a FbUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FbUser we want to update
     *   }
     * })
    **/
    upsert<T extends FbUserUpsertArgs>(
      args: SelectSubset<T, FbUserUpsertArgs>
    ): Prisma__FbUserClient<FbUserGetPayload<T>>

    /**
     * Count the number of FbUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbUserCountArgs} args - Arguments to filter FbUsers to count.
     * @example
     * // Count the number of FbUsers
     * const count = await prisma.fbUser.count({
     *   where: {
     *     // ... the filter for the FbUsers we want to count
     *   }
     * })
    **/
    count<T extends FbUserCountArgs>(
      args?: Subset<T, FbUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FbUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FbUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FbUserAggregateArgs>(args: Subset<T, FbUserAggregateArgs>): Prisma.PrismaPromise<GetFbUserAggregateType<T>>

    /**
     * Group by FbUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FbUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FbUserGroupByArgs['orderBy'] }
        : { orderBy?: FbUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FbUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFbUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FbUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FbUserClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    posts<T extends FbUser$postsArgs= {}>(args?: Subset<T, FbUser$postsArgs>): Prisma.PrismaPromise<Array<FbPostGetPayload<T>>| Null>;

    acceptFbFriends<T extends FbUser$acceptFbFriendsArgs= {}>(args?: Subset<T, FbUser$acceptFbFriendsArgs>): Prisma.PrismaPromise<Array<FbfriendGetPayload<T>>| Null>;

    requestFbFriends<T extends FbUser$requestFbFriendsArgs= {}>(args?: Subset<T, FbUser$requestFbFriendsArgs>): Prisma.PrismaPromise<Array<FbfriendGetPayload<T>>| Null>;

    likes<T extends FbUser$likesArgs= {}>(args?: Subset<T, FbUser$likesArgs>): Prisma.PrismaPromise<Array<FbLikeGetPayload<T>>| Null>;

    fromMessengers<T extends FbUser$fromMessengersArgs= {}>(args?: Subset<T, FbUser$fromMessengersArgs>): Prisma.PrismaPromise<Array<FbMessengerGetPayload<T>>| Null>;

    toMessengers<T extends FbUser$toMessengersArgs= {}>(args?: Subset<T, FbUser$toMessengersArgs>): Prisma.PrismaPromise<Array<FbMessengerGetPayload<T>>| Null>;

    shares<T extends FbUser$sharesArgs= {}>(args?: Subset<T, FbUser$sharesArgs>): Prisma.PrismaPromise<Array<FbShareGetPayload<T>>| Null>;

    comments<T extends FbUser$commentsArgs= {}>(args?: Subset<T, FbUser$commentsArgs>): Prisma.PrismaPromise<Array<FbCommentGetPayload<T>>| Null>;

    groupToUsers<T extends FbUser$groupToUsersArgs= {}>(args?: Subset<T, FbUser$groupToUsersArgs>): Prisma.PrismaPromise<Array<GroupToUserGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FbUser base type for findUnique actions
   */
  export type FbUserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FbUser
     */
    select?: FbUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbUserInclude | null
    /**
     * Filter, which FbUser to fetch.
     */
    where: FbUserWhereUniqueInput
  }

  /**
   * FbUser findUnique
   */
  export interface FbUserFindUniqueArgs extends FbUserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FbUser findUniqueOrThrow
   */
  export type FbUserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FbUser
     */
    select?: FbUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbUserInclude | null
    /**
     * Filter, which FbUser to fetch.
     */
    where: FbUserWhereUniqueInput
  }


  /**
   * FbUser base type for findFirst actions
   */
  export type FbUserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FbUser
     */
    select?: FbUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbUserInclude | null
    /**
     * Filter, which FbUser to fetch.
     */
    where?: FbUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbUsers to fetch.
     */
    orderBy?: Enumerable<FbUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FbUsers.
     */
    cursor?: FbUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FbUsers.
     */
    distinct?: Enumerable<FbUserScalarFieldEnum>
  }

  /**
   * FbUser findFirst
   */
  export interface FbUserFindFirstArgs extends FbUserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FbUser findFirstOrThrow
   */
  export type FbUserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FbUser
     */
    select?: FbUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbUserInclude | null
    /**
     * Filter, which FbUser to fetch.
     */
    where?: FbUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbUsers to fetch.
     */
    orderBy?: Enumerable<FbUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FbUsers.
     */
    cursor?: FbUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FbUsers.
     */
    distinct?: Enumerable<FbUserScalarFieldEnum>
  }


  /**
   * FbUser findMany
   */
  export type FbUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the FbUser
     */
    select?: FbUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbUserInclude | null
    /**
     * Filter, which FbUsers to fetch.
     */
    where?: FbUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbUsers to fetch.
     */
    orderBy?: Enumerable<FbUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FbUsers.
     */
    cursor?: FbUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbUsers.
     */
    skip?: number
    distinct?: Enumerable<FbUserScalarFieldEnum>
  }


  /**
   * FbUser create
   */
  export type FbUserCreateArgs = {
    /**
     * Select specific fields to fetch from the FbUser
     */
    select?: FbUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbUserInclude | null
    /**
     * The data needed to create a FbUser.
     */
    data: XOR<FbUserCreateInput, FbUserUncheckedCreateInput>
  }


  /**
   * FbUser createMany
   */
  export type FbUserCreateManyArgs = {
    /**
     * The data used to create many FbUsers.
     */
    data: Enumerable<FbUserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FbUser update
   */
  export type FbUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the FbUser
     */
    select?: FbUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbUserInclude | null
    /**
     * The data needed to update a FbUser.
     */
    data: XOR<FbUserUpdateInput, FbUserUncheckedUpdateInput>
    /**
     * Choose, which FbUser to update.
     */
    where: FbUserWhereUniqueInput
  }


  /**
   * FbUser updateMany
   */
  export type FbUserUpdateManyArgs = {
    /**
     * The data used to update FbUsers.
     */
    data: XOR<FbUserUpdateManyMutationInput, FbUserUncheckedUpdateManyInput>
    /**
     * Filter which FbUsers to update
     */
    where?: FbUserWhereInput
  }


  /**
   * FbUser upsert
   */
  export type FbUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the FbUser
     */
    select?: FbUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbUserInclude | null
    /**
     * The filter to search for the FbUser to update in case it exists.
     */
    where: FbUserWhereUniqueInput
    /**
     * In case the FbUser found by the `where` argument doesn't exist, create a new FbUser with this data.
     */
    create: XOR<FbUserCreateInput, FbUserUncheckedCreateInput>
    /**
     * In case the FbUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FbUserUpdateInput, FbUserUncheckedUpdateInput>
  }


  /**
   * FbUser delete
   */
  export type FbUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the FbUser
     */
    select?: FbUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbUserInclude | null
    /**
     * Filter which FbUser to delete.
     */
    where: FbUserWhereUniqueInput
  }


  /**
   * FbUser deleteMany
   */
  export type FbUserDeleteManyArgs = {
    /**
     * Filter which FbUsers to delete
     */
    where?: FbUserWhereInput
  }


  /**
   * FbUser.posts
   */
  export type FbUser$postsArgs = {
    /**
     * Select specific fields to fetch from the FbPost
     */
    select?: FbPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostInclude | null
    where?: FbPostWhereInput
    orderBy?: Enumerable<FbPostOrderByWithRelationInput>
    cursor?: FbPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FbPostScalarFieldEnum>
  }


  /**
   * FbUser.acceptFbFriends
   */
  export type FbUser$acceptFbFriendsArgs = {
    /**
     * Select specific fields to fetch from the Fbfriend
     */
    select?: FbfriendSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbfriendInclude | null
    where?: FbfriendWhereInput
    orderBy?: Enumerable<FbfriendOrderByWithRelationInput>
    cursor?: FbfriendWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FbfriendScalarFieldEnum>
  }


  /**
   * FbUser.requestFbFriends
   */
  export type FbUser$requestFbFriendsArgs = {
    /**
     * Select specific fields to fetch from the Fbfriend
     */
    select?: FbfriendSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbfriendInclude | null
    where?: FbfriendWhereInput
    orderBy?: Enumerable<FbfriendOrderByWithRelationInput>
    cursor?: FbfriendWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FbfriendScalarFieldEnum>
  }


  /**
   * FbUser.likes
   */
  export type FbUser$likesArgs = {
    /**
     * Select specific fields to fetch from the FbLike
     */
    select?: FbLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbLikeInclude | null
    where?: FbLikeWhereInput
    orderBy?: Enumerable<FbLikeOrderByWithRelationInput>
    cursor?: FbLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FbLikeScalarFieldEnum>
  }


  /**
   * FbUser.fromMessengers
   */
  export type FbUser$fromMessengersArgs = {
    /**
     * Select specific fields to fetch from the FbMessenger
     */
    select?: FbMessengerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbMessengerInclude | null
    where?: FbMessengerWhereInput
    orderBy?: Enumerable<FbMessengerOrderByWithRelationInput>
    cursor?: FbMessengerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FbMessengerScalarFieldEnum>
  }


  /**
   * FbUser.toMessengers
   */
  export type FbUser$toMessengersArgs = {
    /**
     * Select specific fields to fetch from the FbMessenger
     */
    select?: FbMessengerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbMessengerInclude | null
    where?: FbMessengerWhereInput
    orderBy?: Enumerable<FbMessengerOrderByWithRelationInput>
    cursor?: FbMessengerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FbMessengerScalarFieldEnum>
  }


  /**
   * FbUser.shares
   */
  export type FbUser$sharesArgs = {
    /**
     * Select specific fields to fetch from the FbShare
     */
    select?: FbShareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbShareInclude | null
    where?: FbShareWhereInput
    orderBy?: Enumerable<FbShareOrderByWithRelationInput>
    cursor?: FbShareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FbShareScalarFieldEnum>
  }


  /**
   * FbUser.comments
   */
  export type FbUser$commentsArgs = {
    /**
     * Select specific fields to fetch from the FbComment
     */
    select?: FbCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbCommentInclude | null
    where?: FbCommentWhereInput
    orderBy?: Enumerable<FbCommentOrderByWithRelationInput>
    cursor?: FbCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FbCommentScalarFieldEnum>
  }


  /**
   * FbUser.groupToUsers
   */
  export type FbUser$groupToUsersArgs = {
    /**
     * Select specific fields to fetch from the GroupToUser
     */
    select?: GroupToUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupToUserInclude | null
    where?: GroupToUserWhereInput
    orderBy?: Enumerable<GroupToUserOrderByWithRelationInput>
    cursor?: GroupToUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<GroupToUserScalarFieldEnum>
  }


  /**
   * FbUser without action
   */
  export type FbUserArgs = {
    /**
     * Select specific fields to fetch from the FbUser
     */
    select?: FbUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbUserInclude | null
  }



  /**
   * Model FbPost
   */


  export type AggregateFbPost = {
    _count: FbPostCountAggregateOutputType | null
    _avg: FbPostAvgAggregateOutputType | null
    _sum: FbPostSumAggregateOutputType | null
    _min: FbPostMinAggregateOutputType | null
    _max: FbPostMaxAggregateOutputType | null
  }

  export type FbPostAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    wallId: number | null
  }

  export type FbPostSumAggregateOutputType = {
    id: number | null
    userId: number | null
    wallId: number | null
  }

  export type FbPostMinAggregateOutputType = {
    id: number | null
    caption: string | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    wallId: number | null
  }

  export type FbPostMaxAggregateOutputType = {
    id: number | null
    caption: string | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    wallId: number | null
  }

  export type FbPostCountAggregateOutputType = {
    id: number
    caption: number
    userId: number
    createdAt: number
    updatedAt: number
    wallId: number
    _all: number
  }


  export type FbPostAvgAggregateInputType = {
    id?: true
    userId?: true
    wallId?: true
  }

  export type FbPostSumAggregateInputType = {
    id?: true
    userId?: true
    wallId?: true
  }

  export type FbPostMinAggregateInputType = {
    id?: true
    caption?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    wallId?: true
  }

  export type FbPostMaxAggregateInputType = {
    id?: true
    caption?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    wallId?: true
  }

  export type FbPostCountAggregateInputType = {
    id?: true
    caption?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    wallId?: true
    _all?: true
  }

  export type FbPostAggregateArgs = {
    /**
     * Filter which FbPost to aggregate.
     */
    where?: FbPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbPosts to fetch.
     */
    orderBy?: Enumerable<FbPostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FbPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FbPosts
    **/
    _count?: true | FbPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FbPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FbPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FbPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FbPostMaxAggregateInputType
  }

  export type GetFbPostAggregateType<T extends FbPostAggregateArgs> = {
        [P in keyof T & keyof AggregateFbPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFbPost[P]>
      : GetScalarType<T[P], AggregateFbPost[P]>
  }




  export type FbPostGroupByArgs = {
    where?: FbPostWhereInput
    orderBy?: Enumerable<FbPostOrderByWithAggregationInput>
    by: FbPostScalarFieldEnum[]
    having?: FbPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FbPostCountAggregateInputType | true
    _avg?: FbPostAvgAggregateInputType
    _sum?: FbPostSumAggregateInputType
    _min?: FbPostMinAggregateInputType
    _max?: FbPostMaxAggregateInputType
  }


  export type FbPostGroupByOutputType = {
    id: number
    caption: string
    userId: number
    createdAt: Date
    updatedAt: Date
    wallId: number
    _count: FbPostCountAggregateOutputType | null
    _avg: FbPostAvgAggregateOutputType | null
    _sum: FbPostSumAggregateOutputType | null
    _min: FbPostMinAggregateOutputType | null
    _max: FbPostMaxAggregateOutputType | null
  }

  type GetFbPostGroupByPayload<T extends FbPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FbPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FbPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FbPostGroupByOutputType[P]>
            : GetScalarType<T[P], FbPostGroupByOutputType[P]>
        }
      >
    >


  export type FbPostSelect = {
    id?: boolean
    caption?: boolean
    user?: boolean | FbUserArgs
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    postImages?: boolean | FbPost$postImagesArgs
    postVideoes?: boolean | FbPost$postVideoesArgs
    postOnHashtags?: boolean | FbPost$postOnHashtagsArgs
    shares?: boolean | FbPost$sharesArgs
    likes?: boolean | FbPost$likesArgs
    wall?: boolean | FbWallArgs
    wallId?: boolean
    _count?: boolean | FbPostCountOutputTypeArgs
  }


  export type FbPostInclude = {
    user?: boolean | FbUserArgs
    postImages?: boolean | FbPost$postImagesArgs
    postVideoes?: boolean | FbPost$postVideoesArgs
    postOnHashtags?: boolean | FbPost$postOnHashtagsArgs
    shares?: boolean | FbPost$sharesArgs
    likes?: boolean | FbPost$likesArgs
    wall?: boolean | FbWallArgs
    _count?: boolean | FbPostCountOutputTypeArgs
  }

  export type FbPostGetPayload<S extends boolean | null | undefined | FbPostArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FbPost :
    S extends undefined ? never :
    S extends { include: any } & (FbPostArgs | FbPostFindManyArgs)
    ? FbPost  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? FbUserGetPayload<S['include'][P]> :
        P extends 'postImages' ? Array < FbPostImageGetPayload<S['include'][P]>>  :
        P extends 'postVideoes' ? Array < FbPostVideoGetPayload<S['include'][P]>>  :
        P extends 'postOnHashtags' ? Array < FbPostOnHashtagGetPayload<S['include'][P]>>  :
        P extends 'shares' ? Array < FbShareGetPayload<S['include'][P]>>  :
        P extends 'likes' ? Array < FbLikeGetPayload<S['include'][P]>>  :
        P extends 'wall' ? FbWallGetPayload<S['include'][P]> :
        P extends '_count' ? FbPostCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FbPostArgs | FbPostFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? FbUserGetPayload<S['select'][P]> :
        P extends 'postImages' ? Array < FbPostImageGetPayload<S['select'][P]>>  :
        P extends 'postVideoes' ? Array < FbPostVideoGetPayload<S['select'][P]>>  :
        P extends 'postOnHashtags' ? Array < FbPostOnHashtagGetPayload<S['select'][P]>>  :
        P extends 'shares' ? Array < FbShareGetPayload<S['select'][P]>>  :
        P extends 'likes' ? Array < FbLikeGetPayload<S['select'][P]>>  :
        P extends 'wall' ? FbWallGetPayload<S['select'][P]> :
        P extends '_count' ? FbPostCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof FbPost ? FbPost[P] : never
  } 
      : FbPost


  type FbPostCountArgs = 
    Omit<FbPostFindManyArgs, 'select' | 'include'> & {
      select?: FbPostCountAggregateInputType | true
    }

  export interface FbPostDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one FbPost that matches the filter.
     * @param {FbPostFindUniqueArgs} args - Arguments to find a FbPost
     * @example
     * // Get one FbPost
     * const fbPost = await prisma.fbPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FbPostFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FbPostFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FbPost'> extends True ? Prisma__FbPostClient<FbPostGetPayload<T>> : Prisma__FbPostClient<FbPostGetPayload<T> | null, null>

    /**
     * Find one FbPost that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FbPostFindUniqueOrThrowArgs} args - Arguments to find a FbPost
     * @example
     * // Get one FbPost
     * const fbPost = await prisma.fbPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FbPostFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FbPostFindUniqueOrThrowArgs>
    ): Prisma__FbPostClient<FbPostGetPayload<T>>

    /**
     * Find the first FbPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbPostFindFirstArgs} args - Arguments to find a FbPost
     * @example
     * // Get one FbPost
     * const fbPost = await prisma.fbPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FbPostFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FbPostFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FbPost'> extends True ? Prisma__FbPostClient<FbPostGetPayload<T>> : Prisma__FbPostClient<FbPostGetPayload<T> | null, null>

    /**
     * Find the first FbPost that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbPostFindFirstOrThrowArgs} args - Arguments to find a FbPost
     * @example
     * // Get one FbPost
     * const fbPost = await prisma.fbPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FbPostFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FbPostFindFirstOrThrowArgs>
    ): Prisma__FbPostClient<FbPostGetPayload<T>>

    /**
     * Find zero or more FbPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbPostFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FbPosts
     * const fbPosts = await prisma.fbPost.findMany()
     * 
     * // Get first 10 FbPosts
     * const fbPosts = await prisma.fbPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fbPostWithIdOnly = await prisma.fbPost.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FbPostFindManyArgs>(
      args?: SelectSubset<T, FbPostFindManyArgs>
    ): Prisma.PrismaPromise<Array<FbPostGetPayload<T>>>

    /**
     * Create a FbPost.
     * @param {FbPostCreateArgs} args - Arguments to create a FbPost.
     * @example
     * // Create one FbPost
     * const FbPost = await prisma.fbPost.create({
     *   data: {
     *     // ... data to create a FbPost
     *   }
     * })
     * 
    **/
    create<T extends FbPostCreateArgs>(
      args: SelectSubset<T, FbPostCreateArgs>
    ): Prisma__FbPostClient<FbPostGetPayload<T>>

    /**
     * Create many FbPosts.
     *     @param {FbPostCreateManyArgs} args - Arguments to create many FbPosts.
     *     @example
     *     // Create many FbPosts
     *     const fbPost = await prisma.fbPost.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FbPostCreateManyArgs>(
      args?: SelectSubset<T, FbPostCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FbPost.
     * @param {FbPostDeleteArgs} args - Arguments to delete one FbPost.
     * @example
     * // Delete one FbPost
     * const FbPost = await prisma.fbPost.delete({
     *   where: {
     *     // ... filter to delete one FbPost
     *   }
     * })
     * 
    **/
    delete<T extends FbPostDeleteArgs>(
      args: SelectSubset<T, FbPostDeleteArgs>
    ): Prisma__FbPostClient<FbPostGetPayload<T>>

    /**
     * Update one FbPost.
     * @param {FbPostUpdateArgs} args - Arguments to update one FbPost.
     * @example
     * // Update one FbPost
     * const fbPost = await prisma.fbPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FbPostUpdateArgs>(
      args: SelectSubset<T, FbPostUpdateArgs>
    ): Prisma__FbPostClient<FbPostGetPayload<T>>

    /**
     * Delete zero or more FbPosts.
     * @param {FbPostDeleteManyArgs} args - Arguments to filter FbPosts to delete.
     * @example
     * // Delete a few FbPosts
     * const { count } = await prisma.fbPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FbPostDeleteManyArgs>(
      args?: SelectSubset<T, FbPostDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FbPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FbPosts
     * const fbPost = await prisma.fbPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FbPostUpdateManyArgs>(
      args: SelectSubset<T, FbPostUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FbPost.
     * @param {FbPostUpsertArgs} args - Arguments to update or create a FbPost.
     * @example
     * // Update or create a FbPost
     * const fbPost = await prisma.fbPost.upsert({
     *   create: {
     *     // ... data to create a FbPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FbPost we want to update
     *   }
     * })
    **/
    upsert<T extends FbPostUpsertArgs>(
      args: SelectSubset<T, FbPostUpsertArgs>
    ): Prisma__FbPostClient<FbPostGetPayload<T>>

    /**
     * Count the number of FbPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbPostCountArgs} args - Arguments to filter FbPosts to count.
     * @example
     * // Count the number of FbPosts
     * const count = await prisma.fbPost.count({
     *   where: {
     *     // ... the filter for the FbPosts we want to count
     *   }
     * })
    **/
    count<T extends FbPostCountArgs>(
      args?: Subset<T, FbPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FbPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FbPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FbPostAggregateArgs>(args: Subset<T, FbPostAggregateArgs>): Prisma.PrismaPromise<GetFbPostAggregateType<T>>

    /**
     * Group by FbPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FbPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FbPostGroupByArgs['orderBy'] }
        : { orderBy?: FbPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FbPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFbPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FbPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FbPostClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends FbUserArgs= {}>(args?: Subset<T, FbUserArgs>): Prisma__FbUserClient<FbUserGetPayload<T> | Null>;

    postImages<T extends FbPost$postImagesArgs= {}>(args?: Subset<T, FbPost$postImagesArgs>): Prisma.PrismaPromise<Array<FbPostImageGetPayload<T>>| Null>;

    postVideoes<T extends FbPost$postVideoesArgs= {}>(args?: Subset<T, FbPost$postVideoesArgs>): Prisma.PrismaPromise<Array<FbPostVideoGetPayload<T>>| Null>;

    postOnHashtags<T extends FbPost$postOnHashtagsArgs= {}>(args?: Subset<T, FbPost$postOnHashtagsArgs>): Prisma.PrismaPromise<Array<FbPostOnHashtagGetPayload<T>>| Null>;

    shares<T extends FbPost$sharesArgs= {}>(args?: Subset<T, FbPost$sharesArgs>): Prisma.PrismaPromise<Array<FbShareGetPayload<T>>| Null>;

    likes<T extends FbPost$likesArgs= {}>(args?: Subset<T, FbPost$likesArgs>): Prisma.PrismaPromise<Array<FbLikeGetPayload<T>>| Null>;

    wall<T extends FbWallArgs= {}>(args?: Subset<T, FbWallArgs>): Prisma__FbWallClient<FbWallGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FbPost base type for findUnique actions
   */
  export type FbPostFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FbPost
     */
    select?: FbPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostInclude | null
    /**
     * Filter, which FbPost to fetch.
     */
    where: FbPostWhereUniqueInput
  }

  /**
   * FbPost findUnique
   */
  export interface FbPostFindUniqueArgs extends FbPostFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FbPost findUniqueOrThrow
   */
  export type FbPostFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FbPost
     */
    select?: FbPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostInclude | null
    /**
     * Filter, which FbPost to fetch.
     */
    where: FbPostWhereUniqueInput
  }


  /**
   * FbPost base type for findFirst actions
   */
  export type FbPostFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FbPost
     */
    select?: FbPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostInclude | null
    /**
     * Filter, which FbPost to fetch.
     */
    where?: FbPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbPosts to fetch.
     */
    orderBy?: Enumerable<FbPostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FbPosts.
     */
    cursor?: FbPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FbPosts.
     */
    distinct?: Enumerable<FbPostScalarFieldEnum>
  }

  /**
   * FbPost findFirst
   */
  export interface FbPostFindFirstArgs extends FbPostFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FbPost findFirstOrThrow
   */
  export type FbPostFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FbPost
     */
    select?: FbPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostInclude | null
    /**
     * Filter, which FbPost to fetch.
     */
    where?: FbPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbPosts to fetch.
     */
    orderBy?: Enumerable<FbPostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FbPosts.
     */
    cursor?: FbPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FbPosts.
     */
    distinct?: Enumerable<FbPostScalarFieldEnum>
  }


  /**
   * FbPost findMany
   */
  export type FbPostFindManyArgs = {
    /**
     * Select specific fields to fetch from the FbPost
     */
    select?: FbPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostInclude | null
    /**
     * Filter, which FbPosts to fetch.
     */
    where?: FbPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbPosts to fetch.
     */
    orderBy?: Enumerable<FbPostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FbPosts.
     */
    cursor?: FbPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbPosts.
     */
    skip?: number
    distinct?: Enumerable<FbPostScalarFieldEnum>
  }


  /**
   * FbPost create
   */
  export type FbPostCreateArgs = {
    /**
     * Select specific fields to fetch from the FbPost
     */
    select?: FbPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostInclude | null
    /**
     * The data needed to create a FbPost.
     */
    data: XOR<FbPostCreateInput, FbPostUncheckedCreateInput>
  }


  /**
   * FbPost createMany
   */
  export type FbPostCreateManyArgs = {
    /**
     * The data used to create many FbPosts.
     */
    data: Enumerable<FbPostCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FbPost update
   */
  export type FbPostUpdateArgs = {
    /**
     * Select specific fields to fetch from the FbPost
     */
    select?: FbPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostInclude | null
    /**
     * The data needed to update a FbPost.
     */
    data: XOR<FbPostUpdateInput, FbPostUncheckedUpdateInput>
    /**
     * Choose, which FbPost to update.
     */
    where: FbPostWhereUniqueInput
  }


  /**
   * FbPost updateMany
   */
  export type FbPostUpdateManyArgs = {
    /**
     * The data used to update FbPosts.
     */
    data: XOR<FbPostUpdateManyMutationInput, FbPostUncheckedUpdateManyInput>
    /**
     * Filter which FbPosts to update
     */
    where?: FbPostWhereInput
  }


  /**
   * FbPost upsert
   */
  export type FbPostUpsertArgs = {
    /**
     * Select specific fields to fetch from the FbPost
     */
    select?: FbPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostInclude | null
    /**
     * The filter to search for the FbPost to update in case it exists.
     */
    where: FbPostWhereUniqueInput
    /**
     * In case the FbPost found by the `where` argument doesn't exist, create a new FbPost with this data.
     */
    create: XOR<FbPostCreateInput, FbPostUncheckedCreateInput>
    /**
     * In case the FbPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FbPostUpdateInput, FbPostUncheckedUpdateInput>
  }


  /**
   * FbPost delete
   */
  export type FbPostDeleteArgs = {
    /**
     * Select specific fields to fetch from the FbPost
     */
    select?: FbPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostInclude | null
    /**
     * Filter which FbPost to delete.
     */
    where: FbPostWhereUniqueInput
  }


  /**
   * FbPost deleteMany
   */
  export type FbPostDeleteManyArgs = {
    /**
     * Filter which FbPosts to delete
     */
    where?: FbPostWhereInput
  }


  /**
   * FbPost.postImages
   */
  export type FbPost$postImagesArgs = {
    /**
     * Select specific fields to fetch from the FbPostImage
     */
    select?: FbPostImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostImageInclude | null
    where?: FbPostImageWhereInput
    orderBy?: Enumerable<FbPostImageOrderByWithRelationInput>
    cursor?: FbPostImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FbPostImageScalarFieldEnum>
  }


  /**
   * FbPost.postVideoes
   */
  export type FbPost$postVideoesArgs = {
    /**
     * Select specific fields to fetch from the FbPostVideo
     */
    select?: FbPostVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostVideoInclude | null
    where?: FbPostVideoWhereInput
    orderBy?: Enumerable<FbPostVideoOrderByWithRelationInput>
    cursor?: FbPostVideoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FbPostVideoScalarFieldEnum>
  }


  /**
   * FbPost.postOnHashtags
   */
  export type FbPost$postOnHashtagsArgs = {
    /**
     * Select specific fields to fetch from the FbPostOnHashtag
     */
    select?: FbPostOnHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostOnHashtagInclude | null
    where?: FbPostOnHashtagWhereInput
    orderBy?: Enumerable<FbPostOnHashtagOrderByWithRelationInput>
    cursor?: FbPostOnHashtagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FbPostOnHashtagScalarFieldEnum>
  }


  /**
   * FbPost.shares
   */
  export type FbPost$sharesArgs = {
    /**
     * Select specific fields to fetch from the FbShare
     */
    select?: FbShareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbShareInclude | null
    where?: FbShareWhereInput
    orderBy?: Enumerable<FbShareOrderByWithRelationInput>
    cursor?: FbShareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FbShareScalarFieldEnum>
  }


  /**
   * FbPost.likes
   */
  export type FbPost$likesArgs = {
    /**
     * Select specific fields to fetch from the FbLike
     */
    select?: FbLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbLikeInclude | null
    where?: FbLikeWhereInput
    orderBy?: Enumerable<FbLikeOrderByWithRelationInput>
    cursor?: FbLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FbLikeScalarFieldEnum>
  }


  /**
   * FbPost without action
   */
  export type FbPostArgs = {
    /**
     * Select specific fields to fetch from the FbPost
     */
    select?: FbPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostInclude | null
  }



  /**
   * Model FbPostImage
   */


  export type AggregateFbPostImage = {
    _count: FbPostImageCountAggregateOutputType | null
    _avg: FbPostImageAvgAggregateOutputType | null
    _sum: FbPostImageSumAggregateOutputType | null
    _min: FbPostImageMinAggregateOutputType | null
    _max: FbPostImageMaxAggregateOutputType | null
  }

  export type FbPostImageAvgAggregateOutputType = {
    id: number | null
    postId: number | null
  }

  export type FbPostImageSumAggregateOutputType = {
    id: number | null
    postId: number | null
  }

  export type FbPostImageMinAggregateOutputType = {
    id: number | null
    image: string | null
    postId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FbPostImageMaxAggregateOutputType = {
    id: number | null
    image: string | null
    postId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FbPostImageCountAggregateOutputType = {
    id: number
    image: number
    postId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FbPostImageAvgAggregateInputType = {
    id?: true
    postId?: true
  }

  export type FbPostImageSumAggregateInputType = {
    id?: true
    postId?: true
  }

  export type FbPostImageMinAggregateInputType = {
    id?: true
    image?: true
    postId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FbPostImageMaxAggregateInputType = {
    id?: true
    image?: true
    postId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FbPostImageCountAggregateInputType = {
    id?: true
    image?: true
    postId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FbPostImageAggregateArgs = {
    /**
     * Filter which FbPostImage to aggregate.
     */
    where?: FbPostImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbPostImages to fetch.
     */
    orderBy?: Enumerable<FbPostImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FbPostImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbPostImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbPostImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FbPostImages
    **/
    _count?: true | FbPostImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FbPostImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FbPostImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FbPostImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FbPostImageMaxAggregateInputType
  }

  export type GetFbPostImageAggregateType<T extends FbPostImageAggregateArgs> = {
        [P in keyof T & keyof AggregateFbPostImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFbPostImage[P]>
      : GetScalarType<T[P], AggregateFbPostImage[P]>
  }




  export type FbPostImageGroupByArgs = {
    where?: FbPostImageWhereInput
    orderBy?: Enumerable<FbPostImageOrderByWithAggregationInput>
    by: FbPostImageScalarFieldEnum[]
    having?: FbPostImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FbPostImageCountAggregateInputType | true
    _avg?: FbPostImageAvgAggregateInputType
    _sum?: FbPostImageSumAggregateInputType
    _min?: FbPostImageMinAggregateInputType
    _max?: FbPostImageMaxAggregateInputType
  }


  export type FbPostImageGroupByOutputType = {
    id: number
    image: string
    postId: number
    createdAt: Date
    updatedAt: Date
    _count: FbPostImageCountAggregateOutputType | null
    _avg: FbPostImageAvgAggregateOutputType | null
    _sum: FbPostImageSumAggregateOutputType | null
    _min: FbPostImageMinAggregateOutputType | null
    _max: FbPostImageMaxAggregateOutputType | null
  }

  type GetFbPostImageGroupByPayload<T extends FbPostImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FbPostImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FbPostImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FbPostImageGroupByOutputType[P]>
            : GetScalarType<T[P], FbPostImageGroupByOutputType[P]>
        }
      >
    >


  export type FbPostImageSelect = {
    id?: boolean
    image?: boolean
    post?: boolean | FbPostArgs
    postId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type FbPostImageInclude = {
    post?: boolean | FbPostArgs
  }

  export type FbPostImageGetPayload<S extends boolean | null | undefined | FbPostImageArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FbPostImage :
    S extends undefined ? never :
    S extends { include: any } & (FbPostImageArgs | FbPostImageFindManyArgs)
    ? FbPostImage  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'post' ? FbPostGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FbPostImageArgs | FbPostImageFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'post' ? FbPostGetPayload<S['select'][P]> :  P extends keyof FbPostImage ? FbPostImage[P] : never
  } 
      : FbPostImage


  type FbPostImageCountArgs = 
    Omit<FbPostImageFindManyArgs, 'select' | 'include'> & {
      select?: FbPostImageCountAggregateInputType | true
    }

  export interface FbPostImageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one FbPostImage that matches the filter.
     * @param {FbPostImageFindUniqueArgs} args - Arguments to find a FbPostImage
     * @example
     * // Get one FbPostImage
     * const fbPostImage = await prisma.fbPostImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FbPostImageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FbPostImageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FbPostImage'> extends True ? Prisma__FbPostImageClient<FbPostImageGetPayload<T>> : Prisma__FbPostImageClient<FbPostImageGetPayload<T> | null, null>

    /**
     * Find one FbPostImage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FbPostImageFindUniqueOrThrowArgs} args - Arguments to find a FbPostImage
     * @example
     * // Get one FbPostImage
     * const fbPostImage = await prisma.fbPostImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FbPostImageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FbPostImageFindUniqueOrThrowArgs>
    ): Prisma__FbPostImageClient<FbPostImageGetPayload<T>>

    /**
     * Find the first FbPostImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbPostImageFindFirstArgs} args - Arguments to find a FbPostImage
     * @example
     * // Get one FbPostImage
     * const fbPostImage = await prisma.fbPostImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FbPostImageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FbPostImageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FbPostImage'> extends True ? Prisma__FbPostImageClient<FbPostImageGetPayload<T>> : Prisma__FbPostImageClient<FbPostImageGetPayload<T> | null, null>

    /**
     * Find the first FbPostImage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbPostImageFindFirstOrThrowArgs} args - Arguments to find a FbPostImage
     * @example
     * // Get one FbPostImage
     * const fbPostImage = await prisma.fbPostImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FbPostImageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FbPostImageFindFirstOrThrowArgs>
    ): Prisma__FbPostImageClient<FbPostImageGetPayload<T>>

    /**
     * Find zero or more FbPostImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbPostImageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FbPostImages
     * const fbPostImages = await prisma.fbPostImage.findMany()
     * 
     * // Get first 10 FbPostImages
     * const fbPostImages = await prisma.fbPostImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fbPostImageWithIdOnly = await prisma.fbPostImage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FbPostImageFindManyArgs>(
      args?: SelectSubset<T, FbPostImageFindManyArgs>
    ): Prisma.PrismaPromise<Array<FbPostImageGetPayload<T>>>

    /**
     * Create a FbPostImage.
     * @param {FbPostImageCreateArgs} args - Arguments to create a FbPostImage.
     * @example
     * // Create one FbPostImage
     * const FbPostImage = await prisma.fbPostImage.create({
     *   data: {
     *     // ... data to create a FbPostImage
     *   }
     * })
     * 
    **/
    create<T extends FbPostImageCreateArgs>(
      args: SelectSubset<T, FbPostImageCreateArgs>
    ): Prisma__FbPostImageClient<FbPostImageGetPayload<T>>

    /**
     * Create many FbPostImages.
     *     @param {FbPostImageCreateManyArgs} args - Arguments to create many FbPostImages.
     *     @example
     *     // Create many FbPostImages
     *     const fbPostImage = await prisma.fbPostImage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FbPostImageCreateManyArgs>(
      args?: SelectSubset<T, FbPostImageCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FbPostImage.
     * @param {FbPostImageDeleteArgs} args - Arguments to delete one FbPostImage.
     * @example
     * // Delete one FbPostImage
     * const FbPostImage = await prisma.fbPostImage.delete({
     *   where: {
     *     // ... filter to delete one FbPostImage
     *   }
     * })
     * 
    **/
    delete<T extends FbPostImageDeleteArgs>(
      args: SelectSubset<T, FbPostImageDeleteArgs>
    ): Prisma__FbPostImageClient<FbPostImageGetPayload<T>>

    /**
     * Update one FbPostImage.
     * @param {FbPostImageUpdateArgs} args - Arguments to update one FbPostImage.
     * @example
     * // Update one FbPostImage
     * const fbPostImage = await prisma.fbPostImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FbPostImageUpdateArgs>(
      args: SelectSubset<T, FbPostImageUpdateArgs>
    ): Prisma__FbPostImageClient<FbPostImageGetPayload<T>>

    /**
     * Delete zero or more FbPostImages.
     * @param {FbPostImageDeleteManyArgs} args - Arguments to filter FbPostImages to delete.
     * @example
     * // Delete a few FbPostImages
     * const { count } = await prisma.fbPostImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FbPostImageDeleteManyArgs>(
      args?: SelectSubset<T, FbPostImageDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FbPostImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbPostImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FbPostImages
     * const fbPostImage = await prisma.fbPostImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FbPostImageUpdateManyArgs>(
      args: SelectSubset<T, FbPostImageUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FbPostImage.
     * @param {FbPostImageUpsertArgs} args - Arguments to update or create a FbPostImage.
     * @example
     * // Update or create a FbPostImage
     * const fbPostImage = await prisma.fbPostImage.upsert({
     *   create: {
     *     // ... data to create a FbPostImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FbPostImage we want to update
     *   }
     * })
    **/
    upsert<T extends FbPostImageUpsertArgs>(
      args: SelectSubset<T, FbPostImageUpsertArgs>
    ): Prisma__FbPostImageClient<FbPostImageGetPayload<T>>

    /**
     * Count the number of FbPostImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbPostImageCountArgs} args - Arguments to filter FbPostImages to count.
     * @example
     * // Count the number of FbPostImages
     * const count = await prisma.fbPostImage.count({
     *   where: {
     *     // ... the filter for the FbPostImages we want to count
     *   }
     * })
    **/
    count<T extends FbPostImageCountArgs>(
      args?: Subset<T, FbPostImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FbPostImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FbPostImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbPostImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FbPostImageAggregateArgs>(args: Subset<T, FbPostImageAggregateArgs>): Prisma.PrismaPromise<GetFbPostImageAggregateType<T>>

    /**
     * Group by FbPostImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbPostImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FbPostImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FbPostImageGroupByArgs['orderBy'] }
        : { orderBy?: FbPostImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FbPostImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFbPostImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FbPostImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FbPostImageClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    post<T extends FbPostArgs= {}>(args?: Subset<T, FbPostArgs>): Prisma__FbPostClient<FbPostGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FbPostImage base type for findUnique actions
   */
  export type FbPostImageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FbPostImage
     */
    select?: FbPostImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostImageInclude | null
    /**
     * Filter, which FbPostImage to fetch.
     */
    where: FbPostImageWhereUniqueInput
  }

  /**
   * FbPostImage findUnique
   */
  export interface FbPostImageFindUniqueArgs extends FbPostImageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FbPostImage findUniqueOrThrow
   */
  export type FbPostImageFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FbPostImage
     */
    select?: FbPostImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostImageInclude | null
    /**
     * Filter, which FbPostImage to fetch.
     */
    where: FbPostImageWhereUniqueInput
  }


  /**
   * FbPostImage base type for findFirst actions
   */
  export type FbPostImageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FbPostImage
     */
    select?: FbPostImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostImageInclude | null
    /**
     * Filter, which FbPostImage to fetch.
     */
    where?: FbPostImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbPostImages to fetch.
     */
    orderBy?: Enumerable<FbPostImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FbPostImages.
     */
    cursor?: FbPostImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbPostImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbPostImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FbPostImages.
     */
    distinct?: Enumerable<FbPostImageScalarFieldEnum>
  }

  /**
   * FbPostImage findFirst
   */
  export interface FbPostImageFindFirstArgs extends FbPostImageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FbPostImage findFirstOrThrow
   */
  export type FbPostImageFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FbPostImage
     */
    select?: FbPostImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostImageInclude | null
    /**
     * Filter, which FbPostImage to fetch.
     */
    where?: FbPostImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbPostImages to fetch.
     */
    orderBy?: Enumerable<FbPostImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FbPostImages.
     */
    cursor?: FbPostImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbPostImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbPostImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FbPostImages.
     */
    distinct?: Enumerable<FbPostImageScalarFieldEnum>
  }


  /**
   * FbPostImage findMany
   */
  export type FbPostImageFindManyArgs = {
    /**
     * Select specific fields to fetch from the FbPostImage
     */
    select?: FbPostImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostImageInclude | null
    /**
     * Filter, which FbPostImages to fetch.
     */
    where?: FbPostImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbPostImages to fetch.
     */
    orderBy?: Enumerable<FbPostImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FbPostImages.
     */
    cursor?: FbPostImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbPostImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbPostImages.
     */
    skip?: number
    distinct?: Enumerable<FbPostImageScalarFieldEnum>
  }


  /**
   * FbPostImage create
   */
  export type FbPostImageCreateArgs = {
    /**
     * Select specific fields to fetch from the FbPostImage
     */
    select?: FbPostImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostImageInclude | null
    /**
     * The data needed to create a FbPostImage.
     */
    data: XOR<FbPostImageCreateInput, FbPostImageUncheckedCreateInput>
  }


  /**
   * FbPostImage createMany
   */
  export type FbPostImageCreateManyArgs = {
    /**
     * The data used to create many FbPostImages.
     */
    data: Enumerable<FbPostImageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FbPostImage update
   */
  export type FbPostImageUpdateArgs = {
    /**
     * Select specific fields to fetch from the FbPostImage
     */
    select?: FbPostImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostImageInclude | null
    /**
     * The data needed to update a FbPostImage.
     */
    data: XOR<FbPostImageUpdateInput, FbPostImageUncheckedUpdateInput>
    /**
     * Choose, which FbPostImage to update.
     */
    where: FbPostImageWhereUniqueInput
  }


  /**
   * FbPostImage updateMany
   */
  export type FbPostImageUpdateManyArgs = {
    /**
     * The data used to update FbPostImages.
     */
    data: XOR<FbPostImageUpdateManyMutationInput, FbPostImageUncheckedUpdateManyInput>
    /**
     * Filter which FbPostImages to update
     */
    where?: FbPostImageWhereInput
  }


  /**
   * FbPostImage upsert
   */
  export type FbPostImageUpsertArgs = {
    /**
     * Select specific fields to fetch from the FbPostImage
     */
    select?: FbPostImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostImageInclude | null
    /**
     * The filter to search for the FbPostImage to update in case it exists.
     */
    where: FbPostImageWhereUniqueInput
    /**
     * In case the FbPostImage found by the `where` argument doesn't exist, create a new FbPostImage with this data.
     */
    create: XOR<FbPostImageCreateInput, FbPostImageUncheckedCreateInput>
    /**
     * In case the FbPostImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FbPostImageUpdateInput, FbPostImageUncheckedUpdateInput>
  }


  /**
   * FbPostImage delete
   */
  export type FbPostImageDeleteArgs = {
    /**
     * Select specific fields to fetch from the FbPostImage
     */
    select?: FbPostImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostImageInclude | null
    /**
     * Filter which FbPostImage to delete.
     */
    where: FbPostImageWhereUniqueInput
  }


  /**
   * FbPostImage deleteMany
   */
  export type FbPostImageDeleteManyArgs = {
    /**
     * Filter which FbPostImages to delete
     */
    where?: FbPostImageWhereInput
  }


  /**
   * FbPostImage without action
   */
  export type FbPostImageArgs = {
    /**
     * Select specific fields to fetch from the FbPostImage
     */
    select?: FbPostImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostImageInclude | null
  }



  /**
   * Model FbPostVideo
   */


  export type AggregateFbPostVideo = {
    _count: FbPostVideoCountAggregateOutputType | null
    _avg: FbPostVideoAvgAggregateOutputType | null
    _sum: FbPostVideoSumAggregateOutputType | null
    _min: FbPostVideoMinAggregateOutputType | null
    _max: FbPostVideoMaxAggregateOutputType | null
  }

  export type FbPostVideoAvgAggregateOutputType = {
    id: number | null
    postId: number | null
  }

  export type FbPostVideoSumAggregateOutputType = {
    id: number | null
    postId: number | null
  }

  export type FbPostVideoMinAggregateOutputType = {
    id: number | null
    video: string | null
    postId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FbPostVideoMaxAggregateOutputType = {
    id: number | null
    video: string | null
    postId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FbPostVideoCountAggregateOutputType = {
    id: number
    video: number
    postId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FbPostVideoAvgAggregateInputType = {
    id?: true
    postId?: true
  }

  export type FbPostVideoSumAggregateInputType = {
    id?: true
    postId?: true
  }

  export type FbPostVideoMinAggregateInputType = {
    id?: true
    video?: true
    postId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FbPostVideoMaxAggregateInputType = {
    id?: true
    video?: true
    postId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FbPostVideoCountAggregateInputType = {
    id?: true
    video?: true
    postId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FbPostVideoAggregateArgs = {
    /**
     * Filter which FbPostVideo to aggregate.
     */
    where?: FbPostVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbPostVideos to fetch.
     */
    orderBy?: Enumerable<FbPostVideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FbPostVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbPostVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbPostVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FbPostVideos
    **/
    _count?: true | FbPostVideoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FbPostVideoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FbPostVideoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FbPostVideoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FbPostVideoMaxAggregateInputType
  }

  export type GetFbPostVideoAggregateType<T extends FbPostVideoAggregateArgs> = {
        [P in keyof T & keyof AggregateFbPostVideo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFbPostVideo[P]>
      : GetScalarType<T[P], AggregateFbPostVideo[P]>
  }




  export type FbPostVideoGroupByArgs = {
    where?: FbPostVideoWhereInput
    orderBy?: Enumerable<FbPostVideoOrderByWithAggregationInput>
    by: FbPostVideoScalarFieldEnum[]
    having?: FbPostVideoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FbPostVideoCountAggregateInputType | true
    _avg?: FbPostVideoAvgAggregateInputType
    _sum?: FbPostVideoSumAggregateInputType
    _min?: FbPostVideoMinAggregateInputType
    _max?: FbPostVideoMaxAggregateInputType
  }


  export type FbPostVideoGroupByOutputType = {
    id: number
    video: string
    postId: number
    createdAt: Date
    updatedAt: Date
    _count: FbPostVideoCountAggregateOutputType | null
    _avg: FbPostVideoAvgAggregateOutputType | null
    _sum: FbPostVideoSumAggregateOutputType | null
    _min: FbPostVideoMinAggregateOutputType | null
    _max: FbPostVideoMaxAggregateOutputType | null
  }

  type GetFbPostVideoGroupByPayload<T extends FbPostVideoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FbPostVideoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FbPostVideoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FbPostVideoGroupByOutputType[P]>
            : GetScalarType<T[P], FbPostVideoGroupByOutputType[P]>
        }
      >
    >


  export type FbPostVideoSelect = {
    id?: boolean
    video?: boolean
    post?: boolean | FbPostArgs
    postId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type FbPostVideoInclude = {
    post?: boolean | FbPostArgs
  }

  export type FbPostVideoGetPayload<S extends boolean | null | undefined | FbPostVideoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FbPostVideo :
    S extends undefined ? never :
    S extends { include: any } & (FbPostVideoArgs | FbPostVideoFindManyArgs)
    ? FbPostVideo  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'post' ? FbPostGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FbPostVideoArgs | FbPostVideoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'post' ? FbPostGetPayload<S['select'][P]> :  P extends keyof FbPostVideo ? FbPostVideo[P] : never
  } 
      : FbPostVideo


  type FbPostVideoCountArgs = 
    Omit<FbPostVideoFindManyArgs, 'select' | 'include'> & {
      select?: FbPostVideoCountAggregateInputType | true
    }

  export interface FbPostVideoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one FbPostVideo that matches the filter.
     * @param {FbPostVideoFindUniqueArgs} args - Arguments to find a FbPostVideo
     * @example
     * // Get one FbPostVideo
     * const fbPostVideo = await prisma.fbPostVideo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FbPostVideoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FbPostVideoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FbPostVideo'> extends True ? Prisma__FbPostVideoClient<FbPostVideoGetPayload<T>> : Prisma__FbPostVideoClient<FbPostVideoGetPayload<T> | null, null>

    /**
     * Find one FbPostVideo that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FbPostVideoFindUniqueOrThrowArgs} args - Arguments to find a FbPostVideo
     * @example
     * // Get one FbPostVideo
     * const fbPostVideo = await prisma.fbPostVideo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FbPostVideoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FbPostVideoFindUniqueOrThrowArgs>
    ): Prisma__FbPostVideoClient<FbPostVideoGetPayload<T>>

    /**
     * Find the first FbPostVideo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbPostVideoFindFirstArgs} args - Arguments to find a FbPostVideo
     * @example
     * // Get one FbPostVideo
     * const fbPostVideo = await prisma.fbPostVideo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FbPostVideoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FbPostVideoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FbPostVideo'> extends True ? Prisma__FbPostVideoClient<FbPostVideoGetPayload<T>> : Prisma__FbPostVideoClient<FbPostVideoGetPayload<T> | null, null>

    /**
     * Find the first FbPostVideo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbPostVideoFindFirstOrThrowArgs} args - Arguments to find a FbPostVideo
     * @example
     * // Get one FbPostVideo
     * const fbPostVideo = await prisma.fbPostVideo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FbPostVideoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FbPostVideoFindFirstOrThrowArgs>
    ): Prisma__FbPostVideoClient<FbPostVideoGetPayload<T>>

    /**
     * Find zero or more FbPostVideos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbPostVideoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FbPostVideos
     * const fbPostVideos = await prisma.fbPostVideo.findMany()
     * 
     * // Get first 10 FbPostVideos
     * const fbPostVideos = await prisma.fbPostVideo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fbPostVideoWithIdOnly = await prisma.fbPostVideo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FbPostVideoFindManyArgs>(
      args?: SelectSubset<T, FbPostVideoFindManyArgs>
    ): Prisma.PrismaPromise<Array<FbPostVideoGetPayload<T>>>

    /**
     * Create a FbPostVideo.
     * @param {FbPostVideoCreateArgs} args - Arguments to create a FbPostVideo.
     * @example
     * // Create one FbPostVideo
     * const FbPostVideo = await prisma.fbPostVideo.create({
     *   data: {
     *     // ... data to create a FbPostVideo
     *   }
     * })
     * 
    **/
    create<T extends FbPostVideoCreateArgs>(
      args: SelectSubset<T, FbPostVideoCreateArgs>
    ): Prisma__FbPostVideoClient<FbPostVideoGetPayload<T>>

    /**
     * Create many FbPostVideos.
     *     @param {FbPostVideoCreateManyArgs} args - Arguments to create many FbPostVideos.
     *     @example
     *     // Create many FbPostVideos
     *     const fbPostVideo = await prisma.fbPostVideo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FbPostVideoCreateManyArgs>(
      args?: SelectSubset<T, FbPostVideoCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FbPostVideo.
     * @param {FbPostVideoDeleteArgs} args - Arguments to delete one FbPostVideo.
     * @example
     * // Delete one FbPostVideo
     * const FbPostVideo = await prisma.fbPostVideo.delete({
     *   where: {
     *     // ... filter to delete one FbPostVideo
     *   }
     * })
     * 
    **/
    delete<T extends FbPostVideoDeleteArgs>(
      args: SelectSubset<T, FbPostVideoDeleteArgs>
    ): Prisma__FbPostVideoClient<FbPostVideoGetPayload<T>>

    /**
     * Update one FbPostVideo.
     * @param {FbPostVideoUpdateArgs} args - Arguments to update one FbPostVideo.
     * @example
     * // Update one FbPostVideo
     * const fbPostVideo = await prisma.fbPostVideo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FbPostVideoUpdateArgs>(
      args: SelectSubset<T, FbPostVideoUpdateArgs>
    ): Prisma__FbPostVideoClient<FbPostVideoGetPayload<T>>

    /**
     * Delete zero or more FbPostVideos.
     * @param {FbPostVideoDeleteManyArgs} args - Arguments to filter FbPostVideos to delete.
     * @example
     * // Delete a few FbPostVideos
     * const { count } = await prisma.fbPostVideo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FbPostVideoDeleteManyArgs>(
      args?: SelectSubset<T, FbPostVideoDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FbPostVideos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbPostVideoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FbPostVideos
     * const fbPostVideo = await prisma.fbPostVideo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FbPostVideoUpdateManyArgs>(
      args: SelectSubset<T, FbPostVideoUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FbPostVideo.
     * @param {FbPostVideoUpsertArgs} args - Arguments to update or create a FbPostVideo.
     * @example
     * // Update or create a FbPostVideo
     * const fbPostVideo = await prisma.fbPostVideo.upsert({
     *   create: {
     *     // ... data to create a FbPostVideo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FbPostVideo we want to update
     *   }
     * })
    **/
    upsert<T extends FbPostVideoUpsertArgs>(
      args: SelectSubset<T, FbPostVideoUpsertArgs>
    ): Prisma__FbPostVideoClient<FbPostVideoGetPayload<T>>

    /**
     * Count the number of FbPostVideos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbPostVideoCountArgs} args - Arguments to filter FbPostVideos to count.
     * @example
     * // Count the number of FbPostVideos
     * const count = await prisma.fbPostVideo.count({
     *   where: {
     *     // ... the filter for the FbPostVideos we want to count
     *   }
     * })
    **/
    count<T extends FbPostVideoCountArgs>(
      args?: Subset<T, FbPostVideoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FbPostVideoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FbPostVideo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbPostVideoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FbPostVideoAggregateArgs>(args: Subset<T, FbPostVideoAggregateArgs>): Prisma.PrismaPromise<GetFbPostVideoAggregateType<T>>

    /**
     * Group by FbPostVideo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbPostVideoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FbPostVideoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FbPostVideoGroupByArgs['orderBy'] }
        : { orderBy?: FbPostVideoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FbPostVideoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFbPostVideoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FbPostVideo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FbPostVideoClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    post<T extends FbPostArgs= {}>(args?: Subset<T, FbPostArgs>): Prisma__FbPostClient<FbPostGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FbPostVideo base type for findUnique actions
   */
  export type FbPostVideoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FbPostVideo
     */
    select?: FbPostVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostVideoInclude | null
    /**
     * Filter, which FbPostVideo to fetch.
     */
    where: FbPostVideoWhereUniqueInput
  }

  /**
   * FbPostVideo findUnique
   */
  export interface FbPostVideoFindUniqueArgs extends FbPostVideoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FbPostVideo findUniqueOrThrow
   */
  export type FbPostVideoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FbPostVideo
     */
    select?: FbPostVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostVideoInclude | null
    /**
     * Filter, which FbPostVideo to fetch.
     */
    where: FbPostVideoWhereUniqueInput
  }


  /**
   * FbPostVideo base type for findFirst actions
   */
  export type FbPostVideoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FbPostVideo
     */
    select?: FbPostVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostVideoInclude | null
    /**
     * Filter, which FbPostVideo to fetch.
     */
    where?: FbPostVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbPostVideos to fetch.
     */
    orderBy?: Enumerable<FbPostVideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FbPostVideos.
     */
    cursor?: FbPostVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbPostVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbPostVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FbPostVideos.
     */
    distinct?: Enumerable<FbPostVideoScalarFieldEnum>
  }

  /**
   * FbPostVideo findFirst
   */
  export interface FbPostVideoFindFirstArgs extends FbPostVideoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FbPostVideo findFirstOrThrow
   */
  export type FbPostVideoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FbPostVideo
     */
    select?: FbPostVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostVideoInclude | null
    /**
     * Filter, which FbPostVideo to fetch.
     */
    where?: FbPostVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbPostVideos to fetch.
     */
    orderBy?: Enumerable<FbPostVideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FbPostVideos.
     */
    cursor?: FbPostVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbPostVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbPostVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FbPostVideos.
     */
    distinct?: Enumerable<FbPostVideoScalarFieldEnum>
  }


  /**
   * FbPostVideo findMany
   */
  export type FbPostVideoFindManyArgs = {
    /**
     * Select specific fields to fetch from the FbPostVideo
     */
    select?: FbPostVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostVideoInclude | null
    /**
     * Filter, which FbPostVideos to fetch.
     */
    where?: FbPostVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbPostVideos to fetch.
     */
    orderBy?: Enumerable<FbPostVideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FbPostVideos.
     */
    cursor?: FbPostVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbPostVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbPostVideos.
     */
    skip?: number
    distinct?: Enumerable<FbPostVideoScalarFieldEnum>
  }


  /**
   * FbPostVideo create
   */
  export type FbPostVideoCreateArgs = {
    /**
     * Select specific fields to fetch from the FbPostVideo
     */
    select?: FbPostVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostVideoInclude | null
    /**
     * The data needed to create a FbPostVideo.
     */
    data: XOR<FbPostVideoCreateInput, FbPostVideoUncheckedCreateInput>
  }


  /**
   * FbPostVideo createMany
   */
  export type FbPostVideoCreateManyArgs = {
    /**
     * The data used to create many FbPostVideos.
     */
    data: Enumerable<FbPostVideoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FbPostVideo update
   */
  export type FbPostVideoUpdateArgs = {
    /**
     * Select specific fields to fetch from the FbPostVideo
     */
    select?: FbPostVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostVideoInclude | null
    /**
     * The data needed to update a FbPostVideo.
     */
    data: XOR<FbPostVideoUpdateInput, FbPostVideoUncheckedUpdateInput>
    /**
     * Choose, which FbPostVideo to update.
     */
    where: FbPostVideoWhereUniqueInput
  }


  /**
   * FbPostVideo updateMany
   */
  export type FbPostVideoUpdateManyArgs = {
    /**
     * The data used to update FbPostVideos.
     */
    data: XOR<FbPostVideoUpdateManyMutationInput, FbPostVideoUncheckedUpdateManyInput>
    /**
     * Filter which FbPostVideos to update
     */
    where?: FbPostVideoWhereInput
  }


  /**
   * FbPostVideo upsert
   */
  export type FbPostVideoUpsertArgs = {
    /**
     * Select specific fields to fetch from the FbPostVideo
     */
    select?: FbPostVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostVideoInclude | null
    /**
     * The filter to search for the FbPostVideo to update in case it exists.
     */
    where: FbPostVideoWhereUniqueInput
    /**
     * In case the FbPostVideo found by the `where` argument doesn't exist, create a new FbPostVideo with this data.
     */
    create: XOR<FbPostVideoCreateInput, FbPostVideoUncheckedCreateInput>
    /**
     * In case the FbPostVideo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FbPostVideoUpdateInput, FbPostVideoUncheckedUpdateInput>
  }


  /**
   * FbPostVideo delete
   */
  export type FbPostVideoDeleteArgs = {
    /**
     * Select specific fields to fetch from the FbPostVideo
     */
    select?: FbPostVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostVideoInclude | null
    /**
     * Filter which FbPostVideo to delete.
     */
    where: FbPostVideoWhereUniqueInput
  }


  /**
   * FbPostVideo deleteMany
   */
  export type FbPostVideoDeleteManyArgs = {
    /**
     * Filter which FbPostVideos to delete
     */
    where?: FbPostVideoWhereInput
  }


  /**
   * FbPostVideo without action
   */
  export type FbPostVideoArgs = {
    /**
     * Select specific fields to fetch from the FbPostVideo
     */
    select?: FbPostVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostVideoInclude | null
  }



  /**
   * Model FbHashtag
   */


  export type AggregateFbHashtag = {
    _count: FbHashtagCountAggregateOutputType | null
    _avg: FbHashtagAvgAggregateOutputType | null
    _sum: FbHashtagSumAggregateOutputType | null
    _min: FbHashtagMinAggregateOutputType | null
    _max: FbHashtagMaxAggregateOutputType | null
  }

  export type FbHashtagAvgAggregateOutputType = {
    id: number | null
  }

  export type FbHashtagSumAggregateOutputType = {
    id: number | null
  }

  export type FbHashtagMinAggregateOutputType = {
    id: number | null
    hashtag: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FbHashtagMaxAggregateOutputType = {
    id: number | null
    hashtag: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FbHashtagCountAggregateOutputType = {
    id: number
    hashtag: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FbHashtagAvgAggregateInputType = {
    id?: true
  }

  export type FbHashtagSumAggregateInputType = {
    id?: true
  }

  export type FbHashtagMinAggregateInputType = {
    id?: true
    hashtag?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FbHashtagMaxAggregateInputType = {
    id?: true
    hashtag?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FbHashtagCountAggregateInputType = {
    id?: true
    hashtag?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FbHashtagAggregateArgs = {
    /**
     * Filter which FbHashtag to aggregate.
     */
    where?: FbHashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbHashtags to fetch.
     */
    orderBy?: Enumerable<FbHashtagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FbHashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbHashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbHashtags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FbHashtags
    **/
    _count?: true | FbHashtagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FbHashtagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FbHashtagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FbHashtagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FbHashtagMaxAggregateInputType
  }

  export type GetFbHashtagAggregateType<T extends FbHashtagAggregateArgs> = {
        [P in keyof T & keyof AggregateFbHashtag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFbHashtag[P]>
      : GetScalarType<T[P], AggregateFbHashtag[P]>
  }




  export type FbHashtagGroupByArgs = {
    where?: FbHashtagWhereInput
    orderBy?: Enumerable<FbHashtagOrderByWithAggregationInput>
    by: FbHashtagScalarFieldEnum[]
    having?: FbHashtagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FbHashtagCountAggregateInputType | true
    _avg?: FbHashtagAvgAggregateInputType
    _sum?: FbHashtagSumAggregateInputType
    _min?: FbHashtagMinAggregateInputType
    _max?: FbHashtagMaxAggregateInputType
  }


  export type FbHashtagGroupByOutputType = {
    id: number
    hashtag: string
    createdAt: Date
    updatedAt: Date
    _count: FbHashtagCountAggregateOutputType | null
    _avg: FbHashtagAvgAggregateOutputType | null
    _sum: FbHashtagSumAggregateOutputType | null
    _min: FbHashtagMinAggregateOutputType | null
    _max: FbHashtagMaxAggregateOutputType | null
  }

  type GetFbHashtagGroupByPayload<T extends FbHashtagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FbHashtagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FbHashtagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FbHashtagGroupByOutputType[P]>
            : GetScalarType<T[P], FbHashtagGroupByOutputType[P]>
        }
      >
    >


  export type FbHashtagSelect = {
    id?: boolean
    hashtag?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    postOnHashtags?: boolean | FbHashtag$postOnHashtagsArgs
    _count?: boolean | FbHashtagCountOutputTypeArgs
  }


  export type FbHashtagInclude = {
    postOnHashtags?: boolean | FbHashtag$postOnHashtagsArgs
    _count?: boolean | FbHashtagCountOutputTypeArgs
  }

  export type FbHashtagGetPayload<S extends boolean | null | undefined | FbHashtagArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FbHashtag :
    S extends undefined ? never :
    S extends { include: any } & (FbHashtagArgs | FbHashtagFindManyArgs)
    ? FbHashtag  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'postOnHashtags' ? Array < FbPostOnHashtagGetPayload<S['include'][P]>>  :
        P extends '_count' ? FbHashtagCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FbHashtagArgs | FbHashtagFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'postOnHashtags' ? Array < FbPostOnHashtagGetPayload<S['select'][P]>>  :
        P extends '_count' ? FbHashtagCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof FbHashtag ? FbHashtag[P] : never
  } 
      : FbHashtag


  type FbHashtagCountArgs = 
    Omit<FbHashtagFindManyArgs, 'select' | 'include'> & {
      select?: FbHashtagCountAggregateInputType | true
    }

  export interface FbHashtagDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one FbHashtag that matches the filter.
     * @param {FbHashtagFindUniqueArgs} args - Arguments to find a FbHashtag
     * @example
     * // Get one FbHashtag
     * const fbHashtag = await prisma.fbHashtag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FbHashtagFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FbHashtagFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FbHashtag'> extends True ? Prisma__FbHashtagClient<FbHashtagGetPayload<T>> : Prisma__FbHashtagClient<FbHashtagGetPayload<T> | null, null>

    /**
     * Find one FbHashtag that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FbHashtagFindUniqueOrThrowArgs} args - Arguments to find a FbHashtag
     * @example
     * // Get one FbHashtag
     * const fbHashtag = await prisma.fbHashtag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FbHashtagFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FbHashtagFindUniqueOrThrowArgs>
    ): Prisma__FbHashtagClient<FbHashtagGetPayload<T>>

    /**
     * Find the first FbHashtag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbHashtagFindFirstArgs} args - Arguments to find a FbHashtag
     * @example
     * // Get one FbHashtag
     * const fbHashtag = await prisma.fbHashtag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FbHashtagFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FbHashtagFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FbHashtag'> extends True ? Prisma__FbHashtagClient<FbHashtagGetPayload<T>> : Prisma__FbHashtagClient<FbHashtagGetPayload<T> | null, null>

    /**
     * Find the first FbHashtag that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbHashtagFindFirstOrThrowArgs} args - Arguments to find a FbHashtag
     * @example
     * // Get one FbHashtag
     * const fbHashtag = await prisma.fbHashtag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FbHashtagFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FbHashtagFindFirstOrThrowArgs>
    ): Prisma__FbHashtagClient<FbHashtagGetPayload<T>>

    /**
     * Find zero or more FbHashtags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbHashtagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FbHashtags
     * const fbHashtags = await prisma.fbHashtag.findMany()
     * 
     * // Get first 10 FbHashtags
     * const fbHashtags = await prisma.fbHashtag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fbHashtagWithIdOnly = await prisma.fbHashtag.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FbHashtagFindManyArgs>(
      args?: SelectSubset<T, FbHashtagFindManyArgs>
    ): Prisma.PrismaPromise<Array<FbHashtagGetPayload<T>>>

    /**
     * Create a FbHashtag.
     * @param {FbHashtagCreateArgs} args - Arguments to create a FbHashtag.
     * @example
     * // Create one FbHashtag
     * const FbHashtag = await prisma.fbHashtag.create({
     *   data: {
     *     // ... data to create a FbHashtag
     *   }
     * })
     * 
    **/
    create<T extends FbHashtagCreateArgs>(
      args: SelectSubset<T, FbHashtagCreateArgs>
    ): Prisma__FbHashtagClient<FbHashtagGetPayload<T>>

    /**
     * Create many FbHashtags.
     *     @param {FbHashtagCreateManyArgs} args - Arguments to create many FbHashtags.
     *     @example
     *     // Create many FbHashtags
     *     const fbHashtag = await prisma.fbHashtag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FbHashtagCreateManyArgs>(
      args?: SelectSubset<T, FbHashtagCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FbHashtag.
     * @param {FbHashtagDeleteArgs} args - Arguments to delete one FbHashtag.
     * @example
     * // Delete one FbHashtag
     * const FbHashtag = await prisma.fbHashtag.delete({
     *   where: {
     *     // ... filter to delete one FbHashtag
     *   }
     * })
     * 
    **/
    delete<T extends FbHashtagDeleteArgs>(
      args: SelectSubset<T, FbHashtagDeleteArgs>
    ): Prisma__FbHashtagClient<FbHashtagGetPayload<T>>

    /**
     * Update one FbHashtag.
     * @param {FbHashtagUpdateArgs} args - Arguments to update one FbHashtag.
     * @example
     * // Update one FbHashtag
     * const fbHashtag = await prisma.fbHashtag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FbHashtagUpdateArgs>(
      args: SelectSubset<T, FbHashtagUpdateArgs>
    ): Prisma__FbHashtagClient<FbHashtagGetPayload<T>>

    /**
     * Delete zero or more FbHashtags.
     * @param {FbHashtagDeleteManyArgs} args - Arguments to filter FbHashtags to delete.
     * @example
     * // Delete a few FbHashtags
     * const { count } = await prisma.fbHashtag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FbHashtagDeleteManyArgs>(
      args?: SelectSubset<T, FbHashtagDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FbHashtags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbHashtagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FbHashtags
     * const fbHashtag = await prisma.fbHashtag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FbHashtagUpdateManyArgs>(
      args: SelectSubset<T, FbHashtagUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FbHashtag.
     * @param {FbHashtagUpsertArgs} args - Arguments to update or create a FbHashtag.
     * @example
     * // Update or create a FbHashtag
     * const fbHashtag = await prisma.fbHashtag.upsert({
     *   create: {
     *     // ... data to create a FbHashtag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FbHashtag we want to update
     *   }
     * })
    **/
    upsert<T extends FbHashtagUpsertArgs>(
      args: SelectSubset<T, FbHashtagUpsertArgs>
    ): Prisma__FbHashtagClient<FbHashtagGetPayload<T>>

    /**
     * Count the number of FbHashtags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbHashtagCountArgs} args - Arguments to filter FbHashtags to count.
     * @example
     * // Count the number of FbHashtags
     * const count = await prisma.fbHashtag.count({
     *   where: {
     *     // ... the filter for the FbHashtags we want to count
     *   }
     * })
    **/
    count<T extends FbHashtagCountArgs>(
      args?: Subset<T, FbHashtagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FbHashtagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FbHashtag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbHashtagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FbHashtagAggregateArgs>(args: Subset<T, FbHashtagAggregateArgs>): Prisma.PrismaPromise<GetFbHashtagAggregateType<T>>

    /**
     * Group by FbHashtag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbHashtagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FbHashtagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FbHashtagGroupByArgs['orderBy'] }
        : { orderBy?: FbHashtagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FbHashtagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFbHashtagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FbHashtag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FbHashtagClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    postOnHashtags<T extends FbHashtag$postOnHashtagsArgs= {}>(args?: Subset<T, FbHashtag$postOnHashtagsArgs>): Prisma.PrismaPromise<Array<FbPostOnHashtagGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FbHashtag base type for findUnique actions
   */
  export type FbHashtagFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FbHashtag
     */
    select?: FbHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbHashtagInclude | null
    /**
     * Filter, which FbHashtag to fetch.
     */
    where: FbHashtagWhereUniqueInput
  }

  /**
   * FbHashtag findUnique
   */
  export interface FbHashtagFindUniqueArgs extends FbHashtagFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FbHashtag findUniqueOrThrow
   */
  export type FbHashtagFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FbHashtag
     */
    select?: FbHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbHashtagInclude | null
    /**
     * Filter, which FbHashtag to fetch.
     */
    where: FbHashtagWhereUniqueInput
  }


  /**
   * FbHashtag base type for findFirst actions
   */
  export type FbHashtagFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FbHashtag
     */
    select?: FbHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbHashtagInclude | null
    /**
     * Filter, which FbHashtag to fetch.
     */
    where?: FbHashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbHashtags to fetch.
     */
    orderBy?: Enumerable<FbHashtagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FbHashtags.
     */
    cursor?: FbHashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbHashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbHashtags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FbHashtags.
     */
    distinct?: Enumerable<FbHashtagScalarFieldEnum>
  }

  /**
   * FbHashtag findFirst
   */
  export interface FbHashtagFindFirstArgs extends FbHashtagFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FbHashtag findFirstOrThrow
   */
  export type FbHashtagFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FbHashtag
     */
    select?: FbHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbHashtagInclude | null
    /**
     * Filter, which FbHashtag to fetch.
     */
    where?: FbHashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbHashtags to fetch.
     */
    orderBy?: Enumerable<FbHashtagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FbHashtags.
     */
    cursor?: FbHashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbHashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbHashtags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FbHashtags.
     */
    distinct?: Enumerable<FbHashtagScalarFieldEnum>
  }


  /**
   * FbHashtag findMany
   */
  export type FbHashtagFindManyArgs = {
    /**
     * Select specific fields to fetch from the FbHashtag
     */
    select?: FbHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbHashtagInclude | null
    /**
     * Filter, which FbHashtags to fetch.
     */
    where?: FbHashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbHashtags to fetch.
     */
    orderBy?: Enumerable<FbHashtagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FbHashtags.
     */
    cursor?: FbHashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbHashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbHashtags.
     */
    skip?: number
    distinct?: Enumerable<FbHashtagScalarFieldEnum>
  }


  /**
   * FbHashtag create
   */
  export type FbHashtagCreateArgs = {
    /**
     * Select specific fields to fetch from the FbHashtag
     */
    select?: FbHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbHashtagInclude | null
    /**
     * The data needed to create a FbHashtag.
     */
    data: XOR<FbHashtagCreateInput, FbHashtagUncheckedCreateInput>
  }


  /**
   * FbHashtag createMany
   */
  export type FbHashtagCreateManyArgs = {
    /**
     * The data used to create many FbHashtags.
     */
    data: Enumerable<FbHashtagCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FbHashtag update
   */
  export type FbHashtagUpdateArgs = {
    /**
     * Select specific fields to fetch from the FbHashtag
     */
    select?: FbHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbHashtagInclude | null
    /**
     * The data needed to update a FbHashtag.
     */
    data: XOR<FbHashtagUpdateInput, FbHashtagUncheckedUpdateInput>
    /**
     * Choose, which FbHashtag to update.
     */
    where: FbHashtagWhereUniqueInput
  }


  /**
   * FbHashtag updateMany
   */
  export type FbHashtagUpdateManyArgs = {
    /**
     * The data used to update FbHashtags.
     */
    data: XOR<FbHashtagUpdateManyMutationInput, FbHashtagUncheckedUpdateManyInput>
    /**
     * Filter which FbHashtags to update
     */
    where?: FbHashtagWhereInput
  }


  /**
   * FbHashtag upsert
   */
  export type FbHashtagUpsertArgs = {
    /**
     * Select specific fields to fetch from the FbHashtag
     */
    select?: FbHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbHashtagInclude | null
    /**
     * The filter to search for the FbHashtag to update in case it exists.
     */
    where: FbHashtagWhereUniqueInput
    /**
     * In case the FbHashtag found by the `where` argument doesn't exist, create a new FbHashtag with this data.
     */
    create: XOR<FbHashtagCreateInput, FbHashtagUncheckedCreateInput>
    /**
     * In case the FbHashtag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FbHashtagUpdateInput, FbHashtagUncheckedUpdateInput>
  }


  /**
   * FbHashtag delete
   */
  export type FbHashtagDeleteArgs = {
    /**
     * Select specific fields to fetch from the FbHashtag
     */
    select?: FbHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbHashtagInclude | null
    /**
     * Filter which FbHashtag to delete.
     */
    where: FbHashtagWhereUniqueInput
  }


  /**
   * FbHashtag deleteMany
   */
  export type FbHashtagDeleteManyArgs = {
    /**
     * Filter which FbHashtags to delete
     */
    where?: FbHashtagWhereInput
  }


  /**
   * FbHashtag.postOnHashtags
   */
  export type FbHashtag$postOnHashtagsArgs = {
    /**
     * Select specific fields to fetch from the FbPostOnHashtag
     */
    select?: FbPostOnHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostOnHashtagInclude | null
    where?: FbPostOnHashtagWhereInput
    orderBy?: Enumerable<FbPostOnHashtagOrderByWithRelationInput>
    cursor?: FbPostOnHashtagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FbPostOnHashtagScalarFieldEnum>
  }


  /**
   * FbHashtag without action
   */
  export type FbHashtagArgs = {
    /**
     * Select specific fields to fetch from the FbHashtag
     */
    select?: FbHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbHashtagInclude | null
  }



  /**
   * Model FbPostOnHashtag
   */


  export type AggregateFbPostOnHashtag = {
    _count: FbPostOnHashtagCountAggregateOutputType | null
    _avg: FbPostOnHashtagAvgAggregateOutputType | null
    _sum: FbPostOnHashtagSumAggregateOutputType | null
    _min: FbPostOnHashtagMinAggregateOutputType | null
    _max: FbPostOnHashtagMaxAggregateOutputType | null
  }

  export type FbPostOnHashtagAvgAggregateOutputType = {
    id: number | null
    postId: number | null
    hashtagId: number | null
  }

  export type FbPostOnHashtagSumAggregateOutputType = {
    id: number | null
    postId: number | null
    hashtagId: number | null
  }

  export type FbPostOnHashtagMinAggregateOutputType = {
    id: number | null
    postId: number | null
    hashtagId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FbPostOnHashtagMaxAggregateOutputType = {
    id: number | null
    postId: number | null
    hashtagId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FbPostOnHashtagCountAggregateOutputType = {
    id: number
    postId: number
    hashtagId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FbPostOnHashtagAvgAggregateInputType = {
    id?: true
    postId?: true
    hashtagId?: true
  }

  export type FbPostOnHashtagSumAggregateInputType = {
    id?: true
    postId?: true
    hashtagId?: true
  }

  export type FbPostOnHashtagMinAggregateInputType = {
    id?: true
    postId?: true
    hashtagId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FbPostOnHashtagMaxAggregateInputType = {
    id?: true
    postId?: true
    hashtagId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FbPostOnHashtagCountAggregateInputType = {
    id?: true
    postId?: true
    hashtagId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FbPostOnHashtagAggregateArgs = {
    /**
     * Filter which FbPostOnHashtag to aggregate.
     */
    where?: FbPostOnHashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbPostOnHashtags to fetch.
     */
    orderBy?: Enumerable<FbPostOnHashtagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FbPostOnHashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbPostOnHashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbPostOnHashtags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FbPostOnHashtags
    **/
    _count?: true | FbPostOnHashtagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FbPostOnHashtagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FbPostOnHashtagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FbPostOnHashtagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FbPostOnHashtagMaxAggregateInputType
  }

  export type GetFbPostOnHashtagAggregateType<T extends FbPostOnHashtagAggregateArgs> = {
        [P in keyof T & keyof AggregateFbPostOnHashtag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFbPostOnHashtag[P]>
      : GetScalarType<T[P], AggregateFbPostOnHashtag[P]>
  }




  export type FbPostOnHashtagGroupByArgs = {
    where?: FbPostOnHashtagWhereInput
    orderBy?: Enumerable<FbPostOnHashtagOrderByWithAggregationInput>
    by: FbPostOnHashtagScalarFieldEnum[]
    having?: FbPostOnHashtagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FbPostOnHashtagCountAggregateInputType | true
    _avg?: FbPostOnHashtagAvgAggregateInputType
    _sum?: FbPostOnHashtagSumAggregateInputType
    _min?: FbPostOnHashtagMinAggregateInputType
    _max?: FbPostOnHashtagMaxAggregateInputType
  }


  export type FbPostOnHashtagGroupByOutputType = {
    id: number
    postId: number
    hashtagId: number
    createdAt: Date
    updatedAt: Date
    _count: FbPostOnHashtagCountAggregateOutputType | null
    _avg: FbPostOnHashtagAvgAggregateOutputType | null
    _sum: FbPostOnHashtagSumAggregateOutputType | null
    _min: FbPostOnHashtagMinAggregateOutputType | null
    _max: FbPostOnHashtagMaxAggregateOutputType | null
  }

  type GetFbPostOnHashtagGroupByPayload<T extends FbPostOnHashtagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FbPostOnHashtagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FbPostOnHashtagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FbPostOnHashtagGroupByOutputType[P]>
            : GetScalarType<T[P], FbPostOnHashtagGroupByOutputType[P]>
        }
      >
    >


  export type FbPostOnHashtagSelect = {
    id?: boolean
    post?: boolean | FbPostArgs
    postId?: boolean
    hashtag?: boolean | FbHashtagArgs
    hashtagId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type FbPostOnHashtagInclude = {
    post?: boolean | FbPostArgs
    hashtag?: boolean | FbHashtagArgs
  }

  export type FbPostOnHashtagGetPayload<S extends boolean | null | undefined | FbPostOnHashtagArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FbPostOnHashtag :
    S extends undefined ? never :
    S extends { include: any } & (FbPostOnHashtagArgs | FbPostOnHashtagFindManyArgs)
    ? FbPostOnHashtag  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'post' ? FbPostGetPayload<S['include'][P]> :
        P extends 'hashtag' ? FbHashtagGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FbPostOnHashtagArgs | FbPostOnHashtagFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'post' ? FbPostGetPayload<S['select'][P]> :
        P extends 'hashtag' ? FbHashtagGetPayload<S['select'][P]> :  P extends keyof FbPostOnHashtag ? FbPostOnHashtag[P] : never
  } 
      : FbPostOnHashtag


  type FbPostOnHashtagCountArgs = 
    Omit<FbPostOnHashtagFindManyArgs, 'select' | 'include'> & {
      select?: FbPostOnHashtagCountAggregateInputType | true
    }

  export interface FbPostOnHashtagDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one FbPostOnHashtag that matches the filter.
     * @param {FbPostOnHashtagFindUniqueArgs} args - Arguments to find a FbPostOnHashtag
     * @example
     * // Get one FbPostOnHashtag
     * const fbPostOnHashtag = await prisma.fbPostOnHashtag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FbPostOnHashtagFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FbPostOnHashtagFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FbPostOnHashtag'> extends True ? Prisma__FbPostOnHashtagClient<FbPostOnHashtagGetPayload<T>> : Prisma__FbPostOnHashtagClient<FbPostOnHashtagGetPayload<T> | null, null>

    /**
     * Find one FbPostOnHashtag that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FbPostOnHashtagFindUniqueOrThrowArgs} args - Arguments to find a FbPostOnHashtag
     * @example
     * // Get one FbPostOnHashtag
     * const fbPostOnHashtag = await prisma.fbPostOnHashtag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FbPostOnHashtagFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FbPostOnHashtagFindUniqueOrThrowArgs>
    ): Prisma__FbPostOnHashtagClient<FbPostOnHashtagGetPayload<T>>

    /**
     * Find the first FbPostOnHashtag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbPostOnHashtagFindFirstArgs} args - Arguments to find a FbPostOnHashtag
     * @example
     * // Get one FbPostOnHashtag
     * const fbPostOnHashtag = await prisma.fbPostOnHashtag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FbPostOnHashtagFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FbPostOnHashtagFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FbPostOnHashtag'> extends True ? Prisma__FbPostOnHashtagClient<FbPostOnHashtagGetPayload<T>> : Prisma__FbPostOnHashtagClient<FbPostOnHashtagGetPayload<T> | null, null>

    /**
     * Find the first FbPostOnHashtag that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbPostOnHashtagFindFirstOrThrowArgs} args - Arguments to find a FbPostOnHashtag
     * @example
     * // Get one FbPostOnHashtag
     * const fbPostOnHashtag = await prisma.fbPostOnHashtag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FbPostOnHashtagFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FbPostOnHashtagFindFirstOrThrowArgs>
    ): Prisma__FbPostOnHashtagClient<FbPostOnHashtagGetPayload<T>>

    /**
     * Find zero or more FbPostOnHashtags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbPostOnHashtagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FbPostOnHashtags
     * const fbPostOnHashtags = await prisma.fbPostOnHashtag.findMany()
     * 
     * // Get first 10 FbPostOnHashtags
     * const fbPostOnHashtags = await prisma.fbPostOnHashtag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fbPostOnHashtagWithIdOnly = await prisma.fbPostOnHashtag.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FbPostOnHashtagFindManyArgs>(
      args?: SelectSubset<T, FbPostOnHashtagFindManyArgs>
    ): Prisma.PrismaPromise<Array<FbPostOnHashtagGetPayload<T>>>

    /**
     * Create a FbPostOnHashtag.
     * @param {FbPostOnHashtagCreateArgs} args - Arguments to create a FbPostOnHashtag.
     * @example
     * // Create one FbPostOnHashtag
     * const FbPostOnHashtag = await prisma.fbPostOnHashtag.create({
     *   data: {
     *     // ... data to create a FbPostOnHashtag
     *   }
     * })
     * 
    **/
    create<T extends FbPostOnHashtagCreateArgs>(
      args: SelectSubset<T, FbPostOnHashtagCreateArgs>
    ): Prisma__FbPostOnHashtagClient<FbPostOnHashtagGetPayload<T>>

    /**
     * Create many FbPostOnHashtags.
     *     @param {FbPostOnHashtagCreateManyArgs} args - Arguments to create many FbPostOnHashtags.
     *     @example
     *     // Create many FbPostOnHashtags
     *     const fbPostOnHashtag = await prisma.fbPostOnHashtag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FbPostOnHashtagCreateManyArgs>(
      args?: SelectSubset<T, FbPostOnHashtagCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FbPostOnHashtag.
     * @param {FbPostOnHashtagDeleteArgs} args - Arguments to delete one FbPostOnHashtag.
     * @example
     * // Delete one FbPostOnHashtag
     * const FbPostOnHashtag = await prisma.fbPostOnHashtag.delete({
     *   where: {
     *     // ... filter to delete one FbPostOnHashtag
     *   }
     * })
     * 
    **/
    delete<T extends FbPostOnHashtagDeleteArgs>(
      args: SelectSubset<T, FbPostOnHashtagDeleteArgs>
    ): Prisma__FbPostOnHashtagClient<FbPostOnHashtagGetPayload<T>>

    /**
     * Update one FbPostOnHashtag.
     * @param {FbPostOnHashtagUpdateArgs} args - Arguments to update one FbPostOnHashtag.
     * @example
     * // Update one FbPostOnHashtag
     * const fbPostOnHashtag = await prisma.fbPostOnHashtag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FbPostOnHashtagUpdateArgs>(
      args: SelectSubset<T, FbPostOnHashtagUpdateArgs>
    ): Prisma__FbPostOnHashtagClient<FbPostOnHashtagGetPayload<T>>

    /**
     * Delete zero or more FbPostOnHashtags.
     * @param {FbPostOnHashtagDeleteManyArgs} args - Arguments to filter FbPostOnHashtags to delete.
     * @example
     * // Delete a few FbPostOnHashtags
     * const { count } = await prisma.fbPostOnHashtag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FbPostOnHashtagDeleteManyArgs>(
      args?: SelectSubset<T, FbPostOnHashtagDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FbPostOnHashtags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbPostOnHashtagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FbPostOnHashtags
     * const fbPostOnHashtag = await prisma.fbPostOnHashtag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FbPostOnHashtagUpdateManyArgs>(
      args: SelectSubset<T, FbPostOnHashtagUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FbPostOnHashtag.
     * @param {FbPostOnHashtagUpsertArgs} args - Arguments to update or create a FbPostOnHashtag.
     * @example
     * // Update or create a FbPostOnHashtag
     * const fbPostOnHashtag = await prisma.fbPostOnHashtag.upsert({
     *   create: {
     *     // ... data to create a FbPostOnHashtag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FbPostOnHashtag we want to update
     *   }
     * })
    **/
    upsert<T extends FbPostOnHashtagUpsertArgs>(
      args: SelectSubset<T, FbPostOnHashtagUpsertArgs>
    ): Prisma__FbPostOnHashtagClient<FbPostOnHashtagGetPayload<T>>

    /**
     * Count the number of FbPostOnHashtags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbPostOnHashtagCountArgs} args - Arguments to filter FbPostOnHashtags to count.
     * @example
     * // Count the number of FbPostOnHashtags
     * const count = await prisma.fbPostOnHashtag.count({
     *   where: {
     *     // ... the filter for the FbPostOnHashtags we want to count
     *   }
     * })
    **/
    count<T extends FbPostOnHashtagCountArgs>(
      args?: Subset<T, FbPostOnHashtagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FbPostOnHashtagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FbPostOnHashtag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbPostOnHashtagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FbPostOnHashtagAggregateArgs>(args: Subset<T, FbPostOnHashtagAggregateArgs>): Prisma.PrismaPromise<GetFbPostOnHashtagAggregateType<T>>

    /**
     * Group by FbPostOnHashtag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbPostOnHashtagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FbPostOnHashtagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FbPostOnHashtagGroupByArgs['orderBy'] }
        : { orderBy?: FbPostOnHashtagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FbPostOnHashtagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFbPostOnHashtagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FbPostOnHashtag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FbPostOnHashtagClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    post<T extends FbPostArgs= {}>(args?: Subset<T, FbPostArgs>): Prisma__FbPostClient<FbPostGetPayload<T> | Null>;

    hashtag<T extends FbHashtagArgs= {}>(args?: Subset<T, FbHashtagArgs>): Prisma__FbHashtagClient<FbHashtagGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FbPostOnHashtag base type for findUnique actions
   */
  export type FbPostOnHashtagFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FbPostOnHashtag
     */
    select?: FbPostOnHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostOnHashtagInclude | null
    /**
     * Filter, which FbPostOnHashtag to fetch.
     */
    where: FbPostOnHashtagWhereUniqueInput
  }

  /**
   * FbPostOnHashtag findUnique
   */
  export interface FbPostOnHashtagFindUniqueArgs extends FbPostOnHashtagFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FbPostOnHashtag findUniqueOrThrow
   */
  export type FbPostOnHashtagFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FbPostOnHashtag
     */
    select?: FbPostOnHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostOnHashtagInclude | null
    /**
     * Filter, which FbPostOnHashtag to fetch.
     */
    where: FbPostOnHashtagWhereUniqueInput
  }


  /**
   * FbPostOnHashtag base type for findFirst actions
   */
  export type FbPostOnHashtagFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FbPostOnHashtag
     */
    select?: FbPostOnHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostOnHashtagInclude | null
    /**
     * Filter, which FbPostOnHashtag to fetch.
     */
    where?: FbPostOnHashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbPostOnHashtags to fetch.
     */
    orderBy?: Enumerable<FbPostOnHashtagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FbPostOnHashtags.
     */
    cursor?: FbPostOnHashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbPostOnHashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbPostOnHashtags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FbPostOnHashtags.
     */
    distinct?: Enumerable<FbPostOnHashtagScalarFieldEnum>
  }

  /**
   * FbPostOnHashtag findFirst
   */
  export interface FbPostOnHashtagFindFirstArgs extends FbPostOnHashtagFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FbPostOnHashtag findFirstOrThrow
   */
  export type FbPostOnHashtagFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FbPostOnHashtag
     */
    select?: FbPostOnHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostOnHashtagInclude | null
    /**
     * Filter, which FbPostOnHashtag to fetch.
     */
    where?: FbPostOnHashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbPostOnHashtags to fetch.
     */
    orderBy?: Enumerable<FbPostOnHashtagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FbPostOnHashtags.
     */
    cursor?: FbPostOnHashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbPostOnHashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbPostOnHashtags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FbPostOnHashtags.
     */
    distinct?: Enumerable<FbPostOnHashtagScalarFieldEnum>
  }


  /**
   * FbPostOnHashtag findMany
   */
  export type FbPostOnHashtagFindManyArgs = {
    /**
     * Select specific fields to fetch from the FbPostOnHashtag
     */
    select?: FbPostOnHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostOnHashtagInclude | null
    /**
     * Filter, which FbPostOnHashtags to fetch.
     */
    where?: FbPostOnHashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbPostOnHashtags to fetch.
     */
    orderBy?: Enumerable<FbPostOnHashtagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FbPostOnHashtags.
     */
    cursor?: FbPostOnHashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbPostOnHashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbPostOnHashtags.
     */
    skip?: number
    distinct?: Enumerable<FbPostOnHashtagScalarFieldEnum>
  }


  /**
   * FbPostOnHashtag create
   */
  export type FbPostOnHashtagCreateArgs = {
    /**
     * Select specific fields to fetch from the FbPostOnHashtag
     */
    select?: FbPostOnHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostOnHashtagInclude | null
    /**
     * The data needed to create a FbPostOnHashtag.
     */
    data: XOR<FbPostOnHashtagCreateInput, FbPostOnHashtagUncheckedCreateInput>
  }


  /**
   * FbPostOnHashtag createMany
   */
  export type FbPostOnHashtagCreateManyArgs = {
    /**
     * The data used to create many FbPostOnHashtags.
     */
    data: Enumerable<FbPostOnHashtagCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FbPostOnHashtag update
   */
  export type FbPostOnHashtagUpdateArgs = {
    /**
     * Select specific fields to fetch from the FbPostOnHashtag
     */
    select?: FbPostOnHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostOnHashtagInclude | null
    /**
     * The data needed to update a FbPostOnHashtag.
     */
    data: XOR<FbPostOnHashtagUpdateInput, FbPostOnHashtagUncheckedUpdateInput>
    /**
     * Choose, which FbPostOnHashtag to update.
     */
    where: FbPostOnHashtagWhereUniqueInput
  }


  /**
   * FbPostOnHashtag updateMany
   */
  export type FbPostOnHashtagUpdateManyArgs = {
    /**
     * The data used to update FbPostOnHashtags.
     */
    data: XOR<FbPostOnHashtagUpdateManyMutationInput, FbPostOnHashtagUncheckedUpdateManyInput>
    /**
     * Filter which FbPostOnHashtags to update
     */
    where?: FbPostOnHashtagWhereInput
  }


  /**
   * FbPostOnHashtag upsert
   */
  export type FbPostOnHashtagUpsertArgs = {
    /**
     * Select specific fields to fetch from the FbPostOnHashtag
     */
    select?: FbPostOnHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostOnHashtagInclude | null
    /**
     * The filter to search for the FbPostOnHashtag to update in case it exists.
     */
    where: FbPostOnHashtagWhereUniqueInput
    /**
     * In case the FbPostOnHashtag found by the `where` argument doesn't exist, create a new FbPostOnHashtag with this data.
     */
    create: XOR<FbPostOnHashtagCreateInput, FbPostOnHashtagUncheckedCreateInput>
    /**
     * In case the FbPostOnHashtag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FbPostOnHashtagUpdateInput, FbPostOnHashtagUncheckedUpdateInput>
  }


  /**
   * FbPostOnHashtag delete
   */
  export type FbPostOnHashtagDeleteArgs = {
    /**
     * Select specific fields to fetch from the FbPostOnHashtag
     */
    select?: FbPostOnHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostOnHashtagInclude | null
    /**
     * Filter which FbPostOnHashtag to delete.
     */
    where: FbPostOnHashtagWhereUniqueInput
  }


  /**
   * FbPostOnHashtag deleteMany
   */
  export type FbPostOnHashtagDeleteManyArgs = {
    /**
     * Filter which FbPostOnHashtags to delete
     */
    where?: FbPostOnHashtagWhereInput
  }


  /**
   * FbPostOnHashtag without action
   */
  export type FbPostOnHashtagArgs = {
    /**
     * Select specific fields to fetch from the FbPostOnHashtag
     */
    select?: FbPostOnHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostOnHashtagInclude | null
  }



  /**
   * Model FbLike
   */


  export type AggregateFbLike = {
    _count: FbLikeCountAggregateOutputType | null
    _avg: FbLikeAvgAggregateOutputType | null
    _sum: FbLikeSumAggregateOutputType | null
    _min: FbLikeMinAggregateOutputType | null
    _max: FbLikeMaxAggregateOutputType | null
  }

  export type FbLikeAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    postId: number | null
    commentId: number | null
    shareId: number | null
  }

  export type FbLikeSumAggregateOutputType = {
    id: number | null
    userId: number | null
    postId: number | null
    commentId: number | null
    shareId: number | null
  }

  export type FbLikeMinAggregateOutputType = {
    id: number | null
    userId: number | null
    postId: number | null
    commentId: number | null
    shareId: number | null
    likeType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FbLikeMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    postId: number | null
    commentId: number | null
    shareId: number | null
    likeType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FbLikeCountAggregateOutputType = {
    id: number
    userId: number
    postId: number
    commentId: number
    shareId: number
    likeType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FbLikeAvgAggregateInputType = {
    id?: true
    userId?: true
    postId?: true
    commentId?: true
    shareId?: true
  }

  export type FbLikeSumAggregateInputType = {
    id?: true
    userId?: true
    postId?: true
    commentId?: true
    shareId?: true
  }

  export type FbLikeMinAggregateInputType = {
    id?: true
    userId?: true
    postId?: true
    commentId?: true
    shareId?: true
    likeType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FbLikeMaxAggregateInputType = {
    id?: true
    userId?: true
    postId?: true
    commentId?: true
    shareId?: true
    likeType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FbLikeCountAggregateInputType = {
    id?: true
    userId?: true
    postId?: true
    commentId?: true
    shareId?: true
    likeType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FbLikeAggregateArgs = {
    /**
     * Filter which FbLike to aggregate.
     */
    where?: FbLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbLikes to fetch.
     */
    orderBy?: Enumerable<FbLikeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FbLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FbLikes
    **/
    _count?: true | FbLikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FbLikeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FbLikeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FbLikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FbLikeMaxAggregateInputType
  }

  export type GetFbLikeAggregateType<T extends FbLikeAggregateArgs> = {
        [P in keyof T & keyof AggregateFbLike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFbLike[P]>
      : GetScalarType<T[P], AggregateFbLike[P]>
  }




  export type FbLikeGroupByArgs = {
    where?: FbLikeWhereInput
    orderBy?: Enumerable<FbLikeOrderByWithAggregationInput>
    by: FbLikeScalarFieldEnum[]
    having?: FbLikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FbLikeCountAggregateInputType | true
    _avg?: FbLikeAvgAggregateInputType
    _sum?: FbLikeSumAggregateInputType
    _min?: FbLikeMinAggregateInputType
    _max?: FbLikeMaxAggregateInputType
  }


  export type FbLikeGroupByOutputType = {
    id: number
    userId: number
    postId: number
    commentId: number
    shareId: number
    likeType: string
    createdAt: Date
    updatedAt: Date
    _count: FbLikeCountAggregateOutputType | null
    _avg: FbLikeAvgAggregateOutputType | null
    _sum: FbLikeSumAggregateOutputType | null
    _min: FbLikeMinAggregateOutputType | null
    _max: FbLikeMaxAggregateOutputType | null
  }

  type GetFbLikeGroupByPayload<T extends FbLikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FbLikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FbLikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FbLikeGroupByOutputType[P]>
            : GetScalarType<T[P], FbLikeGroupByOutputType[P]>
        }
      >
    >


  export type FbLikeSelect = {
    id?: boolean
    user?: boolean | FbUserArgs
    userId?: boolean
    post?: boolean | FbPostArgs
    postId?: boolean
    comment?: boolean | FbCommentArgs
    commentId?: boolean
    share?: boolean | FbShareArgs
    shareId?: boolean
    likeType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type FbLikeInclude = {
    user?: boolean | FbUserArgs
    post?: boolean | FbPostArgs
    comment?: boolean | FbCommentArgs
    share?: boolean | FbShareArgs
  }

  export type FbLikeGetPayload<S extends boolean | null | undefined | FbLikeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FbLike :
    S extends undefined ? never :
    S extends { include: any } & (FbLikeArgs | FbLikeFindManyArgs)
    ? FbLike  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? FbUserGetPayload<S['include'][P]> :
        P extends 'post' ? FbPostGetPayload<S['include'][P]> :
        P extends 'comment' ? FbCommentGetPayload<S['include'][P]> :
        P extends 'share' ? FbShareGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FbLikeArgs | FbLikeFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? FbUserGetPayload<S['select'][P]> :
        P extends 'post' ? FbPostGetPayload<S['select'][P]> :
        P extends 'comment' ? FbCommentGetPayload<S['select'][P]> :
        P extends 'share' ? FbShareGetPayload<S['select'][P]> :  P extends keyof FbLike ? FbLike[P] : never
  } 
      : FbLike


  type FbLikeCountArgs = 
    Omit<FbLikeFindManyArgs, 'select' | 'include'> & {
      select?: FbLikeCountAggregateInputType | true
    }

  export interface FbLikeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one FbLike that matches the filter.
     * @param {FbLikeFindUniqueArgs} args - Arguments to find a FbLike
     * @example
     * // Get one FbLike
     * const fbLike = await prisma.fbLike.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FbLikeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FbLikeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FbLike'> extends True ? Prisma__FbLikeClient<FbLikeGetPayload<T>> : Prisma__FbLikeClient<FbLikeGetPayload<T> | null, null>

    /**
     * Find one FbLike that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FbLikeFindUniqueOrThrowArgs} args - Arguments to find a FbLike
     * @example
     * // Get one FbLike
     * const fbLike = await prisma.fbLike.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FbLikeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FbLikeFindUniqueOrThrowArgs>
    ): Prisma__FbLikeClient<FbLikeGetPayload<T>>

    /**
     * Find the first FbLike that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbLikeFindFirstArgs} args - Arguments to find a FbLike
     * @example
     * // Get one FbLike
     * const fbLike = await prisma.fbLike.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FbLikeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FbLikeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FbLike'> extends True ? Prisma__FbLikeClient<FbLikeGetPayload<T>> : Prisma__FbLikeClient<FbLikeGetPayload<T> | null, null>

    /**
     * Find the first FbLike that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbLikeFindFirstOrThrowArgs} args - Arguments to find a FbLike
     * @example
     * // Get one FbLike
     * const fbLike = await prisma.fbLike.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FbLikeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FbLikeFindFirstOrThrowArgs>
    ): Prisma__FbLikeClient<FbLikeGetPayload<T>>

    /**
     * Find zero or more FbLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbLikeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FbLikes
     * const fbLikes = await prisma.fbLike.findMany()
     * 
     * // Get first 10 FbLikes
     * const fbLikes = await prisma.fbLike.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fbLikeWithIdOnly = await prisma.fbLike.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FbLikeFindManyArgs>(
      args?: SelectSubset<T, FbLikeFindManyArgs>
    ): Prisma.PrismaPromise<Array<FbLikeGetPayload<T>>>

    /**
     * Create a FbLike.
     * @param {FbLikeCreateArgs} args - Arguments to create a FbLike.
     * @example
     * // Create one FbLike
     * const FbLike = await prisma.fbLike.create({
     *   data: {
     *     // ... data to create a FbLike
     *   }
     * })
     * 
    **/
    create<T extends FbLikeCreateArgs>(
      args: SelectSubset<T, FbLikeCreateArgs>
    ): Prisma__FbLikeClient<FbLikeGetPayload<T>>

    /**
     * Create many FbLikes.
     *     @param {FbLikeCreateManyArgs} args - Arguments to create many FbLikes.
     *     @example
     *     // Create many FbLikes
     *     const fbLike = await prisma.fbLike.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FbLikeCreateManyArgs>(
      args?: SelectSubset<T, FbLikeCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FbLike.
     * @param {FbLikeDeleteArgs} args - Arguments to delete one FbLike.
     * @example
     * // Delete one FbLike
     * const FbLike = await prisma.fbLike.delete({
     *   where: {
     *     // ... filter to delete one FbLike
     *   }
     * })
     * 
    **/
    delete<T extends FbLikeDeleteArgs>(
      args: SelectSubset<T, FbLikeDeleteArgs>
    ): Prisma__FbLikeClient<FbLikeGetPayload<T>>

    /**
     * Update one FbLike.
     * @param {FbLikeUpdateArgs} args - Arguments to update one FbLike.
     * @example
     * // Update one FbLike
     * const fbLike = await prisma.fbLike.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FbLikeUpdateArgs>(
      args: SelectSubset<T, FbLikeUpdateArgs>
    ): Prisma__FbLikeClient<FbLikeGetPayload<T>>

    /**
     * Delete zero or more FbLikes.
     * @param {FbLikeDeleteManyArgs} args - Arguments to filter FbLikes to delete.
     * @example
     * // Delete a few FbLikes
     * const { count } = await prisma.fbLike.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FbLikeDeleteManyArgs>(
      args?: SelectSubset<T, FbLikeDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FbLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbLikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FbLikes
     * const fbLike = await prisma.fbLike.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FbLikeUpdateManyArgs>(
      args: SelectSubset<T, FbLikeUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FbLike.
     * @param {FbLikeUpsertArgs} args - Arguments to update or create a FbLike.
     * @example
     * // Update or create a FbLike
     * const fbLike = await prisma.fbLike.upsert({
     *   create: {
     *     // ... data to create a FbLike
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FbLike we want to update
     *   }
     * })
    **/
    upsert<T extends FbLikeUpsertArgs>(
      args: SelectSubset<T, FbLikeUpsertArgs>
    ): Prisma__FbLikeClient<FbLikeGetPayload<T>>

    /**
     * Count the number of FbLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbLikeCountArgs} args - Arguments to filter FbLikes to count.
     * @example
     * // Count the number of FbLikes
     * const count = await prisma.fbLike.count({
     *   where: {
     *     // ... the filter for the FbLikes we want to count
     *   }
     * })
    **/
    count<T extends FbLikeCountArgs>(
      args?: Subset<T, FbLikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FbLikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FbLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbLikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FbLikeAggregateArgs>(args: Subset<T, FbLikeAggregateArgs>): Prisma.PrismaPromise<GetFbLikeAggregateType<T>>

    /**
     * Group by FbLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbLikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FbLikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FbLikeGroupByArgs['orderBy'] }
        : { orderBy?: FbLikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FbLikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFbLikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FbLike.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FbLikeClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends FbUserArgs= {}>(args?: Subset<T, FbUserArgs>): Prisma__FbUserClient<FbUserGetPayload<T> | Null>;

    post<T extends FbPostArgs= {}>(args?: Subset<T, FbPostArgs>): Prisma__FbPostClient<FbPostGetPayload<T> | Null>;

    comment<T extends FbCommentArgs= {}>(args?: Subset<T, FbCommentArgs>): Prisma__FbCommentClient<FbCommentGetPayload<T> | Null>;

    share<T extends FbShareArgs= {}>(args?: Subset<T, FbShareArgs>): Prisma__FbShareClient<FbShareGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FbLike base type for findUnique actions
   */
  export type FbLikeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FbLike
     */
    select?: FbLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbLikeInclude | null
    /**
     * Filter, which FbLike to fetch.
     */
    where: FbLikeWhereUniqueInput
  }

  /**
   * FbLike findUnique
   */
  export interface FbLikeFindUniqueArgs extends FbLikeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FbLike findUniqueOrThrow
   */
  export type FbLikeFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FbLike
     */
    select?: FbLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbLikeInclude | null
    /**
     * Filter, which FbLike to fetch.
     */
    where: FbLikeWhereUniqueInput
  }


  /**
   * FbLike base type for findFirst actions
   */
  export type FbLikeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FbLike
     */
    select?: FbLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbLikeInclude | null
    /**
     * Filter, which FbLike to fetch.
     */
    where?: FbLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbLikes to fetch.
     */
    orderBy?: Enumerable<FbLikeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FbLikes.
     */
    cursor?: FbLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FbLikes.
     */
    distinct?: Enumerable<FbLikeScalarFieldEnum>
  }

  /**
   * FbLike findFirst
   */
  export interface FbLikeFindFirstArgs extends FbLikeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FbLike findFirstOrThrow
   */
  export type FbLikeFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FbLike
     */
    select?: FbLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbLikeInclude | null
    /**
     * Filter, which FbLike to fetch.
     */
    where?: FbLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbLikes to fetch.
     */
    orderBy?: Enumerable<FbLikeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FbLikes.
     */
    cursor?: FbLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FbLikes.
     */
    distinct?: Enumerable<FbLikeScalarFieldEnum>
  }


  /**
   * FbLike findMany
   */
  export type FbLikeFindManyArgs = {
    /**
     * Select specific fields to fetch from the FbLike
     */
    select?: FbLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbLikeInclude | null
    /**
     * Filter, which FbLikes to fetch.
     */
    where?: FbLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbLikes to fetch.
     */
    orderBy?: Enumerable<FbLikeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FbLikes.
     */
    cursor?: FbLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbLikes.
     */
    skip?: number
    distinct?: Enumerable<FbLikeScalarFieldEnum>
  }


  /**
   * FbLike create
   */
  export type FbLikeCreateArgs = {
    /**
     * Select specific fields to fetch from the FbLike
     */
    select?: FbLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbLikeInclude | null
    /**
     * The data needed to create a FbLike.
     */
    data: XOR<FbLikeCreateInput, FbLikeUncheckedCreateInput>
  }


  /**
   * FbLike createMany
   */
  export type FbLikeCreateManyArgs = {
    /**
     * The data used to create many FbLikes.
     */
    data: Enumerable<FbLikeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FbLike update
   */
  export type FbLikeUpdateArgs = {
    /**
     * Select specific fields to fetch from the FbLike
     */
    select?: FbLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbLikeInclude | null
    /**
     * The data needed to update a FbLike.
     */
    data: XOR<FbLikeUpdateInput, FbLikeUncheckedUpdateInput>
    /**
     * Choose, which FbLike to update.
     */
    where: FbLikeWhereUniqueInput
  }


  /**
   * FbLike updateMany
   */
  export type FbLikeUpdateManyArgs = {
    /**
     * The data used to update FbLikes.
     */
    data: XOR<FbLikeUpdateManyMutationInput, FbLikeUncheckedUpdateManyInput>
    /**
     * Filter which FbLikes to update
     */
    where?: FbLikeWhereInput
  }


  /**
   * FbLike upsert
   */
  export type FbLikeUpsertArgs = {
    /**
     * Select specific fields to fetch from the FbLike
     */
    select?: FbLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbLikeInclude | null
    /**
     * The filter to search for the FbLike to update in case it exists.
     */
    where: FbLikeWhereUniqueInput
    /**
     * In case the FbLike found by the `where` argument doesn't exist, create a new FbLike with this data.
     */
    create: XOR<FbLikeCreateInput, FbLikeUncheckedCreateInput>
    /**
     * In case the FbLike was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FbLikeUpdateInput, FbLikeUncheckedUpdateInput>
  }


  /**
   * FbLike delete
   */
  export type FbLikeDeleteArgs = {
    /**
     * Select specific fields to fetch from the FbLike
     */
    select?: FbLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbLikeInclude | null
    /**
     * Filter which FbLike to delete.
     */
    where: FbLikeWhereUniqueInput
  }


  /**
   * FbLike deleteMany
   */
  export type FbLikeDeleteManyArgs = {
    /**
     * Filter which FbLikes to delete
     */
    where?: FbLikeWhereInput
  }


  /**
   * FbLike without action
   */
  export type FbLikeArgs = {
    /**
     * Select specific fields to fetch from the FbLike
     */
    select?: FbLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbLikeInclude | null
  }



  /**
   * Model FbShare
   */


  export type AggregateFbShare = {
    _count: FbShareCountAggregateOutputType | null
    _avg: FbShareAvgAggregateOutputType | null
    _sum: FbShareSumAggregateOutputType | null
    _min: FbShareMinAggregateOutputType | null
    _max: FbShareMaxAggregateOutputType | null
  }

  export type FbShareAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    postId: number | null
  }

  export type FbShareSumAggregateOutputType = {
    id: number | null
    userId: number | null
    postId: number | null
  }

  export type FbShareMinAggregateOutputType = {
    id: number | null
    userId: number | null
    postId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FbShareMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    postId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FbShareCountAggregateOutputType = {
    id: number
    userId: number
    postId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FbShareAvgAggregateInputType = {
    id?: true
    userId?: true
    postId?: true
  }

  export type FbShareSumAggregateInputType = {
    id?: true
    userId?: true
    postId?: true
  }

  export type FbShareMinAggregateInputType = {
    id?: true
    userId?: true
    postId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FbShareMaxAggregateInputType = {
    id?: true
    userId?: true
    postId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FbShareCountAggregateInputType = {
    id?: true
    userId?: true
    postId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FbShareAggregateArgs = {
    /**
     * Filter which FbShare to aggregate.
     */
    where?: FbShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbShares to fetch.
     */
    orderBy?: Enumerable<FbShareOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FbShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FbShares
    **/
    _count?: true | FbShareCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FbShareAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FbShareSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FbShareMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FbShareMaxAggregateInputType
  }

  export type GetFbShareAggregateType<T extends FbShareAggregateArgs> = {
        [P in keyof T & keyof AggregateFbShare]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFbShare[P]>
      : GetScalarType<T[P], AggregateFbShare[P]>
  }




  export type FbShareGroupByArgs = {
    where?: FbShareWhereInput
    orderBy?: Enumerable<FbShareOrderByWithAggregationInput>
    by: FbShareScalarFieldEnum[]
    having?: FbShareScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FbShareCountAggregateInputType | true
    _avg?: FbShareAvgAggregateInputType
    _sum?: FbShareSumAggregateInputType
    _min?: FbShareMinAggregateInputType
    _max?: FbShareMaxAggregateInputType
  }


  export type FbShareGroupByOutputType = {
    id: number
    userId: number
    postId: number
    createdAt: Date
    updatedAt: Date
    _count: FbShareCountAggregateOutputType | null
    _avg: FbShareAvgAggregateOutputType | null
    _sum: FbShareSumAggregateOutputType | null
    _min: FbShareMinAggregateOutputType | null
    _max: FbShareMaxAggregateOutputType | null
  }

  type GetFbShareGroupByPayload<T extends FbShareGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FbShareGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FbShareGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FbShareGroupByOutputType[P]>
            : GetScalarType<T[P], FbShareGroupByOutputType[P]>
        }
      >
    >


  export type FbShareSelect = {
    id?: boolean
    user?: boolean | FbUserArgs
    userId?: boolean
    post?: boolean | FbPostArgs
    postId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    likes?: boolean | FbShare$likesArgs
    destinationUsers?: boolean | FbShare$destinationUsersArgs
    _count?: boolean | FbShareCountOutputTypeArgs
  }


  export type FbShareInclude = {
    user?: boolean | FbUserArgs
    post?: boolean | FbPostArgs
    likes?: boolean | FbShare$likesArgs
    destinationUsers?: boolean | FbShare$destinationUsersArgs
    _count?: boolean | FbShareCountOutputTypeArgs
  }

  export type FbShareGetPayload<S extends boolean | null | undefined | FbShareArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FbShare :
    S extends undefined ? never :
    S extends { include: any } & (FbShareArgs | FbShareFindManyArgs)
    ? FbShare  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? FbUserGetPayload<S['include'][P]> :
        P extends 'post' ? FbPostGetPayload<S['include'][P]> :
        P extends 'likes' ? Array < FbLikeGetPayload<S['include'][P]>>  :
        P extends 'destinationUsers' ? Array < FbDestinationUserGetPayload<S['include'][P]>>  :
        P extends '_count' ? FbShareCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FbShareArgs | FbShareFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? FbUserGetPayload<S['select'][P]> :
        P extends 'post' ? FbPostGetPayload<S['select'][P]> :
        P extends 'likes' ? Array < FbLikeGetPayload<S['select'][P]>>  :
        P extends 'destinationUsers' ? Array < FbDestinationUserGetPayload<S['select'][P]>>  :
        P extends '_count' ? FbShareCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof FbShare ? FbShare[P] : never
  } 
      : FbShare


  type FbShareCountArgs = 
    Omit<FbShareFindManyArgs, 'select' | 'include'> & {
      select?: FbShareCountAggregateInputType | true
    }

  export interface FbShareDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one FbShare that matches the filter.
     * @param {FbShareFindUniqueArgs} args - Arguments to find a FbShare
     * @example
     * // Get one FbShare
     * const fbShare = await prisma.fbShare.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FbShareFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FbShareFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FbShare'> extends True ? Prisma__FbShareClient<FbShareGetPayload<T>> : Prisma__FbShareClient<FbShareGetPayload<T> | null, null>

    /**
     * Find one FbShare that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FbShareFindUniqueOrThrowArgs} args - Arguments to find a FbShare
     * @example
     * // Get one FbShare
     * const fbShare = await prisma.fbShare.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FbShareFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FbShareFindUniqueOrThrowArgs>
    ): Prisma__FbShareClient<FbShareGetPayload<T>>

    /**
     * Find the first FbShare that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbShareFindFirstArgs} args - Arguments to find a FbShare
     * @example
     * // Get one FbShare
     * const fbShare = await prisma.fbShare.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FbShareFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FbShareFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FbShare'> extends True ? Prisma__FbShareClient<FbShareGetPayload<T>> : Prisma__FbShareClient<FbShareGetPayload<T> | null, null>

    /**
     * Find the first FbShare that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbShareFindFirstOrThrowArgs} args - Arguments to find a FbShare
     * @example
     * // Get one FbShare
     * const fbShare = await prisma.fbShare.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FbShareFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FbShareFindFirstOrThrowArgs>
    ): Prisma__FbShareClient<FbShareGetPayload<T>>

    /**
     * Find zero or more FbShares that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbShareFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FbShares
     * const fbShares = await prisma.fbShare.findMany()
     * 
     * // Get first 10 FbShares
     * const fbShares = await prisma.fbShare.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fbShareWithIdOnly = await prisma.fbShare.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FbShareFindManyArgs>(
      args?: SelectSubset<T, FbShareFindManyArgs>
    ): Prisma.PrismaPromise<Array<FbShareGetPayload<T>>>

    /**
     * Create a FbShare.
     * @param {FbShareCreateArgs} args - Arguments to create a FbShare.
     * @example
     * // Create one FbShare
     * const FbShare = await prisma.fbShare.create({
     *   data: {
     *     // ... data to create a FbShare
     *   }
     * })
     * 
    **/
    create<T extends FbShareCreateArgs>(
      args: SelectSubset<T, FbShareCreateArgs>
    ): Prisma__FbShareClient<FbShareGetPayload<T>>

    /**
     * Create many FbShares.
     *     @param {FbShareCreateManyArgs} args - Arguments to create many FbShares.
     *     @example
     *     // Create many FbShares
     *     const fbShare = await prisma.fbShare.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FbShareCreateManyArgs>(
      args?: SelectSubset<T, FbShareCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FbShare.
     * @param {FbShareDeleteArgs} args - Arguments to delete one FbShare.
     * @example
     * // Delete one FbShare
     * const FbShare = await prisma.fbShare.delete({
     *   where: {
     *     // ... filter to delete one FbShare
     *   }
     * })
     * 
    **/
    delete<T extends FbShareDeleteArgs>(
      args: SelectSubset<T, FbShareDeleteArgs>
    ): Prisma__FbShareClient<FbShareGetPayload<T>>

    /**
     * Update one FbShare.
     * @param {FbShareUpdateArgs} args - Arguments to update one FbShare.
     * @example
     * // Update one FbShare
     * const fbShare = await prisma.fbShare.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FbShareUpdateArgs>(
      args: SelectSubset<T, FbShareUpdateArgs>
    ): Prisma__FbShareClient<FbShareGetPayload<T>>

    /**
     * Delete zero or more FbShares.
     * @param {FbShareDeleteManyArgs} args - Arguments to filter FbShares to delete.
     * @example
     * // Delete a few FbShares
     * const { count } = await prisma.fbShare.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FbShareDeleteManyArgs>(
      args?: SelectSubset<T, FbShareDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FbShares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbShareUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FbShares
     * const fbShare = await prisma.fbShare.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FbShareUpdateManyArgs>(
      args: SelectSubset<T, FbShareUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FbShare.
     * @param {FbShareUpsertArgs} args - Arguments to update or create a FbShare.
     * @example
     * // Update or create a FbShare
     * const fbShare = await prisma.fbShare.upsert({
     *   create: {
     *     // ... data to create a FbShare
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FbShare we want to update
     *   }
     * })
    **/
    upsert<T extends FbShareUpsertArgs>(
      args: SelectSubset<T, FbShareUpsertArgs>
    ): Prisma__FbShareClient<FbShareGetPayload<T>>

    /**
     * Count the number of FbShares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbShareCountArgs} args - Arguments to filter FbShares to count.
     * @example
     * // Count the number of FbShares
     * const count = await prisma.fbShare.count({
     *   where: {
     *     // ... the filter for the FbShares we want to count
     *   }
     * })
    **/
    count<T extends FbShareCountArgs>(
      args?: Subset<T, FbShareCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FbShareCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FbShare.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbShareAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FbShareAggregateArgs>(args: Subset<T, FbShareAggregateArgs>): Prisma.PrismaPromise<GetFbShareAggregateType<T>>

    /**
     * Group by FbShare.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbShareGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FbShareGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FbShareGroupByArgs['orderBy'] }
        : { orderBy?: FbShareGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FbShareGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFbShareGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FbShare.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FbShareClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends FbUserArgs= {}>(args?: Subset<T, FbUserArgs>): Prisma__FbUserClient<FbUserGetPayload<T> | Null>;

    post<T extends FbPostArgs= {}>(args?: Subset<T, FbPostArgs>): Prisma__FbPostClient<FbPostGetPayload<T> | Null>;

    likes<T extends FbShare$likesArgs= {}>(args?: Subset<T, FbShare$likesArgs>): Prisma.PrismaPromise<Array<FbLikeGetPayload<T>>| Null>;

    destinationUsers<T extends FbShare$destinationUsersArgs= {}>(args?: Subset<T, FbShare$destinationUsersArgs>): Prisma.PrismaPromise<Array<FbDestinationUserGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FbShare base type for findUnique actions
   */
  export type FbShareFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FbShare
     */
    select?: FbShareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbShareInclude | null
    /**
     * Filter, which FbShare to fetch.
     */
    where: FbShareWhereUniqueInput
  }

  /**
   * FbShare findUnique
   */
  export interface FbShareFindUniqueArgs extends FbShareFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FbShare findUniqueOrThrow
   */
  export type FbShareFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FbShare
     */
    select?: FbShareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbShareInclude | null
    /**
     * Filter, which FbShare to fetch.
     */
    where: FbShareWhereUniqueInput
  }


  /**
   * FbShare base type for findFirst actions
   */
  export type FbShareFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FbShare
     */
    select?: FbShareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbShareInclude | null
    /**
     * Filter, which FbShare to fetch.
     */
    where?: FbShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbShares to fetch.
     */
    orderBy?: Enumerable<FbShareOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FbShares.
     */
    cursor?: FbShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FbShares.
     */
    distinct?: Enumerable<FbShareScalarFieldEnum>
  }

  /**
   * FbShare findFirst
   */
  export interface FbShareFindFirstArgs extends FbShareFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FbShare findFirstOrThrow
   */
  export type FbShareFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FbShare
     */
    select?: FbShareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbShareInclude | null
    /**
     * Filter, which FbShare to fetch.
     */
    where?: FbShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbShares to fetch.
     */
    orderBy?: Enumerable<FbShareOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FbShares.
     */
    cursor?: FbShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FbShares.
     */
    distinct?: Enumerable<FbShareScalarFieldEnum>
  }


  /**
   * FbShare findMany
   */
  export type FbShareFindManyArgs = {
    /**
     * Select specific fields to fetch from the FbShare
     */
    select?: FbShareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbShareInclude | null
    /**
     * Filter, which FbShares to fetch.
     */
    where?: FbShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbShares to fetch.
     */
    orderBy?: Enumerable<FbShareOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FbShares.
     */
    cursor?: FbShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbShares.
     */
    skip?: number
    distinct?: Enumerable<FbShareScalarFieldEnum>
  }


  /**
   * FbShare create
   */
  export type FbShareCreateArgs = {
    /**
     * Select specific fields to fetch from the FbShare
     */
    select?: FbShareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbShareInclude | null
    /**
     * The data needed to create a FbShare.
     */
    data: XOR<FbShareCreateInput, FbShareUncheckedCreateInput>
  }


  /**
   * FbShare createMany
   */
  export type FbShareCreateManyArgs = {
    /**
     * The data used to create many FbShares.
     */
    data: Enumerable<FbShareCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FbShare update
   */
  export type FbShareUpdateArgs = {
    /**
     * Select specific fields to fetch from the FbShare
     */
    select?: FbShareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbShareInclude | null
    /**
     * The data needed to update a FbShare.
     */
    data: XOR<FbShareUpdateInput, FbShareUncheckedUpdateInput>
    /**
     * Choose, which FbShare to update.
     */
    where: FbShareWhereUniqueInput
  }


  /**
   * FbShare updateMany
   */
  export type FbShareUpdateManyArgs = {
    /**
     * The data used to update FbShares.
     */
    data: XOR<FbShareUpdateManyMutationInput, FbShareUncheckedUpdateManyInput>
    /**
     * Filter which FbShares to update
     */
    where?: FbShareWhereInput
  }


  /**
   * FbShare upsert
   */
  export type FbShareUpsertArgs = {
    /**
     * Select specific fields to fetch from the FbShare
     */
    select?: FbShareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbShareInclude | null
    /**
     * The filter to search for the FbShare to update in case it exists.
     */
    where: FbShareWhereUniqueInput
    /**
     * In case the FbShare found by the `where` argument doesn't exist, create a new FbShare with this data.
     */
    create: XOR<FbShareCreateInput, FbShareUncheckedCreateInput>
    /**
     * In case the FbShare was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FbShareUpdateInput, FbShareUncheckedUpdateInput>
  }


  /**
   * FbShare delete
   */
  export type FbShareDeleteArgs = {
    /**
     * Select specific fields to fetch from the FbShare
     */
    select?: FbShareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbShareInclude | null
    /**
     * Filter which FbShare to delete.
     */
    where: FbShareWhereUniqueInput
  }


  /**
   * FbShare deleteMany
   */
  export type FbShareDeleteManyArgs = {
    /**
     * Filter which FbShares to delete
     */
    where?: FbShareWhereInput
  }


  /**
   * FbShare.likes
   */
  export type FbShare$likesArgs = {
    /**
     * Select specific fields to fetch from the FbLike
     */
    select?: FbLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbLikeInclude | null
    where?: FbLikeWhereInput
    orderBy?: Enumerable<FbLikeOrderByWithRelationInput>
    cursor?: FbLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FbLikeScalarFieldEnum>
  }


  /**
   * FbShare.destinationUsers
   */
  export type FbShare$destinationUsersArgs = {
    /**
     * Select specific fields to fetch from the FbDestinationUser
     */
    select?: FbDestinationUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbDestinationUserInclude | null
    where?: FbDestinationUserWhereInput
    orderBy?: Enumerable<FbDestinationUserOrderByWithRelationInput>
    cursor?: FbDestinationUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FbDestinationUserScalarFieldEnum>
  }


  /**
   * FbShare without action
   */
  export type FbShareArgs = {
    /**
     * Select specific fields to fetch from the FbShare
     */
    select?: FbShareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbShareInclude | null
  }



  /**
   * Model Fbfriend
   */


  export type AggregateFbfriend = {
    _count: FbfriendCountAggregateOutputType | null
    _avg: FbfriendAvgAggregateOutputType | null
    _sum: FbfriendSumAggregateOutputType | null
    _min: FbfriendMinAggregateOutputType | null
    _max: FbfriendMaxAggregateOutputType | null
  }

  export type FbfriendAvgAggregateOutputType = {
    id: number | null
    acceptId: number | null
    requestId: number | null
  }

  export type FbfriendSumAggregateOutputType = {
    id: number | null
    acceptId: number | null
    requestId: number | null
  }

  export type FbfriendMinAggregateOutputType = {
    id: number | null
    acceptId: number | null
    requestId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FbfriendMaxAggregateOutputType = {
    id: number | null
    acceptId: number | null
    requestId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FbfriendCountAggregateOutputType = {
    id: number
    acceptId: number
    requestId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FbfriendAvgAggregateInputType = {
    id?: true
    acceptId?: true
    requestId?: true
  }

  export type FbfriendSumAggregateInputType = {
    id?: true
    acceptId?: true
    requestId?: true
  }

  export type FbfriendMinAggregateInputType = {
    id?: true
    acceptId?: true
    requestId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FbfriendMaxAggregateInputType = {
    id?: true
    acceptId?: true
    requestId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FbfriendCountAggregateInputType = {
    id?: true
    acceptId?: true
    requestId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FbfriendAggregateArgs = {
    /**
     * Filter which Fbfriend to aggregate.
     */
    where?: FbfriendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fbfriends to fetch.
     */
    orderBy?: Enumerable<FbfriendOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FbfriendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fbfriends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fbfriends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Fbfriends
    **/
    _count?: true | FbfriendCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FbfriendAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FbfriendSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FbfriendMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FbfriendMaxAggregateInputType
  }

  export type GetFbfriendAggregateType<T extends FbfriendAggregateArgs> = {
        [P in keyof T & keyof AggregateFbfriend]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFbfriend[P]>
      : GetScalarType<T[P], AggregateFbfriend[P]>
  }




  export type FbfriendGroupByArgs = {
    where?: FbfriendWhereInput
    orderBy?: Enumerable<FbfriendOrderByWithAggregationInput>
    by: FbfriendScalarFieldEnum[]
    having?: FbfriendScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FbfriendCountAggregateInputType | true
    _avg?: FbfriendAvgAggregateInputType
    _sum?: FbfriendSumAggregateInputType
    _min?: FbfriendMinAggregateInputType
    _max?: FbfriendMaxAggregateInputType
  }


  export type FbfriendGroupByOutputType = {
    id: number
    acceptId: number
    requestId: number
    createdAt: Date
    updatedAt: Date
    _count: FbfriendCountAggregateOutputType | null
    _avg: FbfriendAvgAggregateOutputType | null
    _sum: FbfriendSumAggregateOutputType | null
    _min: FbfriendMinAggregateOutputType | null
    _max: FbfriendMaxAggregateOutputType | null
  }

  type GetFbfriendGroupByPayload<T extends FbfriendGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FbfriendGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FbfriendGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FbfriendGroupByOutputType[P]>
            : GetScalarType<T[P], FbfriendGroupByOutputType[P]>
        }
      >
    >


  export type FbfriendSelect = {
    id?: boolean
    acceptFriend?: boolean | FbUserArgs
    acceptId?: boolean
    requestFriend?: boolean | FbUserArgs
    requestId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type FbfriendInclude = {
    acceptFriend?: boolean | FbUserArgs
    requestFriend?: boolean | FbUserArgs
  }

  export type FbfriendGetPayload<S extends boolean | null | undefined | FbfriendArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Fbfriend :
    S extends undefined ? never :
    S extends { include: any } & (FbfriendArgs | FbfriendFindManyArgs)
    ? Fbfriend  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'acceptFriend' ? FbUserGetPayload<S['include'][P]> :
        P extends 'requestFriend' ? FbUserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FbfriendArgs | FbfriendFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'acceptFriend' ? FbUserGetPayload<S['select'][P]> :
        P extends 'requestFriend' ? FbUserGetPayload<S['select'][P]> :  P extends keyof Fbfriend ? Fbfriend[P] : never
  } 
      : Fbfriend


  type FbfriendCountArgs = 
    Omit<FbfriendFindManyArgs, 'select' | 'include'> & {
      select?: FbfriendCountAggregateInputType | true
    }

  export interface FbfriendDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Fbfriend that matches the filter.
     * @param {FbfriendFindUniqueArgs} args - Arguments to find a Fbfriend
     * @example
     * // Get one Fbfriend
     * const fbfriend = await prisma.fbfriend.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FbfriendFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FbfriendFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Fbfriend'> extends True ? Prisma__FbfriendClient<FbfriendGetPayload<T>> : Prisma__FbfriendClient<FbfriendGetPayload<T> | null, null>

    /**
     * Find one Fbfriend that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FbfriendFindUniqueOrThrowArgs} args - Arguments to find a Fbfriend
     * @example
     * // Get one Fbfriend
     * const fbfriend = await prisma.fbfriend.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FbfriendFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FbfriendFindUniqueOrThrowArgs>
    ): Prisma__FbfriendClient<FbfriendGetPayload<T>>

    /**
     * Find the first Fbfriend that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbfriendFindFirstArgs} args - Arguments to find a Fbfriend
     * @example
     * // Get one Fbfriend
     * const fbfriend = await prisma.fbfriend.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FbfriendFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FbfriendFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Fbfriend'> extends True ? Prisma__FbfriendClient<FbfriendGetPayload<T>> : Prisma__FbfriendClient<FbfriendGetPayload<T> | null, null>

    /**
     * Find the first Fbfriend that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbfriendFindFirstOrThrowArgs} args - Arguments to find a Fbfriend
     * @example
     * // Get one Fbfriend
     * const fbfriend = await prisma.fbfriend.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FbfriendFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FbfriendFindFirstOrThrowArgs>
    ): Prisma__FbfriendClient<FbfriendGetPayload<T>>

    /**
     * Find zero or more Fbfriends that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbfriendFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fbfriends
     * const fbfriends = await prisma.fbfriend.findMany()
     * 
     * // Get first 10 Fbfriends
     * const fbfriends = await prisma.fbfriend.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fbfriendWithIdOnly = await prisma.fbfriend.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FbfriendFindManyArgs>(
      args?: SelectSubset<T, FbfriendFindManyArgs>
    ): Prisma.PrismaPromise<Array<FbfriendGetPayload<T>>>

    /**
     * Create a Fbfriend.
     * @param {FbfriendCreateArgs} args - Arguments to create a Fbfriend.
     * @example
     * // Create one Fbfriend
     * const Fbfriend = await prisma.fbfriend.create({
     *   data: {
     *     // ... data to create a Fbfriend
     *   }
     * })
     * 
    **/
    create<T extends FbfriendCreateArgs>(
      args: SelectSubset<T, FbfriendCreateArgs>
    ): Prisma__FbfriendClient<FbfriendGetPayload<T>>

    /**
     * Create many Fbfriends.
     *     @param {FbfriendCreateManyArgs} args - Arguments to create many Fbfriends.
     *     @example
     *     // Create many Fbfriends
     *     const fbfriend = await prisma.fbfriend.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FbfriendCreateManyArgs>(
      args?: SelectSubset<T, FbfriendCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Fbfriend.
     * @param {FbfriendDeleteArgs} args - Arguments to delete one Fbfriend.
     * @example
     * // Delete one Fbfriend
     * const Fbfriend = await prisma.fbfriend.delete({
     *   where: {
     *     // ... filter to delete one Fbfriend
     *   }
     * })
     * 
    **/
    delete<T extends FbfriendDeleteArgs>(
      args: SelectSubset<T, FbfriendDeleteArgs>
    ): Prisma__FbfriendClient<FbfriendGetPayload<T>>

    /**
     * Update one Fbfriend.
     * @param {FbfriendUpdateArgs} args - Arguments to update one Fbfriend.
     * @example
     * // Update one Fbfriend
     * const fbfriend = await prisma.fbfriend.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FbfriendUpdateArgs>(
      args: SelectSubset<T, FbfriendUpdateArgs>
    ): Prisma__FbfriendClient<FbfriendGetPayload<T>>

    /**
     * Delete zero or more Fbfriends.
     * @param {FbfriendDeleteManyArgs} args - Arguments to filter Fbfriends to delete.
     * @example
     * // Delete a few Fbfriends
     * const { count } = await prisma.fbfriend.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FbfriendDeleteManyArgs>(
      args?: SelectSubset<T, FbfriendDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fbfriends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbfriendUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fbfriends
     * const fbfriend = await prisma.fbfriend.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FbfriendUpdateManyArgs>(
      args: SelectSubset<T, FbfriendUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Fbfriend.
     * @param {FbfriendUpsertArgs} args - Arguments to update or create a Fbfriend.
     * @example
     * // Update or create a Fbfriend
     * const fbfriend = await prisma.fbfriend.upsert({
     *   create: {
     *     // ... data to create a Fbfriend
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fbfriend we want to update
     *   }
     * })
    **/
    upsert<T extends FbfriendUpsertArgs>(
      args: SelectSubset<T, FbfriendUpsertArgs>
    ): Prisma__FbfriendClient<FbfriendGetPayload<T>>

    /**
     * Count the number of Fbfriends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbfriendCountArgs} args - Arguments to filter Fbfriends to count.
     * @example
     * // Count the number of Fbfriends
     * const count = await prisma.fbfriend.count({
     *   where: {
     *     // ... the filter for the Fbfriends we want to count
     *   }
     * })
    **/
    count<T extends FbfriendCountArgs>(
      args?: Subset<T, FbfriendCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FbfriendCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fbfriend.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbfriendAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FbfriendAggregateArgs>(args: Subset<T, FbfriendAggregateArgs>): Prisma.PrismaPromise<GetFbfriendAggregateType<T>>

    /**
     * Group by Fbfriend.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbfriendGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FbfriendGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FbfriendGroupByArgs['orderBy'] }
        : { orderBy?: FbfriendGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FbfriendGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFbfriendGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Fbfriend.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FbfriendClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    acceptFriend<T extends FbUserArgs= {}>(args?: Subset<T, FbUserArgs>): Prisma__FbUserClient<FbUserGetPayload<T> | Null>;

    requestFriend<T extends FbUserArgs= {}>(args?: Subset<T, FbUserArgs>): Prisma__FbUserClient<FbUserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Fbfriend base type for findUnique actions
   */
  export type FbfriendFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Fbfriend
     */
    select?: FbfriendSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbfriendInclude | null
    /**
     * Filter, which Fbfriend to fetch.
     */
    where: FbfriendWhereUniqueInput
  }

  /**
   * Fbfriend findUnique
   */
  export interface FbfriendFindUniqueArgs extends FbfriendFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Fbfriend findUniqueOrThrow
   */
  export type FbfriendFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Fbfriend
     */
    select?: FbfriendSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbfriendInclude | null
    /**
     * Filter, which Fbfriend to fetch.
     */
    where: FbfriendWhereUniqueInput
  }


  /**
   * Fbfriend base type for findFirst actions
   */
  export type FbfriendFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Fbfriend
     */
    select?: FbfriendSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbfriendInclude | null
    /**
     * Filter, which Fbfriend to fetch.
     */
    where?: FbfriendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fbfriends to fetch.
     */
    orderBy?: Enumerable<FbfriendOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fbfriends.
     */
    cursor?: FbfriendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fbfriends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fbfriends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fbfriends.
     */
    distinct?: Enumerable<FbfriendScalarFieldEnum>
  }

  /**
   * Fbfriend findFirst
   */
  export interface FbfriendFindFirstArgs extends FbfriendFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Fbfriend findFirstOrThrow
   */
  export type FbfriendFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Fbfriend
     */
    select?: FbfriendSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbfriendInclude | null
    /**
     * Filter, which Fbfriend to fetch.
     */
    where?: FbfriendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fbfriends to fetch.
     */
    orderBy?: Enumerable<FbfriendOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fbfriends.
     */
    cursor?: FbfriendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fbfriends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fbfriends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fbfriends.
     */
    distinct?: Enumerable<FbfriendScalarFieldEnum>
  }


  /**
   * Fbfriend findMany
   */
  export type FbfriendFindManyArgs = {
    /**
     * Select specific fields to fetch from the Fbfriend
     */
    select?: FbfriendSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbfriendInclude | null
    /**
     * Filter, which Fbfriends to fetch.
     */
    where?: FbfriendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fbfriends to fetch.
     */
    orderBy?: Enumerable<FbfriendOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Fbfriends.
     */
    cursor?: FbfriendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fbfriends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fbfriends.
     */
    skip?: number
    distinct?: Enumerable<FbfriendScalarFieldEnum>
  }


  /**
   * Fbfriend create
   */
  export type FbfriendCreateArgs = {
    /**
     * Select specific fields to fetch from the Fbfriend
     */
    select?: FbfriendSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbfriendInclude | null
    /**
     * The data needed to create a Fbfriend.
     */
    data: XOR<FbfriendCreateInput, FbfriendUncheckedCreateInput>
  }


  /**
   * Fbfriend createMany
   */
  export type FbfriendCreateManyArgs = {
    /**
     * The data used to create many Fbfriends.
     */
    data: Enumerable<FbfriendCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Fbfriend update
   */
  export type FbfriendUpdateArgs = {
    /**
     * Select specific fields to fetch from the Fbfriend
     */
    select?: FbfriendSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbfriendInclude | null
    /**
     * The data needed to update a Fbfriend.
     */
    data: XOR<FbfriendUpdateInput, FbfriendUncheckedUpdateInput>
    /**
     * Choose, which Fbfriend to update.
     */
    where: FbfriendWhereUniqueInput
  }


  /**
   * Fbfriend updateMany
   */
  export type FbfriendUpdateManyArgs = {
    /**
     * The data used to update Fbfriends.
     */
    data: XOR<FbfriendUpdateManyMutationInput, FbfriendUncheckedUpdateManyInput>
    /**
     * Filter which Fbfriends to update
     */
    where?: FbfriendWhereInput
  }


  /**
   * Fbfriend upsert
   */
  export type FbfriendUpsertArgs = {
    /**
     * Select specific fields to fetch from the Fbfriend
     */
    select?: FbfriendSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbfriendInclude | null
    /**
     * The filter to search for the Fbfriend to update in case it exists.
     */
    where: FbfriendWhereUniqueInput
    /**
     * In case the Fbfriend found by the `where` argument doesn't exist, create a new Fbfriend with this data.
     */
    create: XOR<FbfriendCreateInput, FbfriendUncheckedCreateInput>
    /**
     * In case the Fbfriend was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FbfriendUpdateInput, FbfriendUncheckedUpdateInput>
  }


  /**
   * Fbfriend delete
   */
  export type FbfriendDeleteArgs = {
    /**
     * Select specific fields to fetch from the Fbfriend
     */
    select?: FbfriendSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbfriendInclude | null
    /**
     * Filter which Fbfriend to delete.
     */
    where: FbfriendWhereUniqueInput
  }


  /**
   * Fbfriend deleteMany
   */
  export type FbfriendDeleteManyArgs = {
    /**
     * Filter which Fbfriends to delete
     */
    where?: FbfriendWhereInput
  }


  /**
   * Fbfriend without action
   */
  export type FbfriendArgs = {
    /**
     * Select specific fields to fetch from the Fbfriend
     */
    select?: FbfriendSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbfriendInclude | null
  }



  /**
   * Model FbMessenger
   */


  export type AggregateFbMessenger = {
    _count: FbMessengerCountAggregateOutputType | null
    _avg: FbMessengerAvgAggregateOutputType | null
    _sum: FbMessengerSumAggregateOutputType | null
    _min: FbMessengerMinAggregateOutputType | null
    _max: FbMessengerMaxAggregateOutputType | null
  }

  export type FbMessengerAvgAggregateOutputType = {
    id: number | null
    fromuserId: number | null
    toUserId: number | null
  }

  export type FbMessengerSumAggregateOutputType = {
    id: number | null
    fromuserId: number | null
    toUserId: number | null
  }

  export type FbMessengerMinAggregateOutputType = {
    id: number | null
    fromuserId: number | null
    toUserId: number | null
    text: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FbMessengerMaxAggregateOutputType = {
    id: number | null
    fromuserId: number | null
    toUserId: number | null
    text: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FbMessengerCountAggregateOutputType = {
    id: number
    fromuserId: number
    toUserId: number
    text: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FbMessengerAvgAggregateInputType = {
    id?: true
    fromuserId?: true
    toUserId?: true
  }

  export type FbMessengerSumAggregateInputType = {
    id?: true
    fromuserId?: true
    toUserId?: true
  }

  export type FbMessengerMinAggregateInputType = {
    id?: true
    fromuserId?: true
    toUserId?: true
    text?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FbMessengerMaxAggregateInputType = {
    id?: true
    fromuserId?: true
    toUserId?: true
    text?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FbMessengerCountAggregateInputType = {
    id?: true
    fromuserId?: true
    toUserId?: true
    text?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FbMessengerAggregateArgs = {
    /**
     * Filter which FbMessenger to aggregate.
     */
    where?: FbMessengerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbMessengers to fetch.
     */
    orderBy?: Enumerable<FbMessengerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FbMessengerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbMessengers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbMessengers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FbMessengers
    **/
    _count?: true | FbMessengerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FbMessengerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FbMessengerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FbMessengerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FbMessengerMaxAggregateInputType
  }

  export type GetFbMessengerAggregateType<T extends FbMessengerAggregateArgs> = {
        [P in keyof T & keyof AggregateFbMessenger]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFbMessenger[P]>
      : GetScalarType<T[P], AggregateFbMessenger[P]>
  }




  export type FbMessengerGroupByArgs = {
    where?: FbMessengerWhereInput
    orderBy?: Enumerable<FbMessengerOrderByWithAggregationInput>
    by: FbMessengerScalarFieldEnum[]
    having?: FbMessengerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FbMessengerCountAggregateInputType | true
    _avg?: FbMessengerAvgAggregateInputType
    _sum?: FbMessengerSumAggregateInputType
    _min?: FbMessengerMinAggregateInputType
    _max?: FbMessengerMaxAggregateInputType
  }


  export type FbMessengerGroupByOutputType = {
    id: number
    fromuserId: number
    toUserId: number
    text: string
    createdAt: Date
    updatedAt: Date
    _count: FbMessengerCountAggregateOutputType | null
    _avg: FbMessengerAvgAggregateOutputType | null
    _sum: FbMessengerSumAggregateOutputType | null
    _min: FbMessengerMinAggregateOutputType | null
    _max: FbMessengerMaxAggregateOutputType | null
  }

  type GetFbMessengerGroupByPayload<T extends FbMessengerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FbMessengerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FbMessengerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FbMessengerGroupByOutputType[P]>
            : GetScalarType<T[P], FbMessengerGroupByOutputType[P]>
        }
      >
    >


  export type FbMessengerSelect = {
    id?: boolean
    from?: boolean | FbUserArgs
    fromuserId?: boolean
    to?: boolean | FbUserArgs
    toUserId?: boolean
    text?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type FbMessengerInclude = {
    from?: boolean | FbUserArgs
    to?: boolean | FbUserArgs
  }

  export type FbMessengerGetPayload<S extends boolean | null | undefined | FbMessengerArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FbMessenger :
    S extends undefined ? never :
    S extends { include: any } & (FbMessengerArgs | FbMessengerFindManyArgs)
    ? FbMessenger  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'from' ? FbUserGetPayload<S['include'][P]> :
        P extends 'to' ? FbUserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FbMessengerArgs | FbMessengerFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'from' ? FbUserGetPayload<S['select'][P]> :
        P extends 'to' ? FbUserGetPayload<S['select'][P]> :  P extends keyof FbMessenger ? FbMessenger[P] : never
  } 
      : FbMessenger


  type FbMessengerCountArgs = 
    Omit<FbMessengerFindManyArgs, 'select' | 'include'> & {
      select?: FbMessengerCountAggregateInputType | true
    }

  export interface FbMessengerDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one FbMessenger that matches the filter.
     * @param {FbMessengerFindUniqueArgs} args - Arguments to find a FbMessenger
     * @example
     * // Get one FbMessenger
     * const fbMessenger = await prisma.fbMessenger.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FbMessengerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FbMessengerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FbMessenger'> extends True ? Prisma__FbMessengerClient<FbMessengerGetPayload<T>> : Prisma__FbMessengerClient<FbMessengerGetPayload<T> | null, null>

    /**
     * Find one FbMessenger that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FbMessengerFindUniqueOrThrowArgs} args - Arguments to find a FbMessenger
     * @example
     * // Get one FbMessenger
     * const fbMessenger = await prisma.fbMessenger.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FbMessengerFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FbMessengerFindUniqueOrThrowArgs>
    ): Prisma__FbMessengerClient<FbMessengerGetPayload<T>>

    /**
     * Find the first FbMessenger that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbMessengerFindFirstArgs} args - Arguments to find a FbMessenger
     * @example
     * // Get one FbMessenger
     * const fbMessenger = await prisma.fbMessenger.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FbMessengerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FbMessengerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FbMessenger'> extends True ? Prisma__FbMessengerClient<FbMessengerGetPayload<T>> : Prisma__FbMessengerClient<FbMessengerGetPayload<T> | null, null>

    /**
     * Find the first FbMessenger that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbMessengerFindFirstOrThrowArgs} args - Arguments to find a FbMessenger
     * @example
     * // Get one FbMessenger
     * const fbMessenger = await prisma.fbMessenger.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FbMessengerFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FbMessengerFindFirstOrThrowArgs>
    ): Prisma__FbMessengerClient<FbMessengerGetPayload<T>>

    /**
     * Find zero or more FbMessengers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbMessengerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FbMessengers
     * const fbMessengers = await prisma.fbMessenger.findMany()
     * 
     * // Get first 10 FbMessengers
     * const fbMessengers = await prisma.fbMessenger.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fbMessengerWithIdOnly = await prisma.fbMessenger.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FbMessengerFindManyArgs>(
      args?: SelectSubset<T, FbMessengerFindManyArgs>
    ): Prisma.PrismaPromise<Array<FbMessengerGetPayload<T>>>

    /**
     * Create a FbMessenger.
     * @param {FbMessengerCreateArgs} args - Arguments to create a FbMessenger.
     * @example
     * // Create one FbMessenger
     * const FbMessenger = await prisma.fbMessenger.create({
     *   data: {
     *     // ... data to create a FbMessenger
     *   }
     * })
     * 
    **/
    create<T extends FbMessengerCreateArgs>(
      args: SelectSubset<T, FbMessengerCreateArgs>
    ): Prisma__FbMessengerClient<FbMessengerGetPayload<T>>

    /**
     * Create many FbMessengers.
     *     @param {FbMessengerCreateManyArgs} args - Arguments to create many FbMessengers.
     *     @example
     *     // Create many FbMessengers
     *     const fbMessenger = await prisma.fbMessenger.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FbMessengerCreateManyArgs>(
      args?: SelectSubset<T, FbMessengerCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FbMessenger.
     * @param {FbMessengerDeleteArgs} args - Arguments to delete one FbMessenger.
     * @example
     * // Delete one FbMessenger
     * const FbMessenger = await prisma.fbMessenger.delete({
     *   where: {
     *     // ... filter to delete one FbMessenger
     *   }
     * })
     * 
    **/
    delete<T extends FbMessengerDeleteArgs>(
      args: SelectSubset<T, FbMessengerDeleteArgs>
    ): Prisma__FbMessengerClient<FbMessengerGetPayload<T>>

    /**
     * Update one FbMessenger.
     * @param {FbMessengerUpdateArgs} args - Arguments to update one FbMessenger.
     * @example
     * // Update one FbMessenger
     * const fbMessenger = await prisma.fbMessenger.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FbMessengerUpdateArgs>(
      args: SelectSubset<T, FbMessengerUpdateArgs>
    ): Prisma__FbMessengerClient<FbMessengerGetPayload<T>>

    /**
     * Delete zero or more FbMessengers.
     * @param {FbMessengerDeleteManyArgs} args - Arguments to filter FbMessengers to delete.
     * @example
     * // Delete a few FbMessengers
     * const { count } = await prisma.fbMessenger.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FbMessengerDeleteManyArgs>(
      args?: SelectSubset<T, FbMessengerDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FbMessengers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbMessengerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FbMessengers
     * const fbMessenger = await prisma.fbMessenger.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FbMessengerUpdateManyArgs>(
      args: SelectSubset<T, FbMessengerUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FbMessenger.
     * @param {FbMessengerUpsertArgs} args - Arguments to update or create a FbMessenger.
     * @example
     * // Update or create a FbMessenger
     * const fbMessenger = await prisma.fbMessenger.upsert({
     *   create: {
     *     // ... data to create a FbMessenger
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FbMessenger we want to update
     *   }
     * })
    **/
    upsert<T extends FbMessengerUpsertArgs>(
      args: SelectSubset<T, FbMessengerUpsertArgs>
    ): Prisma__FbMessengerClient<FbMessengerGetPayload<T>>

    /**
     * Count the number of FbMessengers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbMessengerCountArgs} args - Arguments to filter FbMessengers to count.
     * @example
     * // Count the number of FbMessengers
     * const count = await prisma.fbMessenger.count({
     *   where: {
     *     // ... the filter for the FbMessengers we want to count
     *   }
     * })
    **/
    count<T extends FbMessengerCountArgs>(
      args?: Subset<T, FbMessengerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FbMessengerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FbMessenger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbMessengerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FbMessengerAggregateArgs>(args: Subset<T, FbMessengerAggregateArgs>): Prisma.PrismaPromise<GetFbMessengerAggregateType<T>>

    /**
     * Group by FbMessenger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbMessengerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FbMessengerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FbMessengerGroupByArgs['orderBy'] }
        : { orderBy?: FbMessengerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FbMessengerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFbMessengerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FbMessenger.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FbMessengerClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    from<T extends FbUserArgs= {}>(args?: Subset<T, FbUserArgs>): Prisma__FbUserClient<FbUserGetPayload<T> | Null>;

    to<T extends FbUserArgs= {}>(args?: Subset<T, FbUserArgs>): Prisma__FbUserClient<FbUserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FbMessenger base type for findUnique actions
   */
  export type FbMessengerFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FbMessenger
     */
    select?: FbMessengerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbMessengerInclude | null
    /**
     * Filter, which FbMessenger to fetch.
     */
    where: FbMessengerWhereUniqueInput
  }

  /**
   * FbMessenger findUnique
   */
  export interface FbMessengerFindUniqueArgs extends FbMessengerFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FbMessenger findUniqueOrThrow
   */
  export type FbMessengerFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FbMessenger
     */
    select?: FbMessengerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbMessengerInclude | null
    /**
     * Filter, which FbMessenger to fetch.
     */
    where: FbMessengerWhereUniqueInput
  }


  /**
   * FbMessenger base type for findFirst actions
   */
  export type FbMessengerFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FbMessenger
     */
    select?: FbMessengerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbMessengerInclude | null
    /**
     * Filter, which FbMessenger to fetch.
     */
    where?: FbMessengerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbMessengers to fetch.
     */
    orderBy?: Enumerable<FbMessengerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FbMessengers.
     */
    cursor?: FbMessengerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbMessengers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbMessengers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FbMessengers.
     */
    distinct?: Enumerable<FbMessengerScalarFieldEnum>
  }

  /**
   * FbMessenger findFirst
   */
  export interface FbMessengerFindFirstArgs extends FbMessengerFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FbMessenger findFirstOrThrow
   */
  export type FbMessengerFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FbMessenger
     */
    select?: FbMessengerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbMessengerInclude | null
    /**
     * Filter, which FbMessenger to fetch.
     */
    where?: FbMessengerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbMessengers to fetch.
     */
    orderBy?: Enumerable<FbMessengerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FbMessengers.
     */
    cursor?: FbMessengerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbMessengers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbMessengers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FbMessengers.
     */
    distinct?: Enumerable<FbMessengerScalarFieldEnum>
  }


  /**
   * FbMessenger findMany
   */
  export type FbMessengerFindManyArgs = {
    /**
     * Select specific fields to fetch from the FbMessenger
     */
    select?: FbMessengerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbMessengerInclude | null
    /**
     * Filter, which FbMessengers to fetch.
     */
    where?: FbMessengerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbMessengers to fetch.
     */
    orderBy?: Enumerable<FbMessengerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FbMessengers.
     */
    cursor?: FbMessengerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbMessengers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbMessengers.
     */
    skip?: number
    distinct?: Enumerable<FbMessengerScalarFieldEnum>
  }


  /**
   * FbMessenger create
   */
  export type FbMessengerCreateArgs = {
    /**
     * Select specific fields to fetch from the FbMessenger
     */
    select?: FbMessengerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbMessengerInclude | null
    /**
     * The data needed to create a FbMessenger.
     */
    data: XOR<FbMessengerCreateInput, FbMessengerUncheckedCreateInput>
  }


  /**
   * FbMessenger createMany
   */
  export type FbMessengerCreateManyArgs = {
    /**
     * The data used to create many FbMessengers.
     */
    data: Enumerable<FbMessengerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FbMessenger update
   */
  export type FbMessengerUpdateArgs = {
    /**
     * Select specific fields to fetch from the FbMessenger
     */
    select?: FbMessengerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbMessengerInclude | null
    /**
     * The data needed to update a FbMessenger.
     */
    data: XOR<FbMessengerUpdateInput, FbMessengerUncheckedUpdateInput>
    /**
     * Choose, which FbMessenger to update.
     */
    where: FbMessengerWhereUniqueInput
  }


  /**
   * FbMessenger updateMany
   */
  export type FbMessengerUpdateManyArgs = {
    /**
     * The data used to update FbMessengers.
     */
    data: XOR<FbMessengerUpdateManyMutationInput, FbMessengerUncheckedUpdateManyInput>
    /**
     * Filter which FbMessengers to update
     */
    where?: FbMessengerWhereInput
  }


  /**
   * FbMessenger upsert
   */
  export type FbMessengerUpsertArgs = {
    /**
     * Select specific fields to fetch from the FbMessenger
     */
    select?: FbMessengerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbMessengerInclude | null
    /**
     * The filter to search for the FbMessenger to update in case it exists.
     */
    where: FbMessengerWhereUniqueInput
    /**
     * In case the FbMessenger found by the `where` argument doesn't exist, create a new FbMessenger with this data.
     */
    create: XOR<FbMessengerCreateInput, FbMessengerUncheckedCreateInput>
    /**
     * In case the FbMessenger was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FbMessengerUpdateInput, FbMessengerUncheckedUpdateInput>
  }


  /**
   * FbMessenger delete
   */
  export type FbMessengerDeleteArgs = {
    /**
     * Select specific fields to fetch from the FbMessenger
     */
    select?: FbMessengerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbMessengerInclude | null
    /**
     * Filter which FbMessenger to delete.
     */
    where: FbMessengerWhereUniqueInput
  }


  /**
   * FbMessenger deleteMany
   */
  export type FbMessengerDeleteManyArgs = {
    /**
     * Filter which FbMessengers to delete
     */
    where?: FbMessengerWhereInput
  }


  /**
   * FbMessenger without action
   */
  export type FbMessengerArgs = {
    /**
     * Select specific fields to fetch from the FbMessenger
     */
    select?: FbMessengerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbMessengerInclude | null
  }



  /**
   * Model FbComment
   */


  export type AggregateFbComment = {
    _count: FbCommentCountAggregateOutputType | null
    _avg: FbCommentAvgAggregateOutputType | null
    _sum: FbCommentSumAggregateOutputType | null
    _min: FbCommentMinAggregateOutputType | null
    _max: FbCommentMaxAggregateOutputType | null
  }

  export type FbCommentAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type FbCommentSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type FbCommentMinAggregateOutputType = {
    id: number | null
    text: string | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FbCommentMaxAggregateOutputType = {
    id: number | null
    text: string | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FbCommentCountAggregateOutputType = {
    id: number
    text: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FbCommentAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type FbCommentSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type FbCommentMinAggregateInputType = {
    id?: true
    text?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FbCommentMaxAggregateInputType = {
    id?: true
    text?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FbCommentCountAggregateInputType = {
    id?: true
    text?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FbCommentAggregateArgs = {
    /**
     * Filter which FbComment to aggregate.
     */
    where?: FbCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbComments to fetch.
     */
    orderBy?: Enumerable<FbCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FbCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FbComments
    **/
    _count?: true | FbCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FbCommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FbCommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FbCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FbCommentMaxAggregateInputType
  }

  export type GetFbCommentAggregateType<T extends FbCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateFbComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFbComment[P]>
      : GetScalarType<T[P], AggregateFbComment[P]>
  }




  export type FbCommentGroupByArgs = {
    where?: FbCommentWhereInput
    orderBy?: Enumerable<FbCommentOrderByWithAggregationInput>
    by: FbCommentScalarFieldEnum[]
    having?: FbCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FbCommentCountAggregateInputType | true
    _avg?: FbCommentAvgAggregateInputType
    _sum?: FbCommentSumAggregateInputType
    _min?: FbCommentMinAggregateInputType
    _max?: FbCommentMaxAggregateInputType
  }


  export type FbCommentGroupByOutputType = {
    id: number
    text: string
    userId: number
    createdAt: Date
    updatedAt: Date
    _count: FbCommentCountAggregateOutputType | null
    _avg: FbCommentAvgAggregateOutputType | null
    _sum: FbCommentSumAggregateOutputType | null
    _min: FbCommentMinAggregateOutputType | null
    _max: FbCommentMaxAggregateOutputType | null
  }

  type GetFbCommentGroupByPayload<T extends FbCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FbCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FbCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FbCommentGroupByOutputType[P]>
            : GetScalarType<T[P], FbCommentGroupByOutputType[P]>
        }
      >
    >


  export type FbCommentSelect = {
    id?: boolean
    text?: boolean
    user?: boolean | FbUserArgs
    userId?: boolean
    likes?: boolean | FbComment$likesArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | FbCommentCountOutputTypeArgs
  }


  export type FbCommentInclude = {
    user?: boolean | FbUserArgs
    likes?: boolean | FbComment$likesArgs
    _count?: boolean | FbCommentCountOutputTypeArgs
  }

  export type FbCommentGetPayload<S extends boolean | null | undefined | FbCommentArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FbComment :
    S extends undefined ? never :
    S extends { include: any } & (FbCommentArgs | FbCommentFindManyArgs)
    ? FbComment  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? FbUserGetPayload<S['include'][P]> :
        P extends 'likes' ? Array < FbLikeGetPayload<S['include'][P]>>  :
        P extends '_count' ? FbCommentCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FbCommentArgs | FbCommentFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? FbUserGetPayload<S['select'][P]> :
        P extends 'likes' ? Array < FbLikeGetPayload<S['select'][P]>>  :
        P extends '_count' ? FbCommentCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof FbComment ? FbComment[P] : never
  } 
      : FbComment


  type FbCommentCountArgs = 
    Omit<FbCommentFindManyArgs, 'select' | 'include'> & {
      select?: FbCommentCountAggregateInputType | true
    }

  export interface FbCommentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one FbComment that matches the filter.
     * @param {FbCommentFindUniqueArgs} args - Arguments to find a FbComment
     * @example
     * // Get one FbComment
     * const fbComment = await prisma.fbComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FbCommentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FbCommentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FbComment'> extends True ? Prisma__FbCommentClient<FbCommentGetPayload<T>> : Prisma__FbCommentClient<FbCommentGetPayload<T> | null, null>

    /**
     * Find one FbComment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FbCommentFindUniqueOrThrowArgs} args - Arguments to find a FbComment
     * @example
     * // Get one FbComment
     * const fbComment = await prisma.fbComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FbCommentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FbCommentFindUniqueOrThrowArgs>
    ): Prisma__FbCommentClient<FbCommentGetPayload<T>>

    /**
     * Find the first FbComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbCommentFindFirstArgs} args - Arguments to find a FbComment
     * @example
     * // Get one FbComment
     * const fbComment = await prisma.fbComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FbCommentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FbCommentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FbComment'> extends True ? Prisma__FbCommentClient<FbCommentGetPayload<T>> : Prisma__FbCommentClient<FbCommentGetPayload<T> | null, null>

    /**
     * Find the first FbComment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbCommentFindFirstOrThrowArgs} args - Arguments to find a FbComment
     * @example
     * // Get one FbComment
     * const fbComment = await prisma.fbComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FbCommentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FbCommentFindFirstOrThrowArgs>
    ): Prisma__FbCommentClient<FbCommentGetPayload<T>>

    /**
     * Find zero or more FbComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbCommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FbComments
     * const fbComments = await prisma.fbComment.findMany()
     * 
     * // Get first 10 FbComments
     * const fbComments = await prisma.fbComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fbCommentWithIdOnly = await prisma.fbComment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FbCommentFindManyArgs>(
      args?: SelectSubset<T, FbCommentFindManyArgs>
    ): Prisma.PrismaPromise<Array<FbCommentGetPayload<T>>>

    /**
     * Create a FbComment.
     * @param {FbCommentCreateArgs} args - Arguments to create a FbComment.
     * @example
     * // Create one FbComment
     * const FbComment = await prisma.fbComment.create({
     *   data: {
     *     // ... data to create a FbComment
     *   }
     * })
     * 
    **/
    create<T extends FbCommentCreateArgs>(
      args: SelectSubset<T, FbCommentCreateArgs>
    ): Prisma__FbCommentClient<FbCommentGetPayload<T>>

    /**
     * Create many FbComments.
     *     @param {FbCommentCreateManyArgs} args - Arguments to create many FbComments.
     *     @example
     *     // Create many FbComments
     *     const fbComment = await prisma.fbComment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FbCommentCreateManyArgs>(
      args?: SelectSubset<T, FbCommentCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FbComment.
     * @param {FbCommentDeleteArgs} args - Arguments to delete one FbComment.
     * @example
     * // Delete one FbComment
     * const FbComment = await prisma.fbComment.delete({
     *   where: {
     *     // ... filter to delete one FbComment
     *   }
     * })
     * 
    **/
    delete<T extends FbCommentDeleteArgs>(
      args: SelectSubset<T, FbCommentDeleteArgs>
    ): Prisma__FbCommentClient<FbCommentGetPayload<T>>

    /**
     * Update one FbComment.
     * @param {FbCommentUpdateArgs} args - Arguments to update one FbComment.
     * @example
     * // Update one FbComment
     * const fbComment = await prisma.fbComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FbCommentUpdateArgs>(
      args: SelectSubset<T, FbCommentUpdateArgs>
    ): Prisma__FbCommentClient<FbCommentGetPayload<T>>

    /**
     * Delete zero or more FbComments.
     * @param {FbCommentDeleteManyArgs} args - Arguments to filter FbComments to delete.
     * @example
     * // Delete a few FbComments
     * const { count } = await prisma.fbComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FbCommentDeleteManyArgs>(
      args?: SelectSubset<T, FbCommentDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FbComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FbComments
     * const fbComment = await prisma.fbComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FbCommentUpdateManyArgs>(
      args: SelectSubset<T, FbCommentUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FbComment.
     * @param {FbCommentUpsertArgs} args - Arguments to update or create a FbComment.
     * @example
     * // Update or create a FbComment
     * const fbComment = await prisma.fbComment.upsert({
     *   create: {
     *     // ... data to create a FbComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FbComment we want to update
     *   }
     * })
    **/
    upsert<T extends FbCommentUpsertArgs>(
      args: SelectSubset<T, FbCommentUpsertArgs>
    ): Prisma__FbCommentClient<FbCommentGetPayload<T>>

    /**
     * Count the number of FbComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbCommentCountArgs} args - Arguments to filter FbComments to count.
     * @example
     * // Count the number of FbComments
     * const count = await prisma.fbComment.count({
     *   where: {
     *     // ... the filter for the FbComments we want to count
     *   }
     * })
    **/
    count<T extends FbCommentCountArgs>(
      args?: Subset<T, FbCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FbCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FbComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FbCommentAggregateArgs>(args: Subset<T, FbCommentAggregateArgs>): Prisma.PrismaPromise<GetFbCommentAggregateType<T>>

    /**
     * Group by FbComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FbCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FbCommentGroupByArgs['orderBy'] }
        : { orderBy?: FbCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FbCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFbCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FbComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FbCommentClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends FbUserArgs= {}>(args?: Subset<T, FbUserArgs>): Prisma__FbUserClient<FbUserGetPayload<T> | Null>;

    likes<T extends FbComment$likesArgs= {}>(args?: Subset<T, FbComment$likesArgs>): Prisma.PrismaPromise<Array<FbLikeGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FbComment base type for findUnique actions
   */
  export type FbCommentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FbComment
     */
    select?: FbCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbCommentInclude | null
    /**
     * Filter, which FbComment to fetch.
     */
    where: FbCommentWhereUniqueInput
  }

  /**
   * FbComment findUnique
   */
  export interface FbCommentFindUniqueArgs extends FbCommentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FbComment findUniqueOrThrow
   */
  export type FbCommentFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FbComment
     */
    select?: FbCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbCommentInclude | null
    /**
     * Filter, which FbComment to fetch.
     */
    where: FbCommentWhereUniqueInput
  }


  /**
   * FbComment base type for findFirst actions
   */
  export type FbCommentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FbComment
     */
    select?: FbCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbCommentInclude | null
    /**
     * Filter, which FbComment to fetch.
     */
    where?: FbCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbComments to fetch.
     */
    orderBy?: Enumerable<FbCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FbComments.
     */
    cursor?: FbCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FbComments.
     */
    distinct?: Enumerable<FbCommentScalarFieldEnum>
  }

  /**
   * FbComment findFirst
   */
  export interface FbCommentFindFirstArgs extends FbCommentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FbComment findFirstOrThrow
   */
  export type FbCommentFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FbComment
     */
    select?: FbCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbCommentInclude | null
    /**
     * Filter, which FbComment to fetch.
     */
    where?: FbCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbComments to fetch.
     */
    orderBy?: Enumerable<FbCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FbComments.
     */
    cursor?: FbCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FbComments.
     */
    distinct?: Enumerable<FbCommentScalarFieldEnum>
  }


  /**
   * FbComment findMany
   */
  export type FbCommentFindManyArgs = {
    /**
     * Select specific fields to fetch from the FbComment
     */
    select?: FbCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbCommentInclude | null
    /**
     * Filter, which FbComments to fetch.
     */
    where?: FbCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbComments to fetch.
     */
    orderBy?: Enumerable<FbCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FbComments.
     */
    cursor?: FbCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbComments.
     */
    skip?: number
    distinct?: Enumerable<FbCommentScalarFieldEnum>
  }


  /**
   * FbComment create
   */
  export type FbCommentCreateArgs = {
    /**
     * Select specific fields to fetch from the FbComment
     */
    select?: FbCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbCommentInclude | null
    /**
     * The data needed to create a FbComment.
     */
    data: XOR<FbCommentCreateInput, FbCommentUncheckedCreateInput>
  }


  /**
   * FbComment createMany
   */
  export type FbCommentCreateManyArgs = {
    /**
     * The data used to create many FbComments.
     */
    data: Enumerable<FbCommentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FbComment update
   */
  export type FbCommentUpdateArgs = {
    /**
     * Select specific fields to fetch from the FbComment
     */
    select?: FbCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbCommentInclude | null
    /**
     * The data needed to update a FbComment.
     */
    data: XOR<FbCommentUpdateInput, FbCommentUncheckedUpdateInput>
    /**
     * Choose, which FbComment to update.
     */
    where: FbCommentWhereUniqueInput
  }


  /**
   * FbComment updateMany
   */
  export type FbCommentUpdateManyArgs = {
    /**
     * The data used to update FbComments.
     */
    data: XOR<FbCommentUpdateManyMutationInput, FbCommentUncheckedUpdateManyInput>
    /**
     * Filter which FbComments to update
     */
    where?: FbCommentWhereInput
  }


  /**
   * FbComment upsert
   */
  export type FbCommentUpsertArgs = {
    /**
     * Select specific fields to fetch from the FbComment
     */
    select?: FbCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbCommentInclude | null
    /**
     * The filter to search for the FbComment to update in case it exists.
     */
    where: FbCommentWhereUniqueInput
    /**
     * In case the FbComment found by the `where` argument doesn't exist, create a new FbComment with this data.
     */
    create: XOR<FbCommentCreateInput, FbCommentUncheckedCreateInput>
    /**
     * In case the FbComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FbCommentUpdateInput, FbCommentUncheckedUpdateInput>
  }


  /**
   * FbComment delete
   */
  export type FbCommentDeleteArgs = {
    /**
     * Select specific fields to fetch from the FbComment
     */
    select?: FbCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbCommentInclude | null
    /**
     * Filter which FbComment to delete.
     */
    where: FbCommentWhereUniqueInput
  }


  /**
   * FbComment deleteMany
   */
  export type FbCommentDeleteManyArgs = {
    /**
     * Filter which FbComments to delete
     */
    where?: FbCommentWhereInput
  }


  /**
   * FbComment.likes
   */
  export type FbComment$likesArgs = {
    /**
     * Select specific fields to fetch from the FbLike
     */
    select?: FbLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbLikeInclude | null
    where?: FbLikeWhereInput
    orderBy?: Enumerable<FbLikeOrderByWithRelationInput>
    cursor?: FbLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FbLikeScalarFieldEnum>
  }


  /**
   * FbComment without action
   */
  export type FbCommentArgs = {
    /**
     * Select specific fields to fetch from the FbComment
     */
    select?: FbCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbCommentInclude | null
  }



  /**
   * Model FbGroup
   */


  export type AggregateFbGroup = {
    _count: FbGroupCountAggregateOutputType | null
    _avg: FbGroupAvgAggregateOutputType | null
    _sum: FbGroupSumAggregateOutputType | null
    _min: FbGroupMinAggregateOutputType | null
    _max: FbGroupMaxAggregateOutputType | null
  }

  export type FbGroupAvgAggregateOutputType = {
    id: number | null
  }

  export type FbGroupSumAggregateOutputType = {
    id: number | null
  }

  export type FbGroupMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FbGroupMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FbGroupCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FbGroupAvgAggregateInputType = {
    id?: true
  }

  export type FbGroupSumAggregateInputType = {
    id?: true
  }

  export type FbGroupMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FbGroupMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FbGroupCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FbGroupAggregateArgs = {
    /**
     * Filter which FbGroup to aggregate.
     */
    where?: FbGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbGroups to fetch.
     */
    orderBy?: Enumerable<FbGroupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FbGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FbGroups
    **/
    _count?: true | FbGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FbGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FbGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FbGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FbGroupMaxAggregateInputType
  }

  export type GetFbGroupAggregateType<T extends FbGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateFbGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFbGroup[P]>
      : GetScalarType<T[P], AggregateFbGroup[P]>
  }




  export type FbGroupGroupByArgs = {
    where?: FbGroupWhereInput
    orderBy?: Enumerable<FbGroupOrderByWithAggregationInput>
    by: FbGroupScalarFieldEnum[]
    having?: FbGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FbGroupCountAggregateInputType | true
    _avg?: FbGroupAvgAggregateInputType
    _sum?: FbGroupSumAggregateInputType
    _min?: FbGroupMinAggregateInputType
    _max?: FbGroupMaxAggregateInputType
  }


  export type FbGroupGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: FbGroupCountAggregateOutputType | null
    _avg: FbGroupAvgAggregateOutputType | null
    _sum: FbGroupSumAggregateOutputType | null
    _min: FbGroupMinAggregateOutputType | null
    _max: FbGroupMaxAggregateOutputType | null
  }

  type GetFbGroupGroupByPayload<T extends FbGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FbGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FbGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FbGroupGroupByOutputType[P]>
            : GetScalarType<T[P], FbGroupGroupByOutputType[P]>
        }
      >
    >


  export type FbGroupSelect = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    groupToUsers?: boolean | FbGroup$groupToUsersArgs
    destinationUsers?: boolean | FbGroup$destinationUsersArgs
    _count?: boolean | FbGroupCountOutputTypeArgs
  }


  export type FbGroupInclude = {
    groupToUsers?: boolean | FbGroup$groupToUsersArgs
    destinationUsers?: boolean | FbGroup$destinationUsersArgs
    _count?: boolean | FbGroupCountOutputTypeArgs
  }

  export type FbGroupGetPayload<S extends boolean | null | undefined | FbGroupArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FbGroup :
    S extends undefined ? never :
    S extends { include: any } & (FbGroupArgs | FbGroupFindManyArgs)
    ? FbGroup  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'groupToUsers' ? Array < GroupToUserGetPayload<S['include'][P]>>  :
        P extends 'destinationUsers' ? Array < FbDestinationUserGetPayload<S['include'][P]>>  :
        P extends '_count' ? FbGroupCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FbGroupArgs | FbGroupFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'groupToUsers' ? Array < GroupToUserGetPayload<S['select'][P]>>  :
        P extends 'destinationUsers' ? Array < FbDestinationUserGetPayload<S['select'][P]>>  :
        P extends '_count' ? FbGroupCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof FbGroup ? FbGroup[P] : never
  } 
      : FbGroup


  type FbGroupCountArgs = 
    Omit<FbGroupFindManyArgs, 'select' | 'include'> & {
      select?: FbGroupCountAggregateInputType | true
    }

  export interface FbGroupDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one FbGroup that matches the filter.
     * @param {FbGroupFindUniqueArgs} args - Arguments to find a FbGroup
     * @example
     * // Get one FbGroup
     * const fbGroup = await prisma.fbGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FbGroupFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FbGroupFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FbGroup'> extends True ? Prisma__FbGroupClient<FbGroupGetPayload<T>> : Prisma__FbGroupClient<FbGroupGetPayload<T> | null, null>

    /**
     * Find one FbGroup that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FbGroupFindUniqueOrThrowArgs} args - Arguments to find a FbGroup
     * @example
     * // Get one FbGroup
     * const fbGroup = await prisma.fbGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FbGroupFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FbGroupFindUniqueOrThrowArgs>
    ): Prisma__FbGroupClient<FbGroupGetPayload<T>>

    /**
     * Find the first FbGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbGroupFindFirstArgs} args - Arguments to find a FbGroup
     * @example
     * // Get one FbGroup
     * const fbGroup = await prisma.fbGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FbGroupFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FbGroupFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FbGroup'> extends True ? Prisma__FbGroupClient<FbGroupGetPayload<T>> : Prisma__FbGroupClient<FbGroupGetPayload<T> | null, null>

    /**
     * Find the first FbGroup that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbGroupFindFirstOrThrowArgs} args - Arguments to find a FbGroup
     * @example
     * // Get one FbGroup
     * const fbGroup = await prisma.fbGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FbGroupFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FbGroupFindFirstOrThrowArgs>
    ): Prisma__FbGroupClient<FbGroupGetPayload<T>>

    /**
     * Find zero or more FbGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbGroupFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FbGroups
     * const fbGroups = await prisma.fbGroup.findMany()
     * 
     * // Get first 10 FbGroups
     * const fbGroups = await prisma.fbGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fbGroupWithIdOnly = await prisma.fbGroup.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FbGroupFindManyArgs>(
      args?: SelectSubset<T, FbGroupFindManyArgs>
    ): Prisma.PrismaPromise<Array<FbGroupGetPayload<T>>>

    /**
     * Create a FbGroup.
     * @param {FbGroupCreateArgs} args - Arguments to create a FbGroup.
     * @example
     * // Create one FbGroup
     * const FbGroup = await prisma.fbGroup.create({
     *   data: {
     *     // ... data to create a FbGroup
     *   }
     * })
     * 
    **/
    create<T extends FbGroupCreateArgs>(
      args: SelectSubset<T, FbGroupCreateArgs>
    ): Prisma__FbGroupClient<FbGroupGetPayload<T>>

    /**
     * Create many FbGroups.
     *     @param {FbGroupCreateManyArgs} args - Arguments to create many FbGroups.
     *     @example
     *     // Create many FbGroups
     *     const fbGroup = await prisma.fbGroup.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FbGroupCreateManyArgs>(
      args?: SelectSubset<T, FbGroupCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FbGroup.
     * @param {FbGroupDeleteArgs} args - Arguments to delete one FbGroup.
     * @example
     * // Delete one FbGroup
     * const FbGroup = await prisma.fbGroup.delete({
     *   where: {
     *     // ... filter to delete one FbGroup
     *   }
     * })
     * 
    **/
    delete<T extends FbGroupDeleteArgs>(
      args: SelectSubset<T, FbGroupDeleteArgs>
    ): Prisma__FbGroupClient<FbGroupGetPayload<T>>

    /**
     * Update one FbGroup.
     * @param {FbGroupUpdateArgs} args - Arguments to update one FbGroup.
     * @example
     * // Update one FbGroup
     * const fbGroup = await prisma.fbGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FbGroupUpdateArgs>(
      args: SelectSubset<T, FbGroupUpdateArgs>
    ): Prisma__FbGroupClient<FbGroupGetPayload<T>>

    /**
     * Delete zero or more FbGroups.
     * @param {FbGroupDeleteManyArgs} args - Arguments to filter FbGroups to delete.
     * @example
     * // Delete a few FbGroups
     * const { count } = await prisma.fbGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FbGroupDeleteManyArgs>(
      args?: SelectSubset<T, FbGroupDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FbGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FbGroups
     * const fbGroup = await prisma.fbGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FbGroupUpdateManyArgs>(
      args: SelectSubset<T, FbGroupUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FbGroup.
     * @param {FbGroupUpsertArgs} args - Arguments to update or create a FbGroup.
     * @example
     * // Update or create a FbGroup
     * const fbGroup = await prisma.fbGroup.upsert({
     *   create: {
     *     // ... data to create a FbGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FbGroup we want to update
     *   }
     * })
    **/
    upsert<T extends FbGroupUpsertArgs>(
      args: SelectSubset<T, FbGroupUpsertArgs>
    ): Prisma__FbGroupClient<FbGroupGetPayload<T>>

    /**
     * Count the number of FbGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbGroupCountArgs} args - Arguments to filter FbGroups to count.
     * @example
     * // Count the number of FbGroups
     * const count = await prisma.fbGroup.count({
     *   where: {
     *     // ... the filter for the FbGroups we want to count
     *   }
     * })
    **/
    count<T extends FbGroupCountArgs>(
      args?: Subset<T, FbGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FbGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FbGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FbGroupAggregateArgs>(args: Subset<T, FbGroupAggregateArgs>): Prisma.PrismaPromise<GetFbGroupAggregateType<T>>

    /**
     * Group by FbGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FbGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FbGroupGroupByArgs['orderBy'] }
        : { orderBy?: FbGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FbGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFbGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FbGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FbGroupClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    groupToUsers<T extends FbGroup$groupToUsersArgs= {}>(args?: Subset<T, FbGroup$groupToUsersArgs>): Prisma.PrismaPromise<Array<GroupToUserGetPayload<T>>| Null>;

    destinationUsers<T extends FbGroup$destinationUsersArgs= {}>(args?: Subset<T, FbGroup$destinationUsersArgs>): Prisma.PrismaPromise<Array<FbDestinationUserGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FbGroup base type for findUnique actions
   */
  export type FbGroupFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FbGroup
     */
    select?: FbGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbGroupInclude | null
    /**
     * Filter, which FbGroup to fetch.
     */
    where: FbGroupWhereUniqueInput
  }

  /**
   * FbGroup findUnique
   */
  export interface FbGroupFindUniqueArgs extends FbGroupFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FbGroup findUniqueOrThrow
   */
  export type FbGroupFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FbGroup
     */
    select?: FbGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbGroupInclude | null
    /**
     * Filter, which FbGroup to fetch.
     */
    where: FbGroupWhereUniqueInput
  }


  /**
   * FbGroup base type for findFirst actions
   */
  export type FbGroupFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FbGroup
     */
    select?: FbGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbGroupInclude | null
    /**
     * Filter, which FbGroup to fetch.
     */
    where?: FbGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbGroups to fetch.
     */
    orderBy?: Enumerable<FbGroupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FbGroups.
     */
    cursor?: FbGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FbGroups.
     */
    distinct?: Enumerable<FbGroupScalarFieldEnum>
  }

  /**
   * FbGroup findFirst
   */
  export interface FbGroupFindFirstArgs extends FbGroupFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FbGroup findFirstOrThrow
   */
  export type FbGroupFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FbGroup
     */
    select?: FbGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbGroupInclude | null
    /**
     * Filter, which FbGroup to fetch.
     */
    where?: FbGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbGroups to fetch.
     */
    orderBy?: Enumerable<FbGroupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FbGroups.
     */
    cursor?: FbGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FbGroups.
     */
    distinct?: Enumerable<FbGroupScalarFieldEnum>
  }


  /**
   * FbGroup findMany
   */
  export type FbGroupFindManyArgs = {
    /**
     * Select specific fields to fetch from the FbGroup
     */
    select?: FbGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbGroupInclude | null
    /**
     * Filter, which FbGroups to fetch.
     */
    where?: FbGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbGroups to fetch.
     */
    orderBy?: Enumerable<FbGroupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FbGroups.
     */
    cursor?: FbGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbGroups.
     */
    skip?: number
    distinct?: Enumerable<FbGroupScalarFieldEnum>
  }


  /**
   * FbGroup create
   */
  export type FbGroupCreateArgs = {
    /**
     * Select specific fields to fetch from the FbGroup
     */
    select?: FbGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbGroupInclude | null
    /**
     * The data needed to create a FbGroup.
     */
    data: XOR<FbGroupCreateInput, FbGroupUncheckedCreateInput>
  }


  /**
   * FbGroup createMany
   */
  export type FbGroupCreateManyArgs = {
    /**
     * The data used to create many FbGroups.
     */
    data: Enumerable<FbGroupCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FbGroup update
   */
  export type FbGroupUpdateArgs = {
    /**
     * Select specific fields to fetch from the FbGroup
     */
    select?: FbGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbGroupInclude | null
    /**
     * The data needed to update a FbGroup.
     */
    data: XOR<FbGroupUpdateInput, FbGroupUncheckedUpdateInput>
    /**
     * Choose, which FbGroup to update.
     */
    where: FbGroupWhereUniqueInput
  }


  /**
   * FbGroup updateMany
   */
  export type FbGroupUpdateManyArgs = {
    /**
     * The data used to update FbGroups.
     */
    data: XOR<FbGroupUpdateManyMutationInput, FbGroupUncheckedUpdateManyInput>
    /**
     * Filter which FbGroups to update
     */
    where?: FbGroupWhereInput
  }


  /**
   * FbGroup upsert
   */
  export type FbGroupUpsertArgs = {
    /**
     * Select specific fields to fetch from the FbGroup
     */
    select?: FbGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbGroupInclude | null
    /**
     * The filter to search for the FbGroup to update in case it exists.
     */
    where: FbGroupWhereUniqueInput
    /**
     * In case the FbGroup found by the `where` argument doesn't exist, create a new FbGroup with this data.
     */
    create: XOR<FbGroupCreateInput, FbGroupUncheckedCreateInput>
    /**
     * In case the FbGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FbGroupUpdateInput, FbGroupUncheckedUpdateInput>
  }


  /**
   * FbGroup delete
   */
  export type FbGroupDeleteArgs = {
    /**
     * Select specific fields to fetch from the FbGroup
     */
    select?: FbGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbGroupInclude | null
    /**
     * Filter which FbGroup to delete.
     */
    where: FbGroupWhereUniqueInput
  }


  /**
   * FbGroup deleteMany
   */
  export type FbGroupDeleteManyArgs = {
    /**
     * Filter which FbGroups to delete
     */
    where?: FbGroupWhereInput
  }


  /**
   * FbGroup.groupToUsers
   */
  export type FbGroup$groupToUsersArgs = {
    /**
     * Select specific fields to fetch from the GroupToUser
     */
    select?: GroupToUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupToUserInclude | null
    where?: GroupToUserWhereInput
    orderBy?: Enumerable<GroupToUserOrderByWithRelationInput>
    cursor?: GroupToUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<GroupToUserScalarFieldEnum>
  }


  /**
   * FbGroup.destinationUsers
   */
  export type FbGroup$destinationUsersArgs = {
    /**
     * Select specific fields to fetch from the FbDestinationUser
     */
    select?: FbDestinationUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbDestinationUserInclude | null
    where?: FbDestinationUserWhereInput
    orderBy?: Enumerable<FbDestinationUserOrderByWithRelationInput>
    cursor?: FbDestinationUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FbDestinationUserScalarFieldEnum>
  }


  /**
   * FbGroup without action
   */
  export type FbGroupArgs = {
    /**
     * Select specific fields to fetch from the FbGroup
     */
    select?: FbGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbGroupInclude | null
  }



  /**
   * Model GroupToUser
   */


  export type AggregateGroupToUser = {
    _count: GroupToUserCountAggregateOutputType | null
    _avg: GroupToUserAvgAggregateOutputType | null
    _sum: GroupToUserSumAggregateOutputType | null
    _min: GroupToUserMinAggregateOutputType | null
    _max: GroupToUserMaxAggregateOutputType | null
  }

  export type GroupToUserAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    groupId: number | null
  }

  export type GroupToUserSumAggregateOutputType = {
    id: number | null
    userId: number | null
    groupId: number | null
  }

  export type GroupToUserMinAggregateOutputType = {
    id: number | null
    userId: number | null
    groupId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupToUserMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    groupId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupToUserCountAggregateOutputType = {
    id: number
    userId: number
    groupId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GroupToUserAvgAggregateInputType = {
    id?: true
    userId?: true
    groupId?: true
  }

  export type GroupToUserSumAggregateInputType = {
    id?: true
    userId?: true
    groupId?: true
  }

  export type GroupToUserMinAggregateInputType = {
    id?: true
    userId?: true
    groupId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupToUserMaxAggregateInputType = {
    id?: true
    userId?: true
    groupId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupToUserCountAggregateInputType = {
    id?: true
    userId?: true
    groupId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GroupToUserAggregateArgs = {
    /**
     * Filter which GroupToUser to aggregate.
     */
    where?: GroupToUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupToUsers to fetch.
     */
    orderBy?: Enumerable<GroupToUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupToUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupToUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupToUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GroupToUsers
    **/
    _count?: true | GroupToUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupToUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupToUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupToUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupToUserMaxAggregateInputType
  }

  export type GetGroupToUserAggregateType<T extends GroupToUserAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupToUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupToUser[P]>
      : GetScalarType<T[P], AggregateGroupToUser[P]>
  }




  export type GroupToUserGroupByArgs = {
    where?: GroupToUserWhereInput
    orderBy?: Enumerable<GroupToUserOrderByWithAggregationInput>
    by: GroupToUserScalarFieldEnum[]
    having?: GroupToUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupToUserCountAggregateInputType | true
    _avg?: GroupToUserAvgAggregateInputType
    _sum?: GroupToUserSumAggregateInputType
    _min?: GroupToUserMinAggregateInputType
    _max?: GroupToUserMaxAggregateInputType
  }


  export type GroupToUserGroupByOutputType = {
    id: number
    userId: number
    groupId: number
    createdAt: Date
    updatedAt: Date
    _count: GroupToUserCountAggregateOutputType | null
    _avg: GroupToUserAvgAggregateOutputType | null
    _sum: GroupToUserSumAggregateOutputType | null
    _min: GroupToUserMinAggregateOutputType | null
    _max: GroupToUserMaxAggregateOutputType | null
  }

  type GetGroupToUserGroupByPayload<T extends GroupToUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<GroupToUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupToUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupToUserGroupByOutputType[P]>
            : GetScalarType<T[P], GroupToUserGroupByOutputType[P]>
        }
      >
    >


  export type GroupToUserSelect = {
    id?: boolean
    user?: boolean | FbUserArgs
    userId?: boolean
    group?: boolean | FbGroupArgs
    groupId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type GroupToUserInclude = {
    user?: boolean | FbUserArgs
    group?: boolean | FbGroupArgs
  }

  export type GroupToUserGetPayload<S extends boolean | null | undefined | GroupToUserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? GroupToUser :
    S extends undefined ? never :
    S extends { include: any } & (GroupToUserArgs | GroupToUserFindManyArgs)
    ? GroupToUser  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? FbUserGetPayload<S['include'][P]> :
        P extends 'group' ? FbGroupGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (GroupToUserArgs | GroupToUserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? FbUserGetPayload<S['select'][P]> :
        P extends 'group' ? FbGroupGetPayload<S['select'][P]> :  P extends keyof GroupToUser ? GroupToUser[P] : never
  } 
      : GroupToUser


  type GroupToUserCountArgs = 
    Omit<GroupToUserFindManyArgs, 'select' | 'include'> & {
      select?: GroupToUserCountAggregateInputType | true
    }

  export interface GroupToUserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one GroupToUser that matches the filter.
     * @param {GroupToUserFindUniqueArgs} args - Arguments to find a GroupToUser
     * @example
     * // Get one GroupToUser
     * const groupToUser = await prisma.groupToUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GroupToUserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, GroupToUserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'GroupToUser'> extends True ? Prisma__GroupToUserClient<GroupToUserGetPayload<T>> : Prisma__GroupToUserClient<GroupToUserGetPayload<T> | null, null>

    /**
     * Find one GroupToUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {GroupToUserFindUniqueOrThrowArgs} args - Arguments to find a GroupToUser
     * @example
     * // Get one GroupToUser
     * const groupToUser = await prisma.groupToUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GroupToUserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, GroupToUserFindUniqueOrThrowArgs>
    ): Prisma__GroupToUserClient<GroupToUserGetPayload<T>>

    /**
     * Find the first GroupToUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupToUserFindFirstArgs} args - Arguments to find a GroupToUser
     * @example
     * // Get one GroupToUser
     * const groupToUser = await prisma.groupToUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GroupToUserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, GroupToUserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'GroupToUser'> extends True ? Prisma__GroupToUserClient<GroupToUserGetPayload<T>> : Prisma__GroupToUserClient<GroupToUserGetPayload<T> | null, null>

    /**
     * Find the first GroupToUser that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupToUserFindFirstOrThrowArgs} args - Arguments to find a GroupToUser
     * @example
     * // Get one GroupToUser
     * const groupToUser = await prisma.groupToUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GroupToUserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, GroupToUserFindFirstOrThrowArgs>
    ): Prisma__GroupToUserClient<GroupToUserGetPayload<T>>

    /**
     * Find zero or more GroupToUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupToUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GroupToUsers
     * const groupToUsers = await prisma.groupToUser.findMany()
     * 
     * // Get first 10 GroupToUsers
     * const groupToUsers = await prisma.groupToUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupToUserWithIdOnly = await prisma.groupToUser.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GroupToUserFindManyArgs>(
      args?: SelectSubset<T, GroupToUserFindManyArgs>
    ): Prisma.PrismaPromise<Array<GroupToUserGetPayload<T>>>

    /**
     * Create a GroupToUser.
     * @param {GroupToUserCreateArgs} args - Arguments to create a GroupToUser.
     * @example
     * // Create one GroupToUser
     * const GroupToUser = await prisma.groupToUser.create({
     *   data: {
     *     // ... data to create a GroupToUser
     *   }
     * })
     * 
    **/
    create<T extends GroupToUserCreateArgs>(
      args: SelectSubset<T, GroupToUserCreateArgs>
    ): Prisma__GroupToUserClient<GroupToUserGetPayload<T>>

    /**
     * Create many GroupToUsers.
     *     @param {GroupToUserCreateManyArgs} args - Arguments to create many GroupToUsers.
     *     @example
     *     // Create many GroupToUsers
     *     const groupToUser = await prisma.groupToUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GroupToUserCreateManyArgs>(
      args?: SelectSubset<T, GroupToUserCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GroupToUser.
     * @param {GroupToUserDeleteArgs} args - Arguments to delete one GroupToUser.
     * @example
     * // Delete one GroupToUser
     * const GroupToUser = await prisma.groupToUser.delete({
     *   where: {
     *     // ... filter to delete one GroupToUser
     *   }
     * })
     * 
    **/
    delete<T extends GroupToUserDeleteArgs>(
      args: SelectSubset<T, GroupToUserDeleteArgs>
    ): Prisma__GroupToUserClient<GroupToUserGetPayload<T>>

    /**
     * Update one GroupToUser.
     * @param {GroupToUserUpdateArgs} args - Arguments to update one GroupToUser.
     * @example
     * // Update one GroupToUser
     * const groupToUser = await prisma.groupToUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GroupToUserUpdateArgs>(
      args: SelectSubset<T, GroupToUserUpdateArgs>
    ): Prisma__GroupToUserClient<GroupToUserGetPayload<T>>

    /**
     * Delete zero or more GroupToUsers.
     * @param {GroupToUserDeleteManyArgs} args - Arguments to filter GroupToUsers to delete.
     * @example
     * // Delete a few GroupToUsers
     * const { count } = await prisma.groupToUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GroupToUserDeleteManyArgs>(
      args?: SelectSubset<T, GroupToUserDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupToUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupToUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GroupToUsers
     * const groupToUser = await prisma.groupToUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GroupToUserUpdateManyArgs>(
      args: SelectSubset<T, GroupToUserUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GroupToUser.
     * @param {GroupToUserUpsertArgs} args - Arguments to update or create a GroupToUser.
     * @example
     * // Update or create a GroupToUser
     * const groupToUser = await prisma.groupToUser.upsert({
     *   create: {
     *     // ... data to create a GroupToUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GroupToUser we want to update
     *   }
     * })
    **/
    upsert<T extends GroupToUserUpsertArgs>(
      args: SelectSubset<T, GroupToUserUpsertArgs>
    ): Prisma__GroupToUserClient<GroupToUserGetPayload<T>>

    /**
     * Count the number of GroupToUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupToUserCountArgs} args - Arguments to filter GroupToUsers to count.
     * @example
     * // Count the number of GroupToUsers
     * const count = await prisma.groupToUser.count({
     *   where: {
     *     // ... the filter for the GroupToUsers we want to count
     *   }
     * })
    **/
    count<T extends GroupToUserCountArgs>(
      args?: Subset<T, GroupToUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupToUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GroupToUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupToUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupToUserAggregateArgs>(args: Subset<T, GroupToUserAggregateArgs>): Prisma.PrismaPromise<GetGroupToUserAggregateType<T>>

    /**
     * Group by GroupToUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupToUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupToUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupToUserGroupByArgs['orderBy'] }
        : { orderBy?: GroupToUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupToUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupToUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for GroupToUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__GroupToUserClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends FbUserArgs= {}>(args?: Subset<T, FbUserArgs>): Prisma__FbUserClient<FbUserGetPayload<T> | Null>;

    group<T extends FbGroupArgs= {}>(args?: Subset<T, FbGroupArgs>): Prisma__FbGroupClient<FbGroupGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * GroupToUser base type for findUnique actions
   */
  export type GroupToUserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the GroupToUser
     */
    select?: GroupToUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupToUserInclude | null
    /**
     * Filter, which GroupToUser to fetch.
     */
    where: GroupToUserWhereUniqueInput
  }

  /**
   * GroupToUser findUnique
   */
  export interface GroupToUserFindUniqueArgs extends GroupToUserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * GroupToUser findUniqueOrThrow
   */
  export type GroupToUserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the GroupToUser
     */
    select?: GroupToUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupToUserInclude | null
    /**
     * Filter, which GroupToUser to fetch.
     */
    where: GroupToUserWhereUniqueInput
  }


  /**
   * GroupToUser base type for findFirst actions
   */
  export type GroupToUserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the GroupToUser
     */
    select?: GroupToUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupToUserInclude | null
    /**
     * Filter, which GroupToUser to fetch.
     */
    where?: GroupToUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupToUsers to fetch.
     */
    orderBy?: Enumerable<GroupToUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupToUsers.
     */
    cursor?: GroupToUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupToUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupToUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupToUsers.
     */
    distinct?: Enumerable<GroupToUserScalarFieldEnum>
  }

  /**
   * GroupToUser findFirst
   */
  export interface GroupToUserFindFirstArgs extends GroupToUserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * GroupToUser findFirstOrThrow
   */
  export type GroupToUserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the GroupToUser
     */
    select?: GroupToUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupToUserInclude | null
    /**
     * Filter, which GroupToUser to fetch.
     */
    where?: GroupToUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupToUsers to fetch.
     */
    orderBy?: Enumerable<GroupToUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupToUsers.
     */
    cursor?: GroupToUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupToUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupToUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupToUsers.
     */
    distinct?: Enumerable<GroupToUserScalarFieldEnum>
  }


  /**
   * GroupToUser findMany
   */
  export type GroupToUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the GroupToUser
     */
    select?: GroupToUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupToUserInclude | null
    /**
     * Filter, which GroupToUsers to fetch.
     */
    where?: GroupToUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupToUsers to fetch.
     */
    orderBy?: Enumerable<GroupToUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GroupToUsers.
     */
    cursor?: GroupToUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupToUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupToUsers.
     */
    skip?: number
    distinct?: Enumerable<GroupToUserScalarFieldEnum>
  }


  /**
   * GroupToUser create
   */
  export type GroupToUserCreateArgs = {
    /**
     * Select specific fields to fetch from the GroupToUser
     */
    select?: GroupToUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupToUserInclude | null
    /**
     * The data needed to create a GroupToUser.
     */
    data: XOR<GroupToUserCreateInput, GroupToUserUncheckedCreateInput>
  }


  /**
   * GroupToUser createMany
   */
  export type GroupToUserCreateManyArgs = {
    /**
     * The data used to create many GroupToUsers.
     */
    data: Enumerable<GroupToUserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * GroupToUser update
   */
  export type GroupToUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the GroupToUser
     */
    select?: GroupToUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupToUserInclude | null
    /**
     * The data needed to update a GroupToUser.
     */
    data: XOR<GroupToUserUpdateInput, GroupToUserUncheckedUpdateInput>
    /**
     * Choose, which GroupToUser to update.
     */
    where: GroupToUserWhereUniqueInput
  }


  /**
   * GroupToUser updateMany
   */
  export type GroupToUserUpdateManyArgs = {
    /**
     * The data used to update GroupToUsers.
     */
    data: XOR<GroupToUserUpdateManyMutationInput, GroupToUserUncheckedUpdateManyInput>
    /**
     * Filter which GroupToUsers to update
     */
    where?: GroupToUserWhereInput
  }


  /**
   * GroupToUser upsert
   */
  export type GroupToUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the GroupToUser
     */
    select?: GroupToUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupToUserInclude | null
    /**
     * The filter to search for the GroupToUser to update in case it exists.
     */
    where: GroupToUserWhereUniqueInput
    /**
     * In case the GroupToUser found by the `where` argument doesn't exist, create a new GroupToUser with this data.
     */
    create: XOR<GroupToUserCreateInput, GroupToUserUncheckedCreateInput>
    /**
     * In case the GroupToUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupToUserUpdateInput, GroupToUserUncheckedUpdateInput>
  }


  /**
   * GroupToUser delete
   */
  export type GroupToUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the GroupToUser
     */
    select?: GroupToUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupToUserInclude | null
    /**
     * Filter which GroupToUser to delete.
     */
    where: GroupToUserWhereUniqueInput
  }


  /**
   * GroupToUser deleteMany
   */
  export type GroupToUserDeleteManyArgs = {
    /**
     * Filter which GroupToUsers to delete
     */
    where?: GroupToUserWhereInput
  }


  /**
   * GroupToUser without action
   */
  export type GroupToUserArgs = {
    /**
     * Select specific fields to fetch from the GroupToUser
     */
    select?: GroupToUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupToUserInclude | null
  }



  /**
   * Model FbWall
   */


  export type AggregateFbWall = {
    _count: FbWallCountAggregateOutputType | null
    _avg: FbWallAvgAggregateOutputType | null
    _sum: FbWallSumAggregateOutputType | null
    _min: FbWallMinAggregateOutputType | null
    _max: FbWallMaxAggregateOutputType | null
  }

  export type FbWallAvgAggregateOutputType = {
    id: number | null
  }

  export type FbWallSumAggregateOutputType = {
    id: number | null
  }

  export type FbWallMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FbWallMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FbWallCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FbWallAvgAggregateInputType = {
    id?: true
  }

  export type FbWallSumAggregateInputType = {
    id?: true
  }

  export type FbWallMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FbWallMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FbWallCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FbWallAggregateArgs = {
    /**
     * Filter which FbWall to aggregate.
     */
    where?: FbWallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbWalls to fetch.
     */
    orderBy?: Enumerable<FbWallOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FbWallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbWalls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbWalls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FbWalls
    **/
    _count?: true | FbWallCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FbWallAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FbWallSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FbWallMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FbWallMaxAggregateInputType
  }

  export type GetFbWallAggregateType<T extends FbWallAggregateArgs> = {
        [P in keyof T & keyof AggregateFbWall]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFbWall[P]>
      : GetScalarType<T[P], AggregateFbWall[P]>
  }




  export type FbWallGroupByArgs = {
    where?: FbWallWhereInput
    orderBy?: Enumerable<FbWallOrderByWithAggregationInput>
    by: FbWallScalarFieldEnum[]
    having?: FbWallScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FbWallCountAggregateInputType | true
    _avg?: FbWallAvgAggregateInputType
    _sum?: FbWallSumAggregateInputType
    _min?: FbWallMinAggregateInputType
    _max?: FbWallMaxAggregateInputType
  }


  export type FbWallGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    _count: FbWallCountAggregateOutputType | null
    _avg: FbWallAvgAggregateOutputType | null
    _sum: FbWallSumAggregateOutputType | null
    _min: FbWallMinAggregateOutputType | null
    _max: FbWallMaxAggregateOutputType | null
  }

  type GetFbWallGroupByPayload<T extends FbWallGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FbWallGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FbWallGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FbWallGroupByOutputType[P]>
            : GetScalarType<T[P], FbWallGroupByOutputType[P]>
        }
      >
    >


  export type FbWallSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    posts?: boolean | FbWall$postsArgs
    destinationUsers?: boolean | FbWall$destinationUsersArgs
    _count?: boolean | FbWallCountOutputTypeArgs
  }


  export type FbWallInclude = {
    posts?: boolean | FbWall$postsArgs
    destinationUsers?: boolean | FbWall$destinationUsersArgs
    _count?: boolean | FbWallCountOutputTypeArgs
  }

  export type FbWallGetPayload<S extends boolean | null | undefined | FbWallArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FbWall :
    S extends undefined ? never :
    S extends { include: any } & (FbWallArgs | FbWallFindManyArgs)
    ? FbWall  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'posts' ? Array < FbPostGetPayload<S['include'][P]>>  :
        P extends 'destinationUsers' ? Array < FbDestinationUserGetPayload<S['include'][P]>>  :
        P extends '_count' ? FbWallCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FbWallArgs | FbWallFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'posts' ? Array < FbPostGetPayload<S['select'][P]>>  :
        P extends 'destinationUsers' ? Array < FbDestinationUserGetPayload<S['select'][P]>>  :
        P extends '_count' ? FbWallCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof FbWall ? FbWall[P] : never
  } 
      : FbWall


  type FbWallCountArgs = 
    Omit<FbWallFindManyArgs, 'select' | 'include'> & {
      select?: FbWallCountAggregateInputType | true
    }

  export interface FbWallDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one FbWall that matches the filter.
     * @param {FbWallFindUniqueArgs} args - Arguments to find a FbWall
     * @example
     * // Get one FbWall
     * const fbWall = await prisma.fbWall.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FbWallFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FbWallFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FbWall'> extends True ? Prisma__FbWallClient<FbWallGetPayload<T>> : Prisma__FbWallClient<FbWallGetPayload<T> | null, null>

    /**
     * Find one FbWall that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FbWallFindUniqueOrThrowArgs} args - Arguments to find a FbWall
     * @example
     * // Get one FbWall
     * const fbWall = await prisma.fbWall.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FbWallFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FbWallFindUniqueOrThrowArgs>
    ): Prisma__FbWallClient<FbWallGetPayload<T>>

    /**
     * Find the first FbWall that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbWallFindFirstArgs} args - Arguments to find a FbWall
     * @example
     * // Get one FbWall
     * const fbWall = await prisma.fbWall.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FbWallFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FbWallFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FbWall'> extends True ? Prisma__FbWallClient<FbWallGetPayload<T>> : Prisma__FbWallClient<FbWallGetPayload<T> | null, null>

    /**
     * Find the first FbWall that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbWallFindFirstOrThrowArgs} args - Arguments to find a FbWall
     * @example
     * // Get one FbWall
     * const fbWall = await prisma.fbWall.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FbWallFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FbWallFindFirstOrThrowArgs>
    ): Prisma__FbWallClient<FbWallGetPayload<T>>

    /**
     * Find zero or more FbWalls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbWallFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FbWalls
     * const fbWalls = await prisma.fbWall.findMany()
     * 
     * // Get first 10 FbWalls
     * const fbWalls = await prisma.fbWall.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fbWallWithIdOnly = await prisma.fbWall.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FbWallFindManyArgs>(
      args?: SelectSubset<T, FbWallFindManyArgs>
    ): Prisma.PrismaPromise<Array<FbWallGetPayload<T>>>

    /**
     * Create a FbWall.
     * @param {FbWallCreateArgs} args - Arguments to create a FbWall.
     * @example
     * // Create one FbWall
     * const FbWall = await prisma.fbWall.create({
     *   data: {
     *     // ... data to create a FbWall
     *   }
     * })
     * 
    **/
    create<T extends FbWallCreateArgs>(
      args: SelectSubset<T, FbWallCreateArgs>
    ): Prisma__FbWallClient<FbWallGetPayload<T>>

    /**
     * Create many FbWalls.
     *     @param {FbWallCreateManyArgs} args - Arguments to create many FbWalls.
     *     @example
     *     // Create many FbWalls
     *     const fbWall = await prisma.fbWall.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FbWallCreateManyArgs>(
      args?: SelectSubset<T, FbWallCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FbWall.
     * @param {FbWallDeleteArgs} args - Arguments to delete one FbWall.
     * @example
     * // Delete one FbWall
     * const FbWall = await prisma.fbWall.delete({
     *   where: {
     *     // ... filter to delete one FbWall
     *   }
     * })
     * 
    **/
    delete<T extends FbWallDeleteArgs>(
      args: SelectSubset<T, FbWallDeleteArgs>
    ): Prisma__FbWallClient<FbWallGetPayload<T>>

    /**
     * Update one FbWall.
     * @param {FbWallUpdateArgs} args - Arguments to update one FbWall.
     * @example
     * // Update one FbWall
     * const fbWall = await prisma.fbWall.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FbWallUpdateArgs>(
      args: SelectSubset<T, FbWallUpdateArgs>
    ): Prisma__FbWallClient<FbWallGetPayload<T>>

    /**
     * Delete zero or more FbWalls.
     * @param {FbWallDeleteManyArgs} args - Arguments to filter FbWalls to delete.
     * @example
     * // Delete a few FbWalls
     * const { count } = await prisma.fbWall.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FbWallDeleteManyArgs>(
      args?: SelectSubset<T, FbWallDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FbWalls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbWallUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FbWalls
     * const fbWall = await prisma.fbWall.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FbWallUpdateManyArgs>(
      args: SelectSubset<T, FbWallUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FbWall.
     * @param {FbWallUpsertArgs} args - Arguments to update or create a FbWall.
     * @example
     * // Update or create a FbWall
     * const fbWall = await prisma.fbWall.upsert({
     *   create: {
     *     // ... data to create a FbWall
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FbWall we want to update
     *   }
     * })
    **/
    upsert<T extends FbWallUpsertArgs>(
      args: SelectSubset<T, FbWallUpsertArgs>
    ): Prisma__FbWallClient<FbWallGetPayload<T>>

    /**
     * Count the number of FbWalls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbWallCountArgs} args - Arguments to filter FbWalls to count.
     * @example
     * // Count the number of FbWalls
     * const count = await prisma.fbWall.count({
     *   where: {
     *     // ... the filter for the FbWalls we want to count
     *   }
     * })
    **/
    count<T extends FbWallCountArgs>(
      args?: Subset<T, FbWallCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FbWallCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FbWall.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbWallAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FbWallAggregateArgs>(args: Subset<T, FbWallAggregateArgs>): Prisma.PrismaPromise<GetFbWallAggregateType<T>>

    /**
     * Group by FbWall.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbWallGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FbWallGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FbWallGroupByArgs['orderBy'] }
        : { orderBy?: FbWallGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FbWallGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFbWallGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FbWall.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FbWallClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    posts<T extends FbWall$postsArgs= {}>(args?: Subset<T, FbWall$postsArgs>): Prisma.PrismaPromise<Array<FbPostGetPayload<T>>| Null>;

    destinationUsers<T extends FbWall$destinationUsersArgs= {}>(args?: Subset<T, FbWall$destinationUsersArgs>): Prisma.PrismaPromise<Array<FbDestinationUserGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FbWall base type for findUnique actions
   */
  export type FbWallFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FbWall
     */
    select?: FbWallSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbWallInclude | null
    /**
     * Filter, which FbWall to fetch.
     */
    where: FbWallWhereUniqueInput
  }

  /**
   * FbWall findUnique
   */
  export interface FbWallFindUniqueArgs extends FbWallFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FbWall findUniqueOrThrow
   */
  export type FbWallFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FbWall
     */
    select?: FbWallSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbWallInclude | null
    /**
     * Filter, which FbWall to fetch.
     */
    where: FbWallWhereUniqueInput
  }


  /**
   * FbWall base type for findFirst actions
   */
  export type FbWallFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FbWall
     */
    select?: FbWallSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbWallInclude | null
    /**
     * Filter, which FbWall to fetch.
     */
    where?: FbWallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbWalls to fetch.
     */
    orderBy?: Enumerable<FbWallOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FbWalls.
     */
    cursor?: FbWallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbWalls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbWalls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FbWalls.
     */
    distinct?: Enumerable<FbWallScalarFieldEnum>
  }

  /**
   * FbWall findFirst
   */
  export interface FbWallFindFirstArgs extends FbWallFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FbWall findFirstOrThrow
   */
  export type FbWallFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FbWall
     */
    select?: FbWallSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbWallInclude | null
    /**
     * Filter, which FbWall to fetch.
     */
    where?: FbWallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbWalls to fetch.
     */
    orderBy?: Enumerable<FbWallOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FbWalls.
     */
    cursor?: FbWallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbWalls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbWalls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FbWalls.
     */
    distinct?: Enumerable<FbWallScalarFieldEnum>
  }


  /**
   * FbWall findMany
   */
  export type FbWallFindManyArgs = {
    /**
     * Select specific fields to fetch from the FbWall
     */
    select?: FbWallSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbWallInclude | null
    /**
     * Filter, which FbWalls to fetch.
     */
    where?: FbWallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbWalls to fetch.
     */
    orderBy?: Enumerable<FbWallOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FbWalls.
     */
    cursor?: FbWallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbWalls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbWalls.
     */
    skip?: number
    distinct?: Enumerable<FbWallScalarFieldEnum>
  }


  /**
   * FbWall create
   */
  export type FbWallCreateArgs = {
    /**
     * Select specific fields to fetch from the FbWall
     */
    select?: FbWallSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbWallInclude | null
    /**
     * The data needed to create a FbWall.
     */
    data: XOR<FbWallCreateInput, FbWallUncheckedCreateInput>
  }


  /**
   * FbWall createMany
   */
  export type FbWallCreateManyArgs = {
    /**
     * The data used to create many FbWalls.
     */
    data: Enumerable<FbWallCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FbWall update
   */
  export type FbWallUpdateArgs = {
    /**
     * Select specific fields to fetch from the FbWall
     */
    select?: FbWallSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbWallInclude | null
    /**
     * The data needed to update a FbWall.
     */
    data: XOR<FbWallUpdateInput, FbWallUncheckedUpdateInput>
    /**
     * Choose, which FbWall to update.
     */
    where: FbWallWhereUniqueInput
  }


  /**
   * FbWall updateMany
   */
  export type FbWallUpdateManyArgs = {
    /**
     * The data used to update FbWalls.
     */
    data: XOR<FbWallUpdateManyMutationInput, FbWallUncheckedUpdateManyInput>
    /**
     * Filter which FbWalls to update
     */
    where?: FbWallWhereInput
  }


  /**
   * FbWall upsert
   */
  export type FbWallUpsertArgs = {
    /**
     * Select specific fields to fetch from the FbWall
     */
    select?: FbWallSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbWallInclude | null
    /**
     * The filter to search for the FbWall to update in case it exists.
     */
    where: FbWallWhereUniqueInput
    /**
     * In case the FbWall found by the `where` argument doesn't exist, create a new FbWall with this data.
     */
    create: XOR<FbWallCreateInput, FbWallUncheckedCreateInput>
    /**
     * In case the FbWall was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FbWallUpdateInput, FbWallUncheckedUpdateInput>
  }


  /**
   * FbWall delete
   */
  export type FbWallDeleteArgs = {
    /**
     * Select specific fields to fetch from the FbWall
     */
    select?: FbWallSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbWallInclude | null
    /**
     * Filter which FbWall to delete.
     */
    where: FbWallWhereUniqueInput
  }


  /**
   * FbWall deleteMany
   */
  export type FbWallDeleteManyArgs = {
    /**
     * Filter which FbWalls to delete
     */
    where?: FbWallWhereInput
  }


  /**
   * FbWall.posts
   */
  export type FbWall$postsArgs = {
    /**
     * Select specific fields to fetch from the FbPost
     */
    select?: FbPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbPostInclude | null
    where?: FbPostWhereInput
    orderBy?: Enumerable<FbPostOrderByWithRelationInput>
    cursor?: FbPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FbPostScalarFieldEnum>
  }


  /**
   * FbWall.destinationUsers
   */
  export type FbWall$destinationUsersArgs = {
    /**
     * Select specific fields to fetch from the FbDestinationUser
     */
    select?: FbDestinationUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbDestinationUserInclude | null
    where?: FbDestinationUserWhereInput
    orderBy?: Enumerable<FbDestinationUserOrderByWithRelationInput>
    cursor?: FbDestinationUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FbDestinationUserScalarFieldEnum>
  }


  /**
   * FbWall without action
   */
  export type FbWallArgs = {
    /**
     * Select specific fields to fetch from the FbWall
     */
    select?: FbWallSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbWallInclude | null
  }



  /**
   * Model FbDestinationUser
   */


  export type AggregateFbDestinationUser = {
    _count: FbDestinationUserCountAggregateOutputType | null
    _avg: FbDestinationUserAvgAggregateOutputType | null
    _sum: FbDestinationUserSumAggregateOutputType | null
    _min: FbDestinationUserMinAggregateOutputType | null
    _max: FbDestinationUserMaxAggregateOutputType | null
  }

  export type FbDestinationUserAvgAggregateOutputType = {
    id: number | null
    fbWallId: number | null
    shareId: number | null
    groupId: number | null
  }

  export type FbDestinationUserSumAggregateOutputType = {
    id: number | null
    fbWallId: number | null
    shareId: number | null
    groupId: number | null
  }

  export type FbDestinationUserMinAggregateOutputType = {
    id: number | null
    fbWallId: number | null
    shareId: number | null
    groupId: number | null
  }

  export type FbDestinationUserMaxAggregateOutputType = {
    id: number | null
    fbWallId: number | null
    shareId: number | null
    groupId: number | null
  }

  export type FbDestinationUserCountAggregateOutputType = {
    id: number
    fbWallId: number
    shareId: number
    groupId: number
    _all: number
  }


  export type FbDestinationUserAvgAggregateInputType = {
    id?: true
    fbWallId?: true
    shareId?: true
    groupId?: true
  }

  export type FbDestinationUserSumAggregateInputType = {
    id?: true
    fbWallId?: true
    shareId?: true
    groupId?: true
  }

  export type FbDestinationUserMinAggregateInputType = {
    id?: true
    fbWallId?: true
    shareId?: true
    groupId?: true
  }

  export type FbDestinationUserMaxAggregateInputType = {
    id?: true
    fbWallId?: true
    shareId?: true
    groupId?: true
  }

  export type FbDestinationUserCountAggregateInputType = {
    id?: true
    fbWallId?: true
    shareId?: true
    groupId?: true
    _all?: true
  }

  export type FbDestinationUserAggregateArgs = {
    /**
     * Filter which FbDestinationUser to aggregate.
     */
    where?: FbDestinationUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbDestinationUsers to fetch.
     */
    orderBy?: Enumerable<FbDestinationUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FbDestinationUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbDestinationUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbDestinationUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FbDestinationUsers
    **/
    _count?: true | FbDestinationUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FbDestinationUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FbDestinationUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FbDestinationUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FbDestinationUserMaxAggregateInputType
  }

  export type GetFbDestinationUserAggregateType<T extends FbDestinationUserAggregateArgs> = {
        [P in keyof T & keyof AggregateFbDestinationUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFbDestinationUser[P]>
      : GetScalarType<T[P], AggregateFbDestinationUser[P]>
  }




  export type FbDestinationUserGroupByArgs = {
    where?: FbDestinationUserWhereInput
    orderBy?: Enumerable<FbDestinationUserOrderByWithAggregationInput>
    by: FbDestinationUserScalarFieldEnum[]
    having?: FbDestinationUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FbDestinationUserCountAggregateInputType | true
    _avg?: FbDestinationUserAvgAggregateInputType
    _sum?: FbDestinationUserSumAggregateInputType
    _min?: FbDestinationUserMinAggregateInputType
    _max?: FbDestinationUserMaxAggregateInputType
  }


  export type FbDestinationUserGroupByOutputType = {
    id: number
    fbWallId: number
    shareId: number
    groupId: number
    _count: FbDestinationUserCountAggregateOutputType | null
    _avg: FbDestinationUserAvgAggregateOutputType | null
    _sum: FbDestinationUserSumAggregateOutputType | null
    _min: FbDestinationUserMinAggregateOutputType | null
    _max: FbDestinationUserMaxAggregateOutputType | null
  }

  type GetFbDestinationUserGroupByPayload<T extends FbDestinationUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FbDestinationUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FbDestinationUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FbDestinationUserGroupByOutputType[P]>
            : GetScalarType<T[P], FbDestinationUserGroupByOutputType[P]>
        }
      >
    >


  export type FbDestinationUserSelect = {
    id?: boolean
    wall?: boolean | FbWallArgs
    fbWallId?: boolean
    share?: boolean | FbShareArgs
    shareId?: boolean
    group?: boolean | FbGroupArgs
    groupId?: boolean
  }


  export type FbDestinationUserInclude = {
    wall?: boolean | FbWallArgs
    share?: boolean | FbShareArgs
    group?: boolean | FbGroupArgs
  }

  export type FbDestinationUserGetPayload<S extends boolean | null | undefined | FbDestinationUserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FbDestinationUser :
    S extends undefined ? never :
    S extends { include: any } & (FbDestinationUserArgs | FbDestinationUserFindManyArgs)
    ? FbDestinationUser  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'wall' ? FbWallGetPayload<S['include'][P]> :
        P extends 'share' ? FbShareGetPayload<S['include'][P]> :
        P extends 'group' ? FbGroupGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FbDestinationUserArgs | FbDestinationUserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'wall' ? FbWallGetPayload<S['select'][P]> :
        P extends 'share' ? FbShareGetPayload<S['select'][P]> :
        P extends 'group' ? FbGroupGetPayload<S['select'][P]> :  P extends keyof FbDestinationUser ? FbDestinationUser[P] : never
  } 
      : FbDestinationUser


  type FbDestinationUserCountArgs = 
    Omit<FbDestinationUserFindManyArgs, 'select' | 'include'> & {
      select?: FbDestinationUserCountAggregateInputType | true
    }

  export interface FbDestinationUserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one FbDestinationUser that matches the filter.
     * @param {FbDestinationUserFindUniqueArgs} args - Arguments to find a FbDestinationUser
     * @example
     * // Get one FbDestinationUser
     * const fbDestinationUser = await prisma.fbDestinationUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FbDestinationUserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FbDestinationUserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FbDestinationUser'> extends True ? Prisma__FbDestinationUserClient<FbDestinationUserGetPayload<T>> : Prisma__FbDestinationUserClient<FbDestinationUserGetPayload<T> | null, null>

    /**
     * Find one FbDestinationUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FbDestinationUserFindUniqueOrThrowArgs} args - Arguments to find a FbDestinationUser
     * @example
     * // Get one FbDestinationUser
     * const fbDestinationUser = await prisma.fbDestinationUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FbDestinationUserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FbDestinationUserFindUniqueOrThrowArgs>
    ): Prisma__FbDestinationUserClient<FbDestinationUserGetPayload<T>>

    /**
     * Find the first FbDestinationUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbDestinationUserFindFirstArgs} args - Arguments to find a FbDestinationUser
     * @example
     * // Get one FbDestinationUser
     * const fbDestinationUser = await prisma.fbDestinationUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FbDestinationUserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FbDestinationUserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FbDestinationUser'> extends True ? Prisma__FbDestinationUserClient<FbDestinationUserGetPayload<T>> : Prisma__FbDestinationUserClient<FbDestinationUserGetPayload<T> | null, null>

    /**
     * Find the first FbDestinationUser that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbDestinationUserFindFirstOrThrowArgs} args - Arguments to find a FbDestinationUser
     * @example
     * // Get one FbDestinationUser
     * const fbDestinationUser = await prisma.fbDestinationUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FbDestinationUserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FbDestinationUserFindFirstOrThrowArgs>
    ): Prisma__FbDestinationUserClient<FbDestinationUserGetPayload<T>>

    /**
     * Find zero or more FbDestinationUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbDestinationUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FbDestinationUsers
     * const fbDestinationUsers = await prisma.fbDestinationUser.findMany()
     * 
     * // Get first 10 FbDestinationUsers
     * const fbDestinationUsers = await prisma.fbDestinationUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fbDestinationUserWithIdOnly = await prisma.fbDestinationUser.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FbDestinationUserFindManyArgs>(
      args?: SelectSubset<T, FbDestinationUserFindManyArgs>
    ): Prisma.PrismaPromise<Array<FbDestinationUserGetPayload<T>>>

    /**
     * Create a FbDestinationUser.
     * @param {FbDestinationUserCreateArgs} args - Arguments to create a FbDestinationUser.
     * @example
     * // Create one FbDestinationUser
     * const FbDestinationUser = await prisma.fbDestinationUser.create({
     *   data: {
     *     // ... data to create a FbDestinationUser
     *   }
     * })
     * 
    **/
    create<T extends FbDestinationUserCreateArgs>(
      args: SelectSubset<T, FbDestinationUserCreateArgs>
    ): Prisma__FbDestinationUserClient<FbDestinationUserGetPayload<T>>

    /**
     * Create many FbDestinationUsers.
     *     @param {FbDestinationUserCreateManyArgs} args - Arguments to create many FbDestinationUsers.
     *     @example
     *     // Create many FbDestinationUsers
     *     const fbDestinationUser = await prisma.fbDestinationUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FbDestinationUserCreateManyArgs>(
      args?: SelectSubset<T, FbDestinationUserCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FbDestinationUser.
     * @param {FbDestinationUserDeleteArgs} args - Arguments to delete one FbDestinationUser.
     * @example
     * // Delete one FbDestinationUser
     * const FbDestinationUser = await prisma.fbDestinationUser.delete({
     *   where: {
     *     // ... filter to delete one FbDestinationUser
     *   }
     * })
     * 
    **/
    delete<T extends FbDestinationUserDeleteArgs>(
      args: SelectSubset<T, FbDestinationUserDeleteArgs>
    ): Prisma__FbDestinationUserClient<FbDestinationUserGetPayload<T>>

    /**
     * Update one FbDestinationUser.
     * @param {FbDestinationUserUpdateArgs} args - Arguments to update one FbDestinationUser.
     * @example
     * // Update one FbDestinationUser
     * const fbDestinationUser = await prisma.fbDestinationUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FbDestinationUserUpdateArgs>(
      args: SelectSubset<T, FbDestinationUserUpdateArgs>
    ): Prisma__FbDestinationUserClient<FbDestinationUserGetPayload<T>>

    /**
     * Delete zero or more FbDestinationUsers.
     * @param {FbDestinationUserDeleteManyArgs} args - Arguments to filter FbDestinationUsers to delete.
     * @example
     * // Delete a few FbDestinationUsers
     * const { count } = await prisma.fbDestinationUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FbDestinationUserDeleteManyArgs>(
      args?: SelectSubset<T, FbDestinationUserDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FbDestinationUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbDestinationUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FbDestinationUsers
     * const fbDestinationUser = await prisma.fbDestinationUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FbDestinationUserUpdateManyArgs>(
      args: SelectSubset<T, FbDestinationUserUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FbDestinationUser.
     * @param {FbDestinationUserUpsertArgs} args - Arguments to update or create a FbDestinationUser.
     * @example
     * // Update or create a FbDestinationUser
     * const fbDestinationUser = await prisma.fbDestinationUser.upsert({
     *   create: {
     *     // ... data to create a FbDestinationUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FbDestinationUser we want to update
     *   }
     * })
    **/
    upsert<T extends FbDestinationUserUpsertArgs>(
      args: SelectSubset<T, FbDestinationUserUpsertArgs>
    ): Prisma__FbDestinationUserClient<FbDestinationUserGetPayload<T>>

    /**
     * Count the number of FbDestinationUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbDestinationUserCountArgs} args - Arguments to filter FbDestinationUsers to count.
     * @example
     * // Count the number of FbDestinationUsers
     * const count = await prisma.fbDestinationUser.count({
     *   where: {
     *     // ... the filter for the FbDestinationUsers we want to count
     *   }
     * })
    **/
    count<T extends FbDestinationUserCountArgs>(
      args?: Subset<T, FbDestinationUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FbDestinationUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FbDestinationUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbDestinationUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FbDestinationUserAggregateArgs>(args: Subset<T, FbDestinationUserAggregateArgs>): Prisma.PrismaPromise<GetFbDestinationUserAggregateType<T>>

    /**
     * Group by FbDestinationUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FbDestinationUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FbDestinationUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FbDestinationUserGroupByArgs['orderBy'] }
        : { orderBy?: FbDestinationUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FbDestinationUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFbDestinationUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FbDestinationUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FbDestinationUserClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    wall<T extends FbWallArgs= {}>(args?: Subset<T, FbWallArgs>): Prisma__FbWallClient<FbWallGetPayload<T> | Null>;

    share<T extends FbShareArgs= {}>(args?: Subset<T, FbShareArgs>): Prisma__FbShareClient<FbShareGetPayload<T> | Null>;

    group<T extends FbGroupArgs= {}>(args?: Subset<T, FbGroupArgs>): Prisma__FbGroupClient<FbGroupGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FbDestinationUser base type for findUnique actions
   */
  export type FbDestinationUserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FbDestinationUser
     */
    select?: FbDestinationUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbDestinationUserInclude | null
    /**
     * Filter, which FbDestinationUser to fetch.
     */
    where: FbDestinationUserWhereUniqueInput
  }

  /**
   * FbDestinationUser findUnique
   */
  export interface FbDestinationUserFindUniqueArgs extends FbDestinationUserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FbDestinationUser findUniqueOrThrow
   */
  export type FbDestinationUserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FbDestinationUser
     */
    select?: FbDestinationUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbDestinationUserInclude | null
    /**
     * Filter, which FbDestinationUser to fetch.
     */
    where: FbDestinationUserWhereUniqueInput
  }


  /**
   * FbDestinationUser base type for findFirst actions
   */
  export type FbDestinationUserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FbDestinationUser
     */
    select?: FbDestinationUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbDestinationUserInclude | null
    /**
     * Filter, which FbDestinationUser to fetch.
     */
    where?: FbDestinationUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbDestinationUsers to fetch.
     */
    orderBy?: Enumerable<FbDestinationUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FbDestinationUsers.
     */
    cursor?: FbDestinationUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbDestinationUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbDestinationUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FbDestinationUsers.
     */
    distinct?: Enumerable<FbDestinationUserScalarFieldEnum>
  }

  /**
   * FbDestinationUser findFirst
   */
  export interface FbDestinationUserFindFirstArgs extends FbDestinationUserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FbDestinationUser findFirstOrThrow
   */
  export type FbDestinationUserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FbDestinationUser
     */
    select?: FbDestinationUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbDestinationUserInclude | null
    /**
     * Filter, which FbDestinationUser to fetch.
     */
    where?: FbDestinationUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbDestinationUsers to fetch.
     */
    orderBy?: Enumerable<FbDestinationUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FbDestinationUsers.
     */
    cursor?: FbDestinationUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbDestinationUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbDestinationUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FbDestinationUsers.
     */
    distinct?: Enumerable<FbDestinationUserScalarFieldEnum>
  }


  /**
   * FbDestinationUser findMany
   */
  export type FbDestinationUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the FbDestinationUser
     */
    select?: FbDestinationUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbDestinationUserInclude | null
    /**
     * Filter, which FbDestinationUsers to fetch.
     */
    where?: FbDestinationUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FbDestinationUsers to fetch.
     */
    orderBy?: Enumerable<FbDestinationUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FbDestinationUsers.
     */
    cursor?: FbDestinationUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FbDestinationUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FbDestinationUsers.
     */
    skip?: number
    distinct?: Enumerable<FbDestinationUserScalarFieldEnum>
  }


  /**
   * FbDestinationUser create
   */
  export type FbDestinationUserCreateArgs = {
    /**
     * Select specific fields to fetch from the FbDestinationUser
     */
    select?: FbDestinationUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbDestinationUserInclude | null
    /**
     * The data needed to create a FbDestinationUser.
     */
    data: XOR<FbDestinationUserCreateInput, FbDestinationUserUncheckedCreateInput>
  }


  /**
   * FbDestinationUser createMany
   */
  export type FbDestinationUserCreateManyArgs = {
    /**
     * The data used to create many FbDestinationUsers.
     */
    data: Enumerable<FbDestinationUserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FbDestinationUser update
   */
  export type FbDestinationUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the FbDestinationUser
     */
    select?: FbDestinationUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbDestinationUserInclude | null
    /**
     * The data needed to update a FbDestinationUser.
     */
    data: XOR<FbDestinationUserUpdateInput, FbDestinationUserUncheckedUpdateInput>
    /**
     * Choose, which FbDestinationUser to update.
     */
    where: FbDestinationUserWhereUniqueInput
  }


  /**
   * FbDestinationUser updateMany
   */
  export type FbDestinationUserUpdateManyArgs = {
    /**
     * The data used to update FbDestinationUsers.
     */
    data: XOR<FbDestinationUserUpdateManyMutationInput, FbDestinationUserUncheckedUpdateManyInput>
    /**
     * Filter which FbDestinationUsers to update
     */
    where?: FbDestinationUserWhereInput
  }


  /**
   * FbDestinationUser upsert
   */
  export type FbDestinationUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the FbDestinationUser
     */
    select?: FbDestinationUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbDestinationUserInclude | null
    /**
     * The filter to search for the FbDestinationUser to update in case it exists.
     */
    where: FbDestinationUserWhereUniqueInput
    /**
     * In case the FbDestinationUser found by the `where` argument doesn't exist, create a new FbDestinationUser with this data.
     */
    create: XOR<FbDestinationUserCreateInput, FbDestinationUserUncheckedCreateInput>
    /**
     * In case the FbDestinationUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FbDestinationUserUpdateInput, FbDestinationUserUncheckedUpdateInput>
  }


  /**
   * FbDestinationUser delete
   */
  export type FbDestinationUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the FbDestinationUser
     */
    select?: FbDestinationUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbDestinationUserInclude | null
    /**
     * Filter which FbDestinationUser to delete.
     */
    where: FbDestinationUserWhereUniqueInput
  }


  /**
   * FbDestinationUser deleteMany
   */
  export type FbDestinationUserDeleteManyArgs = {
    /**
     * Filter which FbDestinationUsers to delete
     */
    where?: FbDestinationUserWhereInput
  }


  /**
   * FbDestinationUser without action
   */
  export type FbDestinationUserArgs = {
    /**
     * Select specific fields to fetch from the FbDestinationUser
     */
    select?: FbDestinationUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FbDestinationUserInclude | null
  }



  /**
   * Model KorKitchenCategory
   */


  export type AggregateKorKitchenCategory = {
    _count: KorKitchenCategoryCountAggregateOutputType | null
    _avg: KorKitchenCategoryAvgAggregateOutputType | null
    _sum: KorKitchenCategorySumAggregateOutputType | null
    _min: KorKitchenCategoryMinAggregateOutputType | null
    _max: KorKitchenCategoryMaxAggregateOutputType | null
  }

  export type KorKitchenCategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type KorKitchenCategorySumAggregateOutputType = {
    id: number | null
  }

  export type KorKitchenCategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type KorKitchenCategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type KorKitchenCategoryCountAggregateOutputType = {
    id: number
    name: number
    createAt: number
    updateAt: number
    _all: number
  }


  export type KorKitchenCategoryAvgAggregateInputType = {
    id?: true
  }

  export type KorKitchenCategorySumAggregateInputType = {
    id?: true
  }

  export type KorKitchenCategoryMinAggregateInputType = {
    id?: true
    name?: true
    createAt?: true
    updateAt?: true
  }

  export type KorKitchenCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    createAt?: true
    updateAt?: true
  }

  export type KorKitchenCategoryCountAggregateInputType = {
    id?: true
    name?: true
    createAt?: true
    updateAt?: true
    _all?: true
  }

  export type KorKitchenCategoryAggregateArgs = {
    /**
     * Filter which KorKitchenCategory to aggregate.
     */
    where?: KorKitchenCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KorKitchenCategories to fetch.
     */
    orderBy?: Enumerable<KorKitchenCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KorKitchenCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KorKitchenCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KorKitchenCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KorKitchenCategories
    **/
    _count?: true | KorKitchenCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KorKitchenCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KorKitchenCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KorKitchenCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KorKitchenCategoryMaxAggregateInputType
  }

  export type GetKorKitchenCategoryAggregateType<T extends KorKitchenCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateKorKitchenCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKorKitchenCategory[P]>
      : GetScalarType<T[P], AggregateKorKitchenCategory[P]>
  }




  export type KorKitchenCategoryGroupByArgs = {
    where?: KorKitchenCategoryWhereInput
    orderBy?: Enumerable<KorKitchenCategoryOrderByWithAggregationInput>
    by: KorKitchenCategoryScalarFieldEnum[]
    having?: KorKitchenCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KorKitchenCategoryCountAggregateInputType | true
    _avg?: KorKitchenCategoryAvgAggregateInputType
    _sum?: KorKitchenCategorySumAggregateInputType
    _min?: KorKitchenCategoryMinAggregateInputType
    _max?: KorKitchenCategoryMaxAggregateInputType
  }


  export type KorKitchenCategoryGroupByOutputType = {
    id: number
    name: string
    createAt: Date
    updateAt: Date
    _count: KorKitchenCategoryCountAggregateOutputType | null
    _avg: KorKitchenCategoryAvgAggregateOutputType | null
    _sum: KorKitchenCategorySumAggregateOutputType | null
    _min: KorKitchenCategoryMinAggregateOutputType | null
    _max: KorKitchenCategoryMaxAggregateOutputType | null
  }

  type GetKorKitchenCategoryGroupByPayload<T extends KorKitchenCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<KorKitchenCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KorKitchenCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KorKitchenCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], KorKitchenCategoryGroupByOutputType[P]>
        }
      >
    >


  export type KorKitchenCategorySelect = {
    id?: boolean
    name?: boolean
    menu?: boolean | KorKitchenCategory$menuArgs
    createAt?: boolean
    updateAt?: boolean
    _count?: boolean | KorKitchenCategoryCountOutputTypeArgs
  }


  export type KorKitchenCategoryInclude = {
    menu?: boolean | KorKitchenCategory$menuArgs
    _count?: boolean | KorKitchenCategoryCountOutputTypeArgs
  }

  export type KorKitchenCategoryGetPayload<S extends boolean | null | undefined | KorKitchenCategoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? KorKitchenCategory :
    S extends undefined ? never :
    S extends { include: any } & (KorKitchenCategoryArgs | KorKitchenCategoryFindManyArgs)
    ? KorKitchenCategory  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'menu' ? Array < KorKitchenMenuGetPayload<S['include'][P]>>  :
        P extends '_count' ? KorKitchenCategoryCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (KorKitchenCategoryArgs | KorKitchenCategoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'menu' ? Array < KorKitchenMenuGetPayload<S['select'][P]>>  :
        P extends '_count' ? KorKitchenCategoryCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof KorKitchenCategory ? KorKitchenCategory[P] : never
  } 
      : KorKitchenCategory


  type KorKitchenCategoryCountArgs = 
    Omit<KorKitchenCategoryFindManyArgs, 'select' | 'include'> & {
      select?: KorKitchenCategoryCountAggregateInputType | true
    }

  export interface KorKitchenCategoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one KorKitchenCategory that matches the filter.
     * @param {KorKitchenCategoryFindUniqueArgs} args - Arguments to find a KorKitchenCategory
     * @example
     * // Get one KorKitchenCategory
     * const korKitchenCategory = await prisma.korKitchenCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends KorKitchenCategoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, KorKitchenCategoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'KorKitchenCategory'> extends True ? Prisma__KorKitchenCategoryClient<KorKitchenCategoryGetPayload<T>> : Prisma__KorKitchenCategoryClient<KorKitchenCategoryGetPayload<T> | null, null>

    /**
     * Find one KorKitchenCategory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {KorKitchenCategoryFindUniqueOrThrowArgs} args - Arguments to find a KorKitchenCategory
     * @example
     * // Get one KorKitchenCategory
     * const korKitchenCategory = await prisma.korKitchenCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends KorKitchenCategoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, KorKitchenCategoryFindUniqueOrThrowArgs>
    ): Prisma__KorKitchenCategoryClient<KorKitchenCategoryGetPayload<T>>

    /**
     * Find the first KorKitchenCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KorKitchenCategoryFindFirstArgs} args - Arguments to find a KorKitchenCategory
     * @example
     * // Get one KorKitchenCategory
     * const korKitchenCategory = await prisma.korKitchenCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends KorKitchenCategoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, KorKitchenCategoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'KorKitchenCategory'> extends True ? Prisma__KorKitchenCategoryClient<KorKitchenCategoryGetPayload<T>> : Prisma__KorKitchenCategoryClient<KorKitchenCategoryGetPayload<T> | null, null>

    /**
     * Find the first KorKitchenCategory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KorKitchenCategoryFindFirstOrThrowArgs} args - Arguments to find a KorKitchenCategory
     * @example
     * // Get one KorKitchenCategory
     * const korKitchenCategory = await prisma.korKitchenCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends KorKitchenCategoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, KorKitchenCategoryFindFirstOrThrowArgs>
    ): Prisma__KorKitchenCategoryClient<KorKitchenCategoryGetPayload<T>>

    /**
     * Find zero or more KorKitchenCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KorKitchenCategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KorKitchenCategories
     * const korKitchenCategories = await prisma.korKitchenCategory.findMany()
     * 
     * // Get first 10 KorKitchenCategories
     * const korKitchenCategories = await prisma.korKitchenCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const korKitchenCategoryWithIdOnly = await prisma.korKitchenCategory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends KorKitchenCategoryFindManyArgs>(
      args?: SelectSubset<T, KorKitchenCategoryFindManyArgs>
    ): Prisma.PrismaPromise<Array<KorKitchenCategoryGetPayload<T>>>

    /**
     * Create a KorKitchenCategory.
     * @param {KorKitchenCategoryCreateArgs} args - Arguments to create a KorKitchenCategory.
     * @example
     * // Create one KorKitchenCategory
     * const KorKitchenCategory = await prisma.korKitchenCategory.create({
     *   data: {
     *     // ... data to create a KorKitchenCategory
     *   }
     * })
     * 
    **/
    create<T extends KorKitchenCategoryCreateArgs>(
      args: SelectSubset<T, KorKitchenCategoryCreateArgs>
    ): Prisma__KorKitchenCategoryClient<KorKitchenCategoryGetPayload<T>>

    /**
     * Create many KorKitchenCategories.
     *     @param {KorKitchenCategoryCreateManyArgs} args - Arguments to create many KorKitchenCategories.
     *     @example
     *     // Create many KorKitchenCategories
     *     const korKitchenCategory = await prisma.korKitchenCategory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends KorKitchenCategoryCreateManyArgs>(
      args?: SelectSubset<T, KorKitchenCategoryCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a KorKitchenCategory.
     * @param {KorKitchenCategoryDeleteArgs} args - Arguments to delete one KorKitchenCategory.
     * @example
     * // Delete one KorKitchenCategory
     * const KorKitchenCategory = await prisma.korKitchenCategory.delete({
     *   where: {
     *     // ... filter to delete one KorKitchenCategory
     *   }
     * })
     * 
    **/
    delete<T extends KorKitchenCategoryDeleteArgs>(
      args: SelectSubset<T, KorKitchenCategoryDeleteArgs>
    ): Prisma__KorKitchenCategoryClient<KorKitchenCategoryGetPayload<T>>

    /**
     * Update one KorKitchenCategory.
     * @param {KorKitchenCategoryUpdateArgs} args - Arguments to update one KorKitchenCategory.
     * @example
     * // Update one KorKitchenCategory
     * const korKitchenCategory = await prisma.korKitchenCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends KorKitchenCategoryUpdateArgs>(
      args: SelectSubset<T, KorKitchenCategoryUpdateArgs>
    ): Prisma__KorKitchenCategoryClient<KorKitchenCategoryGetPayload<T>>

    /**
     * Delete zero or more KorKitchenCategories.
     * @param {KorKitchenCategoryDeleteManyArgs} args - Arguments to filter KorKitchenCategories to delete.
     * @example
     * // Delete a few KorKitchenCategories
     * const { count } = await prisma.korKitchenCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends KorKitchenCategoryDeleteManyArgs>(
      args?: SelectSubset<T, KorKitchenCategoryDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KorKitchenCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KorKitchenCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KorKitchenCategories
     * const korKitchenCategory = await prisma.korKitchenCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends KorKitchenCategoryUpdateManyArgs>(
      args: SelectSubset<T, KorKitchenCategoryUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KorKitchenCategory.
     * @param {KorKitchenCategoryUpsertArgs} args - Arguments to update or create a KorKitchenCategory.
     * @example
     * // Update or create a KorKitchenCategory
     * const korKitchenCategory = await prisma.korKitchenCategory.upsert({
     *   create: {
     *     // ... data to create a KorKitchenCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KorKitchenCategory we want to update
     *   }
     * })
    **/
    upsert<T extends KorKitchenCategoryUpsertArgs>(
      args: SelectSubset<T, KorKitchenCategoryUpsertArgs>
    ): Prisma__KorKitchenCategoryClient<KorKitchenCategoryGetPayload<T>>

    /**
     * Count the number of KorKitchenCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KorKitchenCategoryCountArgs} args - Arguments to filter KorKitchenCategories to count.
     * @example
     * // Count the number of KorKitchenCategories
     * const count = await prisma.korKitchenCategory.count({
     *   where: {
     *     // ... the filter for the KorKitchenCategories we want to count
     *   }
     * })
    **/
    count<T extends KorKitchenCategoryCountArgs>(
      args?: Subset<T, KorKitchenCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KorKitchenCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KorKitchenCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KorKitchenCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KorKitchenCategoryAggregateArgs>(args: Subset<T, KorKitchenCategoryAggregateArgs>): Prisma.PrismaPromise<GetKorKitchenCategoryAggregateType<T>>

    /**
     * Group by KorKitchenCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KorKitchenCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KorKitchenCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KorKitchenCategoryGroupByArgs['orderBy'] }
        : { orderBy?: KorKitchenCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KorKitchenCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKorKitchenCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for KorKitchenCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__KorKitchenCategoryClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    menu<T extends KorKitchenCategory$menuArgs= {}>(args?: Subset<T, KorKitchenCategory$menuArgs>): Prisma.PrismaPromise<Array<KorKitchenMenuGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * KorKitchenCategory base type for findUnique actions
   */
  export type KorKitchenCategoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the KorKitchenCategory
     */
    select?: KorKitchenCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KorKitchenCategoryInclude | null
    /**
     * Filter, which KorKitchenCategory to fetch.
     */
    where: KorKitchenCategoryWhereUniqueInput
  }

  /**
   * KorKitchenCategory findUnique
   */
  export interface KorKitchenCategoryFindUniqueArgs extends KorKitchenCategoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * KorKitchenCategory findUniqueOrThrow
   */
  export type KorKitchenCategoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the KorKitchenCategory
     */
    select?: KorKitchenCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KorKitchenCategoryInclude | null
    /**
     * Filter, which KorKitchenCategory to fetch.
     */
    where: KorKitchenCategoryWhereUniqueInput
  }


  /**
   * KorKitchenCategory base type for findFirst actions
   */
  export type KorKitchenCategoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the KorKitchenCategory
     */
    select?: KorKitchenCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KorKitchenCategoryInclude | null
    /**
     * Filter, which KorKitchenCategory to fetch.
     */
    where?: KorKitchenCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KorKitchenCategories to fetch.
     */
    orderBy?: Enumerable<KorKitchenCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KorKitchenCategories.
     */
    cursor?: KorKitchenCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KorKitchenCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KorKitchenCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KorKitchenCategories.
     */
    distinct?: Enumerable<KorKitchenCategoryScalarFieldEnum>
  }

  /**
   * KorKitchenCategory findFirst
   */
  export interface KorKitchenCategoryFindFirstArgs extends KorKitchenCategoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * KorKitchenCategory findFirstOrThrow
   */
  export type KorKitchenCategoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the KorKitchenCategory
     */
    select?: KorKitchenCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KorKitchenCategoryInclude | null
    /**
     * Filter, which KorKitchenCategory to fetch.
     */
    where?: KorKitchenCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KorKitchenCategories to fetch.
     */
    orderBy?: Enumerable<KorKitchenCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KorKitchenCategories.
     */
    cursor?: KorKitchenCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KorKitchenCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KorKitchenCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KorKitchenCategories.
     */
    distinct?: Enumerable<KorKitchenCategoryScalarFieldEnum>
  }


  /**
   * KorKitchenCategory findMany
   */
  export type KorKitchenCategoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the KorKitchenCategory
     */
    select?: KorKitchenCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KorKitchenCategoryInclude | null
    /**
     * Filter, which KorKitchenCategories to fetch.
     */
    where?: KorKitchenCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KorKitchenCategories to fetch.
     */
    orderBy?: Enumerable<KorKitchenCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KorKitchenCategories.
     */
    cursor?: KorKitchenCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KorKitchenCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KorKitchenCategories.
     */
    skip?: number
    distinct?: Enumerable<KorKitchenCategoryScalarFieldEnum>
  }


  /**
   * KorKitchenCategory create
   */
  export type KorKitchenCategoryCreateArgs = {
    /**
     * Select specific fields to fetch from the KorKitchenCategory
     */
    select?: KorKitchenCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KorKitchenCategoryInclude | null
    /**
     * The data needed to create a KorKitchenCategory.
     */
    data: XOR<KorKitchenCategoryCreateInput, KorKitchenCategoryUncheckedCreateInput>
  }


  /**
   * KorKitchenCategory createMany
   */
  export type KorKitchenCategoryCreateManyArgs = {
    /**
     * The data used to create many KorKitchenCategories.
     */
    data: Enumerable<KorKitchenCategoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * KorKitchenCategory update
   */
  export type KorKitchenCategoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the KorKitchenCategory
     */
    select?: KorKitchenCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KorKitchenCategoryInclude | null
    /**
     * The data needed to update a KorKitchenCategory.
     */
    data: XOR<KorKitchenCategoryUpdateInput, KorKitchenCategoryUncheckedUpdateInput>
    /**
     * Choose, which KorKitchenCategory to update.
     */
    where: KorKitchenCategoryWhereUniqueInput
  }


  /**
   * KorKitchenCategory updateMany
   */
  export type KorKitchenCategoryUpdateManyArgs = {
    /**
     * The data used to update KorKitchenCategories.
     */
    data: XOR<KorKitchenCategoryUpdateManyMutationInput, KorKitchenCategoryUncheckedUpdateManyInput>
    /**
     * Filter which KorKitchenCategories to update
     */
    where?: KorKitchenCategoryWhereInput
  }


  /**
   * KorKitchenCategory upsert
   */
  export type KorKitchenCategoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the KorKitchenCategory
     */
    select?: KorKitchenCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KorKitchenCategoryInclude | null
    /**
     * The filter to search for the KorKitchenCategory to update in case it exists.
     */
    where: KorKitchenCategoryWhereUniqueInput
    /**
     * In case the KorKitchenCategory found by the `where` argument doesn't exist, create a new KorKitchenCategory with this data.
     */
    create: XOR<KorKitchenCategoryCreateInput, KorKitchenCategoryUncheckedCreateInput>
    /**
     * In case the KorKitchenCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KorKitchenCategoryUpdateInput, KorKitchenCategoryUncheckedUpdateInput>
  }


  /**
   * KorKitchenCategory delete
   */
  export type KorKitchenCategoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the KorKitchenCategory
     */
    select?: KorKitchenCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KorKitchenCategoryInclude | null
    /**
     * Filter which KorKitchenCategory to delete.
     */
    where: KorKitchenCategoryWhereUniqueInput
  }


  /**
   * KorKitchenCategory deleteMany
   */
  export type KorKitchenCategoryDeleteManyArgs = {
    /**
     * Filter which KorKitchenCategories to delete
     */
    where?: KorKitchenCategoryWhereInput
  }


  /**
   * KorKitchenCategory.menu
   */
  export type KorKitchenCategory$menuArgs = {
    /**
     * Select specific fields to fetch from the KorKitchenMenu
     */
    select?: KorKitchenMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KorKitchenMenuInclude | null
    where?: KorKitchenMenuWhereInput
    orderBy?: Enumerable<KorKitchenMenuOrderByWithRelationInput>
    cursor?: KorKitchenMenuWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<KorKitchenMenuScalarFieldEnum>
  }


  /**
   * KorKitchenCategory without action
   */
  export type KorKitchenCategoryArgs = {
    /**
     * Select specific fields to fetch from the KorKitchenCategory
     */
    select?: KorKitchenCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KorKitchenCategoryInclude | null
  }



  /**
   * Model KorKitchenMenu
   */


  export type AggregateKorKitchenMenu = {
    _count: KorKitchenMenuCountAggregateOutputType | null
    _avg: KorKitchenMenuAvgAggregateOutputType | null
    _sum: KorKitchenMenuSumAggregateOutputType | null
    _min: KorKitchenMenuMinAggregateOutputType | null
    _max: KorKitchenMenuMaxAggregateOutputType | null
  }

  export type KorKitchenMenuAvgAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type KorKitchenMenuSumAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type KorKitchenMenuMinAggregateOutputType = {
    id: number | null
    name: string | null
    image: string | null
    price: number | null
    categoryName: string | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type KorKitchenMenuMaxAggregateOutputType = {
    id: number | null
    name: string | null
    image: string | null
    price: number | null
    categoryName: string | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type KorKitchenMenuCountAggregateOutputType = {
    id: number
    name: number
    image: number
    price: number
    categoryName: number
    createAt: number
    updateAt: number
    _all: number
  }


  export type KorKitchenMenuAvgAggregateInputType = {
    id?: true
    price?: true
  }

  export type KorKitchenMenuSumAggregateInputType = {
    id?: true
    price?: true
  }

  export type KorKitchenMenuMinAggregateInputType = {
    id?: true
    name?: true
    image?: true
    price?: true
    categoryName?: true
    createAt?: true
    updateAt?: true
  }

  export type KorKitchenMenuMaxAggregateInputType = {
    id?: true
    name?: true
    image?: true
    price?: true
    categoryName?: true
    createAt?: true
    updateAt?: true
  }

  export type KorKitchenMenuCountAggregateInputType = {
    id?: true
    name?: true
    image?: true
    price?: true
    categoryName?: true
    createAt?: true
    updateAt?: true
    _all?: true
  }

  export type KorKitchenMenuAggregateArgs = {
    /**
     * Filter which KorKitchenMenu to aggregate.
     */
    where?: KorKitchenMenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KorKitchenMenus to fetch.
     */
    orderBy?: Enumerable<KorKitchenMenuOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KorKitchenMenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KorKitchenMenus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KorKitchenMenus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KorKitchenMenus
    **/
    _count?: true | KorKitchenMenuCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KorKitchenMenuAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KorKitchenMenuSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KorKitchenMenuMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KorKitchenMenuMaxAggregateInputType
  }

  export type GetKorKitchenMenuAggregateType<T extends KorKitchenMenuAggregateArgs> = {
        [P in keyof T & keyof AggregateKorKitchenMenu]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKorKitchenMenu[P]>
      : GetScalarType<T[P], AggregateKorKitchenMenu[P]>
  }




  export type KorKitchenMenuGroupByArgs = {
    where?: KorKitchenMenuWhereInput
    orderBy?: Enumerable<KorKitchenMenuOrderByWithAggregationInput>
    by: KorKitchenMenuScalarFieldEnum[]
    having?: KorKitchenMenuScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KorKitchenMenuCountAggregateInputType | true
    _avg?: KorKitchenMenuAvgAggregateInputType
    _sum?: KorKitchenMenuSumAggregateInputType
    _min?: KorKitchenMenuMinAggregateInputType
    _max?: KorKitchenMenuMaxAggregateInputType
  }


  export type KorKitchenMenuGroupByOutputType = {
    id: number
    name: string
    image: string
    price: number
    categoryName: string | null
    createAt: Date
    updateAt: Date
    _count: KorKitchenMenuCountAggregateOutputType | null
    _avg: KorKitchenMenuAvgAggregateOutputType | null
    _sum: KorKitchenMenuSumAggregateOutputType | null
    _min: KorKitchenMenuMinAggregateOutputType | null
    _max: KorKitchenMenuMaxAggregateOutputType | null
  }

  type GetKorKitchenMenuGroupByPayload<T extends KorKitchenMenuGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<KorKitchenMenuGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KorKitchenMenuGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KorKitchenMenuGroupByOutputType[P]>
            : GetScalarType<T[P], KorKitchenMenuGroupByOutputType[P]>
        }
      >
    >


  export type KorKitchenMenuSelect = {
    id?: boolean
    name?: boolean
    image?: boolean
    price?: boolean
    category?: boolean | KorKitchenCategoryArgs
    categoryName?: boolean
    orderItems?: boolean | KorKitchenMenu$orderItemsArgs
    createAt?: boolean
    updateAt?: boolean
    _count?: boolean | KorKitchenMenuCountOutputTypeArgs
  }


  export type KorKitchenMenuInclude = {
    category?: boolean | KorKitchenCategoryArgs
    orderItems?: boolean | KorKitchenMenu$orderItemsArgs
    _count?: boolean | KorKitchenMenuCountOutputTypeArgs
  }

  export type KorKitchenMenuGetPayload<S extends boolean | null | undefined | KorKitchenMenuArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? KorKitchenMenu :
    S extends undefined ? never :
    S extends { include: any } & (KorKitchenMenuArgs | KorKitchenMenuFindManyArgs)
    ? KorKitchenMenu  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'category' ? KorKitchenCategoryGetPayload<S['include'][P]> | null :
        P extends 'orderItems' ? Array < KorKitchenOrderItemGetPayload<S['include'][P]>>  :
        P extends '_count' ? KorKitchenMenuCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (KorKitchenMenuArgs | KorKitchenMenuFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'category' ? KorKitchenCategoryGetPayload<S['select'][P]> | null :
        P extends 'orderItems' ? Array < KorKitchenOrderItemGetPayload<S['select'][P]>>  :
        P extends '_count' ? KorKitchenMenuCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof KorKitchenMenu ? KorKitchenMenu[P] : never
  } 
      : KorKitchenMenu


  type KorKitchenMenuCountArgs = 
    Omit<KorKitchenMenuFindManyArgs, 'select' | 'include'> & {
      select?: KorKitchenMenuCountAggregateInputType | true
    }

  export interface KorKitchenMenuDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one KorKitchenMenu that matches the filter.
     * @param {KorKitchenMenuFindUniqueArgs} args - Arguments to find a KorKitchenMenu
     * @example
     * // Get one KorKitchenMenu
     * const korKitchenMenu = await prisma.korKitchenMenu.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends KorKitchenMenuFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, KorKitchenMenuFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'KorKitchenMenu'> extends True ? Prisma__KorKitchenMenuClient<KorKitchenMenuGetPayload<T>> : Prisma__KorKitchenMenuClient<KorKitchenMenuGetPayload<T> | null, null>

    /**
     * Find one KorKitchenMenu that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {KorKitchenMenuFindUniqueOrThrowArgs} args - Arguments to find a KorKitchenMenu
     * @example
     * // Get one KorKitchenMenu
     * const korKitchenMenu = await prisma.korKitchenMenu.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends KorKitchenMenuFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, KorKitchenMenuFindUniqueOrThrowArgs>
    ): Prisma__KorKitchenMenuClient<KorKitchenMenuGetPayload<T>>

    /**
     * Find the first KorKitchenMenu that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KorKitchenMenuFindFirstArgs} args - Arguments to find a KorKitchenMenu
     * @example
     * // Get one KorKitchenMenu
     * const korKitchenMenu = await prisma.korKitchenMenu.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends KorKitchenMenuFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, KorKitchenMenuFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'KorKitchenMenu'> extends True ? Prisma__KorKitchenMenuClient<KorKitchenMenuGetPayload<T>> : Prisma__KorKitchenMenuClient<KorKitchenMenuGetPayload<T> | null, null>

    /**
     * Find the first KorKitchenMenu that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KorKitchenMenuFindFirstOrThrowArgs} args - Arguments to find a KorKitchenMenu
     * @example
     * // Get one KorKitchenMenu
     * const korKitchenMenu = await prisma.korKitchenMenu.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends KorKitchenMenuFindFirstOrThrowArgs>(
      args?: SelectSubset<T, KorKitchenMenuFindFirstOrThrowArgs>
    ): Prisma__KorKitchenMenuClient<KorKitchenMenuGetPayload<T>>

    /**
     * Find zero or more KorKitchenMenus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KorKitchenMenuFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KorKitchenMenus
     * const korKitchenMenus = await prisma.korKitchenMenu.findMany()
     * 
     * // Get first 10 KorKitchenMenus
     * const korKitchenMenus = await prisma.korKitchenMenu.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const korKitchenMenuWithIdOnly = await prisma.korKitchenMenu.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends KorKitchenMenuFindManyArgs>(
      args?: SelectSubset<T, KorKitchenMenuFindManyArgs>
    ): Prisma.PrismaPromise<Array<KorKitchenMenuGetPayload<T>>>

    /**
     * Create a KorKitchenMenu.
     * @param {KorKitchenMenuCreateArgs} args - Arguments to create a KorKitchenMenu.
     * @example
     * // Create one KorKitchenMenu
     * const KorKitchenMenu = await prisma.korKitchenMenu.create({
     *   data: {
     *     // ... data to create a KorKitchenMenu
     *   }
     * })
     * 
    **/
    create<T extends KorKitchenMenuCreateArgs>(
      args: SelectSubset<T, KorKitchenMenuCreateArgs>
    ): Prisma__KorKitchenMenuClient<KorKitchenMenuGetPayload<T>>

    /**
     * Create many KorKitchenMenus.
     *     @param {KorKitchenMenuCreateManyArgs} args - Arguments to create many KorKitchenMenus.
     *     @example
     *     // Create many KorKitchenMenus
     *     const korKitchenMenu = await prisma.korKitchenMenu.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends KorKitchenMenuCreateManyArgs>(
      args?: SelectSubset<T, KorKitchenMenuCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a KorKitchenMenu.
     * @param {KorKitchenMenuDeleteArgs} args - Arguments to delete one KorKitchenMenu.
     * @example
     * // Delete one KorKitchenMenu
     * const KorKitchenMenu = await prisma.korKitchenMenu.delete({
     *   where: {
     *     // ... filter to delete one KorKitchenMenu
     *   }
     * })
     * 
    **/
    delete<T extends KorKitchenMenuDeleteArgs>(
      args: SelectSubset<T, KorKitchenMenuDeleteArgs>
    ): Prisma__KorKitchenMenuClient<KorKitchenMenuGetPayload<T>>

    /**
     * Update one KorKitchenMenu.
     * @param {KorKitchenMenuUpdateArgs} args - Arguments to update one KorKitchenMenu.
     * @example
     * // Update one KorKitchenMenu
     * const korKitchenMenu = await prisma.korKitchenMenu.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends KorKitchenMenuUpdateArgs>(
      args: SelectSubset<T, KorKitchenMenuUpdateArgs>
    ): Prisma__KorKitchenMenuClient<KorKitchenMenuGetPayload<T>>

    /**
     * Delete zero or more KorKitchenMenus.
     * @param {KorKitchenMenuDeleteManyArgs} args - Arguments to filter KorKitchenMenus to delete.
     * @example
     * // Delete a few KorKitchenMenus
     * const { count } = await prisma.korKitchenMenu.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends KorKitchenMenuDeleteManyArgs>(
      args?: SelectSubset<T, KorKitchenMenuDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KorKitchenMenus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KorKitchenMenuUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KorKitchenMenus
     * const korKitchenMenu = await prisma.korKitchenMenu.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends KorKitchenMenuUpdateManyArgs>(
      args: SelectSubset<T, KorKitchenMenuUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KorKitchenMenu.
     * @param {KorKitchenMenuUpsertArgs} args - Arguments to update or create a KorKitchenMenu.
     * @example
     * // Update or create a KorKitchenMenu
     * const korKitchenMenu = await prisma.korKitchenMenu.upsert({
     *   create: {
     *     // ... data to create a KorKitchenMenu
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KorKitchenMenu we want to update
     *   }
     * })
    **/
    upsert<T extends KorKitchenMenuUpsertArgs>(
      args: SelectSubset<T, KorKitchenMenuUpsertArgs>
    ): Prisma__KorKitchenMenuClient<KorKitchenMenuGetPayload<T>>

    /**
     * Count the number of KorKitchenMenus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KorKitchenMenuCountArgs} args - Arguments to filter KorKitchenMenus to count.
     * @example
     * // Count the number of KorKitchenMenus
     * const count = await prisma.korKitchenMenu.count({
     *   where: {
     *     // ... the filter for the KorKitchenMenus we want to count
     *   }
     * })
    **/
    count<T extends KorKitchenMenuCountArgs>(
      args?: Subset<T, KorKitchenMenuCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KorKitchenMenuCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KorKitchenMenu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KorKitchenMenuAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KorKitchenMenuAggregateArgs>(args: Subset<T, KorKitchenMenuAggregateArgs>): Prisma.PrismaPromise<GetKorKitchenMenuAggregateType<T>>

    /**
     * Group by KorKitchenMenu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KorKitchenMenuGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KorKitchenMenuGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KorKitchenMenuGroupByArgs['orderBy'] }
        : { orderBy?: KorKitchenMenuGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KorKitchenMenuGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKorKitchenMenuGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for KorKitchenMenu.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__KorKitchenMenuClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    category<T extends KorKitchenCategoryArgs= {}>(args?: Subset<T, KorKitchenCategoryArgs>): Prisma__KorKitchenCategoryClient<KorKitchenCategoryGetPayload<T> | Null>;

    orderItems<T extends KorKitchenMenu$orderItemsArgs= {}>(args?: Subset<T, KorKitchenMenu$orderItemsArgs>): Prisma.PrismaPromise<Array<KorKitchenOrderItemGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * KorKitchenMenu base type for findUnique actions
   */
  export type KorKitchenMenuFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the KorKitchenMenu
     */
    select?: KorKitchenMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KorKitchenMenuInclude | null
    /**
     * Filter, which KorKitchenMenu to fetch.
     */
    where: KorKitchenMenuWhereUniqueInput
  }

  /**
   * KorKitchenMenu findUnique
   */
  export interface KorKitchenMenuFindUniqueArgs extends KorKitchenMenuFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * KorKitchenMenu findUniqueOrThrow
   */
  export type KorKitchenMenuFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the KorKitchenMenu
     */
    select?: KorKitchenMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KorKitchenMenuInclude | null
    /**
     * Filter, which KorKitchenMenu to fetch.
     */
    where: KorKitchenMenuWhereUniqueInput
  }


  /**
   * KorKitchenMenu base type for findFirst actions
   */
  export type KorKitchenMenuFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the KorKitchenMenu
     */
    select?: KorKitchenMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KorKitchenMenuInclude | null
    /**
     * Filter, which KorKitchenMenu to fetch.
     */
    where?: KorKitchenMenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KorKitchenMenus to fetch.
     */
    orderBy?: Enumerable<KorKitchenMenuOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KorKitchenMenus.
     */
    cursor?: KorKitchenMenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KorKitchenMenus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KorKitchenMenus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KorKitchenMenus.
     */
    distinct?: Enumerable<KorKitchenMenuScalarFieldEnum>
  }

  /**
   * KorKitchenMenu findFirst
   */
  export interface KorKitchenMenuFindFirstArgs extends KorKitchenMenuFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * KorKitchenMenu findFirstOrThrow
   */
  export type KorKitchenMenuFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the KorKitchenMenu
     */
    select?: KorKitchenMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KorKitchenMenuInclude | null
    /**
     * Filter, which KorKitchenMenu to fetch.
     */
    where?: KorKitchenMenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KorKitchenMenus to fetch.
     */
    orderBy?: Enumerable<KorKitchenMenuOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KorKitchenMenus.
     */
    cursor?: KorKitchenMenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KorKitchenMenus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KorKitchenMenus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KorKitchenMenus.
     */
    distinct?: Enumerable<KorKitchenMenuScalarFieldEnum>
  }


  /**
   * KorKitchenMenu findMany
   */
  export type KorKitchenMenuFindManyArgs = {
    /**
     * Select specific fields to fetch from the KorKitchenMenu
     */
    select?: KorKitchenMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KorKitchenMenuInclude | null
    /**
     * Filter, which KorKitchenMenus to fetch.
     */
    where?: KorKitchenMenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KorKitchenMenus to fetch.
     */
    orderBy?: Enumerable<KorKitchenMenuOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KorKitchenMenus.
     */
    cursor?: KorKitchenMenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KorKitchenMenus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KorKitchenMenus.
     */
    skip?: number
    distinct?: Enumerable<KorKitchenMenuScalarFieldEnum>
  }


  /**
   * KorKitchenMenu create
   */
  export type KorKitchenMenuCreateArgs = {
    /**
     * Select specific fields to fetch from the KorKitchenMenu
     */
    select?: KorKitchenMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KorKitchenMenuInclude | null
    /**
     * The data needed to create a KorKitchenMenu.
     */
    data: XOR<KorKitchenMenuCreateInput, KorKitchenMenuUncheckedCreateInput>
  }


  /**
   * KorKitchenMenu createMany
   */
  export type KorKitchenMenuCreateManyArgs = {
    /**
     * The data used to create many KorKitchenMenus.
     */
    data: Enumerable<KorKitchenMenuCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * KorKitchenMenu update
   */
  export type KorKitchenMenuUpdateArgs = {
    /**
     * Select specific fields to fetch from the KorKitchenMenu
     */
    select?: KorKitchenMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KorKitchenMenuInclude | null
    /**
     * The data needed to update a KorKitchenMenu.
     */
    data: XOR<KorKitchenMenuUpdateInput, KorKitchenMenuUncheckedUpdateInput>
    /**
     * Choose, which KorKitchenMenu to update.
     */
    where: KorKitchenMenuWhereUniqueInput
  }


  /**
   * KorKitchenMenu updateMany
   */
  export type KorKitchenMenuUpdateManyArgs = {
    /**
     * The data used to update KorKitchenMenus.
     */
    data: XOR<KorKitchenMenuUpdateManyMutationInput, KorKitchenMenuUncheckedUpdateManyInput>
    /**
     * Filter which KorKitchenMenus to update
     */
    where?: KorKitchenMenuWhereInput
  }


  /**
   * KorKitchenMenu upsert
   */
  export type KorKitchenMenuUpsertArgs = {
    /**
     * Select specific fields to fetch from the KorKitchenMenu
     */
    select?: KorKitchenMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KorKitchenMenuInclude | null
    /**
     * The filter to search for the KorKitchenMenu to update in case it exists.
     */
    where: KorKitchenMenuWhereUniqueInput
    /**
     * In case the KorKitchenMenu found by the `where` argument doesn't exist, create a new KorKitchenMenu with this data.
     */
    create: XOR<KorKitchenMenuCreateInput, KorKitchenMenuUncheckedCreateInput>
    /**
     * In case the KorKitchenMenu was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KorKitchenMenuUpdateInput, KorKitchenMenuUncheckedUpdateInput>
  }


  /**
   * KorKitchenMenu delete
   */
  export type KorKitchenMenuDeleteArgs = {
    /**
     * Select specific fields to fetch from the KorKitchenMenu
     */
    select?: KorKitchenMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KorKitchenMenuInclude | null
    /**
     * Filter which KorKitchenMenu to delete.
     */
    where: KorKitchenMenuWhereUniqueInput
  }


  /**
   * KorKitchenMenu deleteMany
   */
  export type KorKitchenMenuDeleteManyArgs = {
    /**
     * Filter which KorKitchenMenus to delete
     */
    where?: KorKitchenMenuWhereInput
  }


  /**
   * KorKitchenMenu.orderItems
   */
  export type KorKitchenMenu$orderItemsArgs = {
    /**
     * Select specific fields to fetch from the KorKitchenOrderItem
     */
    select?: KorKitchenOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KorKitchenOrderItemInclude | null
    where?: KorKitchenOrderItemWhereInput
    orderBy?: Enumerable<KorKitchenOrderItemOrderByWithRelationInput>
    cursor?: KorKitchenOrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<KorKitchenOrderItemScalarFieldEnum>
  }


  /**
   * KorKitchenMenu without action
   */
  export type KorKitchenMenuArgs = {
    /**
     * Select specific fields to fetch from the KorKitchenMenu
     */
    select?: KorKitchenMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KorKitchenMenuInclude | null
  }



  /**
   * Model KorKitchenOrder
   */


  export type AggregateKorKitchenOrder = {
    _count: KorKitchenOrderCountAggregateOutputType | null
    _avg: KorKitchenOrderAvgAggregateOutputType | null
    _sum: KorKitchenOrderSumAggregateOutputType | null
    _min: KorKitchenOrderMinAggregateOutputType | null
    _max: KorKitchenOrderMaxAggregateOutputType | null
  }

  export type KorKitchenOrderAvgAggregateOutputType = {
    id: number | null
    tableId: number | null
  }

  export type KorKitchenOrderSumAggregateOutputType = {
    id: number | null
    tableId: number | null
  }

  export type KorKitchenOrderMinAggregateOutputType = {
    id: number | null
    status: string | null
    tableId: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type KorKitchenOrderMaxAggregateOutputType = {
    id: number | null
    status: string | null
    tableId: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type KorKitchenOrderCountAggregateOutputType = {
    id: number
    status: number
    tableId: number
    createAt: number
    updateAt: number
    _all: number
  }


  export type KorKitchenOrderAvgAggregateInputType = {
    id?: true
    tableId?: true
  }

  export type KorKitchenOrderSumAggregateInputType = {
    id?: true
    tableId?: true
  }

  export type KorKitchenOrderMinAggregateInputType = {
    id?: true
    status?: true
    tableId?: true
    createAt?: true
    updateAt?: true
  }

  export type KorKitchenOrderMaxAggregateInputType = {
    id?: true
    status?: true
    tableId?: true
    createAt?: true
    updateAt?: true
  }

  export type KorKitchenOrderCountAggregateInputType = {
    id?: true
    status?: true
    tableId?: true
    createAt?: true
    updateAt?: true
    _all?: true
  }

  export type KorKitchenOrderAggregateArgs = {
    /**
     * Filter which KorKitchenOrder to aggregate.
     */
    where?: KorKitchenOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KorKitchenOrders to fetch.
     */
    orderBy?: Enumerable<KorKitchenOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KorKitchenOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KorKitchenOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KorKitchenOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KorKitchenOrders
    **/
    _count?: true | KorKitchenOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KorKitchenOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KorKitchenOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KorKitchenOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KorKitchenOrderMaxAggregateInputType
  }

  export type GetKorKitchenOrderAggregateType<T extends KorKitchenOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateKorKitchenOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKorKitchenOrder[P]>
      : GetScalarType<T[P], AggregateKorKitchenOrder[P]>
  }




  export type KorKitchenOrderGroupByArgs = {
    where?: KorKitchenOrderWhereInput
    orderBy?: Enumerable<KorKitchenOrderOrderByWithAggregationInput>
    by: KorKitchenOrderScalarFieldEnum[]
    having?: KorKitchenOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KorKitchenOrderCountAggregateInputType | true
    _avg?: KorKitchenOrderAvgAggregateInputType
    _sum?: KorKitchenOrderSumAggregateInputType
    _min?: KorKitchenOrderMinAggregateInputType
    _max?: KorKitchenOrderMaxAggregateInputType
  }


  export type KorKitchenOrderGroupByOutputType = {
    id: number
    status: string
    tableId: number
    createAt: Date
    updateAt: Date
    _count: KorKitchenOrderCountAggregateOutputType | null
    _avg: KorKitchenOrderAvgAggregateOutputType | null
    _sum: KorKitchenOrderSumAggregateOutputType | null
    _min: KorKitchenOrderMinAggregateOutputType | null
    _max: KorKitchenOrderMaxAggregateOutputType | null
  }

  type GetKorKitchenOrderGroupByPayload<T extends KorKitchenOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<KorKitchenOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KorKitchenOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KorKitchenOrderGroupByOutputType[P]>
            : GetScalarType<T[P], KorKitchenOrderGroupByOutputType[P]>
        }
      >
    >


  export type KorKitchenOrderSelect = {
    id?: boolean
    status?: boolean
    tableId?: boolean
    items?: boolean | KorKitchenOrder$itemsArgs
    createAt?: boolean
    updateAt?: boolean
    _count?: boolean | KorKitchenOrderCountOutputTypeArgs
  }


  export type KorKitchenOrderInclude = {
    items?: boolean | KorKitchenOrder$itemsArgs
    _count?: boolean | KorKitchenOrderCountOutputTypeArgs
  }

  export type KorKitchenOrderGetPayload<S extends boolean | null | undefined | KorKitchenOrderArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? KorKitchenOrder :
    S extends undefined ? never :
    S extends { include: any } & (KorKitchenOrderArgs | KorKitchenOrderFindManyArgs)
    ? KorKitchenOrder  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'items' ? Array < KorKitchenOrderItemGetPayload<S['include'][P]>>  :
        P extends '_count' ? KorKitchenOrderCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (KorKitchenOrderArgs | KorKitchenOrderFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'items' ? Array < KorKitchenOrderItemGetPayload<S['select'][P]>>  :
        P extends '_count' ? KorKitchenOrderCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof KorKitchenOrder ? KorKitchenOrder[P] : never
  } 
      : KorKitchenOrder


  type KorKitchenOrderCountArgs = 
    Omit<KorKitchenOrderFindManyArgs, 'select' | 'include'> & {
      select?: KorKitchenOrderCountAggregateInputType | true
    }

  export interface KorKitchenOrderDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one KorKitchenOrder that matches the filter.
     * @param {KorKitchenOrderFindUniqueArgs} args - Arguments to find a KorKitchenOrder
     * @example
     * // Get one KorKitchenOrder
     * const korKitchenOrder = await prisma.korKitchenOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends KorKitchenOrderFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, KorKitchenOrderFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'KorKitchenOrder'> extends True ? Prisma__KorKitchenOrderClient<KorKitchenOrderGetPayload<T>> : Prisma__KorKitchenOrderClient<KorKitchenOrderGetPayload<T> | null, null>

    /**
     * Find one KorKitchenOrder that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {KorKitchenOrderFindUniqueOrThrowArgs} args - Arguments to find a KorKitchenOrder
     * @example
     * // Get one KorKitchenOrder
     * const korKitchenOrder = await prisma.korKitchenOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends KorKitchenOrderFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, KorKitchenOrderFindUniqueOrThrowArgs>
    ): Prisma__KorKitchenOrderClient<KorKitchenOrderGetPayload<T>>

    /**
     * Find the first KorKitchenOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KorKitchenOrderFindFirstArgs} args - Arguments to find a KorKitchenOrder
     * @example
     * // Get one KorKitchenOrder
     * const korKitchenOrder = await prisma.korKitchenOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends KorKitchenOrderFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, KorKitchenOrderFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'KorKitchenOrder'> extends True ? Prisma__KorKitchenOrderClient<KorKitchenOrderGetPayload<T>> : Prisma__KorKitchenOrderClient<KorKitchenOrderGetPayload<T> | null, null>

    /**
     * Find the first KorKitchenOrder that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KorKitchenOrderFindFirstOrThrowArgs} args - Arguments to find a KorKitchenOrder
     * @example
     * // Get one KorKitchenOrder
     * const korKitchenOrder = await prisma.korKitchenOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends KorKitchenOrderFindFirstOrThrowArgs>(
      args?: SelectSubset<T, KorKitchenOrderFindFirstOrThrowArgs>
    ): Prisma__KorKitchenOrderClient<KorKitchenOrderGetPayload<T>>

    /**
     * Find zero or more KorKitchenOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KorKitchenOrderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KorKitchenOrders
     * const korKitchenOrders = await prisma.korKitchenOrder.findMany()
     * 
     * // Get first 10 KorKitchenOrders
     * const korKitchenOrders = await prisma.korKitchenOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const korKitchenOrderWithIdOnly = await prisma.korKitchenOrder.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends KorKitchenOrderFindManyArgs>(
      args?: SelectSubset<T, KorKitchenOrderFindManyArgs>
    ): Prisma.PrismaPromise<Array<KorKitchenOrderGetPayload<T>>>

    /**
     * Create a KorKitchenOrder.
     * @param {KorKitchenOrderCreateArgs} args - Arguments to create a KorKitchenOrder.
     * @example
     * // Create one KorKitchenOrder
     * const KorKitchenOrder = await prisma.korKitchenOrder.create({
     *   data: {
     *     // ... data to create a KorKitchenOrder
     *   }
     * })
     * 
    **/
    create<T extends KorKitchenOrderCreateArgs>(
      args: SelectSubset<T, KorKitchenOrderCreateArgs>
    ): Prisma__KorKitchenOrderClient<KorKitchenOrderGetPayload<T>>

    /**
     * Create many KorKitchenOrders.
     *     @param {KorKitchenOrderCreateManyArgs} args - Arguments to create many KorKitchenOrders.
     *     @example
     *     // Create many KorKitchenOrders
     *     const korKitchenOrder = await prisma.korKitchenOrder.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends KorKitchenOrderCreateManyArgs>(
      args?: SelectSubset<T, KorKitchenOrderCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a KorKitchenOrder.
     * @param {KorKitchenOrderDeleteArgs} args - Arguments to delete one KorKitchenOrder.
     * @example
     * // Delete one KorKitchenOrder
     * const KorKitchenOrder = await prisma.korKitchenOrder.delete({
     *   where: {
     *     // ... filter to delete one KorKitchenOrder
     *   }
     * })
     * 
    **/
    delete<T extends KorKitchenOrderDeleteArgs>(
      args: SelectSubset<T, KorKitchenOrderDeleteArgs>
    ): Prisma__KorKitchenOrderClient<KorKitchenOrderGetPayload<T>>

    /**
     * Update one KorKitchenOrder.
     * @param {KorKitchenOrderUpdateArgs} args - Arguments to update one KorKitchenOrder.
     * @example
     * // Update one KorKitchenOrder
     * const korKitchenOrder = await prisma.korKitchenOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends KorKitchenOrderUpdateArgs>(
      args: SelectSubset<T, KorKitchenOrderUpdateArgs>
    ): Prisma__KorKitchenOrderClient<KorKitchenOrderGetPayload<T>>

    /**
     * Delete zero or more KorKitchenOrders.
     * @param {KorKitchenOrderDeleteManyArgs} args - Arguments to filter KorKitchenOrders to delete.
     * @example
     * // Delete a few KorKitchenOrders
     * const { count } = await prisma.korKitchenOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends KorKitchenOrderDeleteManyArgs>(
      args?: SelectSubset<T, KorKitchenOrderDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KorKitchenOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KorKitchenOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KorKitchenOrders
     * const korKitchenOrder = await prisma.korKitchenOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends KorKitchenOrderUpdateManyArgs>(
      args: SelectSubset<T, KorKitchenOrderUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KorKitchenOrder.
     * @param {KorKitchenOrderUpsertArgs} args - Arguments to update or create a KorKitchenOrder.
     * @example
     * // Update or create a KorKitchenOrder
     * const korKitchenOrder = await prisma.korKitchenOrder.upsert({
     *   create: {
     *     // ... data to create a KorKitchenOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KorKitchenOrder we want to update
     *   }
     * })
    **/
    upsert<T extends KorKitchenOrderUpsertArgs>(
      args: SelectSubset<T, KorKitchenOrderUpsertArgs>
    ): Prisma__KorKitchenOrderClient<KorKitchenOrderGetPayload<T>>

    /**
     * Count the number of KorKitchenOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KorKitchenOrderCountArgs} args - Arguments to filter KorKitchenOrders to count.
     * @example
     * // Count the number of KorKitchenOrders
     * const count = await prisma.korKitchenOrder.count({
     *   where: {
     *     // ... the filter for the KorKitchenOrders we want to count
     *   }
     * })
    **/
    count<T extends KorKitchenOrderCountArgs>(
      args?: Subset<T, KorKitchenOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KorKitchenOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KorKitchenOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KorKitchenOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KorKitchenOrderAggregateArgs>(args: Subset<T, KorKitchenOrderAggregateArgs>): Prisma.PrismaPromise<GetKorKitchenOrderAggregateType<T>>

    /**
     * Group by KorKitchenOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KorKitchenOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KorKitchenOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KorKitchenOrderGroupByArgs['orderBy'] }
        : { orderBy?: KorKitchenOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KorKitchenOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKorKitchenOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for KorKitchenOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__KorKitchenOrderClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    items<T extends KorKitchenOrder$itemsArgs= {}>(args?: Subset<T, KorKitchenOrder$itemsArgs>): Prisma.PrismaPromise<Array<KorKitchenOrderItemGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * KorKitchenOrder base type for findUnique actions
   */
  export type KorKitchenOrderFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the KorKitchenOrder
     */
    select?: KorKitchenOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KorKitchenOrderInclude | null
    /**
     * Filter, which KorKitchenOrder to fetch.
     */
    where: KorKitchenOrderWhereUniqueInput
  }

  /**
   * KorKitchenOrder findUnique
   */
  export interface KorKitchenOrderFindUniqueArgs extends KorKitchenOrderFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * KorKitchenOrder findUniqueOrThrow
   */
  export type KorKitchenOrderFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the KorKitchenOrder
     */
    select?: KorKitchenOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KorKitchenOrderInclude | null
    /**
     * Filter, which KorKitchenOrder to fetch.
     */
    where: KorKitchenOrderWhereUniqueInput
  }


  /**
   * KorKitchenOrder base type for findFirst actions
   */
  export type KorKitchenOrderFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the KorKitchenOrder
     */
    select?: KorKitchenOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KorKitchenOrderInclude | null
    /**
     * Filter, which KorKitchenOrder to fetch.
     */
    where?: KorKitchenOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KorKitchenOrders to fetch.
     */
    orderBy?: Enumerable<KorKitchenOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KorKitchenOrders.
     */
    cursor?: KorKitchenOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KorKitchenOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KorKitchenOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KorKitchenOrders.
     */
    distinct?: Enumerable<KorKitchenOrderScalarFieldEnum>
  }

  /**
   * KorKitchenOrder findFirst
   */
  export interface KorKitchenOrderFindFirstArgs extends KorKitchenOrderFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * KorKitchenOrder findFirstOrThrow
   */
  export type KorKitchenOrderFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the KorKitchenOrder
     */
    select?: KorKitchenOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KorKitchenOrderInclude | null
    /**
     * Filter, which KorKitchenOrder to fetch.
     */
    where?: KorKitchenOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KorKitchenOrders to fetch.
     */
    orderBy?: Enumerable<KorKitchenOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KorKitchenOrders.
     */
    cursor?: KorKitchenOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KorKitchenOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KorKitchenOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KorKitchenOrders.
     */
    distinct?: Enumerable<KorKitchenOrderScalarFieldEnum>
  }


  /**
   * KorKitchenOrder findMany
   */
  export type KorKitchenOrderFindManyArgs = {
    /**
     * Select specific fields to fetch from the KorKitchenOrder
     */
    select?: KorKitchenOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KorKitchenOrderInclude | null
    /**
     * Filter, which KorKitchenOrders to fetch.
     */
    where?: KorKitchenOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KorKitchenOrders to fetch.
     */
    orderBy?: Enumerable<KorKitchenOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KorKitchenOrders.
     */
    cursor?: KorKitchenOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KorKitchenOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KorKitchenOrders.
     */
    skip?: number
    distinct?: Enumerable<KorKitchenOrderScalarFieldEnum>
  }


  /**
   * KorKitchenOrder create
   */
  export type KorKitchenOrderCreateArgs = {
    /**
     * Select specific fields to fetch from the KorKitchenOrder
     */
    select?: KorKitchenOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KorKitchenOrderInclude | null
    /**
     * The data needed to create a KorKitchenOrder.
     */
    data: XOR<KorKitchenOrderCreateInput, KorKitchenOrderUncheckedCreateInput>
  }


  /**
   * KorKitchenOrder createMany
   */
  export type KorKitchenOrderCreateManyArgs = {
    /**
     * The data used to create many KorKitchenOrders.
     */
    data: Enumerable<KorKitchenOrderCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * KorKitchenOrder update
   */
  export type KorKitchenOrderUpdateArgs = {
    /**
     * Select specific fields to fetch from the KorKitchenOrder
     */
    select?: KorKitchenOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KorKitchenOrderInclude | null
    /**
     * The data needed to update a KorKitchenOrder.
     */
    data: XOR<KorKitchenOrderUpdateInput, KorKitchenOrderUncheckedUpdateInput>
    /**
     * Choose, which KorKitchenOrder to update.
     */
    where: KorKitchenOrderWhereUniqueInput
  }


  /**
   * KorKitchenOrder updateMany
   */
  export type KorKitchenOrderUpdateManyArgs = {
    /**
     * The data used to update KorKitchenOrders.
     */
    data: XOR<KorKitchenOrderUpdateManyMutationInput, KorKitchenOrderUncheckedUpdateManyInput>
    /**
     * Filter which KorKitchenOrders to update
     */
    where?: KorKitchenOrderWhereInput
  }


  /**
   * KorKitchenOrder upsert
   */
  export type KorKitchenOrderUpsertArgs = {
    /**
     * Select specific fields to fetch from the KorKitchenOrder
     */
    select?: KorKitchenOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KorKitchenOrderInclude | null
    /**
     * The filter to search for the KorKitchenOrder to update in case it exists.
     */
    where: KorKitchenOrderWhereUniqueInput
    /**
     * In case the KorKitchenOrder found by the `where` argument doesn't exist, create a new KorKitchenOrder with this data.
     */
    create: XOR<KorKitchenOrderCreateInput, KorKitchenOrderUncheckedCreateInput>
    /**
     * In case the KorKitchenOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KorKitchenOrderUpdateInput, KorKitchenOrderUncheckedUpdateInput>
  }


  /**
   * KorKitchenOrder delete
   */
  export type KorKitchenOrderDeleteArgs = {
    /**
     * Select specific fields to fetch from the KorKitchenOrder
     */
    select?: KorKitchenOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KorKitchenOrderInclude | null
    /**
     * Filter which KorKitchenOrder to delete.
     */
    where: KorKitchenOrderWhereUniqueInput
  }


  /**
   * KorKitchenOrder deleteMany
   */
  export type KorKitchenOrderDeleteManyArgs = {
    /**
     * Filter which KorKitchenOrders to delete
     */
    where?: KorKitchenOrderWhereInput
  }


  /**
   * KorKitchenOrder.items
   */
  export type KorKitchenOrder$itemsArgs = {
    /**
     * Select specific fields to fetch from the KorKitchenOrderItem
     */
    select?: KorKitchenOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KorKitchenOrderItemInclude | null
    where?: KorKitchenOrderItemWhereInput
    orderBy?: Enumerable<KorKitchenOrderItemOrderByWithRelationInput>
    cursor?: KorKitchenOrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<KorKitchenOrderItemScalarFieldEnum>
  }


  /**
   * KorKitchenOrder without action
   */
  export type KorKitchenOrderArgs = {
    /**
     * Select specific fields to fetch from the KorKitchenOrder
     */
    select?: KorKitchenOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KorKitchenOrderInclude | null
  }



  /**
   * Model KorKitchenOrderItem
   */


  export type AggregateKorKitchenOrderItem = {
    _count: KorKitchenOrderItemCountAggregateOutputType | null
    _avg: KorKitchenOrderItemAvgAggregateOutputType | null
    _sum: KorKitchenOrderItemSumAggregateOutputType | null
    _min: KorKitchenOrderItemMinAggregateOutputType | null
    _max: KorKitchenOrderItemMaxAggregateOutputType | null
  }

  export type KorKitchenOrderItemAvgAggregateOutputType = {
    id: number | null
    menuId: number | null
    orderId: number | null
    quantity: number | null
    totalPrice: number | null
  }

  export type KorKitchenOrderItemSumAggregateOutputType = {
    id: number | null
    menuId: number | null
    orderId: number | null
    quantity: number | null
    totalPrice: number | null
  }

  export type KorKitchenOrderItemMinAggregateOutputType = {
    id: number | null
    menuId: number | null
    orderId: number | null
    quantity: number | null
    totalPrice: number | null
    creatAt: Date | null
    updatedAt: Date | null
  }

  export type KorKitchenOrderItemMaxAggregateOutputType = {
    id: number | null
    menuId: number | null
    orderId: number | null
    quantity: number | null
    totalPrice: number | null
    creatAt: Date | null
    updatedAt: Date | null
  }

  export type KorKitchenOrderItemCountAggregateOutputType = {
    id: number
    menuId: number
    orderId: number
    quantity: number
    totalPrice: number
    creatAt: number
    updatedAt: number
    _all: number
  }


  export type KorKitchenOrderItemAvgAggregateInputType = {
    id?: true
    menuId?: true
    orderId?: true
    quantity?: true
    totalPrice?: true
  }

  export type KorKitchenOrderItemSumAggregateInputType = {
    id?: true
    menuId?: true
    orderId?: true
    quantity?: true
    totalPrice?: true
  }

  export type KorKitchenOrderItemMinAggregateInputType = {
    id?: true
    menuId?: true
    orderId?: true
    quantity?: true
    totalPrice?: true
    creatAt?: true
    updatedAt?: true
  }

  export type KorKitchenOrderItemMaxAggregateInputType = {
    id?: true
    menuId?: true
    orderId?: true
    quantity?: true
    totalPrice?: true
    creatAt?: true
    updatedAt?: true
  }

  export type KorKitchenOrderItemCountAggregateInputType = {
    id?: true
    menuId?: true
    orderId?: true
    quantity?: true
    totalPrice?: true
    creatAt?: true
    updatedAt?: true
    _all?: true
  }

  export type KorKitchenOrderItemAggregateArgs = {
    /**
     * Filter which KorKitchenOrderItem to aggregate.
     */
    where?: KorKitchenOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KorKitchenOrderItems to fetch.
     */
    orderBy?: Enumerable<KorKitchenOrderItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KorKitchenOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KorKitchenOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KorKitchenOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KorKitchenOrderItems
    **/
    _count?: true | KorKitchenOrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KorKitchenOrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KorKitchenOrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KorKitchenOrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KorKitchenOrderItemMaxAggregateInputType
  }

  export type GetKorKitchenOrderItemAggregateType<T extends KorKitchenOrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateKorKitchenOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKorKitchenOrderItem[P]>
      : GetScalarType<T[P], AggregateKorKitchenOrderItem[P]>
  }




  export type KorKitchenOrderItemGroupByArgs = {
    where?: KorKitchenOrderItemWhereInput
    orderBy?: Enumerable<KorKitchenOrderItemOrderByWithAggregationInput>
    by: KorKitchenOrderItemScalarFieldEnum[]
    having?: KorKitchenOrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KorKitchenOrderItemCountAggregateInputType | true
    _avg?: KorKitchenOrderItemAvgAggregateInputType
    _sum?: KorKitchenOrderItemSumAggregateInputType
    _min?: KorKitchenOrderItemMinAggregateInputType
    _max?: KorKitchenOrderItemMaxAggregateInputType
  }


  export type KorKitchenOrderItemGroupByOutputType = {
    id: number
    menuId: number
    orderId: number | null
    quantity: number
    totalPrice: number
    creatAt: Date
    updatedAt: Date
    _count: KorKitchenOrderItemCountAggregateOutputType | null
    _avg: KorKitchenOrderItemAvgAggregateOutputType | null
    _sum: KorKitchenOrderItemSumAggregateOutputType | null
    _min: KorKitchenOrderItemMinAggregateOutputType | null
    _max: KorKitchenOrderItemMaxAggregateOutputType | null
  }

  type GetKorKitchenOrderItemGroupByPayload<T extends KorKitchenOrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<KorKitchenOrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KorKitchenOrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KorKitchenOrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], KorKitchenOrderItemGroupByOutputType[P]>
        }
      >
    >


  export type KorKitchenOrderItemSelect = {
    id?: boolean
    menu?: boolean | KorKitchenMenuArgs
    menuId?: boolean
    order?: boolean | KorKitchenOrderArgs
    orderId?: boolean
    quantity?: boolean
    totalPrice?: boolean
    creatAt?: boolean
    updatedAt?: boolean
  }


  export type KorKitchenOrderItemInclude = {
    menu?: boolean | KorKitchenMenuArgs
    order?: boolean | KorKitchenOrderArgs
  }

  export type KorKitchenOrderItemGetPayload<S extends boolean | null | undefined | KorKitchenOrderItemArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? KorKitchenOrderItem :
    S extends undefined ? never :
    S extends { include: any } & (KorKitchenOrderItemArgs | KorKitchenOrderItemFindManyArgs)
    ? KorKitchenOrderItem  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'menu' ? KorKitchenMenuGetPayload<S['include'][P]> :
        P extends 'order' ? KorKitchenOrderGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (KorKitchenOrderItemArgs | KorKitchenOrderItemFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'menu' ? KorKitchenMenuGetPayload<S['select'][P]> :
        P extends 'order' ? KorKitchenOrderGetPayload<S['select'][P]> | null :  P extends keyof KorKitchenOrderItem ? KorKitchenOrderItem[P] : never
  } 
      : KorKitchenOrderItem


  type KorKitchenOrderItemCountArgs = 
    Omit<KorKitchenOrderItemFindManyArgs, 'select' | 'include'> & {
      select?: KorKitchenOrderItemCountAggregateInputType | true
    }

  export interface KorKitchenOrderItemDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one KorKitchenOrderItem that matches the filter.
     * @param {KorKitchenOrderItemFindUniqueArgs} args - Arguments to find a KorKitchenOrderItem
     * @example
     * // Get one KorKitchenOrderItem
     * const korKitchenOrderItem = await prisma.korKitchenOrderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends KorKitchenOrderItemFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, KorKitchenOrderItemFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'KorKitchenOrderItem'> extends True ? Prisma__KorKitchenOrderItemClient<KorKitchenOrderItemGetPayload<T>> : Prisma__KorKitchenOrderItemClient<KorKitchenOrderItemGetPayload<T> | null, null>

    /**
     * Find one KorKitchenOrderItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {KorKitchenOrderItemFindUniqueOrThrowArgs} args - Arguments to find a KorKitchenOrderItem
     * @example
     * // Get one KorKitchenOrderItem
     * const korKitchenOrderItem = await prisma.korKitchenOrderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends KorKitchenOrderItemFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, KorKitchenOrderItemFindUniqueOrThrowArgs>
    ): Prisma__KorKitchenOrderItemClient<KorKitchenOrderItemGetPayload<T>>

    /**
     * Find the first KorKitchenOrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KorKitchenOrderItemFindFirstArgs} args - Arguments to find a KorKitchenOrderItem
     * @example
     * // Get one KorKitchenOrderItem
     * const korKitchenOrderItem = await prisma.korKitchenOrderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends KorKitchenOrderItemFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, KorKitchenOrderItemFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'KorKitchenOrderItem'> extends True ? Prisma__KorKitchenOrderItemClient<KorKitchenOrderItemGetPayload<T>> : Prisma__KorKitchenOrderItemClient<KorKitchenOrderItemGetPayload<T> | null, null>

    /**
     * Find the first KorKitchenOrderItem that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KorKitchenOrderItemFindFirstOrThrowArgs} args - Arguments to find a KorKitchenOrderItem
     * @example
     * // Get one KorKitchenOrderItem
     * const korKitchenOrderItem = await prisma.korKitchenOrderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends KorKitchenOrderItemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, KorKitchenOrderItemFindFirstOrThrowArgs>
    ): Prisma__KorKitchenOrderItemClient<KorKitchenOrderItemGetPayload<T>>

    /**
     * Find zero or more KorKitchenOrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KorKitchenOrderItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KorKitchenOrderItems
     * const korKitchenOrderItems = await prisma.korKitchenOrderItem.findMany()
     * 
     * // Get first 10 KorKitchenOrderItems
     * const korKitchenOrderItems = await prisma.korKitchenOrderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const korKitchenOrderItemWithIdOnly = await prisma.korKitchenOrderItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends KorKitchenOrderItemFindManyArgs>(
      args?: SelectSubset<T, KorKitchenOrderItemFindManyArgs>
    ): Prisma.PrismaPromise<Array<KorKitchenOrderItemGetPayload<T>>>

    /**
     * Create a KorKitchenOrderItem.
     * @param {KorKitchenOrderItemCreateArgs} args - Arguments to create a KorKitchenOrderItem.
     * @example
     * // Create one KorKitchenOrderItem
     * const KorKitchenOrderItem = await prisma.korKitchenOrderItem.create({
     *   data: {
     *     // ... data to create a KorKitchenOrderItem
     *   }
     * })
     * 
    **/
    create<T extends KorKitchenOrderItemCreateArgs>(
      args: SelectSubset<T, KorKitchenOrderItemCreateArgs>
    ): Prisma__KorKitchenOrderItemClient<KorKitchenOrderItemGetPayload<T>>

    /**
     * Create many KorKitchenOrderItems.
     *     @param {KorKitchenOrderItemCreateManyArgs} args - Arguments to create many KorKitchenOrderItems.
     *     @example
     *     // Create many KorKitchenOrderItems
     *     const korKitchenOrderItem = await prisma.korKitchenOrderItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends KorKitchenOrderItemCreateManyArgs>(
      args?: SelectSubset<T, KorKitchenOrderItemCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a KorKitchenOrderItem.
     * @param {KorKitchenOrderItemDeleteArgs} args - Arguments to delete one KorKitchenOrderItem.
     * @example
     * // Delete one KorKitchenOrderItem
     * const KorKitchenOrderItem = await prisma.korKitchenOrderItem.delete({
     *   where: {
     *     // ... filter to delete one KorKitchenOrderItem
     *   }
     * })
     * 
    **/
    delete<T extends KorKitchenOrderItemDeleteArgs>(
      args: SelectSubset<T, KorKitchenOrderItemDeleteArgs>
    ): Prisma__KorKitchenOrderItemClient<KorKitchenOrderItemGetPayload<T>>

    /**
     * Update one KorKitchenOrderItem.
     * @param {KorKitchenOrderItemUpdateArgs} args - Arguments to update one KorKitchenOrderItem.
     * @example
     * // Update one KorKitchenOrderItem
     * const korKitchenOrderItem = await prisma.korKitchenOrderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends KorKitchenOrderItemUpdateArgs>(
      args: SelectSubset<T, KorKitchenOrderItemUpdateArgs>
    ): Prisma__KorKitchenOrderItemClient<KorKitchenOrderItemGetPayload<T>>

    /**
     * Delete zero or more KorKitchenOrderItems.
     * @param {KorKitchenOrderItemDeleteManyArgs} args - Arguments to filter KorKitchenOrderItems to delete.
     * @example
     * // Delete a few KorKitchenOrderItems
     * const { count } = await prisma.korKitchenOrderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends KorKitchenOrderItemDeleteManyArgs>(
      args?: SelectSubset<T, KorKitchenOrderItemDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KorKitchenOrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KorKitchenOrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KorKitchenOrderItems
     * const korKitchenOrderItem = await prisma.korKitchenOrderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends KorKitchenOrderItemUpdateManyArgs>(
      args: SelectSubset<T, KorKitchenOrderItemUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KorKitchenOrderItem.
     * @param {KorKitchenOrderItemUpsertArgs} args - Arguments to update or create a KorKitchenOrderItem.
     * @example
     * // Update or create a KorKitchenOrderItem
     * const korKitchenOrderItem = await prisma.korKitchenOrderItem.upsert({
     *   create: {
     *     // ... data to create a KorKitchenOrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KorKitchenOrderItem we want to update
     *   }
     * })
    **/
    upsert<T extends KorKitchenOrderItemUpsertArgs>(
      args: SelectSubset<T, KorKitchenOrderItemUpsertArgs>
    ): Prisma__KorKitchenOrderItemClient<KorKitchenOrderItemGetPayload<T>>

    /**
     * Count the number of KorKitchenOrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KorKitchenOrderItemCountArgs} args - Arguments to filter KorKitchenOrderItems to count.
     * @example
     * // Count the number of KorKitchenOrderItems
     * const count = await prisma.korKitchenOrderItem.count({
     *   where: {
     *     // ... the filter for the KorKitchenOrderItems we want to count
     *   }
     * })
    **/
    count<T extends KorKitchenOrderItemCountArgs>(
      args?: Subset<T, KorKitchenOrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KorKitchenOrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KorKitchenOrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KorKitchenOrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KorKitchenOrderItemAggregateArgs>(args: Subset<T, KorKitchenOrderItemAggregateArgs>): Prisma.PrismaPromise<GetKorKitchenOrderItemAggregateType<T>>

    /**
     * Group by KorKitchenOrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KorKitchenOrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KorKitchenOrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KorKitchenOrderItemGroupByArgs['orderBy'] }
        : { orderBy?: KorKitchenOrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KorKitchenOrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKorKitchenOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for KorKitchenOrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__KorKitchenOrderItemClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    menu<T extends KorKitchenMenuArgs= {}>(args?: Subset<T, KorKitchenMenuArgs>): Prisma__KorKitchenMenuClient<KorKitchenMenuGetPayload<T> | Null>;

    order<T extends KorKitchenOrderArgs= {}>(args?: Subset<T, KorKitchenOrderArgs>): Prisma__KorKitchenOrderClient<KorKitchenOrderGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * KorKitchenOrderItem base type for findUnique actions
   */
  export type KorKitchenOrderItemFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the KorKitchenOrderItem
     */
    select?: KorKitchenOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KorKitchenOrderItemInclude | null
    /**
     * Filter, which KorKitchenOrderItem to fetch.
     */
    where: KorKitchenOrderItemWhereUniqueInput
  }

  /**
   * KorKitchenOrderItem findUnique
   */
  export interface KorKitchenOrderItemFindUniqueArgs extends KorKitchenOrderItemFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * KorKitchenOrderItem findUniqueOrThrow
   */
  export type KorKitchenOrderItemFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the KorKitchenOrderItem
     */
    select?: KorKitchenOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KorKitchenOrderItemInclude | null
    /**
     * Filter, which KorKitchenOrderItem to fetch.
     */
    where: KorKitchenOrderItemWhereUniqueInput
  }


  /**
   * KorKitchenOrderItem base type for findFirst actions
   */
  export type KorKitchenOrderItemFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the KorKitchenOrderItem
     */
    select?: KorKitchenOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KorKitchenOrderItemInclude | null
    /**
     * Filter, which KorKitchenOrderItem to fetch.
     */
    where?: KorKitchenOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KorKitchenOrderItems to fetch.
     */
    orderBy?: Enumerable<KorKitchenOrderItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KorKitchenOrderItems.
     */
    cursor?: KorKitchenOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KorKitchenOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KorKitchenOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KorKitchenOrderItems.
     */
    distinct?: Enumerable<KorKitchenOrderItemScalarFieldEnum>
  }

  /**
   * KorKitchenOrderItem findFirst
   */
  export interface KorKitchenOrderItemFindFirstArgs extends KorKitchenOrderItemFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * KorKitchenOrderItem findFirstOrThrow
   */
  export type KorKitchenOrderItemFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the KorKitchenOrderItem
     */
    select?: KorKitchenOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KorKitchenOrderItemInclude | null
    /**
     * Filter, which KorKitchenOrderItem to fetch.
     */
    where?: KorKitchenOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KorKitchenOrderItems to fetch.
     */
    orderBy?: Enumerable<KorKitchenOrderItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KorKitchenOrderItems.
     */
    cursor?: KorKitchenOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KorKitchenOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KorKitchenOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KorKitchenOrderItems.
     */
    distinct?: Enumerable<KorKitchenOrderItemScalarFieldEnum>
  }


  /**
   * KorKitchenOrderItem findMany
   */
  export type KorKitchenOrderItemFindManyArgs = {
    /**
     * Select specific fields to fetch from the KorKitchenOrderItem
     */
    select?: KorKitchenOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KorKitchenOrderItemInclude | null
    /**
     * Filter, which KorKitchenOrderItems to fetch.
     */
    where?: KorKitchenOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KorKitchenOrderItems to fetch.
     */
    orderBy?: Enumerable<KorKitchenOrderItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KorKitchenOrderItems.
     */
    cursor?: KorKitchenOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KorKitchenOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KorKitchenOrderItems.
     */
    skip?: number
    distinct?: Enumerable<KorKitchenOrderItemScalarFieldEnum>
  }


  /**
   * KorKitchenOrderItem create
   */
  export type KorKitchenOrderItemCreateArgs = {
    /**
     * Select specific fields to fetch from the KorKitchenOrderItem
     */
    select?: KorKitchenOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KorKitchenOrderItemInclude | null
    /**
     * The data needed to create a KorKitchenOrderItem.
     */
    data: XOR<KorKitchenOrderItemCreateInput, KorKitchenOrderItemUncheckedCreateInput>
  }


  /**
   * KorKitchenOrderItem createMany
   */
  export type KorKitchenOrderItemCreateManyArgs = {
    /**
     * The data used to create many KorKitchenOrderItems.
     */
    data: Enumerable<KorKitchenOrderItemCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * KorKitchenOrderItem update
   */
  export type KorKitchenOrderItemUpdateArgs = {
    /**
     * Select specific fields to fetch from the KorKitchenOrderItem
     */
    select?: KorKitchenOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KorKitchenOrderItemInclude | null
    /**
     * The data needed to update a KorKitchenOrderItem.
     */
    data: XOR<KorKitchenOrderItemUpdateInput, KorKitchenOrderItemUncheckedUpdateInput>
    /**
     * Choose, which KorKitchenOrderItem to update.
     */
    where: KorKitchenOrderItemWhereUniqueInput
  }


  /**
   * KorKitchenOrderItem updateMany
   */
  export type KorKitchenOrderItemUpdateManyArgs = {
    /**
     * The data used to update KorKitchenOrderItems.
     */
    data: XOR<KorKitchenOrderItemUpdateManyMutationInput, KorKitchenOrderItemUncheckedUpdateManyInput>
    /**
     * Filter which KorKitchenOrderItems to update
     */
    where?: KorKitchenOrderItemWhereInput
  }


  /**
   * KorKitchenOrderItem upsert
   */
  export type KorKitchenOrderItemUpsertArgs = {
    /**
     * Select specific fields to fetch from the KorKitchenOrderItem
     */
    select?: KorKitchenOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KorKitchenOrderItemInclude | null
    /**
     * The filter to search for the KorKitchenOrderItem to update in case it exists.
     */
    where: KorKitchenOrderItemWhereUniqueInput
    /**
     * In case the KorKitchenOrderItem found by the `where` argument doesn't exist, create a new KorKitchenOrderItem with this data.
     */
    create: XOR<KorKitchenOrderItemCreateInput, KorKitchenOrderItemUncheckedCreateInput>
    /**
     * In case the KorKitchenOrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KorKitchenOrderItemUpdateInput, KorKitchenOrderItemUncheckedUpdateInput>
  }


  /**
   * KorKitchenOrderItem delete
   */
  export type KorKitchenOrderItemDeleteArgs = {
    /**
     * Select specific fields to fetch from the KorKitchenOrderItem
     */
    select?: KorKitchenOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KorKitchenOrderItemInclude | null
    /**
     * Filter which KorKitchenOrderItem to delete.
     */
    where: KorKitchenOrderItemWhereUniqueInput
  }


  /**
   * KorKitchenOrderItem deleteMany
   */
  export type KorKitchenOrderItemDeleteManyArgs = {
    /**
     * Filter which KorKitchenOrderItems to delete
     */
    where?: KorKitchenOrderItemWhereInput
  }


  /**
   * KorKitchenOrderItem without action
   */
  export type KorKitchenOrderItemArgs = {
    /**
     * Select specific fields to fetch from the KorKitchenOrderItem
     */
    select?: KorKitchenOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KorKitchenOrderItemInclude | null
  }



  /**
   * Model TodoList
   */


  export type AggregateTodoList = {
    _count: TodoListCountAggregateOutputType | null
    _avg: TodoListAvgAggregateOutputType | null
    _sum: TodoListSumAggregateOutputType | null
    _min: TodoListMinAggregateOutputType | null
    _max: TodoListMaxAggregateOutputType | null
  }

  export type TodoListAvgAggregateOutputType = {
    id: number | null
  }

  export type TodoListSumAggregateOutputType = {
    id: number | null
  }

  export type TodoListMinAggregateOutputType = {
    id: number | null
    task: string | null
    status: string | null
    note: string | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type TodoListMaxAggregateOutputType = {
    id: number | null
    task: string | null
    status: string | null
    note: string | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type TodoListCountAggregateOutputType = {
    id: number
    task: number
    status: number
    note: number
    createAt: number
    updateAt: number
    _all: number
  }


  export type TodoListAvgAggregateInputType = {
    id?: true
  }

  export type TodoListSumAggregateInputType = {
    id?: true
  }

  export type TodoListMinAggregateInputType = {
    id?: true
    task?: true
    status?: true
    note?: true
    createAt?: true
    updateAt?: true
  }

  export type TodoListMaxAggregateInputType = {
    id?: true
    task?: true
    status?: true
    note?: true
    createAt?: true
    updateAt?: true
  }

  export type TodoListCountAggregateInputType = {
    id?: true
    task?: true
    status?: true
    note?: true
    createAt?: true
    updateAt?: true
    _all?: true
  }

  export type TodoListAggregateArgs = {
    /**
     * Filter which TodoList to aggregate.
     */
    where?: TodoListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TodoLists to fetch.
     */
    orderBy?: Enumerable<TodoListOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TodoListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TodoLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TodoLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TodoLists
    **/
    _count?: true | TodoListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TodoListAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TodoListSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TodoListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TodoListMaxAggregateInputType
  }

  export type GetTodoListAggregateType<T extends TodoListAggregateArgs> = {
        [P in keyof T & keyof AggregateTodoList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTodoList[P]>
      : GetScalarType<T[P], AggregateTodoList[P]>
  }




  export type TodoListGroupByArgs = {
    where?: TodoListWhereInput
    orderBy?: Enumerable<TodoListOrderByWithAggregationInput>
    by: TodoListScalarFieldEnum[]
    having?: TodoListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TodoListCountAggregateInputType | true
    _avg?: TodoListAvgAggregateInputType
    _sum?: TodoListSumAggregateInputType
    _min?: TodoListMinAggregateInputType
    _max?: TodoListMaxAggregateInputType
  }


  export type TodoListGroupByOutputType = {
    id: number
    task: string
    status: string
    note: string | null
    createAt: Date
    updateAt: Date
    _count: TodoListCountAggregateOutputType | null
    _avg: TodoListAvgAggregateOutputType | null
    _sum: TodoListSumAggregateOutputType | null
    _min: TodoListMinAggregateOutputType | null
    _max: TodoListMaxAggregateOutputType | null
  }

  type GetTodoListGroupByPayload<T extends TodoListGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TodoListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TodoListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TodoListGroupByOutputType[P]>
            : GetScalarType<T[P], TodoListGroupByOutputType[P]>
        }
      >
    >


  export type TodoListSelect = {
    id?: boolean
    task?: boolean
    status?: boolean
    note?: boolean
    createAt?: boolean
    updateAt?: boolean
  }


  export type TodoListGetPayload<S extends boolean | null | undefined | TodoListArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TodoList :
    S extends undefined ? never :
    S extends { include: any } & (TodoListArgs | TodoListFindManyArgs)
    ? TodoList 
    : S extends { select: any } & (TodoListArgs | TodoListFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TodoList ? TodoList[P] : never
  } 
      : TodoList


  type TodoListCountArgs = 
    Omit<TodoListFindManyArgs, 'select' | 'include'> & {
      select?: TodoListCountAggregateInputType | true
    }

  export interface TodoListDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TodoList that matches the filter.
     * @param {TodoListFindUniqueArgs} args - Arguments to find a TodoList
     * @example
     * // Get one TodoList
     * const todoList = await prisma.todoList.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TodoListFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TodoListFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TodoList'> extends True ? Prisma__TodoListClient<TodoListGetPayload<T>> : Prisma__TodoListClient<TodoListGetPayload<T> | null, null>

    /**
     * Find one TodoList that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TodoListFindUniqueOrThrowArgs} args - Arguments to find a TodoList
     * @example
     * // Get one TodoList
     * const todoList = await prisma.todoList.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TodoListFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TodoListFindUniqueOrThrowArgs>
    ): Prisma__TodoListClient<TodoListGetPayload<T>>

    /**
     * Find the first TodoList that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoListFindFirstArgs} args - Arguments to find a TodoList
     * @example
     * // Get one TodoList
     * const todoList = await prisma.todoList.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TodoListFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TodoListFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TodoList'> extends True ? Prisma__TodoListClient<TodoListGetPayload<T>> : Prisma__TodoListClient<TodoListGetPayload<T> | null, null>

    /**
     * Find the first TodoList that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoListFindFirstOrThrowArgs} args - Arguments to find a TodoList
     * @example
     * // Get one TodoList
     * const todoList = await prisma.todoList.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TodoListFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TodoListFindFirstOrThrowArgs>
    ): Prisma__TodoListClient<TodoListGetPayload<T>>

    /**
     * Find zero or more TodoLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoListFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TodoLists
     * const todoLists = await prisma.todoList.findMany()
     * 
     * // Get first 10 TodoLists
     * const todoLists = await prisma.todoList.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const todoListWithIdOnly = await prisma.todoList.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TodoListFindManyArgs>(
      args?: SelectSubset<T, TodoListFindManyArgs>
    ): Prisma.PrismaPromise<Array<TodoListGetPayload<T>>>

    /**
     * Create a TodoList.
     * @param {TodoListCreateArgs} args - Arguments to create a TodoList.
     * @example
     * // Create one TodoList
     * const TodoList = await prisma.todoList.create({
     *   data: {
     *     // ... data to create a TodoList
     *   }
     * })
     * 
    **/
    create<T extends TodoListCreateArgs>(
      args: SelectSubset<T, TodoListCreateArgs>
    ): Prisma__TodoListClient<TodoListGetPayload<T>>

    /**
     * Create many TodoLists.
     *     @param {TodoListCreateManyArgs} args - Arguments to create many TodoLists.
     *     @example
     *     // Create many TodoLists
     *     const todoList = await prisma.todoList.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TodoListCreateManyArgs>(
      args?: SelectSubset<T, TodoListCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TodoList.
     * @param {TodoListDeleteArgs} args - Arguments to delete one TodoList.
     * @example
     * // Delete one TodoList
     * const TodoList = await prisma.todoList.delete({
     *   where: {
     *     // ... filter to delete one TodoList
     *   }
     * })
     * 
    **/
    delete<T extends TodoListDeleteArgs>(
      args: SelectSubset<T, TodoListDeleteArgs>
    ): Prisma__TodoListClient<TodoListGetPayload<T>>

    /**
     * Update one TodoList.
     * @param {TodoListUpdateArgs} args - Arguments to update one TodoList.
     * @example
     * // Update one TodoList
     * const todoList = await prisma.todoList.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TodoListUpdateArgs>(
      args: SelectSubset<T, TodoListUpdateArgs>
    ): Prisma__TodoListClient<TodoListGetPayload<T>>

    /**
     * Delete zero or more TodoLists.
     * @param {TodoListDeleteManyArgs} args - Arguments to filter TodoLists to delete.
     * @example
     * // Delete a few TodoLists
     * const { count } = await prisma.todoList.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TodoListDeleteManyArgs>(
      args?: SelectSubset<T, TodoListDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TodoLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TodoLists
     * const todoList = await prisma.todoList.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TodoListUpdateManyArgs>(
      args: SelectSubset<T, TodoListUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TodoList.
     * @param {TodoListUpsertArgs} args - Arguments to update or create a TodoList.
     * @example
     * // Update or create a TodoList
     * const todoList = await prisma.todoList.upsert({
     *   create: {
     *     // ... data to create a TodoList
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TodoList we want to update
     *   }
     * })
    **/
    upsert<T extends TodoListUpsertArgs>(
      args: SelectSubset<T, TodoListUpsertArgs>
    ): Prisma__TodoListClient<TodoListGetPayload<T>>

    /**
     * Count the number of TodoLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoListCountArgs} args - Arguments to filter TodoLists to count.
     * @example
     * // Count the number of TodoLists
     * const count = await prisma.todoList.count({
     *   where: {
     *     // ... the filter for the TodoLists we want to count
     *   }
     * })
    **/
    count<T extends TodoListCountArgs>(
      args?: Subset<T, TodoListCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TodoListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TodoList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TodoListAggregateArgs>(args: Subset<T, TodoListAggregateArgs>): Prisma.PrismaPromise<GetTodoListAggregateType<T>>

    /**
     * Group by TodoList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TodoListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TodoListGroupByArgs['orderBy'] }
        : { orderBy?: TodoListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TodoListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTodoListGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TodoList.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TodoListClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TodoList base type for findUnique actions
   */
  export type TodoListFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
    /**
     * Filter, which TodoList to fetch.
     */
    where: TodoListWhereUniqueInput
  }

  /**
   * TodoList findUnique
   */
  export interface TodoListFindUniqueArgs extends TodoListFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TodoList findUniqueOrThrow
   */
  export type TodoListFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
    /**
     * Filter, which TodoList to fetch.
     */
    where: TodoListWhereUniqueInput
  }


  /**
   * TodoList base type for findFirst actions
   */
  export type TodoListFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
    /**
     * Filter, which TodoList to fetch.
     */
    where?: TodoListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TodoLists to fetch.
     */
    orderBy?: Enumerable<TodoListOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TodoLists.
     */
    cursor?: TodoListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TodoLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TodoLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TodoLists.
     */
    distinct?: Enumerable<TodoListScalarFieldEnum>
  }

  /**
   * TodoList findFirst
   */
  export interface TodoListFindFirstArgs extends TodoListFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TodoList findFirstOrThrow
   */
  export type TodoListFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
    /**
     * Filter, which TodoList to fetch.
     */
    where?: TodoListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TodoLists to fetch.
     */
    orderBy?: Enumerable<TodoListOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TodoLists.
     */
    cursor?: TodoListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TodoLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TodoLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TodoLists.
     */
    distinct?: Enumerable<TodoListScalarFieldEnum>
  }


  /**
   * TodoList findMany
   */
  export type TodoListFindManyArgs = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
    /**
     * Filter, which TodoLists to fetch.
     */
    where?: TodoListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TodoLists to fetch.
     */
    orderBy?: Enumerable<TodoListOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TodoLists.
     */
    cursor?: TodoListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TodoLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TodoLists.
     */
    skip?: number
    distinct?: Enumerable<TodoListScalarFieldEnum>
  }


  /**
   * TodoList create
   */
  export type TodoListCreateArgs = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
    /**
     * The data needed to create a TodoList.
     */
    data: XOR<TodoListCreateInput, TodoListUncheckedCreateInput>
  }


  /**
   * TodoList createMany
   */
  export type TodoListCreateManyArgs = {
    /**
     * The data used to create many TodoLists.
     */
    data: Enumerable<TodoListCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TodoList update
   */
  export type TodoListUpdateArgs = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
    /**
     * The data needed to update a TodoList.
     */
    data: XOR<TodoListUpdateInput, TodoListUncheckedUpdateInput>
    /**
     * Choose, which TodoList to update.
     */
    where: TodoListWhereUniqueInput
  }


  /**
   * TodoList updateMany
   */
  export type TodoListUpdateManyArgs = {
    /**
     * The data used to update TodoLists.
     */
    data: XOR<TodoListUpdateManyMutationInput, TodoListUncheckedUpdateManyInput>
    /**
     * Filter which TodoLists to update
     */
    where?: TodoListWhereInput
  }


  /**
   * TodoList upsert
   */
  export type TodoListUpsertArgs = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
    /**
     * The filter to search for the TodoList to update in case it exists.
     */
    where: TodoListWhereUniqueInput
    /**
     * In case the TodoList found by the `where` argument doesn't exist, create a new TodoList with this data.
     */
    create: XOR<TodoListCreateInput, TodoListUncheckedCreateInput>
    /**
     * In case the TodoList was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TodoListUpdateInput, TodoListUncheckedUpdateInput>
  }


  /**
   * TodoList delete
   */
  export type TodoListDeleteArgs = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
    /**
     * Filter which TodoList to delete.
     */
    where: TodoListWhereUniqueInput
  }


  /**
   * TodoList deleteMany
   */
  export type TodoListDeleteManyArgs = {
    /**
     * Filter which TodoLists to delete
     */
    where?: TodoListWhereInput
  }


  /**
   * TodoList without action
   */
  export type TodoListArgs = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
  }



  /**
   * Model TestModel
   */


  export type AggregateTestModel = {
    _count: TestModelCountAggregateOutputType | null
    _avg: TestModelAvgAggregateOutputType | null
    _sum: TestModelSumAggregateOutputType | null
    _min: TestModelMinAggregateOutputType | null
    _max: TestModelMaxAggregateOutputType | null
  }

  export type TestModelAvgAggregateOutputType = {
    id: number | null
  }

  export type TestModelSumAggregateOutputType = {
    id: number | null
  }

  export type TestModelMinAggregateOutputType = {
    id: number | null
    firstname: string | null
    Surname: string | null
  }

  export type TestModelMaxAggregateOutputType = {
    id: number | null
    firstname: string | null
    Surname: string | null
  }

  export type TestModelCountAggregateOutputType = {
    id: number
    firstname: number
    Surname: number
    _all: number
  }


  export type TestModelAvgAggregateInputType = {
    id?: true
  }

  export type TestModelSumAggregateInputType = {
    id?: true
  }

  export type TestModelMinAggregateInputType = {
    id?: true
    firstname?: true
    Surname?: true
  }

  export type TestModelMaxAggregateInputType = {
    id?: true
    firstname?: true
    Surname?: true
  }

  export type TestModelCountAggregateInputType = {
    id?: true
    firstname?: true
    Surname?: true
    _all?: true
  }

  export type TestModelAggregateArgs = {
    /**
     * Filter which TestModel to aggregate.
     */
    where?: TestModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestModels to fetch.
     */
    orderBy?: Enumerable<TestModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TestModels
    **/
    _count?: true | TestModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestModelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestModelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestModelMaxAggregateInputType
  }

  export type GetTestModelAggregateType<T extends TestModelAggregateArgs> = {
        [P in keyof T & keyof AggregateTestModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestModel[P]>
      : GetScalarType<T[P], AggregateTestModel[P]>
  }




  export type TestModelGroupByArgs = {
    where?: TestModelWhereInput
    orderBy?: Enumerable<TestModelOrderByWithAggregationInput>
    by: TestModelScalarFieldEnum[]
    having?: TestModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestModelCountAggregateInputType | true
    _avg?: TestModelAvgAggregateInputType
    _sum?: TestModelSumAggregateInputType
    _min?: TestModelMinAggregateInputType
    _max?: TestModelMaxAggregateInputType
  }


  export type TestModelGroupByOutputType = {
    id: number
    firstname: string
    Surname: string
    _count: TestModelCountAggregateOutputType | null
    _avg: TestModelAvgAggregateOutputType | null
    _sum: TestModelSumAggregateOutputType | null
    _min: TestModelMinAggregateOutputType | null
    _max: TestModelMaxAggregateOutputType | null
  }

  type GetTestModelGroupByPayload<T extends TestModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TestModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestModelGroupByOutputType[P]>
            : GetScalarType<T[P], TestModelGroupByOutputType[P]>
        }
      >
    >


  export type TestModelSelect = {
    id?: boolean
    firstname?: boolean
    Surname?: boolean
  }


  export type TestModelGetPayload<S extends boolean | null | undefined | TestModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TestModel :
    S extends undefined ? never :
    S extends { include: any } & (TestModelArgs | TestModelFindManyArgs)
    ? TestModel 
    : S extends { select: any } & (TestModelArgs | TestModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TestModel ? TestModel[P] : never
  } 
      : TestModel


  type TestModelCountArgs = 
    Omit<TestModelFindManyArgs, 'select' | 'include'> & {
      select?: TestModelCountAggregateInputType | true
    }

  export interface TestModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TestModel that matches the filter.
     * @param {TestModelFindUniqueArgs} args - Arguments to find a TestModel
     * @example
     * // Get one TestModel
     * const testModel = await prisma.testModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TestModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TestModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TestModel'> extends True ? Prisma__TestModelClient<TestModelGetPayload<T>> : Prisma__TestModelClient<TestModelGetPayload<T> | null, null>

    /**
     * Find one TestModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TestModelFindUniqueOrThrowArgs} args - Arguments to find a TestModel
     * @example
     * // Get one TestModel
     * const testModel = await prisma.testModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TestModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TestModelFindUniqueOrThrowArgs>
    ): Prisma__TestModelClient<TestModelGetPayload<T>>

    /**
     * Find the first TestModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestModelFindFirstArgs} args - Arguments to find a TestModel
     * @example
     * // Get one TestModel
     * const testModel = await prisma.testModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TestModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TestModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TestModel'> extends True ? Prisma__TestModelClient<TestModelGetPayload<T>> : Prisma__TestModelClient<TestModelGetPayload<T> | null, null>

    /**
     * Find the first TestModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestModelFindFirstOrThrowArgs} args - Arguments to find a TestModel
     * @example
     * // Get one TestModel
     * const testModel = await prisma.testModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TestModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TestModelFindFirstOrThrowArgs>
    ): Prisma__TestModelClient<TestModelGetPayload<T>>

    /**
     * Find zero or more TestModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TestModels
     * const testModels = await prisma.testModel.findMany()
     * 
     * // Get first 10 TestModels
     * const testModels = await prisma.testModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testModelWithIdOnly = await prisma.testModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TestModelFindManyArgs>(
      args?: SelectSubset<T, TestModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<TestModelGetPayload<T>>>

    /**
     * Create a TestModel.
     * @param {TestModelCreateArgs} args - Arguments to create a TestModel.
     * @example
     * // Create one TestModel
     * const TestModel = await prisma.testModel.create({
     *   data: {
     *     // ... data to create a TestModel
     *   }
     * })
     * 
    **/
    create<T extends TestModelCreateArgs>(
      args: SelectSubset<T, TestModelCreateArgs>
    ): Prisma__TestModelClient<TestModelGetPayload<T>>

    /**
     * Create many TestModels.
     *     @param {TestModelCreateManyArgs} args - Arguments to create many TestModels.
     *     @example
     *     // Create many TestModels
     *     const testModel = await prisma.testModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TestModelCreateManyArgs>(
      args?: SelectSubset<T, TestModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TestModel.
     * @param {TestModelDeleteArgs} args - Arguments to delete one TestModel.
     * @example
     * // Delete one TestModel
     * const TestModel = await prisma.testModel.delete({
     *   where: {
     *     // ... filter to delete one TestModel
     *   }
     * })
     * 
    **/
    delete<T extends TestModelDeleteArgs>(
      args: SelectSubset<T, TestModelDeleteArgs>
    ): Prisma__TestModelClient<TestModelGetPayload<T>>

    /**
     * Update one TestModel.
     * @param {TestModelUpdateArgs} args - Arguments to update one TestModel.
     * @example
     * // Update one TestModel
     * const testModel = await prisma.testModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TestModelUpdateArgs>(
      args: SelectSubset<T, TestModelUpdateArgs>
    ): Prisma__TestModelClient<TestModelGetPayload<T>>

    /**
     * Delete zero or more TestModels.
     * @param {TestModelDeleteManyArgs} args - Arguments to filter TestModels to delete.
     * @example
     * // Delete a few TestModels
     * const { count } = await prisma.testModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TestModelDeleteManyArgs>(
      args?: SelectSubset<T, TestModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TestModels
     * const testModel = await prisma.testModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TestModelUpdateManyArgs>(
      args: SelectSubset<T, TestModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TestModel.
     * @param {TestModelUpsertArgs} args - Arguments to update or create a TestModel.
     * @example
     * // Update or create a TestModel
     * const testModel = await prisma.testModel.upsert({
     *   create: {
     *     // ... data to create a TestModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TestModel we want to update
     *   }
     * })
    **/
    upsert<T extends TestModelUpsertArgs>(
      args: SelectSubset<T, TestModelUpsertArgs>
    ): Prisma__TestModelClient<TestModelGetPayload<T>>

    /**
     * Count the number of TestModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestModelCountArgs} args - Arguments to filter TestModels to count.
     * @example
     * // Count the number of TestModels
     * const count = await prisma.testModel.count({
     *   where: {
     *     // ... the filter for the TestModels we want to count
     *   }
     * })
    **/
    count<T extends TestModelCountArgs>(
      args?: Subset<T, TestModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TestModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestModelAggregateArgs>(args: Subset<T, TestModelAggregateArgs>): Prisma.PrismaPromise<GetTestModelAggregateType<T>>

    /**
     * Group by TestModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestModelGroupByArgs['orderBy'] }
        : { orderBy?: TestModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TestModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TestModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TestModel base type for findUnique actions
   */
  export type TestModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TestModel
     */
    select?: TestModelSelect | null
    /**
     * Filter, which TestModel to fetch.
     */
    where: TestModelWhereUniqueInput
  }

  /**
   * TestModel findUnique
   */
  export interface TestModelFindUniqueArgs extends TestModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TestModel findUniqueOrThrow
   */
  export type TestModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TestModel
     */
    select?: TestModelSelect | null
    /**
     * Filter, which TestModel to fetch.
     */
    where: TestModelWhereUniqueInput
  }


  /**
   * TestModel base type for findFirst actions
   */
  export type TestModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TestModel
     */
    select?: TestModelSelect | null
    /**
     * Filter, which TestModel to fetch.
     */
    where?: TestModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestModels to fetch.
     */
    orderBy?: Enumerable<TestModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestModels.
     */
    cursor?: TestModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestModels.
     */
    distinct?: Enumerable<TestModelScalarFieldEnum>
  }

  /**
   * TestModel findFirst
   */
  export interface TestModelFindFirstArgs extends TestModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TestModel findFirstOrThrow
   */
  export type TestModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TestModel
     */
    select?: TestModelSelect | null
    /**
     * Filter, which TestModel to fetch.
     */
    where?: TestModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestModels to fetch.
     */
    orderBy?: Enumerable<TestModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestModels.
     */
    cursor?: TestModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestModels.
     */
    distinct?: Enumerable<TestModelScalarFieldEnum>
  }


  /**
   * TestModel findMany
   */
  export type TestModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the TestModel
     */
    select?: TestModelSelect | null
    /**
     * Filter, which TestModels to fetch.
     */
    where?: TestModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestModels to fetch.
     */
    orderBy?: Enumerable<TestModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TestModels.
     */
    cursor?: TestModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestModels.
     */
    skip?: number
    distinct?: Enumerable<TestModelScalarFieldEnum>
  }


  /**
   * TestModel create
   */
  export type TestModelCreateArgs = {
    /**
     * Select specific fields to fetch from the TestModel
     */
    select?: TestModelSelect | null
    /**
     * The data needed to create a TestModel.
     */
    data: XOR<TestModelCreateInput, TestModelUncheckedCreateInput>
  }


  /**
   * TestModel createMany
   */
  export type TestModelCreateManyArgs = {
    /**
     * The data used to create many TestModels.
     */
    data: Enumerable<TestModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TestModel update
   */
  export type TestModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the TestModel
     */
    select?: TestModelSelect | null
    /**
     * The data needed to update a TestModel.
     */
    data: XOR<TestModelUpdateInput, TestModelUncheckedUpdateInput>
    /**
     * Choose, which TestModel to update.
     */
    where: TestModelWhereUniqueInput
  }


  /**
   * TestModel updateMany
   */
  export type TestModelUpdateManyArgs = {
    /**
     * The data used to update TestModels.
     */
    data: XOR<TestModelUpdateManyMutationInput, TestModelUncheckedUpdateManyInput>
    /**
     * Filter which TestModels to update
     */
    where?: TestModelWhereInput
  }


  /**
   * TestModel upsert
   */
  export type TestModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the TestModel
     */
    select?: TestModelSelect | null
    /**
     * The filter to search for the TestModel to update in case it exists.
     */
    where: TestModelWhereUniqueInput
    /**
     * In case the TestModel found by the `where` argument doesn't exist, create a new TestModel with this data.
     */
    create: XOR<TestModelCreateInput, TestModelUncheckedCreateInput>
    /**
     * In case the TestModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestModelUpdateInput, TestModelUncheckedUpdateInput>
  }


  /**
   * TestModel delete
   */
  export type TestModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the TestModel
     */
    select?: TestModelSelect | null
    /**
     * Filter which TestModel to delete.
     */
    where: TestModelWhereUniqueInput
  }


  /**
   * TestModel deleteMany
   */
  export type TestModelDeleteManyArgs = {
    /**
     * Filter which TestModels to delete
     */
    where?: TestModelWhereInput
  }


  /**
   * TestModel without action
   */
  export type TestModelArgs = {
    /**
     * Select specific fields to fetch from the TestModel
     */
    select?: TestModelSelect | null
  }



  /**
   * Model TriviaCategory
   */


  export type AggregateTriviaCategory = {
    _count: TriviaCategoryCountAggregateOutputType | null
    _avg: TriviaCategoryAvgAggregateOutputType | null
    _sum: TriviaCategorySumAggregateOutputType | null
    _min: TriviaCategoryMinAggregateOutputType | null
    _max: TriviaCategoryMaxAggregateOutputType | null
  }

  export type TriviaCategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type TriviaCategorySumAggregateOutputType = {
    id: number | null
  }

  export type TriviaCategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type TriviaCategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type TriviaCategoryCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type TriviaCategoryAvgAggregateInputType = {
    id?: true
  }

  export type TriviaCategorySumAggregateInputType = {
    id?: true
  }

  export type TriviaCategoryMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type TriviaCategoryMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type TriviaCategoryCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type TriviaCategoryAggregateArgs = {
    /**
     * Filter which TriviaCategory to aggregate.
     */
    where?: TriviaCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TriviaCategories to fetch.
     */
    orderBy?: Enumerable<TriviaCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TriviaCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TriviaCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TriviaCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TriviaCategories
    **/
    _count?: true | TriviaCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TriviaCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TriviaCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TriviaCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TriviaCategoryMaxAggregateInputType
  }

  export type GetTriviaCategoryAggregateType<T extends TriviaCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateTriviaCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTriviaCategory[P]>
      : GetScalarType<T[P], AggregateTriviaCategory[P]>
  }




  export type TriviaCategoryGroupByArgs = {
    where?: TriviaCategoryWhereInput
    orderBy?: Enumerable<TriviaCategoryOrderByWithAggregationInput>
    by: TriviaCategoryScalarFieldEnum[]
    having?: TriviaCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TriviaCategoryCountAggregateInputType | true
    _avg?: TriviaCategoryAvgAggregateInputType
    _sum?: TriviaCategorySumAggregateInputType
    _min?: TriviaCategoryMinAggregateInputType
    _max?: TriviaCategoryMaxAggregateInputType
  }


  export type TriviaCategoryGroupByOutputType = {
    id: number
    name: string
    _count: TriviaCategoryCountAggregateOutputType | null
    _avg: TriviaCategoryAvgAggregateOutputType | null
    _sum: TriviaCategorySumAggregateOutputType | null
    _min: TriviaCategoryMinAggregateOutputType | null
    _max: TriviaCategoryMaxAggregateOutputType | null
  }

  type GetTriviaCategoryGroupByPayload<T extends TriviaCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TriviaCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TriviaCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TriviaCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], TriviaCategoryGroupByOutputType[P]>
        }
      >
    >


  export type TriviaCategorySelect = {
    id?: boolean
    name?: boolean
    questions?: boolean | TriviaCategory$questionsArgs
    rounds?: boolean | TriviaCategory$roundsArgs
    _count?: boolean | TriviaCategoryCountOutputTypeArgs
  }


  export type TriviaCategoryInclude = {
    questions?: boolean | TriviaCategory$questionsArgs
    rounds?: boolean | TriviaCategory$roundsArgs
    _count?: boolean | TriviaCategoryCountOutputTypeArgs
  }

  export type TriviaCategoryGetPayload<S extends boolean | null | undefined | TriviaCategoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TriviaCategory :
    S extends undefined ? never :
    S extends { include: any } & (TriviaCategoryArgs | TriviaCategoryFindManyArgs)
    ? TriviaCategory  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'questions' ? Array < TriviaQuestionGetPayload<S['include'][P]>>  :
        P extends 'rounds' ? Array < TriviaRoundGetPayload<S['include'][P]>>  :
        P extends '_count' ? TriviaCategoryCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TriviaCategoryArgs | TriviaCategoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'questions' ? Array < TriviaQuestionGetPayload<S['select'][P]>>  :
        P extends 'rounds' ? Array < TriviaRoundGetPayload<S['select'][P]>>  :
        P extends '_count' ? TriviaCategoryCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof TriviaCategory ? TriviaCategory[P] : never
  } 
      : TriviaCategory


  type TriviaCategoryCountArgs = 
    Omit<TriviaCategoryFindManyArgs, 'select' | 'include'> & {
      select?: TriviaCategoryCountAggregateInputType | true
    }

  export interface TriviaCategoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TriviaCategory that matches the filter.
     * @param {TriviaCategoryFindUniqueArgs} args - Arguments to find a TriviaCategory
     * @example
     * // Get one TriviaCategory
     * const triviaCategory = await prisma.triviaCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TriviaCategoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TriviaCategoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TriviaCategory'> extends True ? Prisma__TriviaCategoryClient<TriviaCategoryGetPayload<T>> : Prisma__TriviaCategoryClient<TriviaCategoryGetPayload<T> | null, null>

    /**
     * Find one TriviaCategory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TriviaCategoryFindUniqueOrThrowArgs} args - Arguments to find a TriviaCategory
     * @example
     * // Get one TriviaCategory
     * const triviaCategory = await prisma.triviaCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TriviaCategoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TriviaCategoryFindUniqueOrThrowArgs>
    ): Prisma__TriviaCategoryClient<TriviaCategoryGetPayload<T>>

    /**
     * Find the first TriviaCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriviaCategoryFindFirstArgs} args - Arguments to find a TriviaCategory
     * @example
     * // Get one TriviaCategory
     * const triviaCategory = await prisma.triviaCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TriviaCategoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TriviaCategoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TriviaCategory'> extends True ? Prisma__TriviaCategoryClient<TriviaCategoryGetPayload<T>> : Prisma__TriviaCategoryClient<TriviaCategoryGetPayload<T> | null, null>

    /**
     * Find the first TriviaCategory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriviaCategoryFindFirstOrThrowArgs} args - Arguments to find a TriviaCategory
     * @example
     * // Get one TriviaCategory
     * const triviaCategory = await prisma.triviaCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TriviaCategoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TriviaCategoryFindFirstOrThrowArgs>
    ): Prisma__TriviaCategoryClient<TriviaCategoryGetPayload<T>>

    /**
     * Find zero or more TriviaCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriviaCategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TriviaCategories
     * const triviaCategories = await prisma.triviaCategory.findMany()
     * 
     * // Get first 10 TriviaCategories
     * const triviaCategories = await prisma.triviaCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const triviaCategoryWithIdOnly = await prisma.triviaCategory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TriviaCategoryFindManyArgs>(
      args?: SelectSubset<T, TriviaCategoryFindManyArgs>
    ): Prisma.PrismaPromise<Array<TriviaCategoryGetPayload<T>>>

    /**
     * Create a TriviaCategory.
     * @param {TriviaCategoryCreateArgs} args - Arguments to create a TriviaCategory.
     * @example
     * // Create one TriviaCategory
     * const TriviaCategory = await prisma.triviaCategory.create({
     *   data: {
     *     // ... data to create a TriviaCategory
     *   }
     * })
     * 
    **/
    create<T extends TriviaCategoryCreateArgs>(
      args: SelectSubset<T, TriviaCategoryCreateArgs>
    ): Prisma__TriviaCategoryClient<TriviaCategoryGetPayload<T>>

    /**
     * Create many TriviaCategories.
     *     @param {TriviaCategoryCreateManyArgs} args - Arguments to create many TriviaCategories.
     *     @example
     *     // Create many TriviaCategories
     *     const triviaCategory = await prisma.triviaCategory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TriviaCategoryCreateManyArgs>(
      args?: SelectSubset<T, TriviaCategoryCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TriviaCategory.
     * @param {TriviaCategoryDeleteArgs} args - Arguments to delete one TriviaCategory.
     * @example
     * // Delete one TriviaCategory
     * const TriviaCategory = await prisma.triviaCategory.delete({
     *   where: {
     *     // ... filter to delete one TriviaCategory
     *   }
     * })
     * 
    **/
    delete<T extends TriviaCategoryDeleteArgs>(
      args: SelectSubset<T, TriviaCategoryDeleteArgs>
    ): Prisma__TriviaCategoryClient<TriviaCategoryGetPayload<T>>

    /**
     * Update one TriviaCategory.
     * @param {TriviaCategoryUpdateArgs} args - Arguments to update one TriviaCategory.
     * @example
     * // Update one TriviaCategory
     * const triviaCategory = await prisma.triviaCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TriviaCategoryUpdateArgs>(
      args: SelectSubset<T, TriviaCategoryUpdateArgs>
    ): Prisma__TriviaCategoryClient<TriviaCategoryGetPayload<T>>

    /**
     * Delete zero or more TriviaCategories.
     * @param {TriviaCategoryDeleteManyArgs} args - Arguments to filter TriviaCategories to delete.
     * @example
     * // Delete a few TriviaCategories
     * const { count } = await prisma.triviaCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TriviaCategoryDeleteManyArgs>(
      args?: SelectSubset<T, TriviaCategoryDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TriviaCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriviaCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TriviaCategories
     * const triviaCategory = await prisma.triviaCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TriviaCategoryUpdateManyArgs>(
      args: SelectSubset<T, TriviaCategoryUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TriviaCategory.
     * @param {TriviaCategoryUpsertArgs} args - Arguments to update or create a TriviaCategory.
     * @example
     * // Update or create a TriviaCategory
     * const triviaCategory = await prisma.triviaCategory.upsert({
     *   create: {
     *     // ... data to create a TriviaCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TriviaCategory we want to update
     *   }
     * })
    **/
    upsert<T extends TriviaCategoryUpsertArgs>(
      args: SelectSubset<T, TriviaCategoryUpsertArgs>
    ): Prisma__TriviaCategoryClient<TriviaCategoryGetPayload<T>>

    /**
     * Count the number of TriviaCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriviaCategoryCountArgs} args - Arguments to filter TriviaCategories to count.
     * @example
     * // Count the number of TriviaCategories
     * const count = await prisma.triviaCategory.count({
     *   where: {
     *     // ... the filter for the TriviaCategories we want to count
     *   }
     * })
    **/
    count<T extends TriviaCategoryCountArgs>(
      args?: Subset<T, TriviaCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TriviaCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TriviaCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriviaCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TriviaCategoryAggregateArgs>(args: Subset<T, TriviaCategoryAggregateArgs>): Prisma.PrismaPromise<GetTriviaCategoryAggregateType<T>>

    /**
     * Group by TriviaCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriviaCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TriviaCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TriviaCategoryGroupByArgs['orderBy'] }
        : { orderBy?: TriviaCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TriviaCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTriviaCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TriviaCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TriviaCategoryClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    questions<T extends TriviaCategory$questionsArgs= {}>(args?: Subset<T, TriviaCategory$questionsArgs>): Prisma.PrismaPromise<Array<TriviaQuestionGetPayload<T>>| Null>;

    rounds<T extends TriviaCategory$roundsArgs= {}>(args?: Subset<T, TriviaCategory$roundsArgs>): Prisma.PrismaPromise<Array<TriviaRoundGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TriviaCategory base type for findUnique actions
   */
  export type TriviaCategoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TriviaCategory
     */
    select?: TriviaCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaCategoryInclude | null
    /**
     * Filter, which TriviaCategory to fetch.
     */
    where: TriviaCategoryWhereUniqueInput
  }

  /**
   * TriviaCategory findUnique
   */
  export interface TriviaCategoryFindUniqueArgs extends TriviaCategoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TriviaCategory findUniqueOrThrow
   */
  export type TriviaCategoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TriviaCategory
     */
    select?: TriviaCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaCategoryInclude | null
    /**
     * Filter, which TriviaCategory to fetch.
     */
    where: TriviaCategoryWhereUniqueInput
  }


  /**
   * TriviaCategory base type for findFirst actions
   */
  export type TriviaCategoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TriviaCategory
     */
    select?: TriviaCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaCategoryInclude | null
    /**
     * Filter, which TriviaCategory to fetch.
     */
    where?: TriviaCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TriviaCategories to fetch.
     */
    orderBy?: Enumerable<TriviaCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TriviaCategories.
     */
    cursor?: TriviaCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TriviaCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TriviaCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TriviaCategories.
     */
    distinct?: Enumerable<TriviaCategoryScalarFieldEnum>
  }

  /**
   * TriviaCategory findFirst
   */
  export interface TriviaCategoryFindFirstArgs extends TriviaCategoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TriviaCategory findFirstOrThrow
   */
  export type TriviaCategoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TriviaCategory
     */
    select?: TriviaCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaCategoryInclude | null
    /**
     * Filter, which TriviaCategory to fetch.
     */
    where?: TriviaCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TriviaCategories to fetch.
     */
    orderBy?: Enumerable<TriviaCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TriviaCategories.
     */
    cursor?: TriviaCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TriviaCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TriviaCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TriviaCategories.
     */
    distinct?: Enumerable<TriviaCategoryScalarFieldEnum>
  }


  /**
   * TriviaCategory findMany
   */
  export type TriviaCategoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the TriviaCategory
     */
    select?: TriviaCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaCategoryInclude | null
    /**
     * Filter, which TriviaCategories to fetch.
     */
    where?: TriviaCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TriviaCategories to fetch.
     */
    orderBy?: Enumerable<TriviaCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TriviaCategories.
     */
    cursor?: TriviaCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TriviaCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TriviaCategories.
     */
    skip?: number
    distinct?: Enumerable<TriviaCategoryScalarFieldEnum>
  }


  /**
   * TriviaCategory create
   */
  export type TriviaCategoryCreateArgs = {
    /**
     * Select specific fields to fetch from the TriviaCategory
     */
    select?: TriviaCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaCategoryInclude | null
    /**
     * The data needed to create a TriviaCategory.
     */
    data: XOR<TriviaCategoryCreateInput, TriviaCategoryUncheckedCreateInput>
  }


  /**
   * TriviaCategory createMany
   */
  export type TriviaCategoryCreateManyArgs = {
    /**
     * The data used to create many TriviaCategories.
     */
    data: Enumerable<TriviaCategoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TriviaCategory update
   */
  export type TriviaCategoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the TriviaCategory
     */
    select?: TriviaCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaCategoryInclude | null
    /**
     * The data needed to update a TriviaCategory.
     */
    data: XOR<TriviaCategoryUpdateInput, TriviaCategoryUncheckedUpdateInput>
    /**
     * Choose, which TriviaCategory to update.
     */
    where: TriviaCategoryWhereUniqueInput
  }


  /**
   * TriviaCategory updateMany
   */
  export type TriviaCategoryUpdateManyArgs = {
    /**
     * The data used to update TriviaCategories.
     */
    data: XOR<TriviaCategoryUpdateManyMutationInput, TriviaCategoryUncheckedUpdateManyInput>
    /**
     * Filter which TriviaCategories to update
     */
    where?: TriviaCategoryWhereInput
  }


  /**
   * TriviaCategory upsert
   */
  export type TriviaCategoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the TriviaCategory
     */
    select?: TriviaCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaCategoryInclude | null
    /**
     * The filter to search for the TriviaCategory to update in case it exists.
     */
    where: TriviaCategoryWhereUniqueInput
    /**
     * In case the TriviaCategory found by the `where` argument doesn't exist, create a new TriviaCategory with this data.
     */
    create: XOR<TriviaCategoryCreateInput, TriviaCategoryUncheckedCreateInput>
    /**
     * In case the TriviaCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TriviaCategoryUpdateInput, TriviaCategoryUncheckedUpdateInput>
  }


  /**
   * TriviaCategory delete
   */
  export type TriviaCategoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the TriviaCategory
     */
    select?: TriviaCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaCategoryInclude | null
    /**
     * Filter which TriviaCategory to delete.
     */
    where: TriviaCategoryWhereUniqueInput
  }


  /**
   * TriviaCategory deleteMany
   */
  export type TriviaCategoryDeleteManyArgs = {
    /**
     * Filter which TriviaCategories to delete
     */
    where?: TriviaCategoryWhereInput
  }


  /**
   * TriviaCategory.questions
   */
  export type TriviaCategory$questionsArgs = {
    /**
     * Select specific fields to fetch from the TriviaQuestion
     */
    select?: TriviaQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaQuestionInclude | null
    where?: TriviaQuestionWhereInput
    orderBy?: Enumerable<TriviaQuestionOrderByWithRelationInput>
    cursor?: TriviaQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TriviaQuestionScalarFieldEnum>
  }


  /**
   * TriviaCategory.rounds
   */
  export type TriviaCategory$roundsArgs = {
    /**
     * Select specific fields to fetch from the TriviaRound
     */
    select?: TriviaRoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaRoundInclude | null
    where?: TriviaRoundWhereInput
    orderBy?: Enumerable<TriviaRoundOrderByWithRelationInput>
    cursor?: TriviaRoundWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TriviaRoundScalarFieldEnum>
  }


  /**
   * TriviaCategory without action
   */
  export type TriviaCategoryArgs = {
    /**
     * Select specific fields to fetch from the TriviaCategory
     */
    select?: TriviaCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaCategoryInclude | null
  }



  /**
   * Model TriviaQuestion
   */


  export type AggregateTriviaQuestion = {
    _count: TriviaQuestionCountAggregateOutputType | null
    _avg: TriviaQuestionAvgAggregateOutputType | null
    _sum: TriviaQuestionSumAggregateOutputType | null
    _min: TriviaQuestionMinAggregateOutputType | null
    _max: TriviaQuestionMaxAggregateOutputType | null
  }

  export type TriviaQuestionAvgAggregateOutputType = {
    id: number | null
    categoryId: number | null
    answerID: number | null
  }

  export type TriviaQuestionSumAggregateOutputType = {
    id: number | null
    categoryId: number | null
    answerID: number | null
  }

  export type TriviaQuestionMinAggregateOutputType = {
    id: number | null
    categoryId: number | null
    name: string | null
    answerID: number | null
  }

  export type TriviaQuestionMaxAggregateOutputType = {
    id: number | null
    categoryId: number | null
    name: string | null
    answerID: number | null
  }

  export type TriviaQuestionCountAggregateOutputType = {
    id: number
    categoryId: number
    name: number
    answerID: number
    _all: number
  }


  export type TriviaQuestionAvgAggregateInputType = {
    id?: true
    categoryId?: true
    answerID?: true
  }

  export type TriviaQuestionSumAggregateInputType = {
    id?: true
    categoryId?: true
    answerID?: true
  }

  export type TriviaQuestionMinAggregateInputType = {
    id?: true
    categoryId?: true
    name?: true
    answerID?: true
  }

  export type TriviaQuestionMaxAggregateInputType = {
    id?: true
    categoryId?: true
    name?: true
    answerID?: true
  }

  export type TriviaQuestionCountAggregateInputType = {
    id?: true
    categoryId?: true
    name?: true
    answerID?: true
    _all?: true
  }

  export type TriviaQuestionAggregateArgs = {
    /**
     * Filter which TriviaQuestion to aggregate.
     */
    where?: TriviaQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TriviaQuestions to fetch.
     */
    orderBy?: Enumerable<TriviaQuestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TriviaQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TriviaQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TriviaQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TriviaQuestions
    **/
    _count?: true | TriviaQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TriviaQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TriviaQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TriviaQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TriviaQuestionMaxAggregateInputType
  }

  export type GetTriviaQuestionAggregateType<T extends TriviaQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateTriviaQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTriviaQuestion[P]>
      : GetScalarType<T[P], AggregateTriviaQuestion[P]>
  }




  export type TriviaQuestionGroupByArgs = {
    where?: TriviaQuestionWhereInput
    orderBy?: Enumerable<TriviaQuestionOrderByWithAggregationInput>
    by: TriviaQuestionScalarFieldEnum[]
    having?: TriviaQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TriviaQuestionCountAggregateInputType | true
    _avg?: TriviaQuestionAvgAggregateInputType
    _sum?: TriviaQuestionSumAggregateInputType
    _min?: TriviaQuestionMinAggregateInputType
    _max?: TriviaQuestionMaxAggregateInputType
  }


  export type TriviaQuestionGroupByOutputType = {
    id: number
    categoryId: number
    name: string
    answerID: number
    _count: TriviaQuestionCountAggregateOutputType | null
    _avg: TriviaQuestionAvgAggregateOutputType | null
    _sum: TriviaQuestionSumAggregateOutputType | null
    _min: TriviaQuestionMinAggregateOutputType | null
    _max: TriviaQuestionMaxAggregateOutputType | null
  }

  type GetTriviaQuestionGroupByPayload<T extends TriviaQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TriviaQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TriviaQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TriviaQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], TriviaQuestionGroupByOutputType[P]>
        }
      >
    >


  export type TriviaQuestionSelect = {
    id?: boolean
    category?: boolean | TriviaCategoryArgs
    categoryId?: boolean
    name?: boolean
    answerID?: boolean
    choices?: boolean | TriviaQuestion$choicesArgs
    roundQuestions?: boolean | TriviaQuestion$roundQuestionsArgs
    _count?: boolean | TriviaQuestionCountOutputTypeArgs
  }


  export type TriviaQuestionInclude = {
    category?: boolean | TriviaCategoryArgs
    choices?: boolean | TriviaQuestion$choicesArgs
    roundQuestions?: boolean | TriviaQuestion$roundQuestionsArgs
    _count?: boolean | TriviaQuestionCountOutputTypeArgs
  }

  export type TriviaQuestionGetPayload<S extends boolean | null | undefined | TriviaQuestionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TriviaQuestion :
    S extends undefined ? never :
    S extends { include: any } & (TriviaQuestionArgs | TriviaQuestionFindManyArgs)
    ? TriviaQuestion  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'category' ? TriviaCategoryGetPayload<S['include'][P]> :
        P extends 'choices' ? Array < TriviaChoiceGetPayload<S['include'][P]>>  :
        P extends 'roundQuestions' ? Array < TriviaRoundQuestionGetPayload<S['include'][P]>>  :
        P extends '_count' ? TriviaQuestionCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TriviaQuestionArgs | TriviaQuestionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'category' ? TriviaCategoryGetPayload<S['select'][P]> :
        P extends 'choices' ? Array < TriviaChoiceGetPayload<S['select'][P]>>  :
        P extends 'roundQuestions' ? Array < TriviaRoundQuestionGetPayload<S['select'][P]>>  :
        P extends '_count' ? TriviaQuestionCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof TriviaQuestion ? TriviaQuestion[P] : never
  } 
      : TriviaQuestion


  type TriviaQuestionCountArgs = 
    Omit<TriviaQuestionFindManyArgs, 'select' | 'include'> & {
      select?: TriviaQuestionCountAggregateInputType | true
    }

  export interface TriviaQuestionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TriviaQuestion that matches the filter.
     * @param {TriviaQuestionFindUniqueArgs} args - Arguments to find a TriviaQuestion
     * @example
     * // Get one TriviaQuestion
     * const triviaQuestion = await prisma.triviaQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TriviaQuestionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TriviaQuestionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TriviaQuestion'> extends True ? Prisma__TriviaQuestionClient<TriviaQuestionGetPayload<T>> : Prisma__TriviaQuestionClient<TriviaQuestionGetPayload<T> | null, null>

    /**
     * Find one TriviaQuestion that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TriviaQuestionFindUniqueOrThrowArgs} args - Arguments to find a TriviaQuestion
     * @example
     * // Get one TriviaQuestion
     * const triviaQuestion = await prisma.triviaQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TriviaQuestionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TriviaQuestionFindUniqueOrThrowArgs>
    ): Prisma__TriviaQuestionClient<TriviaQuestionGetPayload<T>>

    /**
     * Find the first TriviaQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriviaQuestionFindFirstArgs} args - Arguments to find a TriviaQuestion
     * @example
     * // Get one TriviaQuestion
     * const triviaQuestion = await prisma.triviaQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TriviaQuestionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TriviaQuestionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TriviaQuestion'> extends True ? Prisma__TriviaQuestionClient<TriviaQuestionGetPayload<T>> : Prisma__TriviaQuestionClient<TriviaQuestionGetPayload<T> | null, null>

    /**
     * Find the first TriviaQuestion that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriviaQuestionFindFirstOrThrowArgs} args - Arguments to find a TriviaQuestion
     * @example
     * // Get one TriviaQuestion
     * const triviaQuestion = await prisma.triviaQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TriviaQuestionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TriviaQuestionFindFirstOrThrowArgs>
    ): Prisma__TriviaQuestionClient<TriviaQuestionGetPayload<T>>

    /**
     * Find zero or more TriviaQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriviaQuestionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TriviaQuestions
     * const triviaQuestions = await prisma.triviaQuestion.findMany()
     * 
     * // Get first 10 TriviaQuestions
     * const triviaQuestions = await prisma.triviaQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const triviaQuestionWithIdOnly = await prisma.triviaQuestion.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TriviaQuestionFindManyArgs>(
      args?: SelectSubset<T, TriviaQuestionFindManyArgs>
    ): Prisma.PrismaPromise<Array<TriviaQuestionGetPayload<T>>>

    /**
     * Create a TriviaQuestion.
     * @param {TriviaQuestionCreateArgs} args - Arguments to create a TriviaQuestion.
     * @example
     * // Create one TriviaQuestion
     * const TriviaQuestion = await prisma.triviaQuestion.create({
     *   data: {
     *     // ... data to create a TriviaQuestion
     *   }
     * })
     * 
    **/
    create<T extends TriviaQuestionCreateArgs>(
      args: SelectSubset<T, TriviaQuestionCreateArgs>
    ): Prisma__TriviaQuestionClient<TriviaQuestionGetPayload<T>>

    /**
     * Create many TriviaQuestions.
     *     @param {TriviaQuestionCreateManyArgs} args - Arguments to create many TriviaQuestions.
     *     @example
     *     // Create many TriviaQuestions
     *     const triviaQuestion = await prisma.triviaQuestion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TriviaQuestionCreateManyArgs>(
      args?: SelectSubset<T, TriviaQuestionCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TriviaQuestion.
     * @param {TriviaQuestionDeleteArgs} args - Arguments to delete one TriviaQuestion.
     * @example
     * // Delete one TriviaQuestion
     * const TriviaQuestion = await prisma.triviaQuestion.delete({
     *   where: {
     *     // ... filter to delete one TriviaQuestion
     *   }
     * })
     * 
    **/
    delete<T extends TriviaQuestionDeleteArgs>(
      args: SelectSubset<T, TriviaQuestionDeleteArgs>
    ): Prisma__TriviaQuestionClient<TriviaQuestionGetPayload<T>>

    /**
     * Update one TriviaQuestion.
     * @param {TriviaQuestionUpdateArgs} args - Arguments to update one TriviaQuestion.
     * @example
     * // Update one TriviaQuestion
     * const triviaQuestion = await prisma.triviaQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TriviaQuestionUpdateArgs>(
      args: SelectSubset<T, TriviaQuestionUpdateArgs>
    ): Prisma__TriviaQuestionClient<TriviaQuestionGetPayload<T>>

    /**
     * Delete zero or more TriviaQuestions.
     * @param {TriviaQuestionDeleteManyArgs} args - Arguments to filter TriviaQuestions to delete.
     * @example
     * // Delete a few TriviaQuestions
     * const { count } = await prisma.triviaQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TriviaQuestionDeleteManyArgs>(
      args?: SelectSubset<T, TriviaQuestionDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TriviaQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriviaQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TriviaQuestions
     * const triviaQuestion = await prisma.triviaQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TriviaQuestionUpdateManyArgs>(
      args: SelectSubset<T, TriviaQuestionUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TriviaQuestion.
     * @param {TriviaQuestionUpsertArgs} args - Arguments to update or create a TriviaQuestion.
     * @example
     * // Update or create a TriviaQuestion
     * const triviaQuestion = await prisma.triviaQuestion.upsert({
     *   create: {
     *     // ... data to create a TriviaQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TriviaQuestion we want to update
     *   }
     * })
    **/
    upsert<T extends TriviaQuestionUpsertArgs>(
      args: SelectSubset<T, TriviaQuestionUpsertArgs>
    ): Prisma__TriviaQuestionClient<TriviaQuestionGetPayload<T>>

    /**
     * Count the number of TriviaQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriviaQuestionCountArgs} args - Arguments to filter TriviaQuestions to count.
     * @example
     * // Count the number of TriviaQuestions
     * const count = await prisma.triviaQuestion.count({
     *   where: {
     *     // ... the filter for the TriviaQuestions we want to count
     *   }
     * })
    **/
    count<T extends TriviaQuestionCountArgs>(
      args?: Subset<T, TriviaQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TriviaQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TriviaQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriviaQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TriviaQuestionAggregateArgs>(args: Subset<T, TriviaQuestionAggregateArgs>): Prisma.PrismaPromise<GetTriviaQuestionAggregateType<T>>

    /**
     * Group by TriviaQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriviaQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TriviaQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TriviaQuestionGroupByArgs['orderBy'] }
        : { orderBy?: TriviaQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TriviaQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTriviaQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TriviaQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TriviaQuestionClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    category<T extends TriviaCategoryArgs= {}>(args?: Subset<T, TriviaCategoryArgs>): Prisma__TriviaCategoryClient<TriviaCategoryGetPayload<T> | Null>;

    choices<T extends TriviaQuestion$choicesArgs= {}>(args?: Subset<T, TriviaQuestion$choicesArgs>): Prisma.PrismaPromise<Array<TriviaChoiceGetPayload<T>>| Null>;

    roundQuestions<T extends TriviaQuestion$roundQuestionsArgs= {}>(args?: Subset<T, TriviaQuestion$roundQuestionsArgs>): Prisma.PrismaPromise<Array<TriviaRoundQuestionGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TriviaQuestion base type for findUnique actions
   */
  export type TriviaQuestionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TriviaQuestion
     */
    select?: TriviaQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaQuestionInclude | null
    /**
     * Filter, which TriviaQuestion to fetch.
     */
    where: TriviaQuestionWhereUniqueInput
  }

  /**
   * TriviaQuestion findUnique
   */
  export interface TriviaQuestionFindUniqueArgs extends TriviaQuestionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TriviaQuestion findUniqueOrThrow
   */
  export type TriviaQuestionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TriviaQuestion
     */
    select?: TriviaQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaQuestionInclude | null
    /**
     * Filter, which TriviaQuestion to fetch.
     */
    where: TriviaQuestionWhereUniqueInput
  }


  /**
   * TriviaQuestion base type for findFirst actions
   */
  export type TriviaQuestionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TriviaQuestion
     */
    select?: TriviaQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaQuestionInclude | null
    /**
     * Filter, which TriviaQuestion to fetch.
     */
    where?: TriviaQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TriviaQuestions to fetch.
     */
    orderBy?: Enumerable<TriviaQuestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TriviaQuestions.
     */
    cursor?: TriviaQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TriviaQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TriviaQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TriviaQuestions.
     */
    distinct?: Enumerable<TriviaQuestionScalarFieldEnum>
  }

  /**
   * TriviaQuestion findFirst
   */
  export interface TriviaQuestionFindFirstArgs extends TriviaQuestionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TriviaQuestion findFirstOrThrow
   */
  export type TriviaQuestionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TriviaQuestion
     */
    select?: TriviaQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaQuestionInclude | null
    /**
     * Filter, which TriviaQuestion to fetch.
     */
    where?: TriviaQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TriviaQuestions to fetch.
     */
    orderBy?: Enumerable<TriviaQuestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TriviaQuestions.
     */
    cursor?: TriviaQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TriviaQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TriviaQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TriviaQuestions.
     */
    distinct?: Enumerable<TriviaQuestionScalarFieldEnum>
  }


  /**
   * TriviaQuestion findMany
   */
  export type TriviaQuestionFindManyArgs = {
    /**
     * Select specific fields to fetch from the TriviaQuestion
     */
    select?: TriviaQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaQuestionInclude | null
    /**
     * Filter, which TriviaQuestions to fetch.
     */
    where?: TriviaQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TriviaQuestions to fetch.
     */
    orderBy?: Enumerable<TriviaQuestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TriviaQuestions.
     */
    cursor?: TriviaQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TriviaQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TriviaQuestions.
     */
    skip?: number
    distinct?: Enumerable<TriviaQuestionScalarFieldEnum>
  }


  /**
   * TriviaQuestion create
   */
  export type TriviaQuestionCreateArgs = {
    /**
     * Select specific fields to fetch from the TriviaQuestion
     */
    select?: TriviaQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaQuestionInclude | null
    /**
     * The data needed to create a TriviaQuestion.
     */
    data: XOR<TriviaQuestionCreateInput, TriviaQuestionUncheckedCreateInput>
  }


  /**
   * TriviaQuestion createMany
   */
  export type TriviaQuestionCreateManyArgs = {
    /**
     * The data used to create many TriviaQuestions.
     */
    data: Enumerable<TriviaQuestionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TriviaQuestion update
   */
  export type TriviaQuestionUpdateArgs = {
    /**
     * Select specific fields to fetch from the TriviaQuestion
     */
    select?: TriviaQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaQuestionInclude | null
    /**
     * The data needed to update a TriviaQuestion.
     */
    data: XOR<TriviaQuestionUpdateInput, TriviaQuestionUncheckedUpdateInput>
    /**
     * Choose, which TriviaQuestion to update.
     */
    where: TriviaQuestionWhereUniqueInput
  }


  /**
   * TriviaQuestion updateMany
   */
  export type TriviaQuestionUpdateManyArgs = {
    /**
     * The data used to update TriviaQuestions.
     */
    data: XOR<TriviaQuestionUpdateManyMutationInput, TriviaQuestionUncheckedUpdateManyInput>
    /**
     * Filter which TriviaQuestions to update
     */
    where?: TriviaQuestionWhereInput
  }


  /**
   * TriviaQuestion upsert
   */
  export type TriviaQuestionUpsertArgs = {
    /**
     * Select specific fields to fetch from the TriviaQuestion
     */
    select?: TriviaQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaQuestionInclude | null
    /**
     * The filter to search for the TriviaQuestion to update in case it exists.
     */
    where: TriviaQuestionWhereUniqueInput
    /**
     * In case the TriviaQuestion found by the `where` argument doesn't exist, create a new TriviaQuestion with this data.
     */
    create: XOR<TriviaQuestionCreateInput, TriviaQuestionUncheckedCreateInput>
    /**
     * In case the TriviaQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TriviaQuestionUpdateInput, TriviaQuestionUncheckedUpdateInput>
  }


  /**
   * TriviaQuestion delete
   */
  export type TriviaQuestionDeleteArgs = {
    /**
     * Select specific fields to fetch from the TriviaQuestion
     */
    select?: TriviaQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaQuestionInclude | null
    /**
     * Filter which TriviaQuestion to delete.
     */
    where: TriviaQuestionWhereUniqueInput
  }


  /**
   * TriviaQuestion deleteMany
   */
  export type TriviaQuestionDeleteManyArgs = {
    /**
     * Filter which TriviaQuestions to delete
     */
    where?: TriviaQuestionWhereInput
  }


  /**
   * TriviaQuestion.choices
   */
  export type TriviaQuestion$choicesArgs = {
    /**
     * Select specific fields to fetch from the TriviaChoice
     */
    select?: TriviaChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaChoiceInclude | null
    where?: TriviaChoiceWhereInput
    orderBy?: Enumerable<TriviaChoiceOrderByWithRelationInput>
    cursor?: TriviaChoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TriviaChoiceScalarFieldEnum>
  }


  /**
   * TriviaQuestion.roundQuestions
   */
  export type TriviaQuestion$roundQuestionsArgs = {
    /**
     * Select specific fields to fetch from the TriviaRoundQuestion
     */
    select?: TriviaRoundQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaRoundQuestionInclude | null
    where?: TriviaRoundQuestionWhereInput
    orderBy?: Enumerable<TriviaRoundQuestionOrderByWithRelationInput>
    cursor?: TriviaRoundQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TriviaRoundQuestionScalarFieldEnum>
  }


  /**
   * TriviaQuestion without action
   */
  export type TriviaQuestionArgs = {
    /**
     * Select specific fields to fetch from the TriviaQuestion
     */
    select?: TriviaQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaQuestionInclude | null
  }



  /**
   * Model TriviaChoice
   */


  export type AggregateTriviaChoice = {
    _count: TriviaChoiceCountAggregateOutputType | null
    _avg: TriviaChoiceAvgAggregateOutputType | null
    _sum: TriviaChoiceSumAggregateOutputType | null
    _min: TriviaChoiceMinAggregateOutputType | null
    _max: TriviaChoiceMaxAggregateOutputType | null
  }

  export type TriviaChoiceAvgAggregateOutputType = {
    id: number | null
    quizId: number | null
  }

  export type TriviaChoiceSumAggregateOutputType = {
    id: number | null
    quizId: number | null
  }

  export type TriviaChoiceMinAggregateOutputType = {
    id: number | null
    quizId: number | null
    name: string | null
  }

  export type TriviaChoiceMaxAggregateOutputType = {
    id: number | null
    quizId: number | null
    name: string | null
  }

  export type TriviaChoiceCountAggregateOutputType = {
    id: number
    quizId: number
    name: number
    _all: number
  }


  export type TriviaChoiceAvgAggregateInputType = {
    id?: true
    quizId?: true
  }

  export type TriviaChoiceSumAggregateInputType = {
    id?: true
    quizId?: true
  }

  export type TriviaChoiceMinAggregateInputType = {
    id?: true
    quizId?: true
    name?: true
  }

  export type TriviaChoiceMaxAggregateInputType = {
    id?: true
    quizId?: true
    name?: true
  }

  export type TriviaChoiceCountAggregateInputType = {
    id?: true
    quizId?: true
    name?: true
    _all?: true
  }

  export type TriviaChoiceAggregateArgs = {
    /**
     * Filter which TriviaChoice to aggregate.
     */
    where?: TriviaChoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TriviaChoices to fetch.
     */
    orderBy?: Enumerable<TriviaChoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TriviaChoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TriviaChoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TriviaChoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TriviaChoices
    **/
    _count?: true | TriviaChoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TriviaChoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TriviaChoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TriviaChoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TriviaChoiceMaxAggregateInputType
  }

  export type GetTriviaChoiceAggregateType<T extends TriviaChoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateTriviaChoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTriviaChoice[P]>
      : GetScalarType<T[P], AggregateTriviaChoice[P]>
  }




  export type TriviaChoiceGroupByArgs = {
    where?: TriviaChoiceWhereInput
    orderBy?: Enumerable<TriviaChoiceOrderByWithAggregationInput>
    by: TriviaChoiceScalarFieldEnum[]
    having?: TriviaChoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TriviaChoiceCountAggregateInputType | true
    _avg?: TriviaChoiceAvgAggregateInputType
    _sum?: TriviaChoiceSumAggregateInputType
    _min?: TriviaChoiceMinAggregateInputType
    _max?: TriviaChoiceMaxAggregateInputType
  }


  export type TriviaChoiceGroupByOutputType = {
    id: number
    quizId: number
    name: string
    _count: TriviaChoiceCountAggregateOutputType | null
    _avg: TriviaChoiceAvgAggregateOutputType | null
    _sum: TriviaChoiceSumAggregateOutputType | null
    _min: TriviaChoiceMinAggregateOutputType | null
    _max: TriviaChoiceMaxAggregateOutputType | null
  }

  type GetTriviaChoiceGroupByPayload<T extends TriviaChoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TriviaChoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TriviaChoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TriviaChoiceGroupByOutputType[P]>
            : GetScalarType<T[P], TriviaChoiceGroupByOutputType[P]>
        }
      >
    >


  export type TriviaChoiceSelect = {
    id?: boolean
    question?: boolean | TriviaQuestionArgs
    quizId?: boolean
    name?: boolean
    roundQuestions?: boolean | TriviaChoice$roundQuestionsArgs
    _count?: boolean | TriviaChoiceCountOutputTypeArgs
  }


  export type TriviaChoiceInclude = {
    question?: boolean | TriviaQuestionArgs
    roundQuestions?: boolean | TriviaChoice$roundQuestionsArgs
    _count?: boolean | TriviaChoiceCountOutputTypeArgs
  }

  export type TriviaChoiceGetPayload<S extends boolean | null | undefined | TriviaChoiceArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TriviaChoice :
    S extends undefined ? never :
    S extends { include: any } & (TriviaChoiceArgs | TriviaChoiceFindManyArgs)
    ? TriviaChoice  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'question' ? TriviaQuestionGetPayload<S['include'][P]> :
        P extends 'roundQuestions' ? Array < TriviaRoundQuestionGetPayload<S['include'][P]>>  :
        P extends '_count' ? TriviaChoiceCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TriviaChoiceArgs | TriviaChoiceFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'question' ? TriviaQuestionGetPayload<S['select'][P]> :
        P extends 'roundQuestions' ? Array < TriviaRoundQuestionGetPayload<S['select'][P]>>  :
        P extends '_count' ? TriviaChoiceCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof TriviaChoice ? TriviaChoice[P] : never
  } 
      : TriviaChoice


  type TriviaChoiceCountArgs = 
    Omit<TriviaChoiceFindManyArgs, 'select' | 'include'> & {
      select?: TriviaChoiceCountAggregateInputType | true
    }

  export interface TriviaChoiceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TriviaChoice that matches the filter.
     * @param {TriviaChoiceFindUniqueArgs} args - Arguments to find a TriviaChoice
     * @example
     * // Get one TriviaChoice
     * const triviaChoice = await prisma.triviaChoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TriviaChoiceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TriviaChoiceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TriviaChoice'> extends True ? Prisma__TriviaChoiceClient<TriviaChoiceGetPayload<T>> : Prisma__TriviaChoiceClient<TriviaChoiceGetPayload<T> | null, null>

    /**
     * Find one TriviaChoice that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TriviaChoiceFindUniqueOrThrowArgs} args - Arguments to find a TriviaChoice
     * @example
     * // Get one TriviaChoice
     * const triviaChoice = await prisma.triviaChoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TriviaChoiceFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TriviaChoiceFindUniqueOrThrowArgs>
    ): Prisma__TriviaChoiceClient<TriviaChoiceGetPayload<T>>

    /**
     * Find the first TriviaChoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriviaChoiceFindFirstArgs} args - Arguments to find a TriviaChoice
     * @example
     * // Get one TriviaChoice
     * const triviaChoice = await prisma.triviaChoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TriviaChoiceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TriviaChoiceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TriviaChoice'> extends True ? Prisma__TriviaChoiceClient<TriviaChoiceGetPayload<T>> : Prisma__TriviaChoiceClient<TriviaChoiceGetPayload<T> | null, null>

    /**
     * Find the first TriviaChoice that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriviaChoiceFindFirstOrThrowArgs} args - Arguments to find a TriviaChoice
     * @example
     * // Get one TriviaChoice
     * const triviaChoice = await prisma.triviaChoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TriviaChoiceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TriviaChoiceFindFirstOrThrowArgs>
    ): Prisma__TriviaChoiceClient<TriviaChoiceGetPayload<T>>

    /**
     * Find zero or more TriviaChoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriviaChoiceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TriviaChoices
     * const triviaChoices = await prisma.triviaChoice.findMany()
     * 
     * // Get first 10 TriviaChoices
     * const triviaChoices = await prisma.triviaChoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const triviaChoiceWithIdOnly = await prisma.triviaChoice.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TriviaChoiceFindManyArgs>(
      args?: SelectSubset<T, TriviaChoiceFindManyArgs>
    ): Prisma.PrismaPromise<Array<TriviaChoiceGetPayload<T>>>

    /**
     * Create a TriviaChoice.
     * @param {TriviaChoiceCreateArgs} args - Arguments to create a TriviaChoice.
     * @example
     * // Create one TriviaChoice
     * const TriviaChoice = await prisma.triviaChoice.create({
     *   data: {
     *     // ... data to create a TriviaChoice
     *   }
     * })
     * 
    **/
    create<T extends TriviaChoiceCreateArgs>(
      args: SelectSubset<T, TriviaChoiceCreateArgs>
    ): Prisma__TriviaChoiceClient<TriviaChoiceGetPayload<T>>

    /**
     * Create many TriviaChoices.
     *     @param {TriviaChoiceCreateManyArgs} args - Arguments to create many TriviaChoices.
     *     @example
     *     // Create many TriviaChoices
     *     const triviaChoice = await prisma.triviaChoice.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TriviaChoiceCreateManyArgs>(
      args?: SelectSubset<T, TriviaChoiceCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TriviaChoice.
     * @param {TriviaChoiceDeleteArgs} args - Arguments to delete one TriviaChoice.
     * @example
     * // Delete one TriviaChoice
     * const TriviaChoice = await prisma.triviaChoice.delete({
     *   where: {
     *     // ... filter to delete one TriviaChoice
     *   }
     * })
     * 
    **/
    delete<T extends TriviaChoiceDeleteArgs>(
      args: SelectSubset<T, TriviaChoiceDeleteArgs>
    ): Prisma__TriviaChoiceClient<TriviaChoiceGetPayload<T>>

    /**
     * Update one TriviaChoice.
     * @param {TriviaChoiceUpdateArgs} args - Arguments to update one TriviaChoice.
     * @example
     * // Update one TriviaChoice
     * const triviaChoice = await prisma.triviaChoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TriviaChoiceUpdateArgs>(
      args: SelectSubset<T, TriviaChoiceUpdateArgs>
    ): Prisma__TriviaChoiceClient<TriviaChoiceGetPayload<T>>

    /**
     * Delete zero or more TriviaChoices.
     * @param {TriviaChoiceDeleteManyArgs} args - Arguments to filter TriviaChoices to delete.
     * @example
     * // Delete a few TriviaChoices
     * const { count } = await prisma.triviaChoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TriviaChoiceDeleteManyArgs>(
      args?: SelectSubset<T, TriviaChoiceDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TriviaChoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriviaChoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TriviaChoices
     * const triviaChoice = await prisma.triviaChoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TriviaChoiceUpdateManyArgs>(
      args: SelectSubset<T, TriviaChoiceUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TriviaChoice.
     * @param {TriviaChoiceUpsertArgs} args - Arguments to update or create a TriviaChoice.
     * @example
     * // Update or create a TriviaChoice
     * const triviaChoice = await prisma.triviaChoice.upsert({
     *   create: {
     *     // ... data to create a TriviaChoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TriviaChoice we want to update
     *   }
     * })
    **/
    upsert<T extends TriviaChoiceUpsertArgs>(
      args: SelectSubset<T, TriviaChoiceUpsertArgs>
    ): Prisma__TriviaChoiceClient<TriviaChoiceGetPayload<T>>

    /**
     * Count the number of TriviaChoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriviaChoiceCountArgs} args - Arguments to filter TriviaChoices to count.
     * @example
     * // Count the number of TriviaChoices
     * const count = await prisma.triviaChoice.count({
     *   where: {
     *     // ... the filter for the TriviaChoices we want to count
     *   }
     * })
    **/
    count<T extends TriviaChoiceCountArgs>(
      args?: Subset<T, TriviaChoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TriviaChoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TriviaChoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriviaChoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TriviaChoiceAggregateArgs>(args: Subset<T, TriviaChoiceAggregateArgs>): Prisma.PrismaPromise<GetTriviaChoiceAggregateType<T>>

    /**
     * Group by TriviaChoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriviaChoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TriviaChoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TriviaChoiceGroupByArgs['orderBy'] }
        : { orderBy?: TriviaChoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TriviaChoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTriviaChoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TriviaChoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TriviaChoiceClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    question<T extends TriviaQuestionArgs= {}>(args?: Subset<T, TriviaQuestionArgs>): Prisma__TriviaQuestionClient<TriviaQuestionGetPayload<T> | Null>;

    roundQuestions<T extends TriviaChoice$roundQuestionsArgs= {}>(args?: Subset<T, TriviaChoice$roundQuestionsArgs>): Prisma.PrismaPromise<Array<TriviaRoundQuestionGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TriviaChoice base type for findUnique actions
   */
  export type TriviaChoiceFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TriviaChoice
     */
    select?: TriviaChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaChoiceInclude | null
    /**
     * Filter, which TriviaChoice to fetch.
     */
    where: TriviaChoiceWhereUniqueInput
  }

  /**
   * TriviaChoice findUnique
   */
  export interface TriviaChoiceFindUniqueArgs extends TriviaChoiceFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TriviaChoice findUniqueOrThrow
   */
  export type TriviaChoiceFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TriviaChoice
     */
    select?: TriviaChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaChoiceInclude | null
    /**
     * Filter, which TriviaChoice to fetch.
     */
    where: TriviaChoiceWhereUniqueInput
  }


  /**
   * TriviaChoice base type for findFirst actions
   */
  export type TriviaChoiceFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TriviaChoice
     */
    select?: TriviaChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaChoiceInclude | null
    /**
     * Filter, which TriviaChoice to fetch.
     */
    where?: TriviaChoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TriviaChoices to fetch.
     */
    orderBy?: Enumerable<TriviaChoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TriviaChoices.
     */
    cursor?: TriviaChoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TriviaChoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TriviaChoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TriviaChoices.
     */
    distinct?: Enumerable<TriviaChoiceScalarFieldEnum>
  }

  /**
   * TriviaChoice findFirst
   */
  export interface TriviaChoiceFindFirstArgs extends TriviaChoiceFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TriviaChoice findFirstOrThrow
   */
  export type TriviaChoiceFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TriviaChoice
     */
    select?: TriviaChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaChoiceInclude | null
    /**
     * Filter, which TriviaChoice to fetch.
     */
    where?: TriviaChoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TriviaChoices to fetch.
     */
    orderBy?: Enumerable<TriviaChoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TriviaChoices.
     */
    cursor?: TriviaChoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TriviaChoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TriviaChoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TriviaChoices.
     */
    distinct?: Enumerable<TriviaChoiceScalarFieldEnum>
  }


  /**
   * TriviaChoice findMany
   */
  export type TriviaChoiceFindManyArgs = {
    /**
     * Select specific fields to fetch from the TriviaChoice
     */
    select?: TriviaChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaChoiceInclude | null
    /**
     * Filter, which TriviaChoices to fetch.
     */
    where?: TriviaChoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TriviaChoices to fetch.
     */
    orderBy?: Enumerable<TriviaChoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TriviaChoices.
     */
    cursor?: TriviaChoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TriviaChoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TriviaChoices.
     */
    skip?: number
    distinct?: Enumerable<TriviaChoiceScalarFieldEnum>
  }


  /**
   * TriviaChoice create
   */
  export type TriviaChoiceCreateArgs = {
    /**
     * Select specific fields to fetch from the TriviaChoice
     */
    select?: TriviaChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaChoiceInclude | null
    /**
     * The data needed to create a TriviaChoice.
     */
    data: XOR<TriviaChoiceCreateInput, TriviaChoiceUncheckedCreateInput>
  }


  /**
   * TriviaChoice createMany
   */
  export type TriviaChoiceCreateManyArgs = {
    /**
     * The data used to create many TriviaChoices.
     */
    data: Enumerable<TriviaChoiceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TriviaChoice update
   */
  export type TriviaChoiceUpdateArgs = {
    /**
     * Select specific fields to fetch from the TriviaChoice
     */
    select?: TriviaChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaChoiceInclude | null
    /**
     * The data needed to update a TriviaChoice.
     */
    data: XOR<TriviaChoiceUpdateInput, TriviaChoiceUncheckedUpdateInput>
    /**
     * Choose, which TriviaChoice to update.
     */
    where: TriviaChoiceWhereUniqueInput
  }


  /**
   * TriviaChoice updateMany
   */
  export type TriviaChoiceUpdateManyArgs = {
    /**
     * The data used to update TriviaChoices.
     */
    data: XOR<TriviaChoiceUpdateManyMutationInput, TriviaChoiceUncheckedUpdateManyInput>
    /**
     * Filter which TriviaChoices to update
     */
    where?: TriviaChoiceWhereInput
  }


  /**
   * TriviaChoice upsert
   */
  export type TriviaChoiceUpsertArgs = {
    /**
     * Select specific fields to fetch from the TriviaChoice
     */
    select?: TriviaChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaChoiceInclude | null
    /**
     * The filter to search for the TriviaChoice to update in case it exists.
     */
    where: TriviaChoiceWhereUniqueInput
    /**
     * In case the TriviaChoice found by the `where` argument doesn't exist, create a new TriviaChoice with this data.
     */
    create: XOR<TriviaChoiceCreateInput, TriviaChoiceUncheckedCreateInput>
    /**
     * In case the TriviaChoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TriviaChoiceUpdateInput, TriviaChoiceUncheckedUpdateInput>
  }


  /**
   * TriviaChoice delete
   */
  export type TriviaChoiceDeleteArgs = {
    /**
     * Select specific fields to fetch from the TriviaChoice
     */
    select?: TriviaChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaChoiceInclude | null
    /**
     * Filter which TriviaChoice to delete.
     */
    where: TriviaChoiceWhereUniqueInput
  }


  /**
   * TriviaChoice deleteMany
   */
  export type TriviaChoiceDeleteManyArgs = {
    /**
     * Filter which TriviaChoices to delete
     */
    where?: TriviaChoiceWhereInput
  }


  /**
   * TriviaChoice.roundQuestions
   */
  export type TriviaChoice$roundQuestionsArgs = {
    /**
     * Select specific fields to fetch from the TriviaRoundQuestion
     */
    select?: TriviaRoundQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaRoundQuestionInclude | null
    where?: TriviaRoundQuestionWhereInput
    orderBy?: Enumerable<TriviaRoundQuestionOrderByWithRelationInput>
    cursor?: TriviaRoundQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TriviaRoundQuestionScalarFieldEnum>
  }


  /**
   * TriviaChoice without action
   */
  export type TriviaChoiceArgs = {
    /**
     * Select specific fields to fetch from the TriviaChoice
     */
    select?: TriviaChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaChoiceInclude | null
  }



  /**
   * Model TriviaRoundQuestion
   */


  export type AggregateTriviaRoundQuestion = {
    _count: TriviaRoundQuestionCountAggregateOutputType | null
    _avg: TriviaRoundQuestionAvgAggregateOutputType | null
    _sum: TriviaRoundQuestionSumAggregateOutputType | null
    _min: TriviaRoundQuestionMinAggregateOutputType | null
    _max: TriviaRoundQuestionMaxAggregateOutputType | null
  }

  export type TriviaRoundQuestionAvgAggregateOutputType = {
    id: number | null
    quizId: number | null
    choiceId: number | null
    roundId: number | null
  }

  export type TriviaRoundQuestionSumAggregateOutputType = {
    id: number | null
    quizId: number | null
    choiceId: number | null
    roundId: number | null
  }

  export type TriviaRoundQuestionMinAggregateOutputType = {
    id: number | null
    quizId: number | null
    choiceId: number | null
    quizResult: boolean | null
    roundId: number | null
  }

  export type TriviaRoundQuestionMaxAggregateOutputType = {
    id: number | null
    quizId: number | null
    choiceId: number | null
    quizResult: boolean | null
    roundId: number | null
  }

  export type TriviaRoundQuestionCountAggregateOutputType = {
    id: number
    quizId: number
    choiceId: number
    quizResult: number
    roundId: number
    _all: number
  }


  export type TriviaRoundQuestionAvgAggregateInputType = {
    id?: true
    quizId?: true
    choiceId?: true
    roundId?: true
  }

  export type TriviaRoundQuestionSumAggregateInputType = {
    id?: true
    quizId?: true
    choiceId?: true
    roundId?: true
  }

  export type TriviaRoundQuestionMinAggregateInputType = {
    id?: true
    quizId?: true
    choiceId?: true
    quizResult?: true
    roundId?: true
  }

  export type TriviaRoundQuestionMaxAggregateInputType = {
    id?: true
    quizId?: true
    choiceId?: true
    quizResult?: true
    roundId?: true
  }

  export type TriviaRoundQuestionCountAggregateInputType = {
    id?: true
    quizId?: true
    choiceId?: true
    quizResult?: true
    roundId?: true
    _all?: true
  }

  export type TriviaRoundQuestionAggregateArgs = {
    /**
     * Filter which TriviaRoundQuestion to aggregate.
     */
    where?: TriviaRoundQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TriviaRoundQuestions to fetch.
     */
    orderBy?: Enumerable<TriviaRoundQuestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TriviaRoundQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TriviaRoundQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TriviaRoundQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TriviaRoundQuestions
    **/
    _count?: true | TriviaRoundQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TriviaRoundQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TriviaRoundQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TriviaRoundQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TriviaRoundQuestionMaxAggregateInputType
  }

  export type GetTriviaRoundQuestionAggregateType<T extends TriviaRoundQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateTriviaRoundQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTriviaRoundQuestion[P]>
      : GetScalarType<T[P], AggregateTriviaRoundQuestion[P]>
  }




  export type TriviaRoundQuestionGroupByArgs = {
    where?: TriviaRoundQuestionWhereInput
    orderBy?: Enumerable<TriviaRoundQuestionOrderByWithAggregationInput>
    by: TriviaRoundQuestionScalarFieldEnum[]
    having?: TriviaRoundQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TriviaRoundQuestionCountAggregateInputType | true
    _avg?: TriviaRoundQuestionAvgAggregateInputType
    _sum?: TriviaRoundQuestionSumAggregateInputType
    _min?: TriviaRoundQuestionMinAggregateInputType
    _max?: TriviaRoundQuestionMaxAggregateInputType
  }


  export type TriviaRoundQuestionGroupByOutputType = {
    id: number
    quizId: number
    choiceId: number
    quizResult: boolean
    roundId: number | null
    _count: TriviaRoundQuestionCountAggregateOutputType | null
    _avg: TriviaRoundQuestionAvgAggregateOutputType | null
    _sum: TriviaRoundQuestionSumAggregateOutputType | null
    _min: TriviaRoundQuestionMinAggregateOutputType | null
    _max: TriviaRoundQuestionMaxAggregateOutputType | null
  }

  type GetTriviaRoundQuestionGroupByPayload<T extends TriviaRoundQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TriviaRoundQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TriviaRoundQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TriviaRoundQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], TriviaRoundQuestionGroupByOutputType[P]>
        }
      >
    >


  export type TriviaRoundQuestionSelect = {
    id?: boolean
    question?: boolean | TriviaQuestionArgs
    quizId?: boolean
    userChoice?: boolean | TriviaChoiceArgs
    choiceId?: boolean
    quizResult?: boolean
    round?: boolean | TriviaRoundArgs
    roundId?: boolean
  }


  export type TriviaRoundQuestionInclude = {
    question?: boolean | TriviaQuestionArgs
    userChoice?: boolean | TriviaChoiceArgs
    round?: boolean | TriviaRoundArgs
  }

  export type TriviaRoundQuestionGetPayload<S extends boolean | null | undefined | TriviaRoundQuestionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TriviaRoundQuestion :
    S extends undefined ? never :
    S extends { include: any } & (TriviaRoundQuestionArgs | TriviaRoundQuestionFindManyArgs)
    ? TriviaRoundQuestion  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'question' ? TriviaQuestionGetPayload<S['include'][P]> :
        P extends 'userChoice' ? TriviaChoiceGetPayload<S['include'][P]> :
        P extends 'round' ? TriviaRoundGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (TriviaRoundQuestionArgs | TriviaRoundQuestionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'question' ? TriviaQuestionGetPayload<S['select'][P]> :
        P extends 'userChoice' ? TriviaChoiceGetPayload<S['select'][P]> :
        P extends 'round' ? TriviaRoundGetPayload<S['select'][P]> | null :  P extends keyof TriviaRoundQuestion ? TriviaRoundQuestion[P] : never
  } 
      : TriviaRoundQuestion


  type TriviaRoundQuestionCountArgs = 
    Omit<TriviaRoundQuestionFindManyArgs, 'select' | 'include'> & {
      select?: TriviaRoundQuestionCountAggregateInputType | true
    }

  export interface TriviaRoundQuestionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TriviaRoundQuestion that matches the filter.
     * @param {TriviaRoundQuestionFindUniqueArgs} args - Arguments to find a TriviaRoundQuestion
     * @example
     * // Get one TriviaRoundQuestion
     * const triviaRoundQuestion = await prisma.triviaRoundQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TriviaRoundQuestionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TriviaRoundQuestionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TriviaRoundQuestion'> extends True ? Prisma__TriviaRoundQuestionClient<TriviaRoundQuestionGetPayload<T>> : Prisma__TriviaRoundQuestionClient<TriviaRoundQuestionGetPayload<T> | null, null>

    /**
     * Find one TriviaRoundQuestion that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TriviaRoundQuestionFindUniqueOrThrowArgs} args - Arguments to find a TriviaRoundQuestion
     * @example
     * // Get one TriviaRoundQuestion
     * const triviaRoundQuestion = await prisma.triviaRoundQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TriviaRoundQuestionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TriviaRoundQuestionFindUniqueOrThrowArgs>
    ): Prisma__TriviaRoundQuestionClient<TriviaRoundQuestionGetPayload<T>>

    /**
     * Find the first TriviaRoundQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriviaRoundQuestionFindFirstArgs} args - Arguments to find a TriviaRoundQuestion
     * @example
     * // Get one TriviaRoundQuestion
     * const triviaRoundQuestion = await prisma.triviaRoundQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TriviaRoundQuestionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TriviaRoundQuestionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TriviaRoundQuestion'> extends True ? Prisma__TriviaRoundQuestionClient<TriviaRoundQuestionGetPayload<T>> : Prisma__TriviaRoundQuestionClient<TriviaRoundQuestionGetPayload<T> | null, null>

    /**
     * Find the first TriviaRoundQuestion that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriviaRoundQuestionFindFirstOrThrowArgs} args - Arguments to find a TriviaRoundQuestion
     * @example
     * // Get one TriviaRoundQuestion
     * const triviaRoundQuestion = await prisma.triviaRoundQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TriviaRoundQuestionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TriviaRoundQuestionFindFirstOrThrowArgs>
    ): Prisma__TriviaRoundQuestionClient<TriviaRoundQuestionGetPayload<T>>

    /**
     * Find zero or more TriviaRoundQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriviaRoundQuestionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TriviaRoundQuestions
     * const triviaRoundQuestions = await prisma.triviaRoundQuestion.findMany()
     * 
     * // Get first 10 TriviaRoundQuestions
     * const triviaRoundQuestions = await prisma.triviaRoundQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const triviaRoundQuestionWithIdOnly = await prisma.triviaRoundQuestion.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TriviaRoundQuestionFindManyArgs>(
      args?: SelectSubset<T, TriviaRoundQuestionFindManyArgs>
    ): Prisma.PrismaPromise<Array<TriviaRoundQuestionGetPayload<T>>>

    /**
     * Create a TriviaRoundQuestion.
     * @param {TriviaRoundQuestionCreateArgs} args - Arguments to create a TriviaRoundQuestion.
     * @example
     * // Create one TriviaRoundQuestion
     * const TriviaRoundQuestion = await prisma.triviaRoundQuestion.create({
     *   data: {
     *     // ... data to create a TriviaRoundQuestion
     *   }
     * })
     * 
    **/
    create<T extends TriviaRoundQuestionCreateArgs>(
      args: SelectSubset<T, TriviaRoundQuestionCreateArgs>
    ): Prisma__TriviaRoundQuestionClient<TriviaRoundQuestionGetPayload<T>>

    /**
     * Create many TriviaRoundQuestions.
     *     @param {TriviaRoundQuestionCreateManyArgs} args - Arguments to create many TriviaRoundQuestions.
     *     @example
     *     // Create many TriviaRoundQuestions
     *     const triviaRoundQuestion = await prisma.triviaRoundQuestion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TriviaRoundQuestionCreateManyArgs>(
      args?: SelectSubset<T, TriviaRoundQuestionCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TriviaRoundQuestion.
     * @param {TriviaRoundQuestionDeleteArgs} args - Arguments to delete one TriviaRoundQuestion.
     * @example
     * // Delete one TriviaRoundQuestion
     * const TriviaRoundQuestion = await prisma.triviaRoundQuestion.delete({
     *   where: {
     *     // ... filter to delete one TriviaRoundQuestion
     *   }
     * })
     * 
    **/
    delete<T extends TriviaRoundQuestionDeleteArgs>(
      args: SelectSubset<T, TriviaRoundQuestionDeleteArgs>
    ): Prisma__TriviaRoundQuestionClient<TriviaRoundQuestionGetPayload<T>>

    /**
     * Update one TriviaRoundQuestion.
     * @param {TriviaRoundQuestionUpdateArgs} args - Arguments to update one TriviaRoundQuestion.
     * @example
     * // Update one TriviaRoundQuestion
     * const triviaRoundQuestion = await prisma.triviaRoundQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TriviaRoundQuestionUpdateArgs>(
      args: SelectSubset<T, TriviaRoundQuestionUpdateArgs>
    ): Prisma__TriviaRoundQuestionClient<TriviaRoundQuestionGetPayload<T>>

    /**
     * Delete zero or more TriviaRoundQuestions.
     * @param {TriviaRoundQuestionDeleteManyArgs} args - Arguments to filter TriviaRoundQuestions to delete.
     * @example
     * // Delete a few TriviaRoundQuestions
     * const { count } = await prisma.triviaRoundQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TriviaRoundQuestionDeleteManyArgs>(
      args?: SelectSubset<T, TriviaRoundQuestionDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TriviaRoundQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriviaRoundQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TriviaRoundQuestions
     * const triviaRoundQuestion = await prisma.triviaRoundQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TriviaRoundQuestionUpdateManyArgs>(
      args: SelectSubset<T, TriviaRoundQuestionUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TriviaRoundQuestion.
     * @param {TriviaRoundQuestionUpsertArgs} args - Arguments to update or create a TriviaRoundQuestion.
     * @example
     * // Update or create a TriviaRoundQuestion
     * const triviaRoundQuestion = await prisma.triviaRoundQuestion.upsert({
     *   create: {
     *     // ... data to create a TriviaRoundQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TriviaRoundQuestion we want to update
     *   }
     * })
    **/
    upsert<T extends TriviaRoundQuestionUpsertArgs>(
      args: SelectSubset<T, TriviaRoundQuestionUpsertArgs>
    ): Prisma__TriviaRoundQuestionClient<TriviaRoundQuestionGetPayload<T>>

    /**
     * Count the number of TriviaRoundQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriviaRoundQuestionCountArgs} args - Arguments to filter TriviaRoundQuestions to count.
     * @example
     * // Count the number of TriviaRoundQuestions
     * const count = await prisma.triviaRoundQuestion.count({
     *   where: {
     *     // ... the filter for the TriviaRoundQuestions we want to count
     *   }
     * })
    **/
    count<T extends TriviaRoundQuestionCountArgs>(
      args?: Subset<T, TriviaRoundQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TriviaRoundQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TriviaRoundQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriviaRoundQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TriviaRoundQuestionAggregateArgs>(args: Subset<T, TriviaRoundQuestionAggregateArgs>): Prisma.PrismaPromise<GetTriviaRoundQuestionAggregateType<T>>

    /**
     * Group by TriviaRoundQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriviaRoundQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TriviaRoundQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TriviaRoundQuestionGroupByArgs['orderBy'] }
        : { orderBy?: TriviaRoundQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TriviaRoundQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTriviaRoundQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TriviaRoundQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TriviaRoundQuestionClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    question<T extends TriviaQuestionArgs= {}>(args?: Subset<T, TriviaQuestionArgs>): Prisma__TriviaQuestionClient<TriviaQuestionGetPayload<T> | Null>;

    userChoice<T extends TriviaChoiceArgs= {}>(args?: Subset<T, TriviaChoiceArgs>): Prisma__TriviaChoiceClient<TriviaChoiceGetPayload<T> | Null>;

    round<T extends TriviaRoundArgs= {}>(args?: Subset<T, TriviaRoundArgs>): Prisma__TriviaRoundClient<TriviaRoundGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TriviaRoundQuestion base type for findUnique actions
   */
  export type TriviaRoundQuestionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TriviaRoundQuestion
     */
    select?: TriviaRoundQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaRoundQuestionInclude | null
    /**
     * Filter, which TriviaRoundQuestion to fetch.
     */
    where: TriviaRoundQuestionWhereUniqueInput
  }

  /**
   * TriviaRoundQuestion findUnique
   */
  export interface TriviaRoundQuestionFindUniqueArgs extends TriviaRoundQuestionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TriviaRoundQuestion findUniqueOrThrow
   */
  export type TriviaRoundQuestionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TriviaRoundQuestion
     */
    select?: TriviaRoundQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaRoundQuestionInclude | null
    /**
     * Filter, which TriviaRoundQuestion to fetch.
     */
    where: TriviaRoundQuestionWhereUniqueInput
  }


  /**
   * TriviaRoundQuestion base type for findFirst actions
   */
  export type TriviaRoundQuestionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TriviaRoundQuestion
     */
    select?: TriviaRoundQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaRoundQuestionInclude | null
    /**
     * Filter, which TriviaRoundQuestion to fetch.
     */
    where?: TriviaRoundQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TriviaRoundQuestions to fetch.
     */
    orderBy?: Enumerable<TriviaRoundQuestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TriviaRoundQuestions.
     */
    cursor?: TriviaRoundQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TriviaRoundQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TriviaRoundQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TriviaRoundQuestions.
     */
    distinct?: Enumerable<TriviaRoundQuestionScalarFieldEnum>
  }

  /**
   * TriviaRoundQuestion findFirst
   */
  export interface TriviaRoundQuestionFindFirstArgs extends TriviaRoundQuestionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TriviaRoundQuestion findFirstOrThrow
   */
  export type TriviaRoundQuestionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TriviaRoundQuestion
     */
    select?: TriviaRoundQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaRoundQuestionInclude | null
    /**
     * Filter, which TriviaRoundQuestion to fetch.
     */
    where?: TriviaRoundQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TriviaRoundQuestions to fetch.
     */
    orderBy?: Enumerable<TriviaRoundQuestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TriviaRoundQuestions.
     */
    cursor?: TriviaRoundQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TriviaRoundQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TriviaRoundQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TriviaRoundQuestions.
     */
    distinct?: Enumerable<TriviaRoundQuestionScalarFieldEnum>
  }


  /**
   * TriviaRoundQuestion findMany
   */
  export type TriviaRoundQuestionFindManyArgs = {
    /**
     * Select specific fields to fetch from the TriviaRoundQuestion
     */
    select?: TriviaRoundQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaRoundQuestionInclude | null
    /**
     * Filter, which TriviaRoundQuestions to fetch.
     */
    where?: TriviaRoundQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TriviaRoundQuestions to fetch.
     */
    orderBy?: Enumerable<TriviaRoundQuestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TriviaRoundQuestions.
     */
    cursor?: TriviaRoundQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TriviaRoundQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TriviaRoundQuestions.
     */
    skip?: number
    distinct?: Enumerable<TriviaRoundQuestionScalarFieldEnum>
  }


  /**
   * TriviaRoundQuestion create
   */
  export type TriviaRoundQuestionCreateArgs = {
    /**
     * Select specific fields to fetch from the TriviaRoundQuestion
     */
    select?: TriviaRoundQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaRoundQuestionInclude | null
    /**
     * The data needed to create a TriviaRoundQuestion.
     */
    data: XOR<TriviaRoundQuestionCreateInput, TriviaRoundQuestionUncheckedCreateInput>
  }


  /**
   * TriviaRoundQuestion createMany
   */
  export type TriviaRoundQuestionCreateManyArgs = {
    /**
     * The data used to create many TriviaRoundQuestions.
     */
    data: Enumerable<TriviaRoundQuestionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TriviaRoundQuestion update
   */
  export type TriviaRoundQuestionUpdateArgs = {
    /**
     * Select specific fields to fetch from the TriviaRoundQuestion
     */
    select?: TriviaRoundQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaRoundQuestionInclude | null
    /**
     * The data needed to update a TriviaRoundQuestion.
     */
    data: XOR<TriviaRoundQuestionUpdateInput, TriviaRoundQuestionUncheckedUpdateInput>
    /**
     * Choose, which TriviaRoundQuestion to update.
     */
    where: TriviaRoundQuestionWhereUniqueInput
  }


  /**
   * TriviaRoundQuestion updateMany
   */
  export type TriviaRoundQuestionUpdateManyArgs = {
    /**
     * The data used to update TriviaRoundQuestions.
     */
    data: XOR<TriviaRoundQuestionUpdateManyMutationInput, TriviaRoundQuestionUncheckedUpdateManyInput>
    /**
     * Filter which TriviaRoundQuestions to update
     */
    where?: TriviaRoundQuestionWhereInput
  }


  /**
   * TriviaRoundQuestion upsert
   */
  export type TriviaRoundQuestionUpsertArgs = {
    /**
     * Select specific fields to fetch from the TriviaRoundQuestion
     */
    select?: TriviaRoundQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaRoundQuestionInclude | null
    /**
     * The filter to search for the TriviaRoundQuestion to update in case it exists.
     */
    where: TriviaRoundQuestionWhereUniqueInput
    /**
     * In case the TriviaRoundQuestion found by the `where` argument doesn't exist, create a new TriviaRoundQuestion with this data.
     */
    create: XOR<TriviaRoundQuestionCreateInput, TriviaRoundQuestionUncheckedCreateInput>
    /**
     * In case the TriviaRoundQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TriviaRoundQuestionUpdateInput, TriviaRoundQuestionUncheckedUpdateInput>
  }


  /**
   * TriviaRoundQuestion delete
   */
  export type TriviaRoundQuestionDeleteArgs = {
    /**
     * Select specific fields to fetch from the TriviaRoundQuestion
     */
    select?: TriviaRoundQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaRoundQuestionInclude | null
    /**
     * Filter which TriviaRoundQuestion to delete.
     */
    where: TriviaRoundQuestionWhereUniqueInput
  }


  /**
   * TriviaRoundQuestion deleteMany
   */
  export type TriviaRoundQuestionDeleteManyArgs = {
    /**
     * Filter which TriviaRoundQuestions to delete
     */
    where?: TriviaRoundQuestionWhereInput
  }


  /**
   * TriviaRoundQuestion without action
   */
  export type TriviaRoundQuestionArgs = {
    /**
     * Select specific fields to fetch from the TriviaRoundQuestion
     */
    select?: TriviaRoundQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaRoundQuestionInclude | null
  }



  /**
   * Model TriviaRound
   */


  export type AggregateTriviaRound = {
    _count: TriviaRoundCountAggregateOutputType | null
    _avg: TriviaRoundAvgAggregateOutputType | null
    _sum: TriviaRoundSumAggregateOutputType | null
    _min: TriviaRoundMinAggregateOutputType | null
    _max: TriviaRoundMaxAggregateOutputType | null
  }

  export type TriviaRoundAvgAggregateOutputType = {
    id: number | null
    categoryId: number | null
    totalResult: number | null
  }

  export type TriviaRoundSumAggregateOutputType = {
    id: number | null
    categoryId: number | null
    totalResult: number | null
  }

  export type TriviaRoundMinAggregateOutputType = {
    id: number | null
    user: string | null
    categoryId: number | null
    totalResult: number | null
    createAt: Date | null
  }

  export type TriviaRoundMaxAggregateOutputType = {
    id: number | null
    user: string | null
    categoryId: number | null
    totalResult: number | null
    createAt: Date | null
  }

  export type TriviaRoundCountAggregateOutputType = {
    id: number
    user: number
    categoryId: number
    totalResult: number
    createAt: number
    _all: number
  }


  export type TriviaRoundAvgAggregateInputType = {
    id?: true
    categoryId?: true
    totalResult?: true
  }

  export type TriviaRoundSumAggregateInputType = {
    id?: true
    categoryId?: true
    totalResult?: true
  }

  export type TriviaRoundMinAggregateInputType = {
    id?: true
    user?: true
    categoryId?: true
    totalResult?: true
    createAt?: true
  }

  export type TriviaRoundMaxAggregateInputType = {
    id?: true
    user?: true
    categoryId?: true
    totalResult?: true
    createAt?: true
  }

  export type TriviaRoundCountAggregateInputType = {
    id?: true
    user?: true
    categoryId?: true
    totalResult?: true
    createAt?: true
    _all?: true
  }

  export type TriviaRoundAggregateArgs = {
    /**
     * Filter which TriviaRound to aggregate.
     */
    where?: TriviaRoundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TriviaRounds to fetch.
     */
    orderBy?: Enumerable<TriviaRoundOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TriviaRoundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TriviaRounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TriviaRounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TriviaRounds
    **/
    _count?: true | TriviaRoundCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TriviaRoundAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TriviaRoundSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TriviaRoundMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TriviaRoundMaxAggregateInputType
  }

  export type GetTriviaRoundAggregateType<T extends TriviaRoundAggregateArgs> = {
        [P in keyof T & keyof AggregateTriviaRound]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTriviaRound[P]>
      : GetScalarType<T[P], AggregateTriviaRound[P]>
  }




  export type TriviaRoundGroupByArgs = {
    where?: TriviaRoundWhereInput
    orderBy?: Enumerable<TriviaRoundOrderByWithAggregationInput>
    by: TriviaRoundScalarFieldEnum[]
    having?: TriviaRoundScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TriviaRoundCountAggregateInputType | true
    _avg?: TriviaRoundAvgAggregateInputType
    _sum?: TriviaRoundSumAggregateInputType
    _min?: TriviaRoundMinAggregateInputType
    _max?: TriviaRoundMaxAggregateInputType
  }


  export type TriviaRoundGroupByOutputType = {
    id: number
    user: string
    categoryId: number
    totalResult: number
    createAt: Date
    _count: TriviaRoundCountAggregateOutputType | null
    _avg: TriviaRoundAvgAggregateOutputType | null
    _sum: TriviaRoundSumAggregateOutputType | null
    _min: TriviaRoundMinAggregateOutputType | null
    _max: TriviaRoundMaxAggregateOutputType | null
  }

  type GetTriviaRoundGroupByPayload<T extends TriviaRoundGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TriviaRoundGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TriviaRoundGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TriviaRoundGroupByOutputType[P]>
            : GetScalarType<T[P], TriviaRoundGroupByOutputType[P]>
        }
      >
    >


  export type TriviaRoundSelect = {
    id?: boolean
    user?: boolean
    questions?: boolean | TriviaRound$questionsArgs
    category?: boolean | TriviaCategoryArgs
    categoryId?: boolean
    totalResult?: boolean
    createAt?: boolean
    _count?: boolean | TriviaRoundCountOutputTypeArgs
  }


  export type TriviaRoundInclude = {
    questions?: boolean | TriviaRound$questionsArgs
    category?: boolean | TriviaCategoryArgs
    _count?: boolean | TriviaRoundCountOutputTypeArgs
  }

  export type TriviaRoundGetPayload<S extends boolean | null | undefined | TriviaRoundArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TriviaRound :
    S extends undefined ? never :
    S extends { include: any } & (TriviaRoundArgs | TriviaRoundFindManyArgs)
    ? TriviaRound  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'questions' ? Array < TriviaRoundQuestionGetPayload<S['include'][P]>>  :
        P extends 'category' ? TriviaCategoryGetPayload<S['include'][P]> :
        P extends '_count' ? TriviaRoundCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TriviaRoundArgs | TriviaRoundFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'questions' ? Array < TriviaRoundQuestionGetPayload<S['select'][P]>>  :
        P extends 'category' ? TriviaCategoryGetPayload<S['select'][P]> :
        P extends '_count' ? TriviaRoundCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof TriviaRound ? TriviaRound[P] : never
  } 
      : TriviaRound


  type TriviaRoundCountArgs = 
    Omit<TriviaRoundFindManyArgs, 'select' | 'include'> & {
      select?: TriviaRoundCountAggregateInputType | true
    }

  export interface TriviaRoundDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TriviaRound that matches the filter.
     * @param {TriviaRoundFindUniqueArgs} args - Arguments to find a TriviaRound
     * @example
     * // Get one TriviaRound
     * const triviaRound = await prisma.triviaRound.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TriviaRoundFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TriviaRoundFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TriviaRound'> extends True ? Prisma__TriviaRoundClient<TriviaRoundGetPayload<T>> : Prisma__TriviaRoundClient<TriviaRoundGetPayload<T> | null, null>

    /**
     * Find one TriviaRound that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TriviaRoundFindUniqueOrThrowArgs} args - Arguments to find a TriviaRound
     * @example
     * // Get one TriviaRound
     * const triviaRound = await prisma.triviaRound.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TriviaRoundFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TriviaRoundFindUniqueOrThrowArgs>
    ): Prisma__TriviaRoundClient<TriviaRoundGetPayload<T>>

    /**
     * Find the first TriviaRound that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriviaRoundFindFirstArgs} args - Arguments to find a TriviaRound
     * @example
     * // Get one TriviaRound
     * const triviaRound = await prisma.triviaRound.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TriviaRoundFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TriviaRoundFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TriviaRound'> extends True ? Prisma__TriviaRoundClient<TriviaRoundGetPayload<T>> : Prisma__TriviaRoundClient<TriviaRoundGetPayload<T> | null, null>

    /**
     * Find the first TriviaRound that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriviaRoundFindFirstOrThrowArgs} args - Arguments to find a TriviaRound
     * @example
     * // Get one TriviaRound
     * const triviaRound = await prisma.triviaRound.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TriviaRoundFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TriviaRoundFindFirstOrThrowArgs>
    ): Prisma__TriviaRoundClient<TriviaRoundGetPayload<T>>

    /**
     * Find zero or more TriviaRounds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriviaRoundFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TriviaRounds
     * const triviaRounds = await prisma.triviaRound.findMany()
     * 
     * // Get first 10 TriviaRounds
     * const triviaRounds = await prisma.triviaRound.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const triviaRoundWithIdOnly = await prisma.triviaRound.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TriviaRoundFindManyArgs>(
      args?: SelectSubset<T, TriviaRoundFindManyArgs>
    ): Prisma.PrismaPromise<Array<TriviaRoundGetPayload<T>>>

    /**
     * Create a TriviaRound.
     * @param {TriviaRoundCreateArgs} args - Arguments to create a TriviaRound.
     * @example
     * // Create one TriviaRound
     * const TriviaRound = await prisma.triviaRound.create({
     *   data: {
     *     // ... data to create a TriviaRound
     *   }
     * })
     * 
    **/
    create<T extends TriviaRoundCreateArgs>(
      args: SelectSubset<T, TriviaRoundCreateArgs>
    ): Prisma__TriviaRoundClient<TriviaRoundGetPayload<T>>

    /**
     * Create many TriviaRounds.
     *     @param {TriviaRoundCreateManyArgs} args - Arguments to create many TriviaRounds.
     *     @example
     *     // Create many TriviaRounds
     *     const triviaRound = await prisma.triviaRound.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TriviaRoundCreateManyArgs>(
      args?: SelectSubset<T, TriviaRoundCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TriviaRound.
     * @param {TriviaRoundDeleteArgs} args - Arguments to delete one TriviaRound.
     * @example
     * // Delete one TriviaRound
     * const TriviaRound = await prisma.triviaRound.delete({
     *   where: {
     *     // ... filter to delete one TriviaRound
     *   }
     * })
     * 
    **/
    delete<T extends TriviaRoundDeleteArgs>(
      args: SelectSubset<T, TriviaRoundDeleteArgs>
    ): Prisma__TriviaRoundClient<TriviaRoundGetPayload<T>>

    /**
     * Update one TriviaRound.
     * @param {TriviaRoundUpdateArgs} args - Arguments to update one TriviaRound.
     * @example
     * // Update one TriviaRound
     * const triviaRound = await prisma.triviaRound.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TriviaRoundUpdateArgs>(
      args: SelectSubset<T, TriviaRoundUpdateArgs>
    ): Prisma__TriviaRoundClient<TriviaRoundGetPayload<T>>

    /**
     * Delete zero or more TriviaRounds.
     * @param {TriviaRoundDeleteManyArgs} args - Arguments to filter TriviaRounds to delete.
     * @example
     * // Delete a few TriviaRounds
     * const { count } = await prisma.triviaRound.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TriviaRoundDeleteManyArgs>(
      args?: SelectSubset<T, TriviaRoundDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TriviaRounds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriviaRoundUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TriviaRounds
     * const triviaRound = await prisma.triviaRound.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TriviaRoundUpdateManyArgs>(
      args: SelectSubset<T, TriviaRoundUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TriviaRound.
     * @param {TriviaRoundUpsertArgs} args - Arguments to update or create a TriviaRound.
     * @example
     * // Update or create a TriviaRound
     * const triviaRound = await prisma.triviaRound.upsert({
     *   create: {
     *     // ... data to create a TriviaRound
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TriviaRound we want to update
     *   }
     * })
    **/
    upsert<T extends TriviaRoundUpsertArgs>(
      args: SelectSubset<T, TriviaRoundUpsertArgs>
    ): Prisma__TriviaRoundClient<TriviaRoundGetPayload<T>>

    /**
     * Count the number of TriviaRounds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriviaRoundCountArgs} args - Arguments to filter TriviaRounds to count.
     * @example
     * // Count the number of TriviaRounds
     * const count = await prisma.triviaRound.count({
     *   where: {
     *     // ... the filter for the TriviaRounds we want to count
     *   }
     * })
    **/
    count<T extends TriviaRoundCountArgs>(
      args?: Subset<T, TriviaRoundCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TriviaRoundCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TriviaRound.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriviaRoundAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TriviaRoundAggregateArgs>(args: Subset<T, TriviaRoundAggregateArgs>): Prisma.PrismaPromise<GetTriviaRoundAggregateType<T>>

    /**
     * Group by TriviaRound.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriviaRoundGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TriviaRoundGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TriviaRoundGroupByArgs['orderBy'] }
        : { orderBy?: TriviaRoundGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TriviaRoundGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTriviaRoundGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TriviaRound.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TriviaRoundClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    questions<T extends TriviaRound$questionsArgs= {}>(args?: Subset<T, TriviaRound$questionsArgs>): Prisma.PrismaPromise<Array<TriviaRoundQuestionGetPayload<T>>| Null>;

    category<T extends TriviaCategoryArgs= {}>(args?: Subset<T, TriviaCategoryArgs>): Prisma__TriviaCategoryClient<TriviaCategoryGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TriviaRound base type for findUnique actions
   */
  export type TriviaRoundFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TriviaRound
     */
    select?: TriviaRoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaRoundInclude | null
    /**
     * Filter, which TriviaRound to fetch.
     */
    where: TriviaRoundWhereUniqueInput
  }

  /**
   * TriviaRound findUnique
   */
  export interface TriviaRoundFindUniqueArgs extends TriviaRoundFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TriviaRound findUniqueOrThrow
   */
  export type TriviaRoundFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TriviaRound
     */
    select?: TriviaRoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaRoundInclude | null
    /**
     * Filter, which TriviaRound to fetch.
     */
    where: TriviaRoundWhereUniqueInput
  }


  /**
   * TriviaRound base type for findFirst actions
   */
  export type TriviaRoundFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TriviaRound
     */
    select?: TriviaRoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaRoundInclude | null
    /**
     * Filter, which TriviaRound to fetch.
     */
    where?: TriviaRoundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TriviaRounds to fetch.
     */
    orderBy?: Enumerable<TriviaRoundOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TriviaRounds.
     */
    cursor?: TriviaRoundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TriviaRounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TriviaRounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TriviaRounds.
     */
    distinct?: Enumerable<TriviaRoundScalarFieldEnum>
  }

  /**
   * TriviaRound findFirst
   */
  export interface TriviaRoundFindFirstArgs extends TriviaRoundFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TriviaRound findFirstOrThrow
   */
  export type TriviaRoundFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TriviaRound
     */
    select?: TriviaRoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaRoundInclude | null
    /**
     * Filter, which TriviaRound to fetch.
     */
    where?: TriviaRoundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TriviaRounds to fetch.
     */
    orderBy?: Enumerable<TriviaRoundOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TriviaRounds.
     */
    cursor?: TriviaRoundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TriviaRounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TriviaRounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TriviaRounds.
     */
    distinct?: Enumerable<TriviaRoundScalarFieldEnum>
  }


  /**
   * TriviaRound findMany
   */
  export type TriviaRoundFindManyArgs = {
    /**
     * Select specific fields to fetch from the TriviaRound
     */
    select?: TriviaRoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaRoundInclude | null
    /**
     * Filter, which TriviaRounds to fetch.
     */
    where?: TriviaRoundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TriviaRounds to fetch.
     */
    orderBy?: Enumerable<TriviaRoundOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TriviaRounds.
     */
    cursor?: TriviaRoundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TriviaRounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TriviaRounds.
     */
    skip?: number
    distinct?: Enumerable<TriviaRoundScalarFieldEnum>
  }


  /**
   * TriviaRound create
   */
  export type TriviaRoundCreateArgs = {
    /**
     * Select specific fields to fetch from the TriviaRound
     */
    select?: TriviaRoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaRoundInclude | null
    /**
     * The data needed to create a TriviaRound.
     */
    data: XOR<TriviaRoundCreateInput, TriviaRoundUncheckedCreateInput>
  }


  /**
   * TriviaRound createMany
   */
  export type TriviaRoundCreateManyArgs = {
    /**
     * The data used to create many TriviaRounds.
     */
    data: Enumerable<TriviaRoundCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TriviaRound update
   */
  export type TriviaRoundUpdateArgs = {
    /**
     * Select specific fields to fetch from the TriviaRound
     */
    select?: TriviaRoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaRoundInclude | null
    /**
     * The data needed to update a TriviaRound.
     */
    data: XOR<TriviaRoundUpdateInput, TriviaRoundUncheckedUpdateInput>
    /**
     * Choose, which TriviaRound to update.
     */
    where: TriviaRoundWhereUniqueInput
  }


  /**
   * TriviaRound updateMany
   */
  export type TriviaRoundUpdateManyArgs = {
    /**
     * The data used to update TriviaRounds.
     */
    data: XOR<TriviaRoundUpdateManyMutationInput, TriviaRoundUncheckedUpdateManyInput>
    /**
     * Filter which TriviaRounds to update
     */
    where?: TriviaRoundWhereInput
  }


  /**
   * TriviaRound upsert
   */
  export type TriviaRoundUpsertArgs = {
    /**
     * Select specific fields to fetch from the TriviaRound
     */
    select?: TriviaRoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaRoundInclude | null
    /**
     * The filter to search for the TriviaRound to update in case it exists.
     */
    where: TriviaRoundWhereUniqueInput
    /**
     * In case the TriviaRound found by the `where` argument doesn't exist, create a new TriviaRound with this data.
     */
    create: XOR<TriviaRoundCreateInput, TriviaRoundUncheckedCreateInput>
    /**
     * In case the TriviaRound was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TriviaRoundUpdateInput, TriviaRoundUncheckedUpdateInput>
  }


  /**
   * TriviaRound delete
   */
  export type TriviaRoundDeleteArgs = {
    /**
     * Select specific fields to fetch from the TriviaRound
     */
    select?: TriviaRoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaRoundInclude | null
    /**
     * Filter which TriviaRound to delete.
     */
    where: TriviaRoundWhereUniqueInput
  }


  /**
   * TriviaRound deleteMany
   */
  export type TriviaRoundDeleteManyArgs = {
    /**
     * Filter which TriviaRounds to delete
     */
    where?: TriviaRoundWhereInput
  }


  /**
   * TriviaRound.questions
   */
  export type TriviaRound$questionsArgs = {
    /**
     * Select specific fields to fetch from the TriviaRoundQuestion
     */
    select?: TriviaRoundQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaRoundQuestionInclude | null
    where?: TriviaRoundQuestionWhereInput
    orderBy?: Enumerable<TriviaRoundQuestionOrderByWithRelationInput>
    cursor?: TriviaRoundQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TriviaRoundQuestionScalarFieldEnum>
  }


  /**
   * TriviaRound without action
   */
  export type TriviaRoundArgs = {
    /**
     * Select specific fields to fetch from the TriviaRound
     */
    select?: TriviaRoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TriviaRoundInclude | null
  }



  /**
   * Model TwitterUser
   */


  export type AggregateTwitterUser = {
    _count: TwitterUserCountAggregateOutputType | null
    _avg: TwitterUserAvgAggregateOutputType | null
    _sum: TwitterUserSumAggregateOutputType | null
    _min: TwitterUserMinAggregateOutputType | null
    _max: TwitterUserMaxAggregateOutputType | null
  }

  export type TwitterUserAvgAggregateOutputType = {
    id: number | null
  }

  export type TwitterUserSumAggregateOutputType = {
    id: number | null
  }

  export type TwitterUserMinAggregateOutputType = {
    id: number | null
    name: string | null
    Image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TwitterUserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    Image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TwitterUserCountAggregateOutputType = {
    id: number
    name: number
    Image: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TwitterUserAvgAggregateInputType = {
    id?: true
  }

  export type TwitterUserSumAggregateInputType = {
    id?: true
  }

  export type TwitterUserMinAggregateInputType = {
    id?: true
    name?: true
    Image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TwitterUserMaxAggregateInputType = {
    id?: true
    name?: true
    Image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TwitterUserCountAggregateInputType = {
    id?: true
    name?: true
    Image?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TwitterUserAggregateArgs = {
    /**
     * Filter which TwitterUser to aggregate.
     */
    where?: TwitterUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterUsers to fetch.
     */
    orderBy?: Enumerable<TwitterUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TwitterUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TwitterUsers
    **/
    _count?: true | TwitterUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TwitterUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TwitterUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TwitterUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TwitterUserMaxAggregateInputType
  }

  export type GetTwitterUserAggregateType<T extends TwitterUserAggregateArgs> = {
        [P in keyof T & keyof AggregateTwitterUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTwitterUser[P]>
      : GetScalarType<T[P], AggregateTwitterUser[P]>
  }




  export type TwitterUserGroupByArgs = {
    where?: TwitterUserWhereInput
    orderBy?: Enumerable<TwitterUserOrderByWithAggregationInput>
    by: TwitterUserScalarFieldEnum[]
    having?: TwitterUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TwitterUserCountAggregateInputType | true
    _avg?: TwitterUserAvgAggregateInputType
    _sum?: TwitterUserSumAggregateInputType
    _min?: TwitterUserMinAggregateInputType
    _max?: TwitterUserMaxAggregateInputType
  }


  export type TwitterUserGroupByOutputType = {
    id: number
    name: string
    Image: string
    createdAt: Date
    updatedAt: Date
    _count: TwitterUserCountAggregateOutputType | null
    _avg: TwitterUserAvgAggregateOutputType | null
    _sum: TwitterUserSumAggregateOutputType | null
    _min: TwitterUserMinAggregateOutputType | null
    _max: TwitterUserMaxAggregateOutputType | null
  }

  type GetTwitterUserGroupByPayload<T extends TwitterUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TwitterUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TwitterUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TwitterUserGroupByOutputType[P]>
            : GetScalarType<T[P], TwitterUserGroupByOutputType[P]>
        }
      >
    >


  export type TwitterUserSelect = {
    id?: boolean
    name?: boolean
    Image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fromFollowing?: boolean | TwitterUser$fromFollowingArgs
    toFollowing?: boolean | TwitterUser$toFollowingArgs
    posts?: boolean | TwitterUser$postsArgs
    fromDirectMessage?: boolean | TwitterUser$fromDirectMessageArgs
    toDirectMessage?: boolean | TwitterUser$toDirectMessageArgs
    comments?: boolean | TwitterUser$commentsArgs
    _count?: boolean | TwitterUserCountOutputTypeArgs
  }


  export type TwitterUserInclude = {
    fromFollowing?: boolean | TwitterUser$fromFollowingArgs
    toFollowing?: boolean | TwitterUser$toFollowingArgs
    posts?: boolean | TwitterUser$postsArgs
    fromDirectMessage?: boolean | TwitterUser$fromDirectMessageArgs
    toDirectMessage?: boolean | TwitterUser$toDirectMessageArgs
    comments?: boolean | TwitterUser$commentsArgs
    _count?: boolean | TwitterUserCountOutputTypeArgs
  }

  export type TwitterUserGetPayload<S extends boolean | null | undefined | TwitterUserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TwitterUser :
    S extends undefined ? never :
    S extends { include: any } & (TwitterUserArgs | TwitterUserFindManyArgs)
    ? TwitterUser  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'fromFollowing' ? Array < TwitterFollowGetPayload<S['include'][P]>>  :
        P extends 'toFollowing' ? Array < TwitterFollowGetPayload<S['include'][P]>>  :
        P extends 'posts' ? Array < TwitterPostGetPayload<S['include'][P]>>  :
        P extends 'fromDirectMessage' ? Array < TwitterDirectMessageGetPayload<S['include'][P]>>  :
        P extends 'toDirectMessage' ? Array < TwitterDirectMessageGetPayload<S['include'][P]>>  :
        P extends 'comments' ? Array < TwitterCommentGetPayload<S['include'][P]>>  :
        P extends '_count' ? TwitterUserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TwitterUserArgs | TwitterUserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'fromFollowing' ? Array < TwitterFollowGetPayload<S['select'][P]>>  :
        P extends 'toFollowing' ? Array < TwitterFollowGetPayload<S['select'][P]>>  :
        P extends 'posts' ? Array < TwitterPostGetPayload<S['select'][P]>>  :
        P extends 'fromDirectMessage' ? Array < TwitterDirectMessageGetPayload<S['select'][P]>>  :
        P extends 'toDirectMessage' ? Array < TwitterDirectMessageGetPayload<S['select'][P]>>  :
        P extends 'comments' ? Array < TwitterCommentGetPayload<S['select'][P]>>  :
        P extends '_count' ? TwitterUserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof TwitterUser ? TwitterUser[P] : never
  } 
      : TwitterUser


  type TwitterUserCountArgs = 
    Omit<TwitterUserFindManyArgs, 'select' | 'include'> & {
      select?: TwitterUserCountAggregateInputType | true
    }

  export interface TwitterUserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TwitterUser that matches the filter.
     * @param {TwitterUserFindUniqueArgs} args - Arguments to find a TwitterUser
     * @example
     * // Get one TwitterUser
     * const twitterUser = await prisma.twitterUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TwitterUserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TwitterUserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TwitterUser'> extends True ? Prisma__TwitterUserClient<TwitterUserGetPayload<T>> : Prisma__TwitterUserClient<TwitterUserGetPayload<T> | null, null>

    /**
     * Find one TwitterUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TwitterUserFindUniqueOrThrowArgs} args - Arguments to find a TwitterUser
     * @example
     * // Get one TwitterUser
     * const twitterUser = await prisma.twitterUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TwitterUserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TwitterUserFindUniqueOrThrowArgs>
    ): Prisma__TwitterUserClient<TwitterUserGetPayload<T>>

    /**
     * Find the first TwitterUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterUserFindFirstArgs} args - Arguments to find a TwitterUser
     * @example
     * // Get one TwitterUser
     * const twitterUser = await prisma.twitterUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TwitterUserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TwitterUserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TwitterUser'> extends True ? Prisma__TwitterUserClient<TwitterUserGetPayload<T>> : Prisma__TwitterUserClient<TwitterUserGetPayload<T> | null, null>

    /**
     * Find the first TwitterUser that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterUserFindFirstOrThrowArgs} args - Arguments to find a TwitterUser
     * @example
     * // Get one TwitterUser
     * const twitterUser = await prisma.twitterUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TwitterUserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TwitterUserFindFirstOrThrowArgs>
    ): Prisma__TwitterUserClient<TwitterUserGetPayload<T>>

    /**
     * Find zero or more TwitterUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TwitterUsers
     * const twitterUsers = await prisma.twitterUser.findMany()
     * 
     * // Get first 10 TwitterUsers
     * const twitterUsers = await prisma.twitterUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const twitterUserWithIdOnly = await prisma.twitterUser.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TwitterUserFindManyArgs>(
      args?: SelectSubset<T, TwitterUserFindManyArgs>
    ): Prisma.PrismaPromise<Array<TwitterUserGetPayload<T>>>

    /**
     * Create a TwitterUser.
     * @param {TwitterUserCreateArgs} args - Arguments to create a TwitterUser.
     * @example
     * // Create one TwitterUser
     * const TwitterUser = await prisma.twitterUser.create({
     *   data: {
     *     // ... data to create a TwitterUser
     *   }
     * })
     * 
    **/
    create<T extends TwitterUserCreateArgs>(
      args: SelectSubset<T, TwitterUserCreateArgs>
    ): Prisma__TwitterUserClient<TwitterUserGetPayload<T>>

    /**
     * Create many TwitterUsers.
     *     @param {TwitterUserCreateManyArgs} args - Arguments to create many TwitterUsers.
     *     @example
     *     // Create many TwitterUsers
     *     const twitterUser = await prisma.twitterUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TwitterUserCreateManyArgs>(
      args?: SelectSubset<T, TwitterUserCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TwitterUser.
     * @param {TwitterUserDeleteArgs} args - Arguments to delete one TwitterUser.
     * @example
     * // Delete one TwitterUser
     * const TwitterUser = await prisma.twitterUser.delete({
     *   where: {
     *     // ... filter to delete one TwitterUser
     *   }
     * })
     * 
    **/
    delete<T extends TwitterUserDeleteArgs>(
      args: SelectSubset<T, TwitterUserDeleteArgs>
    ): Prisma__TwitterUserClient<TwitterUserGetPayload<T>>

    /**
     * Update one TwitterUser.
     * @param {TwitterUserUpdateArgs} args - Arguments to update one TwitterUser.
     * @example
     * // Update one TwitterUser
     * const twitterUser = await prisma.twitterUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TwitterUserUpdateArgs>(
      args: SelectSubset<T, TwitterUserUpdateArgs>
    ): Prisma__TwitterUserClient<TwitterUserGetPayload<T>>

    /**
     * Delete zero or more TwitterUsers.
     * @param {TwitterUserDeleteManyArgs} args - Arguments to filter TwitterUsers to delete.
     * @example
     * // Delete a few TwitterUsers
     * const { count } = await prisma.twitterUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TwitterUserDeleteManyArgs>(
      args?: SelectSubset<T, TwitterUserDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TwitterUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TwitterUsers
     * const twitterUser = await prisma.twitterUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TwitterUserUpdateManyArgs>(
      args: SelectSubset<T, TwitterUserUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TwitterUser.
     * @param {TwitterUserUpsertArgs} args - Arguments to update or create a TwitterUser.
     * @example
     * // Update or create a TwitterUser
     * const twitterUser = await prisma.twitterUser.upsert({
     *   create: {
     *     // ... data to create a TwitterUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TwitterUser we want to update
     *   }
     * })
    **/
    upsert<T extends TwitterUserUpsertArgs>(
      args: SelectSubset<T, TwitterUserUpsertArgs>
    ): Prisma__TwitterUserClient<TwitterUserGetPayload<T>>

    /**
     * Count the number of TwitterUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterUserCountArgs} args - Arguments to filter TwitterUsers to count.
     * @example
     * // Count the number of TwitterUsers
     * const count = await prisma.twitterUser.count({
     *   where: {
     *     // ... the filter for the TwitterUsers we want to count
     *   }
     * })
    **/
    count<T extends TwitterUserCountArgs>(
      args?: Subset<T, TwitterUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TwitterUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TwitterUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TwitterUserAggregateArgs>(args: Subset<T, TwitterUserAggregateArgs>): Prisma.PrismaPromise<GetTwitterUserAggregateType<T>>

    /**
     * Group by TwitterUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TwitterUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TwitterUserGroupByArgs['orderBy'] }
        : { orderBy?: TwitterUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TwitterUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTwitterUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TwitterUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TwitterUserClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    fromFollowing<T extends TwitterUser$fromFollowingArgs= {}>(args?: Subset<T, TwitterUser$fromFollowingArgs>): Prisma.PrismaPromise<Array<TwitterFollowGetPayload<T>>| Null>;

    toFollowing<T extends TwitterUser$toFollowingArgs= {}>(args?: Subset<T, TwitterUser$toFollowingArgs>): Prisma.PrismaPromise<Array<TwitterFollowGetPayload<T>>| Null>;

    posts<T extends TwitterUser$postsArgs= {}>(args?: Subset<T, TwitterUser$postsArgs>): Prisma.PrismaPromise<Array<TwitterPostGetPayload<T>>| Null>;

    fromDirectMessage<T extends TwitterUser$fromDirectMessageArgs= {}>(args?: Subset<T, TwitterUser$fromDirectMessageArgs>): Prisma.PrismaPromise<Array<TwitterDirectMessageGetPayload<T>>| Null>;

    toDirectMessage<T extends TwitterUser$toDirectMessageArgs= {}>(args?: Subset<T, TwitterUser$toDirectMessageArgs>): Prisma.PrismaPromise<Array<TwitterDirectMessageGetPayload<T>>| Null>;

    comments<T extends TwitterUser$commentsArgs= {}>(args?: Subset<T, TwitterUser$commentsArgs>): Prisma.PrismaPromise<Array<TwitterCommentGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TwitterUser base type for findUnique actions
   */
  export type TwitterUserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TwitterUser
     */
    select?: TwitterUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserInclude | null
    /**
     * Filter, which TwitterUser to fetch.
     */
    where: TwitterUserWhereUniqueInput
  }

  /**
   * TwitterUser findUnique
   */
  export interface TwitterUserFindUniqueArgs extends TwitterUserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TwitterUser findUniqueOrThrow
   */
  export type TwitterUserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TwitterUser
     */
    select?: TwitterUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserInclude | null
    /**
     * Filter, which TwitterUser to fetch.
     */
    where: TwitterUserWhereUniqueInput
  }


  /**
   * TwitterUser base type for findFirst actions
   */
  export type TwitterUserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TwitterUser
     */
    select?: TwitterUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserInclude | null
    /**
     * Filter, which TwitterUser to fetch.
     */
    where?: TwitterUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterUsers to fetch.
     */
    orderBy?: Enumerable<TwitterUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterUsers.
     */
    cursor?: TwitterUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterUsers.
     */
    distinct?: Enumerable<TwitterUserScalarFieldEnum>
  }

  /**
   * TwitterUser findFirst
   */
  export interface TwitterUserFindFirstArgs extends TwitterUserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TwitterUser findFirstOrThrow
   */
  export type TwitterUserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TwitterUser
     */
    select?: TwitterUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserInclude | null
    /**
     * Filter, which TwitterUser to fetch.
     */
    where?: TwitterUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterUsers to fetch.
     */
    orderBy?: Enumerable<TwitterUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterUsers.
     */
    cursor?: TwitterUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterUsers.
     */
    distinct?: Enumerable<TwitterUserScalarFieldEnum>
  }


  /**
   * TwitterUser findMany
   */
  export type TwitterUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the TwitterUser
     */
    select?: TwitterUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserInclude | null
    /**
     * Filter, which TwitterUsers to fetch.
     */
    where?: TwitterUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterUsers to fetch.
     */
    orderBy?: Enumerable<TwitterUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TwitterUsers.
     */
    cursor?: TwitterUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterUsers.
     */
    skip?: number
    distinct?: Enumerable<TwitterUserScalarFieldEnum>
  }


  /**
   * TwitterUser create
   */
  export type TwitterUserCreateArgs = {
    /**
     * Select specific fields to fetch from the TwitterUser
     */
    select?: TwitterUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserInclude | null
    /**
     * The data needed to create a TwitterUser.
     */
    data: XOR<TwitterUserCreateInput, TwitterUserUncheckedCreateInput>
  }


  /**
   * TwitterUser createMany
   */
  export type TwitterUserCreateManyArgs = {
    /**
     * The data used to create many TwitterUsers.
     */
    data: Enumerable<TwitterUserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TwitterUser update
   */
  export type TwitterUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the TwitterUser
     */
    select?: TwitterUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserInclude | null
    /**
     * The data needed to update a TwitterUser.
     */
    data: XOR<TwitterUserUpdateInput, TwitterUserUncheckedUpdateInput>
    /**
     * Choose, which TwitterUser to update.
     */
    where: TwitterUserWhereUniqueInput
  }


  /**
   * TwitterUser updateMany
   */
  export type TwitterUserUpdateManyArgs = {
    /**
     * The data used to update TwitterUsers.
     */
    data: XOR<TwitterUserUpdateManyMutationInput, TwitterUserUncheckedUpdateManyInput>
    /**
     * Filter which TwitterUsers to update
     */
    where?: TwitterUserWhereInput
  }


  /**
   * TwitterUser upsert
   */
  export type TwitterUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the TwitterUser
     */
    select?: TwitterUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserInclude | null
    /**
     * The filter to search for the TwitterUser to update in case it exists.
     */
    where: TwitterUserWhereUniqueInput
    /**
     * In case the TwitterUser found by the `where` argument doesn't exist, create a new TwitterUser with this data.
     */
    create: XOR<TwitterUserCreateInput, TwitterUserUncheckedCreateInput>
    /**
     * In case the TwitterUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TwitterUserUpdateInput, TwitterUserUncheckedUpdateInput>
  }


  /**
   * TwitterUser delete
   */
  export type TwitterUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the TwitterUser
     */
    select?: TwitterUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserInclude | null
    /**
     * Filter which TwitterUser to delete.
     */
    where: TwitterUserWhereUniqueInput
  }


  /**
   * TwitterUser deleteMany
   */
  export type TwitterUserDeleteManyArgs = {
    /**
     * Filter which TwitterUsers to delete
     */
    where?: TwitterUserWhereInput
  }


  /**
   * TwitterUser.fromFollowing
   */
  export type TwitterUser$fromFollowingArgs = {
    /**
     * Select specific fields to fetch from the TwitterFollow
     */
    select?: TwitterFollowSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterFollowInclude | null
    where?: TwitterFollowWhereInput
    orderBy?: Enumerable<TwitterFollowOrderByWithRelationInput>
    cursor?: TwitterFollowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TwitterFollowScalarFieldEnum>
  }


  /**
   * TwitterUser.toFollowing
   */
  export type TwitterUser$toFollowingArgs = {
    /**
     * Select specific fields to fetch from the TwitterFollow
     */
    select?: TwitterFollowSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterFollowInclude | null
    where?: TwitterFollowWhereInput
    orderBy?: Enumerable<TwitterFollowOrderByWithRelationInput>
    cursor?: TwitterFollowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TwitterFollowScalarFieldEnum>
  }


  /**
   * TwitterUser.posts
   */
  export type TwitterUser$postsArgs = {
    /**
     * Select specific fields to fetch from the TwitterPost
     */
    select?: TwitterPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostInclude | null
    where?: TwitterPostWhereInput
    orderBy?: Enumerable<TwitterPostOrderByWithRelationInput>
    cursor?: TwitterPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TwitterPostScalarFieldEnum>
  }


  /**
   * TwitterUser.fromDirectMessage
   */
  export type TwitterUser$fromDirectMessageArgs = {
    /**
     * Select specific fields to fetch from the TwitterDirectMessage
     */
    select?: TwitterDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterDirectMessageInclude | null
    where?: TwitterDirectMessageWhereInput
    orderBy?: Enumerable<TwitterDirectMessageOrderByWithRelationInput>
    cursor?: TwitterDirectMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TwitterDirectMessageScalarFieldEnum>
  }


  /**
   * TwitterUser.toDirectMessage
   */
  export type TwitterUser$toDirectMessageArgs = {
    /**
     * Select specific fields to fetch from the TwitterDirectMessage
     */
    select?: TwitterDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterDirectMessageInclude | null
    where?: TwitterDirectMessageWhereInput
    orderBy?: Enumerable<TwitterDirectMessageOrderByWithRelationInput>
    cursor?: TwitterDirectMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TwitterDirectMessageScalarFieldEnum>
  }


  /**
   * TwitterUser.comments
   */
  export type TwitterUser$commentsArgs = {
    /**
     * Select specific fields to fetch from the TwitterComment
     */
    select?: TwitterCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterCommentInclude | null
    where?: TwitterCommentWhereInput
    orderBy?: Enumerable<TwitterCommentOrderByWithRelationInput>
    cursor?: TwitterCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TwitterCommentScalarFieldEnum>
  }


  /**
   * TwitterUser without action
   */
  export type TwitterUserArgs = {
    /**
     * Select specific fields to fetch from the TwitterUser
     */
    select?: TwitterUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserInclude | null
  }



  /**
   * Model TwitterFollow
   */


  export type AggregateTwitterFollow = {
    _count: TwitterFollowCountAggregateOutputType | null
    _avg: TwitterFollowAvgAggregateOutputType | null
    _sum: TwitterFollowSumAggregateOutputType | null
    _min: TwitterFollowMinAggregateOutputType | null
    _max: TwitterFollowMaxAggregateOutputType | null
  }

  export type TwitterFollowAvgAggregateOutputType = {
    id: number | null
    fromUserId: number | null
    toUserId: number | null
  }

  export type TwitterFollowSumAggregateOutputType = {
    id: number | null
    fromUserId: number | null
    toUserId: number | null
  }

  export type TwitterFollowMinAggregateOutputType = {
    id: number | null
    fromUserId: number | null
    toUserId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TwitterFollowMaxAggregateOutputType = {
    id: number | null
    fromUserId: number | null
    toUserId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TwitterFollowCountAggregateOutputType = {
    id: number
    fromUserId: number
    toUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TwitterFollowAvgAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
  }

  export type TwitterFollowSumAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
  }

  export type TwitterFollowMinAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TwitterFollowMaxAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TwitterFollowCountAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TwitterFollowAggregateArgs = {
    /**
     * Filter which TwitterFollow to aggregate.
     */
    where?: TwitterFollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterFollows to fetch.
     */
    orderBy?: Enumerable<TwitterFollowOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TwitterFollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterFollows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterFollows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TwitterFollows
    **/
    _count?: true | TwitterFollowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TwitterFollowAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TwitterFollowSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TwitterFollowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TwitterFollowMaxAggregateInputType
  }

  export type GetTwitterFollowAggregateType<T extends TwitterFollowAggregateArgs> = {
        [P in keyof T & keyof AggregateTwitterFollow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTwitterFollow[P]>
      : GetScalarType<T[P], AggregateTwitterFollow[P]>
  }




  export type TwitterFollowGroupByArgs = {
    where?: TwitterFollowWhereInput
    orderBy?: Enumerable<TwitterFollowOrderByWithAggregationInput>
    by: TwitterFollowScalarFieldEnum[]
    having?: TwitterFollowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TwitterFollowCountAggregateInputType | true
    _avg?: TwitterFollowAvgAggregateInputType
    _sum?: TwitterFollowSumAggregateInputType
    _min?: TwitterFollowMinAggregateInputType
    _max?: TwitterFollowMaxAggregateInputType
  }


  export type TwitterFollowGroupByOutputType = {
    id: number
    fromUserId: number
    toUserId: number
    createdAt: Date
    updatedAt: Date
    _count: TwitterFollowCountAggregateOutputType | null
    _avg: TwitterFollowAvgAggregateOutputType | null
    _sum: TwitterFollowSumAggregateOutputType | null
    _min: TwitterFollowMinAggregateOutputType | null
    _max: TwitterFollowMaxAggregateOutputType | null
  }

  type GetTwitterFollowGroupByPayload<T extends TwitterFollowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TwitterFollowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TwitterFollowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TwitterFollowGroupByOutputType[P]>
            : GetScalarType<T[P], TwitterFollowGroupByOutputType[P]>
        }
      >
    >


  export type TwitterFollowSelect = {
    id?: boolean
    from?: boolean | TwitterUserArgs
    fromUserId?: boolean
    to?: boolean | TwitterUserArgs
    toUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type TwitterFollowInclude = {
    from?: boolean | TwitterUserArgs
    to?: boolean | TwitterUserArgs
  }

  export type TwitterFollowGetPayload<S extends boolean | null | undefined | TwitterFollowArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TwitterFollow :
    S extends undefined ? never :
    S extends { include: any } & (TwitterFollowArgs | TwitterFollowFindManyArgs)
    ? TwitterFollow  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'from' ? TwitterUserGetPayload<S['include'][P]> :
        P extends 'to' ? TwitterUserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TwitterFollowArgs | TwitterFollowFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'from' ? TwitterUserGetPayload<S['select'][P]> :
        P extends 'to' ? TwitterUserGetPayload<S['select'][P]> :  P extends keyof TwitterFollow ? TwitterFollow[P] : never
  } 
      : TwitterFollow


  type TwitterFollowCountArgs = 
    Omit<TwitterFollowFindManyArgs, 'select' | 'include'> & {
      select?: TwitterFollowCountAggregateInputType | true
    }

  export interface TwitterFollowDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TwitterFollow that matches the filter.
     * @param {TwitterFollowFindUniqueArgs} args - Arguments to find a TwitterFollow
     * @example
     * // Get one TwitterFollow
     * const twitterFollow = await prisma.twitterFollow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TwitterFollowFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TwitterFollowFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TwitterFollow'> extends True ? Prisma__TwitterFollowClient<TwitterFollowGetPayload<T>> : Prisma__TwitterFollowClient<TwitterFollowGetPayload<T> | null, null>

    /**
     * Find one TwitterFollow that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TwitterFollowFindUniqueOrThrowArgs} args - Arguments to find a TwitterFollow
     * @example
     * // Get one TwitterFollow
     * const twitterFollow = await prisma.twitterFollow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TwitterFollowFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TwitterFollowFindUniqueOrThrowArgs>
    ): Prisma__TwitterFollowClient<TwitterFollowGetPayload<T>>

    /**
     * Find the first TwitterFollow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterFollowFindFirstArgs} args - Arguments to find a TwitterFollow
     * @example
     * // Get one TwitterFollow
     * const twitterFollow = await prisma.twitterFollow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TwitterFollowFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TwitterFollowFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TwitterFollow'> extends True ? Prisma__TwitterFollowClient<TwitterFollowGetPayload<T>> : Prisma__TwitterFollowClient<TwitterFollowGetPayload<T> | null, null>

    /**
     * Find the first TwitterFollow that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterFollowFindFirstOrThrowArgs} args - Arguments to find a TwitterFollow
     * @example
     * // Get one TwitterFollow
     * const twitterFollow = await prisma.twitterFollow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TwitterFollowFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TwitterFollowFindFirstOrThrowArgs>
    ): Prisma__TwitterFollowClient<TwitterFollowGetPayload<T>>

    /**
     * Find zero or more TwitterFollows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterFollowFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TwitterFollows
     * const twitterFollows = await prisma.twitterFollow.findMany()
     * 
     * // Get first 10 TwitterFollows
     * const twitterFollows = await prisma.twitterFollow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const twitterFollowWithIdOnly = await prisma.twitterFollow.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TwitterFollowFindManyArgs>(
      args?: SelectSubset<T, TwitterFollowFindManyArgs>
    ): Prisma.PrismaPromise<Array<TwitterFollowGetPayload<T>>>

    /**
     * Create a TwitterFollow.
     * @param {TwitterFollowCreateArgs} args - Arguments to create a TwitterFollow.
     * @example
     * // Create one TwitterFollow
     * const TwitterFollow = await prisma.twitterFollow.create({
     *   data: {
     *     // ... data to create a TwitterFollow
     *   }
     * })
     * 
    **/
    create<T extends TwitterFollowCreateArgs>(
      args: SelectSubset<T, TwitterFollowCreateArgs>
    ): Prisma__TwitterFollowClient<TwitterFollowGetPayload<T>>

    /**
     * Create many TwitterFollows.
     *     @param {TwitterFollowCreateManyArgs} args - Arguments to create many TwitterFollows.
     *     @example
     *     // Create many TwitterFollows
     *     const twitterFollow = await prisma.twitterFollow.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TwitterFollowCreateManyArgs>(
      args?: SelectSubset<T, TwitterFollowCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TwitterFollow.
     * @param {TwitterFollowDeleteArgs} args - Arguments to delete one TwitterFollow.
     * @example
     * // Delete one TwitterFollow
     * const TwitterFollow = await prisma.twitterFollow.delete({
     *   where: {
     *     // ... filter to delete one TwitterFollow
     *   }
     * })
     * 
    **/
    delete<T extends TwitterFollowDeleteArgs>(
      args: SelectSubset<T, TwitterFollowDeleteArgs>
    ): Prisma__TwitterFollowClient<TwitterFollowGetPayload<T>>

    /**
     * Update one TwitterFollow.
     * @param {TwitterFollowUpdateArgs} args - Arguments to update one TwitterFollow.
     * @example
     * // Update one TwitterFollow
     * const twitterFollow = await prisma.twitterFollow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TwitterFollowUpdateArgs>(
      args: SelectSubset<T, TwitterFollowUpdateArgs>
    ): Prisma__TwitterFollowClient<TwitterFollowGetPayload<T>>

    /**
     * Delete zero or more TwitterFollows.
     * @param {TwitterFollowDeleteManyArgs} args - Arguments to filter TwitterFollows to delete.
     * @example
     * // Delete a few TwitterFollows
     * const { count } = await prisma.twitterFollow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TwitterFollowDeleteManyArgs>(
      args?: SelectSubset<T, TwitterFollowDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TwitterFollows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterFollowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TwitterFollows
     * const twitterFollow = await prisma.twitterFollow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TwitterFollowUpdateManyArgs>(
      args: SelectSubset<T, TwitterFollowUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TwitterFollow.
     * @param {TwitterFollowUpsertArgs} args - Arguments to update or create a TwitterFollow.
     * @example
     * // Update or create a TwitterFollow
     * const twitterFollow = await prisma.twitterFollow.upsert({
     *   create: {
     *     // ... data to create a TwitterFollow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TwitterFollow we want to update
     *   }
     * })
    **/
    upsert<T extends TwitterFollowUpsertArgs>(
      args: SelectSubset<T, TwitterFollowUpsertArgs>
    ): Prisma__TwitterFollowClient<TwitterFollowGetPayload<T>>

    /**
     * Count the number of TwitterFollows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterFollowCountArgs} args - Arguments to filter TwitterFollows to count.
     * @example
     * // Count the number of TwitterFollows
     * const count = await prisma.twitterFollow.count({
     *   where: {
     *     // ... the filter for the TwitterFollows we want to count
     *   }
     * })
    **/
    count<T extends TwitterFollowCountArgs>(
      args?: Subset<T, TwitterFollowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TwitterFollowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TwitterFollow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterFollowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TwitterFollowAggregateArgs>(args: Subset<T, TwitterFollowAggregateArgs>): Prisma.PrismaPromise<GetTwitterFollowAggregateType<T>>

    /**
     * Group by TwitterFollow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterFollowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TwitterFollowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TwitterFollowGroupByArgs['orderBy'] }
        : { orderBy?: TwitterFollowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TwitterFollowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTwitterFollowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TwitterFollow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TwitterFollowClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    from<T extends TwitterUserArgs= {}>(args?: Subset<T, TwitterUserArgs>): Prisma__TwitterUserClient<TwitterUserGetPayload<T> | Null>;

    to<T extends TwitterUserArgs= {}>(args?: Subset<T, TwitterUserArgs>): Prisma__TwitterUserClient<TwitterUserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TwitterFollow base type for findUnique actions
   */
  export type TwitterFollowFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TwitterFollow
     */
    select?: TwitterFollowSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterFollowInclude | null
    /**
     * Filter, which TwitterFollow to fetch.
     */
    where: TwitterFollowWhereUniqueInput
  }

  /**
   * TwitterFollow findUnique
   */
  export interface TwitterFollowFindUniqueArgs extends TwitterFollowFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TwitterFollow findUniqueOrThrow
   */
  export type TwitterFollowFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TwitterFollow
     */
    select?: TwitterFollowSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterFollowInclude | null
    /**
     * Filter, which TwitterFollow to fetch.
     */
    where: TwitterFollowWhereUniqueInput
  }


  /**
   * TwitterFollow base type for findFirst actions
   */
  export type TwitterFollowFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TwitterFollow
     */
    select?: TwitterFollowSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterFollowInclude | null
    /**
     * Filter, which TwitterFollow to fetch.
     */
    where?: TwitterFollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterFollows to fetch.
     */
    orderBy?: Enumerable<TwitterFollowOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterFollows.
     */
    cursor?: TwitterFollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterFollows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterFollows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterFollows.
     */
    distinct?: Enumerable<TwitterFollowScalarFieldEnum>
  }

  /**
   * TwitterFollow findFirst
   */
  export interface TwitterFollowFindFirstArgs extends TwitterFollowFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TwitterFollow findFirstOrThrow
   */
  export type TwitterFollowFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TwitterFollow
     */
    select?: TwitterFollowSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterFollowInclude | null
    /**
     * Filter, which TwitterFollow to fetch.
     */
    where?: TwitterFollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterFollows to fetch.
     */
    orderBy?: Enumerable<TwitterFollowOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterFollows.
     */
    cursor?: TwitterFollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterFollows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterFollows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterFollows.
     */
    distinct?: Enumerable<TwitterFollowScalarFieldEnum>
  }


  /**
   * TwitterFollow findMany
   */
  export type TwitterFollowFindManyArgs = {
    /**
     * Select specific fields to fetch from the TwitterFollow
     */
    select?: TwitterFollowSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterFollowInclude | null
    /**
     * Filter, which TwitterFollows to fetch.
     */
    where?: TwitterFollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterFollows to fetch.
     */
    orderBy?: Enumerable<TwitterFollowOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TwitterFollows.
     */
    cursor?: TwitterFollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterFollows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterFollows.
     */
    skip?: number
    distinct?: Enumerable<TwitterFollowScalarFieldEnum>
  }


  /**
   * TwitterFollow create
   */
  export type TwitterFollowCreateArgs = {
    /**
     * Select specific fields to fetch from the TwitterFollow
     */
    select?: TwitterFollowSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterFollowInclude | null
    /**
     * The data needed to create a TwitterFollow.
     */
    data: XOR<TwitterFollowCreateInput, TwitterFollowUncheckedCreateInput>
  }


  /**
   * TwitterFollow createMany
   */
  export type TwitterFollowCreateManyArgs = {
    /**
     * The data used to create many TwitterFollows.
     */
    data: Enumerable<TwitterFollowCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TwitterFollow update
   */
  export type TwitterFollowUpdateArgs = {
    /**
     * Select specific fields to fetch from the TwitterFollow
     */
    select?: TwitterFollowSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterFollowInclude | null
    /**
     * The data needed to update a TwitterFollow.
     */
    data: XOR<TwitterFollowUpdateInput, TwitterFollowUncheckedUpdateInput>
    /**
     * Choose, which TwitterFollow to update.
     */
    where: TwitterFollowWhereUniqueInput
  }


  /**
   * TwitterFollow updateMany
   */
  export type TwitterFollowUpdateManyArgs = {
    /**
     * The data used to update TwitterFollows.
     */
    data: XOR<TwitterFollowUpdateManyMutationInput, TwitterFollowUncheckedUpdateManyInput>
    /**
     * Filter which TwitterFollows to update
     */
    where?: TwitterFollowWhereInput
  }


  /**
   * TwitterFollow upsert
   */
  export type TwitterFollowUpsertArgs = {
    /**
     * Select specific fields to fetch from the TwitterFollow
     */
    select?: TwitterFollowSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterFollowInclude | null
    /**
     * The filter to search for the TwitterFollow to update in case it exists.
     */
    where: TwitterFollowWhereUniqueInput
    /**
     * In case the TwitterFollow found by the `where` argument doesn't exist, create a new TwitterFollow with this data.
     */
    create: XOR<TwitterFollowCreateInput, TwitterFollowUncheckedCreateInput>
    /**
     * In case the TwitterFollow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TwitterFollowUpdateInput, TwitterFollowUncheckedUpdateInput>
  }


  /**
   * TwitterFollow delete
   */
  export type TwitterFollowDeleteArgs = {
    /**
     * Select specific fields to fetch from the TwitterFollow
     */
    select?: TwitterFollowSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterFollowInclude | null
    /**
     * Filter which TwitterFollow to delete.
     */
    where: TwitterFollowWhereUniqueInput
  }


  /**
   * TwitterFollow deleteMany
   */
  export type TwitterFollowDeleteManyArgs = {
    /**
     * Filter which TwitterFollows to delete
     */
    where?: TwitterFollowWhereInput
  }


  /**
   * TwitterFollow without action
   */
  export type TwitterFollowArgs = {
    /**
     * Select specific fields to fetch from the TwitterFollow
     */
    select?: TwitterFollowSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterFollowInclude | null
  }



  /**
   * Model TwitterPost
   */


  export type AggregateTwitterPost = {
    _count: TwitterPostCountAggregateOutputType | null
    _avg: TwitterPostAvgAggregateOutputType | null
    _sum: TwitterPostSumAggregateOutputType | null
    _min: TwitterPostMinAggregateOutputType | null
    _max: TwitterPostMaxAggregateOutputType | null
  }

  export type TwitterPostAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type TwitterPostSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type TwitterPostMinAggregateOutputType = {
    id: number | null
    caption: string | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TwitterPostMaxAggregateOutputType = {
    id: number | null
    caption: string | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TwitterPostCountAggregateOutputType = {
    id: number
    caption: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TwitterPostAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type TwitterPostSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type TwitterPostMinAggregateInputType = {
    id?: true
    caption?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TwitterPostMaxAggregateInputType = {
    id?: true
    caption?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TwitterPostCountAggregateInputType = {
    id?: true
    caption?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TwitterPostAggregateArgs = {
    /**
     * Filter which TwitterPost to aggregate.
     */
    where?: TwitterPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterPosts to fetch.
     */
    orderBy?: Enumerable<TwitterPostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TwitterPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TwitterPosts
    **/
    _count?: true | TwitterPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TwitterPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TwitterPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TwitterPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TwitterPostMaxAggregateInputType
  }

  export type GetTwitterPostAggregateType<T extends TwitterPostAggregateArgs> = {
        [P in keyof T & keyof AggregateTwitterPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTwitterPost[P]>
      : GetScalarType<T[P], AggregateTwitterPost[P]>
  }




  export type TwitterPostGroupByArgs = {
    where?: TwitterPostWhereInput
    orderBy?: Enumerable<TwitterPostOrderByWithAggregationInput>
    by: TwitterPostScalarFieldEnum[]
    having?: TwitterPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TwitterPostCountAggregateInputType | true
    _avg?: TwitterPostAvgAggregateInputType
    _sum?: TwitterPostSumAggregateInputType
    _min?: TwitterPostMinAggregateInputType
    _max?: TwitterPostMaxAggregateInputType
  }


  export type TwitterPostGroupByOutputType = {
    id: number
    caption: string
    userId: number
    createdAt: Date
    updatedAt: Date
    _count: TwitterPostCountAggregateOutputType | null
    _avg: TwitterPostAvgAggregateOutputType | null
    _sum: TwitterPostSumAggregateOutputType | null
    _min: TwitterPostMinAggregateOutputType | null
    _max: TwitterPostMaxAggregateOutputType | null
  }

  type GetTwitterPostGroupByPayload<T extends TwitterPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TwitterPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TwitterPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TwitterPostGroupByOutputType[P]>
            : GetScalarType<T[P], TwitterPostGroupByOutputType[P]>
        }
      >
    >


  export type TwitterPostSelect = {
    id?: boolean
    caption?: boolean
    user?: boolean | TwitterUserArgs
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    comments?: boolean | TwitterPost$commentsArgs
    postOnHashtags?: boolean | TwitterPost$postOnHashtagsArgs
    _count?: boolean | TwitterPostCountOutputTypeArgs
  }


  export type TwitterPostInclude = {
    user?: boolean | TwitterUserArgs
    comments?: boolean | TwitterPost$commentsArgs
    postOnHashtags?: boolean | TwitterPost$postOnHashtagsArgs
    _count?: boolean | TwitterPostCountOutputTypeArgs
  }

  export type TwitterPostGetPayload<S extends boolean | null | undefined | TwitterPostArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TwitterPost :
    S extends undefined ? never :
    S extends { include: any } & (TwitterPostArgs | TwitterPostFindManyArgs)
    ? TwitterPost  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? TwitterUserGetPayload<S['include'][P]> :
        P extends 'comments' ? Array < TwitterCommentGetPayload<S['include'][P]>>  :
        P extends 'postOnHashtags' ? Array < TwitterPostOnHashtagGetPayload<S['include'][P]>>  :
        P extends '_count' ? TwitterPostCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TwitterPostArgs | TwitterPostFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? TwitterUserGetPayload<S['select'][P]> :
        P extends 'comments' ? Array < TwitterCommentGetPayload<S['select'][P]>>  :
        P extends 'postOnHashtags' ? Array < TwitterPostOnHashtagGetPayload<S['select'][P]>>  :
        P extends '_count' ? TwitterPostCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof TwitterPost ? TwitterPost[P] : never
  } 
      : TwitterPost


  type TwitterPostCountArgs = 
    Omit<TwitterPostFindManyArgs, 'select' | 'include'> & {
      select?: TwitterPostCountAggregateInputType | true
    }

  export interface TwitterPostDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TwitterPost that matches the filter.
     * @param {TwitterPostFindUniqueArgs} args - Arguments to find a TwitterPost
     * @example
     * // Get one TwitterPost
     * const twitterPost = await prisma.twitterPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TwitterPostFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TwitterPostFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TwitterPost'> extends True ? Prisma__TwitterPostClient<TwitterPostGetPayload<T>> : Prisma__TwitterPostClient<TwitterPostGetPayload<T> | null, null>

    /**
     * Find one TwitterPost that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TwitterPostFindUniqueOrThrowArgs} args - Arguments to find a TwitterPost
     * @example
     * // Get one TwitterPost
     * const twitterPost = await prisma.twitterPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TwitterPostFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TwitterPostFindUniqueOrThrowArgs>
    ): Prisma__TwitterPostClient<TwitterPostGetPayload<T>>

    /**
     * Find the first TwitterPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterPostFindFirstArgs} args - Arguments to find a TwitterPost
     * @example
     * // Get one TwitterPost
     * const twitterPost = await prisma.twitterPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TwitterPostFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TwitterPostFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TwitterPost'> extends True ? Prisma__TwitterPostClient<TwitterPostGetPayload<T>> : Prisma__TwitterPostClient<TwitterPostGetPayload<T> | null, null>

    /**
     * Find the first TwitterPost that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterPostFindFirstOrThrowArgs} args - Arguments to find a TwitterPost
     * @example
     * // Get one TwitterPost
     * const twitterPost = await prisma.twitterPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TwitterPostFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TwitterPostFindFirstOrThrowArgs>
    ): Prisma__TwitterPostClient<TwitterPostGetPayload<T>>

    /**
     * Find zero or more TwitterPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterPostFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TwitterPosts
     * const twitterPosts = await prisma.twitterPost.findMany()
     * 
     * // Get first 10 TwitterPosts
     * const twitterPosts = await prisma.twitterPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const twitterPostWithIdOnly = await prisma.twitterPost.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TwitterPostFindManyArgs>(
      args?: SelectSubset<T, TwitterPostFindManyArgs>
    ): Prisma.PrismaPromise<Array<TwitterPostGetPayload<T>>>

    /**
     * Create a TwitterPost.
     * @param {TwitterPostCreateArgs} args - Arguments to create a TwitterPost.
     * @example
     * // Create one TwitterPost
     * const TwitterPost = await prisma.twitterPost.create({
     *   data: {
     *     // ... data to create a TwitterPost
     *   }
     * })
     * 
    **/
    create<T extends TwitterPostCreateArgs>(
      args: SelectSubset<T, TwitterPostCreateArgs>
    ): Prisma__TwitterPostClient<TwitterPostGetPayload<T>>

    /**
     * Create many TwitterPosts.
     *     @param {TwitterPostCreateManyArgs} args - Arguments to create many TwitterPosts.
     *     @example
     *     // Create many TwitterPosts
     *     const twitterPost = await prisma.twitterPost.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TwitterPostCreateManyArgs>(
      args?: SelectSubset<T, TwitterPostCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TwitterPost.
     * @param {TwitterPostDeleteArgs} args - Arguments to delete one TwitterPost.
     * @example
     * // Delete one TwitterPost
     * const TwitterPost = await prisma.twitterPost.delete({
     *   where: {
     *     // ... filter to delete one TwitterPost
     *   }
     * })
     * 
    **/
    delete<T extends TwitterPostDeleteArgs>(
      args: SelectSubset<T, TwitterPostDeleteArgs>
    ): Prisma__TwitterPostClient<TwitterPostGetPayload<T>>

    /**
     * Update one TwitterPost.
     * @param {TwitterPostUpdateArgs} args - Arguments to update one TwitterPost.
     * @example
     * // Update one TwitterPost
     * const twitterPost = await prisma.twitterPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TwitterPostUpdateArgs>(
      args: SelectSubset<T, TwitterPostUpdateArgs>
    ): Prisma__TwitterPostClient<TwitterPostGetPayload<T>>

    /**
     * Delete zero or more TwitterPosts.
     * @param {TwitterPostDeleteManyArgs} args - Arguments to filter TwitterPosts to delete.
     * @example
     * // Delete a few TwitterPosts
     * const { count } = await prisma.twitterPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TwitterPostDeleteManyArgs>(
      args?: SelectSubset<T, TwitterPostDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TwitterPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TwitterPosts
     * const twitterPost = await prisma.twitterPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TwitterPostUpdateManyArgs>(
      args: SelectSubset<T, TwitterPostUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TwitterPost.
     * @param {TwitterPostUpsertArgs} args - Arguments to update or create a TwitterPost.
     * @example
     * // Update or create a TwitterPost
     * const twitterPost = await prisma.twitterPost.upsert({
     *   create: {
     *     // ... data to create a TwitterPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TwitterPost we want to update
     *   }
     * })
    **/
    upsert<T extends TwitterPostUpsertArgs>(
      args: SelectSubset<T, TwitterPostUpsertArgs>
    ): Prisma__TwitterPostClient<TwitterPostGetPayload<T>>

    /**
     * Count the number of TwitterPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterPostCountArgs} args - Arguments to filter TwitterPosts to count.
     * @example
     * // Count the number of TwitterPosts
     * const count = await prisma.twitterPost.count({
     *   where: {
     *     // ... the filter for the TwitterPosts we want to count
     *   }
     * })
    **/
    count<T extends TwitterPostCountArgs>(
      args?: Subset<T, TwitterPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TwitterPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TwitterPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TwitterPostAggregateArgs>(args: Subset<T, TwitterPostAggregateArgs>): Prisma.PrismaPromise<GetTwitterPostAggregateType<T>>

    /**
     * Group by TwitterPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TwitterPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TwitterPostGroupByArgs['orderBy'] }
        : { orderBy?: TwitterPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TwitterPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTwitterPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TwitterPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TwitterPostClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends TwitterUserArgs= {}>(args?: Subset<T, TwitterUserArgs>): Prisma__TwitterUserClient<TwitterUserGetPayload<T> | Null>;

    comments<T extends TwitterPost$commentsArgs= {}>(args?: Subset<T, TwitterPost$commentsArgs>): Prisma.PrismaPromise<Array<TwitterCommentGetPayload<T>>| Null>;

    postOnHashtags<T extends TwitterPost$postOnHashtagsArgs= {}>(args?: Subset<T, TwitterPost$postOnHashtagsArgs>): Prisma.PrismaPromise<Array<TwitterPostOnHashtagGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TwitterPost base type for findUnique actions
   */
  export type TwitterPostFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TwitterPost
     */
    select?: TwitterPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostInclude | null
    /**
     * Filter, which TwitterPost to fetch.
     */
    where: TwitterPostWhereUniqueInput
  }

  /**
   * TwitterPost findUnique
   */
  export interface TwitterPostFindUniqueArgs extends TwitterPostFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TwitterPost findUniqueOrThrow
   */
  export type TwitterPostFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TwitterPost
     */
    select?: TwitterPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostInclude | null
    /**
     * Filter, which TwitterPost to fetch.
     */
    where: TwitterPostWhereUniqueInput
  }


  /**
   * TwitterPost base type for findFirst actions
   */
  export type TwitterPostFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TwitterPost
     */
    select?: TwitterPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostInclude | null
    /**
     * Filter, which TwitterPost to fetch.
     */
    where?: TwitterPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterPosts to fetch.
     */
    orderBy?: Enumerable<TwitterPostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterPosts.
     */
    cursor?: TwitterPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterPosts.
     */
    distinct?: Enumerable<TwitterPostScalarFieldEnum>
  }

  /**
   * TwitterPost findFirst
   */
  export interface TwitterPostFindFirstArgs extends TwitterPostFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TwitterPost findFirstOrThrow
   */
  export type TwitterPostFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TwitterPost
     */
    select?: TwitterPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostInclude | null
    /**
     * Filter, which TwitterPost to fetch.
     */
    where?: TwitterPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterPosts to fetch.
     */
    orderBy?: Enumerable<TwitterPostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterPosts.
     */
    cursor?: TwitterPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterPosts.
     */
    distinct?: Enumerable<TwitterPostScalarFieldEnum>
  }


  /**
   * TwitterPost findMany
   */
  export type TwitterPostFindManyArgs = {
    /**
     * Select specific fields to fetch from the TwitterPost
     */
    select?: TwitterPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostInclude | null
    /**
     * Filter, which TwitterPosts to fetch.
     */
    where?: TwitterPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterPosts to fetch.
     */
    orderBy?: Enumerable<TwitterPostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TwitterPosts.
     */
    cursor?: TwitterPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterPosts.
     */
    skip?: number
    distinct?: Enumerable<TwitterPostScalarFieldEnum>
  }


  /**
   * TwitterPost create
   */
  export type TwitterPostCreateArgs = {
    /**
     * Select specific fields to fetch from the TwitterPost
     */
    select?: TwitterPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostInclude | null
    /**
     * The data needed to create a TwitterPost.
     */
    data: XOR<TwitterPostCreateInput, TwitterPostUncheckedCreateInput>
  }


  /**
   * TwitterPost createMany
   */
  export type TwitterPostCreateManyArgs = {
    /**
     * The data used to create many TwitterPosts.
     */
    data: Enumerable<TwitterPostCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TwitterPost update
   */
  export type TwitterPostUpdateArgs = {
    /**
     * Select specific fields to fetch from the TwitterPost
     */
    select?: TwitterPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostInclude | null
    /**
     * The data needed to update a TwitterPost.
     */
    data: XOR<TwitterPostUpdateInput, TwitterPostUncheckedUpdateInput>
    /**
     * Choose, which TwitterPost to update.
     */
    where: TwitterPostWhereUniqueInput
  }


  /**
   * TwitterPost updateMany
   */
  export type TwitterPostUpdateManyArgs = {
    /**
     * The data used to update TwitterPosts.
     */
    data: XOR<TwitterPostUpdateManyMutationInput, TwitterPostUncheckedUpdateManyInput>
    /**
     * Filter which TwitterPosts to update
     */
    where?: TwitterPostWhereInput
  }


  /**
   * TwitterPost upsert
   */
  export type TwitterPostUpsertArgs = {
    /**
     * Select specific fields to fetch from the TwitterPost
     */
    select?: TwitterPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostInclude | null
    /**
     * The filter to search for the TwitterPost to update in case it exists.
     */
    where: TwitterPostWhereUniqueInput
    /**
     * In case the TwitterPost found by the `where` argument doesn't exist, create a new TwitterPost with this data.
     */
    create: XOR<TwitterPostCreateInput, TwitterPostUncheckedCreateInput>
    /**
     * In case the TwitterPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TwitterPostUpdateInput, TwitterPostUncheckedUpdateInput>
  }


  /**
   * TwitterPost delete
   */
  export type TwitterPostDeleteArgs = {
    /**
     * Select specific fields to fetch from the TwitterPost
     */
    select?: TwitterPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostInclude | null
    /**
     * Filter which TwitterPost to delete.
     */
    where: TwitterPostWhereUniqueInput
  }


  /**
   * TwitterPost deleteMany
   */
  export type TwitterPostDeleteManyArgs = {
    /**
     * Filter which TwitterPosts to delete
     */
    where?: TwitterPostWhereInput
  }


  /**
   * TwitterPost.comments
   */
  export type TwitterPost$commentsArgs = {
    /**
     * Select specific fields to fetch from the TwitterComment
     */
    select?: TwitterCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterCommentInclude | null
    where?: TwitterCommentWhereInput
    orderBy?: Enumerable<TwitterCommentOrderByWithRelationInput>
    cursor?: TwitterCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TwitterCommentScalarFieldEnum>
  }


  /**
   * TwitterPost.postOnHashtags
   */
  export type TwitterPost$postOnHashtagsArgs = {
    /**
     * Select specific fields to fetch from the TwitterPostOnHashtag
     */
    select?: TwitterPostOnHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostOnHashtagInclude | null
    where?: TwitterPostOnHashtagWhereInput
    orderBy?: Enumerable<TwitterPostOnHashtagOrderByWithRelationInput>
    cursor?: TwitterPostOnHashtagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TwitterPostOnHashtagScalarFieldEnum>
  }


  /**
   * TwitterPost without action
   */
  export type TwitterPostArgs = {
    /**
     * Select specific fields to fetch from the TwitterPost
     */
    select?: TwitterPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostInclude | null
  }



  /**
   * Model TwitterDirectMessage
   */


  export type AggregateTwitterDirectMessage = {
    _count: TwitterDirectMessageCountAggregateOutputType | null
    _avg: TwitterDirectMessageAvgAggregateOutputType | null
    _sum: TwitterDirectMessageSumAggregateOutputType | null
    _min: TwitterDirectMessageMinAggregateOutputType | null
    _max: TwitterDirectMessageMaxAggregateOutputType | null
  }

  export type TwitterDirectMessageAvgAggregateOutputType = {
    id: number | null
    fromUserId: number | null
    toUserId: number | null
  }

  export type TwitterDirectMessageSumAggregateOutputType = {
    id: number | null
    fromUserId: number | null
    toUserId: number | null
  }

  export type TwitterDirectMessageMinAggregateOutputType = {
    id: number | null
    fromUserId: number | null
    toUserId: number | null
    text: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TwitterDirectMessageMaxAggregateOutputType = {
    id: number | null
    fromUserId: number | null
    toUserId: number | null
    text: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TwitterDirectMessageCountAggregateOutputType = {
    id: number
    fromUserId: number
    toUserId: number
    text: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TwitterDirectMessageAvgAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
  }

  export type TwitterDirectMessageSumAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
  }

  export type TwitterDirectMessageMinAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
    text?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TwitterDirectMessageMaxAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
    text?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TwitterDirectMessageCountAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
    text?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TwitterDirectMessageAggregateArgs = {
    /**
     * Filter which TwitterDirectMessage to aggregate.
     */
    where?: TwitterDirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterDirectMessages to fetch.
     */
    orderBy?: Enumerable<TwitterDirectMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TwitterDirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterDirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterDirectMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TwitterDirectMessages
    **/
    _count?: true | TwitterDirectMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TwitterDirectMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TwitterDirectMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TwitterDirectMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TwitterDirectMessageMaxAggregateInputType
  }

  export type GetTwitterDirectMessageAggregateType<T extends TwitterDirectMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateTwitterDirectMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTwitterDirectMessage[P]>
      : GetScalarType<T[P], AggregateTwitterDirectMessage[P]>
  }




  export type TwitterDirectMessageGroupByArgs = {
    where?: TwitterDirectMessageWhereInput
    orderBy?: Enumerable<TwitterDirectMessageOrderByWithAggregationInput>
    by: TwitterDirectMessageScalarFieldEnum[]
    having?: TwitterDirectMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TwitterDirectMessageCountAggregateInputType | true
    _avg?: TwitterDirectMessageAvgAggregateInputType
    _sum?: TwitterDirectMessageSumAggregateInputType
    _min?: TwitterDirectMessageMinAggregateInputType
    _max?: TwitterDirectMessageMaxAggregateInputType
  }


  export type TwitterDirectMessageGroupByOutputType = {
    id: number
    fromUserId: number
    toUserId: number
    text: string
    createdAt: Date
    updatedAt: Date
    _count: TwitterDirectMessageCountAggregateOutputType | null
    _avg: TwitterDirectMessageAvgAggregateOutputType | null
    _sum: TwitterDirectMessageSumAggregateOutputType | null
    _min: TwitterDirectMessageMinAggregateOutputType | null
    _max: TwitterDirectMessageMaxAggregateOutputType | null
  }

  type GetTwitterDirectMessageGroupByPayload<T extends TwitterDirectMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TwitterDirectMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TwitterDirectMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TwitterDirectMessageGroupByOutputType[P]>
            : GetScalarType<T[P], TwitterDirectMessageGroupByOutputType[P]>
        }
      >
    >


  export type TwitterDirectMessageSelect = {
    id?: boolean
    from?: boolean | TwitterUserArgs
    fromUserId?: boolean
    to?: boolean | TwitterUserArgs
    toUserId?: boolean
    text?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type TwitterDirectMessageInclude = {
    from?: boolean | TwitterUserArgs
    to?: boolean | TwitterUserArgs
  }

  export type TwitterDirectMessageGetPayload<S extends boolean | null | undefined | TwitterDirectMessageArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TwitterDirectMessage :
    S extends undefined ? never :
    S extends { include: any } & (TwitterDirectMessageArgs | TwitterDirectMessageFindManyArgs)
    ? TwitterDirectMessage  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'from' ? TwitterUserGetPayload<S['include'][P]> :
        P extends 'to' ? TwitterUserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TwitterDirectMessageArgs | TwitterDirectMessageFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'from' ? TwitterUserGetPayload<S['select'][P]> :
        P extends 'to' ? TwitterUserGetPayload<S['select'][P]> :  P extends keyof TwitterDirectMessage ? TwitterDirectMessage[P] : never
  } 
      : TwitterDirectMessage


  type TwitterDirectMessageCountArgs = 
    Omit<TwitterDirectMessageFindManyArgs, 'select' | 'include'> & {
      select?: TwitterDirectMessageCountAggregateInputType | true
    }

  export interface TwitterDirectMessageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TwitterDirectMessage that matches the filter.
     * @param {TwitterDirectMessageFindUniqueArgs} args - Arguments to find a TwitterDirectMessage
     * @example
     * // Get one TwitterDirectMessage
     * const twitterDirectMessage = await prisma.twitterDirectMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TwitterDirectMessageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TwitterDirectMessageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TwitterDirectMessage'> extends True ? Prisma__TwitterDirectMessageClient<TwitterDirectMessageGetPayload<T>> : Prisma__TwitterDirectMessageClient<TwitterDirectMessageGetPayload<T> | null, null>

    /**
     * Find one TwitterDirectMessage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TwitterDirectMessageFindUniqueOrThrowArgs} args - Arguments to find a TwitterDirectMessage
     * @example
     * // Get one TwitterDirectMessage
     * const twitterDirectMessage = await prisma.twitterDirectMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TwitterDirectMessageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TwitterDirectMessageFindUniqueOrThrowArgs>
    ): Prisma__TwitterDirectMessageClient<TwitterDirectMessageGetPayload<T>>

    /**
     * Find the first TwitterDirectMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterDirectMessageFindFirstArgs} args - Arguments to find a TwitterDirectMessage
     * @example
     * // Get one TwitterDirectMessage
     * const twitterDirectMessage = await prisma.twitterDirectMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TwitterDirectMessageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TwitterDirectMessageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TwitterDirectMessage'> extends True ? Prisma__TwitterDirectMessageClient<TwitterDirectMessageGetPayload<T>> : Prisma__TwitterDirectMessageClient<TwitterDirectMessageGetPayload<T> | null, null>

    /**
     * Find the first TwitterDirectMessage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterDirectMessageFindFirstOrThrowArgs} args - Arguments to find a TwitterDirectMessage
     * @example
     * // Get one TwitterDirectMessage
     * const twitterDirectMessage = await prisma.twitterDirectMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TwitterDirectMessageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TwitterDirectMessageFindFirstOrThrowArgs>
    ): Prisma__TwitterDirectMessageClient<TwitterDirectMessageGetPayload<T>>

    /**
     * Find zero or more TwitterDirectMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterDirectMessageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TwitterDirectMessages
     * const twitterDirectMessages = await prisma.twitterDirectMessage.findMany()
     * 
     * // Get first 10 TwitterDirectMessages
     * const twitterDirectMessages = await prisma.twitterDirectMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const twitterDirectMessageWithIdOnly = await prisma.twitterDirectMessage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TwitterDirectMessageFindManyArgs>(
      args?: SelectSubset<T, TwitterDirectMessageFindManyArgs>
    ): Prisma.PrismaPromise<Array<TwitterDirectMessageGetPayload<T>>>

    /**
     * Create a TwitterDirectMessage.
     * @param {TwitterDirectMessageCreateArgs} args - Arguments to create a TwitterDirectMessage.
     * @example
     * // Create one TwitterDirectMessage
     * const TwitterDirectMessage = await prisma.twitterDirectMessage.create({
     *   data: {
     *     // ... data to create a TwitterDirectMessage
     *   }
     * })
     * 
    **/
    create<T extends TwitterDirectMessageCreateArgs>(
      args: SelectSubset<T, TwitterDirectMessageCreateArgs>
    ): Prisma__TwitterDirectMessageClient<TwitterDirectMessageGetPayload<T>>

    /**
     * Create many TwitterDirectMessages.
     *     @param {TwitterDirectMessageCreateManyArgs} args - Arguments to create many TwitterDirectMessages.
     *     @example
     *     // Create many TwitterDirectMessages
     *     const twitterDirectMessage = await prisma.twitterDirectMessage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TwitterDirectMessageCreateManyArgs>(
      args?: SelectSubset<T, TwitterDirectMessageCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TwitterDirectMessage.
     * @param {TwitterDirectMessageDeleteArgs} args - Arguments to delete one TwitterDirectMessage.
     * @example
     * // Delete one TwitterDirectMessage
     * const TwitterDirectMessage = await prisma.twitterDirectMessage.delete({
     *   where: {
     *     // ... filter to delete one TwitterDirectMessage
     *   }
     * })
     * 
    **/
    delete<T extends TwitterDirectMessageDeleteArgs>(
      args: SelectSubset<T, TwitterDirectMessageDeleteArgs>
    ): Prisma__TwitterDirectMessageClient<TwitterDirectMessageGetPayload<T>>

    /**
     * Update one TwitterDirectMessage.
     * @param {TwitterDirectMessageUpdateArgs} args - Arguments to update one TwitterDirectMessage.
     * @example
     * // Update one TwitterDirectMessage
     * const twitterDirectMessage = await prisma.twitterDirectMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TwitterDirectMessageUpdateArgs>(
      args: SelectSubset<T, TwitterDirectMessageUpdateArgs>
    ): Prisma__TwitterDirectMessageClient<TwitterDirectMessageGetPayload<T>>

    /**
     * Delete zero or more TwitterDirectMessages.
     * @param {TwitterDirectMessageDeleteManyArgs} args - Arguments to filter TwitterDirectMessages to delete.
     * @example
     * // Delete a few TwitterDirectMessages
     * const { count } = await prisma.twitterDirectMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TwitterDirectMessageDeleteManyArgs>(
      args?: SelectSubset<T, TwitterDirectMessageDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TwitterDirectMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterDirectMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TwitterDirectMessages
     * const twitterDirectMessage = await prisma.twitterDirectMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TwitterDirectMessageUpdateManyArgs>(
      args: SelectSubset<T, TwitterDirectMessageUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TwitterDirectMessage.
     * @param {TwitterDirectMessageUpsertArgs} args - Arguments to update or create a TwitterDirectMessage.
     * @example
     * // Update or create a TwitterDirectMessage
     * const twitterDirectMessage = await prisma.twitterDirectMessage.upsert({
     *   create: {
     *     // ... data to create a TwitterDirectMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TwitterDirectMessage we want to update
     *   }
     * })
    **/
    upsert<T extends TwitterDirectMessageUpsertArgs>(
      args: SelectSubset<T, TwitterDirectMessageUpsertArgs>
    ): Prisma__TwitterDirectMessageClient<TwitterDirectMessageGetPayload<T>>

    /**
     * Count the number of TwitterDirectMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterDirectMessageCountArgs} args - Arguments to filter TwitterDirectMessages to count.
     * @example
     * // Count the number of TwitterDirectMessages
     * const count = await prisma.twitterDirectMessage.count({
     *   where: {
     *     // ... the filter for the TwitterDirectMessages we want to count
     *   }
     * })
    **/
    count<T extends TwitterDirectMessageCountArgs>(
      args?: Subset<T, TwitterDirectMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TwitterDirectMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TwitterDirectMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterDirectMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TwitterDirectMessageAggregateArgs>(args: Subset<T, TwitterDirectMessageAggregateArgs>): Prisma.PrismaPromise<GetTwitterDirectMessageAggregateType<T>>

    /**
     * Group by TwitterDirectMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterDirectMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TwitterDirectMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TwitterDirectMessageGroupByArgs['orderBy'] }
        : { orderBy?: TwitterDirectMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TwitterDirectMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTwitterDirectMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TwitterDirectMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TwitterDirectMessageClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    from<T extends TwitterUserArgs= {}>(args?: Subset<T, TwitterUserArgs>): Prisma__TwitterUserClient<TwitterUserGetPayload<T> | Null>;

    to<T extends TwitterUserArgs= {}>(args?: Subset<T, TwitterUserArgs>): Prisma__TwitterUserClient<TwitterUserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TwitterDirectMessage base type for findUnique actions
   */
  export type TwitterDirectMessageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TwitterDirectMessage
     */
    select?: TwitterDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterDirectMessageInclude | null
    /**
     * Filter, which TwitterDirectMessage to fetch.
     */
    where: TwitterDirectMessageWhereUniqueInput
  }

  /**
   * TwitterDirectMessage findUnique
   */
  export interface TwitterDirectMessageFindUniqueArgs extends TwitterDirectMessageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TwitterDirectMessage findUniqueOrThrow
   */
  export type TwitterDirectMessageFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TwitterDirectMessage
     */
    select?: TwitterDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterDirectMessageInclude | null
    /**
     * Filter, which TwitterDirectMessage to fetch.
     */
    where: TwitterDirectMessageWhereUniqueInput
  }


  /**
   * TwitterDirectMessage base type for findFirst actions
   */
  export type TwitterDirectMessageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TwitterDirectMessage
     */
    select?: TwitterDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterDirectMessageInclude | null
    /**
     * Filter, which TwitterDirectMessage to fetch.
     */
    where?: TwitterDirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterDirectMessages to fetch.
     */
    orderBy?: Enumerable<TwitterDirectMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterDirectMessages.
     */
    cursor?: TwitterDirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterDirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterDirectMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterDirectMessages.
     */
    distinct?: Enumerable<TwitterDirectMessageScalarFieldEnum>
  }

  /**
   * TwitterDirectMessage findFirst
   */
  export interface TwitterDirectMessageFindFirstArgs extends TwitterDirectMessageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TwitterDirectMessage findFirstOrThrow
   */
  export type TwitterDirectMessageFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TwitterDirectMessage
     */
    select?: TwitterDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterDirectMessageInclude | null
    /**
     * Filter, which TwitterDirectMessage to fetch.
     */
    where?: TwitterDirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterDirectMessages to fetch.
     */
    orderBy?: Enumerable<TwitterDirectMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterDirectMessages.
     */
    cursor?: TwitterDirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterDirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterDirectMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterDirectMessages.
     */
    distinct?: Enumerable<TwitterDirectMessageScalarFieldEnum>
  }


  /**
   * TwitterDirectMessage findMany
   */
  export type TwitterDirectMessageFindManyArgs = {
    /**
     * Select specific fields to fetch from the TwitterDirectMessage
     */
    select?: TwitterDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterDirectMessageInclude | null
    /**
     * Filter, which TwitterDirectMessages to fetch.
     */
    where?: TwitterDirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterDirectMessages to fetch.
     */
    orderBy?: Enumerable<TwitterDirectMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TwitterDirectMessages.
     */
    cursor?: TwitterDirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterDirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterDirectMessages.
     */
    skip?: number
    distinct?: Enumerable<TwitterDirectMessageScalarFieldEnum>
  }


  /**
   * TwitterDirectMessage create
   */
  export type TwitterDirectMessageCreateArgs = {
    /**
     * Select specific fields to fetch from the TwitterDirectMessage
     */
    select?: TwitterDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterDirectMessageInclude | null
    /**
     * The data needed to create a TwitterDirectMessage.
     */
    data: XOR<TwitterDirectMessageCreateInput, TwitterDirectMessageUncheckedCreateInput>
  }


  /**
   * TwitterDirectMessage createMany
   */
  export type TwitterDirectMessageCreateManyArgs = {
    /**
     * The data used to create many TwitterDirectMessages.
     */
    data: Enumerable<TwitterDirectMessageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TwitterDirectMessage update
   */
  export type TwitterDirectMessageUpdateArgs = {
    /**
     * Select specific fields to fetch from the TwitterDirectMessage
     */
    select?: TwitterDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterDirectMessageInclude | null
    /**
     * The data needed to update a TwitterDirectMessage.
     */
    data: XOR<TwitterDirectMessageUpdateInput, TwitterDirectMessageUncheckedUpdateInput>
    /**
     * Choose, which TwitterDirectMessage to update.
     */
    where: TwitterDirectMessageWhereUniqueInput
  }


  /**
   * TwitterDirectMessage updateMany
   */
  export type TwitterDirectMessageUpdateManyArgs = {
    /**
     * The data used to update TwitterDirectMessages.
     */
    data: XOR<TwitterDirectMessageUpdateManyMutationInput, TwitterDirectMessageUncheckedUpdateManyInput>
    /**
     * Filter which TwitterDirectMessages to update
     */
    where?: TwitterDirectMessageWhereInput
  }


  /**
   * TwitterDirectMessage upsert
   */
  export type TwitterDirectMessageUpsertArgs = {
    /**
     * Select specific fields to fetch from the TwitterDirectMessage
     */
    select?: TwitterDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterDirectMessageInclude | null
    /**
     * The filter to search for the TwitterDirectMessage to update in case it exists.
     */
    where: TwitterDirectMessageWhereUniqueInput
    /**
     * In case the TwitterDirectMessage found by the `where` argument doesn't exist, create a new TwitterDirectMessage with this data.
     */
    create: XOR<TwitterDirectMessageCreateInput, TwitterDirectMessageUncheckedCreateInput>
    /**
     * In case the TwitterDirectMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TwitterDirectMessageUpdateInput, TwitterDirectMessageUncheckedUpdateInput>
  }


  /**
   * TwitterDirectMessage delete
   */
  export type TwitterDirectMessageDeleteArgs = {
    /**
     * Select specific fields to fetch from the TwitterDirectMessage
     */
    select?: TwitterDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterDirectMessageInclude | null
    /**
     * Filter which TwitterDirectMessage to delete.
     */
    where: TwitterDirectMessageWhereUniqueInput
  }


  /**
   * TwitterDirectMessage deleteMany
   */
  export type TwitterDirectMessageDeleteManyArgs = {
    /**
     * Filter which TwitterDirectMessages to delete
     */
    where?: TwitterDirectMessageWhereInput
  }


  /**
   * TwitterDirectMessage without action
   */
  export type TwitterDirectMessageArgs = {
    /**
     * Select specific fields to fetch from the TwitterDirectMessage
     */
    select?: TwitterDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterDirectMessageInclude | null
  }



  /**
   * Model TwitterHashtag
   */


  export type AggregateTwitterHashtag = {
    _count: TwitterHashtagCountAggregateOutputType | null
    _avg: TwitterHashtagAvgAggregateOutputType | null
    _sum: TwitterHashtagSumAggregateOutputType | null
    _min: TwitterHashtagMinAggregateOutputType | null
    _max: TwitterHashtagMaxAggregateOutputType | null
  }

  export type TwitterHashtagAvgAggregateOutputType = {
    id: number | null
  }

  export type TwitterHashtagSumAggregateOutputType = {
    id: number | null
  }

  export type TwitterHashtagMinAggregateOutputType = {
    id: number | null
    hashtag: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TwitterHashtagMaxAggregateOutputType = {
    id: number | null
    hashtag: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TwitterHashtagCountAggregateOutputType = {
    id: number
    hashtag: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TwitterHashtagAvgAggregateInputType = {
    id?: true
  }

  export type TwitterHashtagSumAggregateInputType = {
    id?: true
  }

  export type TwitterHashtagMinAggregateInputType = {
    id?: true
    hashtag?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TwitterHashtagMaxAggregateInputType = {
    id?: true
    hashtag?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TwitterHashtagCountAggregateInputType = {
    id?: true
    hashtag?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TwitterHashtagAggregateArgs = {
    /**
     * Filter which TwitterHashtag to aggregate.
     */
    where?: TwitterHashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterHashtags to fetch.
     */
    orderBy?: Enumerable<TwitterHashtagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TwitterHashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterHashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterHashtags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TwitterHashtags
    **/
    _count?: true | TwitterHashtagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TwitterHashtagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TwitterHashtagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TwitterHashtagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TwitterHashtagMaxAggregateInputType
  }

  export type GetTwitterHashtagAggregateType<T extends TwitterHashtagAggregateArgs> = {
        [P in keyof T & keyof AggregateTwitterHashtag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTwitterHashtag[P]>
      : GetScalarType<T[P], AggregateTwitterHashtag[P]>
  }




  export type TwitterHashtagGroupByArgs = {
    where?: TwitterHashtagWhereInput
    orderBy?: Enumerable<TwitterHashtagOrderByWithAggregationInput>
    by: TwitterHashtagScalarFieldEnum[]
    having?: TwitterHashtagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TwitterHashtagCountAggregateInputType | true
    _avg?: TwitterHashtagAvgAggregateInputType
    _sum?: TwitterHashtagSumAggregateInputType
    _min?: TwitterHashtagMinAggregateInputType
    _max?: TwitterHashtagMaxAggregateInputType
  }


  export type TwitterHashtagGroupByOutputType = {
    id: number
    hashtag: string
    createdAt: Date
    updatedAt: Date
    _count: TwitterHashtagCountAggregateOutputType | null
    _avg: TwitterHashtagAvgAggregateOutputType | null
    _sum: TwitterHashtagSumAggregateOutputType | null
    _min: TwitterHashtagMinAggregateOutputType | null
    _max: TwitterHashtagMaxAggregateOutputType | null
  }

  type GetTwitterHashtagGroupByPayload<T extends TwitterHashtagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TwitterHashtagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TwitterHashtagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TwitterHashtagGroupByOutputType[P]>
            : GetScalarType<T[P], TwitterHashtagGroupByOutputType[P]>
        }
      >
    >


  export type TwitterHashtagSelect = {
    id?: boolean
    hashtag?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    postOnHashtag?: boolean | TwitterHashtag$postOnHashtagArgs
    _count?: boolean | TwitterHashtagCountOutputTypeArgs
  }


  export type TwitterHashtagInclude = {
    postOnHashtag?: boolean | TwitterHashtag$postOnHashtagArgs
    _count?: boolean | TwitterHashtagCountOutputTypeArgs
  }

  export type TwitterHashtagGetPayload<S extends boolean | null | undefined | TwitterHashtagArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TwitterHashtag :
    S extends undefined ? never :
    S extends { include: any } & (TwitterHashtagArgs | TwitterHashtagFindManyArgs)
    ? TwitterHashtag  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'postOnHashtag' ? Array < TwitterPostOnHashtagGetPayload<S['include'][P]>>  :
        P extends '_count' ? TwitterHashtagCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TwitterHashtagArgs | TwitterHashtagFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'postOnHashtag' ? Array < TwitterPostOnHashtagGetPayload<S['select'][P]>>  :
        P extends '_count' ? TwitterHashtagCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof TwitterHashtag ? TwitterHashtag[P] : never
  } 
      : TwitterHashtag


  type TwitterHashtagCountArgs = 
    Omit<TwitterHashtagFindManyArgs, 'select' | 'include'> & {
      select?: TwitterHashtagCountAggregateInputType | true
    }

  export interface TwitterHashtagDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TwitterHashtag that matches the filter.
     * @param {TwitterHashtagFindUniqueArgs} args - Arguments to find a TwitterHashtag
     * @example
     * // Get one TwitterHashtag
     * const twitterHashtag = await prisma.twitterHashtag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TwitterHashtagFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TwitterHashtagFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TwitterHashtag'> extends True ? Prisma__TwitterHashtagClient<TwitterHashtagGetPayload<T>> : Prisma__TwitterHashtagClient<TwitterHashtagGetPayload<T> | null, null>

    /**
     * Find one TwitterHashtag that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TwitterHashtagFindUniqueOrThrowArgs} args - Arguments to find a TwitterHashtag
     * @example
     * // Get one TwitterHashtag
     * const twitterHashtag = await prisma.twitterHashtag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TwitterHashtagFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TwitterHashtagFindUniqueOrThrowArgs>
    ): Prisma__TwitterHashtagClient<TwitterHashtagGetPayload<T>>

    /**
     * Find the first TwitterHashtag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterHashtagFindFirstArgs} args - Arguments to find a TwitterHashtag
     * @example
     * // Get one TwitterHashtag
     * const twitterHashtag = await prisma.twitterHashtag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TwitterHashtagFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TwitterHashtagFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TwitterHashtag'> extends True ? Prisma__TwitterHashtagClient<TwitterHashtagGetPayload<T>> : Prisma__TwitterHashtagClient<TwitterHashtagGetPayload<T> | null, null>

    /**
     * Find the first TwitterHashtag that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterHashtagFindFirstOrThrowArgs} args - Arguments to find a TwitterHashtag
     * @example
     * // Get one TwitterHashtag
     * const twitterHashtag = await prisma.twitterHashtag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TwitterHashtagFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TwitterHashtagFindFirstOrThrowArgs>
    ): Prisma__TwitterHashtagClient<TwitterHashtagGetPayload<T>>

    /**
     * Find zero or more TwitterHashtags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterHashtagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TwitterHashtags
     * const twitterHashtags = await prisma.twitterHashtag.findMany()
     * 
     * // Get first 10 TwitterHashtags
     * const twitterHashtags = await prisma.twitterHashtag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const twitterHashtagWithIdOnly = await prisma.twitterHashtag.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TwitterHashtagFindManyArgs>(
      args?: SelectSubset<T, TwitterHashtagFindManyArgs>
    ): Prisma.PrismaPromise<Array<TwitterHashtagGetPayload<T>>>

    /**
     * Create a TwitterHashtag.
     * @param {TwitterHashtagCreateArgs} args - Arguments to create a TwitterHashtag.
     * @example
     * // Create one TwitterHashtag
     * const TwitterHashtag = await prisma.twitterHashtag.create({
     *   data: {
     *     // ... data to create a TwitterHashtag
     *   }
     * })
     * 
    **/
    create<T extends TwitterHashtagCreateArgs>(
      args: SelectSubset<T, TwitterHashtagCreateArgs>
    ): Prisma__TwitterHashtagClient<TwitterHashtagGetPayload<T>>

    /**
     * Create many TwitterHashtags.
     *     @param {TwitterHashtagCreateManyArgs} args - Arguments to create many TwitterHashtags.
     *     @example
     *     // Create many TwitterHashtags
     *     const twitterHashtag = await prisma.twitterHashtag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TwitterHashtagCreateManyArgs>(
      args?: SelectSubset<T, TwitterHashtagCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TwitterHashtag.
     * @param {TwitterHashtagDeleteArgs} args - Arguments to delete one TwitterHashtag.
     * @example
     * // Delete one TwitterHashtag
     * const TwitterHashtag = await prisma.twitterHashtag.delete({
     *   where: {
     *     // ... filter to delete one TwitterHashtag
     *   }
     * })
     * 
    **/
    delete<T extends TwitterHashtagDeleteArgs>(
      args: SelectSubset<T, TwitterHashtagDeleteArgs>
    ): Prisma__TwitterHashtagClient<TwitterHashtagGetPayload<T>>

    /**
     * Update one TwitterHashtag.
     * @param {TwitterHashtagUpdateArgs} args - Arguments to update one TwitterHashtag.
     * @example
     * // Update one TwitterHashtag
     * const twitterHashtag = await prisma.twitterHashtag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TwitterHashtagUpdateArgs>(
      args: SelectSubset<T, TwitterHashtagUpdateArgs>
    ): Prisma__TwitterHashtagClient<TwitterHashtagGetPayload<T>>

    /**
     * Delete zero or more TwitterHashtags.
     * @param {TwitterHashtagDeleteManyArgs} args - Arguments to filter TwitterHashtags to delete.
     * @example
     * // Delete a few TwitterHashtags
     * const { count } = await prisma.twitterHashtag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TwitterHashtagDeleteManyArgs>(
      args?: SelectSubset<T, TwitterHashtagDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TwitterHashtags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterHashtagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TwitterHashtags
     * const twitterHashtag = await prisma.twitterHashtag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TwitterHashtagUpdateManyArgs>(
      args: SelectSubset<T, TwitterHashtagUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TwitterHashtag.
     * @param {TwitterHashtagUpsertArgs} args - Arguments to update or create a TwitterHashtag.
     * @example
     * // Update or create a TwitterHashtag
     * const twitterHashtag = await prisma.twitterHashtag.upsert({
     *   create: {
     *     // ... data to create a TwitterHashtag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TwitterHashtag we want to update
     *   }
     * })
    **/
    upsert<T extends TwitterHashtagUpsertArgs>(
      args: SelectSubset<T, TwitterHashtagUpsertArgs>
    ): Prisma__TwitterHashtagClient<TwitterHashtagGetPayload<T>>

    /**
     * Count the number of TwitterHashtags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterHashtagCountArgs} args - Arguments to filter TwitterHashtags to count.
     * @example
     * // Count the number of TwitterHashtags
     * const count = await prisma.twitterHashtag.count({
     *   where: {
     *     // ... the filter for the TwitterHashtags we want to count
     *   }
     * })
    **/
    count<T extends TwitterHashtagCountArgs>(
      args?: Subset<T, TwitterHashtagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TwitterHashtagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TwitterHashtag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterHashtagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TwitterHashtagAggregateArgs>(args: Subset<T, TwitterHashtagAggregateArgs>): Prisma.PrismaPromise<GetTwitterHashtagAggregateType<T>>

    /**
     * Group by TwitterHashtag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterHashtagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TwitterHashtagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TwitterHashtagGroupByArgs['orderBy'] }
        : { orderBy?: TwitterHashtagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TwitterHashtagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTwitterHashtagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TwitterHashtag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TwitterHashtagClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    postOnHashtag<T extends TwitterHashtag$postOnHashtagArgs= {}>(args?: Subset<T, TwitterHashtag$postOnHashtagArgs>): Prisma.PrismaPromise<Array<TwitterPostOnHashtagGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TwitterHashtag base type for findUnique actions
   */
  export type TwitterHashtagFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TwitterHashtag
     */
    select?: TwitterHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterHashtagInclude | null
    /**
     * Filter, which TwitterHashtag to fetch.
     */
    where: TwitterHashtagWhereUniqueInput
  }

  /**
   * TwitterHashtag findUnique
   */
  export interface TwitterHashtagFindUniqueArgs extends TwitterHashtagFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TwitterHashtag findUniqueOrThrow
   */
  export type TwitterHashtagFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TwitterHashtag
     */
    select?: TwitterHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterHashtagInclude | null
    /**
     * Filter, which TwitterHashtag to fetch.
     */
    where: TwitterHashtagWhereUniqueInput
  }


  /**
   * TwitterHashtag base type for findFirst actions
   */
  export type TwitterHashtagFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TwitterHashtag
     */
    select?: TwitterHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterHashtagInclude | null
    /**
     * Filter, which TwitterHashtag to fetch.
     */
    where?: TwitterHashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterHashtags to fetch.
     */
    orderBy?: Enumerable<TwitterHashtagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterHashtags.
     */
    cursor?: TwitterHashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterHashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterHashtags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterHashtags.
     */
    distinct?: Enumerable<TwitterHashtagScalarFieldEnum>
  }

  /**
   * TwitterHashtag findFirst
   */
  export interface TwitterHashtagFindFirstArgs extends TwitterHashtagFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TwitterHashtag findFirstOrThrow
   */
  export type TwitterHashtagFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TwitterHashtag
     */
    select?: TwitterHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterHashtagInclude | null
    /**
     * Filter, which TwitterHashtag to fetch.
     */
    where?: TwitterHashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterHashtags to fetch.
     */
    orderBy?: Enumerable<TwitterHashtagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterHashtags.
     */
    cursor?: TwitterHashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterHashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterHashtags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterHashtags.
     */
    distinct?: Enumerable<TwitterHashtagScalarFieldEnum>
  }


  /**
   * TwitterHashtag findMany
   */
  export type TwitterHashtagFindManyArgs = {
    /**
     * Select specific fields to fetch from the TwitterHashtag
     */
    select?: TwitterHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterHashtagInclude | null
    /**
     * Filter, which TwitterHashtags to fetch.
     */
    where?: TwitterHashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterHashtags to fetch.
     */
    orderBy?: Enumerable<TwitterHashtagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TwitterHashtags.
     */
    cursor?: TwitterHashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterHashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterHashtags.
     */
    skip?: number
    distinct?: Enumerable<TwitterHashtagScalarFieldEnum>
  }


  /**
   * TwitterHashtag create
   */
  export type TwitterHashtagCreateArgs = {
    /**
     * Select specific fields to fetch from the TwitterHashtag
     */
    select?: TwitterHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterHashtagInclude | null
    /**
     * The data needed to create a TwitterHashtag.
     */
    data: XOR<TwitterHashtagCreateInput, TwitterHashtagUncheckedCreateInput>
  }


  /**
   * TwitterHashtag createMany
   */
  export type TwitterHashtagCreateManyArgs = {
    /**
     * The data used to create many TwitterHashtags.
     */
    data: Enumerable<TwitterHashtagCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TwitterHashtag update
   */
  export type TwitterHashtagUpdateArgs = {
    /**
     * Select specific fields to fetch from the TwitterHashtag
     */
    select?: TwitterHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterHashtagInclude | null
    /**
     * The data needed to update a TwitterHashtag.
     */
    data: XOR<TwitterHashtagUpdateInput, TwitterHashtagUncheckedUpdateInput>
    /**
     * Choose, which TwitterHashtag to update.
     */
    where: TwitterHashtagWhereUniqueInput
  }


  /**
   * TwitterHashtag updateMany
   */
  export type TwitterHashtagUpdateManyArgs = {
    /**
     * The data used to update TwitterHashtags.
     */
    data: XOR<TwitterHashtagUpdateManyMutationInput, TwitterHashtagUncheckedUpdateManyInput>
    /**
     * Filter which TwitterHashtags to update
     */
    where?: TwitterHashtagWhereInput
  }


  /**
   * TwitterHashtag upsert
   */
  export type TwitterHashtagUpsertArgs = {
    /**
     * Select specific fields to fetch from the TwitterHashtag
     */
    select?: TwitterHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterHashtagInclude | null
    /**
     * The filter to search for the TwitterHashtag to update in case it exists.
     */
    where: TwitterHashtagWhereUniqueInput
    /**
     * In case the TwitterHashtag found by the `where` argument doesn't exist, create a new TwitterHashtag with this data.
     */
    create: XOR<TwitterHashtagCreateInput, TwitterHashtagUncheckedCreateInput>
    /**
     * In case the TwitterHashtag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TwitterHashtagUpdateInput, TwitterHashtagUncheckedUpdateInput>
  }


  /**
   * TwitterHashtag delete
   */
  export type TwitterHashtagDeleteArgs = {
    /**
     * Select specific fields to fetch from the TwitterHashtag
     */
    select?: TwitterHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterHashtagInclude | null
    /**
     * Filter which TwitterHashtag to delete.
     */
    where: TwitterHashtagWhereUniqueInput
  }


  /**
   * TwitterHashtag deleteMany
   */
  export type TwitterHashtagDeleteManyArgs = {
    /**
     * Filter which TwitterHashtags to delete
     */
    where?: TwitterHashtagWhereInput
  }


  /**
   * TwitterHashtag.postOnHashtag
   */
  export type TwitterHashtag$postOnHashtagArgs = {
    /**
     * Select specific fields to fetch from the TwitterPostOnHashtag
     */
    select?: TwitterPostOnHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostOnHashtagInclude | null
    where?: TwitterPostOnHashtagWhereInput
    orderBy?: Enumerable<TwitterPostOnHashtagOrderByWithRelationInput>
    cursor?: TwitterPostOnHashtagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TwitterPostOnHashtagScalarFieldEnum>
  }


  /**
   * TwitterHashtag without action
   */
  export type TwitterHashtagArgs = {
    /**
     * Select specific fields to fetch from the TwitterHashtag
     */
    select?: TwitterHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterHashtagInclude | null
  }



  /**
   * Model TwitterComment
   */


  export type AggregateTwitterComment = {
    _count: TwitterCommentCountAggregateOutputType | null
    _avg: TwitterCommentAvgAggregateOutputType | null
    _sum: TwitterCommentSumAggregateOutputType | null
    _min: TwitterCommentMinAggregateOutputType | null
    _max: TwitterCommentMaxAggregateOutputType | null
  }

  export type TwitterCommentAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    postId: number | null
  }

  export type TwitterCommentSumAggregateOutputType = {
    id: number | null
    userId: number | null
    postId: number | null
  }

  export type TwitterCommentMinAggregateOutputType = {
    id: number | null
    text: string | null
    userId: number | null
    postId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TwitterCommentMaxAggregateOutputType = {
    id: number | null
    text: string | null
    userId: number | null
    postId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TwitterCommentCountAggregateOutputType = {
    id: number
    text: number
    userId: number
    postId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TwitterCommentAvgAggregateInputType = {
    id?: true
    userId?: true
    postId?: true
  }

  export type TwitterCommentSumAggregateInputType = {
    id?: true
    userId?: true
    postId?: true
  }

  export type TwitterCommentMinAggregateInputType = {
    id?: true
    text?: true
    userId?: true
    postId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TwitterCommentMaxAggregateInputType = {
    id?: true
    text?: true
    userId?: true
    postId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TwitterCommentCountAggregateInputType = {
    id?: true
    text?: true
    userId?: true
    postId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TwitterCommentAggregateArgs = {
    /**
     * Filter which TwitterComment to aggregate.
     */
    where?: TwitterCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterComments to fetch.
     */
    orderBy?: Enumerable<TwitterCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TwitterCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TwitterComments
    **/
    _count?: true | TwitterCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TwitterCommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TwitterCommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TwitterCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TwitterCommentMaxAggregateInputType
  }

  export type GetTwitterCommentAggregateType<T extends TwitterCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateTwitterComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTwitterComment[P]>
      : GetScalarType<T[P], AggregateTwitterComment[P]>
  }




  export type TwitterCommentGroupByArgs = {
    where?: TwitterCommentWhereInput
    orderBy?: Enumerable<TwitterCommentOrderByWithAggregationInput>
    by: TwitterCommentScalarFieldEnum[]
    having?: TwitterCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TwitterCommentCountAggregateInputType | true
    _avg?: TwitterCommentAvgAggregateInputType
    _sum?: TwitterCommentSumAggregateInputType
    _min?: TwitterCommentMinAggregateInputType
    _max?: TwitterCommentMaxAggregateInputType
  }


  export type TwitterCommentGroupByOutputType = {
    id: number
    text: string
    userId: number
    postId: number
    createdAt: Date
    updatedAt: Date
    _count: TwitterCommentCountAggregateOutputType | null
    _avg: TwitterCommentAvgAggregateOutputType | null
    _sum: TwitterCommentSumAggregateOutputType | null
    _min: TwitterCommentMinAggregateOutputType | null
    _max: TwitterCommentMaxAggregateOutputType | null
  }

  type GetTwitterCommentGroupByPayload<T extends TwitterCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TwitterCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TwitterCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TwitterCommentGroupByOutputType[P]>
            : GetScalarType<T[P], TwitterCommentGroupByOutputType[P]>
        }
      >
    >


  export type TwitterCommentSelect = {
    id?: boolean
    text?: boolean
    user?: boolean | TwitterUserArgs
    userId?: boolean
    post?: boolean | TwitterPostArgs
    postId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type TwitterCommentInclude = {
    user?: boolean | TwitterUserArgs
    post?: boolean | TwitterPostArgs
  }

  export type TwitterCommentGetPayload<S extends boolean | null | undefined | TwitterCommentArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TwitterComment :
    S extends undefined ? never :
    S extends { include: any } & (TwitterCommentArgs | TwitterCommentFindManyArgs)
    ? TwitterComment  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? TwitterUserGetPayload<S['include'][P]> :
        P extends 'post' ? TwitterPostGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TwitterCommentArgs | TwitterCommentFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? TwitterUserGetPayload<S['select'][P]> :
        P extends 'post' ? TwitterPostGetPayload<S['select'][P]> :  P extends keyof TwitterComment ? TwitterComment[P] : never
  } 
      : TwitterComment


  type TwitterCommentCountArgs = 
    Omit<TwitterCommentFindManyArgs, 'select' | 'include'> & {
      select?: TwitterCommentCountAggregateInputType | true
    }

  export interface TwitterCommentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TwitterComment that matches the filter.
     * @param {TwitterCommentFindUniqueArgs} args - Arguments to find a TwitterComment
     * @example
     * // Get one TwitterComment
     * const twitterComment = await prisma.twitterComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TwitterCommentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TwitterCommentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TwitterComment'> extends True ? Prisma__TwitterCommentClient<TwitterCommentGetPayload<T>> : Prisma__TwitterCommentClient<TwitterCommentGetPayload<T> | null, null>

    /**
     * Find one TwitterComment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TwitterCommentFindUniqueOrThrowArgs} args - Arguments to find a TwitterComment
     * @example
     * // Get one TwitterComment
     * const twitterComment = await prisma.twitterComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TwitterCommentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TwitterCommentFindUniqueOrThrowArgs>
    ): Prisma__TwitterCommentClient<TwitterCommentGetPayload<T>>

    /**
     * Find the first TwitterComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterCommentFindFirstArgs} args - Arguments to find a TwitterComment
     * @example
     * // Get one TwitterComment
     * const twitterComment = await prisma.twitterComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TwitterCommentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TwitterCommentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TwitterComment'> extends True ? Prisma__TwitterCommentClient<TwitterCommentGetPayload<T>> : Prisma__TwitterCommentClient<TwitterCommentGetPayload<T> | null, null>

    /**
     * Find the first TwitterComment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterCommentFindFirstOrThrowArgs} args - Arguments to find a TwitterComment
     * @example
     * // Get one TwitterComment
     * const twitterComment = await prisma.twitterComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TwitterCommentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TwitterCommentFindFirstOrThrowArgs>
    ): Prisma__TwitterCommentClient<TwitterCommentGetPayload<T>>

    /**
     * Find zero or more TwitterComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterCommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TwitterComments
     * const twitterComments = await prisma.twitterComment.findMany()
     * 
     * // Get first 10 TwitterComments
     * const twitterComments = await prisma.twitterComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const twitterCommentWithIdOnly = await prisma.twitterComment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TwitterCommentFindManyArgs>(
      args?: SelectSubset<T, TwitterCommentFindManyArgs>
    ): Prisma.PrismaPromise<Array<TwitterCommentGetPayload<T>>>

    /**
     * Create a TwitterComment.
     * @param {TwitterCommentCreateArgs} args - Arguments to create a TwitterComment.
     * @example
     * // Create one TwitterComment
     * const TwitterComment = await prisma.twitterComment.create({
     *   data: {
     *     // ... data to create a TwitterComment
     *   }
     * })
     * 
    **/
    create<T extends TwitterCommentCreateArgs>(
      args: SelectSubset<T, TwitterCommentCreateArgs>
    ): Prisma__TwitterCommentClient<TwitterCommentGetPayload<T>>

    /**
     * Create many TwitterComments.
     *     @param {TwitterCommentCreateManyArgs} args - Arguments to create many TwitterComments.
     *     @example
     *     // Create many TwitterComments
     *     const twitterComment = await prisma.twitterComment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TwitterCommentCreateManyArgs>(
      args?: SelectSubset<T, TwitterCommentCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TwitterComment.
     * @param {TwitterCommentDeleteArgs} args - Arguments to delete one TwitterComment.
     * @example
     * // Delete one TwitterComment
     * const TwitterComment = await prisma.twitterComment.delete({
     *   where: {
     *     // ... filter to delete one TwitterComment
     *   }
     * })
     * 
    **/
    delete<T extends TwitterCommentDeleteArgs>(
      args: SelectSubset<T, TwitterCommentDeleteArgs>
    ): Prisma__TwitterCommentClient<TwitterCommentGetPayload<T>>

    /**
     * Update one TwitterComment.
     * @param {TwitterCommentUpdateArgs} args - Arguments to update one TwitterComment.
     * @example
     * // Update one TwitterComment
     * const twitterComment = await prisma.twitterComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TwitterCommentUpdateArgs>(
      args: SelectSubset<T, TwitterCommentUpdateArgs>
    ): Prisma__TwitterCommentClient<TwitterCommentGetPayload<T>>

    /**
     * Delete zero or more TwitterComments.
     * @param {TwitterCommentDeleteManyArgs} args - Arguments to filter TwitterComments to delete.
     * @example
     * // Delete a few TwitterComments
     * const { count } = await prisma.twitterComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TwitterCommentDeleteManyArgs>(
      args?: SelectSubset<T, TwitterCommentDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TwitterComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TwitterComments
     * const twitterComment = await prisma.twitterComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TwitterCommentUpdateManyArgs>(
      args: SelectSubset<T, TwitterCommentUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TwitterComment.
     * @param {TwitterCommentUpsertArgs} args - Arguments to update or create a TwitterComment.
     * @example
     * // Update or create a TwitterComment
     * const twitterComment = await prisma.twitterComment.upsert({
     *   create: {
     *     // ... data to create a TwitterComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TwitterComment we want to update
     *   }
     * })
    **/
    upsert<T extends TwitterCommentUpsertArgs>(
      args: SelectSubset<T, TwitterCommentUpsertArgs>
    ): Prisma__TwitterCommentClient<TwitterCommentGetPayload<T>>

    /**
     * Count the number of TwitterComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterCommentCountArgs} args - Arguments to filter TwitterComments to count.
     * @example
     * // Count the number of TwitterComments
     * const count = await prisma.twitterComment.count({
     *   where: {
     *     // ... the filter for the TwitterComments we want to count
     *   }
     * })
    **/
    count<T extends TwitterCommentCountArgs>(
      args?: Subset<T, TwitterCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TwitterCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TwitterComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TwitterCommentAggregateArgs>(args: Subset<T, TwitterCommentAggregateArgs>): Prisma.PrismaPromise<GetTwitterCommentAggregateType<T>>

    /**
     * Group by TwitterComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TwitterCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TwitterCommentGroupByArgs['orderBy'] }
        : { orderBy?: TwitterCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TwitterCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTwitterCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TwitterComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TwitterCommentClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends TwitterUserArgs= {}>(args?: Subset<T, TwitterUserArgs>): Prisma__TwitterUserClient<TwitterUserGetPayload<T> | Null>;

    post<T extends TwitterPostArgs= {}>(args?: Subset<T, TwitterPostArgs>): Prisma__TwitterPostClient<TwitterPostGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TwitterComment base type for findUnique actions
   */
  export type TwitterCommentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TwitterComment
     */
    select?: TwitterCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterCommentInclude | null
    /**
     * Filter, which TwitterComment to fetch.
     */
    where: TwitterCommentWhereUniqueInput
  }

  /**
   * TwitterComment findUnique
   */
  export interface TwitterCommentFindUniqueArgs extends TwitterCommentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TwitterComment findUniqueOrThrow
   */
  export type TwitterCommentFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TwitterComment
     */
    select?: TwitterCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterCommentInclude | null
    /**
     * Filter, which TwitterComment to fetch.
     */
    where: TwitterCommentWhereUniqueInput
  }


  /**
   * TwitterComment base type for findFirst actions
   */
  export type TwitterCommentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TwitterComment
     */
    select?: TwitterCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterCommentInclude | null
    /**
     * Filter, which TwitterComment to fetch.
     */
    where?: TwitterCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterComments to fetch.
     */
    orderBy?: Enumerable<TwitterCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterComments.
     */
    cursor?: TwitterCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterComments.
     */
    distinct?: Enumerable<TwitterCommentScalarFieldEnum>
  }

  /**
   * TwitterComment findFirst
   */
  export interface TwitterCommentFindFirstArgs extends TwitterCommentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TwitterComment findFirstOrThrow
   */
  export type TwitterCommentFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TwitterComment
     */
    select?: TwitterCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterCommentInclude | null
    /**
     * Filter, which TwitterComment to fetch.
     */
    where?: TwitterCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterComments to fetch.
     */
    orderBy?: Enumerable<TwitterCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterComments.
     */
    cursor?: TwitterCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterComments.
     */
    distinct?: Enumerable<TwitterCommentScalarFieldEnum>
  }


  /**
   * TwitterComment findMany
   */
  export type TwitterCommentFindManyArgs = {
    /**
     * Select specific fields to fetch from the TwitterComment
     */
    select?: TwitterCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterCommentInclude | null
    /**
     * Filter, which TwitterComments to fetch.
     */
    where?: TwitterCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterComments to fetch.
     */
    orderBy?: Enumerable<TwitterCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TwitterComments.
     */
    cursor?: TwitterCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterComments.
     */
    skip?: number
    distinct?: Enumerable<TwitterCommentScalarFieldEnum>
  }


  /**
   * TwitterComment create
   */
  export type TwitterCommentCreateArgs = {
    /**
     * Select specific fields to fetch from the TwitterComment
     */
    select?: TwitterCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterCommentInclude | null
    /**
     * The data needed to create a TwitterComment.
     */
    data: XOR<TwitterCommentCreateInput, TwitterCommentUncheckedCreateInput>
  }


  /**
   * TwitterComment createMany
   */
  export type TwitterCommentCreateManyArgs = {
    /**
     * The data used to create many TwitterComments.
     */
    data: Enumerable<TwitterCommentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TwitterComment update
   */
  export type TwitterCommentUpdateArgs = {
    /**
     * Select specific fields to fetch from the TwitterComment
     */
    select?: TwitterCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterCommentInclude | null
    /**
     * The data needed to update a TwitterComment.
     */
    data: XOR<TwitterCommentUpdateInput, TwitterCommentUncheckedUpdateInput>
    /**
     * Choose, which TwitterComment to update.
     */
    where: TwitterCommentWhereUniqueInput
  }


  /**
   * TwitterComment updateMany
   */
  export type TwitterCommentUpdateManyArgs = {
    /**
     * The data used to update TwitterComments.
     */
    data: XOR<TwitterCommentUpdateManyMutationInput, TwitterCommentUncheckedUpdateManyInput>
    /**
     * Filter which TwitterComments to update
     */
    where?: TwitterCommentWhereInput
  }


  /**
   * TwitterComment upsert
   */
  export type TwitterCommentUpsertArgs = {
    /**
     * Select specific fields to fetch from the TwitterComment
     */
    select?: TwitterCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterCommentInclude | null
    /**
     * The filter to search for the TwitterComment to update in case it exists.
     */
    where: TwitterCommentWhereUniqueInput
    /**
     * In case the TwitterComment found by the `where` argument doesn't exist, create a new TwitterComment with this data.
     */
    create: XOR<TwitterCommentCreateInput, TwitterCommentUncheckedCreateInput>
    /**
     * In case the TwitterComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TwitterCommentUpdateInput, TwitterCommentUncheckedUpdateInput>
  }


  /**
   * TwitterComment delete
   */
  export type TwitterCommentDeleteArgs = {
    /**
     * Select specific fields to fetch from the TwitterComment
     */
    select?: TwitterCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterCommentInclude | null
    /**
     * Filter which TwitterComment to delete.
     */
    where: TwitterCommentWhereUniqueInput
  }


  /**
   * TwitterComment deleteMany
   */
  export type TwitterCommentDeleteManyArgs = {
    /**
     * Filter which TwitterComments to delete
     */
    where?: TwitterCommentWhereInput
  }


  /**
   * TwitterComment without action
   */
  export type TwitterCommentArgs = {
    /**
     * Select specific fields to fetch from the TwitterComment
     */
    select?: TwitterCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterCommentInclude | null
  }



  /**
   * Model TwitterPostOnHashtag
   */


  export type AggregateTwitterPostOnHashtag = {
    _count: TwitterPostOnHashtagCountAggregateOutputType | null
    _avg: TwitterPostOnHashtagAvgAggregateOutputType | null
    _sum: TwitterPostOnHashtagSumAggregateOutputType | null
    _min: TwitterPostOnHashtagMinAggregateOutputType | null
    _max: TwitterPostOnHashtagMaxAggregateOutputType | null
  }

  export type TwitterPostOnHashtagAvgAggregateOutputType = {
    id: number | null
    postId: number | null
    hashtagId: number | null
  }

  export type TwitterPostOnHashtagSumAggregateOutputType = {
    id: number | null
    postId: number | null
    hashtagId: number | null
  }

  export type TwitterPostOnHashtagMinAggregateOutputType = {
    id: number | null
    postId: number | null
    hashtagId: number | null
  }

  export type TwitterPostOnHashtagMaxAggregateOutputType = {
    id: number | null
    postId: number | null
    hashtagId: number | null
  }

  export type TwitterPostOnHashtagCountAggregateOutputType = {
    id: number
    postId: number
    hashtagId: number
    _all: number
  }


  export type TwitterPostOnHashtagAvgAggregateInputType = {
    id?: true
    postId?: true
    hashtagId?: true
  }

  export type TwitterPostOnHashtagSumAggregateInputType = {
    id?: true
    postId?: true
    hashtagId?: true
  }

  export type TwitterPostOnHashtagMinAggregateInputType = {
    id?: true
    postId?: true
    hashtagId?: true
  }

  export type TwitterPostOnHashtagMaxAggregateInputType = {
    id?: true
    postId?: true
    hashtagId?: true
  }

  export type TwitterPostOnHashtagCountAggregateInputType = {
    id?: true
    postId?: true
    hashtagId?: true
    _all?: true
  }

  export type TwitterPostOnHashtagAggregateArgs = {
    /**
     * Filter which TwitterPostOnHashtag to aggregate.
     */
    where?: TwitterPostOnHashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterPostOnHashtags to fetch.
     */
    orderBy?: Enumerable<TwitterPostOnHashtagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TwitterPostOnHashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterPostOnHashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterPostOnHashtags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TwitterPostOnHashtags
    **/
    _count?: true | TwitterPostOnHashtagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TwitterPostOnHashtagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TwitterPostOnHashtagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TwitterPostOnHashtagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TwitterPostOnHashtagMaxAggregateInputType
  }

  export type GetTwitterPostOnHashtagAggregateType<T extends TwitterPostOnHashtagAggregateArgs> = {
        [P in keyof T & keyof AggregateTwitterPostOnHashtag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTwitterPostOnHashtag[P]>
      : GetScalarType<T[P], AggregateTwitterPostOnHashtag[P]>
  }




  export type TwitterPostOnHashtagGroupByArgs = {
    where?: TwitterPostOnHashtagWhereInput
    orderBy?: Enumerable<TwitterPostOnHashtagOrderByWithAggregationInput>
    by: TwitterPostOnHashtagScalarFieldEnum[]
    having?: TwitterPostOnHashtagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TwitterPostOnHashtagCountAggregateInputType | true
    _avg?: TwitterPostOnHashtagAvgAggregateInputType
    _sum?: TwitterPostOnHashtagSumAggregateInputType
    _min?: TwitterPostOnHashtagMinAggregateInputType
    _max?: TwitterPostOnHashtagMaxAggregateInputType
  }


  export type TwitterPostOnHashtagGroupByOutputType = {
    id: number
    postId: number
    hashtagId: number
    _count: TwitterPostOnHashtagCountAggregateOutputType | null
    _avg: TwitterPostOnHashtagAvgAggregateOutputType | null
    _sum: TwitterPostOnHashtagSumAggregateOutputType | null
    _min: TwitterPostOnHashtagMinAggregateOutputType | null
    _max: TwitterPostOnHashtagMaxAggregateOutputType | null
  }

  type GetTwitterPostOnHashtagGroupByPayload<T extends TwitterPostOnHashtagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TwitterPostOnHashtagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TwitterPostOnHashtagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TwitterPostOnHashtagGroupByOutputType[P]>
            : GetScalarType<T[P], TwitterPostOnHashtagGroupByOutputType[P]>
        }
      >
    >


  export type TwitterPostOnHashtagSelect = {
    id?: boolean
    post?: boolean | TwitterPostArgs
    postId?: boolean
    hashtag?: boolean | TwitterHashtagArgs
    hashtagId?: boolean
  }


  export type TwitterPostOnHashtagInclude = {
    post?: boolean | TwitterPostArgs
    hashtag?: boolean | TwitterHashtagArgs
  }

  export type TwitterPostOnHashtagGetPayload<S extends boolean | null | undefined | TwitterPostOnHashtagArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TwitterPostOnHashtag :
    S extends undefined ? never :
    S extends { include: any } & (TwitterPostOnHashtagArgs | TwitterPostOnHashtagFindManyArgs)
    ? TwitterPostOnHashtag  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'post' ? TwitterPostGetPayload<S['include'][P]> :
        P extends 'hashtag' ? TwitterHashtagGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TwitterPostOnHashtagArgs | TwitterPostOnHashtagFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'post' ? TwitterPostGetPayload<S['select'][P]> :
        P extends 'hashtag' ? TwitterHashtagGetPayload<S['select'][P]> :  P extends keyof TwitterPostOnHashtag ? TwitterPostOnHashtag[P] : never
  } 
      : TwitterPostOnHashtag


  type TwitterPostOnHashtagCountArgs = 
    Omit<TwitterPostOnHashtagFindManyArgs, 'select' | 'include'> & {
      select?: TwitterPostOnHashtagCountAggregateInputType | true
    }

  export interface TwitterPostOnHashtagDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TwitterPostOnHashtag that matches the filter.
     * @param {TwitterPostOnHashtagFindUniqueArgs} args - Arguments to find a TwitterPostOnHashtag
     * @example
     * // Get one TwitterPostOnHashtag
     * const twitterPostOnHashtag = await prisma.twitterPostOnHashtag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TwitterPostOnHashtagFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TwitterPostOnHashtagFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TwitterPostOnHashtag'> extends True ? Prisma__TwitterPostOnHashtagClient<TwitterPostOnHashtagGetPayload<T>> : Prisma__TwitterPostOnHashtagClient<TwitterPostOnHashtagGetPayload<T> | null, null>

    /**
     * Find one TwitterPostOnHashtag that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TwitterPostOnHashtagFindUniqueOrThrowArgs} args - Arguments to find a TwitterPostOnHashtag
     * @example
     * // Get one TwitterPostOnHashtag
     * const twitterPostOnHashtag = await prisma.twitterPostOnHashtag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TwitterPostOnHashtagFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TwitterPostOnHashtagFindUniqueOrThrowArgs>
    ): Prisma__TwitterPostOnHashtagClient<TwitterPostOnHashtagGetPayload<T>>

    /**
     * Find the first TwitterPostOnHashtag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterPostOnHashtagFindFirstArgs} args - Arguments to find a TwitterPostOnHashtag
     * @example
     * // Get one TwitterPostOnHashtag
     * const twitterPostOnHashtag = await prisma.twitterPostOnHashtag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TwitterPostOnHashtagFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TwitterPostOnHashtagFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TwitterPostOnHashtag'> extends True ? Prisma__TwitterPostOnHashtagClient<TwitterPostOnHashtagGetPayload<T>> : Prisma__TwitterPostOnHashtagClient<TwitterPostOnHashtagGetPayload<T> | null, null>

    /**
     * Find the first TwitterPostOnHashtag that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterPostOnHashtagFindFirstOrThrowArgs} args - Arguments to find a TwitterPostOnHashtag
     * @example
     * // Get one TwitterPostOnHashtag
     * const twitterPostOnHashtag = await prisma.twitterPostOnHashtag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TwitterPostOnHashtagFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TwitterPostOnHashtagFindFirstOrThrowArgs>
    ): Prisma__TwitterPostOnHashtagClient<TwitterPostOnHashtagGetPayload<T>>

    /**
     * Find zero or more TwitterPostOnHashtags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterPostOnHashtagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TwitterPostOnHashtags
     * const twitterPostOnHashtags = await prisma.twitterPostOnHashtag.findMany()
     * 
     * // Get first 10 TwitterPostOnHashtags
     * const twitterPostOnHashtags = await prisma.twitterPostOnHashtag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const twitterPostOnHashtagWithIdOnly = await prisma.twitterPostOnHashtag.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TwitterPostOnHashtagFindManyArgs>(
      args?: SelectSubset<T, TwitterPostOnHashtagFindManyArgs>
    ): Prisma.PrismaPromise<Array<TwitterPostOnHashtagGetPayload<T>>>

    /**
     * Create a TwitterPostOnHashtag.
     * @param {TwitterPostOnHashtagCreateArgs} args - Arguments to create a TwitterPostOnHashtag.
     * @example
     * // Create one TwitterPostOnHashtag
     * const TwitterPostOnHashtag = await prisma.twitterPostOnHashtag.create({
     *   data: {
     *     // ... data to create a TwitterPostOnHashtag
     *   }
     * })
     * 
    **/
    create<T extends TwitterPostOnHashtagCreateArgs>(
      args: SelectSubset<T, TwitterPostOnHashtagCreateArgs>
    ): Prisma__TwitterPostOnHashtagClient<TwitterPostOnHashtagGetPayload<T>>

    /**
     * Create many TwitterPostOnHashtags.
     *     @param {TwitterPostOnHashtagCreateManyArgs} args - Arguments to create many TwitterPostOnHashtags.
     *     @example
     *     // Create many TwitterPostOnHashtags
     *     const twitterPostOnHashtag = await prisma.twitterPostOnHashtag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TwitterPostOnHashtagCreateManyArgs>(
      args?: SelectSubset<T, TwitterPostOnHashtagCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TwitterPostOnHashtag.
     * @param {TwitterPostOnHashtagDeleteArgs} args - Arguments to delete one TwitterPostOnHashtag.
     * @example
     * // Delete one TwitterPostOnHashtag
     * const TwitterPostOnHashtag = await prisma.twitterPostOnHashtag.delete({
     *   where: {
     *     // ... filter to delete one TwitterPostOnHashtag
     *   }
     * })
     * 
    **/
    delete<T extends TwitterPostOnHashtagDeleteArgs>(
      args: SelectSubset<T, TwitterPostOnHashtagDeleteArgs>
    ): Prisma__TwitterPostOnHashtagClient<TwitterPostOnHashtagGetPayload<T>>

    /**
     * Update one TwitterPostOnHashtag.
     * @param {TwitterPostOnHashtagUpdateArgs} args - Arguments to update one TwitterPostOnHashtag.
     * @example
     * // Update one TwitterPostOnHashtag
     * const twitterPostOnHashtag = await prisma.twitterPostOnHashtag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TwitterPostOnHashtagUpdateArgs>(
      args: SelectSubset<T, TwitterPostOnHashtagUpdateArgs>
    ): Prisma__TwitterPostOnHashtagClient<TwitterPostOnHashtagGetPayload<T>>

    /**
     * Delete zero or more TwitterPostOnHashtags.
     * @param {TwitterPostOnHashtagDeleteManyArgs} args - Arguments to filter TwitterPostOnHashtags to delete.
     * @example
     * // Delete a few TwitterPostOnHashtags
     * const { count } = await prisma.twitterPostOnHashtag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TwitterPostOnHashtagDeleteManyArgs>(
      args?: SelectSubset<T, TwitterPostOnHashtagDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TwitterPostOnHashtags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterPostOnHashtagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TwitterPostOnHashtags
     * const twitterPostOnHashtag = await prisma.twitterPostOnHashtag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TwitterPostOnHashtagUpdateManyArgs>(
      args: SelectSubset<T, TwitterPostOnHashtagUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TwitterPostOnHashtag.
     * @param {TwitterPostOnHashtagUpsertArgs} args - Arguments to update or create a TwitterPostOnHashtag.
     * @example
     * // Update or create a TwitterPostOnHashtag
     * const twitterPostOnHashtag = await prisma.twitterPostOnHashtag.upsert({
     *   create: {
     *     // ... data to create a TwitterPostOnHashtag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TwitterPostOnHashtag we want to update
     *   }
     * })
    **/
    upsert<T extends TwitterPostOnHashtagUpsertArgs>(
      args: SelectSubset<T, TwitterPostOnHashtagUpsertArgs>
    ): Prisma__TwitterPostOnHashtagClient<TwitterPostOnHashtagGetPayload<T>>

    /**
     * Count the number of TwitterPostOnHashtags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterPostOnHashtagCountArgs} args - Arguments to filter TwitterPostOnHashtags to count.
     * @example
     * // Count the number of TwitterPostOnHashtags
     * const count = await prisma.twitterPostOnHashtag.count({
     *   where: {
     *     // ... the filter for the TwitterPostOnHashtags we want to count
     *   }
     * })
    **/
    count<T extends TwitterPostOnHashtagCountArgs>(
      args?: Subset<T, TwitterPostOnHashtagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TwitterPostOnHashtagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TwitterPostOnHashtag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterPostOnHashtagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TwitterPostOnHashtagAggregateArgs>(args: Subset<T, TwitterPostOnHashtagAggregateArgs>): Prisma.PrismaPromise<GetTwitterPostOnHashtagAggregateType<T>>

    /**
     * Group by TwitterPostOnHashtag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterPostOnHashtagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TwitterPostOnHashtagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TwitterPostOnHashtagGroupByArgs['orderBy'] }
        : { orderBy?: TwitterPostOnHashtagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TwitterPostOnHashtagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTwitterPostOnHashtagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TwitterPostOnHashtag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TwitterPostOnHashtagClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    post<T extends TwitterPostArgs= {}>(args?: Subset<T, TwitterPostArgs>): Prisma__TwitterPostClient<TwitterPostGetPayload<T> | Null>;

    hashtag<T extends TwitterHashtagArgs= {}>(args?: Subset<T, TwitterHashtagArgs>): Prisma__TwitterHashtagClient<TwitterHashtagGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TwitterPostOnHashtag base type for findUnique actions
   */
  export type TwitterPostOnHashtagFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TwitterPostOnHashtag
     */
    select?: TwitterPostOnHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostOnHashtagInclude | null
    /**
     * Filter, which TwitterPostOnHashtag to fetch.
     */
    where: TwitterPostOnHashtagWhereUniqueInput
  }

  /**
   * TwitterPostOnHashtag findUnique
   */
  export interface TwitterPostOnHashtagFindUniqueArgs extends TwitterPostOnHashtagFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TwitterPostOnHashtag findUniqueOrThrow
   */
  export type TwitterPostOnHashtagFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TwitterPostOnHashtag
     */
    select?: TwitterPostOnHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostOnHashtagInclude | null
    /**
     * Filter, which TwitterPostOnHashtag to fetch.
     */
    where: TwitterPostOnHashtagWhereUniqueInput
  }


  /**
   * TwitterPostOnHashtag base type for findFirst actions
   */
  export type TwitterPostOnHashtagFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TwitterPostOnHashtag
     */
    select?: TwitterPostOnHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostOnHashtagInclude | null
    /**
     * Filter, which TwitterPostOnHashtag to fetch.
     */
    where?: TwitterPostOnHashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterPostOnHashtags to fetch.
     */
    orderBy?: Enumerable<TwitterPostOnHashtagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterPostOnHashtags.
     */
    cursor?: TwitterPostOnHashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterPostOnHashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterPostOnHashtags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterPostOnHashtags.
     */
    distinct?: Enumerable<TwitterPostOnHashtagScalarFieldEnum>
  }

  /**
   * TwitterPostOnHashtag findFirst
   */
  export interface TwitterPostOnHashtagFindFirstArgs extends TwitterPostOnHashtagFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TwitterPostOnHashtag findFirstOrThrow
   */
  export type TwitterPostOnHashtagFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TwitterPostOnHashtag
     */
    select?: TwitterPostOnHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostOnHashtagInclude | null
    /**
     * Filter, which TwitterPostOnHashtag to fetch.
     */
    where?: TwitterPostOnHashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterPostOnHashtags to fetch.
     */
    orderBy?: Enumerable<TwitterPostOnHashtagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterPostOnHashtags.
     */
    cursor?: TwitterPostOnHashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterPostOnHashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterPostOnHashtags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterPostOnHashtags.
     */
    distinct?: Enumerable<TwitterPostOnHashtagScalarFieldEnum>
  }


  /**
   * TwitterPostOnHashtag findMany
   */
  export type TwitterPostOnHashtagFindManyArgs = {
    /**
     * Select specific fields to fetch from the TwitterPostOnHashtag
     */
    select?: TwitterPostOnHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostOnHashtagInclude | null
    /**
     * Filter, which TwitterPostOnHashtags to fetch.
     */
    where?: TwitterPostOnHashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterPostOnHashtags to fetch.
     */
    orderBy?: Enumerable<TwitterPostOnHashtagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TwitterPostOnHashtags.
     */
    cursor?: TwitterPostOnHashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterPostOnHashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterPostOnHashtags.
     */
    skip?: number
    distinct?: Enumerable<TwitterPostOnHashtagScalarFieldEnum>
  }


  /**
   * TwitterPostOnHashtag create
   */
  export type TwitterPostOnHashtagCreateArgs = {
    /**
     * Select specific fields to fetch from the TwitterPostOnHashtag
     */
    select?: TwitterPostOnHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostOnHashtagInclude | null
    /**
     * The data needed to create a TwitterPostOnHashtag.
     */
    data: XOR<TwitterPostOnHashtagCreateInput, TwitterPostOnHashtagUncheckedCreateInput>
  }


  /**
   * TwitterPostOnHashtag createMany
   */
  export type TwitterPostOnHashtagCreateManyArgs = {
    /**
     * The data used to create many TwitterPostOnHashtags.
     */
    data: Enumerable<TwitterPostOnHashtagCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TwitterPostOnHashtag update
   */
  export type TwitterPostOnHashtagUpdateArgs = {
    /**
     * Select specific fields to fetch from the TwitterPostOnHashtag
     */
    select?: TwitterPostOnHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostOnHashtagInclude | null
    /**
     * The data needed to update a TwitterPostOnHashtag.
     */
    data: XOR<TwitterPostOnHashtagUpdateInput, TwitterPostOnHashtagUncheckedUpdateInput>
    /**
     * Choose, which TwitterPostOnHashtag to update.
     */
    where: TwitterPostOnHashtagWhereUniqueInput
  }


  /**
   * TwitterPostOnHashtag updateMany
   */
  export type TwitterPostOnHashtagUpdateManyArgs = {
    /**
     * The data used to update TwitterPostOnHashtags.
     */
    data: XOR<TwitterPostOnHashtagUpdateManyMutationInput, TwitterPostOnHashtagUncheckedUpdateManyInput>
    /**
     * Filter which TwitterPostOnHashtags to update
     */
    where?: TwitterPostOnHashtagWhereInput
  }


  /**
   * TwitterPostOnHashtag upsert
   */
  export type TwitterPostOnHashtagUpsertArgs = {
    /**
     * Select specific fields to fetch from the TwitterPostOnHashtag
     */
    select?: TwitterPostOnHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostOnHashtagInclude | null
    /**
     * The filter to search for the TwitterPostOnHashtag to update in case it exists.
     */
    where: TwitterPostOnHashtagWhereUniqueInput
    /**
     * In case the TwitterPostOnHashtag found by the `where` argument doesn't exist, create a new TwitterPostOnHashtag with this data.
     */
    create: XOR<TwitterPostOnHashtagCreateInput, TwitterPostOnHashtagUncheckedCreateInput>
    /**
     * In case the TwitterPostOnHashtag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TwitterPostOnHashtagUpdateInput, TwitterPostOnHashtagUncheckedUpdateInput>
  }


  /**
   * TwitterPostOnHashtag delete
   */
  export type TwitterPostOnHashtagDeleteArgs = {
    /**
     * Select specific fields to fetch from the TwitterPostOnHashtag
     */
    select?: TwitterPostOnHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostOnHashtagInclude | null
    /**
     * Filter which TwitterPostOnHashtag to delete.
     */
    where: TwitterPostOnHashtagWhereUniqueInput
  }


  /**
   * TwitterPostOnHashtag deleteMany
   */
  export type TwitterPostOnHashtagDeleteManyArgs = {
    /**
     * Filter which TwitterPostOnHashtags to delete
     */
    where?: TwitterPostOnHashtagWhereInput
  }


  /**
   * TwitterPostOnHashtag without action
   */
  export type TwitterPostOnHashtagArgs = {
    /**
     * Select specific fields to fetch from the TwitterPostOnHashtag
     */
    select?: TwitterPostOnHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostOnHashtagInclude | null
  }



  /**
   * Model WSUser
   */


  export type AggregateWSUser = {
    _count: WSUserCountAggregateOutputType | null
    _avg: WSUserAvgAggregateOutputType | null
    _sum: WSUserSumAggregateOutputType | null
    _min: WSUserMinAggregateOutputType | null
    _max: WSUserMaxAggregateOutputType | null
  }

  export type WSUserAvgAggregateOutputType = {
    id: number | null
    tel: number | null
    myWallet: number | null
  }

  export type WSUserSumAggregateOutputType = {
    id: number | null
    tel: number | null
    myWallet: number | null
  }

  export type WSUserMinAggregateOutputType = {
    id: number | null
    name: string | null
    tel: number | null
    myWallet: number | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type WSUserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    tel: number | null
    myWallet: number | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type WSUserCountAggregateOutputType = {
    id: number
    name: number
    tel: number
    myWallet: number
    createdAt: number
    updateAt: number
    _all: number
  }


  export type WSUserAvgAggregateInputType = {
    id?: true
    tel?: true
    myWallet?: true
  }

  export type WSUserSumAggregateInputType = {
    id?: true
    tel?: true
    myWallet?: true
  }

  export type WSUserMinAggregateInputType = {
    id?: true
    name?: true
    tel?: true
    myWallet?: true
    createdAt?: true
    updateAt?: true
  }

  export type WSUserMaxAggregateInputType = {
    id?: true
    name?: true
    tel?: true
    myWallet?: true
    createdAt?: true
    updateAt?: true
  }

  export type WSUserCountAggregateInputType = {
    id?: true
    name?: true
    tel?: true
    myWallet?: true
    createdAt?: true
    updateAt?: true
    _all?: true
  }

  export type WSUserAggregateArgs = {
    /**
     * Filter which WSUser to aggregate.
     */
    where?: WSUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSUsers to fetch.
     */
    orderBy?: Enumerable<WSUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WSUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WSUsers
    **/
    _count?: true | WSUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WSUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WSUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WSUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WSUserMaxAggregateInputType
  }

  export type GetWSUserAggregateType<T extends WSUserAggregateArgs> = {
        [P in keyof T & keyof AggregateWSUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWSUser[P]>
      : GetScalarType<T[P], AggregateWSUser[P]>
  }




  export type WSUserGroupByArgs = {
    where?: WSUserWhereInput
    orderBy?: Enumerable<WSUserOrderByWithAggregationInput>
    by: WSUserScalarFieldEnum[]
    having?: WSUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WSUserCountAggregateInputType | true
    _avg?: WSUserAvgAggregateInputType
    _sum?: WSUserSumAggregateInputType
    _min?: WSUserMinAggregateInputType
    _max?: WSUserMaxAggregateInputType
  }


  export type WSUserGroupByOutputType = {
    id: number
    name: string
    tel: number
    myWallet: number
    createdAt: Date
    updateAt: Date
    _count: WSUserCountAggregateOutputType | null
    _avg: WSUserAvgAggregateOutputType | null
    _sum: WSUserSumAggregateOutputType | null
    _min: WSUserMinAggregateOutputType | null
    _max: WSUserMaxAggregateOutputType | null
  }

  type GetWSUserGroupByPayload<T extends WSUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<WSUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WSUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WSUserGroupByOutputType[P]>
            : GetScalarType<T[P], WSUserGroupByOutputType[P]>
        }
      >
    >


  export type WSUserSelect = {
    id?: boolean
    name?: boolean
    tel?: boolean
    myWallet?: boolean
    createdAt?: boolean
    updateAt?: boolean
    topupHistories?: boolean | WSUser$topupHistoriesArgs
    usingHistories?: boolean | WSUser$usingHistoriesArgs
    _count?: boolean | WSUserCountOutputTypeArgs
  }


  export type WSUserInclude = {
    topupHistories?: boolean | WSUser$topupHistoriesArgs
    usingHistories?: boolean | WSUser$usingHistoriesArgs
    _count?: boolean | WSUserCountOutputTypeArgs
  }

  export type WSUserGetPayload<S extends boolean | null | undefined | WSUserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? WSUser :
    S extends undefined ? never :
    S extends { include: any } & (WSUserArgs | WSUserFindManyArgs)
    ? WSUser  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'topupHistories' ? Array < WSTopupHistoryGetPayload<S['include'][P]>>  :
        P extends 'usingHistories' ? Array < WSUsingHistoryGetPayload<S['include'][P]>>  :
        P extends '_count' ? WSUserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (WSUserArgs | WSUserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'topupHistories' ? Array < WSTopupHistoryGetPayload<S['select'][P]>>  :
        P extends 'usingHistories' ? Array < WSUsingHistoryGetPayload<S['select'][P]>>  :
        P extends '_count' ? WSUserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof WSUser ? WSUser[P] : never
  } 
      : WSUser


  type WSUserCountArgs = 
    Omit<WSUserFindManyArgs, 'select' | 'include'> & {
      select?: WSUserCountAggregateInputType | true
    }

  export interface WSUserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one WSUser that matches the filter.
     * @param {WSUserFindUniqueArgs} args - Arguments to find a WSUser
     * @example
     * // Get one WSUser
     * const wSUser = await prisma.wSUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WSUserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WSUserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'WSUser'> extends True ? Prisma__WSUserClient<WSUserGetPayload<T>> : Prisma__WSUserClient<WSUserGetPayload<T> | null, null>

    /**
     * Find one WSUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WSUserFindUniqueOrThrowArgs} args - Arguments to find a WSUser
     * @example
     * // Get one WSUser
     * const wSUser = await prisma.wSUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WSUserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, WSUserFindUniqueOrThrowArgs>
    ): Prisma__WSUserClient<WSUserGetPayload<T>>

    /**
     * Find the first WSUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSUserFindFirstArgs} args - Arguments to find a WSUser
     * @example
     * // Get one WSUser
     * const wSUser = await prisma.wSUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WSUserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WSUserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'WSUser'> extends True ? Prisma__WSUserClient<WSUserGetPayload<T>> : Prisma__WSUserClient<WSUserGetPayload<T> | null, null>

    /**
     * Find the first WSUser that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSUserFindFirstOrThrowArgs} args - Arguments to find a WSUser
     * @example
     * // Get one WSUser
     * const wSUser = await prisma.wSUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WSUserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, WSUserFindFirstOrThrowArgs>
    ): Prisma__WSUserClient<WSUserGetPayload<T>>

    /**
     * Find zero or more WSUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WSUsers
     * const wSUsers = await prisma.wSUser.findMany()
     * 
     * // Get first 10 WSUsers
     * const wSUsers = await prisma.wSUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wSUserWithIdOnly = await prisma.wSUser.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WSUserFindManyArgs>(
      args?: SelectSubset<T, WSUserFindManyArgs>
    ): Prisma.PrismaPromise<Array<WSUserGetPayload<T>>>

    /**
     * Create a WSUser.
     * @param {WSUserCreateArgs} args - Arguments to create a WSUser.
     * @example
     * // Create one WSUser
     * const WSUser = await prisma.wSUser.create({
     *   data: {
     *     // ... data to create a WSUser
     *   }
     * })
     * 
    **/
    create<T extends WSUserCreateArgs>(
      args: SelectSubset<T, WSUserCreateArgs>
    ): Prisma__WSUserClient<WSUserGetPayload<T>>

    /**
     * Create many WSUsers.
     *     @param {WSUserCreateManyArgs} args - Arguments to create many WSUsers.
     *     @example
     *     // Create many WSUsers
     *     const wSUser = await prisma.wSUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WSUserCreateManyArgs>(
      args?: SelectSubset<T, WSUserCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WSUser.
     * @param {WSUserDeleteArgs} args - Arguments to delete one WSUser.
     * @example
     * // Delete one WSUser
     * const WSUser = await prisma.wSUser.delete({
     *   where: {
     *     // ... filter to delete one WSUser
     *   }
     * })
     * 
    **/
    delete<T extends WSUserDeleteArgs>(
      args: SelectSubset<T, WSUserDeleteArgs>
    ): Prisma__WSUserClient<WSUserGetPayload<T>>

    /**
     * Update one WSUser.
     * @param {WSUserUpdateArgs} args - Arguments to update one WSUser.
     * @example
     * // Update one WSUser
     * const wSUser = await prisma.wSUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WSUserUpdateArgs>(
      args: SelectSubset<T, WSUserUpdateArgs>
    ): Prisma__WSUserClient<WSUserGetPayload<T>>

    /**
     * Delete zero or more WSUsers.
     * @param {WSUserDeleteManyArgs} args - Arguments to filter WSUsers to delete.
     * @example
     * // Delete a few WSUsers
     * const { count } = await prisma.wSUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WSUserDeleteManyArgs>(
      args?: SelectSubset<T, WSUserDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WSUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WSUsers
     * const wSUser = await prisma.wSUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WSUserUpdateManyArgs>(
      args: SelectSubset<T, WSUserUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WSUser.
     * @param {WSUserUpsertArgs} args - Arguments to update or create a WSUser.
     * @example
     * // Update or create a WSUser
     * const wSUser = await prisma.wSUser.upsert({
     *   create: {
     *     // ... data to create a WSUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WSUser we want to update
     *   }
     * })
    **/
    upsert<T extends WSUserUpsertArgs>(
      args: SelectSubset<T, WSUserUpsertArgs>
    ): Prisma__WSUserClient<WSUserGetPayload<T>>

    /**
     * Count the number of WSUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSUserCountArgs} args - Arguments to filter WSUsers to count.
     * @example
     * // Count the number of WSUsers
     * const count = await prisma.wSUser.count({
     *   where: {
     *     // ... the filter for the WSUsers we want to count
     *   }
     * })
    **/
    count<T extends WSUserCountArgs>(
      args?: Subset<T, WSUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WSUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WSUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WSUserAggregateArgs>(args: Subset<T, WSUserAggregateArgs>): Prisma.PrismaPromise<GetWSUserAggregateType<T>>

    /**
     * Group by WSUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WSUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WSUserGroupByArgs['orderBy'] }
        : { orderBy?: WSUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WSUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWSUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for WSUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WSUserClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    topupHistories<T extends WSUser$topupHistoriesArgs= {}>(args?: Subset<T, WSUser$topupHistoriesArgs>): Prisma.PrismaPromise<Array<WSTopupHistoryGetPayload<T>>| Null>;

    usingHistories<T extends WSUser$usingHistoriesArgs= {}>(args?: Subset<T, WSUser$usingHistoriesArgs>): Prisma.PrismaPromise<Array<WSUsingHistoryGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * WSUser base type for findUnique actions
   */
  export type WSUserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the WSUser
     */
    select?: WSUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSUserInclude | null
    /**
     * Filter, which WSUser to fetch.
     */
    where: WSUserWhereUniqueInput
  }

  /**
   * WSUser findUnique
   */
  export interface WSUserFindUniqueArgs extends WSUserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WSUser findUniqueOrThrow
   */
  export type WSUserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the WSUser
     */
    select?: WSUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSUserInclude | null
    /**
     * Filter, which WSUser to fetch.
     */
    where: WSUserWhereUniqueInput
  }


  /**
   * WSUser base type for findFirst actions
   */
  export type WSUserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the WSUser
     */
    select?: WSUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSUserInclude | null
    /**
     * Filter, which WSUser to fetch.
     */
    where?: WSUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSUsers to fetch.
     */
    orderBy?: Enumerable<WSUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WSUsers.
     */
    cursor?: WSUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WSUsers.
     */
    distinct?: Enumerable<WSUserScalarFieldEnum>
  }

  /**
   * WSUser findFirst
   */
  export interface WSUserFindFirstArgs extends WSUserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WSUser findFirstOrThrow
   */
  export type WSUserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the WSUser
     */
    select?: WSUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSUserInclude | null
    /**
     * Filter, which WSUser to fetch.
     */
    where?: WSUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSUsers to fetch.
     */
    orderBy?: Enumerable<WSUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WSUsers.
     */
    cursor?: WSUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WSUsers.
     */
    distinct?: Enumerable<WSUserScalarFieldEnum>
  }


  /**
   * WSUser findMany
   */
  export type WSUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the WSUser
     */
    select?: WSUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSUserInclude | null
    /**
     * Filter, which WSUsers to fetch.
     */
    where?: WSUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSUsers to fetch.
     */
    orderBy?: Enumerable<WSUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WSUsers.
     */
    cursor?: WSUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSUsers.
     */
    skip?: number
    distinct?: Enumerable<WSUserScalarFieldEnum>
  }


  /**
   * WSUser create
   */
  export type WSUserCreateArgs = {
    /**
     * Select specific fields to fetch from the WSUser
     */
    select?: WSUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSUserInclude | null
    /**
     * The data needed to create a WSUser.
     */
    data: XOR<WSUserCreateInput, WSUserUncheckedCreateInput>
  }


  /**
   * WSUser createMany
   */
  export type WSUserCreateManyArgs = {
    /**
     * The data used to create many WSUsers.
     */
    data: Enumerable<WSUserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * WSUser update
   */
  export type WSUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the WSUser
     */
    select?: WSUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSUserInclude | null
    /**
     * The data needed to update a WSUser.
     */
    data: XOR<WSUserUpdateInput, WSUserUncheckedUpdateInput>
    /**
     * Choose, which WSUser to update.
     */
    where: WSUserWhereUniqueInput
  }


  /**
   * WSUser updateMany
   */
  export type WSUserUpdateManyArgs = {
    /**
     * The data used to update WSUsers.
     */
    data: XOR<WSUserUpdateManyMutationInput, WSUserUncheckedUpdateManyInput>
    /**
     * Filter which WSUsers to update
     */
    where?: WSUserWhereInput
  }


  /**
   * WSUser upsert
   */
  export type WSUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the WSUser
     */
    select?: WSUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSUserInclude | null
    /**
     * The filter to search for the WSUser to update in case it exists.
     */
    where: WSUserWhereUniqueInput
    /**
     * In case the WSUser found by the `where` argument doesn't exist, create a new WSUser with this data.
     */
    create: XOR<WSUserCreateInput, WSUserUncheckedCreateInput>
    /**
     * In case the WSUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WSUserUpdateInput, WSUserUncheckedUpdateInput>
  }


  /**
   * WSUser delete
   */
  export type WSUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the WSUser
     */
    select?: WSUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSUserInclude | null
    /**
     * Filter which WSUser to delete.
     */
    where: WSUserWhereUniqueInput
  }


  /**
   * WSUser deleteMany
   */
  export type WSUserDeleteManyArgs = {
    /**
     * Filter which WSUsers to delete
     */
    where?: WSUserWhereInput
  }


  /**
   * WSUser.topupHistories
   */
  export type WSUser$topupHistoriesArgs = {
    /**
     * Select specific fields to fetch from the WSTopupHistory
     */
    select?: WSTopupHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSTopupHistoryInclude | null
    where?: WSTopupHistoryWhereInput
    orderBy?: Enumerable<WSTopupHistoryOrderByWithRelationInput>
    cursor?: WSTopupHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WSTopupHistoryScalarFieldEnum>
  }


  /**
   * WSUser.usingHistories
   */
  export type WSUser$usingHistoriesArgs = {
    /**
     * Select specific fields to fetch from the WSUsingHistory
     */
    select?: WSUsingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSUsingHistoryInclude | null
    where?: WSUsingHistoryWhereInput
    orderBy?: Enumerable<WSUsingHistoryOrderByWithRelationInput>
    cursor?: WSUsingHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WSUsingHistoryScalarFieldEnum>
  }


  /**
   * WSUser without action
   */
  export type WSUserArgs = {
    /**
     * Select specific fields to fetch from the WSUser
     */
    select?: WSUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSUserInclude | null
  }



  /**
   * Model WSTopupHistory
   */


  export type AggregateWSTopupHistory = {
    _count: WSTopupHistoryCountAggregateOutputType | null
    _avg: WSTopupHistoryAvgAggregateOutputType | null
    _sum: WSTopupHistorySumAggregateOutputType | null
    _min: WSTopupHistoryMinAggregateOutputType | null
    _max: WSTopupHistoryMaxAggregateOutputType | null
  }

  export type WSTopupHistoryAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    topup: number | null
  }

  export type WSTopupHistorySumAggregateOutputType = {
    id: number | null
    userId: number | null
    topup: number | null
  }

  export type WSTopupHistoryMinAggregateOutputType = {
    id: number | null
    userId: number | null
    topup: number | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type WSTopupHistoryMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    topup: number | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type WSTopupHistoryCountAggregateOutputType = {
    id: number
    userId: number
    topup: number
    createdAt: number
    updateAt: number
    _all: number
  }


  export type WSTopupHistoryAvgAggregateInputType = {
    id?: true
    userId?: true
    topup?: true
  }

  export type WSTopupHistorySumAggregateInputType = {
    id?: true
    userId?: true
    topup?: true
  }

  export type WSTopupHistoryMinAggregateInputType = {
    id?: true
    userId?: true
    topup?: true
    createdAt?: true
    updateAt?: true
  }

  export type WSTopupHistoryMaxAggregateInputType = {
    id?: true
    userId?: true
    topup?: true
    createdAt?: true
    updateAt?: true
  }

  export type WSTopupHistoryCountAggregateInputType = {
    id?: true
    userId?: true
    topup?: true
    createdAt?: true
    updateAt?: true
    _all?: true
  }

  export type WSTopupHistoryAggregateArgs = {
    /**
     * Filter which WSTopupHistory to aggregate.
     */
    where?: WSTopupHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSTopupHistories to fetch.
     */
    orderBy?: Enumerable<WSTopupHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WSTopupHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSTopupHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSTopupHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WSTopupHistories
    **/
    _count?: true | WSTopupHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WSTopupHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WSTopupHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WSTopupHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WSTopupHistoryMaxAggregateInputType
  }

  export type GetWSTopupHistoryAggregateType<T extends WSTopupHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateWSTopupHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWSTopupHistory[P]>
      : GetScalarType<T[P], AggregateWSTopupHistory[P]>
  }




  export type WSTopupHistoryGroupByArgs = {
    where?: WSTopupHistoryWhereInput
    orderBy?: Enumerable<WSTopupHistoryOrderByWithAggregationInput>
    by: WSTopupHistoryScalarFieldEnum[]
    having?: WSTopupHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WSTopupHistoryCountAggregateInputType | true
    _avg?: WSTopupHistoryAvgAggregateInputType
    _sum?: WSTopupHistorySumAggregateInputType
    _min?: WSTopupHistoryMinAggregateInputType
    _max?: WSTopupHistoryMaxAggregateInputType
  }


  export type WSTopupHistoryGroupByOutputType = {
    id: number
    userId: number
    topup: number
    createdAt: Date
    updateAt: Date
    _count: WSTopupHistoryCountAggregateOutputType | null
    _avg: WSTopupHistoryAvgAggregateOutputType | null
    _sum: WSTopupHistorySumAggregateOutputType | null
    _min: WSTopupHistoryMinAggregateOutputType | null
    _max: WSTopupHistoryMaxAggregateOutputType | null
  }

  type GetWSTopupHistoryGroupByPayload<T extends WSTopupHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<WSTopupHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WSTopupHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WSTopupHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], WSTopupHistoryGroupByOutputType[P]>
        }
      >
    >


  export type WSTopupHistorySelect = {
    id?: boolean
    user?: boolean | WSUserArgs
    userId?: boolean
    topup?: boolean
    createdAt?: boolean
    updateAt?: boolean
  }


  export type WSTopupHistoryInclude = {
    user?: boolean | WSUserArgs
  }

  export type WSTopupHistoryGetPayload<S extends boolean | null | undefined | WSTopupHistoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? WSTopupHistory :
    S extends undefined ? never :
    S extends { include: any } & (WSTopupHistoryArgs | WSTopupHistoryFindManyArgs)
    ? WSTopupHistory  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? WSUserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (WSTopupHistoryArgs | WSTopupHistoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? WSUserGetPayload<S['select'][P]> :  P extends keyof WSTopupHistory ? WSTopupHistory[P] : never
  } 
      : WSTopupHistory


  type WSTopupHistoryCountArgs = 
    Omit<WSTopupHistoryFindManyArgs, 'select' | 'include'> & {
      select?: WSTopupHistoryCountAggregateInputType | true
    }

  export interface WSTopupHistoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one WSTopupHistory that matches the filter.
     * @param {WSTopupHistoryFindUniqueArgs} args - Arguments to find a WSTopupHistory
     * @example
     * // Get one WSTopupHistory
     * const wSTopupHistory = await prisma.wSTopupHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WSTopupHistoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WSTopupHistoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'WSTopupHistory'> extends True ? Prisma__WSTopupHistoryClient<WSTopupHistoryGetPayload<T>> : Prisma__WSTopupHistoryClient<WSTopupHistoryGetPayload<T> | null, null>

    /**
     * Find one WSTopupHistory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WSTopupHistoryFindUniqueOrThrowArgs} args - Arguments to find a WSTopupHistory
     * @example
     * // Get one WSTopupHistory
     * const wSTopupHistory = await prisma.wSTopupHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WSTopupHistoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, WSTopupHistoryFindUniqueOrThrowArgs>
    ): Prisma__WSTopupHistoryClient<WSTopupHistoryGetPayload<T>>

    /**
     * Find the first WSTopupHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSTopupHistoryFindFirstArgs} args - Arguments to find a WSTopupHistory
     * @example
     * // Get one WSTopupHistory
     * const wSTopupHistory = await prisma.wSTopupHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WSTopupHistoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WSTopupHistoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'WSTopupHistory'> extends True ? Prisma__WSTopupHistoryClient<WSTopupHistoryGetPayload<T>> : Prisma__WSTopupHistoryClient<WSTopupHistoryGetPayload<T> | null, null>

    /**
     * Find the first WSTopupHistory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSTopupHistoryFindFirstOrThrowArgs} args - Arguments to find a WSTopupHistory
     * @example
     * // Get one WSTopupHistory
     * const wSTopupHistory = await prisma.wSTopupHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WSTopupHistoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, WSTopupHistoryFindFirstOrThrowArgs>
    ): Prisma__WSTopupHistoryClient<WSTopupHistoryGetPayload<T>>

    /**
     * Find zero or more WSTopupHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSTopupHistoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WSTopupHistories
     * const wSTopupHistories = await prisma.wSTopupHistory.findMany()
     * 
     * // Get first 10 WSTopupHistories
     * const wSTopupHistories = await prisma.wSTopupHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wSTopupHistoryWithIdOnly = await prisma.wSTopupHistory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WSTopupHistoryFindManyArgs>(
      args?: SelectSubset<T, WSTopupHistoryFindManyArgs>
    ): Prisma.PrismaPromise<Array<WSTopupHistoryGetPayload<T>>>

    /**
     * Create a WSTopupHistory.
     * @param {WSTopupHistoryCreateArgs} args - Arguments to create a WSTopupHistory.
     * @example
     * // Create one WSTopupHistory
     * const WSTopupHistory = await prisma.wSTopupHistory.create({
     *   data: {
     *     // ... data to create a WSTopupHistory
     *   }
     * })
     * 
    **/
    create<T extends WSTopupHistoryCreateArgs>(
      args: SelectSubset<T, WSTopupHistoryCreateArgs>
    ): Prisma__WSTopupHistoryClient<WSTopupHistoryGetPayload<T>>

    /**
     * Create many WSTopupHistories.
     *     @param {WSTopupHistoryCreateManyArgs} args - Arguments to create many WSTopupHistories.
     *     @example
     *     // Create many WSTopupHistories
     *     const wSTopupHistory = await prisma.wSTopupHistory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WSTopupHistoryCreateManyArgs>(
      args?: SelectSubset<T, WSTopupHistoryCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WSTopupHistory.
     * @param {WSTopupHistoryDeleteArgs} args - Arguments to delete one WSTopupHistory.
     * @example
     * // Delete one WSTopupHistory
     * const WSTopupHistory = await prisma.wSTopupHistory.delete({
     *   where: {
     *     // ... filter to delete one WSTopupHistory
     *   }
     * })
     * 
    **/
    delete<T extends WSTopupHistoryDeleteArgs>(
      args: SelectSubset<T, WSTopupHistoryDeleteArgs>
    ): Prisma__WSTopupHistoryClient<WSTopupHistoryGetPayload<T>>

    /**
     * Update one WSTopupHistory.
     * @param {WSTopupHistoryUpdateArgs} args - Arguments to update one WSTopupHistory.
     * @example
     * // Update one WSTopupHistory
     * const wSTopupHistory = await prisma.wSTopupHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WSTopupHistoryUpdateArgs>(
      args: SelectSubset<T, WSTopupHistoryUpdateArgs>
    ): Prisma__WSTopupHistoryClient<WSTopupHistoryGetPayload<T>>

    /**
     * Delete zero or more WSTopupHistories.
     * @param {WSTopupHistoryDeleteManyArgs} args - Arguments to filter WSTopupHistories to delete.
     * @example
     * // Delete a few WSTopupHistories
     * const { count } = await prisma.wSTopupHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WSTopupHistoryDeleteManyArgs>(
      args?: SelectSubset<T, WSTopupHistoryDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WSTopupHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSTopupHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WSTopupHistories
     * const wSTopupHistory = await prisma.wSTopupHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WSTopupHistoryUpdateManyArgs>(
      args: SelectSubset<T, WSTopupHistoryUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WSTopupHistory.
     * @param {WSTopupHistoryUpsertArgs} args - Arguments to update or create a WSTopupHistory.
     * @example
     * // Update or create a WSTopupHistory
     * const wSTopupHistory = await prisma.wSTopupHistory.upsert({
     *   create: {
     *     // ... data to create a WSTopupHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WSTopupHistory we want to update
     *   }
     * })
    **/
    upsert<T extends WSTopupHistoryUpsertArgs>(
      args: SelectSubset<T, WSTopupHistoryUpsertArgs>
    ): Prisma__WSTopupHistoryClient<WSTopupHistoryGetPayload<T>>

    /**
     * Count the number of WSTopupHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSTopupHistoryCountArgs} args - Arguments to filter WSTopupHistories to count.
     * @example
     * // Count the number of WSTopupHistories
     * const count = await prisma.wSTopupHistory.count({
     *   where: {
     *     // ... the filter for the WSTopupHistories we want to count
     *   }
     * })
    **/
    count<T extends WSTopupHistoryCountArgs>(
      args?: Subset<T, WSTopupHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WSTopupHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WSTopupHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSTopupHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WSTopupHistoryAggregateArgs>(args: Subset<T, WSTopupHistoryAggregateArgs>): Prisma.PrismaPromise<GetWSTopupHistoryAggregateType<T>>

    /**
     * Group by WSTopupHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSTopupHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WSTopupHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WSTopupHistoryGroupByArgs['orderBy'] }
        : { orderBy?: WSTopupHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WSTopupHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWSTopupHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for WSTopupHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WSTopupHistoryClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends WSUserArgs= {}>(args?: Subset<T, WSUserArgs>): Prisma__WSUserClient<WSUserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * WSTopupHistory base type for findUnique actions
   */
  export type WSTopupHistoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the WSTopupHistory
     */
    select?: WSTopupHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSTopupHistoryInclude | null
    /**
     * Filter, which WSTopupHistory to fetch.
     */
    where: WSTopupHistoryWhereUniqueInput
  }

  /**
   * WSTopupHistory findUnique
   */
  export interface WSTopupHistoryFindUniqueArgs extends WSTopupHistoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WSTopupHistory findUniqueOrThrow
   */
  export type WSTopupHistoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the WSTopupHistory
     */
    select?: WSTopupHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSTopupHistoryInclude | null
    /**
     * Filter, which WSTopupHistory to fetch.
     */
    where: WSTopupHistoryWhereUniqueInput
  }


  /**
   * WSTopupHistory base type for findFirst actions
   */
  export type WSTopupHistoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the WSTopupHistory
     */
    select?: WSTopupHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSTopupHistoryInclude | null
    /**
     * Filter, which WSTopupHistory to fetch.
     */
    where?: WSTopupHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSTopupHistories to fetch.
     */
    orderBy?: Enumerable<WSTopupHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WSTopupHistories.
     */
    cursor?: WSTopupHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSTopupHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSTopupHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WSTopupHistories.
     */
    distinct?: Enumerable<WSTopupHistoryScalarFieldEnum>
  }

  /**
   * WSTopupHistory findFirst
   */
  export interface WSTopupHistoryFindFirstArgs extends WSTopupHistoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WSTopupHistory findFirstOrThrow
   */
  export type WSTopupHistoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the WSTopupHistory
     */
    select?: WSTopupHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSTopupHistoryInclude | null
    /**
     * Filter, which WSTopupHistory to fetch.
     */
    where?: WSTopupHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSTopupHistories to fetch.
     */
    orderBy?: Enumerable<WSTopupHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WSTopupHistories.
     */
    cursor?: WSTopupHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSTopupHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSTopupHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WSTopupHistories.
     */
    distinct?: Enumerable<WSTopupHistoryScalarFieldEnum>
  }


  /**
   * WSTopupHistory findMany
   */
  export type WSTopupHistoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the WSTopupHistory
     */
    select?: WSTopupHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSTopupHistoryInclude | null
    /**
     * Filter, which WSTopupHistories to fetch.
     */
    where?: WSTopupHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSTopupHistories to fetch.
     */
    orderBy?: Enumerable<WSTopupHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WSTopupHistories.
     */
    cursor?: WSTopupHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSTopupHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSTopupHistories.
     */
    skip?: number
    distinct?: Enumerable<WSTopupHistoryScalarFieldEnum>
  }


  /**
   * WSTopupHistory create
   */
  export type WSTopupHistoryCreateArgs = {
    /**
     * Select specific fields to fetch from the WSTopupHistory
     */
    select?: WSTopupHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSTopupHistoryInclude | null
    /**
     * The data needed to create a WSTopupHistory.
     */
    data: XOR<WSTopupHistoryCreateInput, WSTopupHistoryUncheckedCreateInput>
  }


  /**
   * WSTopupHistory createMany
   */
  export type WSTopupHistoryCreateManyArgs = {
    /**
     * The data used to create many WSTopupHistories.
     */
    data: Enumerable<WSTopupHistoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * WSTopupHistory update
   */
  export type WSTopupHistoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the WSTopupHistory
     */
    select?: WSTopupHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSTopupHistoryInclude | null
    /**
     * The data needed to update a WSTopupHistory.
     */
    data: XOR<WSTopupHistoryUpdateInput, WSTopupHistoryUncheckedUpdateInput>
    /**
     * Choose, which WSTopupHistory to update.
     */
    where: WSTopupHistoryWhereUniqueInput
  }


  /**
   * WSTopupHistory updateMany
   */
  export type WSTopupHistoryUpdateManyArgs = {
    /**
     * The data used to update WSTopupHistories.
     */
    data: XOR<WSTopupHistoryUpdateManyMutationInput, WSTopupHistoryUncheckedUpdateManyInput>
    /**
     * Filter which WSTopupHistories to update
     */
    where?: WSTopupHistoryWhereInput
  }


  /**
   * WSTopupHistory upsert
   */
  export type WSTopupHistoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the WSTopupHistory
     */
    select?: WSTopupHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSTopupHistoryInclude | null
    /**
     * The filter to search for the WSTopupHistory to update in case it exists.
     */
    where: WSTopupHistoryWhereUniqueInput
    /**
     * In case the WSTopupHistory found by the `where` argument doesn't exist, create a new WSTopupHistory with this data.
     */
    create: XOR<WSTopupHistoryCreateInput, WSTopupHistoryUncheckedCreateInput>
    /**
     * In case the WSTopupHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WSTopupHistoryUpdateInput, WSTopupHistoryUncheckedUpdateInput>
  }


  /**
   * WSTopupHistory delete
   */
  export type WSTopupHistoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the WSTopupHistory
     */
    select?: WSTopupHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSTopupHistoryInclude | null
    /**
     * Filter which WSTopupHistory to delete.
     */
    where: WSTopupHistoryWhereUniqueInput
  }


  /**
   * WSTopupHistory deleteMany
   */
  export type WSTopupHistoryDeleteManyArgs = {
    /**
     * Filter which WSTopupHistories to delete
     */
    where?: WSTopupHistoryWhereInput
  }


  /**
   * WSTopupHistory without action
   */
  export type WSTopupHistoryArgs = {
    /**
     * Select specific fields to fetch from the WSTopupHistory
     */
    select?: WSTopupHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSTopupHistoryInclude | null
  }



  /**
   * Model WSUsingHistory
   */


  export type AggregateWSUsingHistory = {
    _count: WSUsingHistoryCountAggregateOutputType | null
    _avg: WSUsingHistoryAvgAggregateOutputType | null
    _sum: WSUsingHistorySumAggregateOutputType | null
    _min: WSUsingHistoryMinAggregateOutputType | null
    _max: WSUsingHistoryMaxAggregateOutputType | null
  }

  export type WSUsingHistoryAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    price: number | null
    wSMachineId: number | null
    wSProgramId: number | null
  }

  export type WSUsingHistorySumAggregateOutputType = {
    id: number | null
    userId: number | null
    price: number | null
    wSMachineId: number | null
    wSProgramId: number | null
  }

  export type WSUsingHistoryMinAggregateOutputType = {
    id: number | null
    userId: number | null
    price: number | null
    createdAt: Date | null
    updateAt: Date | null
    usingStartAt: Date | null
    finishingAt: Date | null
    wSMachineId: number | null
    wSProgramId: number | null
  }

  export type WSUsingHistoryMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    price: number | null
    createdAt: Date | null
    updateAt: Date | null
    usingStartAt: Date | null
    finishingAt: Date | null
    wSMachineId: number | null
    wSProgramId: number | null
  }

  export type WSUsingHistoryCountAggregateOutputType = {
    id: number
    userId: number
    price: number
    createdAt: number
    updateAt: number
    usingStartAt: number
    finishingAt: number
    wSMachineId: number
    wSProgramId: number
    _all: number
  }


  export type WSUsingHistoryAvgAggregateInputType = {
    id?: true
    userId?: true
    price?: true
    wSMachineId?: true
    wSProgramId?: true
  }

  export type WSUsingHistorySumAggregateInputType = {
    id?: true
    userId?: true
    price?: true
    wSMachineId?: true
    wSProgramId?: true
  }

  export type WSUsingHistoryMinAggregateInputType = {
    id?: true
    userId?: true
    price?: true
    createdAt?: true
    updateAt?: true
    usingStartAt?: true
    finishingAt?: true
    wSMachineId?: true
    wSProgramId?: true
  }

  export type WSUsingHistoryMaxAggregateInputType = {
    id?: true
    userId?: true
    price?: true
    createdAt?: true
    updateAt?: true
    usingStartAt?: true
    finishingAt?: true
    wSMachineId?: true
    wSProgramId?: true
  }

  export type WSUsingHistoryCountAggregateInputType = {
    id?: true
    userId?: true
    price?: true
    createdAt?: true
    updateAt?: true
    usingStartAt?: true
    finishingAt?: true
    wSMachineId?: true
    wSProgramId?: true
    _all?: true
  }

  export type WSUsingHistoryAggregateArgs = {
    /**
     * Filter which WSUsingHistory to aggregate.
     */
    where?: WSUsingHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSUsingHistories to fetch.
     */
    orderBy?: Enumerable<WSUsingHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WSUsingHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSUsingHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSUsingHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WSUsingHistories
    **/
    _count?: true | WSUsingHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WSUsingHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WSUsingHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WSUsingHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WSUsingHistoryMaxAggregateInputType
  }

  export type GetWSUsingHistoryAggregateType<T extends WSUsingHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateWSUsingHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWSUsingHistory[P]>
      : GetScalarType<T[P], AggregateWSUsingHistory[P]>
  }




  export type WSUsingHistoryGroupByArgs = {
    where?: WSUsingHistoryWhereInput
    orderBy?: Enumerable<WSUsingHistoryOrderByWithAggregationInput>
    by: WSUsingHistoryScalarFieldEnum[]
    having?: WSUsingHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WSUsingHistoryCountAggregateInputType | true
    _avg?: WSUsingHistoryAvgAggregateInputType
    _sum?: WSUsingHistorySumAggregateInputType
    _min?: WSUsingHistoryMinAggregateInputType
    _max?: WSUsingHistoryMaxAggregateInputType
  }


  export type WSUsingHistoryGroupByOutputType = {
    id: number
    userId: number
    price: number
    createdAt: Date
    updateAt: Date
    usingStartAt: Date
    finishingAt: Date
    wSMachineId: number
    wSProgramId: number
    _count: WSUsingHistoryCountAggregateOutputType | null
    _avg: WSUsingHistoryAvgAggregateOutputType | null
    _sum: WSUsingHistorySumAggregateOutputType | null
    _min: WSUsingHistoryMinAggregateOutputType | null
    _max: WSUsingHistoryMaxAggregateOutputType | null
  }

  type GetWSUsingHistoryGroupByPayload<T extends WSUsingHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<WSUsingHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WSUsingHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WSUsingHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], WSUsingHistoryGroupByOutputType[P]>
        }
      >
    >


  export type WSUsingHistorySelect = {
    id?: boolean
    user?: boolean | WSUserArgs
    userId?: boolean
    price?: boolean
    createdAt?: boolean
    updateAt?: boolean
    machine?: boolean | WSMachineArgs
    program?: boolean | WSProgramArgs
    usingStartAt?: boolean
    finishingAt?: boolean
    wSMachineId?: boolean
    wSProgramId?: boolean
  }


  export type WSUsingHistoryInclude = {
    user?: boolean | WSUserArgs
    machine?: boolean | WSMachineArgs
    program?: boolean | WSProgramArgs
  }

  export type WSUsingHistoryGetPayload<S extends boolean | null | undefined | WSUsingHistoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? WSUsingHistory :
    S extends undefined ? never :
    S extends { include: any } & (WSUsingHistoryArgs | WSUsingHistoryFindManyArgs)
    ? WSUsingHistory  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? WSUserGetPayload<S['include'][P]> :
        P extends 'machine' ? WSMachineGetPayload<S['include'][P]> :
        P extends 'program' ? WSProgramGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (WSUsingHistoryArgs | WSUsingHistoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? WSUserGetPayload<S['select'][P]> :
        P extends 'machine' ? WSMachineGetPayload<S['select'][P]> :
        P extends 'program' ? WSProgramGetPayload<S['select'][P]> :  P extends keyof WSUsingHistory ? WSUsingHistory[P] : never
  } 
      : WSUsingHistory


  type WSUsingHistoryCountArgs = 
    Omit<WSUsingHistoryFindManyArgs, 'select' | 'include'> & {
      select?: WSUsingHistoryCountAggregateInputType | true
    }

  export interface WSUsingHistoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one WSUsingHistory that matches the filter.
     * @param {WSUsingHistoryFindUniqueArgs} args - Arguments to find a WSUsingHistory
     * @example
     * // Get one WSUsingHistory
     * const wSUsingHistory = await prisma.wSUsingHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WSUsingHistoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WSUsingHistoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'WSUsingHistory'> extends True ? Prisma__WSUsingHistoryClient<WSUsingHistoryGetPayload<T>> : Prisma__WSUsingHistoryClient<WSUsingHistoryGetPayload<T> | null, null>

    /**
     * Find one WSUsingHistory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WSUsingHistoryFindUniqueOrThrowArgs} args - Arguments to find a WSUsingHistory
     * @example
     * // Get one WSUsingHistory
     * const wSUsingHistory = await prisma.wSUsingHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WSUsingHistoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, WSUsingHistoryFindUniqueOrThrowArgs>
    ): Prisma__WSUsingHistoryClient<WSUsingHistoryGetPayload<T>>

    /**
     * Find the first WSUsingHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSUsingHistoryFindFirstArgs} args - Arguments to find a WSUsingHistory
     * @example
     * // Get one WSUsingHistory
     * const wSUsingHistory = await prisma.wSUsingHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WSUsingHistoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WSUsingHistoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'WSUsingHistory'> extends True ? Prisma__WSUsingHistoryClient<WSUsingHistoryGetPayload<T>> : Prisma__WSUsingHistoryClient<WSUsingHistoryGetPayload<T> | null, null>

    /**
     * Find the first WSUsingHistory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSUsingHistoryFindFirstOrThrowArgs} args - Arguments to find a WSUsingHistory
     * @example
     * // Get one WSUsingHistory
     * const wSUsingHistory = await prisma.wSUsingHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WSUsingHistoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, WSUsingHistoryFindFirstOrThrowArgs>
    ): Prisma__WSUsingHistoryClient<WSUsingHistoryGetPayload<T>>

    /**
     * Find zero or more WSUsingHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSUsingHistoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WSUsingHistories
     * const wSUsingHistories = await prisma.wSUsingHistory.findMany()
     * 
     * // Get first 10 WSUsingHistories
     * const wSUsingHistories = await prisma.wSUsingHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wSUsingHistoryWithIdOnly = await prisma.wSUsingHistory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WSUsingHistoryFindManyArgs>(
      args?: SelectSubset<T, WSUsingHistoryFindManyArgs>
    ): Prisma.PrismaPromise<Array<WSUsingHistoryGetPayload<T>>>

    /**
     * Create a WSUsingHistory.
     * @param {WSUsingHistoryCreateArgs} args - Arguments to create a WSUsingHistory.
     * @example
     * // Create one WSUsingHistory
     * const WSUsingHistory = await prisma.wSUsingHistory.create({
     *   data: {
     *     // ... data to create a WSUsingHistory
     *   }
     * })
     * 
    **/
    create<T extends WSUsingHistoryCreateArgs>(
      args: SelectSubset<T, WSUsingHistoryCreateArgs>
    ): Prisma__WSUsingHistoryClient<WSUsingHistoryGetPayload<T>>

    /**
     * Create many WSUsingHistories.
     *     @param {WSUsingHistoryCreateManyArgs} args - Arguments to create many WSUsingHistories.
     *     @example
     *     // Create many WSUsingHistories
     *     const wSUsingHistory = await prisma.wSUsingHistory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WSUsingHistoryCreateManyArgs>(
      args?: SelectSubset<T, WSUsingHistoryCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WSUsingHistory.
     * @param {WSUsingHistoryDeleteArgs} args - Arguments to delete one WSUsingHistory.
     * @example
     * // Delete one WSUsingHistory
     * const WSUsingHistory = await prisma.wSUsingHistory.delete({
     *   where: {
     *     // ... filter to delete one WSUsingHistory
     *   }
     * })
     * 
    **/
    delete<T extends WSUsingHistoryDeleteArgs>(
      args: SelectSubset<T, WSUsingHistoryDeleteArgs>
    ): Prisma__WSUsingHistoryClient<WSUsingHistoryGetPayload<T>>

    /**
     * Update one WSUsingHistory.
     * @param {WSUsingHistoryUpdateArgs} args - Arguments to update one WSUsingHistory.
     * @example
     * // Update one WSUsingHistory
     * const wSUsingHistory = await prisma.wSUsingHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WSUsingHistoryUpdateArgs>(
      args: SelectSubset<T, WSUsingHistoryUpdateArgs>
    ): Prisma__WSUsingHistoryClient<WSUsingHistoryGetPayload<T>>

    /**
     * Delete zero or more WSUsingHistories.
     * @param {WSUsingHistoryDeleteManyArgs} args - Arguments to filter WSUsingHistories to delete.
     * @example
     * // Delete a few WSUsingHistories
     * const { count } = await prisma.wSUsingHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WSUsingHistoryDeleteManyArgs>(
      args?: SelectSubset<T, WSUsingHistoryDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WSUsingHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSUsingHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WSUsingHistories
     * const wSUsingHistory = await prisma.wSUsingHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WSUsingHistoryUpdateManyArgs>(
      args: SelectSubset<T, WSUsingHistoryUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WSUsingHistory.
     * @param {WSUsingHistoryUpsertArgs} args - Arguments to update or create a WSUsingHistory.
     * @example
     * // Update or create a WSUsingHistory
     * const wSUsingHistory = await prisma.wSUsingHistory.upsert({
     *   create: {
     *     // ... data to create a WSUsingHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WSUsingHistory we want to update
     *   }
     * })
    **/
    upsert<T extends WSUsingHistoryUpsertArgs>(
      args: SelectSubset<T, WSUsingHistoryUpsertArgs>
    ): Prisma__WSUsingHistoryClient<WSUsingHistoryGetPayload<T>>

    /**
     * Count the number of WSUsingHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSUsingHistoryCountArgs} args - Arguments to filter WSUsingHistories to count.
     * @example
     * // Count the number of WSUsingHistories
     * const count = await prisma.wSUsingHistory.count({
     *   where: {
     *     // ... the filter for the WSUsingHistories we want to count
     *   }
     * })
    **/
    count<T extends WSUsingHistoryCountArgs>(
      args?: Subset<T, WSUsingHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WSUsingHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WSUsingHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSUsingHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WSUsingHistoryAggregateArgs>(args: Subset<T, WSUsingHistoryAggregateArgs>): Prisma.PrismaPromise<GetWSUsingHistoryAggregateType<T>>

    /**
     * Group by WSUsingHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSUsingHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WSUsingHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WSUsingHistoryGroupByArgs['orderBy'] }
        : { orderBy?: WSUsingHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WSUsingHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWSUsingHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for WSUsingHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WSUsingHistoryClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends WSUserArgs= {}>(args?: Subset<T, WSUserArgs>): Prisma__WSUserClient<WSUserGetPayload<T> | Null>;

    machine<T extends WSMachineArgs= {}>(args?: Subset<T, WSMachineArgs>): Prisma__WSMachineClient<WSMachineGetPayload<T> | Null>;

    program<T extends WSProgramArgs= {}>(args?: Subset<T, WSProgramArgs>): Prisma__WSProgramClient<WSProgramGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * WSUsingHistory base type for findUnique actions
   */
  export type WSUsingHistoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the WSUsingHistory
     */
    select?: WSUsingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSUsingHistoryInclude | null
    /**
     * Filter, which WSUsingHistory to fetch.
     */
    where: WSUsingHistoryWhereUniqueInput
  }

  /**
   * WSUsingHistory findUnique
   */
  export interface WSUsingHistoryFindUniqueArgs extends WSUsingHistoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WSUsingHistory findUniqueOrThrow
   */
  export type WSUsingHistoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the WSUsingHistory
     */
    select?: WSUsingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSUsingHistoryInclude | null
    /**
     * Filter, which WSUsingHistory to fetch.
     */
    where: WSUsingHistoryWhereUniqueInput
  }


  /**
   * WSUsingHistory base type for findFirst actions
   */
  export type WSUsingHistoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the WSUsingHistory
     */
    select?: WSUsingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSUsingHistoryInclude | null
    /**
     * Filter, which WSUsingHistory to fetch.
     */
    where?: WSUsingHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSUsingHistories to fetch.
     */
    orderBy?: Enumerable<WSUsingHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WSUsingHistories.
     */
    cursor?: WSUsingHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSUsingHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSUsingHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WSUsingHistories.
     */
    distinct?: Enumerable<WSUsingHistoryScalarFieldEnum>
  }

  /**
   * WSUsingHistory findFirst
   */
  export interface WSUsingHistoryFindFirstArgs extends WSUsingHistoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WSUsingHistory findFirstOrThrow
   */
  export type WSUsingHistoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the WSUsingHistory
     */
    select?: WSUsingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSUsingHistoryInclude | null
    /**
     * Filter, which WSUsingHistory to fetch.
     */
    where?: WSUsingHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSUsingHistories to fetch.
     */
    orderBy?: Enumerable<WSUsingHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WSUsingHistories.
     */
    cursor?: WSUsingHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSUsingHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSUsingHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WSUsingHistories.
     */
    distinct?: Enumerable<WSUsingHistoryScalarFieldEnum>
  }


  /**
   * WSUsingHistory findMany
   */
  export type WSUsingHistoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the WSUsingHistory
     */
    select?: WSUsingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSUsingHistoryInclude | null
    /**
     * Filter, which WSUsingHistories to fetch.
     */
    where?: WSUsingHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSUsingHistories to fetch.
     */
    orderBy?: Enumerable<WSUsingHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WSUsingHistories.
     */
    cursor?: WSUsingHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSUsingHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSUsingHistories.
     */
    skip?: number
    distinct?: Enumerable<WSUsingHistoryScalarFieldEnum>
  }


  /**
   * WSUsingHistory create
   */
  export type WSUsingHistoryCreateArgs = {
    /**
     * Select specific fields to fetch from the WSUsingHistory
     */
    select?: WSUsingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSUsingHistoryInclude | null
    /**
     * The data needed to create a WSUsingHistory.
     */
    data: XOR<WSUsingHistoryCreateInput, WSUsingHistoryUncheckedCreateInput>
  }


  /**
   * WSUsingHistory createMany
   */
  export type WSUsingHistoryCreateManyArgs = {
    /**
     * The data used to create many WSUsingHistories.
     */
    data: Enumerable<WSUsingHistoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * WSUsingHistory update
   */
  export type WSUsingHistoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the WSUsingHistory
     */
    select?: WSUsingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSUsingHistoryInclude | null
    /**
     * The data needed to update a WSUsingHistory.
     */
    data: XOR<WSUsingHistoryUpdateInput, WSUsingHistoryUncheckedUpdateInput>
    /**
     * Choose, which WSUsingHistory to update.
     */
    where: WSUsingHistoryWhereUniqueInput
  }


  /**
   * WSUsingHistory updateMany
   */
  export type WSUsingHistoryUpdateManyArgs = {
    /**
     * The data used to update WSUsingHistories.
     */
    data: XOR<WSUsingHistoryUpdateManyMutationInput, WSUsingHistoryUncheckedUpdateManyInput>
    /**
     * Filter which WSUsingHistories to update
     */
    where?: WSUsingHistoryWhereInput
  }


  /**
   * WSUsingHistory upsert
   */
  export type WSUsingHistoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the WSUsingHistory
     */
    select?: WSUsingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSUsingHistoryInclude | null
    /**
     * The filter to search for the WSUsingHistory to update in case it exists.
     */
    where: WSUsingHistoryWhereUniqueInput
    /**
     * In case the WSUsingHistory found by the `where` argument doesn't exist, create a new WSUsingHistory with this data.
     */
    create: XOR<WSUsingHistoryCreateInput, WSUsingHistoryUncheckedCreateInput>
    /**
     * In case the WSUsingHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WSUsingHistoryUpdateInput, WSUsingHistoryUncheckedUpdateInput>
  }


  /**
   * WSUsingHistory delete
   */
  export type WSUsingHistoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the WSUsingHistory
     */
    select?: WSUsingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSUsingHistoryInclude | null
    /**
     * Filter which WSUsingHistory to delete.
     */
    where: WSUsingHistoryWhereUniqueInput
  }


  /**
   * WSUsingHistory deleteMany
   */
  export type WSUsingHistoryDeleteManyArgs = {
    /**
     * Filter which WSUsingHistories to delete
     */
    where?: WSUsingHistoryWhereInput
  }


  /**
   * WSUsingHistory without action
   */
  export type WSUsingHistoryArgs = {
    /**
     * Select specific fields to fetch from the WSUsingHistory
     */
    select?: WSUsingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSUsingHistoryInclude | null
  }



  /**
   * Model WSShop
   */


  export type AggregateWSShop = {
    _count: WSShopCountAggregateOutputType | null
    _avg: WSShopAvgAggregateOutputType | null
    _sum: WSShopSumAggregateOutputType | null
    _min: WSShopMinAggregateOutputType | null
    _max: WSShopMaxAggregateOutputType | null
  }

  export type WSShopAvgAggregateOutputType = {
    id: number | null
    tel: number | null
  }

  export type WSShopSumAggregateOutputType = {
    id: number | null
    tel: number | null
  }

  export type WSShopMinAggregateOutputType = {
    id: number | null
    branch: string | null
    owner: string | null
    tel: number | null
    location: string | null
    area: string | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type WSShopMaxAggregateOutputType = {
    id: number | null
    branch: string | null
    owner: string | null
    tel: number | null
    location: string | null
    area: string | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type WSShopCountAggregateOutputType = {
    id: number
    branch: number
    owner: number
    tel: number
    location: number
    area: number
    createdAt: number
    updateAt: number
    _all: number
  }


  export type WSShopAvgAggregateInputType = {
    id?: true
    tel?: true
  }

  export type WSShopSumAggregateInputType = {
    id?: true
    tel?: true
  }

  export type WSShopMinAggregateInputType = {
    id?: true
    branch?: true
    owner?: true
    tel?: true
    location?: true
    area?: true
    createdAt?: true
    updateAt?: true
  }

  export type WSShopMaxAggregateInputType = {
    id?: true
    branch?: true
    owner?: true
    tel?: true
    location?: true
    area?: true
    createdAt?: true
    updateAt?: true
  }

  export type WSShopCountAggregateInputType = {
    id?: true
    branch?: true
    owner?: true
    tel?: true
    location?: true
    area?: true
    createdAt?: true
    updateAt?: true
    _all?: true
  }

  export type WSShopAggregateArgs = {
    /**
     * Filter which WSShop to aggregate.
     */
    where?: WSShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSShops to fetch.
     */
    orderBy?: Enumerable<WSShopOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WSShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSShops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSShops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WSShops
    **/
    _count?: true | WSShopCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WSShopAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WSShopSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WSShopMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WSShopMaxAggregateInputType
  }

  export type GetWSShopAggregateType<T extends WSShopAggregateArgs> = {
        [P in keyof T & keyof AggregateWSShop]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWSShop[P]>
      : GetScalarType<T[P], AggregateWSShop[P]>
  }




  export type WSShopGroupByArgs = {
    where?: WSShopWhereInput
    orderBy?: Enumerable<WSShopOrderByWithAggregationInput>
    by: WSShopScalarFieldEnum[]
    having?: WSShopScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WSShopCountAggregateInputType | true
    _avg?: WSShopAvgAggregateInputType
    _sum?: WSShopSumAggregateInputType
    _min?: WSShopMinAggregateInputType
    _max?: WSShopMaxAggregateInputType
  }


  export type WSShopGroupByOutputType = {
    id: number
    branch: string
    owner: string
    tel: number
    location: string
    area: string
    createdAt: Date
    updateAt: Date
    _count: WSShopCountAggregateOutputType | null
    _avg: WSShopAvgAggregateOutputType | null
    _sum: WSShopSumAggregateOutputType | null
    _min: WSShopMinAggregateOutputType | null
    _max: WSShopMaxAggregateOutputType | null
  }

  type GetWSShopGroupByPayload<T extends WSShopGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<WSShopGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WSShopGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WSShopGroupByOutputType[P]>
            : GetScalarType<T[P], WSShopGroupByOutputType[P]>
        }
      >
    >


  export type WSShopSelect = {
    id?: boolean
    branch?: boolean
    owner?: boolean
    tel?: boolean
    location?: boolean
    area?: boolean
    machines?: boolean | WSShop$machinesArgs
    createdAt?: boolean
    updateAt?: boolean
    _count?: boolean | WSShopCountOutputTypeArgs
  }


  export type WSShopInclude = {
    machines?: boolean | WSShop$machinesArgs
    _count?: boolean | WSShopCountOutputTypeArgs
  }

  export type WSShopGetPayload<S extends boolean | null | undefined | WSShopArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? WSShop :
    S extends undefined ? never :
    S extends { include: any } & (WSShopArgs | WSShopFindManyArgs)
    ? WSShop  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'machines' ? Array < WSMachineGetPayload<S['include'][P]>>  :
        P extends '_count' ? WSShopCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (WSShopArgs | WSShopFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'machines' ? Array < WSMachineGetPayload<S['select'][P]>>  :
        P extends '_count' ? WSShopCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof WSShop ? WSShop[P] : never
  } 
      : WSShop


  type WSShopCountArgs = 
    Omit<WSShopFindManyArgs, 'select' | 'include'> & {
      select?: WSShopCountAggregateInputType | true
    }

  export interface WSShopDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one WSShop that matches the filter.
     * @param {WSShopFindUniqueArgs} args - Arguments to find a WSShop
     * @example
     * // Get one WSShop
     * const wSShop = await prisma.wSShop.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WSShopFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WSShopFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'WSShop'> extends True ? Prisma__WSShopClient<WSShopGetPayload<T>> : Prisma__WSShopClient<WSShopGetPayload<T> | null, null>

    /**
     * Find one WSShop that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WSShopFindUniqueOrThrowArgs} args - Arguments to find a WSShop
     * @example
     * // Get one WSShop
     * const wSShop = await prisma.wSShop.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WSShopFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, WSShopFindUniqueOrThrowArgs>
    ): Prisma__WSShopClient<WSShopGetPayload<T>>

    /**
     * Find the first WSShop that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSShopFindFirstArgs} args - Arguments to find a WSShop
     * @example
     * // Get one WSShop
     * const wSShop = await prisma.wSShop.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WSShopFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WSShopFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'WSShop'> extends True ? Prisma__WSShopClient<WSShopGetPayload<T>> : Prisma__WSShopClient<WSShopGetPayload<T> | null, null>

    /**
     * Find the first WSShop that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSShopFindFirstOrThrowArgs} args - Arguments to find a WSShop
     * @example
     * // Get one WSShop
     * const wSShop = await prisma.wSShop.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WSShopFindFirstOrThrowArgs>(
      args?: SelectSubset<T, WSShopFindFirstOrThrowArgs>
    ): Prisma__WSShopClient<WSShopGetPayload<T>>

    /**
     * Find zero or more WSShops that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSShopFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WSShops
     * const wSShops = await prisma.wSShop.findMany()
     * 
     * // Get first 10 WSShops
     * const wSShops = await prisma.wSShop.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wSShopWithIdOnly = await prisma.wSShop.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WSShopFindManyArgs>(
      args?: SelectSubset<T, WSShopFindManyArgs>
    ): Prisma.PrismaPromise<Array<WSShopGetPayload<T>>>

    /**
     * Create a WSShop.
     * @param {WSShopCreateArgs} args - Arguments to create a WSShop.
     * @example
     * // Create one WSShop
     * const WSShop = await prisma.wSShop.create({
     *   data: {
     *     // ... data to create a WSShop
     *   }
     * })
     * 
    **/
    create<T extends WSShopCreateArgs>(
      args: SelectSubset<T, WSShopCreateArgs>
    ): Prisma__WSShopClient<WSShopGetPayload<T>>

    /**
     * Create many WSShops.
     *     @param {WSShopCreateManyArgs} args - Arguments to create many WSShops.
     *     @example
     *     // Create many WSShops
     *     const wSShop = await prisma.wSShop.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WSShopCreateManyArgs>(
      args?: SelectSubset<T, WSShopCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WSShop.
     * @param {WSShopDeleteArgs} args - Arguments to delete one WSShop.
     * @example
     * // Delete one WSShop
     * const WSShop = await prisma.wSShop.delete({
     *   where: {
     *     // ... filter to delete one WSShop
     *   }
     * })
     * 
    **/
    delete<T extends WSShopDeleteArgs>(
      args: SelectSubset<T, WSShopDeleteArgs>
    ): Prisma__WSShopClient<WSShopGetPayload<T>>

    /**
     * Update one WSShop.
     * @param {WSShopUpdateArgs} args - Arguments to update one WSShop.
     * @example
     * // Update one WSShop
     * const wSShop = await prisma.wSShop.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WSShopUpdateArgs>(
      args: SelectSubset<T, WSShopUpdateArgs>
    ): Prisma__WSShopClient<WSShopGetPayload<T>>

    /**
     * Delete zero or more WSShops.
     * @param {WSShopDeleteManyArgs} args - Arguments to filter WSShops to delete.
     * @example
     * // Delete a few WSShops
     * const { count } = await prisma.wSShop.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WSShopDeleteManyArgs>(
      args?: SelectSubset<T, WSShopDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WSShops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSShopUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WSShops
     * const wSShop = await prisma.wSShop.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WSShopUpdateManyArgs>(
      args: SelectSubset<T, WSShopUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WSShop.
     * @param {WSShopUpsertArgs} args - Arguments to update or create a WSShop.
     * @example
     * // Update or create a WSShop
     * const wSShop = await prisma.wSShop.upsert({
     *   create: {
     *     // ... data to create a WSShop
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WSShop we want to update
     *   }
     * })
    **/
    upsert<T extends WSShopUpsertArgs>(
      args: SelectSubset<T, WSShopUpsertArgs>
    ): Prisma__WSShopClient<WSShopGetPayload<T>>

    /**
     * Count the number of WSShops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSShopCountArgs} args - Arguments to filter WSShops to count.
     * @example
     * // Count the number of WSShops
     * const count = await prisma.wSShop.count({
     *   where: {
     *     // ... the filter for the WSShops we want to count
     *   }
     * })
    **/
    count<T extends WSShopCountArgs>(
      args?: Subset<T, WSShopCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WSShopCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WSShop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSShopAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WSShopAggregateArgs>(args: Subset<T, WSShopAggregateArgs>): Prisma.PrismaPromise<GetWSShopAggregateType<T>>

    /**
     * Group by WSShop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSShopGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WSShopGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WSShopGroupByArgs['orderBy'] }
        : { orderBy?: WSShopGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WSShopGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWSShopGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for WSShop.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WSShopClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    machines<T extends WSShop$machinesArgs= {}>(args?: Subset<T, WSShop$machinesArgs>): Prisma.PrismaPromise<Array<WSMachineGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * WSShop base type for findUnique actions
   */
  export type WSShopFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the WSShop
     */
    select?: WSShopSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSShopInclude | null
    /**
     * Filter, which WSShop to fetch.
     */
    where: WSShopWhereUniqueInput
  }

  /**
   * WSShop findUnique
   */
  export interface WSShopFindUniqueArgs extends WSShopFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WSShop findUniqueOrThrow
   */
  export type WSShopFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the WSShop
     */
    select?: WSShopSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSShopInclude | null
    /**
     * Filter, which WSShop to fetch.
     */
    where: WSShopWhereUniqueInput
  }


  /**
   * WSShop base type for findFirst actions
   */
  export type WSShopFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the WSShop
     */
    select?: WSShopSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSShopInclude | null
    /**
     * Filter, which WSShop to fetch.
     */
    where?: WSShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSShops to fetch.
     */
    orderBy?: Enumerable<WSShopOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WSShops.
     */
    cursor?: WSShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSShops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSShops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WSShops.
     */
    distinct?: Enumerable<WSShopScalarFieldEnum>
  }

  /**
   * WSShop findFirst
   */
  export interface WSShopFindFirstArgs extends WSShopFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WSShop findFirstOrThrow
   */
  export type WSShopFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the WSShop
     */
    select?: WSShopSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSShopInclude | null
    /**
     * Filter, which WSShop to fetch.
     */
    where?: WSShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSShops to fetch.
     */
    orderBy?: Enumerable<WSShopOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WSShops.
     */
    cursor?: WSShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSShops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSShops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WSShops.
     */
    distinct?: Enumerable<WSShopScalarFieldEnum>
  }


  /**
   * WSShop findMany
   */
  export type WSShopFindManyArgs = {
    /**
     * Select specific fields to fetch from the WSShop
     */
    select?: WSShopSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSShopInclude | null
    /**
     * Filter, which WSShops to fetch.
     */
    where?: WSShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSShops to fetch.
     */
    orderBy?: Enumerable<WSShopOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WSShops.
     */
    cursor?: WSShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSShops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSShops.
     */
    skip?: number
    distinct?: Enumerable<WSShopScalarFieldEnum>
  }


  /**
   * WSShop create
   */
  export type WSShopCreateArgs = {
    /**
     * Select specific fields to fetch from the WSShop
     */
    select?: WSShopSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSShopInclude | null
    /**
     * The data needed to create a WSShop.
     */
    data: XOR<WSShopCreateInput, WSShopUncheckedCreateInput>
  }


  /**
   * WSShop createMany
   */
  export type WSShopCreateManyArgs = {
    /**
     * The data used to create many WSShops.
     */
    data: Enumerable<WSShopCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * WSShop update
   */
  export type WSShopUpdateArgs = {
    /**
     * Select specific fields to fetch from the WSShop
     */
    select?: WSShopSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSShopInclude | null
    /**
     * The data needed to update a WSShop.
     */
    data: XOR<WSShopUpdateInput, WSShopUncheckedUpdateInput>
    /**
     * Choose, which WSShop to update.
     */
    where: WSShopWhereUniqueInput
  }


  /**
   * WSShop updateMany
   */
  export type WSShopUpdateManyArgs = {
    /**
     * The data used to update WSShops.
     */
    data: XOR<WSShopUpdateManyMutationInput, WSShopUncheckedUpdateManyInput>
    /**
     * Filter which WSShops to update
     */
    where?: WSShopWhereInput
  }


  /**
   * WSShop upsert
   */
  export type WSShopUpsertArgs = {
    /**
     * Select specific fields to fetch from the WSShop
     */
    select?: WSShopSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSShopInclude | null
    /**
     * The filter to search for the WSShop to update in case it exists.
     */
    where: WSShopWhereUniqueInput
    /**
     * In case the WSShop found by the `where` argument doesn't exist, create a new WSShop with this data.
     */
    create: XOR<WSShopCreateInput, WSShopUncheckedCreateInput>
    /**
     * In case the WSShop was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WSShopUpdateInput, WSShopUncheckedUpdateInput>
  }


  /**
   * WSShop delete
   */
  export type WSShopDeleteArgs = {
    /**
     * Select specific fields to fetch from the WSShop
     */
    select?: WSShopSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSShopInclude | null
    /**
     * Filter which WSShop to delete.
     */
    where: WSShopWhereUniqueInput
  }


  /**
   * WSShop deleteMany
   */
  export type WSShopDeleteManyArgs = {
    /**
     * Filter which WSShops to delete
     */
    where?: WSShopWhereInput
  }


  /**
   * WSShop.machines
   */
  export type WSShop$machinesArgs = {
    /**
     * Select specific fields to fetch from the WSMachine
     */
    select?: WSMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSMachineInclude | null
    where?: WSMachineWhereInput
    orderBy?: Enumerable<WSMachineOrderByWithRelationInput>
    cursor?: WSMachineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WSMachineScalarFieldEnum>
  }


  /**
   * WSShop without action
   */
  export type WSShopArgs = {
    /**
     * Select specific fields to fetch from the WSShop
     */
    select?: WSShopSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSShopInclude | null
  }



  /**
   * Model WSMachine
   */


  export type AggregateWSMachine = {
    _count: WSMachineCountAggregateOutputType | null
    _avg: WSMachineAvgAggregateOutputType | null
    _sum: WSMachineSumAggregateOutputType | null
    _min: WSMachineMinAggregateOutputType | null
    _max: WSMachineMaxAggregateOutputType | null
  }

  export type WSMachineAvgAggregateOutputType = {
    id: number | null
    shopId: number | null
  }

  export type WSMachineSumAggregateOutputType = {
    id: number | null
    shopId: number | null
  }

  export type WSMachineMinAggregateOutputType = {
    id: number | null
    shopId: number | null
    brandname: string | null
    size: string | null
    type: string | null
    model: string | null
    producedDate: string | null
    insuranceExpiredDate: string | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type WSMachineMaxAggregateOutputType = {
    id: number | null
    shopId: number | null
    brandname: string | null
    size: string | null
    type: string | null
    model: string | null
    producedDate: string | null
    insuranceExpiredDate: string | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type WSMachineCountAggregateOutputType = {
    id: number
    shopId: number
    brandname: number
    size: number
    type: number
    model: number
    producedDate: number
    insuranceExpiredDate: number
    createdAt: number
    updateAt: number
    _all: number
  }


  export type WSMachineAvgAggregateInputType = {
    id?: true
    shopId?: true
  }

  export type WSMachineSumAggregateInputType = {
    id?: true
    shopId?: true
  }

  export type WSMachineMinAggregateInputType = {
    id?: true
    shopId?: true
    brandname?: true
    size?: true
    type?: true
    model?: true
    producedDate?: true
    insuranceExpiredDate?: true
    createdAt?: true
    updateAt?: true
  }

  export type WSMachineMaxAggregateInputType = {
    id?: true
    shopId?: true
    brandname?: true
    size?: true
    type?: true
    model?: true
    producedDate?: true
    insuranceExpiredDate?: true
    createdAt?: true
    updateAt?: true
  }

  export type WSMachineCountAggregateInputType = {
    id?: true
    shopId?: true
    brandname?: true
    size?: true
    type?: true
    model?: true
    producedDate?: true
    insuranceExpiredDate?: true
    createdAt?: true
    updateAt?: true
    _all?: true
  }

  export type WSMachineAggregateArgs = {
    /**
     * Filter which WSMachine to aggregate.
     */
    where?: WSMachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSMachines to fetch.
     */
    orderBy?: Enumerable<WSMachineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WSMachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSMachines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSMachines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WSMachines
    **/
    _count?: true | WSMachineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WSMachineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WSMachineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WSMachineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WSMachineMaxAggregateInputType
  }

  export type GetWSMachineAggregateType<T extends WSMachineAggregateArgs> = {
        [P in keyof T & keyof AggregateWSMachine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWSMachine[P]>
      : GetScalarType<T[P], AggregateWSMachine[P]>
  }




  export type WSMachineGroupByArgs = {
    where?: WSMachineWhereInput
    orderBy?: Enumerable<WSMachineOrderByWithAggregationInput>
    by: WSMachineScalarFieldEnum[]
    having?: WSMachineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WSMachineCountAggregateInputType | true
    _avg?: WSMachineAvgAggregateInputType
    _sum?: WSMachineSumAggregateInputType
    _min?: WSMachineMinAggregateInputType
    _max?: WSMachineMaxAggregateInputType
  }


  export type WSMachineGroupByOutputType = {
    id: number
    shopId: number
    brandname: string
    size: string
    type: string
    model: string
    producedDate: string
    insuranceExpiredDate: string
    createdAt: Date
    updateAt: Date
    _count: WSMachineCountAggregateOutputType | null
    _avg: WSMachineAvgAggregateOutputType | null
    _sum: WSMachineSumAggregateOutputType | null
    _min: WSMachineMinAggregateOutputType | null
    _max: WSMachineMaxAggregateOutputType | null
  }

  type GetWSMachineGroupByPayload<T extends WSMachineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<WSMachineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WSMachineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WSMachineGroupByOutputType[P]>
            : GetScalarType<T[P], WSMachineGroupByOutputType[P]>
        }
      >
    >


  export type WSMachineSelect = {
    id?: boolean
    shop?: boolean | WSShopArgs
    shopId?: boolean
    brandname?: boolean
    size?: boolean
    type?: boolean
    model?: boolean
    producedDate?: boolean
    insuranceExpiredDate?: boolean
    createdAt?: boolean
    updateAt?: boolean
    machineToPrograms?: boolean | WSMachine$machineToProgramsArgs
    maintains?: boolean | WSMachine$maintainsArgs
    usingHistories?: boolean | WSMachine$usingHistoriesArgs
    _count?: boolean | WSMachineCountOutputTypeArgs
  }


  export type WSMachineInclude = {
    shop?: boolean | WSShopArgs
    machineToPrograms?: boolean | WSMachine$machineToProgramsArgs
    maintains?: boolean | WSMachine$maintainsArgs
    usingHistories?: boolean | WSMachine$usingHistoriesArgs
    _count?: boolean | WSMachineCountOutputTypeArgs
  }

  export type WSMachineGetPayload<S extends boolean | null | undefined | WSMachineArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? WSMachine :
    S extends undefined ? never :
    S extends { include: any } & (WSMachineArgs | WSMachineFindManyArgs)
    ? WSMachine  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'shop' ? WSShopGetPayload<S['include'][P]> :
        P extends 'machineToPrograms' ? Array < MachineToProgramGetPayload<S['include'][P]>>  :
        P extends 'maintains' ? Array < WSMaintainGetPayload<S['include'][P]>>  :
        P extends 'usingHistories' ? Array < WSUsingHistoryGetPayload<S['include'][P]>>  :
        P extends '_count' ? WSMachineCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (WSMachineArgs | WSMachineFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'shop' ? WSShopGetPayload<S['select'][P]> :
        P extends 'machineToPrograms' ? Array < MachineToProgramGetPayload<S['select'][P]>>  :
        P extends 'maintains' ? Array < WSMaintainGetPayload<S['select'][P]>>  :
        P extends 'usingHistories' ? Array < WSUsingHistoryGetPayload<S['select'][P]>>  :
        P extends '_count' ? WSMachineCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof WSMachine ? WSMachine[P] : never
  } 
      : WSMachine


  type WSMachineCountArgs = 
    Omit<WSMachineFindManyArgs, 'select' | 'include'> & {
      select?: WSMachineCountAggregateInputType | true
    }

  export interface WSMachineDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one WSMachine that matches the filter.
     * @param {WSMachineFindUniqueArgs} args - Arguments to find a WSMachine
     * @example
     * // Get one WSMachine
     * const wSMachine = await prisma.wSMachine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WSMachineFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WSMachineFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'WSMachine'> extends True ? Prisma__WSMachineClient<WSMachineGetPayload<T>> : Prisma__WSMachineClient<WSMachineGetPayload<T> | null, null>

    /**
     * Find one WSMachine that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WSMachineFindUniqueOrThrowArgs} args - Arguments to find a WSMachine
     * @example
     * // Get one WSMachine
     * const wSMachine = await prisma.wSMachine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WSMachineFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, WSMachineFindUniqueOrThrowArgs>
    ): Prisma__WSMachineClient<WSMachineGetPayload<T>>

    /**
     * Find the first WSMachine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSMachineFindFirstArgs} args - Arguments to find a WSMachine
     * @example
     * // Get one WSMachine
     * const wSMachine = await prisma.wSMachine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WSMachineFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WSMachineFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'WSMachine'> extends True ? Prisma__WSMachineClient<WSMachineGetPayload<T>> : Prisma__WSMachineClient<WSMachineGetPayload<T> | null, null>

    /**
     * Find the first WSMachine that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSMachineFindFirstOrThrowArgs} args - Arguments to find a WSMachine
     * @example
     * // Get one WSMachine
     * const wSMachine = await prisma.wSMachine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WSMachineFindFirstOrThrowArgs>(
      args?: SelectSubset<T, WSMachineFindFirstOrThrowArgs>
    ): Prisma__WSMachineClient<WSMachineGetPayload<T>>

    /**
     * Find zero or more WSMachines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSMachineFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WSMachines
     * const wSMachines = await prisma.wSMachine.findMany()
     * 
     * // Get first 10 WSMachines
     * const wSMachines = await prisma.wSMachine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wSMachineWithIdOnly = await prisma.wSMachine.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WSMachineFindManyArgs>(
      args?: SelectSubset<T, WSMachineFindManyArgs>
    ): Prisma.PrismaPromise<Array<WSMachineGetPayload<T>>>

    /**
     * Create a WSMachine.
     * @param {WSMachineCreateArgs} args - Arguments to create a WSMachine.
     * @example
     * // Create one WSMachine
     * const WSMachine = await prisma.wSMachine.create({
     *   data: {
     *     // ... data to create a WSMachine
     *   }
     * })
     * 
    **/
    create<T extends WSMachineCreateArgs>(
      args: SelectSubset<T, WSMachineCreateArgs>
    ): Prisma__WSMachineClient<WSMachineGetPayload<T>>

    /**
     * Create many WSMachines.
     *     @param {WSMachineCreateManyArgs} args - Arguments to create many WSMachines.
     *     @example
     *     // Create many WSMachines
     *     const wSMachine = await prisma.wSMachine.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WSMachineCreateManyArgs>(
      args?: SelectSubset<T, WSMachineCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WSMachine.
     * @param {WSMachineDeleteArgs} args - Arguments to delete one WSMachine.
     * @example
     * // Delete one WSMachine
     * const WSMachine = await prisma.wSMachine.delete({
     *   where: {
     *     // ... filter to delete one WSMachine
     *   }
     * })
     * 
    **/
    delete<T extends WSMachineDeleteArgs>(
      args: SelectSubset<T, WSMachineDeleteArgs>
    ): Prisma__WSMachineClient<WSMachineGetPayload<T>>

    /**
     * Update one WSMachine.
     * @param {WSMachineUpdateArgs} args - Arguments to update one WSMachine.
     * @example
     * // Update one WSMachine
     * const wSMachine = await prisma.wSMachine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WSMachineUpdateArgs>(
      args: SelectSubset<T, WSMachineUpdateArgs>
    ): Prisma__WSMachineClient<WSMachineGetPayload<T>>

    /**
     * Delete zero or more WSMachines.
     * @param {WSMachineDeleteManyArgs} args - Arguments to filter WSMachines to delete.
     * @example
     * // Delete a few WSMachines
     * const { count } = await prisma.wSMachine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WSMachineDeleteManyArgs>(
      args?: SelectSubset<T, WSMachineDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WSMachines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSMachineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WSMachines
     * const wSMachine = await prisma.wSMachine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WSMachineUpdateManyArgs>(
      args: SelectSubset<T, WSMachineUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WSMachine.
     * @param {WSMachineUpsertArgs} args - Arguments to update or create a WSMachine.
     * @example
     * // Update or create a WSMachine
     * const wSMachine = await prisma.wSMachine.upsert({
     *   create: {
     *     // ... data to create a WSMachine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WSMachine we want to update
     *   }
     * })
    **/
    upsert<T extends WSMachineUpsertArgs>(
      args: SelectSubset<T, WSMachineUpsertArgs>
    ): Prisma__WSMachineClient<WSMachineGetPayload<T>>

    /**
     * Count the number of WSMachines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSMachineCountArgs} args - Arguments to filter WSMachines to count.
     * @example
     * // Count the number of WSMachines
     * const count = await prisma.wSMachine.count({
     *   where: {
     *     // ... the filter for the WSMachines we want to count
     *   }
     * })
    **/
    count<T extends WSMachineCountArgs>(
      args?: Subset<T, WSMachineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WSMachineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WSMachine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSMachineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WSMachineAggregateArgs>(args: Subset<T, WSMachineAggregateArgs>): Prisma.PrismaPromise<GetWSMachineAggregateType<T>>

    /**
     * Group by WSMachine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSMachineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WSMachineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WSMachineGroupByArgs['orderBy'] }
        : { orderBy?: WSMachineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WSMachineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWSMachineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for WSMachine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WSMachineClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    shop<T extends WSShopArgs= {}>(args?: Subset<T, WSShopArgs>): Prisma__WSShopClient<WSShopGetPayload<T> | Null>;

    machineToPrograms<T extends WSMachine$machineToProgramsArgs= {}>(args?: Subset<T, WSMachine$machineToProgramsArgs>): Prisma.PrismaPromise<Array<MachineToProgramGetPayload<T>>| Null>;

    maintains<T extends WSMachine$maintainsArgs= {}>(args?: Subset<T, WSMachine$maintainsArgs>): Prisma.PrismaPromise<Array<WSMaintainGetPayload<T>>| Null>;

    usingHistories<T extends WSMachine$usingHistoriesArgs= {}>(args?: Subset<T, WSMachine$usingHistoriesArgs>): Prisma.PrismaPromise<Array<WSUsingHistoryGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * WSMachine base type for findUnique actions
   */
  export type WSMachineFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the WSMachine
     */
    select?: WSMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSMachineInclude | null
    /**
     * Filter, which WSMachine to fetch.
     */
    where: WSMachineWhereUniqueInput
  }

  /**
   * WSMachine findUnique
   */
  export interface WSMachineFindUniqueArgs extends WSMachineFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WSMachine findUniqueOrThrow
   */
  export type WSMachineFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the WSMachine
     */
    select?: WSMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSMachineInclude | null
    /**
     * Filter, which WSMachine to fetch.
     */
    where: WSMachineWhereUniqueInput
  }


  /**
   * WSMachine base type for findFirst actions
   */
  export type WSMachineFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the WSMachine
     */
    select?: WSMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSMachineInclude | null
    /**
     * Filter, which WSMachine to fetch.
     */
    where?: WSMachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSMachines to fetch.
     */
    orderBy?: Enumerable<WSMachineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WSMachines.
     */
    cursor?: WSMachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSMachines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSMachines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WSMachines.
     */
    distinct?: Enumerable<WSMachineScalarFieldEnum>
  }

  /**
   * WSMachine findFirst
   */
  export interface WSMachineFindFirstArgs extends WSMachineFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WSMachine findFirstOrThrow
   */
  export type WSMachineFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the WSMachine
     */
    select?: WSMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSMachineInclude | null
    /**
     * Filter, which WSMachine to fetch.
     */
    where?: WSMachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSMachines to fetch.
     */
    orderBy?: Enumerable<WSMachineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WSMachines.
     */
    cursor?: WSMachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSMachines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSMachines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WSMachines.
     */
    distinct?: Enumerable<WSMachineScalarFieldEnum>
  }


  /**
   * WSMachine findMany
   */
  export type WSMachineFindManyArgs = {
    /**
     * Select specific fields to fetch from the WSMachine
     */
    select?: WSMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSMachineInclude | null
    /**
     * Filter, which WSMachines to fetch.
     */
    where?: WSMachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSMachines to fetch.
     */
    orderBy?: Enumerable<WSMachineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WSMachines.
     */
    cursor?: WSMachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSMachines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSMachines.
     */
    skip?: number
    distinct?: Enumerable<WSMachineScalarFieldEnum>
  }


  /**
   * WSMachine create
   */
  export type WSMachineCreateArgs = {
    /**
     * Select specific fields to fetch from the WSMachine
     */
    select?: WSMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSMachineInclude | null
    /**
     * The data needed to create a WSMachine.
     */
    data: XOR<WSMachineCreateInput, WSMachineUncheckedCreateInput>
  }


  /**
   * WSMachine createMany
   */
  export type WSMachineCreateManyArgs = {
    /**
     * The data used to create many WSMachines.
     */
    data: Enumerable<WSMachineCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * WSMachine update
   */
  export type WSMachineUpdateArgs = {
    /**
     * Select specific fields to fetch from the WSMachine
     */
    select?: WSMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSMachineInclude | null
    /**
     * The data needed to update a WSMachine.
     */
    data: XOR<WSMachineUpdateInput, WSMachineUncheckedUpdateInput>
    /**
     * Choose, which WSMachine to update.
     */
    where: WSMachineWhereUniqueInput
  }


  /**
   * WSMachine updateMany
   */
  export type WSMachineUpdateManyArgs = {
    /**
     * The data used to update WSMachines.
     */
    data: XOR<WSMachineUpdateManyMutationInput, WSMachineUncheckedUpdateManyInput>
    /**
     * Filter which WSMachines to update
     */
    where?: WSMachineWhereInput
  }


  /**
   * WSMachine upsert
   */
  export type WSMachineUpsertArgs = {
    /**
     * Select specific fields to fetch from the WSMachine
     */
    select?: WSMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSMachineInclude | null
    /**
     * The filter to search for the WSMachine to update in case it exists.
     */
    where: WSMachineWhereUniqueInput
    /**
     * In case the WSMachine found by the `where` argument doesn't exist, create a new WSMachine with this data.
     */
    create: XOR<WSMachineCreateInput, WSMachineUncheckedCreateInput>
    /**
     * In case the WSMachine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WSMachineUpdateInput, WSMachineUncheckedUpdateInput>
  }


  /**
   * WSMachine delete
   */
  export type WSMachineDeleteArgs = {
    /**
     * Select specific fields to fetch from the WSMachine
     */
    select?: WSMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSMachineInclude | null
    /**
     * Filter which WSMachine to delete.
     */
    where: WSMachineWhereUniqueInput
  }


  /**
   * WSMachine deleteMany
   */
  export type WSMachineDeleteManyArgs = {
    /**
     * Filter which WSMachines to delete
     */
    where?: WSMachineWhereInput
  }


  /**
   * WSMachine.machineToPrograms
   */
  export type WSMachine$machineToProgramsArgs = {
    /**
     * Select specific fields to fetch from the MachineToProgram
     */
    select?: MachineToProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineToProgramInclude | null
    where?: MachineToProgramWhereInput
    orderBy?: Enumerable<MachineToProgramOrderByWithRelationInput>
    cursor?: MachineToProgramWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MachineToProgramScalarFieldEnum>
  }


  /**
   * WSMachine.maintains
   */
  export type WSMachine$maintainsArgs = {
    /**
     * Select specific fields to fetch from the WSMaintain
     */
    select?: WSMaintainSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSMaintainInclude | null
    where?: WSMaintainWhereInput
    orderBy?: Enumerable<WSMaintainOrderByWithRelationInput>
    cursor?: WSMaintainWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WSMaintainScalarFieldEnum>
  }


  /**
   * WSMachine.usingHistories
   */
  export type WSMachine$usingHistoriesArgs = {
    /**
     * Select specific fields to fetch from the WSUsingHistory
     */
    select?: WSUsingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSUsingHistoryInclude | null
    where?: WSUsingHistoryWhereInput
    orderBy?: Enumerable<WSUsingHistoryOrderByWithRelationInput>
    cursor?: WSUsingHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WSUsingHistoryScalarFieldEnum>
  }


  /**
   * WSMachine without action
   */
  export type WSMachineArgs = {
    /**
     * Select specific fields to fetch from the WSMachine
     */
    select?: WSMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSMachineInclude | null
  }



  /**
   * Model WSProgram
   */


  export type AggregateWSProgram = {
    _count: WSProgramCountAggregateOutputType | null
    _avg: WSProgramAvgAggregateOutputType | null
    _sum: WSProgramSumAggregateOutputType | null
    _min: WSProgramMinAggregateOutputType | null
    _max: WSProgramMaxAggregateOutputType | null
  }

  export type WSProgramAvgAggregateOutputType = {
    id: number | null
    activeProgramId: number | null
  }

  export type WSProgramSumAggregateOutputType = {
    id: number | null
    activeProgramId: number | null
  }

  export type WSProgramMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updateAt: Date | null
    activeProgramId: number | null
  }

  export type WSProgramMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updateAt: Date | null
    activeProgramId: number | null
  }

  export type WSProgramCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updateAt: number
    activeProgramId: number
    _all: number
  }


  export type WSProgramAvgAggregateInputType = {
    id?: true
    activeProgramId?: true
  }

  export type WSProgramSumAggregateInputType = {
    id?: true
    activeProgramId?: true
  }

  export type WSProgramMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updateAt?: true
    activeProgramId?: true
  }

  export type WSProgramMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updateAt?: true
    activeProgramId?: true
  }

  export type WSProgramCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updateAt?: true
    activeProgramId?: true
    _all?: true
  }

  export type WSProgramAggregateArgs = {
    /**
     * Filter which WSProgram to aggregate.
     */
    where?: WSProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSPrograms to fetch.
     */
    orderBy?: Enumerable<WSProgramOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WSProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WSPrograms
    **/
    _count?: true | WSProgramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WSProgramAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WSProgramSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WSProgramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WSProgramMaxAggregateInputType
  }

  export type GetWSProgramAggregateType<T extends WSProgramAggregateArgs> = {
        [P in keyof T & keyof AggregateWSProgram]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWSProgram[P]>
      : GetScalarType<T[P], AggregateWSProgram[P]>
  }




  export type WSProgramGroupByArgs = {
    where?: WSProgramWhereInput
    orderBy?: Enumerable<WSProgramOrderByWithAggregationInput>
    by: WSProgramScalarFieldEnum[]
    having?: WSProgramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WSProgramCountAggregateInputType | true
    _avg?: WSProgramAvgAggregateInputType
    _sum?: WSProgramSumAggregateInputType
    _min?: WSProgramMinAggregateInputType
    _max?: WSProgramMaxAggregateInputType
  }


  export type WSProgramGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updateAt: Date
    activeProgramId: number
    _count: WSProgramCountAggregateOutputType | null
    _avg: WSProgramAvgAggregateOutputType | null
    _sum: WSProgramSumAggregateOutputType | null
    _min: WSProgramMinAggregateOutputType | null
    _max: WSProgramMaxAggregateOutputType | null
  }

  type GetWSProgramGroupByPayload<T extends WSProgramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<WSProgramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WSProgramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WSProgramGroupByOutputType[P]>
            : GetScalarType<T[P], WSProgramGroupByOutputType[P]>
        }
      >
    >


  export type WSProgramSelect = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updateAt?: boolean
    machineToPrograms?: boolean | WSProgram$machineToProgramsArgs
    programLists?: boolean | WSProgram$programListsArgs
    activeProgram?: boolean | WSProgramDetailArgs
    usingHistories?: boolean | WSProgram$usingHistoriesArgs
    activeProgramId?: boolean
    _count?: boolean | WSProgramCountOutputTypeArgs
  }


  export type WSProgramInclude = {
    machineToPrograms?: boolean | WSProgram$machineToProgramsArgs
    programLists?: boolean | WSProgram$programListsArgs
    activeProgram?: boolean | WSProgramDetailArgs
    usingHistories?: boolean | WSProgram$usingHistoriesArgs
    _count?: boolean | WSProgramCountOutputTypeArgs
  }

  export type WSProgramGetPayload<S extends boolean | null | undefined | WSProgramArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? WSProgram :
    S extends undefined ? never :
    S extends { include: any } & (WSProgramArgs | WSProgramFindManyArgs)
    ? WSProgram  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'machineToPrograms' ? Array < MachineToProgramGetPayload<S['include'][P]>>  :
        P extends 'programLists' ? Array < WSProgramDetailGetPayload<S['include'][P]>>  :
        P extends 'activeProgram' ? WSProgramDetailGetPayload<S['include'][P]> :
        P extends 'usingHistories' ? Array < WSUsingHistoryGetPayload<S['include'][P]>>  :
        P extends '_count' ? WSProgramCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (WSProgramArgs | WSProgramFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'machineToPrograms' ? Array < MachineToProgramGetPayload<S['select'][P]>>  :
        P extends 'programLists' ? Array < WSProgramDetailGetPayload<S['select'][P]>>  :
        P extends 'activeProgram' ? WSProgramDetailGetPayload<S['select'][P]> :
        P extends 'usingHistories' ? Array < WSUsingHistoryGetPayload<S['select'][P]>>  :
        P extends '_count' ? WSProgramCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof WSProgram ? WSProgram[P] : never
  } 
      : WSProgram


  type WSProgramCountArgs = 
    Omit<WSProgramFindManyArgs, 'select' | 'include'> & {
      select?: WSProgramCountAggregateInputType | true
    }

  export interface WSProgramDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one WSProgram that matches the filter.
     * @param {WSProgramFindUniqueArgs} args - Arguments to find a WSProgram
     * @example
     * // Get one WSProgram
     * const wSProgram = await prisma.wSProgram.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WSProgramFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WSProgramFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'WSProgram'> extends True ? Prisma__WSProgramClient<WSProgramGetPayload<T>> : Prisma__WSProgramClient<WSProgramGetPayload<T> | null, null>

    /**
     * Find one WSProgram that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WSProgramFindUniqueOrThrowArgs} args - Arguments to find a WSProgram
     * @example
     * // Get one WSProgram
     * const wSProgram = await prisma.wSProgram.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WSProgramFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, WSProgramFindUniqueOrThrowArgs>
    ): Prisma__WSProgramClient<WSProgramGetPayload<T>>

    /**
     * Find the first WSProgram that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSProgramFindFirstArgs} args - Arguments to find a WSProgram
     * @example
     * // Get one WSProgram
     * const wSProgram = await prisma.wSProgram.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WSProgramFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WSProgramFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'WSProgram'> extends True ? Prisma__WSProgramClient<WSProgramGetPayload<T>> : Prisma__WSProgramClient<WSProgramGetPayload<T> | null, null>

    /**
     * Find the first WSProgram that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSProgramFindFirstOrThrowArgs} args - Arguments to find a WSProgram
     * @example
     * // Get one WSProgram
     * const wSProgram = await prisma.wSProgram.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WSProgramFindFirstOrThrowArgs>(
      args?: SelectSubset<T, WSProgramFindFirstOrThrowArgs>
    ): Prisma__WSProgramClient<WSProgramGetPayload<T>>

    /**
     * Find zero or more WSPrograms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSProgramFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WSPrograms
     * const wSPrograms = await prisma.wSProgram.findMany()
     * 
     * // Get first 10 WSPrograms
     * const wSPrograms = await prisma.wSProgram.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wSProgramWithIdOnly = await prisma.wSProgram.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WSProgramFindManyArgs>(
      args?: SelectSubset<T, WSProgramFindManyArgs>
    ): Prisma.PrismaPromise<Array<WSProgramGetPayload<T>>>

    /**
     * Create a WSProgram.
     * @param {WSProgramCreateArgs} args - Arguments to create a WSProgram.
     * @example
     * // Create one WSProgram
     * const WSProgram = await prisma.wSProgram.create({
     *   data: {
     *     // ... data to create a WSProgram
     *   }
     * })
     * 
    **/
    create<T extends WSProgramCreateArgs>(
      args: SelectSubset<T, WSProgramCreateArgs>
    ): Prisma__WSProgramClient<WSProgramGetPayload<T>>

    /**
     * Create many WSPrograms.
     *     @param {WSProgramCreateManyArgs} args - Arguments to create many WSPrograms.
     *     @example
     *     // Create many WSPrograms
     *     const wSProgram = await prisma.wSProgram.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WSProgramCreateManyArgs>(
      args?: SelectSubset<T, WSProgramCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WSProgram.
     * @param {WSProgramDeleteArgs} args - Arguments to delete one WSProgram.
     * @example
     * // Delete one WSProgram
     * const WSProgram = await prisma.wSProgram.delete({
     *   where: {
     *     // ... filter to delete one WSProgram
     *   }
     * })
     * 
    **/
    delete<T extends WSProgramDeleteArgs>(
      args: SelectSubset<T, WSProgramDeleteArgs>
    ): Prisma__WSProgramClient<WSProgramGetPayload<T>>

    /**
     * Update one WSProgram.
     * @param {WSProgramUpdateArgs} args - Arguments to update one WSProgram.
     * @example
     * // Update one WSProgram
     * const wSProgram = await prisma.wSProgram.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WSProgramUpdateArgs>(
      args: SelectSubset<T, WSProgramUpdateArgs>
    ): Prisma__WSProgramClient<WSProgramGetPayload<T>>

    /**
     * Delete zero or more WSPrograms.
     * @param {WSProgramDeleteManyArgs} args - Arguments to filter WSPrograms to delete.
     * @example
     * // Delete a few WSPrograms
     * const { count } = await prisma.wSProgram.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WSProgramDeleteManyArgs>(
      args?: SelectSubset<T, WSProgramDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WSPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSProgramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WSPrograms
     * const wSProgram = await prisma.wSProgram.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WSProgramUpdateManyArgs>(
      args: SelectSubset<T, WSProgramUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WSProgram.
     * @param {WSProgramUpsertArgs} args - Arguments to update or create a WSProgram.
     * @example
     * // Update or create a WSProgram
     * const wSProgram = await prisma.wSProgram.upsert({
     *   create: {
     *     // ... data to create a WSProgram
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WSProgram we want to update
     *   }
     * })
    **/
    upsert<T extends WSProgramUpsertArgs>(
      args: SelectSubset<T, WSProgramUpsertArgs>
    ): Prisma__WSProgramClient<WSProgramGetPayload<T>>

    /**
     * Count the number of WSPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSProgramCountArgs} args - Arguments to filter WSPrograms to count.
     * @example
     * // Count the number of WSPrograms
     * const count = await prisma.wSProgram.count({
     *   where: {
     *     // ... the filter for the WSPrograms we want to count
     *   }
     * })
    **/
    count<T extends WSProgramCountArgs>(
      args?: Subset<T, WSProgramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WSProgramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WSProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSProgramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WSProgramAggregateArgs>(args: Subset<T, WSProgramAggregateArgs>): Prisma.PrismaPromise<GetWSProgramAggregateType<T>>

    /**
     * Group by WSProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSProgramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WSProgramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WSProgramGroupByArgs['orderBy'] }
        : { orderBy?: WSProgramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WSProgramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWSProgramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for WSProgram.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WSProgramClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    machineToPrograms<T extends WSProgram$machineToProgramsArgs= {}>(args?: Subset<T, WSProgram$machineToProgramsArgs>): Prisma.PrismaPromise<Array<MachineToProgramGetPayload<T>>| Null>;

    programLists<T extends WSProgram$programListsArgs= {}>(args?: Subset<T, WSProgram$programListsArgs>): Prisma.PrismaPromise<Array<WSProgramDetailGetPayload<T>>| Null>;

    activeProgram<T extends WSProgramDetailArgs= {}>(args?: Subset<T, WSProgramDetailArgs>): Prisma__WSProgramDetailClient<WSProgramDetailGetPayload<T> | Null>;

    usingHistories<T extends WSProgram$usingHistoriesArgs= {}>(args?: Subset<T, WSProgram$usingHistoriesArgs>): Prisma.PrismaPromise<Array<WSUsingHistoryGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * WSProgram base type for findUnique actions
   */
  export type WSProgramFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the WSProgram
     */
    select?: WSProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSProgramInclude | null
    /**
     * Filter, which WSProgram to fetch.
     */
    where: WSProgramWhereUniqueInput
  }

  /**
   * WSProgram findUnique
   */
  export interface WSProgramFindUniqueArgs extends WSProgramFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WSProgram findUniqueOrThrow
   */
  export type WSProgramFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the WSProgram
     */
    select?: WSProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSProgramInclude | null
    /**
     * Filter, which WSProgram to fetch.
     */
    where: WSProgramWhereUniqueInput
  }


  /**
   * WSProgram base type for findFirst actions
   */
  export type WSProgramFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the WSProgram
     */
    select?: WSProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSProgramInclude | null
    /**
     * Filter, which WSProgram to fetch.
     */
    where?: WSProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSPrograms to fetch.
     */
    orderBy?: Enumerable<WSProgramOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WSPrograms.
     */
    cursor?: WSProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WSPrograms.
     */
    distinct?: Enumerable<WSProgramScalarFieldEnum>
  }

  /**
   * WSProgram findFirst
   */
  export interface WSProgramFindFirstArgs extends WSProgramFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WSProgram findFirstOrThrow
   */
  export type WSProgramFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the WSProgram
     */
    select?: WSProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSProgramInclude | null
    /**
     * Filter, which WSProgram to fetch.
     */
    where?: WSProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSPrograms to fetch.
     */
    orderBy?: Enumerable<WSProgramOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WSPrograms.
     */
    cursor?: WSProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WSPrograms.
     */
    distinct?: Enumerable<WSProgramScalarFieldEnum>
  }


  /**
   * WSProgram findMany
   */
  export type WSProgramFindManyArgs = {
    /**
     * Select specific fields to fetch from the WSProgram
     */
    select?: WSProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSProgramInclude | null
    /**
     * Filter, which WSPrograms to fetch.
     */
    where?: WSProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSPrograms to fetch.
     */
    orderBy?: Enumerable<WSProgramOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WSPrograms.
     */
    cursor?: WSProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSPrograms.
     */
    skip?: number
    distinct?: Enumerable<WSProgramScalarFieldEnum>
  }


  /**
   * WSProgram create
   */
  export type WSProgramCreateArgs = {
    /**
     * Select specific fields to fetch from the WSProgram
     */
    select?: WSProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSProgramInclude | null
    /**
     * The data needed to create a WSProgram.
     */
    data: XOR<WSProgramCreateInput, WSProgramUncheckedCreateInput>
  }


  /**
   * WSProgram createMany
   */
  export type WSProgramCreateManyArgs = {
    /**
     * The data used to create many WSPrograms.
     */
    data: Enumerable<WSProgramCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * WSProgram update
   */
  export type WSProgramUpdateArgs = {
    /**
     * Select specific fields to fetch from the WSProgram
     */
    select?: WSProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSProgramInclude | null
    /**
     * The data needed to update a WSProgram.
     */
    data: XOR<WSProgramUpdateInput, WSProgramUncheckedUpdateInput>
    /**
     * Choose, which WSProgram to update.
     */
    where: WSProgramWhereUniqueInput
  }


  /**
   * WSProgram updateMany
   */
  export type WSProgramUpdateManyArgs = {
    /**
     * The data used to update WSPrograms.
     */
    data: XOR<WSProgramUpdateManyMutationInput, WSProgramUncheckedUpdateManyInput>
    /**
     * Filter which WSPrograms to update
     */
    where?: WSProgramWhereInput
  }


  /**
   * WSProgram upsert
   */
  export type WSProgramUpsertArgs = {
    /**
     * Select specific fields to fetch from the WSProgram
     */
    select?: WSProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSProgramInclude | null
    /**
     * The filter to search for the WSProgram to update in case it exists.
     */
    where: WSProgramWhereUniqueInput
    /**
     * In case the WSProgram found by the `where` argument doesn't exist, create a new WSProgram with this data.
     */
    create: XOR<WSProgramCreateInput, WSProgramUncheckedCreateInput>
    /**
     * In case the WSProgram was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WSProgramUpdateInput, WSProgramUncheckedUpdateInput>
  }


  /**
   * WSProgram delete
   */
  export type WSProgramDeleteArgs = {
    /**
     * Select specific fields to fetch from the WSProgram
     */
    select?: WSProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSProgramInclude | null
    /**
     * Filter which WSProgram to delete.
     */
    where: WSProgramWhereUniqueInput
  }


  /**
   * WSProgram deleteMany
   */
  export type WSProgramDeleteManyArgs = {
    /**
     * Filter which WSPrograms to delete
     */
    where?: WSProgramWhereInput
  }


  /**
   * WSProgram.machineToPrograms
   */
  export type WSProgram$machineToProgramsArgs = {
    /**
     * Select specific fields to fetch from the MachineToProgram
     */
    select?: MachineToProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineToProgramInclude | null
    where?: MachineToProgramWhereInput
    orderBy?: Enumerable<MachineToProgramOrderByWithRelationInput>
    cursor?: MachineToProgramWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MachineToProgramScalarFieldEnum>
  }


  /**
   * WSProgram.programLists
   */
  export type WSProgram$programListsArgs = {
    /**
     * Select specific fields to fetch from the WSProgramDetail
     */
    select?: WSProgramDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSProgramDetailInclude | null
    where?: WSProgramDetailWhereInput
    orderBy?: Enumerable<WSProgramDetailOrderByWithRelationInput>
    cursor?: WSProgramDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WSProgramDetailScalarFieldEnum>
  }


  /**
   * WSProgram.usingHistories
   */
  export type WSProgram$usingHistoriesArgs = {
    /**
     * Select specific fields to fetch from the WSUsingHistory
     */
    select?: WSUsingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSUsingHistoryInclude | null
    where?: WSUsingHistoryWhereInput
    orderBy?: Enumerable<WSUsingHistoryOrderByWithRelationInput>
    cursor?: WSUsingHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WSUsingHistoryScalarFieldEnum>
  }


  /**
   * WSProgram without action
   */
  export type WSProgramArgs = {
    /**
     * Select specific fields to fetch from the WSProgram
     */
    select?: WSProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSProgramInclude | null
  }



  /**
   * Model MachineToProgram
   */


  export type AggregateMachineToProgram = {
    _count: MachineToProgramCountAggregateOutputType | null
    _avg: MachineToProgramAvgAggregateOutputType | null
    _sum: MachineToProgramSumAggregateOutputType | null
    _min: MachineToProgramMinAggregateOutputType | null
    _max: MachineToProgramMaxAggregateOutputType | null
  }

  export type MachineToProgramAvgAggregateOutputType = {
    id: number | null
    machineId: number | null
    programId: number | null
  }

  export type MachineToProgramSumAggregateOutputType = {
    id: number | null
    machineId: number | null
    programId: number | null
  }

  export type MachineToProgramMinAggregateOutputType = {
    id: number | null
    machineId: number | null
    programId: number | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type MachineToProgramMaxAggregateOutputType = {
    id: number | null
    machineId: number | null
    programId: number | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type MachineToProgramCountAggregateOutputType = {
    id: number
    machineId: number
    programId: number
    createdAt: number
    updateAt: number
    _all: number
  }


  export type MachineToProgramAvgAggregateInputType = {
    id?: true
    machineId?: true
    programId?: true
  }

  export type MachineToProgramSumAggregateInputType = {
    id?: true
    machineId?: true
    programId?: true
  }

  export type MachineToProgramMinAggregateInputType = {
    id?: true
    machineId?: true
    programId?: true
    createdAt?: true
    updateAt?: true
  }

  export type MachineToProgramMaxAggregateInputType = {
    id?: true
    machineId?: true
    programId?: true
    createdAt?: true
    updateAt?: true
  }

  export type MachineToProgramCountAggregateInputType = {
    id?: true
    machineId?: true
    programId?: true
    createdAt?: true
    updateAt?: true
    _all?: true
  }

  export type MachineToProgramAggregateArgs = {
    /**
     * Filter which MachineToProgram to aggregate.
     */
    where?: MachineToProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MachineToPrograms to fetch.
     */
    orderBy?: Enumerable<MachineToProgramOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MachineToProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MachineToPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MachineToPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MachineToPrograms
    **/
    _count?: true | MachineToProgramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MachineToProgramAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MachineToProgramSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MachineToProgramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MachineToProgramMaxAggregateInputType
  }

  export type GetMachineToProgramAggregateType<T extends MachineToProgramAggregateArgs> = {
        [P in keyof T & keyof AggregateMachineToProgram]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMachineToProgram[P]>
      : GetScalarType<T[P], AggregateMachineToProgram[P]>
  }




  export type MachineToProgramGroupByArgs = {
    where?: MachineToProgramWhereInput
    orderBy?: Enumerable<MachineToProgramOrderByWithAggregationInput>
    by: MachineToProgramScalarFieldEnum[]
    having?: MachineToProgramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MachineToProgramCountAggregateInputType | true
    _avg?: MachineToProgramAvgAggregateInputType
    _sum?: MachineToProgramSumAggregateInputType
    _min?: MachineToProgramMinAggregateInputType
    _max?: MachineToProgramMaxAggregateInputType
  }


  export type MachineToProgramGroupByOutputType = {
    id: number
    machineId: number
    programId: number
    createdAt: Date
    updateAt: Date
    _count: MachineToProgramCountAggregateOutputType | null
    _avg: MachineToProgramAvgAggregateOutputType | null
    _sum: MachineToProgramSumAggregateOutputType | null
    _min: MachineToProgramMinAggregateOutputType | null
    _max: MachineToProgramMaxAggregateOutputType | null
  }

  type GetMachineToProgramGroupByPayload<T extends MachineToProgramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MachineToProgramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MachineToProgramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MachineToProgramGroupByOutputType[P]>
            : GetScalarType<T[P], MachineToProgramGroupByOutputType[P]>
        }
      >
    >


  export type MachineToProgramSelect = {
    id?: boolean
    maching?: boolean | WSMachineArgs
    machineId?: boolean
    program?: boolean | WSProgramArgs
    programId?: boolean
    createdAt?: boolean
    updateAt?: boolean
  }


  export type MachineToProgramInclude = {
    maching?: boolean | WSMachineArgs
    program?: boolean | WSProgramArgs
  }

  export type MachineToProgramGetPayload<S extends boolean | null | undefined | MachineToProgramArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MachineToProgram :
    S extends undefined ? never :
    S extends { include: any } & (MachineToProgramArgs | MachineToProgramFindManyArgs)
    ? MachineToProgram  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'maching' ? WSMachineGetPayload<S['include'][P]> :
        P extends 'program' ? WSProgramGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (MachineToProgramArgs | MachineToProgramFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'maching' ? WSMachineGetPayload<S['select'][P]> :
        P extends 'program' ? WSProgramGetPayload<S['select'][P]> :  P extends keyof MachineToProgram ? MachineToProgram[P] : never
  } 
      : MachineToProgram


  type MachineToProgramCountArgs = 
    Omit<MachineToProgramFindManyArgs, 'select' | 'include'> & {
      select?: MachineToProgramCountAggregateInputType | true
    }

  export interface MachineToProgramDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one MachineToProgram that matches the filter.
     * @param {MachineToProgramFindUniqueArgs} args - Arguments to find a MachineToProgram
     * @example
     * // Get one MachineToProgram
     * const machineToProgram = await prisma.machineToProgram.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MachineToProgramFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MachineToProgramFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MachineToProgram'> extends True ? Prisma__MachineToProgramClient<MachineToProgramGetPayload<T>> : Prisma__MachineToProgramClient<MachineToProgramGetPayload<T> | null, null>

    /**
     * Find one MachineToProgram that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MachineToProgramFindUniqueOrThrowArgs} args - Arguments to find a MachineToProgram
     * @example
     * // Get one MachineToProgram
     * const machineToProgram = await prisma.machineToProgram.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MachineToProgramFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MachineToProgramFindUniqueOrThrowArgs>
    ): Prisma__MachineToProgramClient<MachineToProgramGetPayload<T>>

    /**
     * Find the first MachineToProgram that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineToProgramFindFirstArgs} args - Arguments to find a MachineToProgram
     * @example
     * // Get one MachineToProgram
     * const machineToProgram = await prisma.machineToProgram.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MachineToProgramFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MachineToProgramFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MachineToProgram'> extends True ? Prisma__MachineToProgramClient<MachineToProgramGetPayload<T>> : Prisma__MachineToProgramClient<MachineToProgramGetPayload<T> | null, null>

    /**
     * Find the first MachineToProgram that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineToProgramFindFirstOrThrowArgs} args - Arguments to find a MachineToProgram
     * @example
     * // Get one MachineToProgram
     * const machineToProgram = await prisma.machineToProgram.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MachineToProgramFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MachineToProgramFindFirstOrThrowArgs>
    ): Prisma__MachineToProgramClient<MachineToProgramGetPayload<T>>

    /**
     * Find zero or more MachineToPrograms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineToProgramFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MachineToPrograms
     * const machineToPrograms = await prisma.machineToProgram.findMany()
     * 
     * // Get first 10 MachineToPrograms
     * const machineToPrograms = await prisma.machineToProgram.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const machineToProgramWithIdOnly = await prisma.machineToProgram.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MachineToProgramFindManyArgs>(
      args?: SelectSubset<T, MachineToProgramFindManyArgs>
    ): Prisma.PrismaPromise<Array<MachineToProgramGetPayload<T>>>

    /**
     * Create a MachineToProgram.
     * @param {MachineToProgramCreateArgs} args - Arguments to create a MachineToProgram.
     * @example
     * // Create one MachineToProgram
     * const MachineToProgram = await prisma.machineToProgram.create({
     *   data: {
     *     // ... data to create a MachineToProgram
     *   }
     * })
     * 
    **/
    create<T extends MachineToProgramCreateArgs>(
      args: SelectSubset<T, MachineToProgramCreateArgs>
    ): Prisma__MachineToProgramClient<MachineToProgramGetPayload<T>>

    /**
     * Create many MachineToPrograms.
     *     @param {MachineToProgramCreateManyArgs} args - Arguments to create many MachineToPrograms.
     *     @example
     *     // Create many MachineToPrograms
     *     const machineToProgram = await prisma.machineToProgram.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MachineToProgramCreateManyArgs>(
      args?: SelectSubset<T, MachineToProgramCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MachineToProgram.
     * @param {MachineToProgramDeleteArgs} args - Arguments to delete one MachineToProgram.
     * @example
     * // Delete one MachineToProgram
     * const MachineToProgram = await prisma.machineToProgram.delete({
     *   where: {
     *     // ... filter to delete one MachineToProgram
     *   }
     * })
     * 
    **/
    delete<T extends MachineToProgramDeleteArgs>(
      args: SelectSubset<T, MachineToProgramDeleteArgs>
    ): Prisma__MachineToProgramClient<MachineToProgramGetPayload<T>>

    /**
     * Update one MachineToProgram.
     * @param {MachineToProgramUpdateArgs} args - Arguments to update one MachineToProgram.
     * @example
     * // Update one MachineToProgram
     * const machineToProgram = await prisma.machineToProgram.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MachineToProgramUpdateArgs>(
      args: SelectSubset<T, MachineToProgramUpdateArgs>
    ): Prisma__MachineToProgramClient<MachineToProgramGetPayload<T>>

    /**
     * Delete zero or more MachineToPrograms.
     * @param {MachineToProgramDeleteManyArgs} args - Arguments to filter MachineToPrograms to delete.
     * @example
     * // Delete a few MachineToPrograms
     * const { count } = await prisma.machineToProgram.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MachineToProgramDeleteManyArgs>(
      args?: SelectSubset<T, MachineToProgramDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MachineToPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineToProgramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MachineToPrograms
     * const machineToProgram = await prisma.machineToProgram.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MachineToProgramUpdateManyArgs>(
      args: SelectSubset<T, MachineToProgramUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MachineToProgram.
     * @param {MachineToProgramUpsertArgs} args - Arguments to update or create a MachineToProgram.
     * @example
     * // Update or create a MachineToProgram
     * const machineToProgram = await prisma.machineToProgram.upsert({
     *   create: {
     *     // ... data to create a MachineToProgram
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MachineToProgram we want to update
     *   }
     * })
    **/
    upsert<T extends MachineToProgramUpsertArgs>(
      args: SelectSubset<T, MachineToProgramUpsertArgs>
    ): Prisma__MachineToProgramClient<MachineToProgramGetPayload<T>>

    /**
     * Count the number of MachineToPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineToProgramCountArgs} args - Arguments to filter MachineToPrograms to count.
     * @example
     * // Count the number of MachineToPrograms
     * const count = await prisma.machineToProgram.count({
     *   where: {
     *     // ... the filter for the MachineToPrograms we want to count
     *   }
     * })
    **/
    count<T extends MachineToProgramCountArgs>(
      args?: Subset<T, MachineToProgramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MachineToProgramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MachineToProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineToProgramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MachineToProgramAggregateArgs>(args: Subset<T, MachineToProgramAggregateArgs>): Prisma.PrismaPromise<GetMachineToProgramAggregateType<T>>

    /**
     * Group by MachineToProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineToProgramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MachineToProgramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MachineToProgramGroupByArgs['orderBy'] }
        : { orderBy?: MachineToProgramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MachineToProgramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMachineToProgramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for MachineToProgram.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MachineToProgramClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    maching<T extends WSMachineArgs= {}>(args?: Subset<T, WSMachineArgs>): Prisma__WSMachineClient<WSMachineGetPayload<T> | Null>;

    program<T extends WSProgramArgs= {}>(args?: Subset<T, WSProgramArgs>): Prisma__WSProgramClient<WSProgramGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * MachineToProgram base type for findUnique actions
   */
  export type MachineToProgramFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the MachineToProgram
     */
    select?: MachineToProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineToProgramInclude | null
    /**
     * Filter, which MachineToProgram to fetch.
     */
    where: MachineToProgramWhereUniqueInput
  }

  /**
   * MachineToProgram findUnique
   */
  export interface MachineToProgramFindUniqueArgs extends MachineToProgramFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MachineToProgram findUniqueOrThrow
   */
  export type MachineToProgramFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MachineToProgram
     */
    select?: MachineToProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineToProgramInclude | null
    /**
     * Filter, which MachineToProgram to fetch.
     */
    where: MachineToProgramWhereUniqueInput
  }


  /**
   * MachineToProgram base type for findFirst actions
   */
  export type MachineToProgramFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the MachineToProgram
     */
    select?: MachineToProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineToProgramInclude | null
    /**
     * Filter, which MachineToProgram to fetch.
     */
    where?: MachineToProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MachineToPrograms to fetch.
     */
    orderBy?: Enumerable<MachineToProgramOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MachineToPrograms.
     */
    cursor?: MachineToProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MachineToPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MachineToPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MachineToPrograms.
     */
    distinct?: Enumerable<MachineToProgramScalarFieldEnum>
  }

  /**
   * MachineToProgram findFirst
   */
  export interface MachineToProgramFindFirstArgs extends MachineToProgramFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MachineToProgram findFirstOrThrow
   */
  export type MachineToProgramFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MachineToProgram
     */
    select?: MachineToProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineToProgramInclude | null
    /**
     * Filter, which MachineToProgram to fetch.
     */
    where?: MachineToProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MachineToPrograms to fetch.
     */
    orderBy?: Enumerable<MachineToProgramOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MachineToPrograms.
     */
    cursor?: MachineToProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MachineToPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MachineToPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MachineToPrograms.
     */
    distinct?: Enumerable<MachineToProgramScalarFieldEnum>
  }


  /**
   * MachineToProgram findMany
   */
  export type MachineToProgramFindManyArgs = {
    /**
     * Select specific fields to fetch from the MachineToProgram
     */
    select?: MachineToProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineToProgramInclude | null
    /**
     * Filter, which MachineToPrograms to fetch.
     */
    where?: MachineToProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MachineToPrograms to fetch.
     */
    orderBy?: Enumerable<MachineToProgramOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MachineToPrograms.
     */
    cursor?: MachineToProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MachineToPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MachineToPrograms.
     */
    skip?: number
    distinct?: Enumerable<MachineToProgramScalarFieldEnum>
  }


  /**
   * MachineToProgram create
   */
  export type MachineToProgramCreateArgs = {
    /**
     * Select specific fields to fetch from the MachineToProgram
     */
    select?: MachineToProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineToProgramInclude | null
    /**
     * The data needed to create a MachineToProgram.
     */
    data: XOR<MachineToProgramCreateInput, MachineToProgramUncheckedCreateInput>
  }


  /**
   * MachineToProgram createMany
   */
  export type MachineToProgramCreateManyArgs = {
    /**
     * The data used to create many MachineToPrograms.
     */
    data: Enumerable<MachineToProgramCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * MachineToProgram update
   */
  export type MachineToProgramUpdateArgs = {
    /**
     * Select specific fields to fetch from the MachineToProgram
     */
    select?: MachineToProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineToProgramInclude | null
    /**
     * The data needed to update a MachineToProgram.
     */
    data: XOR<MachineToProgramUpdateInput, MachineToProgramUncheckedUpdateInput>
    /**
     * Choose, which MachineToProgram to update.
     */
    where: MachineToProgramWhereUniqueInput
  }


  /**
   * MachineToProgram updateMany
   */
  export type MachineToProgramUpdateManyArgs = {
    /**
     * The data used to update MachineToPrograms.
     */
    data: XOR<MachineToProgramUpdateManyMutationInput, MachineToProgramUncheckedUpdateManyInput>
    /**
     * Filter which MachineToPrograms to update
     */
    where?: MachineToProgramWhereInput
  }


  /**
   * MachineToProgram upsert
   */
  export type MachineToProgramUpsertArgs = {
    /**
     * Select specific fields to fetch from the MachineToProgram
     */
    select?: MachineToProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineToProgramInclude | null
    /**
     * The filter to search for the MachineToProgram to update in case it exists.
     */
    where: MachineToProgramWhereUniqueInput
    /**
     * In case the MachineToProgram found by the `where` argument doesn't exist, create a new MachineToProgram with this data.
     */
    create: XOR<MachineToProgramCreateInput, MachineToProgramUncheckedCreateInput>
    /**
     * In case the MachineToProgram was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MachineToProgramUpdateInput, MachineToProgramUncheckedUpdateInput>
  }


  /**
   * MachineToProgram delete
   */
  export type MachineToProgramDeleteArgs = {
    /**
     * Select specific fields to fetch from the MachineToProgram
     */
    select?: MachineToProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineToProgramInclude | null
    /**
     * Filter which MachineToProgram to delete.
     */
    where: MachineToProgramWhereUniqueInput
  }


  /**
   * MachineToProgram deleteMany
   */
  export type MachineToProgramDeleteManyArgs = {
    /**
     * Filter which MachineToPrograms to delete
     */
    where?: MachineToProgramWhereInput
  }


  /**
   * MachineToProgram without action
   */
  export type MachineToProgramArgs = {
    /**
     * Select specific fields to fetch from the MachineToProgram
     */
    select?: MachineToProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineToProgramInclude | null
  }



  /**
   * Model WSProgramDetail
   */


  export type AggregateWSProgramDetail = {
    _count: WSProgramDetailCountAggregateOutputType | null
    _avg: WSProgramDetailAvgAggregateOutputType | null
    _sum: WSProgramDetailSumAggregateOutputType | null
    _min: WSProgramDetailMinAggregateOutputType | null
    _max: WSProgramDetailMaxAggregateOutputType | null
  }

  export type WSProgramDetailAvgAggregateOutputType = {
    id: number | null
    programId: number | null
    price: number | null
    duration: number | null
    weight: number | null
  }

  export type WSProgramDetailSumAggregateOutputType = {
    id: number | null
    programId: number | null
    price: number | null
    duration: number | null
    weight: number | null
  }

  export type WSProgramDetailMinAggregateOutputType = {
    id: number | null
    programId: number | null
    price: number | null
    duration: number | null
    weight: number | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type WSProgramDetailMaxAggregateOutputType = {
    id: number | null
    programId: number | null
    price: number | null
    duration: number | null
    weight: number | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type WSProgramDetailCountAggregateOutputType = {
    id: number
    programId: number
    price: number
    duration: number
    weight: number
    createdAt: number
    updateAt: number
    _all: number
  }


  export type WSProgramDetailAvgAggregateInputType = {
    id?: true
    programId?: true
    price?: true
    duration?: true
    weight?: true
  }

  export type WSProgramDetailSumAggregateInputType = {
    id?: true
    programId?: true
    price?: true
    duration?: true
    weight?: true
  }

  export type WSProgramDetailMinAggregateInputType = {
    id?: true
    programId?: true
    price?: true
    duration?: true
    weight?: true
    createdAt?: true
    updateAt?: true
  }

  export type WSProgramDetailMaxAggregateInputType = {
    id?: true
    programId?: true
    price?: true
    duration?: true
    weight?: true
    createdAt?: true
    updateAt?: true
  }

  export type WSProgramDetailCountAggregateInputType = {
    id?: true
    programId?: true
    price?: true
    duration?: true
    weight?: true
    createdAt?: true
    updateAt?: true
    _all?: true
  }

  export type WSProgramDetailAggregateArgs = {
    /**
     * Filter which WSProgramDetail to aggregate.
     */
    where?: WSProgramDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSProgramDetails to fetch.
     */
    orderBy?: Enumerable<WSProgramDetailOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WSProgramDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSProgramDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSProgramDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WSProgramDetails
    **/
    _count?: true | WSProgramDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WSProgramDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WSProgramDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WSProgramDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WSProgramDetailMaxAggregateInputType
  }

  export type GetWSProgramDetailAggregateType<T extends WSProgramDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateWSProgramDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWSProgramDetail[P]>
      : GetScalarType<T[P], AggregateWSProgramDetail[P]>
  }




  export type WSProgramDetailGroupByArgs = {
    where?: WSProgramDetailWhereInput
    orderBy?: Enumerable<WSProgramDetailOrderByWithAggregationInput>
    by: WSProgramDetailScalarFieldEnum[]
    having?: WSProgramDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WSProgramDetailCountAggregateInputType | true
    _avg?: WSProgramDetailAvgAggregateInputType
    _sum?: WSProgramDetailSumAggregateInputType
    _min?: WSProgramDetailMinAggregateInputType
    _max?: WSProgramDetailMaxAggregateInputType
  }


  export type WSProgramDetailGroupByOutputType = {
    id: number
    programId: number
    price: number
    duration: number
    weight: number
    createdAt: Date
    updateAt: Date
    _count: WSProgramDetailCountAggregateOutputType | null
    _avg: WSProgramDetailAvgAggregateOutputType | null
    _sum: WSProgramDetailSumAggregateOutputType | null
    _min: WSProgramDetailMinAggregateOutputType | null
    _max: WSProgramDetailMaxAggregateOutputType | null
  }

  type GetWSProgramDetailGroupByPayload<T extends WSProgramDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<WSProgramDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WSProgramDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WSProgramDetailGroupByOutputType[P]>
            : GetScalarType<T[P], WSProgramDetailGroupByOutputType[P]>
        }
      >
    >


  export type WSProgramDetailSelect = {
    id?: boolean
    program?: boolean | WSProgramArgs
    programId?: boolean
    price?: boolean
    duration?: boolean
    weight?: boolean
    createdAt?: boolean
    updateAt?: boolean
    programs?: boolean | WSProgramDetail$programsArgs
    _count?: boolean | WSProgramDetailCountOutputTypeArgs
  }


  export type WSProgramDetailInclude = {
    program?: boolean | WSProgramArgs
    programs?: boolean | WSProgramDetail$programsArgs
    _count?: boolean | WSProgramDetailCountOutputTypeArgs
  }

  export type WSProgramDetailGetPayload<S extends boolean | null | undefined | WSProgramDetailArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? WSProgramDetail :
    S extends undefined ? never :
    S extends { include: any } & (WSProgramDetailArgs | WSProgramDetailFindManyArgs)
    ? WSProgramDetail  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'program' ? WSProgramGetPayload<S['include'][P]> :
        P extends 'programs' ? Array < WSProgramGetPayload<S['include'][P]>>  :
        P extends '_count' ? WSProgramDetailCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (WSProgramDetailArgs | WSProgramDetailFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'program' ? WSProgramGetPayload<S['select'][P]> :
        P extends 'programs' ? Array < WSProgramGetPayload<S['select'][P]>>  :
        P extends '_count' ? WSProgramDetailCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof WSProgramDetail ? WSProgramDetail[P] : never
  } 
      : WSProgramDetail


  type WSProgramDetailCountArgs = 
    Omit<WSProgramDetailFindManyArgs, 'select' | 'include'> & {
      select?: WSProgramDetailCountAggregateInputType | true
    }

  export interface WSProgramDetailDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one WSProgramDetail that matches the filter.
     * @param {WSProgramDetailFindUniqueArgs} args - Arguments to find a WSProgramDetail
     * @example
     * // Get one WSProgramDetail
     * const wSProgramDetail = await prisma.wSProgramDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WSProgramDetailFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WSProgramDetailFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'WSProgramDetail'> extends True ? Prisma__WSProgramDetailClient<WSProgramDetailGetPayload<T>> : Prisma__WSProgramDetailClient<WSProgramDetailGetPayload<T> | null, null>

    /**
     * Find one WSProgramDetail that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WSProgramDetailFindUniqueOrThrowArgs} args - Arguments to find a WSProgramDetail
     * @example
     * // Get one WSProgramDetail
     * const wSProgramDetail = await prisma.wSProgramDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WSProgramDetailFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, WSProgramDetailFindUniqueOrThrowArgs>
    ): Prisma__WSProgramDetailClient<WSProgramDetailGetPayload<T>>

    /**
     * Find the first WSProgramDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSProgramDetailFindFirstArgs} args - Arguments to find a WSProgramDetail
     * @example
     * // Get one WSProgramDetail
     * const wSProgramDetail = await prisma.wSProgramDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WSProgramDetailFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WSProgramDetailFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'WSProgramDetail'> extends True ? Prisma__WSProgramDetailClient<WSProgramDetailGetPayload<T>> : Prisma__WSProgramDetailClient<WSProgramDetailGetPayload<T> | null, null>

    /**
     * Find the first WSProgramDetail that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSProgramDetailFindFirstOrThrowArgs} args - Arguments to find a WSProgramDetail
     * @example
     * // Get one WSProgramDetail
     * const wSProgramDetail = await prisma.wSProgramDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WSProgramDetailFindFirstOrThrowArgs>(
      args?: SelectSubset<T, WSProgramDetailFindFirstOrThrowArgs>
    ): Prisma__WSProgramDetailClient<WSProgramDetailGetPayload<T>>

    /**
     * Find zero or more WSProgramDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSProgramDetailFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WSProgramDetails
     * const wSProgramDetails = await prisma.wSProgramDetail.findMany()
     * 
     * // Get first 10 WSProgramDetails
     * const wSProgramDetails = await prisma.wSProgramDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wSProgramDetailWithIdOnly = await prisma.wSProgramDetail.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WSProgramDetailFindManyArgs>(
      args?: SelectSubset<T, WSProgramDetailFindManyArgs>
    ): Prisma.PrismaPromise<Array<WSProgramDetailGetPayload<T>>>

    /**
     * Create a WSProgramDetail.
     * @param {WSProgramDetailCreateArgs} args - Arguments to create a WSProgramDetail.
     * @example
     * // Create one WSProgramDetail
     * const WSProgramDetail = await prisma.wSProgramDetail.create({
     *   data: {
     *     // ... data to create a WSProgramDetail
     *   }
     * })
     * 
    **/
    create<T extends WSProgramDetailCreateArgs>(
      args: SelectSubset<T, WSProgramDetailCreateArgs>
    ): Prisma__WSProgramDetailClient<WSProgramDetailGetPayload<T>>

    /**
     * Create many WSProgramDetails.
     *     @param {WSProgramDetailCreateManyArgs} args - Arguments to create many WSProgramDetails.
     *     @example
     *     // Create many WSProgramDetails
     *     const wSProgramDetail = await prisma.wSProgramDetail.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WSProgramDetailCreateManyArgs>(
      args?: SelectSubset<T, WSProgramDetailCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WSProgramDetail.
     * @param {WSProgramDetailDeleteArgs} args - Arguments to delete one WSProgramDetail.
     * @example
     * // Delete one WSProgramDetail
     * const WSProgramDetail = await prisma.wSProgramDetail.delete({
     *   where: {
     *     // ... filter to delete one WSProgramDetail
     *   }
     * })
     * 
    **/
    delete<T extends WSProgramDetailDeleteArgs>(
      args: SelectSubset<T, WSProgramDetailDeleteArgs>
    ): Prisma__WSProgramDetailClient<WSProgramDetailGetPayload<T>>

    /**
     * Update one WSProgramDetail.
     * @param {WSProgramDetailUpdateArgs} args - Arguments to update one WSProgramDetail.
     * @example
     * // Update one WSProgramDetail
     * const wSProgramDetail = await prisma.wSProgramDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WSProgramDetailUpdateArgs>(
      args: SelectSubset<T, WSProgramDetailUpdateArgs>
    ): Prisma__WSProgramDetailClient<WSProgramDetailGetPayload<T>>

    /**
     * Delete zero or more WSProgramDetails.
     * @param {WSProgramDetailDeleteManyArgs} args - Arguments to filter WSProgramDetails to delete.
     * @example
     * // Delete a few WSProgramDetails
     * const { count } = await prisma.wSProgramDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WSProgramDetailDeleteManyArgs>(
      args?: SelectSubset<T, WSProgramDetailDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WSProgramDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSProgramDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WSProgramDetails
     * const wSProgramDetail = await prisma.wSProgramDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WSProgramDetailUpdateManyArgs>(
      args: SelectSubset<T, WSProgramDetailUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WSProgramDetail.
     * @param {WSProgramDetailUpsertArgs} args - Arguments to update or create a WSProgramDetail.
     * @example
     * // Update or create a WSProgramDetail
     * const wSProgramDetail = await prisma.wSProgramDetail.upsert({
     *   create: {
     *     // ... data to create a WSProgramDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WSProgramDetail we want to update
     *   }
     * })
    **/
    upsert<T extends WSProgramDetailUpsertArgs>(
      args: SelectSubset<T, WSProgramDetailUpsertArgs>
    ): Prisma__WSProgramDetailClient<WSProgramDetailGetPayload<T>>

    /**
     * Count the number of WSProgramDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSProgramDetailCountArgs} args - Arguments to filter WSProgramDetails to count.
     * @example
     * // Count the number of WSProgramDetails
     * const count = await prisma.wSProgramDetail.count({
     *   where: {
     *     // ... the filter for the WSProgramDetails we want to count
     *   }
     * })
    **/
    count<T extends WSProgramDetailCountArgs>(
      args?: Subset<T, WSProgramDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WSProgramDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WSProgramDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSProgramDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WSProgramDetailAggregateArgs>(args: Subset<T, WSProgramDetailAggregateArgs>): Prisma.PrismaPromise<GetWSProgramDetailAggregateType<T>>

    /**
     * Group by WSProgramDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSProgramDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WSProgramDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WSProgramDetailGroupByArgs['orderBy'] }
        : { orderBy?: WSProgramDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WSProgramDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWSProgramDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for WSProgramDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WSProgramDetailClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    program<T extends WSProgramArgs= {}>(args?: Subset<T, WSProgramArgs>): Prisma__WSProgramClient<WSProgramGetPayload<T> | Null>;

    programs<T extends WSProgramDetail$programsArgs= {}>(args?: Subset<T, WSProgramDetail$programsArgs>): Prisma.PrismaPromise<Array<WSProgramGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * WSProgramDetail base type for findUnique actions
   */
  export type WSProgramDetailFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the WSProgramDetail
     */
    select?: WSProgramDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSProgramDetailInclude | null
    /**
     * Filter, which WSProgramDetail to fetch.
     */
    where: WSProgramDetailWhereUniqueInput
  }

  /**
   * WSProgramDetail findUnique
   */
  export interface WSProgramDetailFindUniqueArgs extends WSProgramDetailFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WSProgramDetail findUniqueOrThrow
   */
  export type WSProgramDetailFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the WSProgramDetail
     */
    select?: WSProgramDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSProgramDetailInclude | null
    /**
     * Filter, which WSProgramDetail to fetch.
     */
    where: WSProgramDetailWhereUniqueInput
  }


  /**
   * WSProgramDetail base type for findFirst actions
   */
  export type WSProgramDetailFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the WSProgramDetail
     */
    select?: WSProgramDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSProgramDetailInclude | null
    /**
     * Filter, which WSProgramDetail to fetch.
     */
    where?: WSProgramDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSProgramDetails to fetch.
     */
    orderBy?: Enumerable<WSProgramDetailOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WSProgramDetails.
     */
    cursor?: WSProgramDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSProgramDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSProgramDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WSProgramDetails.
     */
    distinct?: Enumerable<WSProgramDetailScalarFieldEnum>
  }

  /**
   * WSProgramDetail findFirst
   */
  export interface WSProgramDetailFindFirstArgs extends WSProgramDetailFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WSProgramDetail findFirstOrThrow
   */
  export type WSProgramDetailFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the WSProgramDetail
     */
    select?: WSProgramDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSProgramDetailInclude | null
    /**
     * Filter, which WSProgramDetail to fetch.
     */
    where?: WSProgramDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSProgramDetails to fetch.
     */
    orderBy?: Enumerable<WSProgramDetailOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WSProgramDetails.
     */
    cursor?: WSProgramDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSProgramDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSProgramDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WSProgramDetails.
     */
    distinct?: Enumerable<WSProgramDetailScalarFieldEnum>
  }


  /**
   * WSProgramDetail findMany
   */
  export type WSProgramDetailFindManyArgs = {
    /**
     * Select specific fields to fetch from the WSProgramDetail
     */
    select?: WSProgramDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSProgramDetailInclude | null
    /**
     * Filter, which WSProgramDetails to fetch.
     */
    where?: WSProgramDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSProgramDetails to fetch.
     */
    orderBy?: Enumerable<WSProgramDetailOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WSProgramDetails.
     */
    cursor?: WSProgramDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSProgramDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSProgramDetails.
     */
    skip?: number
    distinct?: Enumerable<WSProgramDetailScalarFieldEnum>
  }


  /**
   * WSProgramDetail create
   */
  export type WSProgramDetailCreateArgs = {
    /**
     * Select specific fields to fetch from the WSProgramDetail
     */
    select?: WSProgramDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSProgramDetailInclude | null
    /**
     * The data needed to create a WSProgramDetail.
     */
    data: XOR<WSProgramDetailCreateInput, WSProgramDetailUncheckedCreateInput>
  }


  /**
   * WSProgramDetail createMany
   */
  export type WSProgramDetailCreateManyArgs = {
    /**
     * The data used to create many WSProgramDetails.
     */
    data: Enumerable<WSProgramDetailCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * WSProgramDetail update
   */
  export type WSProgramDetailUpdateArgs = {
    /**
     * Select specific fields to fetch from the WSProgramDetail
     */
    select?: WSProgramDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSProgramDetailInclude | null
    /**
     * The data needed to update a WSProgramDetail.
     */
    data: XOR<WSProgramDetailUpdateInput, WSProgramDetailUncheckedUpdateInput>
    /**
     * Choose, which WSProgramDetail to update.
     */
    where: WSProgramDetailWhereUniqueInput
  }


  /**
   * WSProgramDetail updateMany
   */
  export type WSProgramDetailUpdateManyArgs = {
    /**
     * The data used to update WSProgramDetails.
     */
    data: XOR<WSProgramDetailUpdateManyMutationInput, WSProgramDetailUncheckedUpdateManyInput>
    /**
     * Filter which WSProgramDetails to update
     */
    where?: WSProgramDetailWhereInput
  }


  /**
   * WSProgramDetail upsert
   */
  export type WSProgramDetailUpsertArgs = {
    /**
     * Select specific fields to fetch from the WSProgramDetail
     */
    select?: WSProgramDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSProgramDetailInclude | null
    /**
     * The filter to search for the WSProgramDetail to update in case it exists.
     */
    where: WSProgramDetailWhereUniqueInput
    /**
     * In case the WSProgramDetail found by the `where` argument doesn't exist, create a new WSProgramDetail with this data.
     */
    create: XOR<WSProgramDetailCreateInput, WSProgramDetailUncheckedCreateInput>
    /**
     * In case the WSProgramDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WSProgramDetailUpdateInput, WSProgramDetailUncheckedUpdateInput>
  }


  /**
   * WSProgramDetail delete
   */
  export type WSProgramDetailDeleteArgs = {
    /**
     * Select specific fields to fetch from the WSProgramDetail
     */
    select?: WSProgramDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSProgramDetailInclude | null
    /**
     * Filter which WSProgramDetail to delete.
     */
    where: WSProgramDetailWhereUniqueInput
  }


  /**
   * WSProgramDetail deleteMany
   */
  export type WSProgramDetailDeleteManyArgs = {
    /**
     * Filter which WSProgramDetails to delete
     */
    where?: WSProgramDetailWhereInput
  }


  /**
   * WSProgramDetail.programs
   */
  export type WSProgramDetail$programsArgs = {
    /**
     * Select specific fields to fetch from the WSProgram
     */
    select?: WSProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSProgramInclude | null
    where?: WSProgramWhereInput
    orderBy?: Enumerable<WSProgramOrderByWithRelationInput>
    cursor?: WSProgramWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WSProgramScalarFieldEnum>
  }


  /**
   * WSProgramDetail without action
   */
  export type WSProgramDetailArgs = {
    /**
     * Select specific fields to fetch from the WSProgramDetail
     */
    select?: WSProgramDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSProgramDetailInclude | null
  }



  /**
   * Model WSMaintain
   */


  export type AggregateWSMaintain = {
    _count: WSMaintainCountAggregateOutputType | null
    _avg: WSMaintainAvgAggregateOutputType | null
    _sum: WSMaintainSumAggregateOutputType | null
    _min: WSMaintainMinAggregateOutputType | null
    _max: WSMaintainMaxAggregateOutputType | null
  }

  export type WSMaintainAvgAggregateOutputType = {
    id: number | null
    machineId: number | null
  }

  export type WSMaintainSumAggregateOutputType = {
    id: number | null
    machineId: number | null
  }

  export type WSMaintainMinAggregateOutputType = {
    id: number | null
    checker: string | null
    item: string | null
    status: string | null
    machineId: number | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type WSMaintainMaxAggregateOutputType = {
    id: number | null
    checker: string | null
    item: string | null
    status: string | null
    machineId: number | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type WSMaintainCountAggregateOutputType = {
    id: number
    checker: number
    item: number
    status: number
    machineId: number
    createdAt: number
    updateAt: number
    _all: number
  }


  export type WSMaintainAvgAggregateInputType = {
    id?: true
    machineId?: true
  }

  export type WSMaintainSumAggregateInputType = {
    id?: true
    machineId?: true
  }

  export type WSMaintainMinAggregateInputType = {
    id?: true
    checker?: true
    item?: true
    status?: true
    machineId?: true
    createdAt?: true
    updateAt?: true
  }

  export type WSMaintainMaxAggregateInputType = {
    id?: true
    checker?: true
    item?: true
    status?: true
    machineId?: true
    createdAt?: true
    updateAt?: true
  }

  export type WSMaintainCountAggregateInputType = {
    id?: true
    checker?: true
    item?: true
    status?: true
    machineId?: true
    createdAt?: true
    updateAt?: true
    _all?: true
  }

  export type WSMaintainAggregateArgs = {
    /**
     * Filter which WSMaintain to aggregate.
     */
    where?: WSMaintainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSMaintains to fetch.
     */
    orderBy?: Enumerable<WSMaintainOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WSMaintainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSMaintains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSMaintains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WSMaintains
    **/
    _count?: true | WSMaintainCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WSMaintainAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WSMaintainSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WSMaintainMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WSMaintainMaxAggregateInputType
  }

  export type GetWSMaintainAggregateType<T extends WSMaintainAggregateArgs> = {
        [P in keyof T & keyof AggregateWSMaintain]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWSMaintain[P]>
      : GetScalarType<T[P], AggregateWSMaintain[P]>
  }




  export type WSMaintainGroupByArgs = {
    where?: WSMaintainWhereInput
    orderBy?: Enumerable<WSMaintainOrderByWithAggregationInput>
    by: WSMaintainScalarFieldEnum[]
    having?: WSMaintainScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WSMaintainCountAggregateInputType | true
    _avg?: WSMaintainAvgAggregateInputType
    _sum?: WSMaintainSumAggregateInputType
    _min?: WSMaintainMinAggregateInputType
    _max?: WSMaintainMaxAggregateInputType
  }


  export type WSMaintainGroupByOutputType = {
    id: number
    checker: string
    item: string
    status: string
    machineId: number
    createdAt: Date
    updateAt: Date
    _count: WSMaintainCountAggregateOutputType | null
    _avg: WSMaintainAvgAggregateOutputType | null
    _sum: WSMaintainSumAggregateOutputType | null
    _min: WSMaintainMinAggregateOutputType | null
    _max: WSMaintainMaxAggregateOutputType | null
  }

  type GetWSMaintainGroupByPayload<T extends WSMaintainGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<WSMaintainGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WSMaintainGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WSMaintainGroupByOutputType[P]>
            : GetScalarType<T[P], WSMaintainGroupByOutputType[P]>
        }
      >
    >


  export type WSMaintainSelect = {
    id?: boolean
    checker?: boolean
    item?: boolean
    status?: boolean
    machine?: boolean | WSMachineArgs
    machineId?: boolean
    createdAt?: boolean
    updateAt?: boolean
  }


  export type WSMaintainInclude = {
    machine?: boolean | WSMachineArgs
  }

  export type WSMaintainGetPayload<S extends boolean | null | undefined | WSMaintainArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? WSMaintain :
    S extends undefined ? never :
    S extends { include: any } & (WSMaintainArgs | WSMaintainFindManyArgs)
    ? WSMaintain  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'machine' ? WSMachineGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (WSMaintainArgs | WSMaintainFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'machine' ? WSMachineGetPayload<S['select'][P]> :  P extends keyof WSMaintain ? WSMaintain[P] : never
  } 
      : WSMaintain


  type WSMaintainCountArgs = 
    Omit<WSMaintainFindManyArgs, 'select' | 'include'> & {
      select?: WSMaintainCountAggregateInputType | true
    }

  export interface WSMaintainDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one WSMaintain that matches the filter.
     * @param {WSMaintainFindUniqueArgs} args - Arguments to find a WSMaintain
     * @example
     * // Get one WSMaintain
     * const wSMaintain = await prisma.wSMaintain.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WSMaintainFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WSMaintainFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'WSMaintain'> extends True ? Prisma__WSMaintainClient<WSMaintainGetPayload<T>> : Prisma__WSMaintainClient<WSMaintainGetPayload<T> | null, null>

    /**
     * Find one WSMaintain that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WSMaintainFindUniqueOrThrowArgs} args - Arguments to find a WSMaintain
     * @example
     * // Get one WSMaintain
     * const wSMaintain = await prisma.wSMaintain.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WSMaintainFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, WSMaintainFindUniqueOrThrowArgs>
    ): Prisma__WSMaintainClient<WSMaintainGetPayload<T>>

    /**
     * Find the first WSMaintain that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSMaintainFindFirstArgs} args - Arguments to find a WSMaintain
     * @example
     * // Get one WSMaintain
     * const wSMaintain = await prisma.wSMaintain.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WSMaintainFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WSMaintainFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'WSMaintain'> extends True ? Prisma__WSMaintainClient<WSMaintainGetPayload<T>> : Prisma__WSMaintainClient<WSMaintainGetPayload<T> | null, null>

    /**
     * Find the first WSMaintain that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSMaintainFindFirstOrThrowArgs} args - Arguments to find a WSMaintain
     * @example
     * // Get one WSMaintain
     * const wSMaintain = await prisma.wSMaintain.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WSMaintainFindFirstOrThrowArgs>(
      args?: SelectSubset<T, WSMaintainFindFirstOrThrowArgs>
    ): Prisma__WSMaintainClient<WSMaintainGetPayload<T>>

    /**
     * Find zero or more WSMaintains that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSMaintainFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WSMaintains
     * const wSMaintains = await prisma.wSMaintain.findMany()
     * 
     * // Get first 10 WSMaintains
     * const wSMaintains = await prisma.wSMaintain.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wSMaintainWithIdOnly = await prisma.wSMaintain.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WSMaintainFindManyArgs>(
      args?: SelectSubset<T, WSMaintainFindManyArgs>
    ): Prisma.PrismaPromise<Array<WSMaintainGetPayload<T>>>

    /**
     * Create a WSMaintain.
     * @param {WSMaintainCreateArgs} args - Arguments to create a WSMaintain.
     * @example
     * // Create one WSMaintain
     * const WSMaintain = await prisma.wSMaintain.create({
     *   data: {
     *     // ... data to create a WSMaintain
     *   }
     * })
     * 
    **/
    create<T extends WSMaintainCreateArgs>(
      args: SelectSubset<T, WSMaintainCreateArgs>
    ): Prisma__WSMaintainClient<WSMaintainGetPayload<T>>

    /**
     * Create many WSMaintains.
     *     @param {WSMaintainCreateManyArgs} args - Arguments to create many WSMaintains.
     *     @example
     *     // Create many WSMaintains
     *     const wSMaintain = await prisma.wSMaintain.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WSMaintainCreateManyArgs>(
      args?: SelectSubset<T, WSMaintainCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WSMaintain.
     * @param {WSMaintainDeleteArgs} args - Arguments to delete one WSMaintain.
     * @example
     * // Delete one WSMaintain
     * const WSMaintain = await prisma.wSMaintain.delete({
     *   where: {
     *     // ... filter to delete one WSMaintain
     *   }
     * })
     * 
    **/
    delete<T extends WSMaintainDeleteArgs>(
      args: SelectSubset<T, WSMaintainDeleteArgs>
    ): Prisma__WSMaintainClient<WSMaintainGetPayload<T>>

    /**
     * Update one WSMaintain.
     * @param {WSMaintainUpdateArgs} args - Arguments to update one WSMaintain.
     * @example
     * // Update one WSMaintain
     * const wSMaintain = await prisma.wSMaintain.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WSMaintainUpdateArgs>(
      args: SelectSubset<T, WSMaintainUpdateArgs>
    ): Prisma__WSMaintainClient<WSMaintainGetPayload<T>>

    /**
     * Delete zero or more WSMaintains.
     * @param {WSMaintainDeleteManyArgs} args - Arguments to filter WSMaintains to delete.
     * @example
     * // Delete a few WSMaintains
     * const { count } = await prisma.wSMaintain.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WSMaintainDeleteManyArgs>(
      args?: SelectSubset<T, WSMaintainDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WSMaintains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSMaintainUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WSMaintains
     * const wSMaintain = await prisma.wSMaintain.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WSMaintainUpdateManyArgs>(
      args: SelectSubset<T, WSMaintainUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WSMaintain.
     * @param {WSMaintainUpsertArgs} args - Arguments to update or create a WSMaintain.
     * @example
     * // Update or create a WSMaintain
     * const wSMaintain = await prisma.wSMaintain.upsert({
     *   create: {
     *     // ... data to create a WSMaintain
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WSMaintain we want to update
     *   }
     * })
    **/
    upsert<T extends WSMaintainUpsertArgs>(
      args: SelectSubset<T, WSMaintainUpsertArgs>
    ): Prisma__WSMaintainClient<WSMaintainGetPayload<T>>

    /**
     * Count the number of WSMaintains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSMaintainCountArgs} args - Arguments to filter WSMaintains to count.
     * @example
     * // Count the number of WSMaintains
     * const count = await prisma.wSMaintain.count({
     *   where: {
     *     // ... the filter for the WSMaintains we want to count
     *   }
     * })
    **/
    count<T extends WSMaintainCountArgs>(
      args?: Subset<T, WSMaintainCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WSMaintainCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WSMaintain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSMaintainAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WSMaintainAggregateArgs>(args: Subset<T, WSMaintainAggregateArgs>): Prisma.PrismaPromise<GetWSMaintainAggregateType<T>>

    /**
     * Group by WSMaintain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSMaintainGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WSMaintainGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WSMaintainGroupByArgs['orderBy'] }
        : { orderBy?: WSMaintainGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WSMaintainGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWSMaintainGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for WSMaintain.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WSMaintainClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    machine<T extends WSMachineArgs= {}>(args?: Subset<T, WSMachineArgs>): Prisma__WSMachineClient<WSMachineGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * WSMaintain base type for findUnique actions
   */
  export type WSMaintainFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the WSMaintain
     */
    select?: WSMaintainSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSMaintainInclude | null
    /**
     * Filter, which WSMaintain to fetch.
     */
    where: WSMaintainWhereUniqueInput
  }

  /**
   * WSMaintain findUnique
   */
  export interface WSMaintainFindUniqueArgs extends WSMaintainFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WSMaintain findUniqueOrThrow
   */
  export type WSMaintainFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the WSMaintain
     */
    select?: WSMaintainSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSMaintainInclude | null
    /**
     * Filter, which WSMaintain to fetch.
     */
    where: WSMaintainWhereUniqueInput
  }


  /**
   * WSMaintain base type for findFirst actions
   */
  export type WSMaintainFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the WSMaintain
     */
    select?: WSMaintainSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSMaintainInclude | null
    /**
     * Filter, which WSMaintain to fetch.
     */
    where?: WSMaintainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSMaintains to fetch.
     */
    orderBy?: Enumerable<WSMaintainOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WSMaintains.
     */
    cursor?: WSMaintainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSMaintains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSMaintains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WSMaintains.
     */
    distinct?: Enumerable<WSMaintainScalarFieldEnum>
  }

  /**
   * WSMaintain findFirst
   */
  export interface WSMaintainFindFirstArgs extends WSMaintainFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WSMaintain findFirstOrThrow
   */
  export type WSMaintainFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the WSMaintain
     */
    select?: WSMaintainSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSMaintainInclude | null
    /**
     * Filter, which WSMaintain to fetch.
     */
    where?: WSMaintainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSMaintains to fetch.
     */
    orderBy?: Enumerable<WSMaintainOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WSMaintains.
     */
    cursor?: WSMaintainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSMaintains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSMaintains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WSMaintains.
     */
    distinct?: Enumerable<WSMaintainScalarFieldEnum>
  }


  /**
   * WSMaintain findMany
   */
  export type WSMaintainFindManyArgs = {
    /**
     * Select specific fields to fetch from the WSMaintain
     */
    select?: WSMaintainSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSMaintainInclude | null
    /**
     * Filter, which WSMaintains to fetch.
     */
    where?: WSMaintainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSMaintains to fetch.
     */
    orderBy?: Enumerable<WSMaintainOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WSMaintains.
     */
    cursor?: WSMaintainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSMaintains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSMaintains.
     */
    skip?: number
    distinct?: Enumerable<WSMaintainScalarFieldEnum>
  }


  /**
   * WSMaintain create
   */
  export type WSMaintainCreateArgs = {
    /**
     * Select specific fields to fetch from the WSMaintain
     */
    select?: WSMaintainSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSMaintainInclude | null
    /**
     * The data needed to create a WSMaintain.
     */
    data: XOR<WSMaintainCreateInput, WSMaintainUncheckedCreateInput>
  }


  /**
   * WSMaintain createMany
   */
  export type WSMaintainCreateManyArgs = {
    /**
     * The data used to create many WSMaintains.
     */
    data: Enumerable<WSMaintainCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * WSMaintain update
   */
  export type WSMaintainUpdateArgs = {
    /**
     * Select specific fields to fetch from the WSMaintain
     */
    select?: WSMaintainSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSMaintainInclude | null
    /**
     * The data needed to update a WSMaintain.
     */
    data: XOR<WSMaintainUpdateInput, WSMaintainUncheckedUpdateInput>
    /**
     * Choose, which WSMaintain to update.
     */
    where: WSMaintainWhereUniqueInput
  }


  /**
   * WSMaintain updateMany
   */
  export type WSMaintainUpdateManyArgs = {
    /**
     * The data used to update WSMaintains.
     */
    data: XOR<WSMaintainUpdateManyMutationInput, WSMaintainUncheckedUpdateManyInput>
    /**
     * Filter which WSMaintains to update
     */
    where?: WSMaintainWhereInput
  }


  /**
   * WSMaintain upsert
   */
  export type WSMaintainUpsertArgs = {
    /**
     * Select specific fields to fetch from the WSMaintain
     */
    select?: WSMaintainSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSMaintainInclude | null
    /**
     * The filter to search for the WSMaintain to update in case it exists.
     */
    where: WSMaintainWhereUniqueInput
    /**
     * In case the WSMaintain found by the `where` argument doesn't exist, create a new WSMaintain with this data.
     */
    create: XOR<WSMaintainCreateInput, WSMaintainUncheckedCreateInput>
    /**
     * In case the WSMaintain was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WSMaintainUpdateInput, WSMaintainUncheckedUpdateInput>
  }


  /**
   * WSMaintain delete
   */
  export type WSMaintainDeleteArgs = {
    /**
     * Select specific fields to fetch from the WSMaintain
     */
    select?: WSMaintainSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSMaintainInclude | null
    /**
     * Filter which WSMaintain to delete.
     */
    where: WSMaintainWhereUniqueInput
  }


  /**
   * WSMaintain deleteMany
   */
  export type WSMaintainDeleteManyArgs = {
    /**
     * Filter which WSMaintains to delete
     */
    where?: WSMaintainWhereInput
  }


  /**
   * WSMaintain without action
   */
  export type WSMaintainArgs = {
    /**
     * Select specific fields to fetch from the WSMaintain
     */
    select?: WSMaintainSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WSMaintainInclude | null
  }



  /**
   * Model YTUser
   */


  export type AggregateYTUser = {
    _count: YTUserCountAggregateOutputType | null
    _avg: YTUserAvgAggregateOutputType | null
    _sum: YTUserSumAggregateOutputType | null
    _min: YTUserMinAggregateOutputType | null
    _max: YTUserMaxAggregateOutputType | null
  }

  export type YTUserAvgAggregateOutputType = {
    id: number | null
  }

  export type YTUserSumAggregateOutputType = {
    id: number | null
  }

  export type YTUserMinAggregateOutputType = {
    id: number | null
    user: string | null
    email: string | null
    avatar: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type YTUserMaxAggregateOutputType = {
    id: number | null
    user: string | null
    email: string | null
    avatar: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type YTUserCountAggregateOutputType = {
    id: number
    user: number
    email: number
    avatar: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type YTUserAvgAggregateInputType = {
    id?: true
  }

  export type YTUserSumAggregateInputType = {
    id?: true
  }

  export type YTUserMinAggregateInputType = {
    id?: true
    user?: true
    email?: true
    avatar?: true
    createdAt?: true
    updatedAt?: true
  }

  export type YTUserMaxAggregateInputType = {
    id?: true
    user?: true
    email?: true
    avatar?: true
    createdAt?: true
    updatedAt?: true
  }

  export type YTUserCountAggregateInputType = {
    id?: true
    user?: true
    email?: true
    avatar?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type YTUserAggregateArgs = {
    /**
     * Filter which YTUser to aggregate.
     */
    where?: YTUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YTUsers to fetch.
     */
    orderBy?: Enumerable<YTUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YTUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YTUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YTUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YTUsers
    **/
    _count?: true | YTUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YTUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YTUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YTUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YTUserMaxAggregateInputType
  }

  export type GetYTUserAggregateType<T extends YTUserAggregateArgs> = {
        [P in keyof T & keyof AggregateYTUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYTUser[P]>
      : GetScalarType<T[P], AggregateYTUser[P]>
  }




  export type YTUserGroupByArgs = {
    where?: YTUserWhereInput
    orderBy?: Enumerable<YTUserOrderByWithAggregationInput>
    by: YTUserScalarFieldEnum[]
    having?: YTUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YTUserCountAggregateInputType | true
    _avg?: YTUserAvgAggregateInputType
    _sum?: YTUserSumAggregateInputType
    _min?: YTUserMinAggregateInputType
    _max?: YTUserMaxAggregateInputType
  }


  export type YTUserGroupByOutputType = {
    id: number
    user: string
    email: string
    avatar: string
    createdAt: Date
    updatedAt: Date
    _count: YTUserCountAggregateOutputType | null
    _avg: YTUserAvgAggregateOutputType | null
    _sum: YTUserSumAggregateOutputType | null
    _min: YTUserMinAggregateOutputType | null
    _max: YTUserMaxAggregateOutputType | null
  }

  type GetYTUserGroupByPayload<T extends YTUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<YTUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YTUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YTUserGroupByOutputType[P]>
            : GetScalarType<T[P], YTUserGroupByOutputType[P]>
        }
      >
    >


  export type YTUserSelect = {
    id?: boolean
    user?: boolean
    email?: boolean
    avatar?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userToChannels?: boolean | YTUser$userToChannelsArgs
    comments?: boolean | YTUser$commentsArgs
    subscribes?: boolean | YTUser$subscribesArgs
    shares?: boolean | YTUser$sharesArgs
    _count?: boolean | YTUserCountOutputTypeArgs
  }


  export type YTUserInclude = {
    userToChannels?: boolean | YTUser$userToChannelsArgs
    comments?: boolean | YTUser$commentsArgs
    subscribes?: boolean | YTUser$subscribesArgs
    shares?: boolean | YTUser$sharesArgs
    _count?: boolean | YTUserCountOutputTypeArgs
  }

  export type YTUserGetPayload<S extends boolean | null | undefined | YTUserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YTUser :
    S extends undefined ? never :
    S extends { include: any } & (YTUserArgs | YTUserFindManyArgs)
    ? YTUser  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'userToChannels' ? Array < UserToChannelGetPayload<S['include'][P]>>  :
        P extends 'comments' ? Array < YTCommentGetPayload<S['include'][P]>>  :
        P extends 'subscribes' ? Array < YTSubscribeGetPayload<S['include'][P]>>  :
        P extends 'shares' ? Array < YTShareGetPayload<S['include'][P]>>  :
        P extends '_count' ? YTUserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (YTUserArgs | YTUserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'userToChannels' ? Array < UserToChannelGetPayload<S['select'][P]>>  :
        P extends 'comments' ? Array < YTCommentGetPayload<S['select'][P]>>  :
        P extends 'subscribes' ? Array < YTSubscribeGetPayload<S['select'][P]>>  :
        P extends 'shares' ? Array < YTShareGetPayload<S['select'][P]>>  :
        P extends '_count' ? YTUserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof YTUser ? YTUser[P] : never
  } 
      : YTUser


  type YTUserCountArgs = 
    Omit<YTUserFindManyArgs, 'select' | 'include'> & {
      select?: YTUserCountAggregateInputType | true
    }

  export interface YTUserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one YTUser that matches the filter.
     * @param {YTUserFindUniqueArgs} args - Arguments to find a YTUser
     * @example
     * // Get one YTUser
     * const yTUser = await prisma.yTUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends YTUserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, YTUserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'YTUser'> extends True ? Prisma__YTUserClient<YTUserGetPayload<T>> : Prisma__YTUserClient<YTUserGetPayload<T> | null, null>

    /**
     * Find one YTUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {YTUserFindUniqueOrThrowArgs} args - Arguments to find a YTUser
     * @example
     * // Get one YTUser
     * const yTUser = await prisma.yTUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends YTUserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, YTUserFindUniqueOrThrowArgs>
    ): Prisma__YTUserClient<YTUserGetPayload<T>>

    /**
     * Find the first YTUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTUserFindFirstArgs} args - Arguments to find a YTUser
     * @example
     * // Get one YTUser
     * const yTUser = await prisma.yTUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends YTUserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, YTUserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'YTUser'> extends True ? Prisma__YTUserClient<YTUserGetPayload<T>> : Prisma__YTUserClient<YTUserGetPayload<T> | null, null>

    /**
     * Find the first YTUser that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTUserFindFirstOrThrowArgs} args - Arguments to find a YTUser
     * @example
     * // Get one YTUser
     * const yTUser = await prisma.yTUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends YTUserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, YTUserFindFirstOrThrowArgs>
    ): Prisma__YTUserClient<YTUserGetPayload<T>>

    /**
     * Find zero or more YTUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YTUsers
     * const yTUsers = await prisma.yTUser.findMany()
     * 
     * // Get first 10 YTUsers
     * const yTUsers = await prisma.yTUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const yTUserWithIdOnly = await prisma.yTUser.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends YTUserFindManyArgs>(
      args?: SelectSubset<T, YTUserFindManyArgs>
    ): Prisma.PrismaPromise<Array<YTUserGetPayload<T>>>

    /**
     * Create a YTUser.
     * @param {YTUserCreateArgs} args - Arguments to create a YTUser.
     * @example
     * // Create one YTUser
     * const YTUser = await prisma.yTUser.create({
     *   data: {
     *     // ... data to create a YTUser
     *   }
     * })
     * 
    **/
    create<T extends YTUserCreateArgs>(
      args: SelectSubset<T, YTUserCreateArgs>
    ): Prisma__YTUserClient<YTUserGetPayload<T>>

    /**
     * Create many YTUsers.
     *     @param {YTUserCreateManyArgs} args - Arguments to create many YTUsers.
     *     @example
     *     // Create many YTUsers
     *     const yTUser = await prisma.yTUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends YTUserCreateManyArgs>(
      args?: SelectSubset<T, YTUserCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a YTUser.
     * @param {YTUserDeleteArgs} args - Arguments to delete one YTUser.
     * @example
     * // Delete one YTUser
     * const YTUser = await prisma.yTUser.delete({
     *   where: {
     *     // ... filter to delete one YTUser
     *   }
     * })
     * 
    **/
    delete<T extends YTUserDeleteArgs>(
      args: SelectSubset<T, YTUserDeleteArgs>
    ): Prisma__YTUserClient<YTUserGetPayload<T>>

    /**
     * Update one YTUser.
     * @param {YTUserUpdateArgs} args - Arguments to update one YTUser.
     * @example
     * // Update one YTUser
     * const yTUser = await prisma.yTUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends YTUserUpdateArgs>(
      args: SelectSubset<T, YTUserUpdateArgs>
    ): Prisma__YTUserClient<YTUserGetPayload<T>>

    /**
     * Delete zero or more YTUsers.
     * @param {YTUserDeleteManyArgs} args - Arguments to filter YTUsers to delete.
     * @example
     * // Delete a few YTUsers
     * const { count } = await prisma.yTUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends YTUserDeleteManyArgs>(
      args?: SelectSubset<T, YTUserDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YTUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YTUsers
     * const yTUser = await prisma.yTUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends YTUserUpdateManyArgs>(
      args: SelectSubset<T, YTUserUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one YTUser.
     * @param {YTUserUpsertArgs} args - Arguments to update or create a YTUser.
     * @example
     * // Update or create a YTUser
     * const yTUser = await prisma.yTUser.upsert({
     *   create: {
     *     // ... data to create a YTUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YTUser we want to update
     *   }
     * })
    **/
    upsert<T extends YTUserUpsertArgs>(
      args: SelectSubset<T, YTUserUpsertArgs>
    ): Prisma__YTUserClient<YTUserGetPayload<T>>

    /**
     * Count the number of YTUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTUserCountArgs} args - Arguments to filter YTUsers to count.
     * @example
     * // Count the number of YTUsers
     * const count = await prisma.yTUser.count({
     *   where: {
     *     // ... the filter for the YTUsers we want to count
     *   }
     * })
    **/
    count<T extends YTUserCountArgs>(
      args?: Subset<T, YTUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YTUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YTUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YTUserAggregateArgs>(args: Subset<T, YTUserAggregateArgs>): Prisma.PrismaPromise<GetYTUserAggregateType<T>>

    /**
     * Group by YTUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YTUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YTUserGroupByArgs['orderBy'] }
        : { orderBy?: YTUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YTUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYTUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for YTUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__YTUserClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    userToChannels<T extends YTUser$userToChannelsArgs= {}>(args?: Subset<T, YTUser$userToChannelsArgs>): Prisma.PrismaPromise<Array<UserToChannelGetPayload<T>>| Null>;

    comments<T extends YTUser$commentsArgs= {}>(args?: Subset<T, YTUser$commentsArgs>): Prisma.PrismaPromise<Array<YTCommentGetPayload<T>>| Null>;

    subscribes<T extends YTUser$subscribesArgs= {}>(args?: Subset<T, YTUser$subscribesArgs>): Prisma.PrismaPromise<Array<YTSubscribeGetPayload<T>>| Null>;

    shares<T extends YTUser$sharesArgs= {}>(args?: Subset<T, YTUser$sharesArgs>): Prisma.PrismaPromise<Array<YTShareGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * YTUser base type for findUnique actions
   */
  export type YTUserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the YTUser
     */
    select?: YTUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTUserInclude | null
    /**
     * Filter, which YTUser to fetch.
     */
    where: YTUserWhereUniqueInput
  }

  /**
   * YTUser findUnique
   */
  export interface YTUserFindUniqueArgs extends YTUserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YTUser findUniqueOrThrow
   */
  export type YTUserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YTUser
     */
    select?: YTUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTUserInclude | null
    /**
     * Filter, which YTUser to fetch.
     */
    where: YTUserWhereUniqueInput
  }


  /**
   * YTUser base type for findFirst actions
   */
  export type YTUserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the YTUser
     */
    select?: YTUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTUserInclude | null
    /**
     * Filter, which YTUser to fetch.
     */
    where?: YTUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YTUsers to fetch.
     */
    orderBy?: Enumerable<YTUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YTUsers.
     */
    cursor?: YTUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YTUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YTUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YTUsers.
     */
    distinct?: Enumerable<YTUserScalarFieldEnum>
  }

  /**
   * YTUser findFirst
   */
  export interface YTUserFindFirstArgs extends YTUserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YTUser findFirstOrThrow
   */
  export type YTUserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YTUser
     */
    select?: YTUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTUserInclude | null
    /**
     * Filter, which YTUser to fetch.
     */
    where?: YTUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YTUsers to fetch.
     */
    orderBy?: Enumerable<YTUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YTUsers.
     */
    cursor?: YTUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YTUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YTUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YTUsers.
     */
    distinct?: Enumerable<YTUserScalarFieldEnum>
  }


  /**
   * YTUser findMany
   */
  export type YTUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the YTUser
     */
    select?: YTUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTUserInclude | null
    /**
     * Filter, which YTUsers to fetch.
     */
    where?: YTUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YTUsers to fetch.
     */
    orderBy?: Enumerable<YTUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YTUsers.
     */
    cursor?: YTUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YTUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YTUsers.
     */
    skip?: number
    distinct?: Enumerable<YTUserScalarFieldEnum>
  }


  /**
   * YTUser create
   */
  export type YTUserCreateArgs = {
    /**
     * Select specific fields to fetch from the YTUser
     */
    select?: YTUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTUserInclude | null
    /**
     * The data needed to create a YTUser.
     */
    data: XOR<YTUserCreateInput, YTUserUncheckedCreateInput>
  }


  /**
   * YTUser createMany
   */
  export type YTUserCreateManyArgs = {
    /**
     * The data used to create many YTUsers.
     */
    data: Enumerable<YTUserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * YTUser update
   */
  export type YTUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the YTUser
     */
    select?: YTUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTUserInclude | null
    /**
     * The data needed to update a YTUser.
     */
    data: XOR<YTUserUpdateInput, YTUserUncheckedUpdateInput>
    /**
     * Choose, which YTUser to update.
     */
    where: YTUserWhereUniqueInput
  }


  /**
   * YTUser updateMany
   */
  export type YTUserUpdateManyArgs = {
    /**
     * The data used to update YTUsers.
     */
    data: XOR<YTUserUpdateManyMutationInput, YTUserUncheckedUpdateManyInput>
    /**
     * Filter which YTUsers to update
     */
    where?: YTUserWhereInput
  }


  /**
   * YTUser upsert
   */
  export type YTUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the YTUser
     */
    select?: YTUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTUserInclude | null
    /**
     * The filter to search for the YTUser to update in case it exists.
     */
    where: YTUserWhereUniqueInput
    /**
     * In case the YTUser found by the `where` argument doesn't exist, create a new YTUser with this data.
     */
    create: XOR<YTUserCreateInput, YTUserUncheckedCreateInput>
    /**
     * In case the YTUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YTUserUpdateInput, YTUserUncheckedUpdateInput>
  }


  /**
   * YTUser delete
   */
  export type YTUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the YTUser
     */
    select?: YTUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTUserInclude | null
    /**
     * Filter which YTUser to delete.
     */
    where: YTUserWhereUniqueInput
  }


  /**
   * YTUser deleteMany
   */
  export type YTUserDeleteManyArgs = {
    /**
     * Filter which YTUsers to delete
     */
    where?: YTUserWhereInput
  }


  /**
   * YTUser.userToChannels
   */
  export type YTUser$userToChannelsArgs = {
    /**
     * Select specific fields to fetch from the UserToChannel
     */
    select?: UserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToChannelInclude | null
    where?: UserToChannelWhereInput
    orderBy?: Enumerable<UserToChannelOrderByWithRelationInput>
    cursor?: UserToChannelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserToChannelScalarFieldEnum>
  }


  /**
   * YTUser.comments
   */
  export type YTUser$commentsArgs = {
    /**
     * Select specific fields to fetch from the YTComment
     */
    select?: YTCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTCommentInclude | null
    where?: YTCommentWhereInput
    orderBy?: Enumerable<YTCommentOrderByWithRelationInput>
    cursor?: YTCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YTCommentScalarFieldEnum>
  }


  /**
   * YTUser.subscribes
   */
  export type YTUser$subscribesArgs = {
    /**
     * Select specific fields to fetch from the YTSubscribe
     */
    select?: YTSubscribeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTSubscribeInclude | null
    where?: YTSubscribeWhereInput
    orderBy?: Enumerable<YTSubscribeOrderByWithRelationInput>
    cursor?: YTSubscribeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YTSubscribeScalarFieldEnum>
  }


  /**
   * YTUser.shares
   */
  export type YTUser$sharesArgs = {
    /**
     * Select specific fields to fetch from the YTShare
     */
    select?: YTShareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTShareInclude | null
    where?: YTShareWhereInput
    orderBy?: Enumerable<YTShareOrderByWithRelationInput>
    cursor?: YTShareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YTShareScalarFieldEnum>
  }


  /**
   * YTUser without action
   */
  export type YTUserArgs = {
    /**
     * Select specific fields to fetch from the YTUser
     */
    select?: YTUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTUserInclude | null
  }



  /**
   * Model YTChannel
   */


  export type AggregateYTChannel = {
    _count: YTChannelCountAggregateOutputType | null
    _avg: YTChannelAvgAggregateOutputType | null
    _sum: YTChannelSumAggregateOutputType | null
    _min: YTChannelMinAggregateOutputType | null
    _max: YTChannelMaxAggregateOutputType | null
  }

  export type YTChannelAvgAggregateOutputType = {
    id: number | null
  }

  export type YTChannelSumAggregateOutputType = {
    id: number | null
  }

  export type YTChannelMinAggregateOutputType = {
    id: number | null
    channelName: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type YTChannelMaxAggregateOutputType = {
    id: number | null
    channelName: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type YTChannelCountAggregateOutputType = {
    id: number
    channelName: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type YTChannelAvgAggregateInputType = {
    id?: true
  }

  export type YTChannelSumAggregateInputType = {
    id?: true
  }

  export type YTChannelMinAggregateInputType = {
    id?: true
    channelName?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type YTChannelMaxAggregateInputType = {
    id?: true
    channelName?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type YTChannelCountAggregateInputType = {
    id?: true
    channelName?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type YTChannelAggregateArgs = {
    /**
     * Filter which YTChannel to aggregate.
     */
    where?: YTChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YTChannels to fetch.
     */
    orderBy?: Enumerable<YTChannelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YTChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YTChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YTChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YTChannels
    **/
    _count?: true | YTChannelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YTChannelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YTChannelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YTChannelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YTChannelMaxAggregateInputType
  }

  export type GetYTChannelAggregateType<T extends YTChannelAggregateArgs> = {
        [P in keyof T & keyof AggregateYTChannel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYTChannel[P]>
      : GetScalarType<T[P], AggregateYTChannel[P]>
  }




  export type YTChannelGroupByArgs = {
    where?: YTChannelWhereInput
    orderBy?: Enumerable<YTChannelOrderByWithAggregationInput>
    by: YTChannelScalarFieldEnum[]
    having?: YTChannelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YTChannelCountAggregateInputType | true
    _avg?: YTChannelAvgAggregateInputType
    _sum?: YTChannelSumAggregateInputType
    _min?: YTChannelMinAggregateInputType
    _max?: YTChannelMaxAggregateInputType
  }


  export type YTChannelGroupByOutputType = {
    id: number
    channelName: string
    description: string
    createdAt: Date
    updatedAt: Date
    _count: YTChannelCountAggregateOutputType | null
    _avg: YTChannelAvgAggregateOutputType | null
    _sum: YTChannelSumAggregateOutputType | null
    _min: YTChannelMinAggregateOutputType | null
    _max: YTChannelMaxAggregateOutputType | null
  }

  type GetYTChannelGroupByPayload<T extends YTChannelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<YTChannelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YTChannelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YTChannelGroupByOutputType[P]>
            : GetScalarType<T[P], YTChannelGroupByOutputType[P]>
        }
      >
    >


  export type YTChannelSelect = {
    id?: boolean
    channelName?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userToChannels?: boolean | YTChannel$userToChannelsArgs
    videos?: boolean | YTChannel$videosArgs
    subscribes?: boolean | YTChannel$subscribesArgs
    _count?: boolean | YTChannelCountOutputTypeArgs
  }


  export type YTChannelInclude = {
    userToChannels?: boolean | YTChannel$userToChannelsArgs
    videos?: boolean | YTChannel$videosArgs
    subscribes?: boolean | YTChannel$subscribesArgs
    _count?: boolean | YTChannelCountOutputTypeArgs
  }

  export type YTChannelGetPayload<S extends boolean | null | undefined | YTChannelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YTChannel :
    S extends undefined ? never :
    S extends { include: any } & (YTChannelArgs | YTChannelFindManyArgs)
    ? YTChannel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'userToChannels' ? Array < UserToChannelGetPayload<S['include'][P]>>  :
        P extends 'videos' ? Array < YTVideoGetPayload<S['include'][P]>>  :
        P extends 'subscribes' ? Array < YTSubscribeGetPayload<S['include'][P]>>  :
        P extends '_count' ? YTChannelCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (YTChannelArgs | YTChannelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'userToChannels' ? Array < UserToChannelGetPayload<S['select'][P]>>  :
        P extends 'videos' ? Array < YTVideoGetPayload<S['select'][P]>>  :
        P extends 'subscribes' ? Array < YTSubscribeGetPayload<S['select'][P]>>  :
        P extends '_count' ? YTChannelCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof YTChannel ? YTChannel[P] : never
  } 
      : YTChannel


  type YTChannelCountArgs = 
    Omit<YTChannelFindManyArgs, 'select' | 'include'> & {
      select?: YTChannelCountAggregateInputType | true
    }

  export interface YTChannelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one YTChannel that matches the filter.
     * @param {YTChannelFindUniqueArgs} args - Arguments to find a YTChannel
     * @example
     * // Get one YTChannel
     * const yTChannel = await prisma.yTChannel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends YTChannelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, YTChannelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'YTChannel'> extends True ? Prisma__YTChannelClient<YTChannelGetPayload<T>> : Prisma__YTChannelClient<YTChannelGetPayload<T> | null, null>

    /**
     * Find one YTChannel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {YTChannelFindUniqueOrThrowArgs} args - Arguments to find a YTChannel
     * @example
     * // Get one YTChannel
     * const yTChannel = await prisma.yTChannel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends YTChannelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, YTChannelFindUniqueOrThrowArgs>
    ): Prisma__YTChannelClient<YTChannelGetPayload<T>>

    /**
     * Find the first YTChannel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTChannelFindFirstArgs} args - Arguments to find a YTChannel
     * @example
     * // Get one YTChannel
     * const yTChannel = await prisma.yTChannel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends YTChannelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, YTChannelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'YTChannel'> extends True ? Prisma__YTChannelClient<YTChannelGetPayload<T>> : Prisma__YTChannelClient<YTChannelGetPayload<T> | null, null>

    /**
     * Find the first YTChannel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTChannelFindFirstOrThrowArgs} args - Arguments to find a YTChannel
     * @example
     * // Get one YTChannel
     * const yTChannel = await prisma.yTChannel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends YTChannelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, YTChannelFindFirstOrThrowArgs>
    ): Prisma__YTChannelClient<YTChannelGetPayload<T>>

    /**
     * Find zero or more YTChannels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTChannelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YTChannels
     * const yTChannels = await prisma.yTChannel.findMany()
     * 
     * // Get first 10 YTChannels
     * const yTChannels = await prisma.yTChannel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const yTChannelWithIdOnly = await prisma.yTChannel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends YTChannelFindManyArgs>(
      args?: SelectSubset<T, YTChannelFindManyArgs>
    ): Prisma.PrismaPromise<Array<YTChannelGetPayload<T>>>

    /**
     * Create a YTChannel.
     * @param {YTChannelCreateArgs} args - Arguments to create a YTChannel.
     * @example
     * // Create one YTChannel
     * const YTChannel = await prisma.yTChannel.create({
     *   data: {
     *     // ... data to create a YTChannel
     *   }
     * })
     * 
    **/
    create<T extends YTChannelCreateArgs>(
      args: SelectSubset<T, YTChannelCreateArgs>
    ): Prisma__YTChannelClient<YTChannelGetPayload<T>>

    /**
     * Create many YTChannels.
     *     @param {YTChannelCreateManyArgs} args - Arguments to create many YTChannels.
     *     @example
     *     // Create many YTChannels
     *     const yTChannel = await prisma.yTChannel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends YTChannelCreateManyArgs>(
      args?: SelectSubset<T, YTChannelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a YTChannel.
     * @param {YTChannelDeleteArgs} args - Arguments to delete one YTChannel.
     * @example
     * // Delete one YTChannel
     * const YTChannel = await prisma.yTChannel.delete({
     *   where: {
     *     // ... filter to delete one YTChannel
     *   }
     * })
     * 
    **/
    delete<T extends YTChannelDeleteArgs>(
      args: SelectSubset<T, YTChannelDeleteArgs>
    ): Prisma__YTChannelClient<YTChannelGetPayload<T>>

    /**
     * Update one YTChannel.
     * @param {YTChannelUpdateArgs} args - Arguments to update one YTChannel.
     * @example
     * // Update one YTChannel
     * const yTChannel = await prisma.yTChannel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends YTChannelUpdateArgs>(
      args: SelectSubset<T, YTChannelUpdateArgs>
    ): Prisma__YTChannelClient<YTChannelGetPayload<T>>

    /**
     * Delete zero or more YTChannels.
     * @param {YTChannelDeleteManyArgs} args - Arguments to filter YTChannels to delete.
     * @example
     * // Delete a few YTChannels
     * const { count } = await prisma.yTChannel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends YTChannelDeleteManyArgs>(
      args?: SelectSubset<T, YTChannelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YTChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTChannelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YTChannels
     * const yTChannel = await prisma.yTChannel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends YTChannelUpdateManyArgs>(
      args: SelectSubset<T, YTChannelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one YTChannel.
     * @param {YTChannelUpsertArgs} args - Arguments to update or create a YTChannel.
     * @example
     * // Update or create a YTChannel
     * const yTChannel = await prisma.yTChannel.upsert({
     *   create: {
     *     // ... data to create a YTChannel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YTChannel we want to update
     *   }
     * })
    **/
    upsert<T extends YTChannelUpsertArgs>(
      args: SelectSubset<T, YTChannelUpsertArgs>
    ): Prisma__YTChannelClient<YTChannelGetPayload<T>>

    /**
     * Count the number of YTChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTChannelCountArgs} args - Arguments to filter YTChannels to count.
     * @example
     * // Count the number of YTChannels
     * const count = await prisma.yTChannel.count({
     *   where: {
     *     // ... the filter for the YTChannels we want to count
     *   }
     * })
    **/
    count<T extends YTChannelCountArgs>(
      args?: Subset<T, YTChannelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YTChannelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YTChannel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTChannelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YTChannelAggregateArgs>(args: Subset<T, YTChannelAggregateArgs>): Prisma.PrismaPromise<GetYTChannelAggregateType<T>>

    /**
     * Group by YTChannel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTChannelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YTChannelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YTChannelGroupByArgs['orderBy'] }
        : { orderBy?: YTChannelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YTChannelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYTChannelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for YTChannel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__YTChannelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    userToChannels<T extends YTChannel$userToChannelsArgs= {}>(args?: Subset<T, YTChannel$userToChannelsArgs>): Prisma.PrismaPromise<Array<UserToChannelGetPayload<T>>| Null>;

    videos<T extends YTChannel$videosArgs= {}>(args?: Subset<T, YTChannel$videosArgs>): Prisma.PrismaPromise<Array<YTVideoGetPayload<T>>| Null>;

    subscribes<T extends YTChannel$subscribesArgs= {}>(args?: Subset<T, YTChannel$subscribesArgs>): Prisma.PrismaPromise<Array<YTSubscribeGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * YTChannel base type for findUnique actions
   */
  export type YTChannelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the YTChannel
     */
    select?: YTChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTChannelInclude | null
    /**
     * Filter, which YTChannel to fetch.
     */
    where: YTChannelWhereUniqueInput
  }

  /**
   * YTChannel findUnique
   */
  export interface YTChannelFindUniqueArgs extends YTChannelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YTChannel findUniqueOrThrow
   */
  export type YTChannelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YTChannel
     */
    select?: YTChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTChannelInclude | null
    /**
     * Filter, which YTChannel to fetch.
     */
    where: YTChannelWhereUniqueInput
  }


  /**
   * YTChannel base type for findFirst actions
   */
  export type YTChannelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the YTChannel
     */
    select?: YTChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTChannelInclude | null
    /**
     * Filter, which YTChannel to fetch.
     */
    where?: YTChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YTChannels to fetch.
     */
    orderBy?: Enumerable<YTChannelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YTChannels.
     */
    cursor?: YTChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YTChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YTChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YTChannels.
     */
    distinct?: Enumerable<YTChannelScalarFieldEnum>
  }

  /**
   * YTChannel findFirst
   */
  export interface YTChannelFindFirstArgs extends YTChannelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YTChannel findFirstOrThrow
   */
  export type YTChannelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YTChannel
     */
    select?: YTChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTChannelInclude | null
    /**
     * Filter, which YTChannel to fetch.
     */
    where?: YTChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YTChannels to fetch.
     */
    orderBy?: Enumerable<YTChannelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YTChannels.
     */
    cursor?: YTChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YTChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YTChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YTChannels.
     */
    distinct?: Enumerable<YTChannelScalarFieldEnum>
  }


  /**
   * YTChannel findMany
   */
  export type YTChannelFindManyArgs = {
    /**
     * Select specific fields to fetch from the YTChannel
     */
    select?: YTChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTChannelInclude | null
    /**
     * Filter, which YTChannels to fetch.
     */
    where?: YTChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YTChannels to fetch.
     */
    orderBy?: Enumerable<YTChannelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YTChannels.
     */
    cursor?: YTChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YTChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YTChannels.
     */
    skip?: number
    distinct?: Enumerable<YTChannelScalarFieldEnum>
  }


  /**
   * YTChannel create
   */
  export type YTChannelCreateArgs = {
    /**
     * Select specific fields to fetch from the YTChannel
     */
    select?: YTChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTChannelInclude | null
    /**
     * The data needed to create a YTChannel.
     */
    data: XOR<YTChannelCreateInput, YTChannelUncheckedCreateInput>
  }


  /**
   * YTChannel createMany
   */
  export type YTChannelCreateManyArgs = {
    /**
     * The data used to create many YTChannels.
     */
    data: Enumerable<YTChannelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * YTChannel update
   */
  export type YTChannelUpdateArgs = {
    /**
     * Select specific fields to fetch from the YTChannel
     */
    select?: YTChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTChannelInclude | null
    /**
     * The data needed to update a YTChannel.
     */
    data: XOR<YTChannelUpdateInput, YTChannelUncheckedUpdateInput>
    /**
     * Choose, which YTChannel to update.
     */
    where: YTChannelWhereUniqueInput
  }


  /**
   * YTChannel updateMany
   */
  export type YTChannelUpdateManyArgs = {
    /**
     * The data used to update YTChannels.
     */
    data: XOR<YTChannelUpdateManyMutationInput, YTChannelUncheckedUpdateManyInput>
    /**
     * Filter which YTChannels to update
     */
    where?: YTChannelWhereInput
  }


  /**
   * YTChannel upsert
   */
  export type YTChannelUpsertArgs = {
    /**
     * Select specific fields to fetch from the YTChannel
     */
    select?: YTChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTChannelInclude | null
    /**
     * The filter to search for the YTChannel to update in case it exists.
     */
    where: YTChannelWhereUniqueInput
    /**
     * In case the YTChannel found by the `where` argument doesn't exist, create a new YTChannel with this data.
     */
    create: XOR<YTChannelCreateInput, YTChannelUncheckedCreateInput>
    /**
     * In case the YTChannel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YTChannelUpdateInput, YTChannelUncheckedUpdateInput>
  }


  /**
   * YTChannel delete
   */
  export type YTChannelDeleteArgs = {
    /**
     * Select specific fields to fetch from the YTChannel
     */
    select?: YTChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTChannelInclude | null
    /**
     * Filter which YTChannel to delete.
     */
    where: YTChannelWhereUniqueInput
  }


  /**
   * YTChannel deleteMany
   */
  export type YTChannelDeleteManyArgs = {
    /**
     * Filter which YTChannels to delete
     */
    where?: YTChannelWhereInput
  }


  /**
   * YTChannel.userToChannels
   */
  export type YTChannel$userToChannelsArgs = {
    /**
     * Select specific fields to fetch from the UserToChannel
     */
    select?: UserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToChannelInclude | null
    where?: UserToChannelWhereInput
    orderBy?: Enumerable<UserToChannelOrderByWithRelationInput>
    cursor?: UserToChannelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserToChannelScalarFieldEnum>
  }


  /**
   * YTChannel.videos
   */
  export type YTChannel$videosArgs = {
    /**
     * Select specific fields to fetch from the YTVideo
     */
    select?: YTVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTVideoInclude | null
    where?: YTVideoWhereInput
    orderBy?: Enumerable<YTVideoOrderByWithRelationInput>
    cursor?: YTVideoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YTVideoScalarFieldEnum>
  }


  /**
   * YTChannel.subscribes
   */
  export type YTChannel$subscribesArgs = {
    /**
     * Select specific fields to fetch from the YTSubscribe
     */
    select?: YTSubscribeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTSubscribeInclude | null
    where?: YTSubscribeWhereInput
    orderBy?: Enumerable<YTSubscribeOrderByWithRelationInput>
    cursor?: YTSubscribeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YTSubscribeScalarFieldEnum>
  }


  /**
   * YTChannel without action
   */
  export type YTChannelArgs = {
    /**
     * Select specific fields to fetch from the YTChannel
     */
    select?: YTChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTChannelInclude | null
  }



  /**
   * Model UserToChannel
   */


  export type AggregateUserToChannel = {
    _count: UserToChannelCountAggregateOutputType | null
    _avg: UserToChannelAvgAggregateOutputType | null
    _sum: UserToChannelSumAggregateOutputType | null
    _min: UserToChannelMinAggregateOutputType | null
    _max: UserToChannelMaxAggregateOutputType | null
  }

  export type UserToChannelAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    channelId: number | null
  }

  export type UserToChannelSumAggregateOutputType = {
    id: number | null
    userId: number | null
    channelId: number | null
  }

  export type UserToChannelMinAggregateOutputType = {
    id: number | null
    userId: number | null
    channelId: number | null
    role: YTRoleEnum | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserToChannelMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    channelId: number | null
    role: YTRoleEnum | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserToChannelCountAggregateOutputType = {
    id: number
    userId: number
    channelId: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserToChannelAvgAggregateInputType = {
    id?: true
    userId?: true
    channelId?: true
  }

  export type UserToChannelSumAggregateInputType = {
    id?: true
    userId?: true
    channelId?: true
  }

  export type UserToChannelMinAggregateInputType = {
    id?: true
    userId?: true
    channelId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserToChannelMaxAggregateInputType = {
    id?: true
    userId?: true
    channelId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserToChannelCountAggregateInputType = {
    id?: true
    userId?: true
    channelId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserToChannelAggregateArgs = {
    /**
     * Filter which UserToChannel to aggregate.
     */
    where?: UserToChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToChannels to fetch.
     */
    orderBy?: Enumerable<UserToChannelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserToChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserToChannels
    **/
    _count?: true | UserToChannelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserToChannelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserToChannelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserToChannelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserToChannelMaxAggregateInputType
  }

  export type GetUserToChannelAggregateType<T extends UserToChannelAggregateArgs> = {
        [P in keyof T & keyof AggregateUserToChannel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserToChannel[P]>
      : GetScalarType<T[P], AggregateUserToChannel[P]>
  }




  export type UserToChannelGroupByArgs = {
    where?: UserToChannelWhereInput
    orderBy?: Enumerable<UserToChannelOrderByWithAggregationInput>
    by: UserToChannelScalarFieldEnum[]
    having?: UserToChannelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserToChannelCountAggregateInputType | true
    _avg?: UserToChannelAvgAggregateInputType
    _sum?: UserToChannelSumAggregateInputType
    _min?: UserToChannelMinAggregateInputType
    _max?: UserToChannelMaxAggregateInputType
  }


  export type UserToChannelGroupByOutputType = {
    id: number
    userId: number
    channelId: number
    role: YTRoleEnum
    createdAt: Date
    updatedAt: Date
    _count: UserToChannelCountAggregateOutputType | null
    _avg: UserToChannelAvgAggregateOutputType | null
    _sum: UserToChannelSumAggregateOutputType | null
    _min: UserToChannelMinAggregateOutputType | null
    _max: UserToChannelMaxAggregateOutputType | null
  }

  type GetUserToChannelGroupByPayload<T extends UserToChannelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserToChannelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserToChannelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserToChannelGroupByOutputType[P]>
            : GetScalarType<T[P], UserToChannelGroupByOutputType[P]>
        }
      >
    >


  export type UserToChannelSelect = {
    id?: boolean
    user?: boolean | YTUserArgs
    userId?: boolean
    channel?: boolean | YTChannelArgs
    channelId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type UserToChannelInclude = {
    user?: boolean | YTUserArgs
    channel?: boolean | YTChannelArgs
  }

  export type UserToChannelGetPayload<S extends boolean | null | undefined | UserToChannelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserToChannel :
    S extends undefined ? never :
    S extends { include: any } & (UserToChannelArgs | UserToChannelFindManyArgs)
    ? UserToChannel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? YTUserGetPayload<S['include'][P]> :
        P extends 'channel' ? YTChannelGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserToChannelArgs | UserToChannelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? YTUserGetPayload<S['select'][P]> :
        P extends 'channel' ? YTChannelGetPayload<S['select'][P]> :  P extends keyof UserToChannel ? UserToChannel[P] : never
  } 
      : UserToChannel


  type UserToChannelCountArgs = 
    Omit<UserToChannelFindManyArgs, 'select' | 'include'> & {
      select?: UserToChannelCountAggregateInputType | true
    }

  export interface UserToChannelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one UserToChannel that matches the filter.
     * @param {UserToChannelFindUniqueArgs} args - Arguments to find a UserToChannel
     * @example
     * // Get one UserToChannel
     * const userToChannel = await prisma.userToChannel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserToChannelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserToChannelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserToChannel'> extends True ? Prisma__UserToChannelClient<UserToChannelGetPayload<T>> : Prisma__UserToChannelClient<UserToChannelGetPayload<T> | null, null>

    /**
     * Find one UserToChannel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserToChannelFindUniqueOrThrowArgs} args - Arguments to find a UserToChannel
     * @example
     * // Get one UserToChannel
     * const userToChannel = await prisma.userToChannel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserToChannelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserToChannelFindUniqueOrThrowArgs>
    ): Prisma__UserToChannelClient<UserToChannelGetPayload<T>>

    /**
     * Find the first UserToChannel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToChannelFindFirstArgs} args - Arguments to find a UserToChannel
     * @example
     * // Get one UserToChannel
     * const userToChannel = await prisma.userToChannel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserToChannelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserToChannelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserToChannel'> extends True ? Prisma__UserToChannelClient<UserToChannelGetPayload<T>> : Prisma__UserToChannelClient<UserToChannelGetPayload<T> | null, null>

    /**
     * Find the first UserToChannel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToChannelFindFirstOrThrowArgs} args - Arguments to find a UserToChannel
     * @example
     * // Get one UserToChannel
     * const userToChannel = await prisma.userToChannel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserToChannelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserToChannelFindFirstOrThrowArgs>
    ): Prisma__UserToChannelClient<UserToChannelGetPayload<T>>

    /**
     * Find zero or more UserToChannels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToChannelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserToChannels
     * const userToChannels = await prisma.userToChannel.findMany()
     * 
     * // Get first 10 UserToChannels
     * const userToChannels = await prisma.userToChannel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userToChannelWithIdOnly = await prisma.userToChannel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserToChannelFindManyArgs>(
      args?: SelectSubset<T, UserToChannelFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserToChannelGetPayload<T>>>

    /**
     * Create a UserToChannel.
     * @param {UserToChannelCreateArgs} args - Arguments to create a UserToChannel.
     * @example
     * // Create one UserToChannel
     * const UserToChannel = await prisma.userToChannel.create({
     *   data: {
     *     // ... data to create a UserToChannel
     *   }
     * })
     * 
    **/
    create<T extends UserToChannelCreateArgs>(
      args: SelectSubset<T, UserToChannelCreateArgs>
    ): Prisma__UserToChannelClient<UserToChannelGetPayload<T>>

    /**
     * Create many UserToChannels.
     *     @param {UserToChannelCreateManyArgs} args - Arguments to create many UserToChannels.
     *     @example
     *     // Create many UserToChannels
     *     const userToChannel = await prisma.userToChannel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserToChannelCreateManyArgs>(
      args?: SelectSubset<T, UserToChannelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserToChannel.
     * @param {UserToChannelDeleteArgs} args - Arguments to delete one UserToChannel.
     * @example
     * // Delete one UserToChannel
     * const UserToChannel = await prisma.userToChannel.delete({
     *   where: {
     *     // ... filter to delete one UserToChannel
     *   }
     * })
     * 
    **/
    delete<T extends UserToChannelDeleteArgs>(
      args: SelectSubset<T, UserToChannelDeleteArgs>
    ): Prisma__UserToChannelClient<UserToChannelGetPayload<T>>

    /**
     * Update one UserToChannel.
     * @param {UserToChannelUpdateArgs} args - Arguments to update one UserToChannel.
     * @example
     * // Update one UserToChannel
     * const userToChannel = await prisma.userToChannel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserToChannelUpdateArgs>(
      args: SelectSubset<T, UserToChannelUpdateArgs>
    ): Prisma__UserToChannelClient<UserToChannelGetPayload<T>>

    /**
     * Delete zero or more UserToChannels.
     * @param {UserToChannelDeleteManyArgs} args - Arguments to filter UserToChannels to delete.
     * @example
     * // Delete a few UserToChannels
     * const { count } = await prisma.userToChannel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserToChannelDeleteManyArgs>(
      args?: SelectSubset<T, UserToChannelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserToChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToChannelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserToChannels
     * const userToChannel = await prisma.userToChannel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserToChannelUpdateManyArgs>(
      args: SelectSubset<T, UserToChannelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserToChannel.
     * @param {UserToChannelUpsertArgs} args - Arguments to update or create a UserToChannel.
     * @example
     * // Update or create a UserToChannel
     * const userToChannel = await prisma.userToChannel.upsert({
     *   create: {
     *     // ... data to create a UserToChannel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserToChannel we want to update
     *   }
     * })
    **/
    upsert<T extends UserToChannelUpsertArgs>(
      args: SelectSubset<T, UserToChannelUpsertArgs>
    ): Prisma__UserToChannelClient<UserToChannelGetPayload<T>>

    /**
     * Count the number of UserToChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToChannelCountArgs} args - Arguments to filter UserToChannels to count.
     * @example
     * // Count the number of UserToChannels
     * const count = await prisma.userToChannel.count({
     *   where: {
     *     // ... the filter for the UserToChannels we want to count
     *   }
     * })
    **/
    count<T extends UserToChannelCountArgs>(
      args?: Subset<T, UserToChannelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserToChannelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserToChannel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToChannelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserToChannelAggregateArgs>(args: Subset<T, UserToChannelAggregateArgs>): Prisma.PrismaPromise<GetUserToChannelAggregateType<T>>

    /**
     * Group by UserToChannel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToChannelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserToChannelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserToChannelGroupByArgs['orderBy'] }
        : { orderBy?: UserToChannelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserToChannelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserToChannelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserToChannel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserToChannelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends YTUserArgs= {}>(args?: Subset<T, YTUserArgs>): Prisma__YTUserClient<YTUserGetPayload<T> | Null>;

    channel<T extends YTChannelArgs= {}>(args?: Subset<T, YTChannelArgs>): Prisma__YTChannelClient<YTChannelGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserToChannel base type for findUnique actions
   */
  export type UserToChannelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the UserToChannel
     */
    select?: UserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToChannelInclude | null
    /**
     * Filter, which UserToChannel to fetch.
     */
    where: UserToChannelWhereUniqueInput
  }

  /**
   * UserToChannel findUnique
   */
  export interface UserToChannelFindUniqueArgs extends UserToChannelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserToChannel findUniqueOrThrow
   */
  export type UserToChannelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserToChannel
     */
    select?: UserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToChannelInclude | null
    /**
     * Filter, which UserToChannel to fetch.
     */
    where: UserToChannelWhereUniqueInput
  }


  /**
   * UserToChannel base type for findFirst actions
   */
  export type UserToChannelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the UserToChannel
     */
    select?: UserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToChannelInclude | null
    /**
     * Filter, which UserToChannel to fetch.
     */
    where?: UserToChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToChannels to fetch.
     */
    orderBy?: Enumerable<UserToChannelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserToChannels.
     */
    cursor?: UserToChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserToChannels.
     */
    distinct?: Enumerable<UserToChannelScalarFieldEnum>
  }

  /**
   * UserToChannel findFirst
   */
  export interface UserToChannelFindFirstArgs extends UserToChannelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserToChannel findFirstOrThrow
   */
  export type UserToChannelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserToChannel
     */
    select?: UserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToChannelInclude | null
    /**
     * Filter, which UserToChannel to fetch.
     */
    where?: UserToChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToChannels to fetch.
     */
    orderBy?: Enumerable<UserToChannelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserToChannels.
     */
    cursor?: UserToChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserToChannels.
     */
    distinct?: Enumerable<UserToChannelScalarFieldEnum>
  }


  /**
   * UserToChannel findMany
   */
  export type UserToChannelFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserToChannel
     */
    select?: UserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToChannelInclude | null
    /**
     * Filter, which UserToChannels to fetch.
     */
    where?: UserToChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToChannels to fetch.
     */
    orderBy?: Enumerable<UserToChannelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserToChannels.
     */
    cursor?: UserToChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToChannels.
     */
    skip?: number
    distinct?: Enumerable<UserToChannelScalarFieldEnum>
  }


  /**
   * UserToChannel create
   */
  export type UserToChannelCreateArgs = {
    /**
     * Select specific fields to fetch from the UserToChannel
     */
    select?: UserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToChannelInclude | null
    /**
     * The data needed to create a UserToChannel.
     */
    data: XOR<UserToChannelCreateInput, UserToChannelUncheckedCreateInput>
  }


  /**
   * UserToChannel createMany
   */
  export type UserToChannelCreateManyArgs = {
    /**
     * The data used to create many UserToChannels.
     */
    data: Enumerable<UserToChannelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserToChannel update
   */
  export type UserToChannelUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserToChannel
     */
    select?: UserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToChannelInclude | null
    /**
     * The data needed to update a UserToChannel.
     */
    data: XOR<UserToChannelUpdateInput, UserToChannelUncheckedUpdateInput>
    /**
     * Choose, which UserToChannel to update.
     */
    where: UserToChannelWhereUniqueInput
  }


  /**
   * UserToChannel updateMany
   */
  export type UserToChannelUpdateManyArgs = {
    /**
     * The data used to update UserToChannels.
     */
    data: XOR<UserToChannelUpdateManyMutationInput, UserToChannelUncheckedUpdateManyInput>
    /**
     * Filter which UserToChannels to update
     */
    where?: UserToChannelWhereInput
  }


  /**
   * UserToChannel upsert
   */
  export type UserToChannelUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserToChannel
     */
    select?: UserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToChannelInclude | null
    /**
     * The filter to search for the UserToChannel to update in case it exists.
     */
    where: UserToChannelWhereUniqueInput
    /**
     * In case the UserToChannel found by the `where` argument doesn't exist, create a new UserToChannel with this data.
     */
    create: XOR<UserToChannelCreateInput, UserToChannelUncheckedCreateInput>
    /**
     * In case the UserToChannel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserToChannelUpdateInput, UserToChannelUncheckedUpdateInput>
  }


  /**
   * UserToChannel delete
   */
  export type UserToChannelDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserToChannel
     */
    select?: UserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToChannelInclude | null
    /**
     * Filter which UserToChannel to delete.
     */
    where: UserToChannelWhereUniqueInput
  }


  /**
   * UserToChannel deleteMany
   */
  export type UserToChannelDeleteManyArgs = {
    /**
     * Filter which UserToChannels to delete
     */
    where?: UserToChannelWhereInput
  }


  /**
   * UserToChannel without action
   */
  export type UserToChannelArgs = {
    /**
     * Select specific fields to fetch from the UserToChannel
     */
    select?: UserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserToChannelInclude | null
  }



  /**
   * Model YTVideo
   */


  export type AggregateYTVideo = {
    _count: YTVideoCountAggregateOutputType | null
    _avg: YTVideoAvgAggregateOutputType | null
    _sum: YTVideoSumAggregateOutputType | null
    _min: YTVideoMinAggregateOutputType | null
    _max: YTVideoMaxAggregateOutputType | null
  }

  export type YTVideoAvgAggregateOutputType = {
    id: number | null
    channelId: number | null
  }

  export type YTVideoSumAggregateOutputType = {
    id: number | null
    channelId: number | null
  }

  export type YTVideoMinAggregateOutputType = {
    id: number | null
    name: string | null
    file: string | null
    logo: string | null
    createdAt: Date | null
    updatedAt: Date | null
    channelId: number | null
  }

  export type YTVideoMaxAggregateOutputType = {
    id: number | null
    name: string | null
    file: string | null
    logo: string | null
    createdAt: Date | null
    updatedAt: Date | null
    channelId: number | null
  }

  export type YTVideoCountAggregateOutputType = {
    id: number
    name: number
    file: number
    logo: number
    createdAt: number
    updatedAt: number
    channelId: number
    _all: number
  }


  export type YTVideoAvgAggregateInputType = {
    id?: true
    channelId?: true
  }

  export type YTVideoSumAggregateInputType = {
    id?: true
    channelId?: true
  }

  export type YTVideoMinAggregateInputType = {
    id?: true
    name?: true
    file?: true
    logo?: true
    createdAt?: true
    updatedAt?: true
    channelId?: true
  }

  export type YTVideoMaxAggregateInputType = {
    id?: true
    name?: true
    file?: true
    logo?: true
    createdAt?: true
    updatedAt?: true
    channelId?: true
  }

  export type YTVideoCountAggregateInputType = {
    id?: true
    name?: true
    file?: true
    logo?: true
    createdAt?: true
    updatedAt?: true
    channelId?: true
    _all?: true
  }

  export type YTVideoAggregateArgs = {
    /**
     * Filter which YTVideo to aggregate.
     */
    where?: YTVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YTVideos to fetch.
     */
    orderBy?: Enumerable<YTVideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YTVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YTVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YTVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YTVideos
    **/
    _count?: true | YTVideoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YTVideoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YTVideoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YTVideoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YTVideoMaxAggregateInputType
  }

  export type GetYTVideoAggregateType<T extends YTVideoAggregateArgs> = {
        [P in keyof T & keyof AggregateYTVideo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYTVideo[P]>
      : GetScalarType<T[P], AggregateYTVideo[P]>
  }




  export type YTVideoGroupByArgs = {
    where?: YTVideoWhereInput
    orderBy?: Enumerable<YTVideoOrderByWithAggregationInput>
    by: YTVideoScalarFieldEnum[]
    having?: YTVideoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YTVideoCountAggregateInputType | true
    _avg?: YTVideoAvgAggregateInputType
    _sum?: YTVideoSumAggregateInputType
    _min?: YTVideoMinAggregateInputType
    _max?: YTVideoMaxAggregateInputType
  }


  export type YTVideoGroupByOutputType = {
    id: number
    name: string
    file: string
    logo: string
    createdAt: Date
    updatedAt: Date
    channelId: number
    _count: YTVideoCountAggregateOutputType | null
    _avg: YTVideoAvgAggregateOutputType | null
    _sum: YTVideoSumAggregateOutputType | null
    _min: YTVideoMinAggregateOutputType | null
    _max: YTVideoMaxAggregateOutputType | null
  }

  type GetYTVideoGroupByPayload<T extends YTVideoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<YTVideoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YTVideoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YTVideoGroupByOutputType[P]>
            : GetScalarType<T[P], YTVideoGroupByOutputType[P]>
        }
      >
    >


  export type YTVideoSelect = {
    id?: boolean
    name?: boolean
    file?: boolean
    logo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    channel?: boolean | YTChannelArgs
    channelId?: boolean
    likes?: boolean | YTVideo$likesArgs
    comments?: boolean | YTVideo$commentsArgs
    shares?: boolean | YTVideo$sharesArgs
    _count?: boolean | YTVideoCountOutputTypeArgs
  }


  export type YTVideoInclude = {
    channel?: boolean | YTChannelArgs
    likes?: boolean | YTVideo$likesArgs
    comments?: boolean | YTVideo$commentsArgs
    shares?: boolean | YTVideo$sharesArgs
    _count?: boolean | YTVideoCountOutputTypeArgs
  }

  export type YTVideoGetPayload<S extends boolean | null | undefined | YTVideoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YTVideo :
    S extends undefined ? never :
    S extends { include: any } & (YTVideoArgs | YTVideoFindManyArgs)
    ? YTVideo  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'channel' ? YTChannelGetPayload<S['include'][P]> :
        P extends 'likes' ? Array < YTLikeGetPayload<S['include'][P]>>  :
        P extends 'comments' ? Array < YTCommentGetPayload<S['include'][P]>>  :
        P extends 'shares' ? Array < YTShareGetPayload<S['include'][P]>>  :
        P extends '_count' ? YTVideoCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (YTVideoArgs | YTVideoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'channel' ? YTChannelGetPayload<S['select'][P]> :
        P extends 'likes' ? Array < YTLikeGetPayload<S['select'][P]>>  :
        P extends 'comments' ? Array < YTCommentGetPayload<S['select'][P]>>  :
        P extends 'shares' ? Array < YTShareGetPayload<S['select'][P]>>  :
        P extends '_count' ? YTVideoCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof YTVideo ? YTVideo[P] : never
  } 
      : YTVideo


  type YTVideoCountArgs = 
    Omit<YTVideoFindManyArgs, 'select' | 'include'> & {
      select?: YTVideoCountAggregateInputType | true
    }

  export interface YTVideoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one YTVideo that matches the filter.
     * @param {YTVideoFindUniqueArgs} args - Arguments to find a YTVideo
     * @example
     * // Get one YTVideo
     * const yTVideo = await prisma.yTVideo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends YTVideoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, YTVideoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'YTVideo'> extends True ? Prisma__YTVideoClient<YTVideoGetPayload<T>> : Prisma__YTVideoClient<YTVideoGetPayload<T> | null, null>

    /**
     * Find one YTVideo that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {YTVideoFindUniqueOrThrowArgs} args - Arguments to find a YTVideo
     * @example
     * // Get one YTVideo
     * const yTVideo = await prisma.yTVideo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends YTVideoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, YTVideoFindUniqueOrThrowArgs>
    ): Prisma__YTVideoClient<YTVideoGetPayload<T>>

    /**
     * Find the first YTVideo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTVideoFindFirstArgs} args - Arguments to find a YTVideo
     * @example
     * // Get one YTVideo
     * const yTVideo = await prisma.yTVideo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends YTVideoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, YTVideoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'YTVideo'> extends True ? Prisma__YTVideoClient<YTVideoGetPayload<T>> : Prisma__YTVideoClient<YTVideoGetPayload<T> | null, null>

    /**
     * Find the first YTVideo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTVideoFindFirstOrThrowArgs} args - Arguments to find a YTVideo
     * @example
     * // Get one YTVideo
     * const yTVideo = await prisma.yTVideo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends YTVideoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, YTVideoFindFirstOrThrowArgs>
    ): Prisma__YTVideoClient<YTVideoGetPayload<T>>

    /**
     * Find zero or more YTVideos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTVideoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YTVideos
     * const yTVideos = await prisma.yTVideo.findMany()
     * 
     * // Get first 10 YTVideos
     * const yTVideos = await prisma.yTVideo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const yTVideoWithIdOnly = await prisma.yTVideo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends YTVideoFindManyArgs>(
      args?: SelectSubset<T, YTVideoFindManyArgs>
    ): Prisma.PrismaPromise<Array<YTVideoGetPayload<T>>>

    /**
     * Create a YTVideo.
     * @param {YTVideoCreateArgs} args - Arguments to create a YTVideo.
     * @example
     * // Create one YTVideo
     * const YTVideo = await prisma.yTVideo.create({
     *   data: {
     *     // ... data to create a YTVideo
     *   }
     * })
     * 
    **/
    create<T extends YTVideoCreateArgs>(
      args: SelectSubset<T, YTVideoCreateArgs>
    ): Prisma__YTVideoClient<YTVideoGetPayload<T>>

    /**
     * Create many YTVideos.
     *     @param {YTVideoCreateManyArgs} args - Arguments to create many YTVideos.
     *     @example
     *     // Create many YTVideos
     *     const yTVideo = await prisma.yTVideo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends YTVideoCreateManyArgs>(
      args?: SelectSubset<T, YTVideoCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a YTVideo.
     * @param {YTVideoDeleteArgs} args - Arguments to delete one YTVideo.
     * @example
     * // Delete one YTVideo
     * const YTVideo = await prisma.yTVideo.delete({
     *   where: {
     *     // ... filter to delete one YTVideo
     *   }
     * })
     * 
    **/
    delete<T extends YTVideoDeleteArgs>(
      args: SelectSubset<T, YTVideoDeleteArgs>
    ): Prisma__YTVideoClient<YTVideoGetPayload<T>>

    /**
     * Update one YTVideo.
     * @param {YTVideoUpdateArgs} args - Arguments to update one YTVideo.
     * @example
     * // Update one YTVideo
     * const yTVideo = await prisma.yTVideo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends YTVideoUpdateArgs>(
      args: SelectSubset<T, YTVideoUpdateArgs>
    ): Prisma__YTVideoClient<YTVideoGetPayload<T>>

    /**
     * Delete zero or more YTVideos.
     * @param {YTVideoDeleteManyArgs} args - Arguments to filter YTVideos to delete.
     * @example
     * // Delete a few YTVideos
     * const { count } = await prisma.yTVideo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends YTVideoDeleteManyArgs>(
      args?: SelectSubset<T, YTVideoDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YTVideos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTVideoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YTVideos
     * const yTVideo = await prisma.yTVideo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends YTVideoUpdateManyArgs>(
      args: SelectSubset<T, YTVideoUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one YTVideo.
     * @param {YTVideoUpsertArgs} args - Arguments to update or create a YTVideo.
     * @example
     * // Update or create a YTVideo
     * const yTVideo = await prisma.yTVideo.upsert({
     *   create: {
     *     // ... data to create a YTVideo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YTVideo we want to update
     *   }
     * })
    **/
    upsert<T extends YTVideoUpsertArgs>(
      args: SelectSubset<T, YTVideoUpsertArgs>
    ): Prisma__YTVideoClient<YTVideoGetPayload<T>>

    /**
     * Count the number of YTVideos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTVideoCountArgs} args - Arguments to filter YTVideos to count.
     * @example
     * // Count the number of YTVideos
     * const count = await prisma.yTVideo.count({
     *   where: {
     *     // ... the filter for the YTVideos we want to count
     *   }
     * })
    **/
    count<T extends YTVideoCountArgs>(
      args?: Subset<T, YTVideoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YTVideoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YTVideo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTVideoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YTVideoAggregateArgs>(args: Subset<T, YTVideoAggregateArgs>): Prisma.PrismaPromise<GetYTVideoAggregateType<T>>

    /**
     * Group by YTVideo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTVideoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YTVideoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YTVideoGroupByArgs['orderBy'] }
        : { orderBy?: YTVideoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YTVideoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYTVideoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for YTVideo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__YTVideoClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    channel<T extends YTChannelArgs= {}>(args?: Subset<T, YTChannelArgs>): Prisma__YTChannelClient<YTChannelGetPayload<T> | Null>;

    likes<T extends YTVideo$likesArgs= {}>(args?: Subset<T, YTVideo$likesArgs>): Prisma.PrismaPromise<Array<YTLikeGetPayload<T>>| Null>;

    comments<T extends YTVideo$commentsArgs= {}>(args?: Subset<T, YTVideo$commentsArgs>): Prisma.PrismaPromise<Array<YTCommentGetPayload<T>>| Null>;

    shares<T extends YTVideo$sharesArgs= {}>(args?: Subset<T, YTVideo$sharesArgs>): Prisma.PrismaPromise<Array<YTShareGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * YTVideo base type for findUnique actions
   */
  export type YTVideoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the YTVideo
     */
    select?: YTVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTVideoInclude | null
    /**
     * Filter, which YTVideo to fetch.
     */
    where: YTVideoWhereUniqueInput
  }

  /**
   * YTVideo findUnique
   */
  export interface YTVideoFindUniqueArgs extends YTVideoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YTVideo findUniqueOrThrow
   */
  export type YTVideoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YTVideo
     */
    select?: YTVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTVideoInclude | null
    /**
     * Filter, which YTVideo to fetch.
     */
    where: YTVideoWhereUniqueInput
  }


  /**
   * YTVideo base type for findFirst actions
   */
  export type YTVideoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the YTVideo
     */
    select?: YTVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTVideoInclude | null
    /**
     * Filter, which YTVideo to fetch.
     */
    where?: YTVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YTVideos to fetch.
     */
    orderBy?: Enumerable<YTVideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YTVideos.
     */
    cursor?: YTVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YTVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YTVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YTVideos.
     */
    distinct?: Enumerable<YTVideoScalarFieldEnum>
  }

  /**
   * YTVideo findFirst
   */
  export interface YTVideoFindFirstArgs extends YTVideoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YTVideo findFirstOrThrow
   */
  export type YTVideoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YTVideo
     */
    select?: YTVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTVideoInclude | null
    /**
     * Filter, which YTVideo to fetch.
     */
    where?: YTVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YTVideos to fetch.
     */
    orderBy?: Enumerable<YTVideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YTVideos.
     */
    cursor?: YTVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YTVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YTVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YTVideos.
     */
    distinct?: Enumerable<YTVideoScalarFieldEnum>
  }


  /**
   * YTVideo findMany
   */
  export type YTVideoFindManyArgs = {
    /**
     * Select specific fields to fetch from the YTVideo
     */
    select?: YTVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTVideoInclude | null
    /**
     * Filter, which YTVideos to fetch.
     */
    where?: YTVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YTVideos to fetch.
     */
    orderBy?: Enumerable<YTVideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YTVideos.
     */
    cursor?: YTVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YTVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YTVideos.
     */
    skip?: number
    distinct?: Enumerable<YTVideoScalarFieldEnum>
  }


  /**
   * YTVideo create
   */
  export type YTVideoCreateArgs = {
    /**
     * Select specific fields to fetch from the YTVideo
     */
    select?: YTVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTVideoInclude | null
    /**
     * The data needed to create a YTVideo.
     */
    data: XOR<YTVideoCreateInput, YTVideoUncheckedCreateInput>
  }


  /**
   * YTVideo createMany
   */
  export type YTVideoCreateManyArgs = {
    /**
     * The data used to create many YTVideos.
     */
    data: Enumerable<YTVideoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * YTVideo update
   */
  export type YTVideoUpdateArgs = {
    /**
     * Select specific fields to fetch from the YTVideo
     */
    select?: YTVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTVideoInclude | null
    /**
     * The data needed to update a YTVideo.
     */
    data: XOR<YTVideoUpdateInput, YTVideoUncheckedUpdateInput>
    /**
     * Choose, which YTVideo to update.
     */
    where: YTVideoWhereUniqueInput
  }


  /**
   * YTVideo updateMany
   */
  export type YTVideoUpdateManyArgs = {
    /**
     * The data used to update YTVideos.
     */
    data: XOR<YTVideoUpdateManyMutationInput, YTVideoUncheckedUpdateManyInput>
    /**
     * Filter which YTVideos to update
     */
    where?: YTVideoWhereInput
  }


  /**
   * YTVideo upsert
   */
  export type YTVideoUpsertArgs = {
    /**
     * Select specific fields to fetch from the YTVideo
     */
    select?: YTVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTVideoInclude | null
    /**
     * The filter to search for the YTVideo to update in case it exists.
     */
    where: YTVideoWhereUniqueInput
    /**
     * In case the YTVideo found by the `where` argument doesn't exist, create a new YTVideo with this data.
     */
    create: XOR<YTVideoCreateInput, YTVideoUncheckedCreateInput>
    /**
     * In case the YTVideo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YTVideoUpdateInput, YTVideoUncheckedUpdateInput>
  }


  /**
   * YTVideo delete
   */
  export type YTVideoDeleteArgs = {
    /**
     * Select specific fields to fetch from the YTVideo
     */
    select?: YTVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTVideoInclude | null
    /**
     * Filter which YTVideo to delete.
     */
    where: YTVideoWhereUniqueInput
  }


  /**
   * YTVideo deleteMany
   */
  export type YTVideoDeleteManyArgs = {
    /**
     * Filter which YTVideos to delete
     */
    where?: YTVideoWhereInput
  }


  /**
   * YTVideo.likes
   */
  export type YTVideo$likesArgs = {
    /**
     * Select specific fields to fetch from the YTLike
     */
    select?: YTLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTLikeInclude | null
    where?: YTLikeWhereInput
    orderBy?: Enumerable<YTLikeOrderByWithRelationInput>
    cursor?: YTLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YTLikeScalarFieldEnum>
  }


  /**
   * YTVideo.comments
   */
  export type YTVideo$commentsArgs = {
    /**
     * Select specific fields to fetch from the YTComment
     */
    select?: YTCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTCommentInclude | null
    where?: YTCommentWhereInput
    orderBy?: Enumerable<YTCommentOrderByWithRelationInput>
    cursor?: YTCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YTCommentScalarFieldEnum>
  }


  /**
   * YTVideo.shares
   */
  export type YTVideo$sharesArgs = {
    /**
     * Select specific fields to fetch from the YTShare
     */
    select?: YTShareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTShareInclude | null
    where?: YTShareWhereInput
    orderBy?: Enumerable<YTShareOrderByWithRelationInput>
    cursor?: YTShareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YTShareScalarFieldEnum>
  }


  /**
   * YTVideo without action
   */
  export type YTVideoArgs = {
    /**
     * Select specific fields to fetch from the YTVideo
     */
    select?: YTVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTVideoInclude | null
  }



  /**
   * Model YTLike
   */


  export type AggregateYTLike = {
    _count: YTLikeCountAggregateOutputType | null
    _avg: YTLikeAvgAggregateOutputType | null
    _sum: YTLikeSumAggregateOutputType | null
    _min: YTLikeMinAggregateOutputType | null
    _max: YTLikeMaxAggregateOutputType | null
  }

  export type YTLikeAvgAggregateOutputType = {
    id: number | null
    videoId: number | null
    commentId: number | null
  }

  export type YTLikeSumAggregateOutputType = {
    id: number | null
    videoId: number | null
    commentId: number | null
  }

  export type YTLikeMinAggregateOutputType = {
    id: number | null
    type: string | null
    videoId: number | null
    commentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type YTLikeMaxAggregateOutputType = {
    id: number | null
    type: string | null
    videoId: number | null
    commentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type YTLikeCountAggregateOutputType = {
    id: number
    type: number
    videoId: number
    commentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type YTLikeAvgAggregateInputType = {
    id?: true
    videoId?: true
    commentId?: true
  }

  export type YTLikeSumAggregateInputType = {
    id?: true
    videoId?: true
    commentId?: true
  }

  export type YTLikeMinAggregateInputType = {
    id?: true
    type?: true
    videoId?: true
    commentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type YTLikeMaxAggregateInputType = {
    id?: true
    type?: true
    videoId?: true
    commentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type YTLikeCountAggregateInputType = {
    id?: true
    type?: true
    videoId?: true
    commentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type YTLikeAggregateArgs = {
    /**
     * Filter which YTLike to aggregate.
     */
    where?: YTLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YTLikes to fetch.
     */
    orderBy?: Enumerable<YTLikeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YTLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YTLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YTLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YTLikes
    **/
    _count?: true | YTLikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YTLikeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YTLikeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YTLikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YTLikeMaxAggregateInputType
  }

  export type GetYTLikeAggregateType<T extends YTLikeAggregateArgs> = {
        [P in keyof T & keyof AggregateYTLike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYTLike[P]>
      : GetScalarType<T[P], AggregateYTLike[P]>
  }




  export type YTLikeGroupByArgs = {
    where?: YTLikeWhereInput
    orderBy?: Enumerable<YTLikeOrderByWithAggregationInput>
    by: YTLikeScalarFieldEnum[]
    having?: YTLikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YTLikeCountAggregateInputType | true
    _avg?: YTLikeAvgAggregateInputType
    _sum?: YTLikeSumAggregateInputType
    _min?: YTLikeMinAggregateInputType
    _max?: YTLikeMaxAggregateInputType
  }


  export type YTLikeGroupByOutputType = {
    id: number
    type: string
    videoId: number
    commentId: number
    createdAt: Date
    updatedAt: Date
    _count: YTLikeCountAggregateOutputType | null
    _avg: YTLikeAvgAggregateOutputType | null
    _sum: YTLikeSumAggregateOutputType | null
    _min: YTLikeMinAggregateOutputType | null
    _max: YTLikeMaxAggregateOutputType | null
  }

  type GetYTLikeGroupByPayload<T extends YTLikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<YTLikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YTLikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YTLikeGroupByOutputType[P]>
            : GetScalarType<T[P], YTLikeGroupByOutputType[P]>
        }
      >
    >


  export type YTLikeSelect = {
    id?: boolean
    type?: boolean
    video?: boolean | YTVideoArgs
    videoId?: boolean
    comment?: boolean | YTCommentArgs
    commentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type YTLikeInclude = {
    video?: boolean | YTVideoArgs
    comment?: boolean | YTCommentArgs
  }

  export type YTLikeGetPayload<S extends boolean | null | undefined | YTLikeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YTLike :
    S extends undefined ? never :
    S extends { include: any } & (YTLikeArgs | YTLikeFindManyArgs)
    ? YTLike  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'video' ? YTVideoGetPayload<S['include'][P]> :
        P extends 'comment' ? YTCommentGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (YTLikeArgs | YTLikeFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'video' ? YTVideoGetPayload<S['select'][P]> :
        P extends 'comment' ? YTCommentGetPayload<S['select'][P]> :  P extends keyof YTLike ? YTLike[P] : never
  } 
      : YTLike


  type YTLikeCountArgs = 
    Omit<YTLikeFindManyArgs, 'select' | 'include'> & {
      select?: YTLikeCountAggregateInputType | true
    }

  export interface YTLikeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one YTLike that matches the filter.
     * @param {YTLikeFindUniqueArgs} args - Arguments to find a YTLike
     * @example
     * // Get one YTLike
     * const yTLike = await prisma.yTLike.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends YTLikeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, YTLikeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'YTLike'> extends True ? Prisma__YTLikeClient<YTLikeGetPayload<T>> : Prisma__YTLikeClient<YTLikeGetPayload<T> | null, null>

    /**
     * Find one YTLike that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {YTLikeFindUniqueOrThrowArgs} args - Arguments to find a YTLike
     * @example
     * // Get one YTLike
     * const yTLike = await prisma.yTLike.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends YTLikeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, YTLikeFindUniqueOrThrowArgs>
    ): Prisma__YTLikeClient<YTLikeGetPayload<T>>

    /**
     * Find the first YTLike that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTLikeFindFirstArgs} args - Arguments to find a YTLike
     * @example
     * // Get one YTLike
     * const yTLike = await prisma.yTLike.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends YTLikeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, YTLikeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'YTLike'> extends True ? Prisma__YTLikeClient<YTLikeGetPayload<T>> : Prisma__YTLikeClient<YTLikeGetPayload<T> | null, null>

    /**
     * Find the first YTLike that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTLikeFindFirstOrThrowArgs} args - Arguments to find a YTLike
     * @example
     * // Get one YTLike
     * const yTLike = await prisma.yTLike.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends YTLikeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, YTLikeFindFirstOrThrowArgs>
    ): Prisma__YTLikeClient<YTLikeGetPayload<T>>

    /**
     * Find zero or more YTLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTLikeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YTLikes
     * const yTLikes = await prisma.yTLike.findMany()
     * 
     * // Get first 10 YTLikes
     * const yTLikes = await prisma.yTLike.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const yTLikeWithIdOnly = await prisma.yTLike.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends YTLikeFindManyArgs>(
      args?: SelectSubset<T, YTLikeFindManyArgs>
    ): Prisma.PrismaPromise<Array<YTLikeGetPayload<T>>>

    /**
     * Create a YTLike.
     * @param {YTLikeCreateArgs} args - Arguments to create a YTLike.
     * @example
     * // Create one YTLike
     * const YTLike = await prisma.yTLike.create({
     *   data: {
     *     // ... data to create a YTLike
     *   }
     * })
     * 
    **/
    create<T extends YTLikeCreateArgs>(
      args: SelectSubset<T, YTLikeCreateArgs>
    ): Prisma__YTLikeClient<YTLikeGetPayload<T>>

    /**
     * Create many YTLikes.
     *     @param {YTLikeCreateManyArgs} args - Arguments to create many YTLikes.
     *     @example
     *     // Create many YTLikes
     *     const yTLike = await prisma.yTLike.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends YTLikeCreateManyArgs>(
      args?: SelectSubset<T, YTLikeCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a YTLike.
     * @param {YTLikeDeleteArgs} args - Arguments to delete one YTLike.
     * @example
     * // Delete one YTLike
     * const YTLike = await prisma.yTLike.delete({
     *   where: {
     *     // ... filter to delete one YTLike
     *   }
     * })
     * 
    **/
    delete<T extends YTLikeDeleteArgs>(
      args: SelectSubset<T, YTLikeDeleteArgs>
    ): Prisma__YTLikeClient<YTLikeGetPayload<T>>

    /**
     * Update one YTLike.
     * @param {YTLikeUpdateArgs} args - Arguments to update one YTLike.
     * @example
     * // Update one YTLike
     * const yTLike = await prisma.yTLike.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends YTLikeUpdateArgs>(
      args: SelectSubset<T, YTLikeUpdateArgs>
    ): Prisma__YTLikeClient<YTLikeGetPayload<T>>

    /**
     * Delete zero or more YTLikes.
     * @param {YTLikeDeleteManyArgs} args - Arguments to filter YTLikes to delete.
     * @example
     * // Delete a few YTLikes
     * const { count } = await prisma.yTLike.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends YTLikeDeleteManyArgs>(
      args?: SelectSubset<T, YTLikeDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YTLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTLikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YTLikes
     * const yTLike = await prisma.yTLike.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends YTLikeUpdateManyArgs>(
      args: SelectSubset<T, YTLikeUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one YTLike.
     * @param {YTLikeUpsertArgs} args - Arguments to update or create a YTLike.
     * @example
     * // Update or create a YTLike
     * const yTLike = await prisma.yTLike.upsert({
     *   create: {
     *     // ... data to create a YTLike
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YTLike we want to update
     *   }
     * })
    **/
    upsert<T extends YTLikeUpsertArgs>(
      args: SelectSubset<T, YTLikeUpsertArgs>
    ): Prisma__YTLikeClient<YTLikeGetPayload<T>>

    /**
     * Count the number of YTLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTLikeCountArgs} args - Arguments to filter YTLikes to count.
     * @example
     * // Count the number of YTLikes
     * const count = await prisma.yTLike.count({
     *   where: {
     *     // ... the filter for the YTLikes we want to count
     *   }
     * })
    **/
    count<T extends YTLikeCountArgs>(
      args?: Subset<T, YTLikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YTLikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YTLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTLikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YTLikeAggregateArgs>(args: Subset<T, YTLikeAggregateArgs>): Prisma.PrismaPromise<GetYTLikeAggregateType<T>>

    /**
     * Group by YTLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTLikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YTLikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YTLikeGroupByArgs['orderBy'] }
        : { orderBy?: YTLikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YTLikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYTLikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for YTLike.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__YTLikeClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    video<T extends YTVideoArgs= {}>(args?: Subset<T, YTVideoArgs>): Prisma__YTVideoClient<YTVideoGetPayload<T> | Null>;

    comment<T extends YTCommentArgs= {}>(args?: Subset<T, YTCommentArgs>): Prisma__YTCommentClient<YTCommentGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * YTLike base type for findUnique actions
   */
  export type YTLikeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the YTLike
     */
    select?: YTLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTLikeInclude | null
    /**
     * Filter, which YTLike to fetch.
     */
    where: YTLikeWhereUniqueInput
  }

  /**
   * YTLike findUnique
   */
  export interface YTLikeFindUniqueArgs extends YTLikeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YTLike findUniqueOrThrow
   */
  export type YTLikeFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YTLike
     */
    select?: YTLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTLikeInclude | null
    /**
     * Filter, which YTLike to fetch.
     */
    where: YTLikeWhereUniqueInput
  }


  /**
   * YTLike base type for findFirst actions
   */
  export type YTLikeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the YTLike
     */
    select?: YTLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTLikeInclude | null
    /**
     * Filter, which YTLike to fetch.
     */
    where?: YTLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YTLikes to fetch.
     */
    orderBy?: Enumerable<YTLikeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YTLikes.
     */
    cursor?: YTLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YTLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YTLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YTLikes.
     */
    distinct?: Enumerable<YTLikeScalarFieldEnum>
  }

  /**
   * YTLike findFirst
   */
  export interface YTLikeFindFirstArgs extends YTLikeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YTLike findFirstOrThrow
   */
  export type YTLikeFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YTLike
     */
    select?: YTLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTLikeInclude | null
    /**
     * Filter, which YTLike to fetch.
     */
    where?: YTLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YTLikes to fetch.
     */
    orderBy?: Enumerable<YTLikeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YTLikes.
     */
    cursor?: YTLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YTLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YTLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YTLikes.
     */
    distinct?: Enumerable<YTLikeScalarFieldEnum>
  }


  /**
   * YTLike findMany
   */
  export type YTLikeFindManyArgs = {
    /**
     * Select specific fields to fetch from the YTLike
     */
    select?: YTLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTLikeInclude | null
    /**
     * Filter, which YTLikes to fetch.
     */
    where?: YTLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YTLikes to fetch.
     */
    orderBy?: Enumerable<YTLikeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YTLikes.
     */
    cursor?: YTLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YTLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YTLikes.
     */
    skip?: number
    distinct?: Enumerable<YTLikeScalarFieldEnum>
  }


  /**
   * YTLike create
   */
  export type YTLikeCreateArgs = {
    /**
     * Select specific fields to fetch from the YTLike
     */
    select?: YTLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTLikeInclude | null
    /**
     * The data needed to create a YTLike.
     */
    data: XOR<YTLikeCreateInput, YTLikeUncheckedCreateInput>
  }


  /**
   * YTLike createMany
   */
  export type YTLikeCreateManyArgs = {
    /**
     * The data used to create many YTLikes.
     */
    data: Enumerable<YTLikeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * YTLike update
   */
  export type YTLikeUpdateArgs = {
    /**
     * Select specific fields to fetch from the YTLike
     */
    select?: YTLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTLikeInclude | null
    /**
     * The data needed to update a YTLike.
     */
    data: XOR<YTLikeUpdateInput, YTLikeUncheckedUpdateInput>
    /**
     * Choose, which YTLike to update.
     */
    where: YTLikeWhereUniqueInput
  }


  /**
   * YTLike updateMany
   */
  export type YTLikeUpdateManyArgs = {
    /**
     * The data used to update YTLikes.
     */
    data: XOR<YTLikeUpdateManyMutationInput, YTLikeUncheckedUpdateManyInput>
    /**
     * Filter which YTLikes to update
     */
    where?: YTLikeWhereInput
  }


  /**
   * YTLike upsert
   */
  export type YTLikeUpsertArgs = {
    /**
     * Select specific fields to fetch from the YTLike
     */
    select?: YTLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTLikeInclude | null
    /**
     * The filter to search for the YTLike to update in case it exists.
     */
    where: YTLikeWhereUniqueInput
    /**
     * In case the YTLike found by the `where` argument doesn't exist, create a new YTLike with this data.
     */
    create: XOR<YTLikeCreateInput, YTLikeUncheckedCreateInput>
    /**
     * In case the YTLike was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YTLikeUpdateInput, YTLikeUncheckedUpdateInput>
  }


  /**
   * YTLike delete
   */
  export type YTLikeDeleteArgs = {
    /**
     * Select specific fields to fetch from the YTLike
     */
    select?: YTLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTLikeInclude | null
    /**
     * Filter which YTLike to delete.
     */
    where: YTLikeWhereUniqueInput
  }


  /**
   * YTLike deleteMany
   */
  export type YTLikeDeleteManyArgs = {
    /**
     * Filter which YTLikes to delete
     */
    where?: YTLikeWhereInput
  }


  /**
   * YTLike without action
   */
  export type YTLikeArgs = {
    /**
     * Select specific fields to fetch from the YTLike
     */
    select?: YTLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTLikeInclude | null
  }



  /**
   * Model YTComment
   */


  export type AggregateYTComment = {
    _count: YTCommentCountAggregateOutputType | null
    _avg: YTCommentAvgAggregateOutputType | null
    _sum: YTCommentSumAggregateOutputType | null
    _min: YTCommentMinAggregateOutputType | null
    _max: YTCommentMaxAggregateOutputType | null
  }

  export type YTCommentAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    commentTo: number | null
    videoId: number | null
  }

  export type YTCommentSumAggregateOutputType = {
    id: number | null
    userId: number | null
    commentTo: number | null
    videoId: number | null
  }

  export type YTCommentMinAggregateOutputType = {
    id: number | null
    text: string | null
    userId: number | null
    commentTo: number | null
    videoId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type YTCommentMaxAggregateOutputType = {
    id: number | null
    text: string | null
    userId: number | null
    commentTo: number | null
    videoId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type YTCommentCountAggregateOutputType = {
    id: number
    text: number
    userId: number
    commentTo: number
    videoId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type YTCommentAvgAggregateInputType = {
    id?: true
    userId?: true
    commentTo?: true
    videoId?: true
  }

  export type YTCommentSumAggregateInputType = {
    id?: true
    userId?: true
    commentTo?: true
    videoId?: true
  }

  export type YTCommentMinAggregateInputType = {
    id?: true
    text?: true
    userId?: true
    commentTo?: true
    videoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type YTCommentMaxAggregateInputType = {
    id?: true
    text?: true
    userId?: true
    commentTo?: true
    videoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type YTCommentCountAggregateInputType = {
    id?: true
    text?: true
    userId?: true
    commentTo?: true
    videoId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type YTCommentAggregateArgs = {
    /**
     * Filter which YTComment to aggregate.
     */
    where?: YTCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YTComments to fetch.
     */
    orderBy?: Enumerable<YTCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YTCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YTComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YTComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YTComments
    **/
    _count?: true | YTCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YTCommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YTCommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YTCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YTCommentMaxAggregateInputType
  }

  export type GetYTCommentAggregateType<T extends YTCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateYTComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYTComment[P]>
      : GetScalarType<T[P], AggregateYTComment[P]>
  }




  export type YTCommentGroupByArgs = {
    where?: YTCommentWhereInput
    orderBy?: Enumerable<YTCommentOrderByWithAggregationInput>
    by: YTCommentScalarFieldEnum[]
    having?: YTCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YTCommentCountAggregateInputType | true
    _avg?: YTCommentAvgAggregateInputType
    _sum?: YTCommentSumAggregateInputType
    _min?: YTCommentMinAggregateInputType
    _max?: YTCommentMaxAggregateInputType
  }


  export type YTCommentGroupByOutputType = {
    id: number
    text: string
    userId: number
    commentTo: number | null
    videoId: number
    createdAt: Date
    updatedAt: Date
    _count: YTCommentCountAggregateOutputType | null
    _avg: YTCommentAvgAggregateOutputType | null
    _sum: YTCommentSumAggregateOutputType | null
    _min: YTCommentMinAggregateOutputType | null
    _max: YTCommentMaxAggregateOutputType | null
  }

  type GetYTCommentGroupByPayload<T extends YTCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<YTCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YTCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YTCommentGroupByOutputType[P]>
            : GetScalarType<T[P], YTCommentGroupByOutputType[P]>
        }
      >
    >


  export type YTCommentSelect = {
    id?: boolean
    text?: boolean
    user?: boolean | YTUserArgs
    userId?: boolean
    commentTo?: boolean
    video?: boolean | YTVideoArgs
    videoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    likes?: boolean | YTComment$likesArgs
    _count?: boolean | YTCommentCountOutputTypeArgs
  }


  export type YTCommentInclude = {
    user?: boolean | YTUserArgs
    video?: boolean | YTVideoArgs
    likes?: boolean | YTComment$likesArgs
    _count?: boolean | YTCommentCountOutputTypeArgs
  }

  export type YTCommentGetPayload<S extends boolean | null | undefined | YTCommentArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YTComment :
    S extends undefined ? never :
    S extends { include: any } & (YTCommentArgs | YTCommentFindManyArgs)
    ? YTComment  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? YTUserGetPayload<S['include'][P]> :
        P extends 'video' ? YTVideoGetPayload<S['include'][P]> :
        P extends 'likes' ? Array < YTLikeGetPayload<S['include'][P]>>  :
        P extends '_count' ? YTCommentCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (YTCommentArgs | YTCommentFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? YTUserGetPayload<S['select'][P]> :
        P extends 'video' ? YTVideoGetPayload<S['select'][P]> :
        P extends 'likes' ? Array < YTLikeGetPayload<S['select'][P]>>  :
        P extends '_count' ? YTCommentCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof YTComment ? YTComment[P] : never
  } 
      : YTComment


  type YTCommentCountArgs = 
    Omit<YTCommentFindManyArgs, 'select' | 'include'> & {
      select?: YTCommentCountAggregateInputType | true
    }

  export interface YTCommentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one YTComment that matches the filter.
     * @param {YTCommentFindUniqueArgs} args - Arguments to find a YTComment
     * @example
     * // Get one YTComment
     * const yTComment = await prisma.yTComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends YTCommentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, YTCommentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'YTComment'> extends True ? Prisma__YTCommentClient<YTCommentGetPayload<T>> : Prisma__YTCommentClient<YTCommentGetPayload<T> | null, null>

    /**
     * Find one YTComment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {YTCommentFindUniqueOrThrowArgs} args - Arguments to find a YTComment
     * @example
     * // Get one YTComment
     * const yTComment = await prisma.yTComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends YTCommentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, YTCommentFindUniqueOrThrowArgs>
    ): Prisma__YTCommentClient<YTCommentGetPayload<T>>

    /**
     * Find the first YTComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTCommentFindFirstArgs} args - Arguments to find a YTComment
     * @example
     * // Get one YTComment
     * const yTComment = await prisma.yTComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends YTCommentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, YTCommentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'YTComment'> extends True ? Prisma__YTCommentClient<YTCommentGetPayload<T>> : Prisma__YTCommentClient<YTCommentGetPayload<T> | null, null>

    /**
     * Find the first YTComment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTCommentFindFirstOrThrowArgs} args - Arguments to find a YTComment
     * @example
     * // Get one YTComment
     * const yTComment = await prisma.yTComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends YTCommentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, YTCommentFindFirstOrThrowArgs>
    ): Prisma__YTCommentClient<YTCommentGetPayload<T>>

    /**
     * Find zero or more YTComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTCommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YTComments
     * const yTComments = await prisma.yTComment.findMany()
     * 
     * // Get first 10 YTComments
     * const yTComments = await prisma.yTComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const yTCommentWithIdOnly = await prisma.yTComment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends YTCommentFindManyArgs>(
      args?: SelectSubset<T, YTCommentFindManyArgs>
    ): Prisma.PrismaPromise<Array<YTCommentGetPayload<T>>>

    /**
     * Create a YTComment.
     * @param {YTCommentCreateArgs} args - Arguments to create a YTComment.
     * @example
     * // Create one YTComment
     * const YTComment = await prisma.yTComment.create({
     *   data: {
     *     // ... data to create a YTComment
     *   }
     * })
     * 
    **/
    create<T extends YTCommentCreateArgs>(
      args: SelectSubset<T, YTCommentCreateArgs>
    ): Prisma__YTCommentClient<YTCommentGetPayload<T>>

    /**
     * Create many YTComments.
     *     @param {YTCommentCreateManyArgs} args - Arguments to create many YTComments.
     *     @example
     *     // Create many YTComments
     *     const yTComment = await prisma.yTComment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends YTCommentCreateManyArgs>(
      args?: SelectSubset<T, YTCommentCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a YTComment.
     * @param {YTCommentDeleteArgs} args - Arguments to delete one YTComment.
     * @example
     * // Delete one YTComment
     * const YTComment = await prisma.yTComment.delete({
     *   where: {
     *     // ... filter to delete one YTComment
     *   }
     * })
     * 
    **/
    delete<T extends YTCommentDeleteArgs>(
      args: SelectSubset<T, YTCommentDeleteArgs>
    ): Prisma__YTCommentClient<YTCommentGetPayload<T>>

    /**
     * Update one YTComment.
     * @param {YTCommentUpdateArgs} args - Arguments to update one YTComment.
     * @example
     * // Update one YTComment
     * const yTComment = await prisma.yTComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends YTCommentUpdateArgs>(
      args: SelectSubset<T, YTCommentUpdateArgs>
    ): Prisma__YTCommentClient<YTCommentGetPayload<T>>

    /**
     * Delete zero or more YTComments.
     * @param {YTCommentDeleteManyArgs} args - Arguments to filter YTComments to delete.
     * @example
     * // Delete a few YTComments
     * const { count } = await prisma.yTComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends YTCommentDeleteManyArgs>(
      args?: SelectSubset<T, YTCommentDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YTComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YTComments
     * const yTComment = await prisma.yTComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends YTCommentUpdateManyArgs>(
      args: SelectSubset<T, YTCommentUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one YTComment.
     * @param {YTCommentUpsertArgs} args - Arguments to update or create a YTComment.
     * @example
     * // Update or create a YTComment
     * const yTComment = await prisma.yTComment.upsert({
     *   create: {
     *     // ... data to create a YTComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YTComment we want to update
     *   }
     * })
    **/
    upsert<T extends YTCommentUpsertArgs>(
      args: SelectSubset<T, YTCommentUpsertArgs>
    ): Prisma__YTCommentClient<YTCommentGetPayload<T>>

    /**
     * Count the number of YTComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTCommentCountArgs} args - Arguments to filter YTComments to count.
     * @example
     * // Count the number of YTComments
     * const count = await prisma.yTComment.count({
     *   where: {
     *     // ... the filter for the YTComments we want to count
     *   }
     * })
    **/
    count<T extends YTCommentCountArgs>(
      args?: Subset<T, YTCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YTCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YTComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YTCommentAggregateArgs>(args: Subset<T, YTCommentAggregateArgs>): Prisma.PrismaPromise<GetYTCommentAggregateType<T>>

    /**
     * Group by YTComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YTCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YTCommentGroupByArgs['orderBy'] }
        : { orderBy?: YTCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YTCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYTCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for YTComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__YTCommentClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends YTUserArgs= {}>(args?: Subset<T, YTUserArgs>): Prisma__YTUserClient<YTUserGetPayload<T> | Null>;

    video<T extends YTVideoArgs= {}>(args?: Subset<T, YTVideoArgs>): Prisma__YTVideoClient<YTVideoGetPayload<T> | Null>;

    likes<T extends YTComment$likesArgs= {}>(args?: Subset<T, YTComment$likesArgs>): Prisma.PrismaPromise<Array<YTLikeGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * YTComment base type for findUnique actions
   */
  export type YTCommentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the YTComment
     */
    select?: YTCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTCommentInclude | null
    /**
     * Filter, which YTComment to fetch.
     */
    where: YTCommentWhereUniqueInput
  }

  /**
   * YTComment findUnique
   */
  export interface YTCommentFindUniqueArgs extends YTCommentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YTComment findUniqueOrThrow
   */
  export type YTCommentFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YTComment
     */
    select?: YTCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTCommentInclude | null
    /**
     * Filter, which YTComment to fetch.
     */
    where: YTCommentWhereUniqueInput
  }


  /**
   * YTComment base type for findFirst actions
   */
  export type YTCommentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the YTComment
     */
    select?: YTCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTCommentInclude | null
    /**
     * Filter, which YTComment to fetch.
     */
    where?: YTCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YTComments to fetch.
     */
    orderBy?: Enumerable<YTCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YTComments.
     */
    cursor?: YTCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YTComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YTComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YTComments.
     */
    distinct?: Enumerable<YTCommentScalarFieldEnum>
  }

  /**
   * YTComment findFirst
   */
  export interface YTCommentFindFirstArgs extends YTCommentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YTComment findFirstOrThrow
   */
  export type YTCommentFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YTComment
     */
    select?: YTCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTCommentInclude | null
    /**
     * Filter, which YTComment to fetch.
     */
    where?: YTCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YTComments to fetch.
     */
    orderBy?: Enumerable<YTCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YTComments.
     */
    cursor?: YTCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YTComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YTComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YTComments.
     */
    distinct?: Enumerable<YTCommentScalarFieldEnum>
  }


  /**
   * YTComment findMany
   */
  export type YTCommentFindManyArgs = {
    /**
     * Select specific fields to fetch from the YTComment
     */
    select?: YTCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTCommentInclude | null
    /**
     * Filter, which YTComments to fetch.
     */
    where?: YTCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YTComments to fetch.
     */
    orderBy?: Enumerable<YTCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YTComments.
     */
    cursor?: YTCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YTComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YTComments.
     */
    skip?: number
    distinct?: Enumerable<YTCommentScalarFieldEnum>
  }


  /**
   * YTComment create
   */
  export type YTCommentCreateArgs = {
    /**
     * Select specific fields to fetch from the YTComment
     */
    select?: YTCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTCommentInclude | null
    /**
     * The data needed to create a YTComment.
     */
    data: XOR<YTCommentCreateInput, YTCommentUncheckedCreateInput>
  }


  /**
   * YTComment createMany
   */
  export type YTCommentCreateManyArgs = {
    /**
     * The data used to create many YTComments.
     */
    data: Enumerable<YTCommentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * YTComment update
   */
  export type YTCommentUpdateArgs = {
    /**
     * Select specific fields to fetch from the YTComment
     */
    select?: YTCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTCommentInclude | null
    /**
     * The data needed to update a YTComment.
     */
    data: XOR<YTCommentUpdateInput, YTCommentUncheckedUpdateInput>
    /**
     * Choose, which YTComment to update.
     */
    where: YTCommentWhereUniqueInput
  }


  /**
   * YTComment updateMany
   */
  export type YTCommentUpdateManyArgs = {
    /**
     * The data used to update YTComments.
     */
    data: XOR<YTCommentUpdateManyMutationInput, YTCommentUncheckedUpdateManyInput>
    /**
     * Filter which YTComments to update
     */
    where?: YTCommentWhereInput
  }


  /**
   * YTComment upsert
   */
  export type YTCommentUpsertArgs = {
    /**
     * Select specific fields to fetch from the YTComment
     */
    select?: YTCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTCommentInclude | null
    /**
     * The filter to search for the YTComment to update in case it exists.
     */
    where: YTCommentWhereUniqueInput
    /**
     * In case the YTComment found by the `where` argument doesn't exist, create a new YTComment with this data.
     */
    create: XOR<YTCommentCreateInput, YTCommentUncheckedCreateInput>
    /**
     * In case the YTComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YTCommentUpdateInput, YTCommentUncheckedUpdateInput>
  }


  /**
   * YTComment delete
   */
  export type YTCommentDeleteArgs = {
    /**
     * Select specific fields to fetch from the YTComment
     */
    select?: YTCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTCommentInclude | null
    /**
     * Filter which YTComment to delete.
     */
    where: YTCommentWhereUniqueInput
  }


  /**
   * YTComment deleteMany
   */
  export type YTCommentDeleteManyArgs = {
    /**
     * Filter which YTComments to delete
     */
    where?: YTCommentWhereInput
  }


  /**
   * YTComment.likes
   */
  export type YTComment$likesArgs = {
    /**
     * Select specific fields to fetch from the YTLike
     */
    select?: YTLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTLikeInclude | null
    where?: YTLikeWhereInput
    orderBy?: Enumerable<YTLikeOrderByWithRelationInput>
    cursor?: YTLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YTLikeScalarFieldEnum>
  }


  /**
   * YTComment without action
   */
  export type YTCommentArgs = {
    /**
     * Select specific fields to fetch from the YTComment
     */
    select?: YTCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTCommentInclude | null
  }



  /**
   * Model YTSubscribe
   */


  export type AggregateYTSubscribe = {
    _count: YTSubscribeCountAggregateOutputType | null
    _avg: YTSubscribeAvgAggregateOutputType | null
    _sum: YTSubscribeSumAggregateOutputType | null
    _min: YTSubscribeMinAggregateOutputType | null
    _max: YTSubscribeMaxAggregateOutputType | null
  }

  export type YTSubscribeAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    channelId: number | null
  }

  export type YTSubscribeSumAggregateOutputType = {
    id: number | null
    userId: number | null
    channelId: number | null
  }

  export type YTSubscribeMinAggregateOutputType = {
    id: number | null
    userId: number | null
    channelId: number | null
    member: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type YTSubscribeMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    channelId: number | null
    member: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type YTSubscribeCountAggregateOutputType = {
    id: number
    userId: number
    channelId: number
    member: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type YTSubscribeAvgAggregateInputType = {
    id?: true
    userId?: true
    channelId?: true
  }

  export type YTSubscribeSumAggregateInputType = {
    id?: true
    userId?: true
    channelId?: true
  }

  export type YTSubscribeMinAggregateInputType = {
    id?: true
    userId?: true
    channelId?: true
    member?: true
    createdAt?: true
    updatedAt?: true
  }

  export type YTSubscribeMaxAggregateInputType = {
    id?: true
    userId?: true
    channelId?: true
    member?: true
    createdAt?: true
    updatedAt?: true
  }

  export type YTSubscribeCountAggregateInputType = {
    id?: true
    userId?: true
    channelId?: true
    member?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type YTSubscribeAggregateArgs = {
    /**
     * Filter which YTSubscribe to aggregate.
     */
    where?: YTSubscribeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YTSubscribes to fetch.
     */
    orderBy?: Enumerable<YTSubscribeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YTSubscribeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YTSubscribes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YTSubscribes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YTSubscribes
    **/
    _count?: true | YTSubscribeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YTSubscribeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YTSubscribeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YTSubscribeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YTSubscribeMaxAggregateInputType
  }

  export type GetYTSubscribeAggregateType<T extends YTSubscribeAggregateArgs> = {
        [P in keyof T & keyof AggregateYTSubscribe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYTSubscribe[P]>
      : GetScalarType<T[P], AggregateYTSubscribe[P]>
  }




  export type YTSubscribeGroupByArgs = {
    where?: YTSubscribeWhereInput
    orderBy?: Enumerable<YTSubscribeOrderByWithAggregationInput>
    by: YTSubscribeScalarFieldEnum[]
    having?: YTSubscribeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YTSubscribeCountAggregateInputType | true
    _avg?: YTSubscribeAvgAggregateInputType
    _sum?: YTSubscribeSumAggregateInputType
    _min?: YTSubscribeMinAggregateInputType
    _max?: YTSubscribeMaxAggregateInputType
  }


  export type YTSubscribeGroupByOutputType = {
    id: number
    userId: number
    channelId: number
    member: boolean
    createdAt: Date
    updatedAt: Date
    _count: YTSubscribeCountAggregateOutputType | null
    _avg: YTSubscribeAvgAggregateOutputType | null
    _sum: YTSubscribeSumAggregateOutputType | null
    _min: YTSubscribeMinAggregateOutputType | null
    _max: YTSubscribeMaxAggregateOutputType | null
  }

  type GetYTSubscribeGroupByPayload<T extends YTSubscribeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<YTSubscribeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YTSubscribeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YTSubscribeGroupByOutputType[P]>
            : GetScalarType<T[P], YTSubscribeGroupByOutputType[P]>
        }
      >
    >


  export type YTSubscribeSelect = {
    id?: boolean
    user?: boolean | YTUserArgs
    userId?: boolean
    channel?: boolean | YTChannelArgs
    channelId?: boolean
    member?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type YTSubscribeInclude = {
    user?: boolean | YTUserArgs
    channel?: boolean | YTChannelArgs
  }

  export type YTSubscribeGetPayload<S extends boolean | null | undefined | YTSubscribeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YTSubscribe :
    S extends undefined ? never :
    S extends { include: any } & (YTSubscribeArgs | YTSubscribeFindManyArgs)
    ? YTSubscribe  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? YTUserGetPayload<S['include'][P]> :
        P extends 'channel' ? YTChannelGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (YTSubscribeArgs | YTSubscribeFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? YTUserGetPayload<S['select'][P]> :
        P extends 'channel' ? YTChannelGetPayload<S['select'][P]> :  P extends keyof YTSubscribe ? YTSubscribe[P] : never
  } 
      : YTSubscribe


  type YTSubscribeCountArgs = 
    Omit<YTSubscribeFindManyArgs, 'select' | 'include'> & {
      select?: YTSubscribeCountAggregateInputType | true
    }

  export interface YTSubscribeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one YTSubscribe that matches the filter.
     * @param {YTSubscribeFindUniqueArgs} args - Arguments to find a YTSubscribe
     * @example
     * // Get one YTSubscribe
     * const yTSubscribe = await prisma.yTSubscribe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends YTSubscribeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, YTSubscribeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'YTSubscribe'> extends True ? Prisma__YTSubscribeClient<YTSubscribeGetPayload<T>> : Prisma__YTSubscribeClient<YTSubscribeGetPayload<T> | null, null>

    /**
     * Find one YTSubscribe that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {YTSubscribeFindUniqueOrThrowArgs} args - Arguments to find a YTSubscribe
     * @example
     * // Get one YTSubscribe
     * const yTSubscribe = await prisma.yTSubscribe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends YTSubscribeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, YTSubscribeFindUniqueOrThrowArgs>
    ): Prisma__YTSubscribeClient<YTSubscribeGetPayload<T>>

    /**
     * Find the first YTSubscribe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTSubscribeFindFirstArgs} args - Arguments to find a YTSubscribe
     * @example
     * // Get one YTSubscribe
     * const yTSubscribe = await prisma.yTSubscribe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends YTSubscribeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, YTSubscribeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'YTSubscribe'> extends True ? Prisma__YTSubscribeClient<YTSubscribeGetPayload<T>> : Prisma__YTSubscribeClient<YTSubscribeGetPayload<T> | null, null>

    /**
     * Find the first YTSubscribe that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTSubscribeFindFirstOrThrowArgs} args - Arguments to find a YTSubscribe
     * @example
     * // Get one YTSubscribe
     * const yTSubscribe = await prisma.yTSubscribe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends YTSubscribeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, YTSubscribeFindFirstOrThrowArgs>
    ): Prisma__YTSubscribeClient<YTSubscribeGetPayload<T>>

    /**
     * Find zero or more YTSubscribes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTSubscribeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YTSubscribes
     * const yTSubscribes = await prisma.yTSubscribe.findMany()
     * 
     * // Get first 10 YTSubscribes
     * const yTSubscribes = await prisma.yTSubscribe.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const yTSubscribeWithIdOnly = await prisma.yTSubscribe.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends YTSubscribeFindManyArgs>(
      args?: SelectSubset<T, YTSubscribeFindManyArgs>
    ): Prisma.PrismaPromise<Array<YTSubscribeGetPayload<T>>>

    /**
     * Create a YTSubscribe.
     * @param {YTSubscribeCreateArgs} args - Arguments to create a YTSubscribe.
     * @example
     * // Create one YTSubscribe
     * const YTSubscribe = await prisma.yTSubscribe.create({
     *   data: {
     *     // ... data to create a YTSubscribe
     *   }
     * })
     * 
    **/
    create<T extends YTSubscribeCreateArgs>(
      args: SelectSubset<T, YTSubscribeCreateArgs>
    ): Prisma__YTSubscribeClient<YTSubscribeGetPayload<T>>

    /**
     * Create many YTSubscribes.
     *     @param {YTSubscribeCreateManyArgs} args - Arguments to create many YTSubscribes.
     *     @example
     *     // Create many YTSubscribes
     *     const yTSubscribe = await prisma.yTSubscribe.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends YTSubscribeCreateManyArgs>(
      args?: SelectSubset<T, YTSubscribeCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a YTSubscribe.
     * @param {YTSubscribeDeleteArgs} args - Arguments to delete one YTSubscribe.
     * @example
     * // Delete one YTSubscribe
     * const YTSubscribe = await prisma.yTSubscribe.delete({
     *   where: {
     *     // ... filter to delete one YTSubscribe
     *   }
     * })
     * 
    **/
    delete<T extends YTSubscribeDeleteArgs>(
      args: SelectSubset<T, YTSubscribeDeleteArgs>
    ): Prisma__YTSubscribeClient<YTSubscribeGetPayload<T>>

    /**
     * Update one YTSubscribe.
     * @param {YTSubscribeUpdateArgs} args - Arguments to update one YTSubscribe.
     * @example
     * // Update one YTSubscribe
     * const yTSubscribe = await prisma.yTSubscribe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends YTSubscribeUpdateArgs>(
      args: SelectSubset<T, YTSubscribeUpdateArgs>
    ): Prisma__YTSubscribeClient<YTSubscribeGetPayload<T>>

    /**
     * Delete zero or more YTSubscribes.
     * @param {YTSubscribeDeleteManyArgs} args - Arguments to filter YTSubscribes to delete.
     * @example
     * // Delete a few YTSubscribes
     * const { count } = await prisma.yTSubscribe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends YTSubscribeDeleteManyArgs>(
      args?: SelectSubset<T, YTSubscribeDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YTSubscribes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTSubscribeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YTSubscribes
     * const yTSubscribe = await prisma.yTSubscribe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends YTSubscribeUpdateManyArgs>(
      args: SelectSubset<T, YTSubscribeUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one YTSubscribe.
     * @param {YTSubscribeUpsertArgs} args - Arguments to update or create a YTSubscribe.
     * @example
     * // Update or create a YTSubscribe
     * const yTSubscribe = await prisma.yTSubscribe.upsert({
     *   create: {
     *     // ... data to create a YTSubscribe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YTSubscribe we want to update
     *   }
     * })
    **/
    upsert<T extends YTSubscribeUpsertArgs>(
      args: SelectSubset<T, YTSubscribeUpsertArgs>
    ): Prisma__YTSubscribeClient<YTSubscribeGetPayload<T>>

    /**
     * Count the number of YTSubscribes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTSubscribeCountArgs} args - Arguments to filter YTSubscribes to count.
     * @example
     * // Count the number of YTSubscribes
     * const count = await prisma.yTSubscribe.count({
     *   where: {
     *     // ... the filter for the YTSubscribes we want to count
     *   }
     * })
    **/
    count<T extends YTSubscribeCountArgs>(
      args?: Subset<T, YTSubscribeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YTSubscribeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YTSubscribe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTSubscribeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YTSubscribeAggregateArgs>(args: Subset<T, YTSubscribeAggregateArgs>): Prisma.PrismaPromise<GetYTSubscribeAggregateType<T>>

    /**
     * Group by YTSubscribe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTSubscribeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YTSubscribeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YTSubscribeGroupByArgs['orderBy'] }
        : { orderBy?: YTSubscribeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YTSubscribeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYTSubscribeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for YTSubscribe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__YTSubscribeClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends YTUserArgs= {}>(args?: Subset<T, YTUserArgs>): Prisma__YTUserClient<YTUserGetPayload<T> | Null>;

    channel<T extends YTChannelArgs= {}>(args?: Subset<T, YTChannelArgs>): Prisma__YTChannelClient<YTChannelGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * YTSubscribe base type for findUnique actions
   */
  export type YTSubscribeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the YTSubscribe
     */
    select?: YTSubscribeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTSubscribeInclude | null
    /**
     * Filter, which YTSubscribe to fetch.
     */
    where: YTSubscribeWhereUniqueInput
  }

  /**
   * YTSubscribe findUnique
   */
  export interface YTSubscribeFindUniqueArgs extends YTSubscribeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YTSubscribe findUniqueOrThrow
   */
  export type YTSubscribeFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YTSubscribe
     */
    select?: YTSubscribeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTSubscribeInclude | null
    /**
     * Filter, which YTSubscribe to fetch.
     */
    where: YTSubscribeWhereUniqueInput
  }


  /**
   * YTSubscribe base type for findFirst actions
   */
  export type YTSubscribeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the YTSubscribe
     */
    select?: YTSubscribeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTSubscribeInclude | null
    /**
     * Filter, which YTSubscribe to fetch.
     */
    where?: YTSubscribeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YTSubscribes to fetch.
     */
    orderBy?: Enumerable<YTSubscribeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YTSubscribes.
     */
    cursor?: YTSubscribeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YTSubscribes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YTSubscribes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YTSubscribes.
     */
    distinct?: Enumerable<YTSubscribeScalarFieldEnum>
  }

  /**
   * YTSubscribe findFirst
   */
  export interface YTSubscribeFindFirstArgs extends YTSubscribeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YTSubscribe findFirstOrThrow
   */
  export type YTSubscribeFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YTSubscribe
     */
    select?: YTSubscribeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTSubscribeInclude | null
    /**
     * Filter, which YTSubscribe to fetch.
     */
    where?: YTSubscribeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YTSubscribes to fetch.
     */
    orderBy?: Enumerable<YTSubscribeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YTSubscribes.
     */
    cursor?: YTSubscribeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YTSubscribes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YTSubscribes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YTSubscribes.
     */
    distinct?: Enumerable<YTSubscribeScalarFieldEnum>
  }


  /**
   * YTSubscribe findMany
   */
  export type YTSubscribeFindManyArgs = {
    /**
     * Select specific fields to fetch from the YTSubscribe
     */
    select?: YTSubscribeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTSubscribeInclude | null
    /**
     * Filter, which YTSubscribes to fetch.
     */
    where?: YTSubscribeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YTSubscribes to fetch.
     */
    orderBy?: Enumerable<YTSubscribeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YTSubscribes.
     */
    cursor?: YTSubscribeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YTSubscribes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YTSubscribes.
     */
    skip?: number
    distinct?: Enumerable<YTSubscribeScalarFieldEnum>
  }


  /**
   * YTSubscribe create
   */
  export type YTSubscribeCreateArgs = {
    /**
     * Select specific fields to fetch from the YTSubscribe
     */
    select?: YTSubscribeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTSubscribeInclude | null
    /**
     * The data needed to create a YTSubscribe.
     */
    data: XOR<YTSubscribeCreateInput, YTSubscribeUncheckedCreateInput>
  }


  /**
   * YTSubscribe createMany
   */
  export type YTSubscribeCreateManyArgs = {
    /**
     * The data used to create many YTSubscribes.
     */
    data: Enumerable<YTSubscribeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * YTSubscribe update
   */
  export type YTSubscribeUpdateArgs = {
    /**
     * Select specific fields to fetch from the YTSubscribe
     */
    select?: YTSubscribeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTSubscribeInclude | null
    /**
     * The data needed to update a YTSubscribe.
     */
    data: XOR<YTSubscribeUpdateInput, YTSubscribeUncheckedUpdateInput>
    /**
     * Choose, which YTSubscribe to update.
     */
    where: YTSubscribeWhereUniqueInput
  }


  /**
   * YTSubscribe updateMany
   */
  export type YTSubscribeUpdateManyArgs = {
    /**
     * The data used to update YTSubscribes.
     */
    data: XOR<YTSubscribeUpdateManyMutationInput, YTSubscribeUncheckedUpdateManyInput>
    /**
     * Filter which YTSubscribes to update
     */
    where?: YTSubscribeWhereInput
  }


  /**
   * YTSubscribe upsert
   */
  export type YTSubscribeUpsertArgs = {
    /**
     * Select specific fields to fetch from the YTSubscribe
     */
    select?: YTSubscribeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTSubscribeInclude | null
    /**
     * The filter to search for the YTSubscribe to update in case it exists.
     */
    where: YTSubscribeWhereUniqueInput
    /**
     * In case the YTSubscribe found by the `where` argument doesn't exist, create a new YTSubscribe with this data.
     */
    create: XOR<YTSubscribeCreateInput, YTSubscribeUncheckedCreateInput>
    /**
     * In case the YTSubscribe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YTSubscribeUpdateInput, YTSubscribeUncheckedUpdateInput>
  }


  /**
   * YTSubscribe delete
   */
  export type YTSubscribeDeleteArgs = {
    /**
     * Select specific fields to fetch from the YTSubscribe
     */
    select?: YTSubscribeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTSubscribeInclude | null
    /**
     * Filter which YTSubscribe to delete.
     */
    where: YTSubscribeWhereUniqueInput
  }


  /**
   * YTSubscribe deleteMany
   */
  export type YTSubscribeDeleteManyArgs = {
    /**
     * Filter which YTSubscribes to delete
     */
    where?: YTSubscribeWhereInput
  }


  /**
   * YTSubscribe without action
   */
  export type YTSubscribeArgs = {
    /**
     * Select specific fields to fetch from the YTSubscribe
     */
    select?: YTSubscribeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTSubscribeInclude | null
  }



  /**
   * Model YTShare
   */


  export type AggregateYTShare = {
    _count: YTShareCountAggregateOutputType | null
    _avg: YTShareAvgAggregateOutputType | null
    _sum: YTShareSumAggregateOutputType | null
    _min: YTShareMinAggregateOutputType | null
    _max: YTShareMaxAggregateOutputType | null
  }

  export type YTShareAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    videoId: number | null
  }

  export type YTShareSumAggregateOutputType = {
    id: number | null
    userId: number | null
    videoId: number | null
  }

  export type YTShareMinAggregateOutputType = {
    id: number | null
    userId: number | null
    videoId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type YTShareMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    videoId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type YTShareCountAggregateOutputType = {
    id: number
    userId: number
    videoId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type YTShareAvgAggregateInputType = {
    id?: true
    userId?: true
    videoId?: true
  }

  export type YTShareSumAggregateInputType = {
    id?: true
    userId?: true
    videoId?: true
  }

  export type YTShareMinAggregateInputType = {
    id?: true
    userId?: true
    videoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type YTShareMaxAggregateInputType = {
    id?: true
    userId?: true
    videoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type YTShareCountAggregateInputType = {
    id?: true
    userId?: true
    videoId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type YTShareAggregateArgs = {
    /**
     * Filter which YTShare to aggregate.
     */
    where?: YTShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YTShares to fetch.
     */
    orderBy?: Enumerable<YTShareOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YTShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YTShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YTShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YTShares
    **/
    _count?: true | YTShareCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YTShareAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YTShareSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YTShareMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YTShareMaxAggregateInputType
  }

  export type GetYTShareAggregateType<T extends YTShareAggregateArgs> = {
        [P in keyof T & keyof AggregateYTShare]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYTShare[P]>
      : GetScalarType<T[P], AggregateYTShare[P]>
  }




  export type YTShareGroupByArgs = {
    where?: YTShareWhereInput
    orderBy?: Enumerable<YTShareOrderByWithAggregationInput>
    by: YTShareScalarFieldEnum[]
    having?: YTShareScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YTShareCountAggregateInputType | true
    _avg?: YTShareAvgAggregateInputType
    _sum?: YTShareSumAggregateInputType
    _min?: YTShareMinAggregateInputType
    _max?: YTShareMaxAggregateInputType
  }


  export type YTShareGroupByOutputType = {
    id: number
    userId: number
    videoId: number
    createdAt: Date
    updatedAt: Date
    _count: YTShareCountAggregateOutputType | null
    _avg: YTShareAvgAggregateOutputType | null
    _sum: YTShareSumAggregateOutputType | null
    _min: YTShareMinAggregateOutputType | null
    _max: YTShareMaxAggregateOutputType | null
  }

  type GetYTShareGroupByPayload<T extends YTShareGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<YTShareGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YTShareGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YTShareGroupByOutputType[P]>
            : GetScalarType<T[P], YTShareGroupByOutputType[P]>
        }
      >
    >


  export type YTShareSelect = {
    id?: boolean
    user?: boolean | YTUserArgs
    userId?: boolean
    video?: boolean | YTVideoArgs
    videoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type YTShareInclude = {
    user?: boolean | YTUserArgs
    video?: boolean | YTVideoArgs
  }

  export type YTShareGetPayload<S extends boolean | null | undefined | YTShareArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YTShare :
    S extends undefined ? never :
    S extends { include: any } & (YTShareArgs | YTShareFindManyArgs)
    ? YTShare  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? YTUserGetPayload<S['include'][P]> :
        P extends 'video' ? YTVideoGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (YTShareArgs | YTShareFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? YTUserGetPayload<S['select'][P]> :
        P extends 'video' ? YTVideoGetPayload<S['select'][P]> :  P extends keyof YTShare ? YTShare[P] : never
  } 
      : YTShare


  type YTShareCountArgs = 
    Omit<YTShareFindManyArgs, 'select' | 'include'> & {
      select?: YTShareCountAggregateInputType | true
    }

  export interface YTShareDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one YTShare that matches the filter.
     * @param {YTShareFindUniqueArgs} args - Arguments to find a YTShare
     * @example
     * // Get one YTShare
     * const yTShare = await prisma.yTShare.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends YTShareFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, YTShareFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'YTShare'> extends True ? Prisma__YTShareClient<YTShareGetPayload<T>> : Prisma__YTShareClient<YTShareGetPayload<T> | null, null>

    /**
     * Find one YTShare that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {YTShareFindUniqueOrThrowArgs} args - Arguments to find a YTShare
     * @example
     * // Get one YTShare
     * const yTShare = await prisma.yTShare.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends YTShareFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, YTShareFindUniqueOrThrowArgs>
    ): Prisma__YTShareClient<YTShareGetPayload<T>>

    /**
     * Find the first YTShare that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTShareFindFirstArgs} args - Arguments to find a YTShare
     * @example
     * // Get one YTShare
     * const yTShare = await prisma.yTShare.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends YTShareFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, YTShareFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'YTShare'> extends True ? Prisma__YTShareClient<YTShareGetPayload<T>> : Prisma__YTShareClient<YTShareGetPayload<T> | null, null>

    /**
     * Find the first YTShare that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTShareFindFirstOrThrowArgs} args - Arguments to find a YTShare
     * @example
     * // Get one YTShare
     * const yTShare = await prisma.yTShare.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends YTShareFindFirstOrThrowArgs>(
      args?: SelectSubset<T, YTShareFindFirstOrThrowArgs>
    ): Prisma__YTShareClient<YTShareGetPayload<T>>

    /**
     * Find zero or more YTShares that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTShareFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YTShares
     * const yTShares = await prisma.yTShare.findMany()
     * 
     * // Get first 10 YTShares
     * const yTShares = await prisma.yTShare.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const yTShareWithIdOnly = await prisma.yTShare.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends YTShareFindManyArgs>(
      args?: SelectSubset<T, YTShareFindManyArgs>
    ): Prisma.PrismaPromise<Array<YTShareGetPayload<T>>>

    /**
     * Create a YTShare.
     * @param {YTShareCreateArgs} args - Arguments to create a YTShare.
     * @example
     * // Create one YTShare
     * const YTShare = await prisma.yTShare.create({
     *   data: {
     *     // ... data to create a YTShare
     *   }
     * })
     * 
    **/
    create<T extends YTShareCreateArgs>(
      args: SelectSubset<T, YTShareCreateArgs>
    ): Prisma__YTShareClient<YTShareGetPayload<T>>

    /**
     * Create many YTShares.
     *     @param {YTShareCreateManyArgs} args - Arguments to create many YTShares.
     *     @example
     *     // Create many YTShares
     *     const yTShare = await prisma.yTShare.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends YTShareCreateManyArgs>(
      args?: SelectSubset<T, YTShareCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a YTShare.
     * @param {YTShareDeleteArgs} args - Arguments to delete one YTShare.
     * @example
     * // Delete one YTShare
     * const YTShare = await prisma.yTShare.delete({
     *   where: {
     *     // ... filter to delete one YTShare
     *   }
     * })
     * 
    **/
    delete<T extends YTShareDeleteArgs>(
      args: SelectSubset<T, YTShareDeleteArgs>
    ): Prisma__YTShareClient<YTShareGetPayload<T>>

    /**
     * Update one YTShare.
     * @param {YTShareUpdateArgs} args - Arguments to update one YTShare.
     * @example
     * // Update one YTShare
     * const yTShare = await prisma.yTShare.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends YTShareUpdateArgs>(
      args: SelectSubset<T, YTShareUpdateArgs>
    ): Prisma__YTShareClient<YTShareGetPayload<T>>

    /**
     * Delete zero or more YTShares.
     * @param {YTShareDeleteManyArgs} args - Arguments to filter YTShares to delete.
     * @example
     * // Delete a few YTShares
     * const { count } = await prisma.yTShare.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends YTShareDeleteManyArgs>(
      args?: SelectSubset<T, YTShareDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YTShares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTShareUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YTShares
     * const yTShare = await prisma.yTShare.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends YTShareUpdateManyArgs>(
      args: SelectSubset<T, YTShareUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one YTShare.
     * @param {YTShareUpsertArgs} args - Arguments to update or create a YTShare.
     * @example
     * // Update or create a YTShare
     * const yTShare = await prisma.yTShare.upsert({
     *   create: {
     *     // ... data to create a YTShare
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YTShare we want to update
     *   }
     * })
    **/
    upsert<T extends YTShareUpsertArgs>(
      args: SelectSubset<T, YTShareUpsertArgs>
    ): Prisma__YTShareClient<YTShareGetPayload<T>>

    /**
     * Count the number of YTShares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTShareCountArgs} args - Arguments to filter YTShares to count.
     * @example
     * // Count the number of YTShares
     * const count = await prisma.yTShare.count({
     *   where: {
     *     // ... the filter for the YTShares we want to count
     *   }
     * })
    **/
    count<T extends YTShareCountArgs>(
      args?: Subset<T, YTShareCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YTShareCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YTShare.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTShareAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YTShareAggregateArgs>(args: Subset<T, YTShareAggregateArgs>): Prisma.PrismaPromise<GetYTShareAggregateType<T>>

    /**
     * Group by YTShare.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YTShareGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YTShareGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YTShareGroupByArgs['orderBy'] }
        : { orderBy?: YTShareGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YTShareGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYTShareGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for YTShare.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__YTShareClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends YTUserArgs= {}>(args?: Subset<T, YTUserArgs>): Prisma__YTUserClient<YTUserGetPayload<T> | Null>;

    video<T extends YTVideoArgs= {}>(args?: Subset<T, YTVideoArgs>): Prisma__YTVideoClient<YTVideoGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * YTShare base type for findUnique actions
   */
  export type YTShareFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the YTShare
     */
    select?: YTShareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTShareInclude | null
    /**
     * Filter, which YTShare to fetch.
     */
    where: YTShareWhereUniqueInput
  }

  /**
   * YTShare findUnique
   */
  export interface YTShareFindUniqueArgs extends YTShareFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YTShare findUniqueOrThrow
   */
  export type YTShareFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YTShare
     */
    select?: YTShareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTShareInclude | null
    /**
     * Filter, which YTShare to fetch.
     */
    where: YTShareWhereUniqueInput
  }


  /**
   * YTShare base type for findFirst actions
   */
  export type YTShareFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the YTShare
     */
    select?: YTShareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTShareInclude | null
    /**
     * Filter, which YTShare to fetch.
     */
    where?: YTShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YTShares to fetch.
     */
    orderBy?: Enumerable<YTShareOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YTShares.
     */
    cursor?: YTShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YTShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YTShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YTShares.
     */
    distinct?: Enumerable<YTShareScalarFieldEnum>
  }

  /**
   * YTShare findFirst
   */
  export interface YTShareFindFirstArgs extends YTShareFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YTShare findFirstOrThrow
   */
  export type YTShareFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YTShare
     */
    select?: YTShareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTShareInclude | null
    /**
     * Filter, which YTShare to fetch.
     */
    where?: YTShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YTShares to fetch.
     */
    orderBy?: Enumerable<YTShareOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YTShares.
     */
    cursor?: YTShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YTShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YTShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YTShares.
     */
    distinct?: Enumerable<YTShareScalarFieldEnum>
  }


  /**
   * YTShare findMany
   */
  export type YTShareFindManyArgs = {
    /**
     * Select specific fields to fetch from the YTShare
     */
    select?: YTShareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTShareInclude | null
    /**
     * Filter, which YTShares to fetch.
     */
    where?: YTShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YTShares to fetch.
     */
    orderBy?: Enumerable<YTShareOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YTShares.
     */
    cursor?: YTShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YTShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YTShares.
     */
    skip?: number
    distinct?: Enumerable<YTShareScalarFieldEnum>
  }


  /**
   * YTShare create
   */
  export type YTShareCreateArgs = {
    /**
     * Select specific fields to fetch from the YTShare
     */
    select?: YTShareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTShareInclude | null
    /**
     * The data needed to create a YTShare.
     */
    data: XOR<YTShareCreateInput, YTShareUncheckedCreateInput>
  }


  /**
   * YTShare createMany
   */
  export type YTShareCreateManyArgs = {
    /**
     * The data used to create many YTShares.
     */
    data: Enumerable<YTShareCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * YTShare update
   */
  export type YTShareUpdateArgs = {
    /**
     * Select specific fields to fetch from the YTShare
     */
    select?: YTShareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTShareInclude | null
    /**
     * The data needed to update a YTShare.
     */
    data: XOR<YTShareUpdateInput, YTShareUncheckedUpdateInput>
    /**
     * Choose, which YTShare to update.
     */
    where: YTShareWhereUniqueInput
  }


  /**
   * YTShare updateMany
   */
  export type YTShareUpdateManyArgs = {
    /**
     * The data used to update YTShares.
     */
    data: XOR<YTShareUpdateManyMutationInput, YTShareUncheckedUpdateManyInput>
    /**
     * Filter which YTShares to update
     */
    where?: YTShareWhereInput
  }


  /**
   * YTShare upsert
   */
  export type YTShareUpsertArgs = {
    /**
     * Select specific fields to fetch from the YTShare
     */
    select?: YTShareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTShareInclude | null
    /**
     * The filter to search for the YTShare to update in case it exists.
     */
    where: YTShareWhereUniqueInput
    /**
     * In case the YTShare found by the `where` argument doesn't exist, create a new YTShare with this data.
     */
    create: XOR<YTShareCreateInput, YTShareUncheckedCreateInput>
    /**
     * In case the YTShare was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YTShareUpdateInput, YTShareUncheckedUpdateInput>
  }


  /**
   * YTShare delete
   */
  export type YTShareDeleteArgs = {
    /**
     * Select specific fields to fetch from the YTShare
     */
    select?: YTShareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTShareInclude | null
    /**
     * Filter which YTShare to delete.
     */
    where: YTShareWhereUniqueInput
  }


  /**
   * YTShare deleteMany
   */
  export type YTShareDeleteManyArgs = {
    /**
     * Filter which YTShares to delete
     */
    where?: YTShareWhereInput
  }


  /**
   * YTShare without action
   */
  export type YTShareArgs = {
    /**
     * Select specific fields to fetch from the YTShare
     */
    select?: YTShareSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YTShareInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const BKAuthorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BKAuthorScalarFieldEnum = (typeof BKAuthorScalarFieldEnum)[keyof typeof BKAuthorScalarFieldEnum]


  export const BKBorrowingHistoryScalarFieldEnum: {
    id: 'id',
    reserveUserId: 'reserveUserId',
    copyId: 'copyId',
    fromUniversityId: 'fromUniversityId',
    borrowDate: 'borrowDate',
    returnDate: 'returnDate',
    actualReturnDate: 'actualReturnDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BKBorrowingHistoryScalarFieldEnum = (typeof BKBorrowingHistoryScalarFieldEnum)[keyof typeof BKBorrowingHistoryScalarFieldEnum]


  export const BKCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BKCategoryScalarFieldEnum = (typeof BKCategoryScalarFieldEnum)[keyof typeof BKCategoryScalarFieldEnum]


  export const BKCopyScalarFieldEnum: {
    id: 'id',
    status: 'status',
    titleId: 'titleId',
    reserveUserId: 'reserveUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BKCopyScalarFieldEnum = (typeof BKCopyScalarFieldEnum)[keyof typeof BKCopyScalarFieldEnum]


  export const BKRequestScalarFieldEnum: {
    id: 'id',
    reserveUserId: 'reserveUserId',
    copyId: 'copyId',
    fromUniversityId: 'fromUniversityId',
    toUniversityId: 'toUniversityId',
    requestDate: 'requestDate',
    status: 'status',
    planRecievedDate: 'planRecievedDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BKRequestScalarFieldEnum = (typeof BKRequestScalarFieldEnum)[keyof typeof BKRequestScalarFieldEnum]


  export const BKReserveUserScalarFieldEnum: {
    id: 'id',
    universityId: 'universityId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BKReserveUserScalarFieldEnum = (typeof BKReserveUserScalarFieldEnum)[keyof typeof BKReserveUserScalarFieldEnum]


  export const BKTitleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    ISBN: 'ISBN',
    copyQty: 'copyQty',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BKTitleScalarFieldEnum = (typeof BKTitleScalarFieldEnum)[keyof typeof BKTitleScalarFieldEnum]


  export const BKUniversityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BKUniversityScalarFieldEnum = (typeof BKUniversityScalarFieldEnum)[keyof typeof BKUniversityScalarFieldEnum]


  export const FbCommentScalarFieldEnum: {
    id: 'id',
    text: 'text',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FbCommentScalarFieldEnum = (typeof FbCommentScalarFieldEnum)[keyof typeof FbCommentScalarFieldEnum]


  export const FbDestinationUserScalarFieldEnum: {
    id: 'id',
    fbWallId: 'fbWallId',
    shareId: 'shareId',
    groupId: 'groupId'
  };

  export type FbDestinationUserScalarFieldEnum = (typeof FbDestinationUserScalarFieldEnum)[keyof typeof FbDestinationUserScalarFieldEnum]


  export const FbGroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FbGroupScalarFieldEnum = (typeof FbGroupScalarFieldEnum)[keyof typeof FbGroupScalarFieldEnum]


  export const FbHashtagScalarFieldEnum: {
    id: 'id',
    hashtag: 'hashtag',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FbHashtagScalarFieldEnum = (typeof FbHashtagScalarFieldEnum)[keyof typeof FbHashtagScalarFieldEnum]


  export const FbLikeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    postId: 'postId',
    commentId: 'commentId',
    shareId: 'shareId',
    likeType: 'likeType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FbLikeScalarFieldEnum = (typeof FbLikeScalarFieldEnum)[keyof typeof FbLikeScalarFieldEnum]


  export const FbMessengerScalarFieldEnum: {
    id: 'id',
    fromuserId: 'fromuserId',
    toUserId: 'toUserId',
    text: 'text',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FbMessengerScalarFieldEnum = (typeof FbMessengerScalarFieldEnum)[keyof typeof FbMessengerScalarFieldEnum]


  export const FbPostImageScalarFieldEnum: {
    id: 'id',
    image: 'image',
    postId: 'postId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FbPostImageScalarFieldEnum = (typeof FbPostImageScalarFieldEnum)[keyof typeof FbPostImageScalarFieldEnum]


  export const FbPostOnHashtagScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    hashtagId: 'hashtagId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FbPostOnHashtagScalarFieldEnum = (typeof FbPostOnHashtagScalarFieldEnum)[keyof typeof FbPostOnHashtagScalarFieldEnum]


  export const FbPostScalarFieldEnum: {
    id: 'id',
    caption: 'caption',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    wallId: 'wallId'
  };

  export type FbPostScalarFieldEnum = (typeof FbPostScalarFieldEnum)[keyof typeof FbPostScalarFieldEnum]


  export const FbPostVideoScalarFieldEnum: {
    id: 'id',
    video: 'video',
    postId: 'postId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FbPostVideoScalarFieldEnum = (typeof FbPostVideoScalarFieldEnum)[keyof typeof FbPostVideoScalarFieldEnum]


  export const FbShareScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    postId: 'postId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FbShareScalarFieldEnum = (typeof FbShareScalarFieldEnum)[keyof typeof FbShareScalarFieldEnum]


  export const FbUserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    image: 'image',
    location: 'location',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FbUserScalarFieldEnum = (typeof FbUserScalarFieldEnum)[keyof typeof FbUserScalarFieldEnum]


  export const FbWallScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FbWallScalarFieldEnum = (typeof FbWallScalarFieldEnum)[keyof typeof FbWallScalarFieldEnum]


  export const FbfriendScalarFieldEnum: {
    id: 'id',
    acceptId: 'acceptId',
    requestId: 'requestId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FbfriendScalarFieldEnum = (typeof FbfriendScalarFieldEnum)[keyof typeof FbfriendScalarFieldEnum]


  export const GroupToUserScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    groupId: 'groupId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GroupToUserScalarFieldEnum = (typeof GroupToUserScalarFieldEnum)[keyof typeof GroupToUserScalarFieldEnum]


  export const KorKitchenCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createAt: 'createAt',
    updateAt: 'updateAt'
  };

  export type KorKitchenCategoryScalarFieldEnum = (typeof KorKitchenCategoryScalarFieldEnum)[keyof typeof KorKitchenCategoryScalarFieldEnum]


  export const KorKitchenMenuScalarFieldEnum: {
    id: 'id',
    name: 'name',
    image: 'image',
    price: 'price',
    categoryName: 'categoryName',
    createAt: 'createAt',
    updateAt: 'updateAt'
  };

  export type KorKitchenMenuScalarFieldEnum = (typeof KorKitchenMenuScalarFieldEnum)[keyof typeof KorKitchenMenuScalarFieldEnum]


  export const KorKitchenOrderItemScalarFieldEnum: {
    id: 'id',
    menuId: 'menuId',
    orderId: 'orderId',
    quantity: 'quantity',
    totalPrice: 'totalPrice',
    creatAt: 'creatAt',
    updatedAt: 'updatedAt'
  };

  export type KorKitchenOrderItemScalarFieldEnum = (typeof KorKitchenOrderItemScalarFieldEnum)[keyof typeof KorKitchenOrderItemScalarFieldEnum]


  export const KorKitchenOrderScalarFieldEnum: {
    id: 'id',
    status: 'status',
    tableId: 'tableId',
    createAt: 'createAt',
    updateAt: 'updateAt'
  };

  export type KorKitchenOrderScalarFieldEnum = (typeof KorKitchenOrderScalarFieldEnum)[keyof typeof KorKitchenOrderScalarFieldEnum]


  export const MachineToProgramScalarFieldEnum: {
    id: 'id',
    machineId: 'machineId',
    programId: 'programId',
    createdAt: 'createdAt',
    updateAt: 'updateAt'
  };

  export type MachineToProgramScalarFieldEnum = (typeof MachineToProgramScalarFieldEnum)[keyof typeof MachineToProgramScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const TestModelScalarFieldEnum: {
    id: 'id',
    firstname: 'firstname',
    Surname: 'Surname'
  };

  export type TestModelScalarFieldEnum = (typeof TestModelScalarFieldEnum)[keyof typeof TestModelScalarFieldEnum]


  export const TitleToAuthorScalarFieldEnum: {
    id: 'id',
    titleId: 'titleId',
    authorId: 'authorId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TitleToAuthorScalarFieldEnum = (typeof TitleToAuthorScalarFieldEnum)[keyof typeof TitleToAuthorScalarFieldEnum]


  export const TitleToCategoryScalarFieldEnum: {
    id: 'id',
    titleId: 'titleId',
    categoryId: 'categoryId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TitleToCategoryScalarFieldEnum = (typeof TitleToCategoryScalarFieldEnum)[keyof typeof TitleToCategoryScalarFieldEnum]


  export const TodoListScalarFieldEnum: {
    id: 'id',
    task: 'task',
    status: 'status',
    note: 'note',
    createAt: 'createAt',
    updateAt: 'updateAt'
  };

  export type TodoListScalarFieldEnum = (typeof TodoListScalarFieldEnum)[keyof typeof TodoListScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TriviaCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type TriviaCategoryScalarFieldEnum = (typeof TriviaCategoryScalarFieldEnum)[keyof typeof TriviaCategoryScalarFieldEnum]


  export const TriviaChoiceScalarFieldEnum: {
    id: 'id',
    quizId: 'quizId',
    name: 'name'
  };

  export type TriviaChoiceScalarFieldEnum = (typeof TriviaChoiceScalarFieldEnum)[keyof typeof TriviaChoiceScalarFieldEnum]


  export const TriviaQuestionScalarFieldEnum: {
    id: 'id',
    categoryId: 'categoryId',
    name: 'name',
    answerID: 'answerID'
  };

  export type TriviaQuestionScalarFieldEnum = (typeof TriviaQuestionScalarFieldEnum)[keyof typeof TriviaQuestionScalarFieldEnum]


  export const TriviaRoundQuestionScalarFieldEnum: {
    id: 'id',
    quizId: 'quizId',
    choiceId: 'choiceId',
    quizResult: 'quizResult',
    roundId: 'roundId'
  };

  export type TriviaRoundQuestionScalarFieldEnum = (typeof TriviaRoundQuestionScalarFieldEnum)[keyof typeof TriviaRoundQuestionScalarFieldEnum]


  export const TriviaRoundScalarFieldEnum: {
    id: 'id',
    user: 'user',
    categoryId: 'categoryId',
    totalResult: 'totalResult',
    createAt: 'createAt'
  };

  export type TriviaRoundScalarFieldEnum = (typeof TriviaRoundScalarFieldEnum)[keyof typeof TriviaRoundScalarFieldEnum]


  export const TwitterCommentScalarFieldEnum: {
    id: 'id',
    text: 'text',
    userId: 'userId',
    postId: 'postId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TwitterCommentScalarFieldEnum = (typeof TwitterCommentScalarFieldEnum)[keyof typeof TwitterCommentScalarFieldEnum]


  export const TwitterDirectMessageScalarFieldEnum: {
    id: 'id',
    fromUserId: 'fromUserId',
    toUserId: 'toUserId',
    text: 'text',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TwitterDirectMessageScalarFieldEnum = (typeof TwitterDirectMessageScalarFieldEnum)[keyof typeof TwitterDirectMessageScalarFieldEnum]


  export const TwitterFollowScalarFieldEnum: {
    id: 'id',
    fromUserId: 'fromUserId',
    toUserId: 'toUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TwitterFollowScalarFieldEnum = (typeof TwitterFollowScalarFieldEnum)[keyof typeof TwitterFollowScalarFieldEnum]


  export const TwitterHashtagScalarFieldEnum: {
    id: 'id',
    hashtag: 'hashtag',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TwitterHashtagScalarFieldEnum = (typeof TwitterHashtagScalarFieldEnum)[keyof typeof TwitterHashtagScalarFieldEnum]


  export const TwitterPostOnHashtagScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    hashtagId: 'hashtagId'
  };

  export type TwitterPostOnHashtagScalarFieldEnum = (typeof TwitterPostOnHashtagScalarFieldEnum)[keyof typeof TwitterPostOnHashtagScalarFieldEnum]


  export const TwitterPostScalarFieldEnum: {
    id: 'id',
    caption: 'caption',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TwitterPostScalarFieldEnum = (typeof TwitterPostScalarFieldEnum)[keyof typeof TwitterPostScalarFieldEnum]


  export const TwitterUserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    Image: 'Image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TwitterUserScalarFieldEnum = (typeof TwitterUserScalarFieldEnum)[keyof typeof TwitterUserScalarFieldEnum]


  export const UniversityToTitleScalarFieldEnum: {
    id: 'id',
    universityId: 'universityId',
    titleId: 'titleId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UniversityToTitleScalarFieldEnum = (typeof UniversityToTitleScalarFieldEnum)[keyof typeof UniversityToTitleScalarFieldEnum]


  export const UserToChannelScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    channelId: 'channelId',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserToChannelScalarFieldEnum = (typeof UserToChannelScalarFieldEnum)[keyof typeof UserToChannelScalarFieldEnum]


  export const WSMachineScalarFieldEnum: {
    id: 'id',
    shopId: 'shopId',
    brandname: 'brandname',
    size: 'size',
    type: 'type',
    model: 'model',
    producedDate: 'producedDate',
    insuranceExpiredDate: 'insuranceExpiredDate',
    createdAt: 'createdAt',
    updateAt: 'updateAt'
  };

  export type WSMachineScalarFieldEnum = (typeof WSMachineScalarFieldEnum)[keyof typeof WSMachineScalarFieldEnum]


  export const WSMaintainScalarFieldEnum: {
    id: 'id',
    checker: 'checker',
    item: 'item',
    status: 'status',
    machineId: 'machineId',
    createdAt: 'createdAt',
    updateAt: 'updateAt'
  };

  export type WSMaintainScalarFieldEnum = (typeof WSMaintainScalarFieldEnum)[keyof typeof WSMaintainScalarFieldEnum]


  export const WSProgramDetailScalarFieldEnum: {
    id: 'id',
    programId: 'programId',
    price: 'price',
    duration: 'duration',
    weight: 'weight',
    createdAt: 'createdAt',
    updateAt: 'updateAt'
  };

  export type WSProgramDetailScalarFieldEnum = (typeof WSProgramDetailScalarFieldEnum)[keyof typeof WSProgramDetailScalarFieldEnum]


  export const WSProgramScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updateAt: 'updateAt',
    activeProgramId: 'activeProgramId'
  };

  export type WSProgramScalarFieldEnum = (typeof WSProgramScalarFieldEnum)[keyof typeof WSProgramScalarFieldEnum]


  export const WSShopScalarFieldEnum: {
    id: 'id',
    branch: 'branch',
    owner: 'owner',
    tel: 'tel',
    location: 'location',
    area: 'area',
    createdAt: 'createdAt',
    updateAt: 'updateAt'
  };

  export type WSShopScalarFieldEnum = (typeof WSShopScalarFieldEnum)[keyof typeof WSShopScalarFieldEnum]


  export const WSTopupHistoryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    topup: 'topup',
    createdAt: 'createdAt',
    updateAt: 'updateAt'
  };

  export type WSTopupHistoryScalarFieldEnum = (typeof WSTopupHistoryScalarFieldEnum)[keyof typeof WSTopupHistoryScalarFieldEnum]


  export const WSUserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    tel: 'tel',
    myWallet: 'myWallet',
    createdAt: 'createdAt',
    updateAt: 'updateAt'
  };

  export type WSUserScalarFieldEnum = (typeof WSUserScalarFieldEnum)[keyof typeof WSUserScalarFieldEnum]


  export const WSUsingHistoryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    price: 'price',
    createdAt: 'createdAt',
    updateAt: 'updateAt',
    usingStartAt: 'usingStartAt',
    finishingAt: 'finishingAt',
    wSMachineId: 'wSMachineId',
    wSProgramId: 'wSProgramId'
  };

  export type WSUsingHistoryScalarFieldEnum = (typeof WSUsingHistoryScalarFieldEnum)[keyof typeof WSUsingHistoryScalarFieldEnum]


  export const YTChannelScalarFieldEnum: {
    id: 'id',
    channelName: 'channelName',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type YTChannelScalarFieldEnum = (typeof YTChannelScalarFieldEnum)[keyof typeof YTChannelScalarFieldEnum]


  export const YTCommentScalarFieldEnum: {
    id: 'id',
    text: 'text',
    userId: 'userId',
    commentTo: 'commentTo',
    videoId: 'videoId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type YTCommentScalarFieldEnum = (typeof YTCommentScalarFieldEnum)[keyof typeof YTCommentScalarFieldEnum]


  export const YTLikeScalarFieldEnum: {
    id: 'id',
    type: 'type',
    videoId: 'videoId',
    commentId: 'commentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type YTLikeScalarFieldEnum = (typeof YTLikeScalarFieldEnum)[keyof typeof YTLikeScalarFieldEnum]


  export const YTShareScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    videoId: 'videoId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type YTShareScalarFieldEnum = (typeof YTShareScalarFieldEnum)[keyof typeof YTShareScalarFieldEnum]


  export const YTSubscribeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    channelId: 'channelId',
    member: 'member',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type YTSubscribeScalarFieldEnum = (typeof YTSubscribeScalarFieldEnum)[keyof typeof YTSubscribeScalarFieldEnum]


  export const YTUserScalarFieldEnum: {
    id: 'id',
    user: 'user',
    email: 'email',
    avatar: 'avatar',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type YTUserScalarFieldEnum = (typeof YTUserScalarFieldEnum)[keyof typeof YTUserScalarFieldEnum]


  export const YTVideoScalarFieldEnum: {
    id: 'id',
    name: 'name',
    file: 'file',
    logo: 'logo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    channelId: 'channelId'
  };

  export type YTVideoScalarFieldEnum = (typeof YTVideoScalarFieldEnum)[keyof typeof YTVideoScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type BKReserveUserWhereInput = {
    AND?: Enumerable<BKReserveUserWhereInput>
    OR?: Enumerable<BKReserveUserWhereInput>
    NOT?: Enumerable<BKReserveUserWhereInput>
    id?: IntFilter | number
    university?: XOR<BKUniversityRelationFilter, BKUniversityWhereInput>
    universityId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    requests?: BKRequestListRelationFilter
    BKBorrowingHistory?: BKBorrowingHistoryListRelationFilter
    BKCopy?: BKCopyListRelationFilter
  }

  export type BKReserveUserOrderByWithRelationInput = {
    id?: SortOrder
    university?: BKUniversityOrderByWithRelationInput
    universityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    requests?: BKRequestOrderByRelationAggregateInput
    BKBorrowingHistory?: BKBorrowingHistoryOrderByRelationAggregateInput
    BKCopy?: BKCopyOrderByRelationAggregateInput
  }

  export type BKReserveUserWhereUniqueInput = {
    id?: number
  }

  export type BKReserveUserOrderByWithAggregationInput = {
    id?: SortOrder
    universityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BKReserveUserCountOrderByAggregateInput
    _avg?: BKReserveUserAvgOrderByAggregateInput
    _max?: BKReserveUserMaxOrderByAggregateInput
    _min?: BKReserveUserMinOrderByAggregateInput
    _sum?: BKReserveUserSumOrderByAggregateInput
  }

  export type BKReserveUserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BKReserveUserScalarWhereWithAggregatesInput>
    OR?: Enumerable<BKReserveUserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BKReserveUserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    universityId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type BKRequestWhereInput = {
    AND?: Enumerable<BKRequestWhereInput>
    OR?: Enumerable<BKRequestWhereInput>
    NOT?: Enumerable<BKRequestWhereInput>
    id?: IntFilter | number
    user?: XOR<BKReserveUserRelationFilter, BKReserveUserWhereInput>
    reserveUserId?: IntFilter | number
    copy?: XOR<BKCopyRelationFilter, BKCopyWhereInput>
    copyId?: IntFilter | number
    from?: XOR<BKUniversityRelationFilter, BKUniversityWhereInput>
    fromUniversityId?: IntFilter | number
    to?: XOR<BKUniversityRelationFilter, BKUniversityWhereInput>
    toUniversityId?: IntFilter | number
    requestDate?: DateTimeFilter | Date | string
    status?: EnumRequestStatusEnumFilter | RequestStatusEnum
    planRecievedDate?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type BKRequestOrderByWithRelationInput = {
    id?: SortOrder
    user?: BKReserveUserOrderByWithRelationInput
    reserveUserId?: SortOrder
    copy?: BKCopyOrderByWithRelationInput
    copyId?: SortOrder
    from?: BKUniversityOrderByWithRelationInput
    fromUniversityId?: SortOrder
    to?: BKUniversityOrderByWithRelationInput
    toUniversityId?: SortOrder
    requestDate?: SortOrder
    status?: SortOrder
    planRecievedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BKRequestWhereUniqueInput = {
    id?: number
  }

  export type BKRequestOrderByWithAggregationInput = {
    id?: SortOrder
    reserveUserId?: SortOrder
    copyId?: SortOrder
    fromUniversityId?: SortOrder
    toUniversityId?: SortOrder
    requestDate?: SortOrder
    status?: SortOrder
    planRecievedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BKRequestCountOrderByAggregateInput
    _avg?: BKRequestAvgOrderByAggregateInput
    _max?: BKRequestMaxOrderByAggregateInput
    _min?: BKRequestMinOrderByAggregateInput
    _sum?: BKRequestSumOrderByAggregateInput
  }

  export type BKRequestScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BKRequestScalarWhereWithAggregatesInput>
    OR?: Enumerable<BKRequestScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BKRequestScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    reserveUserId?: IntWithAggregatesFilter | number
    copyId?: IntWithAggregatesFilter | number
    fromUniversityId?: IntWithAggregatesFilter | number
    toUniversityId?: IntWithAggregatesFilter | number
    requestDate?: DateTimeWithAggregatesFilter | Date | string
    status?: EnumRequestStatusEnumWithAggregatesFilter | RequestStatusEnum
    planRecievedDate?: DateTimeWithAggregatesFilter | Date | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type BKBorrowingHistoryWhereInput = {
    AND?: Enumerable<BKBorrowingHistoryWhereInput>
    OR?: Enumerable<BKBorrowingHistoryWhereInput>
    NOT?: Enumerable<BKBorrowingHistoryWhereInput>
    id?: IntFilter | number
    user?: XOR<BKReserveUserRelationFilter, BKReserveUserWhereInput>
    reserveUserId?: IntFilter | number
    copy?: XOR<BKCopyRelationFilter, BKCopyWhereInput>
    copyId?: IntFilter | number
    from?: XOR<BKUniversityRelationFilter, BKUniversityWhereInput>
    fromUniversityId?: IntFilter | number
    borrowDate?: DateTimeFilter | Date | string
    returnDate?: DateTimeFilter | Date | string
    actualReturnDate?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type BKBorrowingHistoryOrderByWithRelationInput = {
    id?: SortOrder
    user?: BKReserveUserOrderByWithRelationInput
    reserveUserId?: SortOrder
    copy?: BKCopyOrderByWithRelationInput
    copyId?: SortOrder
    from?: BKUniversityOrderByWithRelationInput
    fromUniversityId?: SortOrder
    borrowDate?: SortOrder
    returnDate?: SortOrder
    actualReturnDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BKBorrowingHistoryWhereUniqueInput = {
    id?: number
  }

  export type BKBorrowingHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    reserveUserId?: SortOrder
    copyId?: SortOrder
    fromUniversityId?: SortOrder
    borrowDate?: SortOrder
    returnDate?: SortOrder
    actualReturnDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BKBorrowingHistoryCountOrderByAggregateInput
    _avg?: BKBorrowingHistoryAvgOrderByAggregateInput
    _max?: BKBorrowingHistoryMaxOrderByAggregateInput
    _min?: BKBorrowingHistoryMinOrderByAggregateInput
    _sum?: BKBorrowingHistorySumOrderByAggregateInput
  }

  export type BKBorrowingHistoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BKBorrowingHistoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<BKBorrowingHistoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BKBorrowingHistoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    reserveUserId?: IntWithAggregatesFilter | number
    copyId?: IntWithAggregatesFilter | number
    fromUniversityId?: IntWithAggregatesFilter | number
    borrowDate?: DateTimeWithAggregatesFilter | Date | string
    returnDate?: DateTimeWithAggregatesFilter | Date | string
    actualReturnDate?: DateTimeWithAggregatesFilter | Date | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type BKCopyWhereInput = {
    AND?: Enumerable<BKCopyWhereInput>
    OR?: Enumerable<BKCopyWhereInput>
    NOT?: Enumerable<BKCopyWhereInput>
    id?: IntFilter | number
    status?: EnumCopyStatusEnumFilter | CopyStatusEnum
    title?: XOR<BKTitleRelationFilter, BKTitleWhereInput>
    titleId?: IntFilter | number
    user?: XOR<BKReserveUserRelationFilter, BKReserveUserWhereInput> | null
    reserveUserId?: IntNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    requests?: BKRequestListRelationFilter
    BKBorrowingHistory?: BKBorrowingHistoryListRelationFilter
  }

  export type BKCopyOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    title?: BKTitleOrderByWithRelationInput
    titleId?: SortOrder
    user?: BKReserveUserOrderByWithRelationInput
    reserveUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    requests?: BKRequestOrderByRelationAggregateInput
    BKBorrowingHistory?: BKBorrowingHistoryOrderByRelationAggregateInput
  }

  export type BKCopyWhereUniqueInput = {
    id?: number
  }

  export type BKCopyOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    titleId?: SortOrder
    reserveUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BKCopyCountOrderByAggregateInput
    _avg?: BKCopyAvgOrderByAggregateInput
    _max?: BKCopyMaxOrderByAggregateInput
    _min?: BKCopyMinOrderByAggregateInput
    _sum?: BKCopySumOrderByAggregateInput
  }

  export type BKCopyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BKCopyScalarWhereWithAggregatesInput>
    OR?: Enumerable<BKCopyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BKCopyScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    status?: EnumCopyStatusEnumWithAggregatesFilter | CopyStatusEnum
    titleId?: IntWithAggregatesFilter | number
    reserveUserId?: IntNullableWithAggregatesFilter | number | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type BKUniversityWhereInput = {
    AND?: Enumerable<BKUniversityWhereInput>
    OR?: Enumerable<BKUniversityWhereInput>
    NOT?: Enumerable<BKUniversityWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    universityToTitles?: UniversityToTitleListRelationFilter
    reserveUsers?: BKReserveUserListRelationFilter
    fromRequest?: BKRequestListRelationFilter
    toRequest?: BKRequestListRelationFilter
    BKBorrowingHistory?: BKBorrowingHistoryListRelationFilter
  }

  export type BKUniversityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    universityToTitles?: UniversityToTitleOrderByRelationAggregateInput
    reserveUsers?: BKReserveUserOrderByRelationAggregateInput
    fromRequest?: BKRequestOrderByRelationAggregateInput
    toRequest?: BKRequestOrderByRelationAggregateInput
    BKBorrowingHistory?: BKBorrowingHistoryOrderByRelationAggregateInput
  }

  export type BKUniversityWhereUniqueInput = {
    id?: number
  }

  export type BKUniversityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BKUniversityCountOrderByAggregateInput
    _avg?: BKUniversityAvgOrderByAggregateInput
    _max?: BKUniversityMaxOrderByAggregateInput
    _min?: BKUniversityMinOrderByAggregateInput
    _sum?: BKUniversitySumOrderByAggregateInput
  }

  export type BKUniversityScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BKUniversityScalarWhereWithAggregatesInput>
    OR?: Enumerable<BKUniversityScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BKUniversityScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type BKTitleWhereInput = {
    AND?: Enumerable<BKTitleWhereInput>
    OR?: Enumerable<BKTitleWhereInput>
    NOT?: Enumerable<BKTitleWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    ISBN?: IntFilter | number
    copyQty?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    titleToCategories?: TitleToCategoryListRelationFilter
    titleToAuthors?: TitleToAuthorListRelationFilter
    universityToTitles?: UniversityToTitleListRelationFilter
    copies?: BKCopyListRelationFilter
  }

  export type BKTitleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    ISBN?: SortOrder
    copyQty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    titleToCategories?: TitleToCategoryOrderByRelationAggregateInput
    titleToAuthors?: TitleToAuthorOrderByRelationAggregateInput
    universityToTitles?: UniversityToTitleOrderByRelationAggregateInput
    copies?: BKCopyOrderByRelationAggregateInput
  }

  export type BKTitleWhereUniqueInput = {
    id?: number
  }

  export type BKTitleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    ISBN?: SortOrder
    copyQty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BKTitleCountOrderByAggregateInput
    _avg?: BKTitleAvgOrderByAggregateInput
    _max?: BKTitleMaxOrderByAggregateInput
    _min?: BKTitleMinOrderByAggregateInput
    _sum?: BKTitleSumOrderByAggregateInput
  }

  export type BKTitleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BKTitleScalarWhereWithAggregatesInput>
    OR?: Enumerable<BKTitleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BKTitleScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    ISBN?: IntWithAggregatesFilter | number
    copyQty?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UniversityToTitleWhereInput = {
    AND?: Enumerable<UniversityToTitleWhereInput>
    OR?: Enumerable<UniversityToTitleWhereInput>
    NOT?: Enumerable<UniversityToTitleWhereInput>
    id?: IntFilter | number
    university?: XOR<BKUniversityRelationFilter, BKUniversityWhereInput>
    universityId?: IntFilter | number
    title?: XOR<BKTitleRelationFilter, BKTitleWhereInput>
    titleId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type UniversityToTitleOrderByWithRelationInput = {
    id?: SortOrder
    university?: BKUniversityOrderByWithRelationInput
    universityId?: SortOrder
    title?: BKTitleOrderByWithRelationInput
    titleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UniversityToTitleWhereUniqueInput = {
    id?: number
  }

  export type UniversityToTitleOrderByWithAggregationInput = {
    id?: SortOrder
    universityId?: SortOrder
    titleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UniversityToTitleCountOrderByAggregateInput
    _avg?: UniversityToTitleAvgOrderByAggregateInput
    _max?: UniversityToTitleMaxOrderByAggregateInput
    _min?: UniversityToTitleMinOrderByAggregateInput
    _sum?: UniversityToTitleSumOrderByAggregateInput
  }

  export type UniversityToTitleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UniversityToTitleScalarWhereWithAggregatesInput>
    OR?: Enumerable<UniversityToTitleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UniversityToTitleScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    universityId?: IntWithAggregatesFilter | number
    titleId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type BKCategoryWhereInput = {
    AND?: Enumerable<BKCategoryWhereInput>
    OR?: Enumerable<BKCategoryWhereInput>
    NOT?: Enumerable<BKCategoryWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    titleToCategories?: TitleToCategoryListRelationFilter
  }

  export type BKCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    titleToCategories?: TitleToCategoryOrderByRelationAggregateInput
  }

  export type BKCategoryWhereUniqueInput = {
    id?: number
  }

  export type BKCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BKCategoryCountOrderByAggregateInput
    _avg?: BKCategoryAvgOrderByAggregateInput
    _max?: BKCategoryMaxOrderByAggregateInput
    _min?: BKCategoryMinOrderByAggregateInput
    _sum?: BKCategorySumOrderByAggregateInput
  }

  export type BKCategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BKCategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<BKCategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BKCategoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TitleToCategoryWhereInput = {
    AND?: Enumerable<TitleToCategoryWhereInput>
    OR?: Enumerable<TitleToCategoryWhereInput>
    NOT?: Enumerable<TitleToCategoryWhereInput>
    id?: IntFilter | number
    title?: XOR<BKTitleRelationFilter, BKTitleWhereInput>
    titleId?: IntFilter | number
    category?: XOR<BKCategoryRelationFilter, BKCategoryWhereInput>
    categoryId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TitleToCategoryOrderByWithRelationInput = {
    id?: SortOrder
    title?: BKTitleOrderByWithRelationInput
    titleId?: SortOrder
    category?: BKCategoryOrderByWithRelationInput
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TitleToCategoryWhereUniqueInput = {
    id?: number
  }

  export type TitleToCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    titleId?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TitleToCategoryCountOrderByAggregateInput
    _avg?: TitleToCategoryAvgOrderByAggregateInput
    _max?: TitleToCategoryMaxOrderByAggregateInput
    _min?: TitleToCategoryMinOrderByAggregateInput
    _sum?: TitleToCategorySumOrderByAggregateInput
  }

  export type TitleToCategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TitleToCategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<TitleToCategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TitleToCategoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    titleId?: IntWithAggregatesFilter | number
    categoryId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type BKAuthorWhereInput = {
    AND?: Enumerable<BKAuthorWhereInput>
    OR?: Enumerable<BKAuthorWhereInput>
    NOT?: Enumerable<BKAuthorWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    titleToAuthors?: TitleToAuthorListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type BKAuthorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    titleToAuthors?: TitleToAuthorOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BKAuthorWhereUniqueInput = {
    id?: number
  }

  export type BKAuthorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BKAuthorCountOrderByAggregateInput
    _avg?: BKAuthorAvgOrderByAggregateInput
    _max?: BKAuthorMaxOrderByAggregateInput
    _min?: BKAuthorMinOrderByAggregateInput
    _sum?: BKAuthorSumOrderByAggregateInput
  }

  export type BKAuthorScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BKAuthorScalarWhereWithAggregatesInput>
    OR?: Enumerable<BKAuthorScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BKAuthorScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TitleToAuthorWhereInput = {
    AND?: Enumerable<TitleToAuthorWhereInput>
    OR?: Enumerable<TitleToAuthorWhereInput>
    NOT?: Enumerable<TitleToAuthorWhereInput>
    id?: IntFilter | number
    title?: XOR<BKTitleRelationFilter, BKTitleWhereInput>
    titleId?: IntFilter | number
    author?: XOR<BKAuthorRelationFilter, BKAuthorWhereInput>
    authorId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TitleToAuthorOrderByWithRelationInput = {
    id?: SortOrder
    title?: BKTitleOrderByWithRelationInput
    titleId?: SortOrder
    author?: BKAuthorOrderByWithRelationInput
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TitleToAuthorWhereUniqueInput = {
    id?: number
  }

  export type TitleToAuthorOrderByWithAggregationInput = {
    id?: SortOrder
    titleId?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TitleToAuthorCountOrderByAggregateInput
    _avg?: TitleToAuthorAvgOrderByAggregateInput
    _max?: TitleToAuthorMaxOrderByAggregateInput
    _min?: TitleToAuthorMinOrderByAggregateInput
    _sum?: TitleToAuthorSumOrderByAggregateInput
  }

  export type TitleToAuthorScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TitleToAuthorScalarWhereWithAggregatesInput>
    OR?: Enumerable<TitleToAuthorScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TitleToAuthorScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    titleId?: IntWithAggregatesFilter | number
    authorId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FbUserWhereInput = {
    AND?: Enumerable<FbUserWhereInput>
    OR?: Enumerable<FbUserWhereInput>
    NOT?: Enumerable<FbUserWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    image?: StringFilter | string
    location?: StringFilter | string
    posts?: FbPostListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    acceptFbFriends?: FbfriendListRelationFilter
    requestFbFriends?: FbfriendListRelationFilter
    likes?: FbLikeListRelationFilter
    fromMessengers?: FbMessengerListRelationFilter
    toMessengers?: FbMessengerListRelationFilter
    shares?: FbShareListRelationFilter
    comments?: FbCommentListRelationFilter
    groupToUsers?: GroupToUserListRelationFilter
  }

  export type FbUserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    location?: SortOrder
    posts?: FbPostOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
    acceptFbFriends?: FbfriendOrderByRelationAggregateInput
    requestFbFriends?: FbfriendOrderByRelationAggregateInput
    likes?: FbLikeOrderByRelationAggregateInput
    fromMessengers?: FbMessengerOrderByRelationAggregateInput
    toMessengers?: FbMessengerOrderByRelationAggregateInput
    shares?: FbShareOrderByRelationAggregateInput
    comments?: FbCommentOrderByRelationAggregateInput
    groupToUsers?: GroupToUserOrderByRelationAggregateInput
  }

  export type FbUserWhereUniqueInput = {
    id?: number
  }

  export type FbUserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FbUserCountOrderByAggregateInput
    _avg?: FbUserAvgOrderByAggregateInput
    _max?: FbUserMaxOrderByAggregateInput
    _min?: FbUserMinOrderByAggregateInput
    _sum?: FbUserSumOrderByAggregateInput
  }

  export type FbUserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FbUserScalarWhereWithAggregatesInput>
    OR?: Enumerable<FbUserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FbUserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    image?: StringWithAggregatesFilter | string
    location?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FbPostWhereInput = {
    AND?: Enumerable<FbPostWhereInput>
    OR?: Enumerable<FbPostWhereInput>
    NOT?: Enumerable<FbPostWhereInput>
    id?: IntFilter | number
    caption?: StringFilter | string
    user?: XOR<FbUserRelationFilter, FbUserWhereInput>
    userId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    postImages?: FbPostImageListRelationFilter
    postVideoes?: FbPostVideoListRelationFilter
    postOnHashtags?: FbPostOnHashtagListRelationFilter
    shares?: FbShareListRelationFilter
    likes?: FbLikeListRelationFilter
    wall?: XOR<FbWallRelationFilter, FbWallWhereInput>
    wallId?: IntFilter | number
  }

  export type FbPostOrderByWithRelationInput = {
    id?: SortOrder
    caption?: SortOrder
    user?: FbUserOrderByWithRelationInput
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postImages?: FbPostImageOrderByRelationAggregateInput
    postVideoes?: FbPostVideoOrderByRelationAggregateInput
    postOnHashtags?: FbPostOnHashtagOrderByRelationAggregateInput
    shares?: FbShareOrderByRelationAggregateInput
    likes?: FbLikeOrderByRelationAggregateInput
    wall?: FbWallOrderByWithRelationInput
    wallId?: SortOrder
  }

  export type FbPostWhereUniqueInput = {
    id?: number
  }

  export type FbPostOrderByWithAggregationInput = {
    id?: SortOrder
    caption?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    wallId?: SortOrder
    _count?: FbPostCountOrderByAggregateInput
    _avg?: FbPostAvgOrderByAggregateInput
    _max?: FbPostMaxOrderByAggregateInput
    _min?: FbPostMinOrderByAggregateInput
    _sum?: FbPostSumOrderByAggregateInput
  }

  export type FbPostScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FbPostScalarWhereWithAggregatesInput>
    OR?: Enumerable<FbPostScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FbPostScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    caption?: StringWithAggregatesFilter | string
    userId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    wallId?: IntWithAggregatesFilter | number
  }

  export type FbPostImageWhereInput = {
    AND?: Enumerable<FbPostImageWhereInput>
    OR?: Enumerable<FbPostImageWhereInput>
    NOT?: Enumerable<FbPostImageWhereInput>
    id?: IntFilter | number
    image?: StringFilter | string
    post?: XOR<FbPostRelationFilter, FbPostWhereInput>
    postId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type FbPostImageOrderByWithRelationInput = {
    id?: SortOrder
    image?: SortOrder
    post?: FbPostOrderByWithRelationInput
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FbPostImageWhereUniqueInput = {
    id?: number
  }

  export type FbPostImageOrderByWithAggregationInput = {
    id?: SortOrder
    image?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FbPostImageCountOrderByAggregateInput
    _avg?: FbPostImageAvgOrderByAggregateInput
    _max?: FbPostImageMaxOrderByAggregateInput
    _min?: FbPostImageMinOrderByAggregateInput
    _sum?: FbPostImageSumOrderByAggregateInput
  }

  export type FbPostImageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FbPostImageScalarWhereWithAggregatesInput>
    OR?: Enumerable<FbPostImageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FbPostImageScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    image?: StringWithAggregatesFilter | string
    postId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FbPostVideoWhereInput = {
    AND?: Enumerable<FbPostVideoWhereInput>
    OR?: Enumerable<FbPostVideoWhereInput>
    NOT?: Enumerable<FbPostVideoWhereInput>
    id?: IntFilter | number
    video?: StringFilter | string
    post?: XOR<FbPostRelationFilter, FbPostWhereInput>
    postId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type FbPostVideoOrderByWithRelationInput = {
    id?: SortOrder
    video?: SortOrder
    post?: FbPostOrderByWithRelationInput
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FbPostVideoWhereUniqueInput = {
    id?: number
  }

  export type FbPostVideoOrderByWithAggregationInput = {
    id?: SortOrder
    video?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FbPostVideoCountOrderByAggregateInput
    _avg?: FbPostVideoAvgOrderByAggregateInput
    _max?: FbPostVideoMaxOrderByAggregateInput
    _min?: FbPostVideoMinOrderByAggregateInput
    _sum?: FbPostVideoSumOrderByAggregateInput
  }

  export type FbPostVideoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FbPostVideoScalarWhereWithAggregatesInput>
    OR?: Enumerable<FbPostVideoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FbPostVideoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    video?: StringWithAggregatesFilter | string
    postId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FbHashtagWhereInput = {
    AND?: Enumerable<FbHashtagWhereInput>
    OR?: Enumerable<FbHashtagWhereInput>
    NOT?: Enumerable<FbHashtagWhereInput>
    id?: IntFilter | number
    hashtag?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    postOnHashtags?: FbPostOnHashtagListRelationFilter
  }

  export type FbHashtagOrderByWithRelationInput = {
    id?: SortOrder
    hashtag?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postOnHashtags?: FbPostOnHashtagOrderByRelationAggregateInput
  }

  export type FbHashtagWhereUniqueInput = {
    id?: number
  }

  export type FbHashtagOrderByWithAggregationInput = {
    id?: SortOrder
    hashtag?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FbHashtagCountOrderByAggregateInput
    _avg?: FbHashtagAvgOrderByAggregateInput
    _max?: FbHashtagMaxOrderByAggregateInput
    _min?: FbHashtagMinOrderByAggregateInput
    _sum?: FbHashtagSumOrderByAggregateInput
  }

  export type FbHashtagScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FbHashtagScalarWhereWithAggregatesInput>
    OR?: Enumerable<FbHashtagScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FbHashtagScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    hashtag?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FbPostOnHashtagWhereInput = {
    AND?: Enumerable<FbPostOnHashtagWhereInput>
    OR?: Enumerable<FbPostOnHashtagWhereInput>
    NOT?: Enumerable<FbPostOnHashtagWhereInput>
    id?: IntFilter | number
    post?: XOR<FbPostRelationFilter, FbPostWhereInput>
    postId?: IntFilter | number
    hashtag?: XOR<FbHashtagRelationFilter, FbHashtagWhereInput>
    hashtagId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type FbPostOnHashtagOrderByWithRelationInput = {
    id?: SortOrder
    post?: FbPostOrderByWithRelationInput
    postId?: SortOrder
    hashtag?: FbHashtagOrderByWithRelationInput
    hashtagId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FbPostOnHashtagWhereUniqueInput = {
    id?: number
  }

  export type FbPostOnHashtagOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    hashtagId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FbPostOnHashtagCountOrderByAggregateInput
    _avg?: FbPostOnHashtagAvgOrderByAggregateInput
    _max?: FbPostOnHashtagMaxOrderByAggregateInput
    _min?: FbPostOnHashtagMinOrderByAggregateInput
    _sum?: FbPostOnHashtagSumOrderByAggregateInput
  }

  export type FbPostOnHashtagScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FbPostOnHashtagScalarWhereWithAggregatesInput>
    OR?: Enumerable<FbPostOnHashtagScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FbPostOnHashtagScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    postId?: IntWithAggregatesFilter | number
    hashtagId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FbLikeWhereInput = {
    AND?: Enumerable<FbLikeWhereInput>
    OR?: Enumerable<FbLikeWhereInput>
    NOT?: Enumerable<FbLikeWhereInput>
    id?: IntFilter | number
    user?: XOR<FbUserRelationFilter, FbUserWhereInput>
    userId?: IntFilter | number
    post?: XOR<FbPostRelationFilter, FbPostWhereInput>
    postId?: IntFilter | number
    comment?: XOR<FbCommentRelationFilter, FbCommentWhereInput>
    commentId?: IntFilter | number
    share?: XOR<FbShareRelationFilter, FbShareWhereInput>
    shareId?: IntFilter | number
    likeType?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type FbLikeOrderByWithRelationInput = {
    id?: SortOrder
    user?: FbUserOrderByWithRelationInput
    userId?: SortOrder
    post?: FbPostOrderByWithRelationInput
    postId?: SortOrder
    comment?: FbCommentOrderByWithRelationInput
    commentId?: SortOrder
    share?: FbShareOrderByWithRelationInput
    shareId?: SortOrder
    likeType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FbLikeWhereUniqueInput = {
    id?: number
  }

  export type FbLikeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    commentId?: SortOrder
    shareId?: SortOrder
    likeType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FbLikeCountOrderByAggregateInput
    _avg?: FbLikeAvgOrderByAggregateInput
    _max?: FbLikeMaxOrderByAggregateInput
    _min?: FbLikeMinOrderByAggregateInput
    _sum?: FbLikeSumOrderByAggregateInput
  }

  export type FbLikeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FbLikeScalarWhereWithAggregatesInput>
    OR?: Enumerable<FbLikeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FbLikeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    postId?: IntWithAggregatesFilter | number
    commentId?: IntWithAggregatesFilter | number
    shareId?: IntWithAggregatesFilter | number
    likeType?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FbShareWhereInput = {
    AND?: Enumerable<FbShareWhereInput>
    OR?: Enumerable<FbShareWhereInput>
    NOT?: Enumerable<FbShareWhereInput>
    id?: IntFilter | number
    user?: XOR<FbUserRelationFilter, FbUserWhereInput>
    userId?: IntFilter | number
    post?: XOR<FbPostRelationFilter, FbPostWhereInput>
    postId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    likes?: FbLikeListRelationFilter
    destinationUsers?: FbDestinationUserListRelationFilter
  }

  export type FbShareOrderByWithRelationInput = {
    id?: SortOrder
    user?: FbUserOrderByWithRelationInput
    userId?: SortOrder
    post?: FbPostOrderByWithRelationInput
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    likes?: FbLikeOrderByRelationAggregateInput
    destinationUsers?: FbDestinationUserOrderByRelationAggregateInput
  }

  export type FbShareWhereUniqueInput = {
    id?: number
  }

  export type FbShareOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FbShareCountOrderByAggregateInput
    _avg?: FbShareAvgOrderByAggregateInput
    _max?: FbShareMaxOrderByAggregateInput
    _min?: FbShareMinOrderByAggregateInput
    _sum?: FbShareSumOrderByAggregateInput
  }

  export type FbShareScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FbShareScalarWhereWithAggregatesInput>
    OR?: Enumerable<FbShareScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FbShareScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    postId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FbfriendWhereInput = {
    AND?: Enumerable<FbfriendWhereInput>
    OR?: Enumerable<FbfriendWhereInput>
    NOT?: Enumerable<FbfriendWhereInput>
    id?: IntFilter | number
    acceptFriend?: XOR<FbUserRelationFilter, FbUserWhereInput>
    acceptId?: IntFilter | number
    requestFriend?: XOR<FbUserRelationFilter, FbUserWhereInput>
    requestId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type FbfriendOrderByWithRelationInput = {
    id?: SortOrder
    acceptFriend?: FbUserOrderByWithRelationInput
    acceptId?: SortOrder
    requestFriend?: FbUserOrderByWithRelationInput
    requestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FbfriendWhereUniqueInput = {
    id?: number
  }

  export type FbfriendOrderByWithAggregationInput = {
    id?: SortOrder
    acceptId?: SortOrder
    requestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FbfriendCountOrderByAggregateInput
    _avg?: FbfriendAvgOrderByAggregateInput
    _max?: FbfriendMaxOrderByAggregateInput
    _min?: FbfriendMinOrderByAggregateInput
    _sum?: FbfriendSumOrderByAggregateInput
  }

  export type FbfriendScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FbfriendScalarWhereWithAggregatesInput>
    OR?: Enumerable<FbfriendScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FbfriendScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    acceptId?: IntWithAggregatesFilter | number
    requestId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FbMessengerWhereInput = {
    AND?: Enumerable<FbMessengerWhereInput>
    OR?: Enumerable<FbMessengerWhereInput>
    NOT?: Enumerable<FbMessengerWhereInput>
    id?: IntFilter | number
    from?: XOR<FbUserRelationFilter, FbUserWhereInput>
    fromuserId?: IntFilter | number
    to?: XOR<FbUserRelationFilter, FbUserWhereInput>
    toUserId?: IntFilter | number
    text?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type FbMessengerOrderByWithRelationInput = {
    id?: SortOrder
    from?: FbUserOrderByWithRelationInput
    fromuserId?: SortOrder
    to?: FbUserOrderByWithRelationInput
    toUserId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FbMessengerWhereUniqueInput = {
    id?: number
  }

  export type FbMessengerOrderByWithAggregationInput = {
    id?: SortOrder
    fromuserId?: SortOrder
    toUserId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FbMessengerCountOrderByAggregateInput
    _avg?: FbMessengerAvgOrderByAggregateInput
    _max?: FbMessengerMaxOrderByAggregateInput
    _min?: FbMessengerMinOrderByAggregateInput
    _sum?: FbMessengerSumOrderByAggregateInput
  }

  export type FbMessengerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FbMessengerScalarWhereWithAggregatesInput>
    OR?: Enumerable<FbMessengerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FbMessengerScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    fromuserId?: IntWithAggregatesFilter | number
    toUserId?: IntWithAggregatesFilter | number
    text?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FbCommentWhereInput = {
    AND?: Enumerable<FbCommentWhereInput>
    OR?: Enumerable<FbCommentWhereInput>
    NOT?: Enumerable<FbCommentWhereInput>
    id?: IntFilter | number
    text?: StringFilter | string
    user?: XOR<FbUserRelationFilter, FbUserWhereInput>
    userId?: IntFilter | number
    likes?: FbLikeListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type FbCommentOrderByWithRelationInput = {
    id?: SortOrder
    text?: SortOrder
    user?: FbUserOrderByWithRelationInput
    userId?: SortOrder
    likes?: FbLikeOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FbCommentWhereUniqueInput = {
    id?: number
  }

  export type FbCommentOrderByWithAggregationInput = {
    id?: SortOrder
    text?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FbCommentCountOrderByAggregateInput
    _avg?: FbCommentAvgOrderByAggregateInput
    _max?: FbCommentMaxOrderByAggregateInput
    _min?: FbCommentMinOrderByAggregateInput
    _sum?: FbCommentSumOrderByAggregateInput
  }

  export type FbCommentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FbCommentScalarWhereWithAggregatesInput>
    OR?: Enumerable<FbCommentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FbCommentScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    text?: StringWithAggregatesFilter | string
    userId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FbGroupWhereInput = {
    AND?: Enumerable<FbGroupWhereInput>
    OR?: Enumerable<FbGroupWhereInput>
    NOT?: Enumerable<FbGroupWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    groupToUsers?: GroupToUserListRelationFilter
    destinationUsers?: FbDestinationUserListRelationFilter
  }

  export type FbGroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    groupToUsers?: GroupToUserOrderByRelationAggregateInput
    destinationUsers?: FbDestinationUserOrderByRelationAggregateInput
  }

  export type FbGroupWhereUniqueInput = {
    id?: number
  }

  export type FbGroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FbGroupCountOrderByAggregateInput
    _avg?: FbGroupAvgOrderByAggregateInput
    _max?: FbGroupMaxOrderByAggregateInput
    _min?: FbGroupMinOrderByAggregateInput
    _sum?: FbGroupSumOrderByAggregateInput
  }

  export type FbGroupScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FbGroupScalarWhereWithAggregatesInput>
    OR?: Enumerable<FbGroupScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FbGroupScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type GroupToUserWhereInput = {
    AND?: Enumerable<GroupToUserWhereInput>
    OR?: Enumerable<GroupToUserWhereInput>
    NOT?: Enumerable<GroupToUserWhereInput>
    id?: IntFilter | number
    user?: XOR<FbUserRelationFilter, FbUserWhereInput>
    userId?: IntFilter | number
    group?: XOR<FbGroupRelationFilter, FbGroupWhereInput>
    groupId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type GroupToUserOrderByWithRelationInput = {
    id?: SortOrder
    user?: FbUserOrderByWithRelationInput
    userId?: SortOrder
    group?: FbGroupOrderByWithRelationInput
    groupId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupToUserWhereUniqueInput = {
    id?: number
  }

  export type GroupToUserOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GroupToUserCountOrderByAggregateInput
    _avg?: GroupToUserAvgOrderByAggregateInput
    _max?: GroupToUserMaxOrderByAggregateInput
    _min?: GroupToUserMinOrderByAggregateInput
    _sum?: GroupToUserSumOrderByAggregateInput
  }

  export type GroupToUserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<GroupToUserScalarWhereWithAggregatesInput>
    OR?: Enumerable<GroupToUserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<GroupToUserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    groupId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FbWallWhereInput = {
    AND?: Enumerable<FbWallWhereInput>
    OR?: Enumerable<FbWallWhereInput>
    NOT?: Enumerable<FbWallWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    posts?: FbPostListRelationFilter
    destinationUsers?: FbDestinationUserListRelationFilter
  }

  export type FbWallOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    posts?: FbPostOrderByRelationAggregateInput
    destinationUsers?: FbDestinationUserOrderByRelationAggregateInput
  }

  export type FbWallWhereUniqueInput = {
    id?: number
  }

  export type FbWallOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FbWallCountOrderByAggregateInput
    _avg?: FbWallAvgOrderByAggregateInput
    _max?: FbWallMaxOrderByAggregateInput
    _min?: FbWallMinOrderByAggregateInput
    _sum?: FbWallSumOrderByAggregateInput
  }

  export type FbWallScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FbWallScalarWhereWithAggregatesInput>
    OR?: Enumerable<FbWallScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FbWallScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FbDestinationUserWhereInput = {
    AND?: Enumerable<FbDestinationUserWhereInput>
    OR?: Enumerable<FbDestinationUserWhereInput>
    NOT?: Enumerable<FbDestinationUserWhereInput>
    id?: IntFilter | number
    wall?: XOR<FbWallRelationFilter, FbWallWhereInput>
    fbWallId?: IntFilter | number
    share?: XOR<FbShareRelationFilter, FbShareWhereInput>
    shareId?: IntFilter | number
    group?: XOR<FbGroupRelationFilter, FbGroupWhereInput>
    groupId?: IntFilter | number
  }

  export type FbDestinationUserOrderByWithRelationInput = {
    id?: SortOrder
    wall?: FbWallOrderByWithRelationInput
    fbWallId?: SortOrder
    share?: FbShareOrderByWithRelationInput
    shareId?: SortOrder
    group?: FbGroupOrderByWithRelationInput
    groupId?: SortOrder
  }

  export type FbDestinationUserWhereUniqueInput = {
    id?: number
  }

  export type FbDestinationUserOrderByWithAggregationInput = {
    id?: SortOrder
    fbWallId?: SortOrder
    shareId?: SortOrder
    groupId?: SortOrder
    _count?: FbDestinationUserCountOrderByAggregateInput
    _avg?: FbDestinationUserAvgOrderByAggregateInput
    _max?: FbDestinationUserMaxOrderByAggregateInput
    _min?: FbDestinationUserMinOrderByAggregateInput
    _sum?: FbDestinationUserSumOrderByAggregateInput
  }

  export type FbDestinationUserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FbDestinationUserScalarWhereWithAggregatesInput>
    OR?: Enumerable<FbDestinationUserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FbDestinationUserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    fbWallId?: IntWithAggregatesFilter | number
    shareId?: IntWithAggregatesFilter | number
    groupId?: IntWithAggregatesFilter | number
  }

  export type KorKitchenCategoryWhereInput = {
    AND?: Enumerable<KorKitchenCategoryWhereInput>
    OR?: Enumerable<KorKitchenCategoryWhereInput>
    NOT?: Enumerable<KorKitchenCategoryWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    menu?: KorKitchenMenuListRelationFilter
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type KorKitchenCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    menu?: KorKitchenMenuOrderByRelationAggregateInput
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type KorKitchenCategoryWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type KorKitchenCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    _count?: KorKitchenCategoryCountOrderByAggregateInput
    _avg?: KorKitchenCategoryAvgOrderByAggregateInput
    _max?: KorKitchenCategoryMaxOrderByAggregateInput
    _min?: KorKitchenCategoryMinOrderByAggregateInput
    _sum?: KorKitchenCategorySumOrderByAggregateInput
  }

  export type KorKitchenCategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<KorKitchenCategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<KorKitchenCategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<KorKitchenCategoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type KorKitchenMenuWhereInput = {
    AND?: Enumerable<KorKitchenMenuWhereInput>
    OR?: Enumerable<KorKitchenMenuWhereInput>
    NOT?: Enumerable<KorKitchenMenuWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    image?: StringFilter | string
    price?: FloatFilter | number
    category?: XOR<KorKitchenCategoryRelationFilter, KorKitchenCategoryWhereInput> | null
    categoryName?: StringNullableFilter | string | null
    orderItems?: KorKitchenOrderItemListRelationFilter
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type KorKitchenMenuOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    price?: SortOrder
    category?: KorKitchenCategoryOrderByWithRelationInput
    categoryName?: SortOrder
    orderItems?: KorKitchenOrderItemOrderByRelationAggregateInput
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type KorKitchenMenuWhereUniqueInput = {
    id?: number
  }

  export type KorKitchenMenuOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    price?: SortOrder
    categoryName?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    _count?: KorKitchenMenuCountOrderByAggregateInput
    _avg?: KorKitchenMenuAvgOrderByAggregateInput
    _max?: KorKitchenMenuMaxOrderByAggregateInput
    _min?: KorKitchenMenuMinOrderByAggregateInput
    _sum?: KorKitchenMenuSumOrderByAggregateInput
  }

  export type KorKitchenMenuScalarWhereWithAggregatesInput = {
    AND?: Enumerable<KorKitchenMenuScalarWhereWithAggregatesInput>
    OR?: Enumerable<KorKitchenMenuScalarWhereWithAggregatesInput>
    NOT?: Enumerable<KorKitchenMenuScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    image?: StringWithAggregatesFilter | string
    price?: FloatWithAggregatesFilter | number
    categoryName?: StringNullableWithAggregatesFilter | string | null
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type KorKitchenOrderWhereInput = {
    AND?: Enumerable<KorKitchenOrderWhereInput>
    OR?: Enumerable<KorKitchenOrderWhereInput>
    NOT?: Enumerable<KorKitchenOrderWhereInput>
    id?: IntFilter | number
    status?: StringFilter | string
    tableId?: IntFilter | number
    items?: KorKitchenOrderItemListRelationFilter
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type KorKitchenOrderOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    tableId?: SortOrder
    items?: KorKitchenOrderItemOrderByRelationAggregateInput
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type KorKitchenOrderWhereUniqueInput = {
    id?: number
  }

  export type KorKitchenOrderOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    tableId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    _count?: KorKitchenOrderCountOrderByAggregateInput
    _avg?: KorKitchenOrderAvgOrderByAggregateInput
    _max?: KorKitchenOrderMaxOrderByAggregateInput
    _min?: KorKitchenOrderMinOrderByAggregateInput
    _sum?: KorKitchenOrderSumOrderByAggregateInput
  }

  export type KorKitchenOrderScalarWhereWithAggregatesInput = {
    AND?: Enumerable<KorKitchenOrderScalarWhereWithAggregatesInput>
    OR?: Enumerable<KorKitchenOrderScalarWhereWithAggregatesInput>
    NOT?: Enumerable<KorKitchenOrderScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    status?: StringWithAggregatesFilter | string
    tableId?: IntWithAggregatesFilter | number
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type KorKitchenOrderItemWhereInput = {
    AND?: Enumerable<KorKitchenOrderItemWhereInput>
    OR?: Enumerable<KorKitchenOrderItemWhereInput>
    NOT?: Enumerable<KorKitchenOrderItemWhereInput>
    id?: IntFilter | number
    menu?: XOR<KorKitchenMenuRelationFilter, KorKitchenMenuWhereInput>
    menuId?: IntFilter | number
    order?: XOR<KorKitchenOrderRelationFilter, KorKitchenOrderWhereInput> | null
    orderId?: IntNullableFilter | number | null
    quantity?: IntFilter | number
    totalPrice?: FloatFilter | number
    creatAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type KorKitchenOrderItemOrderByWithRelationInput = {
    id?: SortOrder
    menu?: KorKitchenMenuOrderByWithRelationInput
    menuId?: SortOrder
    order?: KorKitchenOrderOrderByWithRelationInput
    orderId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    creatAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KorKitchenOrderItemWhereUniqueInput = {
    id?: number
  }

  export type KorKitchenOrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    menuId?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    creatAt?: SortOrder
    updatedAt?: SortOrder
    _count?: KorKitchenOrderItemCountOrderByAggregateInput
    _avg?: KorKitchenOrderItemAvgOrderByAggregateInput
    _max?: KorKitchenOrderItemMaxOrderByAggregateInput
    _min?: KorKitchenOrderItemMinOrderByAggregateInput
    _sum?: KorKitchenOrderItemSumOrderByAggregateInput
  }

  export type KorKitchenOrderItemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<KorKitchenOrderItemScalarWhereWithAggregatesInput>
    OR?: Enumerable<KorKitchenOrderItemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<KorKitchenOrderItemScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    menuId?: IntWithAggregatesFilter | number
    orderId?: IntNullableWithAggregatesFilter | number | null
    quantity?: IntWithAggregatesFilter | number
    totalPrice?: FloatWithAggregatesFilter | number
    creatAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TodoListWhereInput = {
    AND?: Enumerable<TodoListWhereInput>
    OR?: Enumerable<TodoListWhereInput>
    NOT?: Enumerable<TodoListWhereInput>
    id?: IntFilter | number
    task?: StringFilter | string
    status?: StringFilter | string
    note?: StringNullableFilter | string | null
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type TodoListOrderByWithRelationInput = {
    id?: SortOrder
    task?: SortOrder
    status?: SortOrder
    note?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type TodoListWhereUniqueInput = {
    id?: number
  }

  export type TodoListOrderByWithAggregationInput = {
    id?: SortOrder
    task?: SortOrder
    status?: SortOrder
    note?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    _count?: TodoListCountOrderByAggregateInput
    _avg?: TodoListAvgOrderByAggregateInput
    _max?: TodoListMaxOrderByAggregateInput
    _min?: TodoListMinOrderByAggregateInput
    _sum?: TodoListSumOrderByAggregateInput
  }

  export type TodoListScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TodoListScalarWhereWithAggregatesInput>
    OR?: Enumerable<TodoListScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TodoListScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    task?: StringWithAggregatesFilter | string
    status?: StringWithAggregatesFilter | string
    note?: StringNullableWithAggregatesFilter | string | null
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TestModelWhereInput = {
    AND?: Enumerable<TestModelWhereInput>
    OR?: Enumerable<TestModelWhereInput>
    NOT?: Enumerable<TestModelWhereInput>
    id?: IntFilter | number
    firstname?: StringFilter | string
    Surname?: StringFilter | string
  }

  export type TestModelOrderByWithRelationInput = {
    id?: SortOrder
    firstname?: SortOrder
    Surname?: SortOrder
  }

  export type TestModelWhereUniqueInput = {
    id?: number
  }

  export type TestModelOrderByWithAggregationInput = {
    id?: SortOrder
    firstname?: SortOrder
    Surname?: SortOrder
    _count?: TestModelCountOrderByAggregateInput
    _avg?: TestModelAvgOrderByAggregateInput
    _max?: TestModelMaxOrderByAggregateInput
    _min?: TestModelMinOrderByAggregateInput
    _sum?: TestModelSumOrderByAggregateInput
  }

  export type TestModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TestModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<TestModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TestModelScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    firstname?: StringWithAggregatesFilter | string
    Surname?: StringWithAggregatesFilter | string
  }

  export type TriviaCategoryWhereInput = {
    AND?: Enumerable<TriviaCategoryWhereInput>
    OR?: Enumerable<TriviaCategoryWhereInput>
    NOT?: Enumerable<TriviaCategoryWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    questions?: TriviaQuestionListRelationFilter
    rounds?: TriviaRoundListRelationFilter
  }

  export type TriviaCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    questions?: TriviaQuestionOrderByRelationAggregateInput
    rounds?: TriviaRoundOrderByRelationAggregateInput
  }

  export type TriviaCategoryWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type TriviaCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: TriviaCategoryCountOrderByAggregateInput
    _avg?: TriviaCategoryAvgOrderByAggregateInput
    _max?: TriviaCategoryMaxOrderByAggregateInput
    _min?: TriviaCategoryMinOrderByAggregateInput
    _sum?: TriviaCategorySumOrderByAggregateInput
  }

  export type TriviaCategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TriviaCategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<TriviaCategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TriviaCategoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
  }

  export type TriviaQuestionWhereInput = {
    AND?: Enumerable<TriviaQuestionWhereInput>
    OR?: Enumerable<TriviaQuestionWhereInput>
    NOT?: Enumerable<TriviaQuestionWhereInput>
    id?: IntFilter | number
    category?: XOR<TriviaCategoryRelationFilter, TriviaCategoryWhereInput>
    categoryId?: IntFilter | number
    name?: StringFilter | string
    answerID?: IntFilter | number
    choices?: TriviaChoiceListRelationFilter
    roundQuestions?: TriviaRoundQuestionListRelationFilter
  }

  export type TriviaQuestionOrderByWithRelationInput = {
    id?: SortOrder
    category?: TriviaCategoryOrderByWithRelationInput
    categoryId?: SortOrder
    name?: SortOrder
    answerID?: SortOrder
    choices?: TriviaChoiceOrderByRelationAggregateInput
    roundQuestions?: TriviaRoundQuestionOrderByRelationAggregateInput
  }

  export type TriviaQuestionWhereUniqueInput = {
    id?: number
  }

  export type TriviaQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    answerID?: SortOrder
    _count?: TriviaQuestionCountOrderByAggregateInput
    _avg?: TriviaQuestionAvgOrderByAggregateInput
    _max?: TriviaQuestionMaxOrderByAggregateInput
    _min?: TriviaQuestionMinOrderByAggregateInput
    _sum?: TriviaQuestionSumOrderByAggregateInput
  }

  export type TriviaQuestionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TriviaQuestionScalarWhereWithAggregatesInput>
    OR?: Enumerable<TriviaQuestionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TriviaQuestionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    categoryId?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    answerID?: IntWithAggregatesFilter | number
  }

  export type TriviaChoiceWhereInput = {
    AND?: Enumerable<TriviaChoiceWhereInput>
    OR?: Enumerable<TriviaChoiceWhereInput>
    NOT?: Enumerable<TriviaChoiceWhereInput>
    id?: IntFilter | number
    question?: XOR<TriviaQuestionRelationFilter, TriviaQuestionWhereInput>
    quizId?: IntFilter | number
    name?: StringFilter | string
    roundQuestions?: TriviaRoundQuestionListRelationFilter
  }

  export type TriviaChoiceOrderByWithRelationInput = {
    id?: SortOrder
    question?: TriviaQuestionOrderByWithRelationInput
    quizId?: SortOrder
    name?: SortOrder
    roundQuestions?: TriviaRoundQuestionOrderByRelationAggregateInput
  }

  export type TriviaChoiceWhereUniqueInput = {
    id?: number
  }

  export type TriviaChoiceOrderByWithAggregationInput = {
    id?: SortOrder
    quizId?: SortOrder
    name?: SortOrder
    _count?: TriviaChoiceCountOrderByAggregateInput
    _avg?: TriviaChoiceAvgOrderByAggregateInput
    _max?: TriviaChoiceMaxOrderByAggregateInput
    _min?: TriviaChoiceMinOrderByAggregateInput
    _sum?: TriviaChoiceSumOrderByAggregateInput
  }

  export type TriviaChoiceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TriviaChoiceScalarWhereWithAggregatesInput>
    OR?: Enumerable<TriviaChoiceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TriviaChoiceScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    quizId?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
  }

  export type TriviaRoundQuestionWhereInput = {
    AND?: Enumerable<TriviaRoundQuestionWhereInput>
    OR?: Enumerable<TriviaRoundQuestionWhereInput>
    NOT?: Enumerable<TriviaRoundQuestionWhereInput>
    id?: IntFilter | number
    question?: XOR<TriviaQuestionRelationFilter, TriviaQuestionWhereInput>
    quizId?: IntFilter | number
    userChoice?: XOR<TriviaChoiceRelationFilter, TriviaChoiceWhereInput>
    choiceId?: IntFilter | number
    quizResult?: BoolFilter | boolean
    round?: XOR<TriviaRoundRelationFilter, TriviaRoundWhereInput> | null
    roundId?: IntNullableFilter | number | null
  }

  export type TriviaRoundQuestionOrderByWithRelationInput = {
    id?: SortOrder
    question?: TriviaQuestionOrderByWithRelationInput
    quizId?: SortOrder
    userChoice?: TriviaChoiceOrderByWithRelationInput
    choiceId?: SortOrder
    quizResult?: SortOrder
    round?: TriviaRoundOrderByWithRelationInput
    roundId?: SortOrder
  }

  export type TriviaRoundQuestionWhereUniqueInput = {
    id?: number
  }

  export type TriviaRoundQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    quizId?: SortOrder
    choiceId?: SortOrder
    quizResult?: SortOrder
    roundId?: SortOrder
    _count?: TriviaRoundQuestionCountOrderByAggregateInput
    _avg?: TriviaRoundQuestionAvgOrderByAggregateInput
    _max?: TriviaRoundQuestionMaxOrderByAggregateInput
    _min?: TriviaRoundQuestionMinOrderByAggregateInput
    _sum?: TriviaRoundQuestionSumOrderByAggregateInput
  }

  export type TriviaRoundQuestionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TriviaRoundQuestionScalarWhereWithAggregatesInput>
    OR?: Enumerable<TriviaRoundQuestionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TriviaRoundQuestionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    quizId?: IntWithAggregatesFilter | number
    choiceId?: IntWithAggregatesFilter | number
    quizResult?: BoolWithAggregatesFilter | boolean
    roundId?: IntNullableWithAggregatesFilter | number | null
  }

  export type TriviaRoundWhereInput = {
    AND?: Enumerable<TriviaRoundWhereInput>
    OR?: Enumerable<TriviaRoundWhereInput>
    NOT?: Enumerable<TriviaRoundWhereInput>
    id?: IntFilter | number
    user?: StringFilter | string
    questions?: TriviaRoundQuestionListRelationFilter
    category?: XOR<TriviaCategoryRelationFilter, TriviaCategoryWhereInput>
    categoryId?: IntFilter | number
    totalResult?: IntFilter | number
    createAt?: DateTimeFilter | Date | string
  }

  export type TriviaRoundOrderByWithRelationInput = {
    id?: SortOrder
    user?: SortOrder
    questions?: TriviaRoundQuestionOrderByRelationAggregateInput
    category?: TriviaCategoryOrderByWithRelationInput
    categoryId?: SortOrder
    totalResult?: SortOrder
    createAt?: SortOrder
  }

  export type TriviaRoundWhereUniqueInput = {
    id?: number
  }

  export type TriviaRoundOrderByWithAggregationInput = {
    id?: SortOrder
    user?: SortOrder
    categoryId?: SortOrder
    totalResult?: SortOrder
    createAt?: SortOrder
    _count?: TriviaRoundCountOrderByAggregateInput
    _avg?: TriviaRoundAvgOrderByAggregateInput
    _max?: TriviaRoundMaxOrderByAggregateInput
    _min?: TriviaRoundMinOrderByAggregateInput
    _sum?: TriviaRoundSumOrderByAggregateInput
  }

  export type TriviaRoundScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TriviaRoundScalarWhereWithAggregatesInput>
    OR?: Enumerable<TriviaRoundScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TriviaRoundScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    user?: StringWithAggregatesFilter | string
    categoryId?: IntWithAggregatesFilter | number
    totalResult?: IntWithAggregatesFilter | number
    createAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TwitterUserWhereInput = {
    AND?: Enumerable<TwitterUserWhereInput>
    OR?: Enumerable<TwitterUserWhereInput>
    NOT?: Enumerable<TwitterUserWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    Image?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    fromFollowing?: TwitterFollowListRelationFilter
    toFollowing?: TwitterFollowListRelationFilter
    posts?: TwitterPostListRelationFilter
    fromDirectMessage?: TwitterDirectMessageListRelationFilter
    toDirectMessage?: TwitterDirectMessageListRelationFilter
    comments?: TwitterCommentListRelationFilter
  }

  export type TwitterUserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    Image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fromFollowing?: TwitterFollowOrderByRelationAggregateInput
    toFollowing?: TwitterFollowOrderByRelationAggregateInput
    posts?: TwitterPostOrderByRelationAggregateInput
    fromDirectMessage?: TwitterDirectMessageOrderByRelationAggregateInput
    toDirectMessage?: TwitterDirectMessageOrderByRelationAggregateInput
    comments?: TwitterCommentOrderByRelationAggregateInput
  }

  export type TwitterUserWhereUniqueInput = {
    id?: number
  }

  export type TwitterUserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    Image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TwitterUserCountOrderByAggregateInput
    _avg?: TwitterUserAvgOrderByAggregateInput
    _max?: TwitterUserMaxOrderByAggregateInput
    _min?: TwitterUserMinOrderByAggregateInput
    _sum?: TwitterUserSumOrderByAggregateInput
  }

  export type TwitterUserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TwitterUserScalarWhereWithAggregatesInput>
    OR?: Enumerable<TwitterUserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TwitterUserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    Image?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TwitterFollowWhereInput = {
    AND?: Enumerable<TwitterFollowWhereInput>
    OR?: Enumerable<TwitterFollowWhereInput>
    NOT?: Enumerable<TwitterFollowWhereInput>
    id?: IntFilter | number
    from?: XOR<TwitterUserRelationFilter, TwitterUserWhereInput>
    fromUserId?: IntFilter | number
    to?: XOR<TwitterUserRelationFilter, TwitterUserWhereInput>
    toUserId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TwitterFollowOrderByWithRelationInput = {
    id?: SortOrder
    from?: TwitterUserOrderByWithRelationInput
    fromUserId?: SortOrder
    to?: TwitterUserOrderByWithRelationInput
    toUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterFollowWhereUniqueInput = {
    id?: number
  }

  export type TwitterFollowOrderByWithAggregationInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TwitterFollowCountOrderByAggregateInput
    _avg?: TwitterFollowAvgOrderByAggregateInput
    _max?: TwitterFollowMaxOrderByAggregateInput
    _min?: TwitterFollowMinOrderByAggregateInput
    _sum?: TwitterFollowSumOrderByAggregateInput
  }

  export type TwitterFollowScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TwitterFollowScalarWhereWithAggregatesInput>
    OR?: Enumerable<TwitterFollowScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TwitterFollowScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    fromUserId?: IntWithAggregatesFilter | number
    toUserId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TwitterPostWhereInput = {
    AND?: Enumerable<TwitterPostWhereInput>
    OR?: Enumerable<TwitterPostWhereInput>
    NOT?: Enumerable<TwitterPostWhereInput>
    id?: IntFilter | number
    caption?: StringFilter | string
    user?: XOR<TwitterUserRelationFilter, TwitterUserWhereInput>
    userId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    comments?: TwitterCommentListRelationFilter
    postOnHashtags?: TwitterPostOnHashtagListRelationFilter
  }

  export type TwitterPostOrderByWithRelationInput = {
    id?: SortOrder
    caption?: SortOrder
    user?: TwitterUserOrderByWithRelationInput
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    comments?: TwitterCommentOrderByRelationAggregateInput
    postOnHashtags?: TwitterPostOnHashtagOrderByRelationAggregateInput
  }

  export type TwitterPostWhereUniqueInput = {
    id?: number
  }

  export type TwitterPostOrderByWithAggregationInput = {
    id?: SortOrder
    caption?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TwitterPostCountOrderByAggregateInput
    _avg?: TwitterPostAvgOrderByAggregateInput
    _max?: TwitterPostMaxOrderByAggregateInput
    _min?: TwitterPostMinOrderByAggregateInput
    _sum?: TwitterPostSumOrderByAggregateInput
  }

  export type TwitterPostScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TwitterPostScalarWhereWithAggregatesInput>
    OR?: Enumerable<TwitterPostScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TwitterPostScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    caption?: StringWithAggregatesFilter | string
    userId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TwitterDirectMessageWhereInput = {
    AND?: Enumerable<TwitterDirectMessageWhereInput>
    OR?: Enumerable<TwitterDirectMessageWhereInput>
    NOT?: Enumerable<TwitterDirectMessageWhereInput>
    id?: IntFilter | number
    from?: XOR<TwitterUserRelationFilter, TwitterUserWhereInput>
    fromUserId?: IntFilter | number
    to?: XOR<TwitterUserRelationFilter, TwitterUserWhereInput>
    toUserId?: IntFilter | number
    text?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TwitterDirectMessageOrderByWithRelationInput = {
    id?: SortOrder
    from?: TwitterUserOrderByWithRelationInput
    fromUserId?: SortOrder
    to?: TwitterUserOrderByWithRelationInput
    toUserId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterDirectMessageWhereUniqueInput = {
    id?: number
  }

  export type TwitterDirectMessageOrderByWithAggregationInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TwitterDirectMessageCountOrderByAggregateInput
    _avg?: TwitterDirectMessageAvgOrderByAggregateInput
    _max?: TwitterDirectMessageMaxOrderByAggregateInput
    _min?: TwitterDirectMessageMinOrderByAggregateInput
    _sum?: TwitterDirectMessageSumOrderByAggregateInput
  }

  export type TwitterDirectMessageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TwitterDirectMessageScalarWhereWithAggregatesInput>
    OR?: Enumerable<TwitterDirectMessageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TwitterDirectMessageScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    fromUserId?: IntWithAggregatesFilter | number
    toUserId?: IntWithAggregatesFilter | number
    text?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TwitterHashtagWhereInput = {
    AND?: Enumerable<TwitterHashtagWhereInput>
    OR?: Enumerable<TwitterHashtagWhereInput>
    NOT?: Enumerable<TwitterHashtagWhereInput>
    id?: IntFilter | number
    hashtag?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    postOnHashtag?: TwitterPostOnHashtagListRelationFilter
  }

  export type TwitterHashtagOrderByWithRelationInput = {
    id?: SortOrder
    hashtag?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postOnHashtag?: TwitterPostOnHashtagOrderByRelationAggregateInput
  }

  export type TwitterHashtagWhereUniqueInput = {
    id?: number
  }

  export type TwitterHashtagOrderByWithAggregationInput = {
    id?: SortOrder
    hashtag?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TwitterHashtagCountOrderByAggregateInput
    _avg?: TwitterHashtagAvgOrderByAggregateInput
    _max?: TwitterHashtagMaxOrderByAggregateInput
    _min?: TwitterHashtagMinOrderByAggregateInput
    _sum?: TwitterHashtagSumOrderByAggregateInput
  }

  export type TwitterHashtagScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TwitterHashtagScalarWhereWithAggregatesInput>
    OR?: Enumerable<TwitterHashtagScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TwitterHashtagScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    hashtag?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TwitterCommentWhereInput = {
    AND?: Enumerable<TwitterCommentWhereInput>
    OR?: Enumerable<TwitterCommentWhereInput>
    NOT?: Enumerable<TwitterCommentWhereInput>
    id?: IntFilter | number
    text?: StringFilter | string
    user?: XOR<TwitterUserRelationFilter, TwitterUserWhereInput>
    userId?: IntFilter | number
    post?: XOR<TwitterPostRelationFilter, TwitterPostWhereInput>
    postId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TwitterCommentOrderByWithRelationInput = {
    id?: SortOrder
    text?: SortOrder
    user?: TwitterUserOrderByWithRelationInput
    userId?: SortOrder
    post?: TwitterPostOrderByWithRelationInput
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterCommentWhereUniqueInput = {
    id?: number
  }

  export type TwitterCommentOrderByWithAggregationInput = {
    id?: SortOrder
    text?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TwitterCommentCountOrderByAggregateInput
    _avg?: TwitterCommentAvgOrderByAggregateInput
    _max?: TwitterCommentMaxOrderByAggregateInput
    _min?: TwitterCommentMinOrderByAggregateInput
    _sum?: TwitterCommentSumOrderByAggregateInput
  }

  export type TwitterCommentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TwitterCommentScalarWhereWithAggregatesInput>
    OR?: Enumerable<TwitterCommentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TwitterCommentScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    text?: StringWithAggregatesFilter | string
    userId?: IntWithAggregatesFilter | number
    postId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TwitterPostOnHashtagWhereInput = {
    AND?: Enumerable<TwitterPostOnHashtagWhereInput>
    OR?: Enumerable<TwitterPostOnHashtagWhereInput>
    NOT?: Enumerable<TwitterPostOnHashtagWhereInput>
    id?: IntFilter | number
    post?: XOR<TwitterPostRelationFilter, TwitterPostWhereInput>
    postId?: IntFilter | number
    hashtag?: XOR<TwitterHashtagRelationFilter, TwitterHashtagWhereInput>
    hashtagId?: IntFilter | number
  }

  export type TwitterPostOnHashtagOrderByWithRelationInput = {
    id?: SortOrder
    post?: TwitterPostOrderByWithRelationInput
    postId?: SortOrder
    hashtag?: TwitterHashtagOrderByWithRelationInput
    hashtagId?: SortOrder
  }

  export type TwitterPostOnHashtagWhereUniqueInput = {
    id?: number
  }

  export type TwitterPostOnHashtagOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    hashtagId?: SortOrder
    _count?: TwitterPostOnHashtagCountOrderByAggregateInput
    _avg?: TwitterPostOnHashtagAvgOrderByAggregateInput
    _max?: TwitterPostOnHashtagMaxOrderByAggregateInput
    _min?: TwitterPostOnHashtagMinOrderByAggregateInput
    _sum?: TwitterPostOnHashtagSumOrderByAggregateInput
  }

  export type TwitterPostOnHashtagScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TwitterPostOnHashtagScalarWhereWithAggregatesInput>
    OR?: Enumerable<TwitterPostOnHashtagScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TwitterPostOnHashtagScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    postId?: IntWithAggregatesFilter | number
    hashtagId?: IntWithAggregatesFilter | number
  }

  export type WSUserWhereInput = {
    AND?: Enumerable<WSUserWhereInput>
    OR?: Enumerable<WSUserWhereInput>
    NOT?: Enumerable<WSUserWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    tel?: IntFilter | number
    myWallet?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
    topupHistories?: WSTopupHistoryListRelationFilter
    usingHistories?: WSUsingHistoryListRelationFilter
  }

  export type WSUserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    tel?: SortOrder
    myWallet?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    topupHistories?: WSTopupHistoryOrderByRelationAggregateInput
    usingHistories?: WSUsingHistoryOrderByRelationAggregateInput
  }

  export type WSUserWhereUniqueInput = {
    id?: number
  }

  export type WSUserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    tel?: SortOrder
    myWallet?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    _count?: WSUserCountOrderByAggregateInput
    _avg?: WSUserAvgOrderByAggregateInput
    _max?: WSUserMaxOrderByAggregateInput
    _min?: WSUserMinOrderByAggregateInput
    _sum?: WSUserSumOrderByAggregateInput
  }

  export type WSUserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WSUserScalarWhereWithAggregatesInput>
    OR?: Enumerable<WSUserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WSUserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    tel?: IntWithAggregatesFilter | number
    myWallet?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type WSTopupHistoryWhereInput = {
    AND?: Enumerable<WSTopupHistoryWhereInput>
    OR?: Enumerable<WSTopupHistoryWhereInput>
    NOT?: Enumerable<WSTopupHistoryWhereInput>
    id?: IntFilter | number
    user?: XOR<WSUserRelationFilter, WSUserWhereInput>
    userId?: IntFilter | number
    topup?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type WSTopupHistoryOrderByWithRelationInput = {
    id?: SortOrder
    user?: WSUserOrderByWithRelationInput
    userId?: SortOrder
    topup?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type WSTopupHistoryWhereUniqueInput = {
    id?: number
  }

  export type WSTopupHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    topup?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    _count?: WSTopupHistoryCountOrderByAggregateInput
    _avg?: WSTopupHistoryAvgOrderByAggregateInput
    _max?: WSTopupHistoryMaxOrderByAggregateInput
    _min?: WSTopupHistoryMinOrderByAggregateInput
    _sum?: WSTopupHistorySumOrderByAggregateInput
  }

  export type WSTopupHistoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WSTopupHistoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<WSTopupHistoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WSTopupHistoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    topup?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type WSUsingHistoryWhereInput = {
    AND?: Enumerable<WSUsingHistoryWhereInput>
    OR?: Enumerable<WSUsingHistoryWhereInput>
    NOT?: Enumerable<WSUsingHistoryWhereInput>
    id?: IntFilter | number
    user?: XOR<WSUserRelationFilter, WSUserWhereInput>
    userId?: IntFilter | number
    price?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
    machine?: XOR<WSMachineRelationFilter, WSMachineWhereInput>
    program?: XOR<WSProgramRelationFilter, WSProgramWhereInput>
    usingStartAt?: DateTimeFilter | Date | string
    finishingAt?: DateTimeFilter | Date | string
    wSMachineId?: IntFilter | number
    wSProgramId?: IntFilter | number
  }

  export type WSUsingHistoryOrderByWithRelationInput = {
    id?: SortOrder
    user?: WSUserOrderByWithRelationInput
    userId?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    machine?: WSMachineOrderByWithRelationInput
    program?: WSProgramOrderByWithRelationInput
    usingStartAt?: SortOrder
    finishingAt?: SortOrder
    wSMachineId?: SortOrder
    wSProgramId?: SortOrder
  }

  export type WSUsingHistoryWhereUniqueInput = {
    id?: number
  }

  export type WSUsingHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    usingStartAt?: SortOrder
    finishingAt?: SortOrder
    wSMachineId?: SortOrder
    wSProgramId?: SortOrder
    _count?: WSUsingHistoryCountOrderByAggregateInput
    _avg?: WSUsingHistoryAvgOrderByAggregateInput
    _max?: WSUsingHistoryMaxOrderByAggregateInput
    _min?: WSUsingHistoryMinOrderByAggregateInput
    _sum?: WSUsingHistorySumOrderByAggregateInput
  }

  export type WSUsingHistoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WSUsingHistoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<WSUsingHistoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WSUsingHistoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    price?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
    usingStartAt?: DateTimeWithAggregatesFilter | Date | string
    finishingAt?: DateTimeWithAggregatesFilter | Date | string
    wSMachineId?: IntWithAggregatesFilter | number
    wSProgramId?: IntWithAggregatesFilter | number
  }

  export type WSShopWhereInput = {
    AND?: Enumerable<WSShopWhereInput>
    OR?: Enumerable<WSShopWhereInput>
    NOT?: Enumerable<WSShopWhereInput>
    id?: IntFilter | number
    branch?: StringFilter | string
    owner?: StringFilter | string
    tel?: IntFilter | number
    location?: StringFilter | string
    area?: StringFilter | string
    machines?: WSMachineListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type WSShopOrderByWithRelationInput = {
    id?: SortOrder
    branch?: SortOrder
    owner?: SortOrder
    tel?: SortOrder
    location?: SortOrder
    area?: SortOrder
    machines?: WSMachineOrderByRelationAggregateInput
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type WSShopWhereUniqueInput = {
    id?: number
  }

  export type WSShopOrderByWithAggregationInput = {
    id?: SortOrder
    branch?: SortOrder
    owner?: SortOrder
    tel?: SortOrder
    location?: SortOrder
    area?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    _count?: WSShopCountOrderByAggregateInput
    _avg?: WSShopAvgOrderByAggregateInput
    _max?: WSShopMaxOrderByAggregateInput
    _min?: WSShopMinOrderByAggregateInput
    _sum?: WSShopSumOrderByAggregateInput
  }

  export type WSShopScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WSShopScalarWhereWithAggregatesInput>
    OR?: Enumerable<WSShopScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WSShopScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    branch?: StringWithAggregatesFilter | string
    owner?: StringWithAggregatesFilter | string
    tel?: IntWithAggregatesFilter | number
    location?: StringWithAggregatesFilter | string
    area?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type WSMachineWhereInput = {
    AND?: Enumerable<WSMachineWhereInput>
    OR?: Enumerable<WSMachineWhereInput>
    NOT?: Enumerable<WSMachineWhereInput>
    id?: IntFilter | number
    shop?: XOR<WSShopRelationFilter, WSShopWhereInput>
    shopId?: IntFilter | number
    brandname?: StringFilter | string
    size?: StringFilter | string
    type?: StringFilter | string
    model?: StringFilter | string
    producedDate?: StringFilter | string
    insuranceExpiredDate?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
    machineToPrograms?: MachineToProgramListRelationFilter
    maintains?: WSMaintainListRelationFilter
    usingHistories?: WSUsingHistoryListRelationFilter
  }

  export type WSMachineOrderByWithRelationInput = {
    id?: SortOrder
    shop?: WSShopOrderByWithRelationInput
    shopId?: SortOrder
    brandname?: SortOrder
    size?: SortOrder
    type?: SortOrder
    model?: SortOrder
    producedDate?: SortOrder
    insuranceExpiredDate?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    machineToPrograms?: MachineToProgramOrderByRelationAggregateInput
    maintains?: WSMaintainOrderByRelationAggregateInput
    usingHistories?: WSUsingHistoryOrderByRelationAggregateInput
  }

  export type WSMachineWhereUniqueInput = {
    id?: number
  }

  export type WSMachineOrderByWithAggregationInput = {
    id?: SortOrder
    shopId?: SortOrder
    brandname?: SortOrder
    size?: SortOrder
    type?: SortOrder
    model?: SortOrder
    producedDate?: SortOrder
    insuranceExpiredDate?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    _count?: WSMachineCountOrderByAggregateInput
    _avg?: WSMachineAvgOrderByAggregateInput
    _max?: WSMachineMaxOrderByAggregateInput
    _min?: WSMachineMinOrderByAggregateInput
    _sum?: WSMachineSumOrderByAggregateInput
  }

  export type WSMachineScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WSMachineScalarWhereWithAggregatesInput>
    OR?: Enumerable<WSMachineScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WSMachineScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    shopId?: IntWithAggregatesFilter | number
    brandname?: StringWithAggregatesFilter | string
    size?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    model?: StringWithAggregatesFilter | string
    producedDate?: StringWithAggregatesFilter | string
    insuranceExpiredDate?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type WSProgramWhereInput = {
    AND?: Enumerable<WSProgramWhereInput>
    OR?: Enumerable<WSProgramWhereInput>
    NOT?: Enumerable<WSProgramWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
    machineToPrograms?: MachineToProgramListRelationFilter
    programLists?: WSProgramDetailListRelationFilter
    activeProgram?: XOR<WSProgramDetailRelationFilter, WSProgramDetailWhereInput>
    usingHistories?: WSUsingHistoryListRelationFilter
    activeProgramId?: IntFilter | number
  }

  export type WSProgramOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    machineToPrograms?: MachineToProgramOrderByRelationAggregateInput
    programLists?: WSProgramDetailOrderByRelationAggregateInput
    activeProgram?: WSProgramDetailOrderByWithRelationInput
    usingHistories?: WSUsingHistoryOrderByRelationAggregateInput
    activeProgramId?: SortOrder
  }

  export type WSProgramWhereUniqueInput = {
    id?: number
  }

  export type WSProgramOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    activeProgramId?: SortOrder
    _count?: WSProgramCountOrderByAggregateInput
    _avg?: WSProgramAvgOrderByAggregateInput
    _max?: WSProgramMaxOrderByAggregateInput
    _min?: WSProgramMinOrderByAggregateInput
    _sum?: WSProgramSumOrderByAggregateInput
  }

  export type WSProgramScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WSProgramScalarWhereWithAggregatesInput>
    OR?: Enumerable<WSProgramScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WSProgramScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
    activeProgramId?: IntWithAggregatesFilter | number
  }

  export type MachineToProgramWhereInput = {
    AND?: Enumerable<MachineToProgramWhereInput>
    OR?: Enumerable<MachineToProgramWhereInput>
    NOT?: Enumerable<MachineToProgramWhereInput>
    id?: IntFilter | number
    maching?: XOR<WSMachineRelationFilter, WSMachineWhereInput>
    machineId?: IntFilter | number
    program?: XOR<WSProgramRelationFilter, WSProgramWhereInput>
    programId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type MachineToProgramOrderByWithRelationInput = {
    id?: SortOrder
    maching?: WSMachineOrderByWithRelationInput
    machineId?: SortOrder
    program?: WSProgramOrderByWithRelationInput
    programId?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type MachineToProgramWhereUniqueInput = {
    id?: number
  }

  export type MachineToProgramOrderByWithAggregationInput = {
    id?: SortOrder
    machineId?: SortOrder
    programId?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    _count?: MachineToProgramCountOrderByAggregateInput
    _avg?: MachineToProgramAvgOrderByAggregateInput
    _max?: MachineToProgramMaxOrderByAggregateInput
    _min?: MachineToProgramMinOrderByAggregateInput
    _sum?: MachineToProgramSumOrderByAggregateInput
  }

  export type MachineToProgramScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MachineToProgramScalarWhereWithAggregatesInput>
    OR?: Enumerable<MachineToProgramScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MachineToProgramScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    machineId?: IntWithAggregatesFilter | number
    programId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type WSProgramDetailWhereInput = {
    AND?: Enumerable<WSProgramDetailWhereInput>
    OR?: Enumerable<WSProgramDetailWhereInput>
    NOT?: Enumerable<WSProgramDetailWhereInput>
    id?: IntFilter | number
    program?: XOR<WSProgramRelationFilter, WSProgramWhereInput>
    programId?: IntFilter | number
    price?: IntFilter | number
    duration?: IntFilter | number
    weight?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
    programs?: WSProgramListRelationFilter
  }

  export type WSProgramDetailOrderByWithRelationInput = {
    id?: SortOrder
    program?: WSProgramOrderByWithRelationInput
    programId?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    weight?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    programs?: WSProgramOrderByRelationAggregateInput
  }

  export type WSProgramDetailWhereUniqueInput = {
    id?: number
  }

  export type WSProgramDetailOrderByWithAggregationInput = {
    id?: SortOrder
    programId?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    weight?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    _count?: WSProgramDetailCountOrderByAggregateInput
    _avg?: WSProgramDetailAvgOrderByAggregateInput
    _max?: WSProgramDetailMaxOrderByAggregateInput
    _min?: WSProgramDetailMinOrderByAggregateInput
    _sum?: WSProgramDetailSumOrderByAggregateInput
  }

  export type WSProgramDetailScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WSProgramDetailScalarWhereWithAggregatesInput>
    OR?: Enumerable<WSProgramDetailScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WSProgramDetailScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    programId?: IntWithAggregatesFilter | number
    price?: IntWithAggregatesFilter | number
    duration?: IntWithAggregatesFilter | number
    weight?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type WSMaintainWhereInput = {
    AND?: Enumerable<WSMaintainWhereInput>
    OR?: Enumerable<WSMaintainWhereInput>
    NOT?: Enumerable<WSMaintainWhereInput>
    id?: IntFilter | number
    checker?: StringFilter | string
    item?: StringFilter | string
    status?: StringFilter | string
    machine?: XOR<WSMachineRelationFilter, WSMachineWhereInput>
    machineId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type WSMaintainOrderByWithRelationInput = {
    id?: SortOrder
    checker?: SortOrder
    item?: SortOrder
    status?: SortOrder
    machine?: WSMachineOrderByWithRelationInput
    machineId?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type WSMaintainWhereUniqueInput = {
    id?: number
  }

  export type WSMaintainOrderByWithAggregationInput = {
    id?: SortOrder
    checker?: SortOrder
    item?: SortOrder
    status?: SortOrder
    machineId?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    _count?: WSMaintainCountOrderByAggregateInput
    _avg?: WSMaintainAvgOrderByAggregateInput
    _max?: WSMaintainMaxOrderByAggregateInput
    _min?: WSMaintainMinOrderByAggregateInput
    _sum?: WSMaintainSumOrderByAggregateInput
  }

  export type WSMaintainScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WSMaintainScalarWhereWithAggregatesInput>
    OR?: Enumerable<WSMaintainScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WSMaintainScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    checker?: StringWithAggregatesFilter | string
    item?: StringWithAggregatesFilter | string
    status?: StringWithAggregatesFilter | string
    machineId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type YTUserWhereInput = {
    AND?: Enumerable<YTUserWhereInput>
    OR?: Enumerable<YTUserWhereInput>
    NOT?: Enumerable<YTUserWhereInput>
    id?: IntFilter | number
    user?: StringFilter | string
    email?: StringFilter | string
    avatar?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    userToChannels?: UserToChannelListRelationFilter
    comments?: YTCommentListRelationFilter
    subscribes?: YTSubscribeListRelationFilter
    shares?: YTShareListRelationFilter
  }

  export type YTUserOrderByWithRelationInput = {
    id?: SortOrder
    user?: SortOrder
    email?: SortOrder
    avatar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userToChannels?: UserToChannelOrderByRelationAggregateInput
    comments?: YTCommentOrderByRelationAggregateInput
    subscribes?: YTSubscribeOrderByRelationAggregateInput
    shares?: YTShareOrderByRelationAggregateInput
  }

  export type YTUserWhereUniqueInput = {
    id?: number
    user?: string
    email?: string
  }

  export type YTUserOrderByWithAggregationInput = {
    id?: SortOrder
    user?: SortOrder
    email?: SortOrder
    avatar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: YTUserCountOrderByAggregateInput
    _avg?: YTUserAvgOrderByAggregateInput
    _max?: YTUserMaxOrderByAggregateInput
    _min?: YTUserMinOrderByAggregateInput
    _sum?: YTUserSumOrderByAggregateInput
  }

  export type YTUserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<YTUserScalarWhereWithAggregatesInput>
    OR?: Enumerable<YTUserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<YTUserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    user?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    avatar?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type YTChannelWhereInput = {
    AND?: Enumerable<YTChannelWhereInput>
    OR?: Enumerable<YTChannelWhereInput>
    NOT?: Enumerable<YTChannelWhereInput>
    id?: IntFilter | number
    channelName?: StringFilter | string
    description?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    userToChannels?: UserToChannelListRelationFilter
    videos?: YTVideoListRelationFilter
    subscribes?: YTSubscribeListRelationFilter
  }

  export type YTChannelOrderByWithRelationInput = {
    id?: SortOrder
    channelName?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userToChannels?: UserToChannelOrderByRelationAggregateInput
    videos?: YTVideoOrderByRelationAggregateInput
    subscribes?: YTSubscribeOrderByRelationAggregateInput
  }

  export type YTChannelWhereUniqueInput = {
    id?: number
  }

  export type YTChannelOrderByWithAggregationInput = {
    id?: SortOrder
    channelName?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: YTChannelCountOrderByAggregateInput
    _avg?: YTChannelAvgOrderByAggregateInput
    _max?: YTChannelMaxOrderByAggregateInput
    _min?: YTChannelMinOrderByAggregateInput
    _sum?: YTChannelSumOrderByAggregateInput
  }

  export type YTChannelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<YTChannelScalarWhereWithAggregatesInput>
    OR?: Enumerable<YTChannelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<YTChannelScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    channelName?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserToChannelWhereInput = {
    AND?: Enumerable<UserToChannelWhereInput>
    OR?: Enumerable<UserToChannelWhereInput>
    NOT?: Enumerable<UserToChannelWhereInput>
    id?: IntFilter | number
    user?: XOR<YTUserRelationFilter, YTUserWhereInput>
    userId?: IntFilter | number
    channel?: XOR<YTChannelRelationFilter, YTChannelWhereInput>
    channelId?: IntFilter | number
    role?: EnumYTRoleEnumFilter | YTRoleEnum
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type UserToChannelOrderByWithRelationInput = {
    id?: SortOrder
    user?: YTUserOrderByWithRelationInput
    userId?: SortOrder
    channel?: YTChannelOrderByWithRelationInput
    channelId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserToChannelWhereUniqueInput = {
    id?: number
  }

  export type UserToChannelOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    channelId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserToChannelCountOrderByAggregateInput
    _avg?: UserToChannelAvgOrderByAggregateInput
    _max?: UserToChannelMaxOrderByAggregateInput
    _min?: UserToChannelMinOrderByAggregateInput
    _sum?: UserToChannelSumOrderByAggregateInput
  }

  export type UserToChannelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserToChannelScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserToChannelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserToChannelScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    channelId?: IntWithAggregatesFilter | number
    role?: EnumYTRoleEnumWithAggregatesFilter | YTRoleEnum
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type YTVideoWhereInput = {
    AND?: Enumerable<YTVideoWhereInput>
    OR?: Enumerable<YTVideoWhereInput>
    NOT?: Enumerable<YTVideoWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    file?: StringFilter | string
    logo?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    channel?: XOR<YTChannelRelationFilter, YTChannelWhereInput>
    channelId?: IntFilter | number
    likes?: YTLikeListRelationFilter
    comments?: YTCommentListRelationFilter
    shares?: YTShareListRelationFilter
  }

  export type YTVideoOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    file?: SortOrder
    logo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    channel?: YTChannelOrderByWithRelationInput
    channelId?: SortOrder
    likes?: YTLikeOrderByRelationAggregateInput
    comments?: YTCommentOrderByRelationAggregateInput
    shares?: YTShareOrderByRelationAggregateInput
  }

  export type YTVideoWhereUniqueInput = {
    id?: number
  }

  export type YTVideoOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    file?: SortOrder
    logo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    channelId?: SortOrder
    _count?: YTVideoCountOrderByAggregateInput
    _avg?: YTVideoAvgOrderByAggregateInput
    _max?: YTVideoMaxOrderByAggregateInput
    _min?: YTVideoMinOrderByAggregateInput
    _sum?: YTVideoSumOrderByAggregateInput
  }

  export type YTVideoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<YTVideoScalarWhereWithAggregatesInput>
    OR?: Enumerable<YTVideoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<YTVideoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    file?: StringWithAggregatesFilter | string
    logo?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    channelId?: IntWithAggregatesFilter | number
  }

  export type YTLikeWhereInput = {
    AND?: Enumerable<YTLikeWhereInput>
    OR?: Enumerable<YTLikeWhereInput>
    NOT?: Enumerable<YTLikeWhereInput>
    id?: IntFilter | number
    type?: StringFilter | string
    video?: XOR<YTVideoRelationFilter, YTVideoWhereInput>
    videoId?: IntFilter | number
    comment?: XOR<YTCommentRelationFilter, YTCommentWhereInput>
    commentId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type YTLikeOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    video?: YTVideoOrderByWithRelationInput
    videoId?: SortOrder
    comment?: YTCommentOrderByWithRelationInput
    commentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YTLikeWhereUniqueInput = {
    id?: number
  }

  export type YTLikeOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    videoId?: SortOrder
    commentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: YTLikeCountOrderByAggregateInput
    _avg?: YTLikeAvgOrderByAggregateInput
    _max?: YTLikeMaxOrderByAggregateInput
    _min?: YTLikeMinOrderByAggregateInput
    _sum?: YTLikeSumOrderByAggregateInput
  }

  export type YTLikeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<YTLikeScalarWhereWithAggregatesInput>
    OR?: Enumerable<YTLikeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<YTLikeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    type?: StringWithAggregatesFilter | string
    videoId?: IntWithAggregatesFilter | number
    commentId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type YTCommentWhereInput = {
    AND?: Enumerable<YTCommentWhereInput>
    OR?: Enumerable<YTCommentWhereInput>
    NOT?: Enumerable<YTCommentWhereInput>
    id?: IntFilter | number
    text?: StringFilter | string
    user?: XOR<YTUserRelationFilter, YTUserWhereInput>
    userId?: IntFilter | number
    commentTo?: IntNullableFilter | number | null
    video?: XOR<YTVideoRelationFilter, YTVideoWhereInput>
    videoId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    likes?: YTLikeListRelationFilter
  }

  export type YTCommentOrderByWithRelationInput = {
    id?: SortOrder
    text?: SortOrder
    user?: YTUserOrderByWithRelationInput
    userId?: SortOrder
    commentTo?: SortOrder
    video?: YTVideoOrderByWithRelationInput
    videoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    likes?: YTLikeOrderByRelationAggregateInput
  }

  export type YTCommentWhereUniqueInput = {
    id?: number
  }

  export type YTCommentOrderByWithAggregationInput = {
    id?: SortOrder
    text?: SortOrder
    userId?: SortOrder
    commentTo?: SortOrder
    videoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: YTCommentCountOrderByAggregateInput
    _avg?: YTCommentAvgOrderByAggregateInput
    _max?: YTCommentMaxOrderByAggregateInput
    _min?: YTCommentMinOrderByAggregateInput
    _sum?: YTCommentSumOrderByAggregateInput
  }

  export type YTCommentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<YTCommentScalarWhereWithAggregatesInput>
    OR?: Enumerable<YTCommentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<YTCommentScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    text?: StringWithAggregatesFilter | string
    userId?: IntWithAggregatesFilter | number
    commentTo?: IntNullableWithAggregatesFilter | number | null
    videoId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type YTSubscribeWhereInput = {
    AND?: Enumerable<YTSubscribeWhereInput>
    OR?: Enumerable<YTSubscribeWhereInput>
    NOT?: Enumerable<YTSubscribeWhereInput>
    id?: IntFilter | number
    user?: XOR<YTUserRelationFilter, YTUserWhereInput>
    userId?: IntFilter | number
    channel?: XOR<YTChannelRelationFilter, YTChannelWhereInput>
    channelId?: IntFilter | number
    member?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type YTSubscribeOrderByWithRelationInput = {
    id?: SortOrder
    user?: YTUserOrderByWithRelationInput
    userId?: SortOrder
    channel?: YTChannelOrderByWithRelationInput
    channelId?: SortOrder
    member?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YTSubscribeWhereUniqueInput = {
    id?: number
  }

  export type YTSubscribeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    channelId?: SortOrder
    member?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: YTSubscribeCountOrderByAggregateInput
    _avg?: YTSubscribeAvgOrderByAggregateInput
    _max?: YTSubscribeMaxOrderByAggregateInput
    _min?: YTSubscribeMinOrderByAggregateInput
    _sum?: YTSubscribeSumOrderByAggregateInput
  }

  export type YTSubscribeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<YTSubscribeScalarWhereWithAggregatesInput>
    OR?: Enumerable<YTSubscribeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<YTSubscribeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    channelId?: IntWithAggregatesFilter | number
    member?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type YTShareWhereInput = {
    AND?: Enumerable<YTShareWhereInput>
    OR?: Enumerable<YTShareWhereInput>
    NOT?: Enumerable<YTShareWhereInput>
    id?: IntFilter | number
    user?: XOR<YTUserRelationFilter, YTUserWhereInput>
    userId?: IntFilter | number
    video?: XOR<YTVideoRelationFilter, YTVideoWhereInput>
    videoId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type YTShareOrderByWithRelationInput = {
    id?: SortOrder
    user?: YTUserOrderByWithRelationInput
    userId?: SortOrder
    video?: YTVideoOrderByWithRelationInput
    videoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YTShareWhereUniqueInput = {
    id?: number
  }

  export type YTShareOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    videoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: YTShareCountOrderByAggregateInput
    _avg?: YTShareAvgOrderByAggregateInput
    _max?: YTShareMaxOrderByAggregateInput
    _min?: YTShareMinOrderByAggregateInput
    _sum?: YTShareSumOrderByAggregateInput
  }

  export type YTShareScalarWhereWithAggregatesInput = {
    AND?: Enumerable<YTShareScalarWhereWithAggregatesInput>
    OR?: Enumerable<YTShareScalarWhereWithAggregatesInput>
    NOT?: Enumerable<YTShareScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    videoId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type BKReserveUserCreateInput = {
    university: BKUniversityCreateNestedOneWithoutReserveUsersInput
    createdAt?: Date | string
    updatedAt?: Date | string
    requests?: BKRequestCreateNestedManyWithoutUserInput
    BKBorrowingHistory?: BKBorrowingHistoryCreateNestedManyWithoutUserInput
    BKCopy?: BKCopyCreateNestedManyWithoutUserInput
  }

  export type BKReserveUserUncheckedCreateInput = {
    id?: number
    universityId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    requests?: BKRequestUncheckedCreateNestedManyWithoutUserInput
    BKBorrowingHistory?: BKBorrowingHistoryUncheckedCreateNestedManyWithoutUserInput
    BKCopy?: BKCopyUncheckedCreateNestedManyWithoutUserInput
  }

  export type BKReserveUserUpdateInput = {
    university?: BKUniversityUpdateOneRequiredWithoutReserveUsersNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requests?: BKRequestUpdateManyWithoutUserNestedInput
    BKBorrowingHistory?: BKBorrowingHistoryUpdateManyWithoutUserNestedInput
    BKCopy?: BKCopyUpdateManyWithoutUserNestedInput
  }

  export type BKReserveUserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    universityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requests?: BKRequestUncheckedUpdateManyWithoutUserNestedInput
    BKBorrowingHistory?: BKBorrowingHistoryUncheckedUpdateManyWithoutUserNestedInput
    BKCopy?: BKCopyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BKReserveUserCreateManyInput = {
    id?: number
    universityId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BKReserveUserUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BKReserveUserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    universityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BKRequestCreateInput = {
    user: BKReserveUserCreateNestedOneWithoutRequestsInput
    copy: BKCopyCreateNestedOneWithoutRequestsInput
    from: BKUniversityCreateNestedOneWithoutFromRequestInput
    to: BKUniversityCreateNestedOneWithoutToRequestInput
    requestDate: Date | string
    status: RequestStatusEnum
    planRecievedDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BKRequestUncheckedCreateInput = {
    id?: number
    reserveUserId: number
    copyId: number
    fromUniversityId: number
    toUniversityId: number
    requestDate: Date | string
    status: RequestStatusEnum
    planRecievedDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BKRequestUpdateInput = {
    user?: BKReserveUserUpdateOneRequiredWithoutRequestsNestedInput
    copy?: BKCopyUpdateOneRequiredWithoutRequestsNestedInput
    from?: BKUniversityUpdateOneRequiredWithoutFromRequestNestedInput
    to?: BKUniversityUpdateOneRequiredWithoutToRequestNestedInput
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRequestStatusEnumFieldUpdateOperationsInput | RequestStatusEnum
    planRecievedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BKRequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    reserveUserId?: IntFieldUpdateOperationsInput | number
    copyId?: IntFieldUpdateOperationsInput | number
    fromUniversityId?: IntFieldUpdateOperationsInput | number
    toUniversityId?: IntFieldUpdateOperationsInput | number
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRequestStatusEnumFieldUpdateOperationsInput | RequestStatusEnum
    planRecievedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BKRequestCreateManyInput = {
    id?: number
    reserveUserId: number
    copyId: number
    fromUniversityId: number
    toUniversityId: number
    requestDate: Date | string
    status: RequestStatusEnum
    planRecievedDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BKRequestUpdateManyMutationInput = {
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRequestStatusEnumFieldUpdateOperationsInput | RequestStatusEnum
    planRecievedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BKRequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    reserveUserId?: IntFieldUpdateOperationsInput | number
    copyId?: IntFieldUpdateOperationsInput | number
    fromUniversityId?: IntFieldUpdateOperationsInput | number
    toUniversityId?: IntFieldUpdateOperationsInput | number
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRequestStatusEnumFieldUpdateOperationsInput | RequestStatusEnum
    planRecievedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BKBorrowingHistoryCreateInput = {
    user: BKReserveUserCreateNestedOneWithoutBKBorrowingHistoryInput
    copy: BKCopyCreateNestedOneWithoutBKBorrowingHistoryInput
    from: BKUniversityCreateNestedOneWithoutBKBorrowingHistoryInput
    borrowDate: Date | string
    returnDate: Date | string
    actualReturnDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BKBorrowingHistoryUncheckedCreateInput = {
    id?: number
    reserveUserId: number
    copyId: number
    fromUniversityId: number
    borrowDate: Date | string
    returnDate: Date | string
    actualReturnDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BKBorrowingHistoryUpdateInput = {
    user?: BKReserveUserUpdateOneRequiredWithoutBKBorrowingHistoryNestedInput
    copy?: BKCopyUpdateOneRequiredWithoutBKBorrowingHistoryNestedInput
    from?: BKUniversityUpdateOneRequiredWithoutBKBorrowingHistoryNestedInput
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualReturnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BKBorrowingHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    reserveUserId?: IntFieldUpdateOperationsInput | number
    copyId?: IntFieldUpdateOperationsInput | number
    fromUniversityId?: IntFieldUpdateOperationsInput | number
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualReturnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BKBorrowingHistoryCreateManyInput = {
    id?: number
    reserveUserId: number
    copyId: number
    fromUniversityId: number
    borrowDate: Date | string
    returnDate: Date | string
    actualReturnDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BKBorrowingHistoryUpdateManyMutationInput = {
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualReturnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BKBorrowingHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    reserveUserId?: IntFieldUpdateOperationsInput | number
    copyId?: IntFieldUpdateOperationsInput | number
    fromUniversityId?: IntFieldUpdateOperationsInput | number
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualReturnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BKCopyCreateInput = {
    status: CopyStatusEnum
    title: BKTitleCreateNestedOneWithoutCopiesInput
    user?: BKReserveUserCreateNestedOneWithoutBKCopyInput
    createdAt?: Date | string
    updatedAt?: Date | string
    requests?: BKRequestCreateNestedManyWithoutCopyInput
    BKBorrowingHistory?: BKBorrowingHistoryCreateNestedManyWithoutCopyInput
  }

  export type BKCopyUncheckedCreateInput = {
    id?: number
    status: CopyStatusEnum
    titleId: number
    reserveUserId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    requests?: BKRequestUncheckedCreateNestedManyWithoutCopyInput
    BKBorrowingHistory?: BKBorrowingHistoryUncheckedCreateNestedManyWithoutCopyInput
  }

  export type BKCopyUpdateInput = {
    status?: EnumCopyStatusEnumFieldUpdateOperationsInput | CopyStatusEnum
    title?: BKTitleUpdateOneRequiredWithoutCopiesNestedInput
    user?: BKReserveUserUpdateOneWithoutBKCopyNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requests?: BKRequestUpdateManyWithoutCopyNestedInput
    BKBorrowingHistory?: BKBorrowingHistoryUpdateManyWithoutCopyNestedInput
  }

  export type BKCopyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumCopyStatusEnumFieldUpdateOperationsInput | CopyStatusEnum
    titleId?: IntFieldUpdateOperationsInput | number
    reserveUserId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requests?: BKRequestUncheckedUpdateManyWithoutCopyNestedInput
    BKBorrowingHistory?: BKBorrowingHistoryUncheckedUpdateManyWithoutCopyNestedInput
  }

  export type BKCopyCreateManyInput = {
    id?: number
    status: CopyStatusEnum
    titleId: number
    reserveUserId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BKCopyUpdateManyMutationInput = {
    status?: EnumCopyStatusEnumFieldUpdateOperationsInput | CopyStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BKCopyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumCopyStatusEnumFieldUpdateOperationsInput | CopyStatusEnum
    titleId?: IntFieldUpdateOperationsInput | number
    reserveUserId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BKUniversityCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    universityToTitles?: UniversityToTitleCreateNestedManyWithoutUniversityInput
    reserveUsers?: BKReserveUserCreateNestedManyWithoutUniversityInput
    fromRequest?: BKRequestCreateNestedManyWithoutFromInput
    toRequest?: BKRequestCreateNestedManyWithoutToInput
    BKBorrowingHistory?: BKBorrowingHistoryCreateNestedManyWithoutFromInput
  }

  export type BKUniversityUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    universityToTitles?: UniversityToTitleUncheckedCreateNestedManyWithoutUniversityInput
    reserveUsers?: BKReserveUserUncheckedCreateNestedManyWithoutUniversityInput
    fromRequest?: BKRequestUncheckedCreateNestedManyWithoutFromInput
    toRequest?: BKRequestUncheckedCreateNestedManyWithoutToInput
    BKBorrowingHistory?: BKBorrowingHistoryUncheckedCreateNestedManyWithoutFromInput
  }

  export type BKUniversityUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    universityToTitles?: UniversityToTitleUpdateManyWithoutUniversityNestedInput
    reserveUsers?: BKReserveUserUpdateManyWithoutUniversityNestedInput
    fromRequest?: BKRequestUpdateManyWithoutFromNestedInput
    toRequest?: BKRequestUpdateManyWithoutToNestedInput
    BKBorrowingHistory?: BKBorrowingHistoryUpdateManyWithoutFromNestedInput
  }

  export type BKUniversityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    universityToTitles?: UniversityToTitleUncheckedUpdateManyWithoutUniversityNestedInput
    reserveUsers?: BKReserveUserUncheckedUpdateManyWithoutUniversityNestedInput
    fromRequest?: BKRequestUncheckedUpdateManyWithoutFromNestedInput
    toRequest?: BKRequestUncheckedUpdateManyWithoutToNestedInput
    BKBorrowingHistory?: BKBorrowingHistoryUncheckedUpdateManyWithoutFromNestedInput
  }

  export type BKUniversityCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BKUniversityUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BKUniversityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BKTitleCreateInput = {
    name: string
    ISBN: number
    copyQty: number
    createdAt?: Date | string
    updatedAt?: Date | string
    titleToCategories?: TitleToCategoryCreateNestedManyWithoutTitleInput
    titleToAuthors?: TitleToAuthorCreateNestedManyWithoutTitleInput
    universityToTitles?: UniversityToTitleCreateNestedManyWithoutTitleInput
    copies?: BKCopyCreateNestedManyWithoutTitleInput
  }

  export type BKTitleUncheckedCreateInput = {
    id?: number
    name: string
    ISBN: number
    copyQty: number
    createdAt?: Date | string
    updatedAt?: Date | string
    titleToCategories?: TitleToCategoryUncheckedCreateNestedManyWithoutTitleInput
    titleToAuthors?: TitleToAuthorUncheckedCreateNestedManyWithoutTitleInput
    universityToTitles?: UniversityToTitleUncheckedCreateNestedManyWithoutTitleInput
    copies?: BKCopyUncheckedCreateNestedManyWithoutTitleInput
  }

  export type BKTitleUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    ISBN?: IntFieldUpdateOperationsInput | number
    copyQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    titleToCategories?: TitleToCategoryUpdateManyWithoutTitleNestedInput
    titleToAuthors?: TitleToAuthorUpdateManyWithoutTitleNestedInput
    universityToTitles?: UniversityToTitleUpdateManyWithoutTitleNestedInput
    copies?: BKCopyUpdateManyWithoutTitleNestedInput
  }

  export type BKTitleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    ISBN?: IntFieldUpdateOperationsInput | number
    copyQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    titleToCategories?: TitleToCategoryUncheckedUpdateManyWithoutTitleNestedInput
    titleToAuthors?: TitleToAuthorUncheckedUpdateManyWithoutTitleNestedInput
    universityToTitles?: UniversityToTitleUncheckedUpdateManyWithoutTitleNestedInput
    copies?: BKCopyUncheckedUpdateManyWithoutTitleNestedInput
  }

  export type BKTitleCreateManyInput = {
    id?: number
    name: string
    ISBN: number
    copyQty: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BKTitleUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    ISBN?: IntFieldUpdateOperationsInput | number
    copyQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BKTitleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    ISBN?: IntFieldUpdateOperationsInput | number
    copyQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UniversityToTitleCreateInput = {
    university: BKUniversityCreateNestedOneWithoutUniversityToTitlesInput
    title: BKTitleCreateNestedOneWithoutUniversityToTitlesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UniversityToTitleUncheckedCreateInput = {
    id?: number
    universityId: number
    titleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UniversityToTitleUpdateInput = {
    university?: BKUniversityUpdateOneRequiredWithoutUniversityToTitlesNestedInput
    title?: BKTitleUpdateOneRequiredWithoutUniversityToTitlesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UniversityToTitleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    universityId?: IntFieldUpdateOperationsInput | number
    titleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UniversityToTitleCreateManyInput = {
    id?: number
    universityId: number
    titleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UniversityToTitleUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UniversityToTitleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    universityId?: IntFieldUpdateOperationsInput | number
    titleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BKCategoryCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    titleToCategories?: TitleToCategoryCreateNestedManyWithoutCategoryInput
  }

  export type BKCategoryUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    titleToCategories?: TitleToCategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type BKCategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    titleToCategories?: TitleToCategoryUpdateManyWithoutCategoryNestedInput
  }

  export type BKCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    titleToCategories?: TitleToCategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type BKCategoryCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BKCategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BKCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TitleToCategoryCreateInput = {
    title: BKTitleCreateNestedOneWithoutTitleToCategoriesInput
    category: BKCategoryCreateNestedOneWithoutTitleToCategoriesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TitleToCategoryUncheckedCreateInput = {
    id?: number
    titleId: number
    categoryId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TitleToCategoryUpdateInput = {
    title?: BKTitleUpdateOneRequiredWithoutTitleToCategoriesNestedInput
    category?: BKCategoryUpdateOneRequiredWithoutTitleToCategoriesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TitleToCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    titleId?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TitleToCategoryCreateManyInput = {
    id?: number
    titleId: number
    categoryId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TitleToCategoryUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TitleToCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    titleId?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BKAuthorCreateInput = {
    name: string
    titleToAuthors?: TitleToAuthorCreateNestedManyWithoutAuthorInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BKAuthorUncheckedCreateInput = {
    id?: number
    name: string
    titleToAuthors?: TitleToAuthorUncheckedCreateNestedManyWithoutAuthorInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BKAuthorUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    titleToAuthors?: TitleToAuthorUpdateManyWithoutAuthorNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BKAuthorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    titleToAuthors?: TitleToAuthorUncheckedUpdateManyWithoutAuthorNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BKAuthorCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BKAuthorUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BKAuthorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TitleToAuthorCreateInput = {
    title: BKTitleCreateNestedOneWithoutTitleToAuthorsInput
    author: BKAuthorCreateNestedOneWithoutTitleToAuthorsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TitleToAuthorUncheckedCreateInput = {
    id?: number
    titleId: number
    authorId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TitleToAuthorUpdateInput = {
    title?: BKTitleUpdateOneRequiredWithoutTitleToAuthorsNestedInput
    author?: BKAuthorUpdateOneRequiredWithoutTitleToAuthorsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TitleToAuthorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    titleId?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TitleToAuthorCreateManyInput = {
    id?: number
    titleId: number
    authorId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TitleToAuthorUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TitleToAuthorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    titleId?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbUserCreateInput = {
    name: string
    image: string
    location: string
    posts?: FbPostCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
    acceptFbFriends?: FbfriendCreateNestedManyWithoutAcceptFriendInput
    requestFbFriends?: FbfriendCreateNestedManyWithoutRequestFriendInput
    likes?: FbLikeCreateNestedManyWithoutUserInput
    fromMessengers?: FbMessengerCreateNestedManyWithoutFromInput
    toMessengers?: FbMessengerCreateNestedManyWithoutToInput
    shares?: FbShareCreateNestedManyWithoutUserInput
    comments?: FbCommentCreateNestedManyWithoutUserInput
    groupToUsers?: GroupToUserCreateNestedManyWithoutUserInput
  }

  export type FbUserUncheckedCreateInput = {
    id?: number
    name: string
    image: string
    location: string
    posts?: FbPostUncheckedCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
    acceptFbFriends?: FbfriendUncheckedCreateNestedManyWithoutAcceptFriendInput
    requestFbFriends?: FbfriendUncheckedCreateNestedManyWithoutRequestFriendInput
    likes?: FbLikeUncheckedCreateNestedManyWithoutUserInput
    fromMessengers?: FbMessengerUncheckedCreateNestedManyWithoutFromInput
    toMessengers?: FbMessengerUncheckedCreateNestedManyWithoutToInput
    shares?: FbShareUncheckedCreateNestedManyWithoutUserInput
    comments?: FbCommentUncheckedCreateNestedManyWithoutUserInput
    groupToUsers?: GroupToUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type FbUserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    posts?: FbPostUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptFbFriends?: FbfriendUpdateManyWithoutAcceptFriendNestedInput
    requestFbFriends?: FbfriendUpdateManyWithoutRequestFriendNestedInput
    likes?: FbLikeUpdateManyWithoutUserNestedInput
    fromMessengers?: FbMessengerUpdateManyWithoutFromNestedInput
    toMessengers?: FbMessengerUpdateManyWithoutToNestedInput
    shares?: FbShareUpdateManyWithoutUserNestedInput
    comments?: FbCommentUpdateManyWithoutUserNestedInput
    groupToUsers?: GroupToUserUpdateManyWithoutUserNestedInput
  }

  export type FbUserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    posts?: FbPostUncheckedUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptFbFriends?: FbfriendUncheckedUpdateManyWithoutAcceptFriendNestedInput
    requestFbFriends?: FbfriendUncheckedUpdateManyWithoutRequestFriendNestedInput
    likes?: FbLikeUncheckedUpdateManyWithoutUserNestedInput
    fromMessengers?: FbMessengerUncheckedUpdateManyWithoutFromNestedInput
    toMessengers?: FbMessengerUncheckedUpdateManyWithoutToNestedInput
    shares?: FbShareUncheckedUpdateManyWithoutUserNestedInput
    comments?: FbCommentUncheckedUpdateManyWithoutUserNestedInput
    groupToUsers?: GroupToUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FbUserCreateManyInput = {
    id?: number
    name: string
    image: string
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbUserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbUserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbPostCreateInput = {
    caption: string
    user: FbUserCreateNestedOneWithoutPostsInput
    createdAt?: Date | string
    updatedAt?: Date | string
    postImages?: FbPostImageCreateNestedManyWithoutPostInput
    postVideoes?: FbPostVideoCreateNestedManyWithoutPostInput
    postOnHashtags?: FbPostOnHashtagCreateNestedManyWithoutPostInput
    shares?: FbShareCreateNestedManyWithoutPostInput
    likes?: FbLikeCreateNestedManyWithoutPostInput
    wall: FbWallCreateNestedOneWithoutPostsInput
  }

  export type FbPostUncheckedCreateInput = {
    id?: number
    caption: string
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    postImages?: FbPostImageUncheckedCreateNestedManyWithoutPostInput
    postVideoes?: FbPostVideoUncheckedCreateNestedManyWithoutPostInput
    postOnHashtags?: FbPostOnHashtagUncheckedCreateNestedManyWithoutPostInput
    shares?: FbShareUncheckedCreateNestedManyWithoutPostInput
    likes?: FbLikeUncheckedCreateNestedManyWithoutPostInput
    wallId: number
  }

  export type FbPostUpdateInput = {
    caption?: StringFieldUpdateOperationsInput | string
    user?: FbUserUpdateOneRequiredWithoutPostsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postImages?: FbPostImageUpdateManyWithoutPostNestedInput
    postVideoes?: FbPostVideoUpdateManyWithoutPostNestedInput
    postOnHashtags?: FbPostOnHashtagUpdateManyWithoutPostNestedInput
    shares?: FbShareUpdateManyWithoutPostNestedInput
    likes?: FbLikeUpdateManyWithoutPostNestedInput
    wall?: FbWallUpdateOneRequiredWithoutPostsNestedInput
  }

  export type FbPostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    caption?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postImages?: FbPostImageUncheckedUpdateManyWithoutPostNestedInput
    postVideoes?: FbPostVideoUncheckedUpdateManyWithoutPostNestedInput
    postOnHashtags?: FbPostOnHashtagUncheckedUpdateManyWithoutPostNestedInput
    shares?: FbShareUncheckedUpdateManyWithoutPostNestedInput
    likes?: FbLikeUncheckedUpdateManyWithoutPostNestedInput
    wallId?: IntFieldUpdateOperationsInput | number
  }

  export type FbPostCreateManyInput = {
    id?: number
    caption: string
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    wallId: number
  }

  export type FbPostUpdateManyMutationInput = {
    caption?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbPostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    caption?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wallId?: IntFieldUpdateOperationsInput | number
  }

  export type FbPostImageCreateInput = {
    image: string
    post: FbPostCreateNestedOneWithoutPostImagesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbPostImageUncheckedCreateInput = {
    id?: number
    image: string
    postId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbPostImageUpdateInput = {
    image?: StringFieldUpdateOperationsInput | string
    post?: FbPostUpdateOneRequiredWithoutPostImagesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbPostImageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    postId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbPostImageCreateManyInput = {
    id?: number
    image: string
    postId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbPostImageUpdateManyMutationInput = {
    image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbPostImageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    postId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbPostVideoCreateInput = {
    video: string
    post: FbPostCreateNestedOneWithoutPostVideoesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbPostVideoUncheckedCreateInput = {
    id?: number
    video: string
    postId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbPostVideoUpdateInput = {
    video?: StringFieldUpdateOperationsInput | string
    post?: FbPostUpdateOneRequiredWithoutPostVideoesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbPostVideoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    video?: StringFieldUpdateOperationsInput | string
    postId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbPostVideoCreateManyInput = {
    id?: number
    video: string
    postId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbPostVideoUpdateManyMutationInput = {
    video?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbPostVideoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    video?: StringFieldUpdateOperationsInput | string
    postId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbHashtagCreateInput = {
    hashtag: string
    createdAt?: Date | string
    updatedAt?: Date | string
    postOnHashtags?: FbPostOnHashtagCreateNestedManyWithoutHashtagInput
  }

  export type FbHashtagUncheckedCreateInput = {
    id?: number
    hashtag: string
    createdAt?: Date | string
    updatedAt?: Date | string
    postOnHashtags?: FbPostOnHashtagUncheckedCreateNestedManyWithoutHashtagInput
  }

  export type FbHashtagUpdateInput = {
    hashtag?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postOnHashtags?: FbPostOnHashtagUpdateManyWithoutHashtagNestedInput
  }

  export type FbHashtagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    hashtag?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postOnHashtags?: FbPostOnHashtagUncheckedUpdateManyWithoutHashtagNestedInput
  }

  export type FbHashtagCreateManyInput = {
    id?: number
    hashtag: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbHashtagUpdateManyMutationInput = {
    hashtag?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbHashtagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    hashtag?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbPostOnHashtagCreateInput = {
    post: FbPostCreateNestedOneWithoutPostOnHashtagsInput
    hashtag: FbHashtagCreateNestedOneWithoutPostOnHashtagsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbPostOnHashtagUncheckedCreateInput = {
    id?: number
    postId: number
    hashtagId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbPostOnHashtagUpdateInput = {
    post?: FbPostUpdateOneRequiredWithoutPostOnHashtagsNestedInput
    hashtag?: FbHashtagUpdateOneRequiredWithoutPostOnHashtagsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbPostOnHashtagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    hashtagId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbPostOnHashtagCreateManyInput = {
    id?: number
    postId: number
    hashtagId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbPostOnHashtagUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbPostOnHashtagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    hashtagId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbLikeCreateInput = {
    user: FbUserCreateNestedOneWithoutLikesInput
    post: FbPostCreateNestedOneWithoutLikesInput
    comment: FbCommentCreateNestedOneWithoutLikesInput
    share: FbShareCreateNestedOneWithoutLikesInput
    likeType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbLikeUncheckedCreateInput = {
    id?: number
    userId: number
    postId: number
    commentId: number
    shareId: number
    likeType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbLikeUpdateInput = {
    user?: FbUserUpdateOneRequiredWithoutLikesNestedInput
    post?: FbPostUpdateOneRequiredWithoutLikesNestedInput
    comment?: FbCommentUpdateOneRequiredWithoutLikesNestedInput
    share?: FbShareUpdateOneRequiredWithoutLikesNestedInput
    likeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbLikeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    shareId?: IntFieldUpdateOperationsInput | number
    likeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbLikeCreateManyInput = {
    id?: number
    userId: number
    postId: number
    commentId: number
    shareId: number
    likeType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbLikeUpdateManyMutationInput = {
    likeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbLikeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    shareId?: IntFieldUpdateOperationsInput | number
    likeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbShareCreateInput = {
    user: FbUserCreateNestedOneWithoutSharesInput
    post: FbPostCreateNestedOneWithoutSharesInput
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: FbLikeCreateNestedManyWithoutShareInput
    destinationUsers?: FbDestinationUserCreateNestedManyWithoutShareInput
  }

  export type FbShareUncheckedCreateInput = {
    id?: number
    userId: number
    postId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: FbLikeUncheckedCreateNestedManyWithoutShareInput
    destinationUsers?: FbDestinationUserUncheckedCreateNestedManyWithoutShareInput
  }

  export type FbShareUpdateInput = {
    user?: FbUserUpdateOneRequiredWithoutSharesNestedInput
    post?: FbPostUpdateOneRequiredWithoutSharesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: FbLikeUpdateManyWithoutShareNestedInput
    destinationUsers?: FbDestinationUserUpdateManyWithoutShareNestedInput
  }

  export type FbShareUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: FbLikeUncheckedUpdateManyWithoutShareNestedInput
    destinationUsers?: FbDestinationUserUncheckedUpdateManyWithoutShareNestedInput
  }

  export type FbShareCreateManyInput = {
    id?: number
    userId: number
    postId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbShareUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbShareUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbfriendCreateInput = {
    acceptFriend: FbUserCreateNestedOneWithoutAcceptFbFriendsInput
    requestFriend: FbUserCreateNestedOneWithoutRequestFbFriendsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbfriendUncheckedCreateInput = {
    id?: number
    acceptId: number
    requestId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbfriendUpdateInput = {
    acceptFriend?: FbUserUpdateOneRequiredWithoutAcceptFbFriendsNestedInput
    requestFriend?: FbUserUpdateOneRequiredWithoutRequestFbFriendsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbfriendUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    acceptId?: IntFieldUpdateOperationsInput | number
    requestId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbfriendCreateManyInput = {
    id?: number
    acceptId: number
    requestId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbfriendUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbfriendUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    acceptId?: IntFieldUpdateOperationsInput | number
    requestId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbMessengerCreateInput = {
    from: FbUserCreateNestedOneWithoutFromMessengersInput
    to: FbUserCreateNestedOneWithoutToMessengersInput
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbMessengerUncheckedCreateInput = {
    id?: number
    fromuserId: number
    toUserId: number
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbMessengerUpdateInput = {
    from?: FbUserUpdateOneRequiredWithoutFromMessengersNestedInput
    to?: FbUserUpdateOneRequiredWithoutToMessengersNestedInput
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbMessengerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromuserId?: IntFieldUpdateOperationsInput | number
    toUserId?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbMessengerCreateManyInput = {
    id?: number
    fromuserId: number
    toUserId: number
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbMessengerUpdateManyMutationInput = {
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbMessengerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromuserId?: IntFieldUpdateOperationsInput | number
    toUserId?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbCommentCreateInput = {
    text: string
    user: FbUserCreateNestedOneWithoutCommentsInput
    likes?: FbLikeCreateNestedManyWithoutCommentInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbCommentUncheckedCreateInput = {
    id?: number
    text: string
    userId: number
    likes?: FbLikeUncheckedCreateNestedManyWithoutCommentInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbCommentUpdateInput = {
    text?: StringFieldUpdateOperationsInput | string
    user?: FbUserUpdateOneRequiredWithoutCommentsNestedInput
    likes?: FbLikeUpdateManyWithoutCommentNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbCommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    likes?: FbLikeUncheckedUpdateManyWithoutCommentNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbCommentCreateManyInput = {
    id?: number
    text: string
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbCommentUpdateManyMutationInput = {
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbCommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbGroupCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    groupToUsers?: GroupToUserCreateNestedManyWithoutGroupInput
    destinationUsers?: FbDestinationUserCreateNestedManyWithoutGroupInput
  }

  export type FbGroupUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    groupToUsers?: GroupToUserUncheckedCreateNestedManyWithoutGroupInput
    destinationUsers?: FbDestinationUserUncheckedCreateNestedManyWithoutGroupInput
  }

  export type FbGroupUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupToUsers?: GroupToUserUpdateManyWithoutGroupNestedInput
    destinationUsers?: FbDestinationUserUpdateManyWithoutGroupNestedInput
  }

  export type FbGroupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupToUsers?: GroupToUserUncheckedUpdateManyWithoutGroupNestedInput
    destinationUsers?: FbDestinationUserUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type FbGroupCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbGroupUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbGroupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupToUserCreateInput = {
    user: FbUserCreateNestedOneWithoutGroupToUsersInput
    group: FbGroupCreateNestedOneWithoutGroupToUsersInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupToUserUncheckedCreateInput = {
    id?: number
    userId: number
    groupId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupToUserUpdateInput = {
    user?: FbUserUpdateOneRequiredWithoutGroupToUsersNestedInput
    group?: FbGroupUpdateOneRequiredWithoutGroupToUsersNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupToUserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupToUserCreateManyInput = {
    id?: number
    userId: number
    groupId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupToUserUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupToUserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbWallCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: FbPostCreateNestedManyWithoutWallInput
    destinationUsers?: FbDestinationUserCreateNestedManyWithoutWallInput
  }

  export type FbWallUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: FbPostUncheckedCreateNestedManyWithoutWallInput
    destinationUsers?: FbDestinationUserUncheckedCreateNestedManyWithoutWallInput
  }

  export type FbWallUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: FbPostUpdateManyWithoutWallNestedInput
    destinationUsers?: FbDestinationUserUpdateManyWithoutWallNestedInput
  }

  export type FbWallUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: FbPostUncheckedUpdateManyWithoutWallNestedInput
    destinationUsers?: FbDestinationUserUncheckedUpdateManyWithoutWallNestedInput
  }

  export type FbWallCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbWallUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbWallUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbDestinationUserCreateInput = {
    wall: FbWallCreateNestedOneWithoutDestinationUsersInput
    share: FbShareCreateNestedOneWithoutDestinationUsersInput
    group: FbGroupCreateNestedOneWithoutDestinationUsersInput
  }

  export type FbDestinationUserUncheckedCreateInput = {
    id?: number
    fbWallId: number
    shareId: number
    groupId: number
  }

  export type FbDestinationUserUpdateInput = {
    wall?: FbWallUpdateOneRequiredWithoutDestinationUsersNestedInput
    share?: FbShareUpdateOneRequiredWithoutDestinationUsersNestedInput
    group?: FbGroupUpdateOneRequiredWithoutDestinationUsersNestedInput
  }

  export type FbDestinationUserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fbWallId?: IntFieldUpdateOperationsInput | number
    shareId?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
  }

  export type FbDestinationUserCreateManyInput = {
    id?: number
    fbWallId: number
    shareId: number
    groupId: number
  }

  export type FbDestinationUserUpdateManyMutationInput = {

  }

  export type FbDestinationUserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fbWallId?: IntFieldUpdateOperationsInput | number
    shareId?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
  }

  export type KorKitchenCategoryCreateInput = {
    name: string
    menu?: KorKitchenMenuCreateNestedManyWithoutCategoryInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type KorKitchenCategoryUncheckedCreateInput = {
    id?: number
    name: string
    menu?: KorKitchenMenuUncheckedCreateNestedManyWithoutCategoryInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type KorKitchenCategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    menu?: KorKitchenMenuUpdateManyWithoutCategoryNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KorKitchenCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    menu?: KorKitchenMenuUncheckedUpdateManyWithoutCategoryNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KorKitchenCategoryCreateManyInput = {
    id?: number
    name: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type KorKitchenCategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KorKitchenCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KorKitchenMenuCreateInput = {
    name: string
    image: string
    price: number
    category?: KorKitchenCategoryCreateNestedOneWithoutMenuInput
    orderItems?: KorKitchenOrderItemCreateNestedManyWithoutMenuInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type KorKitchenMenuUncheckedCreateInput = {
    id?: number
    name: string
    image: string
    price: number
    categoryName?: string | null
    orderItems?: KorKitchenOrderItemUncheckedCreateNestedManyWithoutMenuInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type KorKitchenMenuUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    category?: KorKitchenCategoryUpdateOneWithoutMenuNestedInput
    orderItems?: KorKitchenOrderItemUpdateManyWithoutMenuNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KorKitchenMenuUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    categoryName?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: KorKitchenOrderItemUncheckedUpdateManyWithoutMenuNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KorKitchenMenuCreateManyInput = {
    id?: number
    name: string
    image: string
    price: number
    categoryName?: string | null
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type KorKitchenMenuUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KorKitchenMenuUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    categoryName?: NullableStringFieldUpdateOperationsInput | string | null
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KorKitchenOrderCreateInput = {
    status?: string
    tableId: number
    items?: KorKitchenOrderItemCreateNestedManyWithoutOrderInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type KorKitchenOrderUncheckedCreateInput = {
    id?: number
    status?: string
    tableId: number
    items?: KorKitchenOrderItemUncheckedCreateNestedManyWithoutOrderInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type KorKitchenOrderUpdateInput = {
    status?: StringFieldUpdateOperationsInput | string
    tableId?: IntFieldUpdateOperationsInput | number
    items?: KorKitchenOrderItemUpdateManyWithoutOrderNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KorKitchenOrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    tableId?: IntFieldUpdateOperationsInput | number
    items?: KorKitchenOrderItemUncheckedUpdateManyWithoutOrderNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KorKitchenOrderCreateManyInput = {
    id?: number
    status?: string
    tableId: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type KorKitchenOrderUpdateManyMutationInput = {
    status?: StringFieldUpdateOperationsInput | string
    tableId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KorKitchenOrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    tableId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KorKitchenOrderItemCreateInput = {
    menu: KorKitchenMenuCreateNestedOneWithoutOrderItemsInput
    order?: KorKitchenOrderCreateNestedOneWithoutItemsInput
    quantity: number
    totalPrice: number
    creatAt?: Date | string
    updatedAt?: Date | string
  }

  export type KorKitchenOrderItemUncheckedCreateInput = {
    id?: number
    menuId: number
    orderId?: number | null
    quantity: number
    totalPrice: number
    creatAt?: Date | string
    updatedAt?: Date | string
  }

  export type KorKitchenOrderItemUpdateInput = {
    menu?: KorKitchenMenuUpdateOneRequiredWithoutOrderItemsNestedInput
    order?: KorKitchenOrderUpdateOneWithoutItemsNestedInput
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    creatAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KorKitchenOrderItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuId?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    creatAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KorKitchenOrderItemCreateManyInput = {
    id?: number
    menuId: number
    orderId?: number | null
    quantity: number
    totalPrice: number
    creatAt?: Date | string
    updatedAt?: Date | string
  }

  export type KorKitchenOrderItemUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    creatAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KorKitchenOrderItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuId?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    creatAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TodoListCreateInput = {
    task: string
    status?: string
    note?: string | null
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type TodoListUncheckedCreateInput = {
    id?: number
    task: string
    status?: string
    note?: string | null
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type TodoListUpdateInput = {
    task?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TodoListUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    task?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TodoListCreateManyInput = {
    id?: number
    task: string
    status?: string
    note?: string | null
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type TodoListUpdateManyMutationInput = {
    task?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TodoListUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    task?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestModelCreateInput = {
    firstname: string
    Surname: string
  }

  export type TestModelUncheckedCreateInput = {
    id?: number
    firstname: string
    Surname: string
  }

  export type TestModelUpdateInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    Surname?: StringFieldUpdateOperationsInput | string
  }

  export type TestModelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    Surname?: StringFieldUpdateOperationsInput | string
  }

  export type TestModelCreateManyInput = {
    id?: number
    firstname: string
    Surname: string
  }

  export type TestModelUpdateManyMutationInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    Surname?: StringFieldUpdateOperationsInput | string
  }

  export type TestModelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    Surname?: StringFieldUpdateOperationsInput | string
  }

  export type TriviaCategoryCreateInput = {
    name: string
    questions?: TriviaQuestionCreateNestedManyWithoutCategoryInput
    rounds?: TriviaRoundCreateNestedManyWithoutCategoryInput
  }

  export type TriviaCategoryUncheckedCreateInput = {
    id?: number
    name: string
    questions?: TriviaQuestionUncheckedCreateNestedManyWithoutCategoryInput
    rounds?: TriviaRoundUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type TriviaCategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    questions?: TriviaQuestionUpdateManyWithoutCategoryNestedInput
    rounds?: TriviaRoundUpdateManyWithoutCategoryNestedInput
  }

  export type TriviaCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    questions?: TriviaQuestionUncheckedUpdateManyWithoutCategoryNestedInput
    rounds?: TriviaRoundUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type TriviaCategoryCreateManyInput = {
    id?: number
    name: string
  }

  export type TriviaCategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TriviaCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TriviaQuestionCreateInput = {
    category: TriviaCategoryCreateNestedOneWithoutQuestionsInput
    name: string
    answerID: number
    choices?: TriviaChoiceCreateNestedManyWithoutQuestionInput
    roundQuestions?: TriviaRoundQuestionCreateNestedManyWithoutQuestionInput
  }

  export type TriviaQuestionUncheckedCreateInput = {
    id?: number
    categoryId: number
    name: string
    answerID: number
    choices?: TriviaChoiceUncheckedCreateNestedManyWithoutQuestionInput
    roundQuestions?: TriviaRoundQuestionUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type TriviaQuestionUpdateInput = {
    category?: TriviaCategoryUpdateOneRequiredWithoutQuestionsNestedInput
    name?: StringFieldUpdateOperationsInput | string
    answerID?: IntFieldUpdateOperationsInput | number
    choices?: TriviaChoiceUpdateManyWithoutQuestionNestedInput
    roundQuestions?: TriviaRoundQuestionUpdateManyWithoutQuestionNestedInput
  }

  export type TriviaQuestionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    answerID?: IntFieldUpdateOperationsInput | number
    choices?: TriviaChoiceUncheckedUpdateManyWithoutQuestionNestedInput
    roundQuestions?: TriviaRoundQuestionUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type TriviaQuestionCreateManyInput = {
    id?: number
    categoryId: number
    name: string
    answerID: number
  }

  export type TriviaQuestionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    answerID?: IntFieldUpdateOperationsInput | number
  }

  export type TriviaQuestionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    answerID?: IntFieldUpdateOperationsInput | number
  }

  export type TriviaChoiceCreateInput = {
    question: TriviaQuestionCreateNestedOneWithoutChoicesInput
    name: string
    roundQuestions?: TriviaRoundQuestionCreateNestedManyWithoutUserChoiceInput
  }

  export type TriviaChoiceUncheckedCreateInput = {
    id?: number
    quizId: number
    name: string
    roundQuestions?: TriviaRoundQuestionUncheckedCreateNestedManyWithoutUserChoiceInput
  }

  export type TriviaChoiceUpdateInput = {
    question?: TriviaQuestionUpdateOneRequiredWithoutChoicesNestedInput
    name?: StringFieldUpdateOperationsInput | string
    roundQuestions?: TriviaRoundQuestionUpdateManyWithoutUserChoiceNestedInput
  }

  export type TriviaChoiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    roundQuestions?: TriviaRoundQuestionUncheckedUpdateManyWithoutUserChoiceNestedInput
  }

  export type TriviaChoiceCreateManyInput = {
    id?: number
    quizId: number
    name: string
  }

  export type TriviaChoiceUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TriviaChoiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TriviaRoundQuestionCreateInput = {
    question: TriviaQuestionCreateNestedOneWithoutRoundQuestionsInput
    userChoice: TriviaChoiceCreateNestedOneWithoutRoundQuestionsInput
    quizResult: boolean
    round?: TriviaRoundCreateNestedOneWithoutQuestionsInput
  }

  export type TriviaRoundQuestionUncheckedCreateInput = {
    id?: number
    quizId: number
    choiceId: number
    quizResult: boolean
    roundId?: number | null
  }

  export type TriviaRoundQuestionUpdateInput = {
    question?: TriviaQuestionUpdateOneRequiredWithoutRoundQuestionsNestedInput
    userChoice?: TriviaChoiceUpdateOneRequiredWithoutRoundQuestionsNestedInput
    quizResult?: BoolFieldUpdateOperationsInput | boolean
    round?: TriviaRoundUpdateOneWithoutQuestionsNestedInput
  }

  export type TriviaRoundQuestionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    choiceId?: IntFieldUpdateOperationsInput | number
    quizResult?: BoolFieldUpdateOperationsInput | boolean
    roundId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TriviaRoundQuestionCreateManyInput = {
    id?: number
    quizId: number
    choiceId: number
    quizResult: boolean
    roundId?: number | null
  }

  export type TriviaRoundQuestionUpdateManyMutationInput = {
    quizResult?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TriviaRoundQuestionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    choiceId?: IntFieldUpdateOperationsInput | number
    quizResult?: BoolFieldUpdateOperationsInput | boolean
    roundId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TriviaRoundCreateInput = {
    user: string
    questions?: TriviaRoundQuestionCreateNestedManyWithoutRoundInput
    category: TriviaCategoryCreateNestedOneWithoutRoundsInput
    totalResult: number
    createAt?: Date | string
  }

  export type TriviaRoundUncheckedCreateInput = {
    id?: number
    user: string
    questions?: TriviaRoundQuestionUncheckedCreateNestedManyWithoutRoundInput
    categoryId: number
    totalResult: number
    createAt?: Date | string
  }

  export type TriviaRoundUpdateInput = {
    user?: StringFieldUpdateOperationsInput | string
    questions?: TriviaRoundQuestionUpdateManyWithoutRoundNestedInput
    category?: TriviaCategoryUpdateOneRequiredWithoutRoundsNestedInput
    totalResult?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TriviaRoundUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    questions?: TriviaRoundQuestionUncheckedUpdateManyWithoutRoundNestedInput
    categoryId?: IntFieldUpdateOperationsInput | number
    totalResult?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TriviaRoundCreateManyInput = {
    id?: number
    user: string
    categoryId: number
    totalResult: number
    createAt?: Date | string
  }

  export type TriviaRoundUpdateManyMutationInput = {
    user?: StringFieldUpdateOperationsInput | string
    totalResult?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TriviaRoundUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    totalResult?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterUserCreateInput = {
    name: string
    Image: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fromFollowing?: TwitterFollowCreateNestedManyWithoutFromInput
    toFollowing?: TwitterFollowCreateNestedManyWithoutToInput
    posts?: TwitterPostCreateNestedManyWithoutUserInput
    fromDirectMessage?: TwitterDirectMessageCreateNestedManyWithoutFromInput
    toDirectMessage?: TwitterDirectMessageCreateNestedManyWithoutToInput
    comments?: TwitterCommentCreateNestedManyWithoutUserInput
  }

  export type TwitterUserUncheckedCreateInput = {
    id?: number
    name: string
    Image: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fromFollowing?: TwitterFollowUncheckedCreateNestedManyWithoutFromInput
    toFollowing?: TwitterFollowUncheckedCreateNestedManyWithoutToInput
    posts?: TwitterPostUncheckedCreateNestedManyWithoutUserInput
    fromDirectMessage?: TwitterDirectMessageUncheckedCreateNestedManyWithoutFromInput
    toDirectMessage?: TwitterDirectMessageUncheckedCreateNestedManyWithoutToInput
    comments?: TwitterCommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type TwitterUserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    Image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromFollowing?: TwitterFollowUpdateManyWithoutFromNestedInput
    toFollowing?: TwitterFollowUpdateManyWithoutToNestedInput
    posts?: TwitterPostUpdateManyWithoutUserNestedInput
    fromDirectMessage?: TwitterDirectMessageUpdateManyWithoutFromNestedInput
    toDirectMessage?: TwitterDirectMessageUpdateManyWithoutToNestedInput
    comments?: TwitterCommentUpdateManyWithoutUserNestedInput
  }

  export type TwitterUserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    Image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromFollowing?: TwitterFollowUncheckedUpdateManyWithoutFromNestedInput
    toFollowing?: TwitterFollowUncheckedUpdateManyWithoutToNestedInput
    posts?: TwitterPostUncheckedUpdateManyWithoutUserNestedInput
    fromDirectMessage?: TwitterDirectMessageUncheckedUpdateManyWithoutFromNestedInput
    toDirectMessage?: TwitterDirectMessageUncheckedUpdateManyWithoutToNestedInput
    comments?: TwitterCommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TwitterUserCreateManyInput = {
    id?: number
    name: string
    Image: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterUserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    Image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterUserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    Image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterFollowCreateInput = {
    from: TwitterUserCreateNestedOneWithoutFromFollowingInput
    to: TwitterUserCreateNestedOneWithoutToFollowingInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterFollowUncheckedCreateInput = {
    id?: number
    fromUserId: number
    toUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterFollowUpdateInput = {
    from?: TwitterUserUpdateOneRequiredWithoutFromFollowingNestedInput
    to?: TwitterUserUpdateOneRequiredWithoutToFollowingNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterFollowUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromUserId?: IntFieldUpdateOperationsInput | number
    toUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterFollowCreateManyInput = {
    id?: number
    fromUserId: number
    toUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterFollowUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterFollowUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromUserId?: IntFieldUpdateOperationsInput | number
    toUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterPostCreateInput = {
    caption: string
    user: TwitterUserCreateNestedOneWithoutPostsInput
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: TwitterCommentCreateNestedManyWithoutPostInput
    postOnHashtags?: TwitterPostOnHashtagCreateNestedManyWithoutPostInput
  }

  export type TwitterPostUncheckedCreateInput = {
    id?: number
    caption: string
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: TwitterCommentUncheckedCreateNestedManyWithoutPostInput
    postOnHashtags?: TwitterPostOnHashtagUncheckedCreateNestedManyWithoutPostInput
  }

  export type TwitterPostUpdateInput = {
    caption?: StringFieldUpdateOperationsInput | string
    user?: TwitterUserUpdateOneRequiredWithoutPostsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: TwitterCommentUpdateManyWithoutPostNestedInput
    postOnHashtags?: TwitterPostOnHashtagUpdateManyWithoutPostNestedInput
  }

  export type TwitterPostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    caption?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: TwitterCommentUncheckedUpdateManyWithoutPostNestedInput
    postOnHashtags?: TwitterPostOnHashtagUncheckedUpdateManyWithoutPostNestedInput
  }

  export type TwitterPostCreateManyInput = {
    id?: number
    caption: string
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterPostUpdateManyMutationInput = {
    caption?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterPostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    caption?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterDirectMessageCreateInput = {
    from: TwitterUserCreateNestedOneWithoutFromDirectMessageInput
    to: TwitterUserCreateNestedOneWithoutToDirectMessageInput
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterDirectMessageUncheckedCreateInput = {
    id?: number
    fromUserId: number
    toUserId: number
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterDirectMessageUpdateInput = {
    from?: TwitterUserUpdateOneRequiredWithoutFromDirectMessageNestedInput
    to?: TwitterUserUpdateOneRequiredWithoutToDirectMessageNestedInput
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterDirectMessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromUserId?: IntFieldUpdateOperationsInput | number
    toUserId?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterDirectMessageCreateManyInput = {
    id?: number
    fromUserId: number
    toUserId: number
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterDirectMessageUpdateManyMutationInput = {
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterDirectMessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromUserId?: IntFieldUpdateOperationsInput | number
    toUserId?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterHashtagCreateInput = {
    hashtag: string
    createdAt?: Date | string
    updatedAt?: Date | string
    postOnHashtag?: TwitterPostOnHashtagCreateNestedManyWithoutHashtagInput
  }

  export type TwitterHashtagUncheckedCreateInput = {
    id?: number
    hashtag: string
    createdAt?: Date | string
    updatedAt?: Date | string
    postOnHashtag?: TwitterPostOnHashtagUncheckedCreateNestedManyWithoutHashtagInput
  }

  export type TwitterHashtagUpdateInput = {
    hashtag?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postOnHashtag?: TwitterPostOnHashtagUpdateManyWithoutHashtagNestedInput
  }

  export type TwitterHashtagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    hashtag?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postOnHashtag?: TwitterPostOnHashtagUncheckedUpdateManyWithoutHashtagNestedInput
  }

  export type TwitterHashtagCreateManyInput = {
    id?: number
    hashtag: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterHashtagUpdateManyMutationInput = {
    hashtag?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterHashtagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    hashtag?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterCommentCreateInput = {
    text: string
    user: TwitterUserCreateNestedOneWithoutCommentsInput
    post: TwitterPostCreateNestedOneWithoutCommentsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterCommentUncheckedCreateInput = {
    id?: number
    text: string
    userId: number
    postId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterCommentUpdateInput = {
    text?: StringFieldUpdateOperationsInput | string
    user?: TwitterUserUpdateOneRequiredWithoutCommentsNestedInput
    post?: TwitterPostUpdateOneRequiredWithoutCommentsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterCommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterCommentCreateManyInput = {
    id?: number
    text: string
    userId: number
    postId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterCommentUpdateManyMutationInput = {
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterCommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterPostOnHashtagCreateInput = {
    post: TwitterPostCreateNestedOneWithoutPostOnHashtagsInput
    hashtag: TwitterHashtagCreateNestedOneWithoutPostOnHashtagInput
  }

  export type TwitterPostOnHashtagUncheckedCreateInput = {
    id?: number
    postId: number
    hashtagId: number
  }

  export type TwitterPostOnHashtagUpdateInput = {
    post?: TwitterPostUpdateOneRequiredWithoutPostOnHashtagsNestedInput
    hashtag?: TwitterHashtagUpdateOneRequiredWithoutPostOnHashtagNestedInput
  }

  export type TwitterPostOnHashtagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    hashtagId?: IntFieldUpdateOperationsInput | number
  }

  export type TwitterPostOnHashtagCreateManyInput = {
    id?: number
    postId: number
    hashtagId: number
  }

  export type TwitterPostOnHashtagUpdateManyMutationInput = {

  }

  export type TwitterPostOnHashtagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    hashtagId?: IntFieldUpdateOperationsInput | number
  }

  export type WSUserCreateInput = {
    name: string
    tel: number
    myWallet: number
    createdAt?: Date | string
    updateAt?: Date | string
    topupHistories?: WSTopupHistoryCreateNestedManyWithoutUserInput
    usingHistories?: WSUsingHistoryCreateNestedManyWithoutUserInput
  }

  export type WSUserUncheckedCreateInput = {
    id?: number
    name: string
    tel: number
    myWallet: number
    createdAt?: Date | string
    updateAt?: Date | string
    topupHistories?: WSTopupHistoryUncheckedCreateNestedManyWithoutUserInput
    usingHistories?: WSUsingHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type WSUserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    tel?: IntFieldUpdateOperationsInput | number
    myWallet?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topupHistories?: WSTopupHistoryUpdateManyWithoutUserNestedInput
    usingHistories?: WSUsingHistoryUpdateManyWithoutUserNestedInput
  }

  export type WSUserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tel?: IntFieldUpdateOperationsInput | number
    myWallet?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topupHistories?: WSTopupHistoryUncheckedUpdateManyWithoutUserNestedInput
    usingHistories?: WSUsingHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WSUserCreateManyInput = {
    id?: number
    name: string
    tel: number
    myWallet: number
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type WSUserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    tel?: IntFieldUpdateOperationsInput | number
    myWallet?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WSUserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tel?: IntFieldUpdateOperationsInput | number
    myWallet?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WSTopupHistoryCreateInput = {
    user: WSUserCreateNestedOneWithoutTopupHistoriesInput
    topup: number
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type WSTopupHistoryUncheckedCreateInput = {
    id?: number
    userId: number
    topup: number
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type WSTopupHistoryUpdateInput = {
    user?: WSUserUpdateOneRequiredWithoutTopupHistoriesNestedInput
    topup?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WSTopupHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    topup?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WSTopupHistoryCreateManyInput = {
    id?: number
    userId: number
    topup: number
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type WSTopupHistoryUpdateManyMutationInput = {
    topup?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WSTopupHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    topup?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WSUsingHistoryCreateInput = {
    user: WSUserCreateNestedOneWithoutUsingHistoriesInput
    price: number
    createdAt?: Date | string
    updateAt?: Date | string
    machine: WSMachineCreateNestedOneWithoutUsingHistoriesInput
    program: WSProgramCreateNestedOneWithoutUsingHistoriesInput
    usingStartAt: Date | string
    finishingAt: Date | string
  }

  export type WSUsingHistoryUncheckedCreateInput = {
    id?: number
    userId: number
    price: number
    createdAt?: Date | string
    updateAt?: Date | string
    usingStartAt: Date | string
    finishingAt: Date | string
    wSMachineId: number
    wSProgramId: number
  }

  export type WSUsingHistoryUpdateInput = {
    user?: WSUserUpdateOneRequiredWithoutUsingHistoriesNestedInput
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    machine?: WSMachineUpdateOneRequiredWithoutUsingHistoriesNestedInput
    program?: WSProgramUpdateOneRequiredWithoutUsingHistoriesNestedInput
    usingStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishingAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WSUsingHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usingStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishingAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wSMachineId?: IntFieldUpdateOperationsInput | number
    wSProgramId?: IntFieldUpdateOperationsInput | number
  }

  export type WSUsingHistoryCreateManyInput = {
    id?: number
    userId: number
    price: number
    createdAt?: Date | string
    updateAt?: Date | string
    usingStartAt: Date | string
    finishingAt: Date | string
    wSMachineId: number
    wSProgramId: number
  }

  export type WSUsingHistoryUpdateManyMutationInput = {
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usingStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishingAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WSUsingHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usingStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishingAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wSMachineId?: IntFieldUpdateOperationsInput | number
    wSProgramId?: IntFieldUpdateOperationsInput | number
  }

  export type WSShopCreateInput = {
    branch: string
    owner: string
    tel: number
    location: string
    area: string
    machines?: WSMachineCreateNestedManyWithoutShopInput
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type WSShopUncheckedCreateInput = {
    id?: number
    branch: string
    owner: string
    tel: number
    location: string
    area: string
    machines?: WSMachineUncheckedCreateNestedManyWithoutShopInput
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type WSShopUpdateInput = {
    branch?: StringFieldUpdateOperationsInput | string
    owner?: StringFieldUpdateOperationsInput | string
    tel?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    machines?: WSMachineUpdateManyWithoutShopNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WSShopUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    branch?: StringFieldUpdateOperationsInput | string
    owner?: StringFieldUpdateOperationsInput | string
    tel?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    machines?: WSMachineUncheckedUpdateManyWithoutShopNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WSShopCreateManyInput = {
    id?: number
    branch: string
    owner: string
    tel: number
    location: string
    area: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type WSShopUpdateManyMutationInput = {
    branch?: StringFieldUpdateOperationsInput | string
    owner?: StringFieldUpdateOperationsInput | string
    tel?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WSShopUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    branch?: StringFieldUpdateOperationsInput | string
    owner?: StringFieldUpdateOperationsInput | string
    tel?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WSMachineCreateInput = {
    shop: WSShopCreateNestedOneWithoutMachinesInput
    brandname: string
    size: string
    type: string
    model: string
    producedDate: string
    insuranceExpiredDate: string
    createdAt?: Date | string
    updateAt?: Date | string
    machineToPrograms?: MachineToProgramCreateNestedManyWithoutMachingInput
    maintains?: WSMaintainCreateNestedManyWithoutMachineInput
    usingHistories?: WSUsingHistoryCreateNestedManyWithoutMachineInput
  }

  export type WSMachineUncheckedCreateInput = {
    id?: number
    shopId: number
    brandname: string
    size: string
    type: string
    model: string
    producedDate: string
    insuranceExpiredDate: string
    createdAt?: Date | string
    updateAt?: Date | string
    machineToPrograms?: MachineToProgramUncheckedCreateNestedManyWithoutMachingInput
    maintains?: WSMaintainUncheckedCreateNestedManyWithoutMachineInput
    usingHistories?: WSUsingHistoryUncheckedCreateNestedManyWithoutMachineInput
  }

  export type WSMachineUpdateInput = {
    shop?: WSShopUpdateOneRequiredWithoutMachinesNestedInput
    brandname?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    producedDate?: StringFieldUpdateOperationsInput | string
    insuranceExpiredDate?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    machineToPrograms?: MachineToProgramUpdateManyWithoutMachingNestedInput
    maintains?: WSMaintainUpdateManyWithoutMachineNestedInput
    usingHistories?: WSUsingHistoryUpdateManyWithoutMachineNestedInput
  }

  export type WSMachineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    brandname?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    producedDate?: StringFieldUpdateOperationsInput | string
    insuranceExpiredDate?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    machineToPrograms?: MachineToProgramUncheckedUpdateManyWithoutMachingNestedInput
    maintains?: WSMaintainUncheckedUpdateManyWithoutMachineNestedInput
    usingHistories?: WSUsingHistoryUncheckedUpdateManyWithoutMachineNestedInput
  }

  export type WSMachineCreateManyInput = {
    id?: number
    shopId: number
    brandname: string
    size: string
    type: string
    model: string
    producedDate: string
    insuranceExpiredDate: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type WSMachineUpdateManyMutationInput = {
    brandname?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    producedDate?: StringFieldUpdateOperationsInput | string
    insuranceExpiredDate?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WSMachineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    brandname?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    producedDate?: StringFieldUpdateOperationsInput | string
    insuranceExpiredDate?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WSProgramCreateInput = {
    name: string
    createdAt?: Date | string
    updateAt?: Date | string
    machineToPrograms?: MachineToProgramCreateNestedManyWithoutProgramInput
    programLists?: WSProgramDetailCreateNestedManyWithoutProgramInput
    activeProgram: WSProgramDetailCreateNestedOneWithoutProgramsInput
    usingHistories?: WSUsingHistoryCreateNestedManyWithoutProgramInput
  }

  export type WSProgramUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updateAt?: Date | string
    machineToPrograms?: MachineToProgramUncheckedCreateNestedManyWithoutProgramInput
    programLists?: WSProgramDetailUncheckedCreateNestedManyWithoutProgramInput
    usingHistories?: WSUsingHistoryUncheckedCreateNestedManyWithoutProgramInput
    activeProgramId: number
  }

  export type WSProgramUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    machineToPrograms?: MachineToProgramUpdateManyWithoutProgramNestedInput
    programLists?: WSProgramDetailUpdateManyWithoutProgramNestedInput
    activeProgram?: WSProgramDetailUpdateOneRequiredWithoutProgramsNestedInput
    usingHistories?: WSUsingHistoryUpdateManyWithoutProgramNestedInput
  }

  export type WSProgramUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    machineToPrograms?: MachineToProgramUncheckedUpdateManyWithoutProgramNestedInput
    programLists?: WSProgramDetailUncheckedUpdateManyWithoutProgramNestedInput
    usingHistories?: WSUsingHistoryUncheckedUpdateManyWithoutProgramNestedInput
    activeProgramId?: IntFieldUpdateOperationsInput | number
  }

  export type WSProgramCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updateAt?: Date | string
    activeProgramId: number
  }

  export type WSProgramUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WSProgramUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeProgramId?: IntFieldUpdateOperationsInput | number
  }

  export type MachineToProgramCreateInput = {
    maching: WSMachineCreateNestedOneWithoutMachineToProgramsInput
    program: WSProgramCreateNestedOneWithoutMachineToProgramsInput
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type MachineToProgramUncheckedCreateInput = {
    id?: number
    machineId: number
    programId: number
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type MachineToProgramUpdateInput = {
    maching?: WSMachineUpdateOneRequiredWithoutMachineToProgramsNestedInput
    program?: WSProgramUpdateOneRequiredWithoutMachineToProgramsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineToProgramUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    machineId?: IntFieldUpdateOperationsInput | number
    programId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineToProgramCreateManyInput = {
    id?: number
    machineId: number
    programId: number
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type MachineToProgramUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineToProgramUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    machineId?: IntFieldUpdateOperationsInput | number
    programId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WSProgramDetailCreateInput = {
    program: WSProgramCreateNestedOneWithoutProgramListsInput
    price: number
    duration: number
    weight: number
    createdAt?: Date | string
    updateAt?: Date | string
    programs?: WSProgramCreateNestedManyWithoutActiveProgramInput
  }

  export type WSProgramDetailUncheckedCreateInput = {
    id?: number
    programId: number
    price: number
    duration: number
    weight: number
    createdAt?: Date | string
    updateAt?: Date | string
    programs?: WSProgramUncheckedCreateNestedManyWithoutActiveProgramInput
  }

  export type WSProgramDetailUpdateInput = {
    program?: WSProgramUpdateOneRequiredWithoutProgramListsNestedInput
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    weight?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programs?: WSProgramUpdateManyWithoutActiveProgramNestedInput
  }

  export type WSProgramDetailUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    programId?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    weight?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programs?: WSProgramUncheckedUpdateManyWithoutActiveProgramNestedInput
  }

  export type WSProgramDetailCreateManyInput = {
    id?: number
    programId: number
    price: number
    duration: number
    weight: number
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type WSProgramDetailUpdateManyMutationInput = {
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    weight?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WSProgramDetailUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    programId?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    weight?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WSMaintainCreateInput = {
    checker: string
    item: string
    status: string
    machine: WSMachineCreateNestedOneWithoutMaintainsInput
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type WSMaintainUncheckedCreateInput = {
    id?: number
    checker: string
    item: string
    status: string
    machineId: number
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type WSMaintainUpdateInput = {
    checker?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    machine?: WSMachineUpdateOneRequiredWithoutMaintainsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WSMaintainUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    checker?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    machineId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WSMaintainCreateManyInput = {
    id?: number
    checker: string
    item: string
    status: string
    machineId: number
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type WSMaintainUpdateManyMutationInput = {
    checker?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WSMaintainUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    checker?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    machineId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YTUserCreateInput = {
    user: string
    email: string
    avatar: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userToChannels?: UserToChannelCreateNestedManyWithoutUserInput
    comments?: YTCommentCreateNestedManyWithoutUserInput
    subscribes?: YTSubscribeCreateNestedManyWithoutUserInput
    shares?: YTShareCreateNestedManyWithoutUserInput
  }

  export type YTUserUncheckedCreateInput = {
    id?: number
    user: string
    email: string
    avatar: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userToChannels?: UserToChannelUncheckedCreateNestedManyWithoutUserInput
    comments?: YTCommentUncheckedCreateNestedManyWithoutUserInput
    subscribes?: YTSubscribeUncheckedCreateNestedManyWithoutUserInput
    shares?: YTShareUncheckedCreateNestedManyWithoutUserInput
  }

  export type YTUserUpdateInput = {
    user?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userToChannels?: UserToChannelUpdateManyWithoutUserNestedInput
    comments?: YTCommentUpdateManyWithoutUserNestedInput
    subscribes?: YTSubscribeUpdateManyWithoutUserNestedInput
    shares?: YTShareUpdateManyWithoutUserNestedInput
  }

  export type YTUserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userToChannels?: UserToChannelUncheckedUpdateManyWithoutUserNestedInput
    comments?: YTCommentUncheckedUpdateManyWithoutUserNestedInput
    subscribes?: YTSubscribeUncheckedUpdateManyWithoutUserNestedInput
    shares?: YTShareUncheckedUpdateManyWithoutUserNestedInput
  }

  export type YTUserCreateManyInput = {
    id?: number
    user: string
    email: string
    avatar: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YTUserUpdateManyMutationInput = {
    user?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YTUserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YTChannelCreateInput = {
    channelName: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userToChannels?: UserToChannelCreateNestedManyWithoutChannelInput
    videos?: YTVideoCreateNestedManyWithoutChannelInput
    subscribes?: YTSubscribeCreateNestedManyWithoutChannelInput
  }

  export type YTChannelUncheckedCreateInput = {
    id?: number
    channelName: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userToChannels?: UserToChannelUncheckedCreateNestedManyWithoutChannelInput
    videos?: YTVideoUncheckedCreateNestedManyWithoutChannelInput
    subscribes?: YTSubscribeUncheckedCreateNestedManyWithoutChannelInput
  }

  export type YTChannelUpdateInput = {
    channelName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userToChannels?: UserToChannelUpdateManyWithoutChannelNestedInput
    videos?: YTVideoUpdateManyWithoutChannelNestedInput
    subscribes?: YTSubscribeUpdateManyWithoutChannelNestedInput
  }

  export type YTChannelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    channelName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userToChannels?: UserToChannelUncheckedUpdateManyWithoutChannelNestedInput
    videos?: YTVideoUncheckedUpdateManyWithoutChannelNestedInput
    subscribes?: YTSubscribeUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type YTChannelCreateManyInput = {
    id?: number
    channelName: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YTChannelUpdateManyMutationInput = {
    channelName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YTChannelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    channelName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToChannelCreateInput = {
    user: YTUserCreateNestedOneWithoutUserToChannelsInput
    channel: YTChannelCreateNestedOneWithoutUserToChannelsInput
    role: YTRoleEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToChannelUncheckedCreateInput = {
    id?: number
    userId: number
    channelId: number
    role: YTRoleEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToChannelUpdateInput = {
    user?: YTUserUpdateOneRequiredWithoutUserToChannelsNestedInput
    channel?: YTChannelUpdateOneRequiredWithoutUserToChannelsNestedInput
    role?: EnumYTRoleEnumFieldUpdateOperationsInput | YTRoleEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToChannelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    channelId?: IntFieldUpdateOperationsInput | number
    role?: EnumYTRoleEnumFieldUpdateOperationsInput | YTRoleEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToChannelCreateManyInput = {
    id?: number
    userId: number
    channelId: number
    role: YTRoleEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToChannelUpdateManyMutationInput = {
    role?: EnumYTRoleEnumFieldUpdateOperationsInput | YTRoleEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToChannelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    channelId?: IntFieldUpdateOperationsInput | number
    role?: EnumYTRoleEnumFieldUpdateOperationsInput | YTRoleEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YTVideoCreateInput = {
    name: string
    file: string
    logo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    channel: YTChannelCreateNestedOneWithoutVideosInput
    likes?: YTLikeCreateNestedManyWithoutVideoInput
    comments?: YTCommentCreateNestedManyWithoutVideoInput
    shares?: YTShareCreateNestedManyWithoutVideoInput
  }

  export type YTVideoUncheckedCreateInput = {
    id?: number
    name: string
    file: string
    logo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    channelId: number
    likes?: YTLikeUncheckedCreateNestedManyWithoutVideoInput
    comments?: YTCommentUncheckedCreateNestedManyWithoutVideoInput
    shares?: YTShareUncheckedCreateNestedManyWithoutVideoInput
  }

  export type YTVideoUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    file?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: YTChannelUpdateOneRequiredWithoutVideosNestedInput
    likes?: YTLikeUpdateManyWithoutVideoNestedInput
    comments?: YTCommentUpdateManyWithoutVideoNestedInput
    shares?: YTShareUpdateManyWithoutVideoNestedInput
  }

  export type YTVideoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    file?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channelId?: IntFieldUpdateOperationsInput | number
    likes?: YTLikeUncheckedUpdateManyWithoutVideoNestedInput
    comments?: YTCommentUncheckedUpdateManyWithoutVideoNestedInput
    shares?: YTShareUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type YTVideoCreateManyInput = {
    id?: number
    name: string
    file: string
    logo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    channelId: number
  }

  export type YTVideoUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    file?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YTVideoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    file?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channelId?: IntFieldUpdateOperationsInput | number
  }

  export type YTLikeCreateInput = {
    type: string
    video: YTVideoCreateNestedOneWithoutLikesInput
    comment: YTCommentCreateNestedOneWithoutLikesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YTLikeUncheckedCreateInput = {
    id?: number
    type: string
    videoId: number
    commentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YTLikeUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    video?: YTVideoUpdateOneRequiredWithoutLikesNestedInput
    comment?: YTCommentUpdateOneRequiredWithoutLikesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YTLikeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    videoId?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YTLikeCreateManyInput = {
    id?: number
    type: string
    videoId: number
    commentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YTLikeUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YTLikeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    videoId?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YTCommentCreateInput = {
    text: string
    user: YTUserCreateNestedOneWithoutCommentsInput
    commentTo?: number | null
    video: YTVideoCreateNestedOneWithoutCommentsInput
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: YTLikeCreateNestedManyWithoutCommentInput
  }

  export type YTCommentUncheckedCreateInput = {
    id?: number
    text: string
    userId: number
    commentTo?: number | null
    videoId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: YTLikeUncheckedCreateNestedManyWithoutCommentInput
  }

  export type YTCommentUpdateInput = {
    text?: StringFieldUpdateOperationsInput | string
    user?: YTUserUpdateOneRequiredWithoutCommentsNestedInput
    commentTo?: NullableIntFieldUpdateOperationsInput | number | null
    video?: YTVideoUpdateOneRequiredWithoutCommentsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: YTLikeUpdateManyWithoutCommentNestedInput
  }

  export type YTCommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    commentTo?: NullableIntFieldUpdateOperationsInput | number | null
    videoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: YTLikeUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type YTCommentCreateManyInput = {
    id?: number
    text: string
    userId: number
    commentTo?: number | null
    videoId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YTCommentUpdateManyMutationInput = {
    text?: StringFieldUpdateOperationsInput | string
    commentTo?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YTCommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    commentTo?: NullableIntFieldUpdateOperationsInput | number | null
    videoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YTSubscribeCreateInput = {
    user: YTUserCreateNestedOneWithoutSubscribesInput
    channel: YTChannelCreateNestedOneWithoutSubscribesInput
    member: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YTSubscribeUncheckedCreateInput = {
    id?: number
    userId: number
    channelId: number
    member: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YTSubscribeUpdateInput = {
    user?: YTUserUpdateOneRequiredWithoutSubscribesNestedInput
    channel?: YTChannelUpdateOneRequiredWithoutSubscribesNestedInput
    member?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YTSubscribeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    channelId?: IntFieldUpdateOperationsInput | number
    member?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YTSubscribeCreateManyInput = {
    id?: number
    userId: number
    channelId: number
    member: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YTSubscribeUpdateManyMutationInput = {
    member?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YTSubscribeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    channelId?: IntFieldUpdateOperationsInput | number
    member?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YTShareCreateInput = {
    user: YTUserCreateNestedOneWithoutSharesInput
    video: YTVideoCreateNestedOneWithoutSharesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YTShareUncheckedCreateInput = {
    id?: number
    userId: number
    videoId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YTShareUpdateInput = {
    user?: YTUserUpdateOneRequiredWithoutSharesNestedInput
    video?: YTVideoUpdateOneRequiredWithoutSharesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YTShareUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    videoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YTShareCreateManyInput = {
    id?: number
    userId: number
    videoId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YTShareUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YTShareUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    videoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type BKUniversityRelationFilter = {
    is?: BKUniversityWhereInput
    isNot?: BKUniversityWhereInput
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type BKRequestListRelationFilter = {
    every?: BKRequestWhereInput
    some?: BKRequestWhereInput
    none?: BKRequestWhereInput
  }

  export type BKBorrowingHistoryListRelationFilter = {
    every?: BKBorrowingHistoryWhereInput
    some?: BKBorrowingHistoryWhereInput
    none?: BKBorrowingHistoryWhereInput
  }

  export type BKCopyListRelationFilter = {
    every?: BKCopyWhereInput
    some?: BKCopyWhereInput
    none?: BKCopyWhereInput
  }

  export type BKRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BKBorrowingHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BKCopyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BKReserveUserCountOrderByAggregateInput = {
    id?: SortOrder
    universityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BKReserveUserAvgOrderByAggregateInput = {
    id?: SortOrder
    universityId?: SortOrder
  }

  export type BKReserveUserMaxOrderByAggregateInput = {
    id?: SortOrder
    universityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BKReserveUserMinOrderByAggregateInput = {
    id?: SortOrder
    universityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BKReserveUserSumOrderByAggregateInput = {
    id?: SortOrder
    universityId?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type BKReserveUserRelationFilter = {
    is?: BKReserveUserWhereInput | null
    isNot?: BKReserveUserWhereInput | null
  }

  export type BKCopyRelationFilter = {
    is?: BKCopyWhereInput
    isNot?: BKCopyWhereInput
  }

  export type EnumRequestStatusEnumFilter = {
    equals?: RequestStatusEnum
    in?: Enumerable<RequestStatusEnum>
    notIn?: Enumerable<RequestStatusEnum>
    not?: NestedEnumRequestStatusEnumFilter | RequestStatusEnum
  }

  export type BKRequestCountOrderByAggregateInput = {
    id?: SortOrder
    reserveUserId?: SortOrder
    copyId?: SortOrder
    fromUniversityId?: SortOrder
    toUniversityId?: SortOrder
    requestDate?: SortOrder
    status?: SortOrder
    planRecievedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BKRequestAvgOrderByAggregateInput = {
    id?: SortOrder
    reserveUserId?: SortOrder
    copyId?: SortOrder
    fromUniversityId?: SortOrder
    toUniversityId?: SortOrder
  }

  export type BKRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    reserveUserId?: SortOrder
    copyId?: SortOrder
    fromUniversityId?: SortOrder
    toUniversityId?: SortOrder
    requestDate?: SortOrder
    status?: SortOrder
    planRecievedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BKRequestMinOrderByAggregateInput = {
    id?: SortOrder
    reserveUserId?: SortOrder
    copyId?: SortOrder
    fromUniversityId?: SortOrder
    toUniversityId?: SortOrder
    requestDate?: SortOrder
    status?: SortOrder
    planRecievedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BKRequestSumOrderByAggregateInput = {
    id?: SortOrder
    reserveUserId?: SortOrder
    copyId?: SortOrder
    fromUniversityId?: SortOrder
    toUniversityId?: SortOrder
  }

  export type EnumRequestStatusEnumWithAggregatesFilter = {
    equals?: RequestStatusEnum
    in?: Enumerable<RequestStatusEnum>
    notIn?: Enumerable<RequestStatusEnum>
    not?: NestedEnumRequestStatusEnumWithAggregatesFilter | RequestStatusEnum
    _count?: NestedIntFilter
    _min?: NestedEnumRequestStatusEnumFilter
    _max?: NestedEnumRequestStatusEnumFilter
  }

  export type BKBorrowingHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    reserveUserId?: SortOrder
    copyId?: SortOrder
    fromUniversityId?: SortOrder
    borrowDate?: SortOrder
    returnDate?: SortOrder
    actualReturnDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BKBorrowingHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    reserveUserId?: SortOrder
    copyId?: SortOrder
    fromUniversityId?: SortOrder
  }

  export type BKBorrowingHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    reserveUserId?: SortOrder
    copyId?: SortOrder
    fromUniversityId?: SortOrder
    borrowDate?: SortOrder
    returnDate?: SortOrder
    actualReturnDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BKBorrowingHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    reserveUserId?: SortOrder
    copyId?: SortOrder
    fromUniversityId?: SortOrder
    borrowDate?: SortOrder
    returnDate?: SortOrder
    actualReturnDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BKBorrowingHistorySumOrderByAggregateInput = {
    id?: SortOrder
    reserveUserId?: SortOrder
    copyId?: SortOrder
    fromUniversityId?: SortOrder
  }

  export type EnumCopyStatusEnumFilter = {
    equals?: CopyStatusEnum
    in?: Enumerable<CopyStatusEnum>
    notIn?: Enumerable<CopyStatusEnum>
    not?: NestedEnumCopyStatusEnumFilter | CopyStatusEnum
  }

  export type BKTitleRelationFilter = {
    is?: BKTitleWhereInput
    isNot?: BKTitleWhereInput
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type BKCopyCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    titleId?: SortOrder
    reserveUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BKCopyAvgOrderByAggregateInput = {
    id?: SortOrder
    titleId?: SortOrder
    reserveUserId?: SortOrder
  }

  export type BKCopyMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    titleId?: SortOrder
    reserveUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BKCopyMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    titleId?: SortOrder
    reserveUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BKCopySumOrderByAggregateInput = {
    id?: SortOrder
    titleId?: SortOrder
    reserveUserId?: SortOrder
  }

  export type EnumCopyStatusEnumWithAggregatesFilter = {
    equals?: CopyStatusEnum
    in?: Enumerable<CopyStatusEnum>
    notIn?: Enumerable<CopyStatusEnum>
    not?: NestedEnumCopyStatusEnumWithAggregatesFilter | CopyStatusEnum
    _count?: NestedIntFilter
    _min?: NestedEnumCopyStatusEnumFilter
    _max?: NestedEnumCopyStatusEnumFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type UniversityToTitleListRelationFilter = {
    every?: UniversityToTitleWhereInput
    some?: UniversityToTitleWhereInput
    none?: UniversityToTitleWhereInput
  }

  export type BKReserveUserListRelationFilter = {
    every?: BKReserveUserWhereInput
    some?: BKReserveUserWhereInput
    none?: BKReserveUserWhereInput
  }

  export type UniversityToTitleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BKReserveUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BKUniversityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BKUniversityAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BKUniversityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BKUniversityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BKUniversitySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type TitleToCategoryListRelationFilter = {
    every?: TitleToCategoryWhereInput
    some?: TitleToCategoryWhereInput
    none?: TitleToCategoryWhereInput
  }

  export type TitleToAuthorListRelationFilter = {
    every?: TitleToAuthorWhereInput
    some?: TitleToAuthorWhereInput
    none?: TitleToAuthorWhereInput
  }

  export type TitleToCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TitleToAuthorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BKTitleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ISBN?: SortOrder
    copyQty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BKTitleAvgOrderByAggregateInput = {
    id?: SortOrder
    ISBN?: SortOrder
    copyQty?: SortOrder
  }

  export type BKTitleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ISBN?: SortOrder
    copyQty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BKTitleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ISBN?: SortOrder
    copyQty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BKTitleSumOrderByAggregateInput = {
    id?: SortOrder
    ISBN?: SortOrder
    copyQty?: SortOrder
  }

  export type UniversityToTitleCountOrderByAggregateInput = {
    id?: SortOrder
    universityId?: SortOrder
    titleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UniversityToTitleAvgOrderByAggregateInput = {
    id?: SortOrder
    universityId?: SortOrder
    titleId?: SortOrder
  }

  export type UniversityToTitleMaxOrderByAggregateInput = {
    id?: SortOrder
    universityId?: SortOrder
    titleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UniversityToTitleMinOrderByAggregateInput = {
    id?: SortOrder
    universityId?: SortOrder
    titleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UniversityToTitleSumOrderByAggregateInput = {
    id?: SortOrder
    universityId?: SortOrder
    titleId?: SortOrder
  }

  export type BKCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BKCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BKCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BKCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BKCategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BKCategoryRelationFilter = {
    is?: BKCategoryWhereInput
    isNot?: BKCategoryWhereInput
  }

  export type TitleToCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    titleId?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TitleToCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
    titleId?: SortOrder
    categoryId?: SortOrder
  }

  export type TitleToCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    titleId?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TitleToCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    titleId?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TitleToCategorySumOrderByAggregateInput = {
    id?: SortOrder
    titleId?: SortOrder
    categoryId?: SortOrder
  }

  export type BKAuthorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BKAuthorAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BKAuthorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BKAuthorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BKAuthorSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BKAuthorRelationFilter = {
    is?: BKAuthorWhereInput
    isNot?: BKAuthorWhereInput
  }

  export type TitleToAuthorCountOrderByAggregateInput = {
    id?: SortOrder
    titleId?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TitleToAuthorAvgOrderByAggregateInput = {
    id?: SortOrder
    titleId?: SortOrder
    authorId?: SortOrder
  }

  export type TitleToAuthorMaxOrderByAggregateInput = {
    id?: SortOrder
    titleId?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TitleToAuthorMinOrderByAggregateInput = {
    id?: SortOrder
    titleId?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TitleToAuthorSumOrderByAggregateInput = {
    id?: SortOrder
    titleId?: SortOrder
    authorId?: SortOrder
  }

  export type FbPostListRelationFilter = {
    every?: FbPostWhereInput
    some?: FbPostWhereInput
    none?: FbPostWhereInput
  }

  export type FbfriendListRelationFilter = {
    every?: FbfriendWhereInput
    some?: FbfriendWhereInput
    none?: FbfriendWhereInput
  }

  export type FbLikeListRelationFilter = {
    every?: FbLikeWhereInput
    some?: FbLikeWhereInput
    none?: FbLikeWhereInput
  }

  export type FbMessengerListRelationFilter = {
    every?: FbMessengerWhereInput
    some?: FbMessengerWhereInput
    none?: FbMessengerWhereInput
  }

  export type FbShareListRelationFilter = {
    every?: FbShareWhereInput
    some?: FbShareWhereInput
    none?: FbShareWhereInput
  }

  export type FbCommentListRelationFilter = {
    every?: FbCommentWhereInput
    some?: FbCommentWhereInput
    none?: FbCommentWhereInput
  }

  export type GroupToUserListRelationFilter = {
    every?: GroupToUserWhereInput
    some?: GroupToUserWhereInput
    none?: GroupToUserWhereInput
  }

  export type FbPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FbfriendOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FbLikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FbMessengerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FbShareOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FbCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupToUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FbUserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FbUserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FbUserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FbUserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FbUserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FbUserRelationFilter = {
    is?: FbUserWhereInput
    isNot?: FbUserWhereInput
  }

  export type FbPostImageListRelationFilter = {
    every?: FbPostImageWhereInput
    some?: FbPostImageWhereInput
    none?: FbPostImageWhereInput
  }

  export type FbPostVideoListRelationFilter = {
    every?: FbPostVideoWhereInput
    some?: FbPostVideoWhereInput
    none?: FbPostVideoWhereInput
  }

  export type FbPostOnHashtagListRelationFilter = {
    every?: FbPostOnHashtagWhereInput
    some?: FbPostOnHashtagWhereInput
    none?: FbPostOnHashtagWhereInput
  }

  export type FbWallRelationFilter = {
    is?: FbWallWhereInput
    isNot?: FbWallWhereInput
  }

  export type FbPostImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FbPostVideoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FbPostOnHashtagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FbPostCountOrderByAggregateInput = {
    id?: SortOrder
    caption?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    wallId?: SortOrder
  }

  export type FbPostAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    wallId?: SortOrder
  }

  export type FbPostMaxOrderByAggregateInput = {
    id?: SortOrder
    caption?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    wallId?: SortOrder
  }

  export type FbPostMinOrderByAggregateInput = {
    id?: SortOrder
    caption?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    wallId?: SortOrder
  }

  export type FbPostSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    wallId?: SortOrder
  }

  export type FbPostRelationFilter = {
    is?: FbPostWhereInput
    isNot?: FbPostWhereInput
  }

  export type FbPostImageCountOrderByAggregateInput = {
    id?: SortOrder
    image?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FbPostImageAvgOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
  }

  export type FbPostImageMaxOrderByAggregateInput = {
    id?: SortOrder
    image?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FbPostImageMinOrderByAggregateInput = {
    id?: SortOrder
    image?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FbPostImageSumOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
  }

  export type FbPostVideoCountOrderByAggregateInput = {
    id?: SortOrder
    video?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FbPostVideoAvgOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
  }

  export type FbPostVideoMaxOrderByAggregateInput = {
    id?: SortOrder
    video?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FbPostVideoMinOrderByAggregateInput = {
    id?: SortOrder
    video?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FbPostVideoSumOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
  }

  export type FbHashtagCountOrderByAggregateInput = {
    id?: SortOrder
    hashtag?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FbHashtagAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FbHashtagMaxOrderByAggregateInput = {
    id?: SortOrder
    hashtag?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FbHashtagMinOrderByAggregateInput = {
    id?: SortOrder
    hashtag?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FbHashtagSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FbHashtagRelationFilter = {
    is?: FbHashtagWhereInput
    isNot?: FbHashtagWhereInput
  }

  export type FbPostOnHashtagCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    hashtagId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FbPostOnHashtagAvgOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    hashtagId?: SortOrder
  }

  export type FbPostOnHashtagMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    hashtagId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FbPostOnHashtagMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    hashtagId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FbPostOnHashtagSumOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    hashtagId?: SortOrder
  }

  export type FbCommentRelationFilter = {
    is?: FbCommentWhereInput
    isNot?: FbCommentWhereInput
  }

  export type FbShareRelationFilter = {
    is?: FbShareWhereInput
    isNot?: FbShareWhereInput
  }

  export type FbLikeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    commentId?: SortOrder
    shareId?: SortOrder
    likeType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FbLikeAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    commentId?: SortOrder
    shareId?: SortOrder
  }

  export type FbLikeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    commentId?: SortOrder
    shareId?: SortOrder
    likeType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FbLikeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    commentId?: SortOrder
    shareId?: SortOrder
    likeType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FbLikeSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    commentId?: SortOrder
    shareId?: SortOrder
  }

  export type FbDestinationUserListRelationFilter = {
    every?: FbDestinationUserWhereInput
    some?: FbDestinationUserWhereInput
    none?: FbDestinationUserWhereInput
  }

  export type FbDestinationUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FbShareCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FbShareAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
  }

  export type FbShareMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FbShareMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FbShareSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
  }

  export type FbfriendCountOrderByAggregateInput = {
    id?: SortOrder
    acceptId?: SortOrder
    requestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FbfriendAvgOrderByAggregateInput = {
    id?: SortOrder
    acceptId?: SortOrder
    requestId?: SortOrder
  }

  export type FbfriendMaxOrderByAggregateInput = {
    id?: SortOrder
    acceptId?: SortOrder
    requestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FbfriendMinOrderByAggregateInput = {
    id?: SortOrder
    acceptId?: SortOrder
    requestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FbfriendSumOrderByAggregateInput = {
    id?: SortOrder
    acceptId?: SortOrder
    requestId?: SortOrder
  }

  export type FbMessengerCountOrderByAggregateInput = {
    id?: SortOrder
    fromuserId?: SortOrder
    toUserId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FbMessengerAvgOrderByAggregateInput = {
    id?: SortOrder
    fromuserId?: SortOrder
    toUserId?: SortOrder
  }

  export type FbMessengerMaxOrderByAggregateInput = {
    id?: SortOrder
    fromuserId?: SortOrder
    toUserId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FbMessengerMinOrderByAggregateInput = {
    id?: SortOrder
    fromuserId?: SortOrder
    toUserId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FbMessengerSumOrderByAggregateInput = {
    id?: SortOrder
    fromuserId?: SortOrder
    toUserId?: SortOrder
  }

  export type FbCommentCountOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FbCommentAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type FbCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FbCommentMinOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FbCommentSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type FbGroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FbGroupAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FbGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FbGroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FbGroupSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FbGroupRelationFilter = {
    is?: FbGroupWhereInput
    isNot?: FbGroupWhereInput
  }

  export type GroupToUserCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupToUserAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
  }

  export type GroupToUserMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupToUserMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupToUserSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
  }

  export type FbWallCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FbWallAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FbWallMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FbWallMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FbWallSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FbDestinationUserCountOrderByAggregateInput = {
    id?: SortOrder
    fbWallId?: SortOrder
    shareId?: SortOrder
    groupId?: SortOrder
  }

  export type FbDestinationUserAvgOrderByAggregateInput = {
    id?: SortOrder
    fbWallId?: SortOrder
    shareId?: SortOrder
    groupId?: SortOrder
  }

  export type FbDestinationUserMaxOrderByAggregateInput = {
    id?: SortOrder
    fbWallId?: SortOrder
    shareId?: SortOrder
    groupId?: SortOrder
  }

  export type FbDestinationUserMinOrderByAggregateInput = {
    id?: SortOrder
    fbWallId?: SortOrder
    shareId?: SortOrder
    groupId?: SortOrder
  }

  export type FbDestinationUserSumOrderByAggregateInput = {
    id?: SortOrder
    fbWallId?: SortOrder
    shareId?: SortOrder
    groupId?: SortOrder
  }

  export type KorKitchenMenuListRelationFilter = {
    every?: KorKitchenMenuWhereInput
    some?: KorKitchenMenuWhereInput
    none?: KorKitchenMenuWhereInput
  }

  export type KorKitchenMenuOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KorKitchenCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type KorKitchenCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type KorKitchenCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type KorKitchenCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type KorKitchenCategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type KorKitchenCategoryRelationFilter = {
    is?: KorKitchenCategoryWhereInput | null
    isNot?: KorKitchenCategoryWhereInput | null
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type KorKitchenOrderItemListRelationFilter = {
    every?: KorKitchenOrderItemWhereInput
    some?: KorKitchenOrderItemWhereInput
    none?: KorKitchenOrderItemWhereInput
  }

  export type KorKitchenOrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KorKitchenMenuCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    price?: SortOrder
    categoryName?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type KorKitchenMenuAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type KorKitchenMenuMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    price?: SortOrder
    categoryName?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type KorKitchenMenuMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    price?: SortOrder
    categoryName?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type KorKitchenMenuSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type KorKitchenOrderCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    tableId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type KorKitchenOrderAvgOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
  }

  export type KorKitchenOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    tableId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type KorKitchenOrderMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    tableId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type KorKitchenOrderSumOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
  }

  export type KorKitchenMenuRelationFilter = {
    is?: KorKitchenMenuWhereInput
    isNot?: KorKitchenMenuWhereInput
  }

  export type KorKitchenOrderRelationFilter = {
    is?: KorKitchenOrderWhereInput | null
    isNot?: KorKitchenOrderWhereInput | null
  }

  export type KorKitchenOrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    creatAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KorKitchenOrderItemAvgOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
  }

  export type KorKitchenOrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    creatAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KorKitchenOrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    creatAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KorKitchenOrderItemSumOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
  }

  export type TodoListCountOrderByAggregateInput = {
    id?: SortOrder
    task?: SortOrder
    status?: SortOrder
    note?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type TodoListAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TodoListMaxOrderByAggregateInput = {
    id?: SortOrder
    task?: SortOrder
    status?: SortOrder
    note?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type TodoListMinOrderByAggregateInput = {
    id?: SortOrder
    task?: SortOrder
    status?: SortOrder
    note?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type TodoListSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TestModelCountOrderByAggregateInput = {
    id?: SortOrder
    firstname?: SortOrder
    Surname?: SortOrder
  }

  export type TestModelAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TestModelMaxOrderByAggregateInput = {
    id?: SortOrder
    firstname?: SortOrder
    Surname?: SortOrder
  }

  export type TestModelMinOrderByAggregateInput = {
    id?: SortOrder
    firstname?: SortOrder
    Surname?: SortOrder
  }

  export type TestModelSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TriviaQuestionListRelationFilter = {
    every?: TriviaQuestionWhereInput
    some?: TriviaQuestionWhereInput
    none?: TriviaQuestionWhereInput
  }

  export type TriviaRoundListRelationFilter = {
    every?: TriviaRoundWhereInput
    some?: TriviaRoundWhereInput
    none?: TriviaRoundWhereInput
  }

  export type TriviaQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TriviaRoundOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TriviaCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type TriviaCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TriviaCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type TriviaCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type TriviaCategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TriviaCategoryRelationFilter = {
    is?: TriviaCategoryWhereInput
    isNot?: TriviaCategoryWhereInput
  }

  export type TriviaChoiceListRelationFilter = {
    every?: TriviaChoiceWhereInput
    some?: TriviaChoiceWhereInput
    none?: TriviaChoiceWhereInput
  }

  export type TriviaRoundQuestionListRelationFilter = {
    every?: TriviaRoundQuestionWhereInput
    some?: TriviaRoundQuestionWhereInput
    none?: TriviaRoundQuestionWhereInput
  }

  export type TriviaChoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TriviaRoundQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TriviaQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    answerID?: SortOrder
  }

  export type TriviaQuestionAvgOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    answerID?: SortOrder
  }

  export type TriviaQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    answerID?: SortOrder
  }

  export type TriviaQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    answerID?: SortOrder
  }

  export type TriviaQuestionSumOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    answerID?: SortOrder
  }

  export type TriviaQuestionRelationFilter = {
    is?: TriviaQuestionWhereInput
    isNot?: TriviaQuestionWhereInput
  }

  export type TriviaChoiceCountOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    name?: SortOrder
  }

  export type TriviaChoiceAvgOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
  }

  export type TriviaChoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    name?: SortOrder
  }

  export type TriviaChoiceMinOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    name?: SortOrder
  }

  export type TriviaChoiceSumOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
  }

  export type TriviaChoiceRelationFilter = {
    is?: TriviaChoiceWhereInput
    isNot?: TriviaChoiceWhereInput
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type TriviaRoundRelationFilter = {
    is?: TriviaRoundWhereInput | null
    isNot?: TriviaRoundWhereInput | null
  }

  export type TriviaRoundQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    choiceId?: SortOrder
    quizResult?: SortOrder
    roundId?: SortOrder
  }

  export type TriviaRoundQuestionAvgOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    choiceId?: SortOrder
    roundId?: SortOrder
  }

  export type TriviaRoundQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    choiceId?: SortOrder
    quizResult?: SortOrder
    roundId?: SortOrder
  }

  export type TriviaRoundQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    choiceId?: SortOrder
    quizResult?: SortOrder
    roundId?: SortOrder
  }

  export type TriviaRoundQuestionSumOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    choiceId?: SortOrder
    roundId?: SortOrder
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type TriviaRoundCountOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    categoryId?: SortOrder
    totalResult?: SortOrder
    createAt?: SortOrder
  }

  export type TriviaRoundAvgOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    totalResult?: SortOrder
  }

  export type TriviaRoundMaxOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    categoryId?: SortOrder
    totalResult?: SortOrder
    createAt?: SortOrder
  }

  export type TriviaRoundMinOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    categoryId?: SortOrder
    totalResult?: SortOrder
    createAt?: SortOrder
  }

  export type TriviaRoundSumOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    totalResult?: SortOrder
  }

  export type TwitterFollowListRelationFilter = {
    every?: TwitterFollowWhereInput
    some?: TwitterFollowWhereInput
    none?: TwitterFollowWhereInput
  }

  export type TwitterPostListRelationFilter = {
    every?: TwitterPostWhereInput
    some?: TwitterPostWhereInput
    none?: TwitterPostWhereInput
  }

  export type TwitterDirectMessageListRelationFilter = {
    every?: TwitterDirectMessageWhereInput
    some?: TwitterDirectMessageWhereInput
    none?: TwitterDirectMessageWhereInput
  }

  export type TwitterCommentListRelationFilter = {
    every?: TwitterCommentWhereInput
    some?: TwitterCommentWhereInput
    none?: TwitterCommentWhereInput
  }

  export type TwitterFollowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TwitterPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TwitterDirectMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TwitterCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TwitterUserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    Image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterUserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TwitterUserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    Image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterUserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    Image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterUserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TwitterUserRelationFilter = {
    is?: TwitterUserWhereInput
    isNot?: TwitterUserWhereInput
  }

  export type TwitterFollowCountOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterFollowAvgOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
  }

  export type TwitterFollowMaxOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterFollowMinOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterFollowSumOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
  }

  export type TwitterPostOnHashtagListRelationFilter = {
    every?: TwitterPostOnHashtagWhereInput
    some?: TwitterPostOnHashtagWhereInput
    none?: TwitterPostOnHashtagWhereInput
  }

  export type TwitterPostOnHashtagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TwitterPostCountOrderByAggregateInput = {
    id?: SortOrder
    caption?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterPostAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type TwitterPostMaxOrderByAggregateInput = {
    id?: SortOrder
    caption?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterPostMinOrderByAggregateInput = {
    id?: SortOrder
    caption?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterPostSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type TwitterDirectMessageCountOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterDirectMessageAvgOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
  }

  export type TwitterDirectMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterDirectMessageMinOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterDirectMessageSumOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
  }

  export type TwitterHashtagCountOrderByAggregateInput = {
    id?: SortOrder
    hashtag?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterHashtagAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TwitterHashtagMaxOrderByAggregateInput = {
    id?: SortOrder
    hashtag?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterHashtagMinOrderByAggregateInput = {
    id?: SortOrder
    hashtag?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterHashtagSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TwitterPostRelationFilter = {
    is?: TwitterPostWhereInput
    isNot?: TwitterPostWhereInput
  }

  export type TwitterCommentCountOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterCommentAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
  }

  export type TwitterCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterCommentMinOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterCommentSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
  }

  export type TwitterHashtagRelationFilter = {
    is?: TwitterHashtagWhereInput
    isNot?: TwitterHashtagWhereInput
  }

  export type TwitterPostOnHashtagCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    hashtagId?: SortOrder
  }

  export type TwitterPostOnHashtagAvgOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    hashtagId?: SortOrder
  }

  export type TwitterPostOnHashtagMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    hashtagId?: SortOrder
  }

  export type TwitterPostOnHashtagMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    hashtagId?: SortOrder
  }

  export type TwitterPostOnHashtagSumOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    hashtagId?: SortOrder
  }

  export type WSTopupHistoryListRelationFilter = {
    every?: WSTopupHistoryWhereInput
    some?: WSTopupHistoryWhereInput
    none?: WSTopupHistoryWhereInput
  }

  export type WSUsingHistoryListRelationFilter = {
    every?: WSUsingHistoryWhereInput
    some?: WSUsingHistoryWhereInput
    none?: WSUsingHistoryWhereInput
  }

  export type WSTopupHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WSUsingHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WSUserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tel?: SortOrder
    myWallet?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type WSUserAvgOrderByAggregateInput = {
    id?: SortOrder
    tel?: SortOrder
    myWallet?: SortOrder
  }

  export type WSUserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tel?: SortOrder
    myWallet?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type WSUserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tel?: SortOrder
    myWallet?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type WSUserSumOrderByAggregateInput = {
    id?: SortOrder
    tel?: SortOrder
    myWallet?: SortOrder
  }

  export type WSUserRelationFilter = {
    is?: WSUserWhereInput
    isNot?: WSUserWhereInput
  }

  export type WSTopupHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    topup?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type WSTopupHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    topup?: SortOrder
  }

  export type WSTopupHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    topup?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type WSTopupHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    topup?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type WSTopupHistorySumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    topup?: SortOrder
  }

  export type WSMachineRelationFilter = {
    is?: WSMachineWhereInput
    isNot?: WSMachineWhereInput
  }

  export type WSProgramRelationFilter = {
    is?: WSProgramWhereInput
    isNot?: WSProgramWhereInput
  }

  export type WSUsingHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    usingStartAt?: SortOrder
    finishingAt?: SortOrder
    wSMachineId?: SortOrder
    wSProgramId?: SortOrder
  }

  export type WSUsingHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    price?: SortOrder
    wSMachineId?: SortOrder
    wSProgramId?: SortOrder
  }

  export type WSUsingHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    usingStartAt?: SortOrder
    finishingAt?: SortOrder
    wSMachineId?: SortOrder
    wSProgramId?: SortOrder
  }

  export type WSUsingHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    usingStartAt?: SortOrder
    finishingAt?: SortOrder
    wSMachineId?: SortOrder
    wSProgramId?: SortOrder
  }

  export type WSUsingHistorySumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    price?: SortOrder
    wSMachineId?: SortOrder
    wSProgramId?: SortOrder
  }

  export type WSMachineListRelationFilter = {
    every?: WSMachineWhereInput
    some?: WSMachineWhereInput
    none?: WSMachineWhereInput
  }

  export type WSMachineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WSShopCountOrderByAggregateInput = {
    id?: SortOrder
    branch?: SortOrder
    owner?: SortOrder
    tel?: SortOrder
    location?: SortOrder
    area?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type WSShopAvgOrderByAggregateInput = {
    id?: SortOrder
    tel?: SortOrder
  }

  export type WSShopMaxOrderByAggregateInput = {
    id?: SortOrder
    branch?: SortOrder
    owner?: SortOrder
    tel?: SortOrder
    location?: SortOrder
    area?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type WSShopMinOrderByAggregateInput = {
    id?: SortOrder
    branch?: SortOrder
    owner?: SortOrder
    tel?: SortOrder
    location?: SortOrder
    area?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type WSShopSumOrderByAggregateInput = {
    id?: SortOrder
    tel?: SortOrder
  }

  export type WSShopRelationFilter = {
    is?: WSShopWhereInput
    isNot?: WSShopWhereInput
  }

  export type MachineToProgramListRelationFilter = {
    every?: MachineToProgramWhereInput
    some?: MachineToProgramWhereInput
    none?: MachineToProgramWhereInput
  }

  export type WSMaintainListRelationFilter = {
    every?: WSMaintainWhereInput
    some?: WSMaintainWhereInput
    none?: WSMaintainWhereInput
  }

  export type MachineToProgramOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WSMaintainOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WSMachineCountOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    brandname?: SortOrder
    size?: SortOrder
    type?: SortOrder
    model?: SortOrder
    producedDate?: SortOrder
    insuranceExpiredDate?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type WSMachineAvgOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
  }

  export type WSMachineMaxOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    brandname?: SortOrder
    size?: SortOrder
    type?: SortOrder
    model?: SortOrder
    producedDate?: SortOrder
    insuranceExpiredDate?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type WSMachineMinOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    brandname?: SortOrder
    size?: SortOrder
    type?: SortOrder
    model?: SortOrder
    producedDate?: SortOrder
    insuranceExpiredDate?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type WSMachineSumOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
  }

  export type WSProgramDetailListRelationFilter = {
    every?: WSProgramDetailWhereInput
    some?: WSProgramDetailWhereInput
    none?: WSProgramDetailWhereInput
  }

  export type WSProgramDetailRelationFilter = {
    is?: WSProgramDetailWhereInput
    isNot?: WSProgramDetailWhereInput
  }

  export type WSProgramDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WSProgramCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    activeProgramId?: SortOrder
  }

  export type WSProgramAvgOrderByAggregateInput = {
    id?: SortOrder
    activeProgramId?: SortOrder
  }

  export type WSProgramMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    activeProgramId?: SortOrder
  }

  export type WSProgramMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    activeProgramId?: SortOrder
  }

  export type WSProgramSumOrderByAggregateInput = {
    id?: SortOrder
    activeProgramId?: SortOrder
  }

  export type MachineToProgramCountOrderByAggregateInput = {
    id?: SortOrder
    machineId?: SortOrder
    programId?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type MachineToProgramAvgOrderByAggregateInput = {
    id?: SortOrder
    machineId?: SortOrder
    programId?: SortOrder
  }

  export type MachineToProgramMaxOrderByAggregateInput = {
    id?: SortOrder
    machineId?: SortOrder
    programId?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type MachineToProgramMinOrderByAggregateInput = {
    id?: SortOrder
    machineId?: SortOrder
    programId?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type MachineToProgramSumOrderByAggregateInput = {
    id?: SortOrder
    machineId?: SortOrder
    programId?: SortOrder
  }

  export type WSProgramListRelationFilter = {
    every?: WSProgramWhereInput
    some?: WSProgramWhereInput
    none?: WSProgramWhereInput
  }

  export type WSProgramOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WSProgramDetailCountOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    weight?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type WSProgramDetailAvgOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    weight?: SortOrder
  }

  export type WSProgramDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    weight?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type WSProgramDetailMinOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    weight?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type WSProgramDetailSumOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    weight?: SortOrder
  }

  export type WSMaintainCountOrderByAggregateInput = {
    id?: SortOrder
    checker?: SortOrder
    item?: SortOrder
    status?: SortOrder
    machineId?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type WSMaintainAvgOrderByAggregateInput = {
    id?: SortOrder
    machineId?: SortOrder
  }

  export type WSMaintainMaxOrderByAggregateInput = {
    id?: SortOrder
    checker?: SortOrder
    item?: SortOrder
    status?: SortOrder
    machineId?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type WSMaintainMinOrderByAggregateInput = {
    id?: SortOrder
    checker?: SortOrder
    item?: SortOrder
    status?: SortOrder
    machineId?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type WSMaintainSumOrderByAggregateInput = {
    id?: SortOrder
    machineId?: SortOrder
  }

  export type UserToChannelListRelationFilter = {
    every?: UserToChannelWhereInput
    some?: UserToChannelWhereInput
    none?: UserToChannelWhereInput
  }

  export type YTCommentListRelationFilter = {
    every?: YTCommentWhereInput
    some?: YTCommentWhereInput
    none?: YTCommentWhereInput
  }

  export type YTSubscribeListRelationFilter = {
    every?: YTSubscribeWhereInput
    some?: YTSubscribeWhereInput
    none?: YTSubscribeWhereInput
  }

  export type YTShareListRelationFilter = {
    every?: YTShareWhereInput
    some?: YTShareWhereInput
    none?: YTShareWhereInput
  }

  export type UserToChannelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type YTCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type YTSubscribeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type YTShareOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type YTUserCountOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    email?: SortOrder
    avatar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YTUserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type YTUserMaxOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    email?: SortOrder
    avatar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YTUserMinOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    email?: SortOrder
    avatar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YTUserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type YTVideoListRelationFilter = {
    every?: YTVideoWhereInput
    some?: YTVideoWhereInput
    none?: YTVideoWhereInput
  }

  export type YTVideoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type YTChannelCountOrderByAggregateInput = {
    id?: SortOrder
    channelName?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YTChannelAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type YTChannelMaxOrderByAggregateInput = {
    id?: SortOrder
    channelName?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YTChannelMinOrderByAggregateInput = {
    id?: SortOrder
    channelName?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YTChannelSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type YTUserRelationFilter = {
    is?: YTUserWhereInput
    isNot?: YTUserWhereInput
  }

  export type YTChannelRelationFilter = {
    is?: YTChannelWhereInput
    isNot?: YTChannelWhereInput
  }

  export type EnumYTRoleEnumFilter = {
    equals?: YTRoleEnum
    in?: Enumerable<YTRoleEnum>
    notIn?: Enumerable<YTRoleEnum>
    not?: NestedEnumYTRoleEnumFilter | YTRoleEnum
  }

  export type UserToChannelCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    channelId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserToChannelAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    channelId?: SortOrder
  }

  export type UserToChannelMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    channelId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserToChannelMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    channelId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserToChannelSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    channelId?: SortOrder
  }

  export type EnumYTRoleEnumWithAggregatesFilter = {
    equals?: YTRoleEnum
    in?: Enumerable<YTRoleEnum>
    notIn?: Enumerable<YTRoleEnum>
    not?: NestedEnumYTRoleEnumWithAggregatesFilter | YTRoleEnum
    _count?: NestedIntFilter
    _min?: NestedEnumYTRoleEnumFilter
    _max?: NestedEnumYTRoleEnumFilter
  }

  export type YTLikeListRelationFilter = {
    every?: YTLikeWhereInput
    some?: YTLikeWhereInput
    none?: YTLikeWhereInput
  }

  export type YTLikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type YTVideoCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    file?: SortOrder
    logo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    channelId?: SortOrder
  }

  export type YTVideoAvgOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
  }

  export type YTVideoMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    file?: SortOrder
    logo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    channelId?: SortOrder
  }

  export type YTVideoMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    file?: SortOrder
    logo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    channelId?: SortOrder
  }

  export type YTVideoSumOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
  }

  export type YTVideoRelationFilter = {
    is?: YTVideoWhereInput
    isNot?: YTVideoWhereInput
  }

  export type YTCommentRelationFilter = {
    is?: YTCommentWhereInput
    isNot?: YTCommentWhereInput
  }

  export type YTLikeCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    videoId?: SortOrder
    commentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YTLikeAvgOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    commentId?: SortOrder
  }

  export type YTLikeMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    videoId?: SortOrder
    commentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YTLikeMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    videoId?: SortOrder
    commentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YTLikeSumOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    commentId?: SortOrder
  }

  export type YTCommentCountOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    userId?: SortOrder
    commentTo?: SortOrder
    videoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YTCommentAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    commentTo?: SortOrder
    videoId?: SortOrder
  }

  export type YTCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    userId?: SortOrder
    commentTo?: SortOrder
    videoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YTCommentMinOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    userId?: SortOrder
    commentTo?: SortOrder
    videoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YTCommentSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    commentTo?: SortOrder
    videoId?: SortOrder
  }

  export type YTSubscribeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    channelId?: SortOrder
    member?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YTSubscribeAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    channelId?: SortOrder
  }

  export type YTSubscribeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    channelId?: SortOrder
    member?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YTSubscribeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    channelId?: SortOrder
    member?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YTSubscribeSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    channelId?: SortOrder
  }

  export type YTShareCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    videoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YTShareAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    videoId?: SortOrder
  }

  export type YTShareMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    videoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YTShareMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    videoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YTShareSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    videoId?: SortOrder
  }

  export type BKUniversityCreateNestedOneWithoutReserveUsersInput = {
    create?: XOR<BKUniversityCreateWithoutReserveUsersInput, BKUniversityUncheckedCreateWithoutReserveUsersInput>
    connectOrCreate?: BKUniversityCreateOrConnectWithoutReserveUsersInput
    connect?: BKUniversityWhereUniqueInput
  }

  export type BKRequestCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<BKRequestCreateWithoutUserInput>, Enumerable<BKRequestUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BKRequestCreateOrConnectWithoutUserInput>
    createMany?: BKRequestCreateManyUserInputEnvelope
    connect?: Enumerable<BKRequestWhereUniqueInput>
  }

  export type BKBorrowingHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<BKBorrowingHistoryCreateWithoutUserInput>, Enumerable<BKBorrowingHistoryUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BKBorrowingHistoryCreateOrConnectWithoutUserInput>
    createMany?: BKBorrowingHistoryCreateManyUserInputEnvelope
    connect?: Enumerable<BKBorrowingHistoryWhereUniqueInput>
  }

  export type BKCopyCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<BKCopyCreateWithoutUserInput>, Enumerable<BKCopyUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BKCopyCreateOrConnectWithoutUserInput>
    createMany?: BKCopyCreateManyUserInputEnvelope
    connect?: Enumerable<BKCopyWhereUniqueInput>
  }

  export type BKRequestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<BKRequestCreateWithoutUserInput>, Enumerable<BKRequestUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BKRequestCreateOrConnectWithoutUserInput>
    createMany?: BKRequestCreateManyUserInputEnvelope
    connect?: Enumerable<BKRequestWhereUniqueInput>
  }

  export type BKBorrowingHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<BKBorrowingHistoryCreateWithoutUserInput>, Enumerable<BKBorrowingHistoryUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BKBorrowingHistoryCreateOrConnectWithoutUserInput>
    createMany?: BKBorrowingHistoryCreateManyUserInputEnvelope
    connect?: Enumerable<BKBorrowingHistoryWhereUniqueInput>
  }

  export type BKCopyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<BKCopyCreateWithoutUserInput>, Enumerable<BKCopyUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BKCopyCreateOrConnectWithoutUserInput>
    createMany?: BKCopyCreateManyUserInputEnvelope
    connect?: Enumerable<BKCopyWhereUniqueInput>
  }

  export type BKUniversityUpdateOneRequiredWithoutReserveUsersNestedInput = {
    create?: XOR<BKUniversityCreateWithoutReserveUsersInput, BKUniversityUncheckedCreateWithoutReserveUsersInput>
    connectOrCreate?: BKUniversityCreateOrConnectWithoutReserveUsersInput
    upsert?: BKUniversityUpsertWithoutReserveUsersInput
    connect?: BKUniversityWhereUniqueInput
    update?: XOR<BKUniversityUpdateWithoutReserveUsersInput, BKUniversityUncheckedUpdateWithoutReserveUsersInput>
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BKRequestUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<BKRequestCreateWithoutUserInput>, Enumerable<BKRequestUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BKRequestCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<BKRequestUpsertWithWhereUniqueWithoutUserInput>
    createMany?: BKRequestCreateManyUserInputEnvelope
    set?: Enumerable<BKRequestWhereUniqueInput>
    disconnect?: Enumerable<BKRequestWhereUniqueInput>
    delete?: Enumerable<BKRequestWhereUniqueInput>
    connect?: Enumerable<BKRequestWhereUniqueInput>
    update?: Enumerable<BKRequestUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<BKRequestUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<BKRequestScalarWhereInput>
  }

  export type BKBorrowingHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<BKBorrowingHistoryCreateWithoutUserInput>, Enumerable<BKBorrowingHistoryUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BKBorrowingHistoryCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<BKBorrowingHistoryUpsertWithWhereUniqueWithoutUserInput>
    createMany?: BKBorrowingHistoryCreateManyUserInputEnvelope
    set?: Enumerable<BKBorrowingHistoryWhereUniqueInput>
    disconnect?: Enumerable<BKBorrowingHistoryWhereUniqueInput>
    delete?: Enumerable<BKBorrowingHistoryWhereUniqueInput>
    connect?: Enumerable<BKBorrowingHistoryWhereUniqueInput>
    update?: Enumerable<BKBorrowingHistoryUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<BKBorrowingHistoryUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<BKBorrowingHistoryScalarWhereInput>
  }

  export type BKCopyUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<BKCopyCreateWithoutUserInput>, Enumerable<BKCopyUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BKCopyCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<BKCopyUpsertWithWhereUniqueWithoutUserInput>
    createMany?: BKCopyCreateManyUserInputEnvelope
    set?: Enumerable<BKCopyWhereUniqueInput>
    disconnect?: Enumerable<BKCopyWhereUniqueInput>
    delete?: Enumerable<BKCopyWhereUniqueInput>
    connect?: Enumerable<BKCopyWhereUniqueInput>
    update?: Enumerable<BKCopyUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<BKCopyUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<BKCopyScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BKRequestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<BKRequestCreateWithoutUserInput>, Enumerable<BKRequestUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BKRequestCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<BKRequestUpsertWithWhereUniqueWithoutUserInput>
    createMany?: BKRequestCreateManyUserInputEnvelope
    set?: Enumerable<BKRequestWhereUniqueInput>
    disconnect?: Enumerable<BKRequestWhereUniqueInput>
    delete?: Enumerable<BKRequestWhereUniqueInput>
    connect?: Enumerable<BKRequestWhereUniqueInput>
    update?: Enumerable<BKRequestUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<BKRequestUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<BKRequestScalarWhereInput>
  }

  export type BKBorrowingHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<BKBorrowingHistoryCreateWithoutUserInput>, Enumerable<BKBorrowingHistoryUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BKBorrowingHistoryCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<BKBorrowingHistoryUpsertWithWhereUniqueWithoutUserInput>
    createMany?: BKBorrowingHistoryCreateManyUserInputEnvelope
    set?: Enumerable<BKBorrowingHistoryWhereUniqueInput>
    disconnect?: Enumerable<BKBorrowingHistoryWhereUniqueInput>
    delete?: Enumerable<BKBorrowingHistoryWhereUniqueInput>
    connect?: Enumerable<BKBorrowingHistoryWhereUniqueInput>
    update?: Enumerable<BKBorrowingHistoryUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<BKBorrowingHistoryUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<BKBorrowingHistoryScalarWhereInput>
  }

  export type BKCopyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<BKCopyCreateWithoutUserInput>, Enumerable<BKCopyUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BKCopyCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<BKCopyUpsertWithWhereUniqueWithoutUserInput>
    createMany?: BKCopyCreateManyUserInputEnvelope
    set?: Enumerable<BKCopyWhereUniqueInput>
    disconnect?: Enumerable<BKCopyWhereUniqueInput>
    delete?: Enumerable<BKCopyWhereUniqueInput>
    connect?: Enumerable<BKCopyWhereUniqueInput>
    update?: Enumerable<BKCopyUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<BKCopyUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<BKCopyScalarWhereInput>
  }

  export type BKReserveUserCreateNestedOneWithoutRequestsInput = {
    create?: XOR<BKReserveUserCreateWithoutRequestsInput, BKReserveUserUncheckedCreateWithoutRequestsInput>
    connectOrCreate?: BKReserveUserCreateOrConnectWithoutRequestsInput
    connect?: BKReserveUserWhereUniqueInput
  }

  export type BKCopyCreateNestedOneWithoutRequestsInput = {
    create?: XOR<BKCopyCreateWithoutRequestsInput, BKCopyUncheckedCreateWithoutRequestsInput>
    connectOrCreate?: BKCopyCreateOrConnectWithoutRequestsInput
    connect?: BKCopyWhereUniqueInput
  }

  export type BKUniversityCreateNestedOneWithoutFromRequestInput = {
    create?: XOR<BKUniversityCreateWithoutFromRequestInput, BKUniversityUncheckedCreateWithoutFromRequestInput>
    connectOrCreate?: BKUniversityCreateOrConnectWithoutFromRequestInput
    connect?: BKUniversityWhereUniqueInput
  }

  export type BKUniversityCreateNestedOneWithoutToRequestInput = {
    create?: XOR<BKUniversityCreateWithoutToRequestInput, BKUniversityUncheckedCreateWithoutToRequestInput>
    connectOrCreate?: BKUniversityCreateOrConnectWithoutToRequestInput
    connect?: BKUniversityWhereUniqueInput
  }

  export type BKReserveUserUpdateOneRequiredWithoutRequestsNestedInput = {
    create?: XOR<BKReserveUserCreateWithoutRequestsInput, BKReserveUserUncheckedCreateWithoutRequestsInput>
    connectOrCreate?: BKReserveUserCreateOrConnectWithoutRequestsInput
    upsert?: BKReserveUserUpsertWithoutRequestsInput
    connect?: BKReserveUserWhereUniqueInput
    update?: XOR<BKReserveUserUpdateWithoutRequestsInput, BKReserveUserUncheckedUpdateWithoutRequestsInput>
  }

  export type BKCopyUpdateOneRequiredWithoutRequestsNestedInput = {
    create?: XOR<BKCopyCreateWithoutRequestsInput, BKCopyUncheckedCreateWithoutRequestsInput>
    connectOrCreate?: BKCopyCreateOrConnectWithoutRequestsInput
    upsert?: BKCopyUpsertWithoutRequestsInput
    connect?: BKCopyWhereUniqueInput
    update?: XOR<BKCopyUpdateWithoutRequestsInput, BKCopyUncheckedUpdateWithoutRequestsInput>
  }

  export type BKUniversityUpdateOneRequiredWithoutFromRequestNestedInput = {
    create?: XOR<BKUniversityCreateWithoutFromRequestInput, BKUniversityUncheckedCreateWithoutFromRequestInput>
    connectOrCreate?: BKUniversityCreateOrConnectWithoutFromRequestInput
    upsert?: BKUniversityUpsertWithoutFromRequestInput
    connect?: BKUniversityWhereUniqueInput
    update?: XOR<BKUniversityUpdateWithoutFromRequestInput, BKUniversityUncheckedUpdateWithoutFromRequestInput>
  }

  export type BKUniversityUpdateOneRequiredWithoutToRequestNestedInput = {
    create?: XOR<BKUniversityCreateWithoutToRequestInput, BKUniversityUncheckedCreateWithoutToRequestInput>
    connectOrCreate?: BKUniversityCreateOrConnectWithoutToRequestInput
    upsert?: BKUniversityUpsertWithoutToRequestInput
    connect?: BKUniversityWhereUniqueInput
    update?: XOR<BKUniversityUpdateWithoutToRequestInput, BKUniversityUncheckedUpdateWithoutToRequestInput>
  }

  export type EnumRequestStatusEnumFieldUpdateOperationsInput = {
    set?: RequestStatusEnum
  }

  export type BKReserveUserCreateNestedOneWithoutBKBorrowingHistoryInput = {
    create?: XOR<BKReserveUserCreateWithoutBKBorrowingHistoryInput, BKReserveUserUncheckedCreateWithoutBKBorrowingHistoryInput>
    connectOrCreate?: BKReserveUserCreateOrConnectWithoutBKBorrowingHistoryInput
    connect?: BKReserveUserWhereUniqueInput
  }

  export type BKCopyCreateNestedOneWithoutBKBorrowingHistoryInput = {
    create?: XOR<BKCopyCreateWithoutBKBorrowingHistoryInput, BKCopyUncheckedCreateWithoutBKBorrowingHistoryInput>
    connectOrCreate?: BKCopyCreateOrConnectWithoutBKBorrowingHistoryInput
    connect?: BKCopyWhereUniqueInput
  }

  export type BKUniversityCreateNestedOneWithoutBKBorrowingHistoryInput = {
    create?: XOR<BKUniversityCreateWithoutBKBorrowingHistoryInput, BKUniversityUncheckedCreateWithoutBKBorrowingHistoryInput>
    connectOrCreate?: BKUniversityCreateOrConnectWithoutBKBorrowingHistoryInput
    connect?: BKUniversityWhereUniqueInput
  }

  export type BKReserveUserUpdateOneRequiredWithoutBKBorrowingHistoryNestedInput = {
    create?: XOR<BKReserveUserCreateWithoutBKBorrowingHistoryInput, BKReserveUserUncheckedCreateWithoutBKBorrowingHistoryInput>
    connectOrCreate?: BKReserveUserCreateOrConnectWithoutBKBorrowingHistoryInput
    upsert?: BKReserveUserUpsertWithoutBKBorrowingHistoryInput
    connect?: BKReserveUserWhereUniqueInput
    update?: XOR<BKReserveUserUpdateWithoutBKBorrowingHistoryInput, BKReserveUserUncheckedUpdateWithoutBKBorrowingHistoryInput>
  }

  export type BKCopyUpdateOneRequiredWithoutBKBorrowingHistoryNestedInput = {
    create?: XOR<BKCopyCreateWithoutBKBorrowingHistoryInput, BKCopyUncheckedCreateWithoutBKBorrowingHistoryInput>
    connectOrCreate?: BKCopyCreateOrConnectWithoutBKBorrowingHistoryInput
    upsert?: BKCopyUpsertWithoutBKBorrowingHistoryInput
    connect?: BKCopyWhereUniqueInput
    update?: XOR<BKCopyUpdateWithoutBKBorrowingHistoryInput, BKCopyUncheckedUpdateWithoutBKBorrowingHistoryInput>
  }

  export type BKUniversityUpdateOneRequiredWithoutBKBorrowingHistoryNestedInput = {
    create?: XOR<BKUniversityCreateWithoutBKBorrowingHistoryInput, BKUniversityUncheckedCreateWithoutBKBorrowingHistoryInput>
    connectOrCreate?: BKUniversityCreateOrConnectWithoutBKBorrowingHistoryInput
    upsert?: BKUniversityUpsertWithoutBKBorrowingHistoryInput
    connect?: BKUniversityWhereUniqueInput
    update?: XOR<BKUniversityUpdateWithoutBKBorrowingHistoryInput, BKUniversityUncheckedUpdateWithoutBKBorrowingHistoryInput>
  }

  export type BKTitleCreateNestedOneWithoutCopiesInput = {
    create?: XOR<BKTitleCreateWithoutCopiesInput, BKTitleUncheckedCreateWithoutCopiesInput>
    connectOrCreate?: BKTitleCreateOrConnectWithoutCopiesInput
    connect?: BKTitleWhereUniqueInput
  }

  export type BKReserveUserCreateNestedOneWithoutBKCopyInput = {
    create?: XOR<BKReserveUserCreateWithoutBKCopyInput, BKReserveUserUncheckedCreateWithoutBKCopyInput>
    connectOrCreate?: BKReserveUserCreateOrConnectWithoutBKCopyInput
    connect?: BKReserveUserWhereUniqueInput
  }

  export type BKRequestCreateNestedManyWithoutCopyInput = {
    create?: XOR<Enumerable<BKRequestCreateWithoutCopyInput>, Enumerable<BKRequestUncheckedCreateWithoutCopyInput>>
    connectOrCreate?: Enumerable<BKRequestCreateOrConnectWithoutCopyInput>
    createMany?: BKRequestCreateManyCopyInputEnvelope
    connect?: Enumerable<BKRequestWhereUniqueInput>
  }

  export type BKBorrowingHistoryCreateNestedManyWithoutCopyInput = {
    create?: XOR<Enumerable<BKBorrowingHistoryCreateWithoutCopyInput>, Enumerable<BKBorrowingHistoryUncheckedCreateWithoutCopyInput>>
    connectOrCreate?: Enumerable<BKBorrowingHistoryCreateOrConnectWithoutCopyInput>
    createMany?: BKBorrowingHistoryCreateManyCopyInputEnvelope
    connect?: Enumerable<BKBorrowingHistoryWhereUniqueInput>
  }

  export type BKRequestUncheckedCreateNestedManyWithoutCopyInput = {
    create?: XOR<Enumerable<BKRequestCreateWithoutCopyInput>, Enumerable<BKRequestUncheckedCreateWithoutCopyInput>>
    connectOrCreate?: Enumerable<BKRequestCreateOrConnectWithoutCopyInput>
    createMany?: BKRequestCreateManyCopyInputEnvelope
    connect?: Enumerable<BKRequestWhereUniqueInput>
  }

  export type BKBorrowingHistoryUncheckedCreateNestedManyWithoutCopyInput = {
    create?: XOR<Enumerable<BKBorrowingHistoryCreateWithoutCopyInput>, Enumerable<BKBorrowingHistoryUncheckedCreateWithoutCopyInput>>
    connectOrCreate?: Enumerable<BKBorrowingHistoryCreateOrConnectWithoutCopyInput>
    createMany?: BKBorrowingHistoryCreateManyCopyInputEnvelope
    connect?: Enumerable<BKBorrowingHistoryWhereUniqueInput>
  }

  export type EnumCopyStatusEnumFieldUpdateOperationsInput = {
    set?: CopyStatusEnum
  }

  export type BKTitleUpdateOneRequiredWithoutCopiesNestedInput = {
    create?: XOR<BKTitleCreateWithoutCopiesInput, BKTitleUncheckedCreateWithoutCopiesInput>
    connectOrCreate?: BKTitleCreateOrConnectWithoutCopiesInput
    upsert?: BKTitleUpsertWithoutCopiesInput
    connect?: BKTitleWhereUniqueInput
    update?: XOR<BKTitleUpdateWithoutCopiesInput, BKTitleUncheckedUpdateWithoutCopiesInput>
  }

  export type BKReserveUserUpdateOneWithoutBKCopyNestedInput = {
    create?: XOR<BKReserveUserCreateWithoutBKCopyInput, BKReserveUserUncheckedCreateWithoutBKCopyInput>
    connectOrCreate?: BKReserveUserCreateOrConnectWithoutBKCopyInput
    upsert?: BKReserveUserUpsertWithoutBKCopyInput
    disconnect?: boolean
    delete?: boolean
    connect?: BKReserveUserWhereUniqueInput
    update?: XOR<BKReserveUserUpdateWithoutBKCopyInput, BKReserveUserUncheckedUpdateWithoutBKCopyInput>
  }

  export type BKRequestUpdateManyWithoutCopyNestedInput = {
    create?: XOR<Enumerable<BKRequestCreateWithoutCopyInput>, Enumerable<BKRequestUncheckedCreateWithoutCopyInput>>
    connectOrCreate?: Enumerable<BKRequestCreateOrConnectWithoutCopyInput>
    upsert?: Enumerable<BKRequestUpsertWithWhereUniqueWithoutCopyInput>
    createMany?: BKRequestCreateManyCopyInputEnvelope
    set?: Enumerable<BKRequestWhereUniqueInput>
    disconnect?: Enumerable<BKRequestWhereUniqueInput>
    delete?: Enumerable<BKRequestWhereUniqueInput>
    connect?: Enumerable<BKRequestWhereUniqueInput>
    update?: Enumerable<BKRequestUpdateWithWhereUniqueWithoutCopyInput>
    updateMany?: Enumerable<BKRequestUpdateManyWithWhereWithoutCopyInput>
    deleteMany?: Enumerable<BKRequestScalarWhereInput>
  }

  export type BKBorrowingHistoryUpdateManyWithoutCopyNestedInput = {
    create?: XOR<Enumerable<BKBorrowingHistoryCreateWithoutCopyInput>, Enumerable<BKBorrowingHistoryUncheckedCreateWithoutCopyInput>>
    connectOrCreate?: Enumerable<BKBorrowingHistoryCreateOrConnectWithoutCopyInput>
    upsert?: Enumerable<BKBorrowingHistoryUpsertWithWhereUniqueWithoutCopyInput>
    createMany?: BKBorrowingHistoryCreateManyCopyInputEnvelope
    set?: Enumerable<BKBorrowingHistoryWhereUniqueInput>
    disconnect?: Enumerable<BKBorrowingHistoryWhereUniqueInput>
    delete?: Enumerable<BKBorrowingHistoryWhereUniqueInput>
    connect?: Enumerable<BKBorrowingHistoryWhereUniqueInput>
    update?: Enumerable<BKBorrowingHistoryUpdateWithWhereUniqueWithoutCopyInput>
    updateMany?: Enumerable<BKBorrowingHistoryUpdateManyWithWhereWithoutCopyInput>
    deleteMany?: Enumerable<BKBorrowingHistoryScalarWhereInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BKRequestUncheckedUpdateManyWithoutCopyNestedInput = {
    create?: XOR<Enumerable<BKRequestCreateWithoutCopyInput>, Enumerable<BKRequestUncheckedCreateWithoutCopyInput>>
    connectOrCreate?: Enumerable<BKRequestCreateOrConnectWithoutCopyInput>
    upsert?: Enumerable<BKRequestUpsertWithWhereUniqueWithoutCopyInput>
    createMany?: BKRequestCreateManyCopyInputEnvelope
    set?: Enumerable<BKRequestWhereUniqueInput>
    disconnect?: Enumerable<BKRequestWhereUniqueInput>
    delete?: Enumerable<BKRequestWhereUniqueInput>
    connect?: Enumerable<BKRequestWhereUniqueInput>
    update?: Enumerable<BKRequestUpdateWithWhereUniqueWithoutCopyInput>
    updateMany?: Enumerable<BKRequestUpdateManyWithWhereWithoutCopyInput>
    deleteMany?: Enumerable<BKRequestScalarWhereInput>
  }

  export type BKBorrowingHistoryUncheckedUpdateManyWithoutCopyNestedInput = {
    create?: XOR<Enumerable<BKBorrowingHistoryCreateWithoutCopyInput>, Enumerable<BKBorrowingHistoryUncheckedCreateWithoutCopyInput>>
    connectOrCreate?: Enumerable<BKBorrowingHistoryCreateOrConnectWithoutCopyInput>
    upsert?: Enumerable<BKBorrowingHistoryUpsertWithWhereUniqueWithoutCopyInput>
    createMany?: BKBorrowingHistoryCreateManyCopyInputEnvelope
    set?: Enumerable<BKBorrowingHistoryWhereUniqueInput>
    disconnect?: Enumerable<BKBorrowingHistoryWhereUniqueInput>
    delete?: Enumerable<BKBorrowingHistoryWhereUniqueInput>
    connect?: Enumerable<BKBorrowingHistoryWhereUniqueInput>
    update?: Enumerable<BKBorrowingHistoryUpdateWithWhereUniqueWithoutCopyInput>
    updateMany?: Enumerable<BKBorrowingHistoryUpdateManyWithWhereWithoutCopyInput>
    deleteMany?: Enumerable<BKBorrowingHistoryScalarWhereInput>
  }

  export type UniversityToTitleCreateNestedManyWithoutUniversityInput = {
    create?: XOR<Enumerable<UniversityToTitleCreateWithoutUniversityInput>, Enumerable<UniversityToTitleUncheckedCreateWithoutUniversityInput>>
    connectOrCreate?: Enumerable<UniversityToTitleCreateOrConnectWithoutUniversityInput>
    createMany?: UniversityToTitleCreateManyUniversityInputEnvelope
    connect?: Enumerable<UniversityToTitleWhereUniqueInput>
  }

  export type BKReserveUserCreateNestedManyWithoutUniversityInput = {
    create?: XOR<Enumerable<BKReserveUserCreateWithoutUniversityInput>, Enumerable<BKReserveUserUncheckedCreateWithoutUniversityInput>>
    connectOrCreate?: Enumerable<BKReserveUserCreateOrConnectWithoutUniversityInput>
    createMany?: BKReserveUserCreateManyUniversityInputEnvelope
    connect?: Enumerable<BKReserveUserWhereUniqueInput>
  }

  export type BKRequestCreateNestedManyWithoutFromInput = {
    create?: XOR<Enumerable<BKRequestCreateWithoutFromInput>, Enumerable<BKRequestUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<BKRequestCreateOrConnectWithoutFromInput>
    createMany?: BKRequestCreateManyFromInputEnvelope
    connect?: Enumerable<BKRequestWhereUniqueInput>
  }

  export type BKRequestCreateNestedManyWithoutToInput = {
    create?: XOR<Enumerable<BKRequestCreateWithoutToInput>, Enumerable<BKRequestUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<BKRequestCreateOrConnectWithoutToInput>
    createMany?: BKRequestCreateManyToInputEnvelope
    connect?: Enumerable<BKRequestWhereUniqueInput>
  }

  export type BKBorrowingHistoryCreateNestedManyWithoutFromInput = {
    create?: XOR<Enumerable<BKBorrowingHistoryCreateWithoutFromInput>, Enumerable<BKBorrowingHistoryUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<BKBorrowingHistoryCreateOrConnectWithoutFromInput>
    createMany?: BKBorrowingHistoryCreateManyFromInputEnvelope
    connect?: Enumerable<BKBorrowingHistoryWhereUniqueInput>
  }

  export type UniversityToTitleUncheckedCreateNestedManyWithoutUniversityInput = {
    create?: XOR<Enumerable<UniversityToTitleCreateWithoutUniversityInput>, Enumerable<UniversityToTitleUncheckedCreateWithoutUniversityInput>>
    connectOrCreate?: Enumerable<UniversityToTitleCreateOrConnectWithoutUniversityInput>
    createMany?: UniversityToTitleCreateManyUniversityInputEnvelope
    connect?: Enumerable<UniversityToTitleWhereUniqueInput>
  }

  export type BKReserveUserUncheckedCreateNestedManyWithoutUniversityInput = {
    create?: XOR<Enumerable<BKReserveUserCreateWithoutUniversityInput>, Enumerable<BKReserveUserUncheckedCreateWithoutUniversityInput>>
    connectOrCreate?: Enumerable<BKReserveUserCreateOrConnectWithoutUniversityInput>
    createMany?: BKReserveUserCreateManyUniversityInputEnvelope
    connect?: Enumerable<BKReserveUserWhereUniqueInput>
  }

  export type BKRequestUncheckedCreateNestedManyWithoutFromInput = {
    create?: XOR<Enumerable<BKRequestCreateWithoutFromInput>, Enumerable<BKRequestUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<BKRequestCreateOrConnectWithoutFromInput>
    createMany?: BKRequestCreateManyFromInputEnvelope
    connect?: Enumerable<BKRequestWhereUniqueInput>
  }

  export type BKRequestUncheckedCreateNestedManyWithoutToInput = {
    create?: XOR<Enumerable<BKRequestCreateWithoutToInput>, Enumerable<BKRequestUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<BKRequestCreateOrConnectWithoutToInput>
    createMany?: BKRequestCreateManyToInputEnvelope
    connect?: Enumerable<BKRequestWhereUniqueInput>
  }

  export type BKBorrowingHistoryUncheckedCreateNestedManyWithoutFromInput = {
    create?: XOR<Enumerable<BKBorrowingHistoryCreateWithoutFromInput>, Enumerable<BKBorrowingHistoryUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<BKBorrowingHistoryCreateOrConnectWithoutFromInput>
    createMany?: BKBorrowingHistoryCreateManyFromInputEnvelope
    connect?: Enumerable<BKBorrowingHistoryWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type UniversityToTitleUpdateManyWithoutUniversityNestedInput = {
    create?: XOR<Enumerable<UniversityToTitleCreateWithoutUniversityInput>, Enumerable<UniversityToTitleUncheckedCreateWithoutUniversityInput>>
    connectOrCreate?: Enumerable<UniversityToTitleCreateOrConnectWithoutUniversityInput>
    upsert?: Enumerable<UniversityToTitleUpsertWithWhereUniqueWithoutUniversityInput>
    createMany?: UniversityToTitleCreateManyUniversityInputEnvelope
    set?: Enumerable<UniversityToTitleWhereUniqueInput>
    disconnect?: Enumerable<UniversityToTitleWhereUniqueInput>
    delete?: Enumerable<UniversityToTitleWhereUniqueInput>
    connect?: Enumerable<UniversityToTitleWhereUniqueInput>
    update?: Enumerable<UniversityToTitleUpdateWithWhereUniqueWithoutUniversityInput>
    updateMany?: Enumerable<UniversityToTitleUpdateManyWithWhereWithoutUniversityInput>
    deleteMany?: Enumerable<UniversityToTitleScalarWhereInput>
  }

  export type BKReserveUserUpdateManyWithoutUniversityNestedInput = {
    create?: XOR<Enumerable<BKReserveUserCreateWithoutUniversityInput>, Enumerable<BKReserveUserUncheckedCreateWithoutUniversityInput>>
    connectOrCreate?: Enumerable<BKReserveUserCreateOrConnectWithoutUniversityInput>
    upsert?: Enumerable<BKReserveUserUpsertWithWhereUniqueWithoutUniversityInput>
    createMany?: BKReserveUserCreateManyUniversityInputEnvelope
    set?: Enumerable<BKReserveUserWhereUniqueInput>
    disconnect?: Enumerable<BKReserveUserWhereUniqueInput>
    delete?: Enumerable<BKReserveUserWhereUniqueInput>
    connect?: Enumerable<BKReserveUserWhereUniqueInput>
    update?: Enumerable<BKReserveUserUpdateWithWhereUniqueWithoutUniversityInput>
    updateMany?: Enumerable<BKReserveUserUpdateManyWithWhereWithoutUniversityInput>
    deleteMany?: Enumerable<BKReserveUserScalarWhereInput>
  }

  export type BKRequestUpdateManyWithoutFromNestedInput = {
    create?: XOR<Enumerable<BKRequestCreateWithoutFromInput>, Enumerable<BKRequestUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<BKRequestCreateOrConnectWithoutFromInput>
    upsert?: Enumerable<BKRequestUpsertWithWhereUniqueWithoutFromInput>
    createMany?: BKRequestCreateManyFromInputEnvelope
    set?: Enumerable<BKRequestWhereUniqueInput>
    disconnect?: Enumerable<BKRequestWhereUniqueInput>
    delete?: Enumerable<BKRequestWhereUniqueInput>
    connect?: Enumerable<BKRequestWhereUniqueInput>
    update?: Enumerable<BKRequestUpdateWithWhereUniqueWithoutFromInput>
    updateMany?: Enumerable<BKRequestUpdateManyWithWhereWithoutFromInput>
    deleteMany?: Enumerable<BKRequestScalarWhereInput>
  }

  export type BKRequestUpdateManyWithoutToNestedInput = {
    create?: XOR<Enumerable<BKRequestCreateWithoutToInput>, Enumerable<BKRequestUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<BKRequestCreateOrConnectWithoutToInput>
    upsert?: Enumerable<BKRequestUpsertWithWhereUniqueWithoutToInput>
    createMany?: BKRequestCreateManyToInputEnvelope
    set?: Enumerable<BKRequestWhereUniqueInput>
    disconnect?: Enumerable<BKRequestWhereUniqueInput>
    delete?: Enumerable<BKRequestWhereUniqueInput>
    connect?: Enumerable<BKRequestWhereUniqueInput>
    update?: Enumerable<BKRequestUpdateWithWhereUniqueWithoutToInput>
    updateMany?: Enumerable<BKRequestUpdateManyWithWhereWithoutToInput>
    deleteMany?: Enumerable<BKRequestScalarWhereInput>
  }

  export type BKBorrowingHistoryUpdateManyWithoutFromNestedInput = {
    create?: XOR<Enumerable<BKBorrowingHistoryCreateWithoutFromInput>, Enumerable<BKBorrowingHistoryUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<BKBorrowingHistoryCreateOrConnectWithoutFromInput>
    upsert?: Enumerable<BKBorrowingHistoryUpsertWithWhereUniqueWithoutFromInput>
    createMany?: BKBorrowingHistoryCreateManyFromInputEnvelope
    set?: Enumerable<BKBorrowingHistoryWhereUniqueInput>
    disconnect?: Enumerable<BKBorrowingHistoryWhereUniqueInput>
    delete?: Enumerable<BKBorrowingHistoryWhereUniqueInput>
    connect?: Enumerable<BKBorrowingHistoryWhereUniqueInput>
    update?: Enumerable<BKBorrowingHistoryUpdateWithWhereUniqueWithoutFromInput>
    updateMany?: Enumerable<BKBorrowingHistoryUpdateManyWithWhereWithoutFromInput>
    deleteMany?: Enumerable<BKBorrowingHistoryScalarWhereInput>
  }

  export type UniversityToTitleUncheckedUpdateManyWithoutUniversityNestedInput = {
    create?: XOR<Enumerable<UniversityToTitleCreateWithoutUniversityInput>, Enumerable<UniversityToTitleUncheckedCreateWithoutUniversityInput>>
    connectOrCreate?: Enumerable<UniversityToTitleCreateOrConnectWithoutUniversityInput>
    upsert?: Enumerable<UniversityToTitleUpsertWithWhereUniqueWithoutUniversityInput>
    createMany?: UniversityToTitleCreateManyUniversityInputEnvelope
    set?: Enumerable<UniversityToTitleWhereUniqueInput>
    disconnect?: Enumerable<UniversityToTitleWhereUniqueInput>
    delete?: Enumerable<UniversityToTitleWhereUniqueInput>
    connect?: Enumerable<UniversityToTitleWhereUniqueInput>
    update?: Enumerable<UniversityToTitleUpdateWithWhereUniqueWithoutUniversityInput>
    updateMany?: Enumerable<UniversityToTitleUpdateManyWithWhereWithoutUniversityInput>
    deleteMany?: Enumerable<UniversityToTitleScalarWhereInput>
  }

  export type BKReserveUserUncheckedUpdateManyWithoutUniversityNestedInput = {
    create?: XOR<Enumerable<BKReserveUserCreateWithoutUniversityInput>, Enumerable<BKReserveUserUncheckedCreateWithoutUniversityInput>>
    connectOrCreate?: Enumerable<BKReserveUserCreateOrConnectWithoutUniversityInput>
    upsert?: Enumerable<BKReserveUserUpsertWithWhereUniqueWithoutUniversityInput>
    createMany?: BKReserveUserCreateManyUniversityInputEnvelope
    set?: Enumerable<BKReserveUserWhereUniqueInput>
    disconnect?: Enumerable<BKReserveUserWhereUniqueInput>
    delete?: Enumerable<BKReserveUserWhereUniqueInput>
    connect?: Enumerable<BKReserveUserWhereUniqueInput>
    update?: Enumerable<BKReserveUserUpdateWithWhereUniqueWithoutUniversityInput>
    updateMany?: Enumerable<BKReserveUserUpdateManyWithWhereWithoutUniversityInput>
    deleteMany?: Enumerable<BKReserveUserScalarWhereInput>
  }

  export type BKRequestUncheckedUpdateManyWithoutFromNestedInput = {
    create?: XOR<Enumerable<BKRequestCreateWithoutFromInput>, Enumerable<BKRequestUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<BKRequestCreateOrConnectWithoutFromInput>
    upsert?: Enumerable<BKRequestUpsertWithWhereUniqueWithoutFromInput>
    createMany?: BKRequestCreateManyFromInputEnvelope
    set?: Enumerable<BKRequestWhereUniqueInput>
    disconnect?: Enumerable<BKRequestWhereUniqueInput>
    delete?: Enumerable<BKRequestWhereUniqueInput>
    connect?: Enumerable<BKRequestWhereUniqueInput>
    update?: Enumerable<BKRequestUpdateWithWhereUniqueWithoutFromInput>
    updateMany?: Enumerable<BKRequestUpdateManyWithWhereWithoutFromInput>
    deleteMany?: Enumerable<BKRequestScalarWhereInput>
  }

  export type BKRequestUncheckedUpdateManyWithoutToNestedInput = {
    create?: XOR<Enumerable<BKRequestCreateWithoutToInput>, Enumerable<BKRequestUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<BKRequestCreateOrConnectWithoutToInput>
    upsert?: Enumerable<BKRequestUpsertWithWhereUniqueWithoutToInput>
    createMany?: BKRequestCreateManyToInputEnvelope
    set?: Enumerable<BKRequestWhereUniqueInput>
    disconnect?: Enumerable<BKRequestWhereUniqueInput>
    delete?: Enumerable<BKRequestWhereUniqueInput>
    connect?: Enumerable<BKRequestWhereUniqueInput>
    update?: Enumerable<BKRequestUpdateWithWhereUniqueWithoutToInput>
    updateMany?: Enumerable<BKRequestUpdateManyWithWhereWithoutToInput>
    deleteMany?: Enumerable<BKRequestScalarWhereInput>
  }

  export type BKBorrowingHistoryUncheckedUpdateManyWithoutFromNestedInput = {
    create?: XOR<Enumerable<BKBorrowingHistoryCreateWithoutFromInput>, Enumerable<BKBorrowingHistoryUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<BKBorrowingHistoryCreateOrConnectWithoutFromInput>
    upsert?: Enumerable<BKBorrowingHistoryUpsertWithWhereUniqueWithoutFromInput>
    createMany?: BKBorrowingHistoryCreateManyFromInputEnvelope
    set?: Enumerable<BKBorrowingHistoryWhereUniqueInput>
    disconnect?: Enumerable<BKBorrowingHistoryWhereUniqueInput>
    delete?: Enumerable<BKBorrowingHistoryWhereUniqueInput>
    connect?: Enumerable<BKBorrowingHistoryWhereUniqueInput>
    update?: Enumerable<BKBorrowingHistoryUpdateWithWhereUniqueWithoutFromInput>
    updateMany?: Enumerable<BKBorrowingHistoryUpdateManyWithWhereWithoutFromInput>
    deleteMany?: Enumerable<BKBorrowingHistoryScalarWhereInput>
  }

  export type TitleToCategoryCreateNestedManyWithoutTitleInput = {
    create?: XOR<Enumerable<TitleToCategoryCreateWithoutTitleInput>, Enumerable<TitleToCategoryUncheckedCreateWithoutTitleInput>>
    connectOrCreate?: Enumerable<TitleToCategoryCreateOrConnectWithoutTitleInput>
    createMany?: TitleToCategoryCreateManyTitleInputEnvelope
    connect?: Enumerable<TitleToCategoryWhereUniqueInput>
  }

  export type TitleToAuthorCreateNestedManyWithoutTitleInput = {
    create?: XOR<Enumerable<TitleToAuthorCreateWithoutTitleInput>, Enumerable<TitleToAuthorUncheckedCreateWithoutTitleInput>>
    connectOrCreate?: Enumerable<TitleToAuthorCreateOrConnectWithoutTitleInput>
    createMany?: TitleToAuthorCreateManyTitleInputEnvelope
    connect?: Enumerable<TitleToAuthorWhereUniqueInput>
  }

  export type UniversityToTitleCreateNestedManyWithoutTitleInput = {
    create?: XOR<Enumerable<UniversityToTitleCreateWithoutTitleInput>, Enumerable<UniversityToTitleUncheckedCreateWithoutTitleInput>>
    connectOrCreate?: Enumerable<UniversityToTitleCreateOrConnectWithoutTitleInput>
    createMany?: UniversityToTitleCreateManyTitleInputEnvelope
    connect?: Enumerable<UniversityToTitleWhereUniqueInput>
  }

  export type BKCopyCreateNestedManyWithoutTitleInput = {
    create?: XOR<Enumerable<BKCopyCreateWithoutTitleInput>, Enumerable<BKCopyUncheckedCreateWithoutTitleInput>>
    connectOrCreate?: Enumerable<BKCopyCreateOrConnectWithoutTitleInput>
    createMany?: BKCopyCreateManyTitleInputEnvelope
    connect?: Enumerable<BKCopyWhereUniqueInput>
  }

  export type TitleToCategoryUncheckedCreateNestedManyWithoutTitleInput = {
    create?: XOR<Enumerable<TitleToCategoryCreateWithoutTitleInput>, Enumerable<TitleToCategoryUncheckedCreateWithoutTitleInput>>
    connectOrCreate?: Enumerable<TitleToCategoryCreateOrConnectWithoutTitleInput>
    createMany?: TitleToCategoryCreateManyTitleInputEnvelope
    connect?: Enumerable<TitleToCategoryWhereUniqueInput>
  }

  export type TitleToAuthorUncheckedCreateNestedManyWithoutTitleInput = {
    create?: XOR<Enumerable<TitleToAuthorCreateWithoutTitleInput>, Enumerable<TitleToAuthorUncheckedCreateWithoutTitleInput>>
    connectOrCreate?: Enumerable<TitleToAuthorCreateOrConnectWithoutTitleInput>
    createMany?: TitleToAuthorCreateManyTitleInputEnvelope
    connect?: Enumerable<TitleToAuthorWhereUniqueInput>
  }

  export type UniversityToTitleUncheckedCreateNestedManyWithoutTitleInput = {
    create?: XOR<Enumerable<UniversityToTitleCreateWithoutTitleInput>, Enumerable<UniversityToTitleUncheckedCreateWithoutTitleInput>>
    connectOrCreate?: Enumerable<UniversityToTitleCreateOrConnectWithoutTitleInput>
    createMany?: UniversityToTitleCreateManyTitleInputEnvelope
    connect?: Enumerable<UniversityToTitleWhereUniqueInput>
  }

  export type BKCopyUncheckedCreateNestedManyWithoutTitleInput = {
    create?: XOR<Enumerable<BKCopyCreateWithoutTitleInput>, Enumerable<BKCopyUncheckedCreateWithoutTitleInput>>
    connectOrCreate?: Enumerable<BKCopyCreateOrConnectWithoutTitleInput>
    createMany?: BKCopyCreateManyTitleInputEnvelope
    connect?: Enumerable<BKCopyWhereUniqueInput>
  }

  export type TitleToCategoryUpdateManyWithoutTitleNestedInput = {
    create?: XOR<Enumerable<TitleToCategoryCreateWithoutTitleInput>, Enumerable<TitleToCategoryUncheckedCreateWithoutTitleInput>>
    connectOrCreate?: Enumerable<TitleToCategoryCreateOrConnectWithoutTitleInput>
    upsert?: Enumerable<TitleToCategoryUpsertWithWhereUniqueWithoutTitleInput>
    createMany?: TitleToCategoryCreateManyTitleInputEnvelope
    set?: Enumerable<TitleToCategoryWhereUniqueInput>
    disconnect?: Enumerable<TitleToCategoryWhereUniqueInput>
    delete?: Enumerable<TitleToCategoryWhereUniqueInput>
    connect?: Enumerable<TitleToCategoryWhereUniqueInput>
    update?: Enumerable<TitleToCategoryUpdateWithWhereUniqueWithoutTitleInput>
    updateMany?: Enumerable<TitleToCategoryUpdateManyWithWhereWithoutTitleInput>
    deleteMany?: Enumerable<TitleToCategoryScalarWhereInput>
  }

  export type TitleToAuthorUpdateManyWithoutTitleNestedInput = {
    create?: XOR<Enumerable<TitleToAuthorCreateWithoutTitleInput>, Enumerable<TitleToAuthorUncheckedCreateWithoutTitleInput>>
    connectOrCreate?: Enumerable<TitleToAuthorCreateOrConnectWithoutTitleInput>
    upsert?: Enumerable<TitleToAuthorUpsertWithWhereUniqueWithoutTitleInput>
    createMany?: TitleToAuthorCreateManyTitleInputEnvelope
    set?: Enumerable<TitleToAuthorWhereUniqueInput>
    disconnect?: Enumerable<TitleToAuthorWhereUniqueInput>
    delete?: Enumerable<TitleToAuthorWhereUniqueInput>
    connect?: Enumerable<TitleToAuthorWhereUniqueInput>
    update?: Enumerable<TitleToAuthorUpdateWithWhereUniqueWithoutTitleInput>
    updateMany?: Enumerable<TitleToAuthorUpdateManyWithWhereWithoutTitleInput>
    deleteMany?: Enumerable<TitleToAuthorScalarWhereInput>
  }

  export type UniversityToTitleUpdateManyWithoutTitleNestedInput = {
    create?: XOR<Enumerable<UniversityToTitleCreateWithoutTitleInput>, Enumerable<UniversityToTitleUncheckedCreateWithoutTitleInput>>
    connectOrCreate?: Enumerable<UniversityToTitleCreateOrConnectWithoutTitleInput>
    upsert?: Enumerable<UniversityToTitleUpsertWithWhereUniqueWithoutTitleInput>
    createMany?: UniversityToTitleCreateManyTitleInputEnvelope
    set?: Enumerable<UniversityToTitleWhereUniqueInput>
    disconnect?: Enumerable<UniversityToTitleWhereUniqueInput>
    delete?: Enumerable<UniversityToTitleWhereUniqueInput>
    connect?: Enumerable<UniversityToTitleWhereUniqueInput>
    update?: Enumerable<UniversityToTitleUpdateWithWhereUniqueWithoutTitleInput>
    updateMany?: Enumerable<UniversityToTitleUpdateManyWithWhereWithoutTitleInput>
    deleteMany?: Enumerable<UniversityToTitleScalarWhereInput>
  }

  export type BKCopyUpdateManyWithoutTitleNestedInput = {
    create?: XOR<Enumerable<BKCopyCreateWithoutTitleInput>, Enumerable<BKCopyUncheckedCreateWithoutTitleInput>>
    connectOrCreate?: Enumerable<BKCopyCreateOrConnectWithoutTitleInput>
    upsert?: Enumerable<BKCopyUpsertWithWhereUniqueWithoutTitleInput>
    createMany?: BKCopyCreateManyTitleInputEnvelope
    set?: Enumerable<BKCopyWhereUniqueInput>
    disconnect?: Enumerable<BKCopyWhereUniqueInput>
    delete?: Enumerable<BKCopyWhereUniqueInput>
    connect?: Enumerable<BKCopyWhereUniqueInput>
    update?: Enumerable<BKCopyUpdateWithWhereUniqueWithoutTitleInput>
    updateMany?: Enumerable<BKCopyUpdateManyWithWhereWithoutTitleInput>
    deleteMany?: Enumerable<BKCopyScalarWhereInput>
  }

  export type TitleToCategoryUncheckedUpdateManyWithoutTitleNestedInput = {
    create?: XOR<Enumerable<TitleToCategoryCreateWithoutTitleInput>, Enumerable<TitleToCategoryUncheckedCreateWithoutTitleInput>>
    connectOrCreate?: Enumerable<TitleToCategoryCreateOrConnectWithoutTitleInput>
    upsert?: Enumerable<TitleToCategoryUpsertWithWhereUniqueWithoutTitleInput>
    createMany?: TitleToCategoryCreateManyTitleInputEnvelope
    set?: Enumerable<TitleToCategoryWhereUniqueInput>
    disconnect?: Enumerable<TitleToCategoryWhereUniqueInput>
    delete?: Enumerable<TitleToCategoryWhereUniqueInput>
    connect?: Enumerable<TitleToCategoryWhereUniqueInput>
    update?: Enumerable<TitleToCategoryUpdateWithWhereUniqueWithoutTitleInput>
    updateMany?: Enumerable<TitleToCategoryUpdateManyWithWhereWithoutTitleInput>
    deleteMany?: Enumerable<TitleToCategoryScalarWhereInput>
  }

  export type TitleToAuthorUncheckedUpdateManyWithoutTitleNestedInput = {
    create?: XOR<Enumerable<TitleToAuthorCreateWithoutTitleInput>, Enumerable<TitleToAuthorUncheckedCreateWithoutTitleInput>>
    connectOrCreate?: Enumerable<TitleToAuthorCreateOrConnectWithoutTitleInput>
    upsert?: Enumerable<TitleToAuthorUpsertWithWhereUniqueWithoutTitleInput>
    createMany?: TitleToAuthorCreateManyTitleInputEnvelope
    set?: Enumerable<TitleToAuthorWhereUniqueInput>
    disconnect?: Enumerable<TitleToAuthorWhereUniqueInput>
    delete?: Enumerable<TitleToAuthorWhereUniqueInput>
    connect?: Enumerable<TitleToAuthorWhereUniqueInput>
    update?: Enumerable<TitleToAuthorUpdateWithWhereUniqueWithoutTitleInput>
    updateMany?: Enumerable<TitleToAuthorUpdateManyWithWhereWithoutTitleInput>
    deleteMany?: Enumerable<TitleToAuthorScalarWhereInput>
  }

  export type UniversityToTitleUncheckedUpdateManyWithoutTitleNestedInput = {
    create?: XOR<Enumerable<UniversityToTitleCreateWithoutTitleInput>, Enumerable<UniversityToTitleUncheckedCreateWithoutTitleInput>>
    connectOrCreate?: Enumerable<UniversityToTitleCreateOrConnectWithoutTitleInput>
    upsert?: Enumerable<UniversityToTitleUpsertWithWhereUniqueWithoutTitleInput>
    createMany?: UniversityToTitleCreateManyTitleInputEnvelope
    set?: Enumerable<UniversityToTitleWhereUniqueInput>
    disconnect?: Enumerable<UniversityToTitleWhereUniqueInput>
    delete?: Enumerable<UniversityToTitleWhereUniqueInput>
    connect?: Enumerable<UniversityToTitleWhereUniqueInput>
    update?: Enumerable<UniversityToTitleUpdateWithWhereUniqueWithoutTitleInput>
    updateMany?: Enumerable<UniversityToTitleUpdateManyWithWhereWithoutTitleInput>
    deleteMany?: Enumerable<UniversityToTitleScalarWhereInput>
  }

  export type BKCopyUncheckedUpdateManyWithoutTitleNestedInput = {
    create?: XOR<Enumerable<BKCopyCreateWithoutTitleInput>, Enumerable<BKCopyUncheckedCreateWithoutTitleInput>>
    connectOrCreate?: Enumerable<BKCopyCreateOrConnectWithoutTitleInput>
    upsert?: Enumerable<BKCopyUpsertWithWhereUniqueWithoutTitleInput>
    createMany?: BKCopyCreateManyTitleInputEnvelope
    set?: Enumerable<BKCopyWhereUniqueInput>
    disconnect?: Enumerable<BKCopyWhereUniqueInput>
    delete?: Enumerable<BKCopyWhereUniqueInput>
    connect?: Enumerable<BKCopyWhereUniqueInput>
    update?: Enumerable<BKCopyUpdateWithWhereUniqueWithoutTitleInput>
    updateMany?: Enumerable<BKCopyUpdateManyWithWhereWithoutTitleInput>
    deleteMany?: Enumerable<BKCopyScalarWhereInput>
  }

  export type BKUniversityCreateNestedOneWithoutUniversityToTitlesInput = {
    create?: XOR<BKUniversityCreateWithoutUniversityToTitlesInput, BKUniversityUncheckedCreateWithoutUniversityToTitlesInput>
    connectOrCreate?: BKUniversityCreateOrConnectWithoutUniversityToTitlesInput
    connect?: BKUniversityWhereUniqueInput
  }

  export type BKTitleCreateNestedOneWithoutUniversityToTitlesInput = {
    create?: XOR<BKTitleCreateWithoutUniversityToTitlesInput, BKTitleUncheckedCreateWithoutUniversityToTitlesInput>
    connectOrCreate?: BKTitleCreateOrConnectWithoutUniversityToTitlesInput
    connect?: BKTitleWhereUniqueInput
  }

  export type BKUniversityUpdateOneRequiredWithoutUniversityToTitlesNestedInput = {
    create?: XOR<BKUniversityCreateWithoutUniversityToTitlesInput, BKUniversityUncheckedCreateWithoutUniversityToTitlesInput>
    connectOrCreate?: BKUniversityCreateOrConnectWithoutUniversityToTitlesInput
    upsert?: BKUniversityUpsertWithoutUniversityToTitlesInput
    connect?: BKUniversityWhereUniqueInput
    update?: XOR<BKUniversityUpdateWithoutUniversityToTitlesInput, BKUniversityUncheckedUpdateWithoutUniversityToTitlesInput>
  }

  export type BKTitleUpdateOneRequiredWithoutUniversityToTitlesNestedInput = {
    create?: XOR<BKTitleCreateWithoutUniversityToTitlesInput, BKTitleUncheckedCreateWithoutUniversityToTitlesInput>
    connectOrCreate?: BKTitleCreateOrConnectWithoutUniversityToTitlesInput
    upsert?: BKTitleUpsertWithoutUniversityToTitlesInput
    connect?: BKTitleWhereUniqueInput
    update?: XOR<BKTitleUpdateWithoutUniversityToTitlesInput, BKTitleUncheckedUpdateWithoutUniversityToTitlesInput>
  }

  export type TitleToCategoryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<TitleToCategoryCreateWithoutCategoryInput>, Enumerable<TitleToCategoryUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<TitleToCategoryCreateOrConnectWithoutCategoryInput>
    createMany?: TitleToCategoryCreateManyCategoryInputEnvelope
    connect?: Enumerable<TitleToCategoryWhereUniqueInput>
  }

  export type TitleToCategoryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<TitleToCategoryCreateWithoutCategoryInput>, Enumerable<TitleToCategoryUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<TitleToCategoryCreateOrConnectWithoutCategoryInput>
    createMany?: TitleToCategoryCreateManyCategoryInputEnvelope
    connect?: Enumerable<TitleToCategoryWhereUniqueInput>
  }

  export type TitleToCategoryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<TitleToCategoryCreateWithoutCategoryInput>, Enumerable<TitleToCategoryUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<TitleToCategoryCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<TitleToCategoryUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: TitleToCategoryCreateManyCategoryInputEnvelope
    set?: Enumerable<TitleToCategoryWhereUniqueInput>
    disconnect?: Enumerable<TitleToCategoryWhereUniqueInput>
    delete?: Enumerable<TitleToCategoryWhereUniqueInput>
    connect?: Enumerable<TitleToCategoryWhereUniqueInput>
    update?: Enumerable<TitleToCategoryUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<TitleToCategoryUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<TitleToCategoryScalarWhereInput>
  }

  export type TitleToCategoryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<TitleToCategoryCreateWithoutCategoryInput>, Enumerable<TitleToCategoryUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<TitleToCategoryCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<TitleToCategoryUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: TitleToCategoryCreateManyCategoryInputEnvelope
    set?: Enumerable<TitleToCategoryWhereUniqueInput>
    disconnect?: Enumerable<TitleToCategoryWhereUniqueInput>
    delete?: Enumerable<TitleToCategoryWhereUniqueInput>
    connect?: Enumerable<TitleToCategoryWhereUniqueInput>
    update?: Enumerable<TitleToCategoryUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<TitleToCategoryUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<TitleToCategoryScalarWhereInput>
  }

  export type BKTitleCreateNestedOneWithoutTitleToCategoriesInput = {
    create?: XOR<BKTitleCreateWithoutTitleToCategoriesInput, BKTitleUncheckedCreateWithoutTitleToCategoriesInput>
    connectOrCreate?: BKTitleCreateOrConnectWithoutTitleToCategoriesInput
    connect?: BKTitleWhereUniqueInput
  }

  export type BKCategoryCreateNestedOneWithoutTitleToCategoriesInput = {
    create?: XOR<BKCategoryCreateWithoutTitleToCategoriesInput, BKCategoryUncheckedCreateWithoutTitleToCategoriesInput>
    connectOrCreate?: BKCategoryCreateOrConnectWithoutTitleToCategoriesInput
    connect?: BKCategoryWhereUniqueInput
  }

  export type BKTitleUpdateOneRequiredWithoutTitleToCategoriesNestedInput = {
    create?: XOR<BKTitleCreateWithoutTitleToCategoriesInput, BKTitleUncheckedCreateWithoutTitleToCategoriesInput>
    connectOrCreate?: BKTitleCreateOrConnectWithoutTitleToCategoriesInput
    upsert?: BKTitleUpsertWithoutTitleToCategoriesInput
    connect?: BKTitleWhereUniqueInput
    update?: XOR<BKTitleUpdateWithoutTitleToCategoriesInput, BKTitleUncheckedUpdateWithoutTitleToCategoriesInput>
  }

  export type BKCategoryUpdateOneRequiredWithoutTitleToCategoriesNestedInput = {
    create?: XOR<BKCategoryCreateWithoutTitleToCategoriesInput, BKCategoryUncheckedCreateWithoutTitleToCategoriesInput>
    connectOrCreate?: BKCategoryCreateOrConnectWithoutTitleToCategoriesInput
    upsert?: BKCategoryUpsertWithoutTitleToCategoriesInput
    connect?: BKCategoryWhereUniqueInput
    update?: XOR<BKCategoryUpdateWithoutTitleToCategoriesInput, BKCategoryUncheckedUpdateWithoutTitleToCategoriesInput>
  }

  export type TitleToAuthorCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<TitleToAuthorCreateWithoutAuthorInput>, Enumerable<TitleToAuthorUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<TitleToAuthorCreateOrConnectWithoutAuthorInput>
    createMany?: TitleToAuthorCreateManyAuthorInputEnvelope
    connect?: Enumerable<TitleToAuthorWhereUniqueInput>
  }

  export type TitleToAuthorUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<TitleToAuthorCreateWithoutAuthorInput>, Enumerable<TitleToAuthorUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<TitleToAuthorCreateOrConnectWithoutAuthorInput>
    createMany?: TitleToAuthorCreateManyAuthorInputEnvelope
    connect?: Enumerable<TitleToAuthorWhereUniqueInput>
  }

  export type TitleToAuthorUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<Enumerable<TitleToAuthorCreateWithoutAuthorInput>, Enumerable<TitleToAuthorUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<TitleToAuthorCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<TitleToAuthorUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: TitleToAuthorCreateManyAuthorInputEnvelope
    set?: Enumerable<TitleToAuthorWhereUniqueInput>
    disconnect?: Enumerable<TitleToAuthorWhereUniqueInput>
    delete?: Enumerable<TitleToAuthorWhereUniqueInput>
    connect?: Enumerable<TitleToAuthorWhereUniqueInput>
    update?: Enumerable<TitleToAuthorUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<TitleToAuthorUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<TitleToAuthorScalarWhereInput>
  }

  export type TitleToAuthorUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<Enumerable<TitleToAuthorCreateWithoutAuthorInput>, Enumerable<TitleToAuthorUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<TitleToAuthorCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<TitleToAuthorUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: TitleToAuthorCreateManyAuthorInputEnvelope
    set?: Enumerable<TitleToAuthorWhereUniqueInput>
    disconnect?: Enumerable<TitleToAuthorWhereUniqueInput>
    delete?: Enumerable<TitleToAuthorWhereUniqueInput>
    connect?: Enumerable<TitleToAuthorWhereUniqueInput>
    update?: Enumerable<TitleToAuthorUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<TitleToAuthorUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<TitleToAuthorScalarWhereInput>
  }

  export type BKTitleCreateNestedOneWithoutTitleToAuthorsInput = {
    create?: XOR<BKTitleCreateWithoutTitleToAuthorsInput, BKTitleUncheckedCreateWithoutTitleToAuthorsInput>
    connectOrCreate?: BKTitleCreateOrConnectWithoutTitleToAuthorsInput
    connect?: BKTitleWhereUniqueInput
  }

  export type BKAuthorCreateNestedOneWithoutTitleToAuthorsInput = {
    create?: XOR<BKAuthorCreateWithoutTitleToAuthorsInput, BKAuthorUncheckedCreateWithoutTitleToAuthorsInput>
    connectOrCreate?: BKAuthorCreateOrConnectWithoutTitleToAuthorsInput
    connect?: BKAuthorWhereUniqueInput
  }

  export type BKTitleUpdateOneRequiredWithoutTitleToAuthorsNestedInput = {
    create?: XOR<BKTitleCreateWithoutTitleToAuthorsInput, BKTitleUncheckedCreateWithoutTitleToAuthorsInput>
    connectOrCreate?: BKTitleCreateOrConnectWithoutTitleToAuthorsInput
    upsert?: BKTitleUpsertWithoutTitleToAuthorsInput
    connect?: BKTitleWhereUniqueInput
    update?: XOR<BKTitleUpdateWithoutTitleToAuthorsInput, BKTitleUncheckedUpdateWithoutTitleToAuthorsInput>
  }

  export type BKAuthorUpdateOneRequiredWithoutTitleToAuthorsNestedInput = {
    create?: XOR<BKAuthorCreateWithoutTitleToAuthorsInput, BKAuthorUncheckedCreateWithoutTitleToAuthorsInput>
    connectOrCreate?: BKAuthorCreateOrConnectWithoutTitleToAuthorsInput
    upsert?: BKAuthorUpsertWithoutTitleToAuthorsInput
    connect?: BKAuthorWhereUniqueInput
    update?: XOR<BKAuthorUpdateWithoutTitleToAuthorsInput, BKAuthorUncheckedUpdateWithoutTitleToAuthorsInput>
  }

  export type FbPostCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<FbPostCreateWithoutUserInput>, Enumerable<FbPostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FbPostCreateOrConnectWithoutUserInput>
    createMany?: FbPostCreateManyUserInputEnvelope
    connect?: Enumerable<FbPostWhereUniqueInput>
  }

  export type FbfriendCreateNestedManyWithoutAcceptFriendInput = {
    create?: XOR<Enumerable<FbfriendCreateWithoutAcceptFriendInput>, Enumerable<FbfriendUncheckedCreateWithoutAcceptFriendInput>>
    connectOrCreate?: Enumerable<FbfriendCreateOrConnectWithoutAcceptFriendInput>
    createMany?: FbfriendCreateManyAcceptFriendInputEnvelope
    connect?: Enumerable<FbfriendWhereUniqueInput>
  }

  export type FbfriendCreateNestedManyWithoutRequestFriendInput = {
    create?: XOR<Enumerable<FbfriendCreateWithoutRequestFriendInput>, Enumerable<FbfriendUncheckedCreateWithoutRequestFriendInput>>
    connectOrCreate?: Enumerable<FbfriendCreateOrConnectWithoutRequestFriendInput>
    createMany?: FbfriendCreateManyRequestFriendInputEnvelope
    connect?: Enumerable<FbfriendWhereUniqueInput>
  }

  export type FbLikeCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<FbLikeCreateWithoutUserInput>, Enumerable<FbLikeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FbLikeCreateOrConnectWithoutUserInput>
    createMany?: FbLikeCreateManyUserInputEnvelope
    connect?: Enumerable<FbLikeWhereUniqueInput>
  }

  export type FbMessengerCreateNestedManyWithoutFromInput = {
    create?: XOR<Enumerable<FbMessengerCreateWithoutFromInput>, Enumerable<FbMessengerUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<FbMessengerCreateOrConnectWithoutFromInput>
    createMany?: FbMessengerCreateManyFromInputEnvelope
    connect?: Enumerable<FbMessengerWhereUniqueInput>
  }

  export type FbMessengerCreateNestedManyWithoutToInput = {
    create?: XOR<Enumerable<FbMessengerCreateWithoutToInput>, Enumerable<FbMessengerUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<FbMessengerCreateOrConnectWithoutToInput>
    createMany?: FbMessengerCreateManyToInputEnvelope
    connect?: Enumerable<FbMessengerWhereUniqueInput>
  }

  export type FbShareCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<FbShareCreateWithoutUserInput>, Enumerable<FbShareUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FbShareCreateOrConnectWithoutUserInput>
    createMany?: FbShareCreateManyUserInputEnvelope
    connect?: Enumerable<FbShareWhereUniqueInput>
  }

  export type FbCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<FbCommentCreateWithoutUserInput>, Enumerable<FbCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FbCommentCreateOrConnectWithoutUserInput>
    createMany?: FbCommentCreateManyUserInputEnvelope
    connect?: Enumerable<FbCommentWhereUniqueInput>
  }

  export type GroupToUserCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<GroupToUserCreateWithoutUserInput>, Enumerable<GroupToUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<GroupToUserCreateOrConnectWithoutUserInput>
    createMany?: GroupToUserCreateManyUserInputEnvelope
    connect?: Enumerable<GroupToUserWhereUniqueInput>
  }

  export type FbPostUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<FbPostCreateWithoutUserInput>, Enumerable<FbPostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FbPostCreateOrConnectWithoutUserInput>
    createMany?: FbPostCreateManyUserInputEnvelope
    connect?: Enumerable<FbPostWhereUniqueInput>
  }

  export type FbfriendUncheckedCreateNestedManyWithoutAcceptFriendInput = {
    create?: XOR<Enumerable<FbfriendCreateWithoutAcceptFriendInput>, Enumerable<FbfriendUncheckedCreateWithoutAcceptFriendInput>>
    connectOrCreate?: Enumerable<FbfriendCreateOrConnectWithoutAcceptFriendInput>
    createMany?: FbfriendCreateManyAcceptFriendInputEnvelope
    connect?: Enumerable<FbfriendWhereUniqueInput>
  }

  export type FbfriendUncheckedCreateNestedManyWithoutRequestFriendInput = {
    create?: XOR<Enumerable<FbfriendCreateWithoutRequestFriendInput>, Enumerable<FbfriendUncheckedCreateWithoutRequestFriendInput>>
    connectOrCreate?: Enumerable<FbfriendCreateOrConnectWithoutRequestFriendInput>
    createMany?: FbfriendCreateManyRequestFriendInputEnvelope
    connect?: Enumerable<FbfriendWhereUniqueInput>
  }

  export type FbLikeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<FbLikeCreateWithoutUserInput>, Enumerable<FbLikeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FbLikeCreateOrConnectWithoutUserInput>
    createMany?: FbLikeCreateManyUserInputEnvelope
    connect?: Enumerable<FbLikeWhereUniqueInput>
  }

  export type FbMessengerUncheckedCreateNestedManyWithoutFromInput = {
    create?: XOR<Enumerable<FbMessengerCreateWithoutFromInput>, Enumerable<FbMessengerUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<FbMessengerCreateOrConnectWithoutFromInput>
    createMany?: FbMessengerCreateManyFromInputEnvelope
    connect?: Enumerable<FbMessengerWhereUniqueInput>
  }

  export type FbMessengerUncheckedCreateNestedManyWithoutToInput = {
    create?: XOR<Enumerable<FbMessengerCreateWithoutToInput>, Enumerable<FbMessengerUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<FbMessengerCreateOrConnectWithoutToInput>
    createMany?: FbMessengerCreateManyToInputEnvelope
    connect?: Enumerable<FbMessengerWhereUniqueInput>
  }

  export type FbShareUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<FbShareCreateWithoutUserInput>, Enumerable<FbShareUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FbShareCreateOrConnectWithoutUserInput>
    createMany?: FbShareCreateManyUserInputEnvelope
    connect?: Enumerable<FbShareWhereUniqueInput>
  }

  export type FbCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<FbCommentCreateWithoutUserInput>, Enumerable<FbCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FbCommentCreateOrConnectWithoutUserInput>
    createMany?: FbCommentCreateManyUserInputEnvelope
    connect?: Enumerable<FbCommentWhereUniqueInput>
  }

  export type GroupToUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<GroupToUserCreateWithoutUserInput>, Enumerable<GroupToUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<GroupToUserCreateOrConnectWithoutUserInput>
    createMany?: GroupToUserCreateManyUserInputEnvelope
    connect?: Enumerable<GroupToUserWhereUniqueInput>
  }

  export type FbPostUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<FbPostCreateWithoutUserInput>, Enumerable<FbPostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FbPostCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<FbPostUpsertWithWhereUniqueWithoutUserInput>
    createMany?: FbPostCreateManyUserInputEnvelope
    set?: Enumerable<FbPostWhereUniqueInput>
    disconnect?: Enumerable<FbPostWhereUniqueInput>
    delete?: Enumerable<FbPostWhereUniqueInput>
    connect?: Enumerable<FbPostWhereUniqueInput>
    update?: Enumerable<FbPostUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<FbPostUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<FbPostScalarWhereInput>
  }

  export type FbfriendUpdateManyWithoutAcceptFriendNestedInput = {
    create?: XOR<Enumerable<FbfriendCreateWithoutAcceptFriendInput>, Enumerable<FbfriendUncheckedCreateWithoutAcceptFriendInput>>
    connectOrCreate?: Enumerable<FbfriendCreateOrConnectWithoutAcceptFriendInput>
    upsert?: Enumerable<FbfriendUpsertWithWhereUniqueWithoutAcceptFriendInput>
    createMany?: FbfriendCreateManyAcceptFriendInputEnvelope
    set?: Enumerable<FbfriendWhereUniqueInput>
    disconnect?: Enumerable<FbfriendWhereUniqueInput>
    delete?: Enumerable<FbfriendWhereUniqueInput>
    connect?: Enumerable<FbfriendWhereUniqueInput>
    update?: Enumerable<FbfriendUpdateWithWhereUniqueWithoutAcceptFriendInput>
    updateMany?: Enumerable<FbfriendUpdateManyWithWhereWithoutAcceptFriendInput>
    deleteMany?: Enumerable<FbfriendScalarWhereInput>
  }

  export type FbfriendUpdateManyWithoutRequestFriendNestedInput = {
    create?: XOR<Enumerable<FbfriendCreateWithoutRequestFriendInput>, Enumerable<FbfriendUncheckedCreateWithoutRequestFriendInput>>
    connectOrCreate?: Enumerable<FbfriendCreateOrConnectWithoutRequestFriendInput>
    upsert?: Enumerable<FbfriendUpsertWithWhereUniqueWithoutRequestFriendInput>
    createMany?: FbfriendCreateManyRequestFriendInputEnvelope
    set?: Enumerable<FbfriendWhereUniqueInput>
    disconnect?: Enumerable<FbfriendWhereUniqueInput>
    delete?: Enumerable<FbfriendWhereUniqueInput>
    connect?: Enumerable<FbfriendWhereUniqueInput>
    update?: Enumerable<FbfriendUpdateWithWhereUniqueWithoutRequestFriendInput>
    updateMany?: Enumerable<FbfriendUpdateManyWithWhereWithoutRequestFriendInput>
    deleteMany?: Enumerable<FbfriendScalarWhereInput>
  }

  export type FbLikeUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<FbLikeCreateWithoutUserInput>, Enumerable<FbLikeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FbLikeCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<FbLikeUpsertWithWhereUniqueWithoutUserInput>
    createMany?: FbLikeCreateManyUserInputEnvelope
    set?: Enumerable<FbLikeWhereUniqueInput>
    disconnect?: Enumerable<FbLikeWhereUniqueInput>
    delete?: Enumerable<FbLikeWhereUniqueInput>
    connect?: Enumerable<FbLikeWhereUniqueInput>
    update?: Enumerable<FbLikeUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<FbLikeUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<FbLikeScalarWhereInput>
  }

  export type FbMessengerUpdateManyWithoutFromNestedInput = {
    create?: XOR<Enumerable<FbMessengerCreateWithoutFromInput>, Enumerable<FbMessengerUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<FbMessengerCreateOrConnectWithoutFromInput>
    upsert?: Enumerable<FbMessengerUpsertWithWhereUniqueWithoutFromInput>
    createMany?: FbMessengerCreateManyFromInputEnvelope
    set?: Enumerable<FbMessengerWhereUniqueInput>
    disconnect?: Enumerable<FbMessengerWhereUniqueInput>
    delete?: Enumerable<FbMessengerWhereUniqueInput>
    connect?: Enumerable<FbMessengerWhereUniqueInput>
    update?: Enumerable<FbMessengerUpdateWithWhereUniqueWithoutFromInput>
    updateMany?: Enumerable<FbMessengerUpdateManyWithWhereWithoutFromInput>
    deleteMany?: Enumerable<FbMessengerScalarWhereInput>
  }

  export type FbMessengerUpdateManyWithoutToNestedInput = {
    create?: XOR<Enumerable<FbMessengerCreateWithoutToInput>, Enumerable<FbMessengerUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<FbMessengerCreateOrConnectWithoutToInput>
    upsert?: Enumerable<FbMessengerUpsertWithWhereUniqueWithoutToInput>
    createMany?: FbMessengerCreateManyToInputEnvelope
    set?: Enumerable<FbMessengerWhereUniqueInput>
    disconnect?: Enumerable<FbMessengerWhereUniqueInput>
    delete?: Enumerable<FbMessengerWhereUniqueInput>
    connect?: Enumerable<FbMessengerWhereUniqueInput>
    update?: Enumerable<FbMessengerUpdateWithWhereUniqueWithoutToInput>
    updateMany?: Enumerable<FbMessengerUpdateManyWithWhereWithoutToInput>
    deleteMany?: Enumerable<FbMessengerScalarWhereInput>
  }

  export type FbShareUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<FbShareCreateWithoutUserInput>, Enumerable<FbShareUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FbShareCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<FbShareUpsertWithWhereUniqueWithoutUserInput>
    createMany?: FbShareCreateManyUserInputEnvelope
    set?: Enumerable<FbShareWhereUniqueInput>
    disconnect?: Enumerable<FbShareWhereUniqueInput>
    delete?: Enumerable<FbShareWhereUniqueInput>
    connect?: Enumerable<FbShareWhereUniqueInput>
    update?: Enumerable<FbShareUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<FbShareUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<FbShareScalarWhereInput>
  }

  export type FbCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<FbCommentCreateWithoutUserInput>, Enumerable<FbCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FbCommentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<FbCommentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: FbCommentCreateManyUserInputEnvelope
    set?: Enumerable<FbCommentWhereUniqueInput>
    disconnect?: Enumerable<FbCommentWhereUniqueInput>
    delete?: Enumerable<FbCommentWhereUniqueInput>
    connect?: Enumerable<FbCommentWhereUniqueInput>
    update?: Enumerable<FbCommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<FbCommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<FbCommentScalarWhereInput>
  }

  export type GroupToUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<GroupToUserCreateWithoutUserInput>, Enumerable<GroupToUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<GroupToUserCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<GroupToUserUpsertWithWhereUniqueWithoutUserInput>
    createMany?: GroupToUserCreateManyUserInputEnvelope
    set?: Enumerable<GroupToUserWhereUniqueInput>
    disconnect?: Enumerable<GroupToUserWhereUniqueInput>
    delete?: Enumerable<GroupToUserWhereUniqueInput>
    connect?: Enumerable<GroupToUserWhereUniqueInput>
    update?: Enumerable<GroupToUserUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<GroupToUserUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<GroupToUserScalarWhereInput>
  }

  export type FbPostUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<FbPostCreateWithoutUserInput>, Enumerable<FbPostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FbPostCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<FbPostUpsertWithWhereUniqueWithoutUserInput>
    createMany?: FbPostCreateManyUserInputEnvelope
    set?: Enumerable<FbPostWhereUniqueInput>
    disconnect?: Enumerable<FbPostWhereUniqueInput>
    delete?: Enumerable<FbPostWhereUniqueInput>
    connect?: Enumerable<FbPostWhereUniqueInput>
    update?: Enumerable<FbPostUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<FbPostUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<FbPostScalarWhereInput>
  }

  export type FbfriendUncheckedUpdateManyWithoutAcceptFriendNestedInput = {
    create?: XOR<Enumerable<FbfriendCreateWithoutAcceptFriendInput>, Enumerable<FbfriendUncheckedCreateWithoutAcceptFriendInput>>
    connectOrCreate?: Enumerable<FbfriendCreateOrConnectWithoutAcceptFriendInput>
    upsert?: Enumerable<FbfriendUpsertWithWhereUniqueWithoutAcceptFriendInput>
    createMany?: FbfriendCreateManyAcceptFriendInputEnvelope
    set?: Enumerable<FbfriendWhereUniqueInput>
    disconnect?: Enumerable<FbfriendWhereUniqueInput>
    delete?: Enumerable<FbfriendWhereUniqueInput>
    connect?: Enumerable<FbfriendWhereUniqueInput>
    update?: Enumerable<FbfriendUpdateWithWhereUniqueWithoutAcceptFriendInput>
    updateMany?: Enumerable<FbfriendUpdateManyWithWhereWithoutAcceptFriendInput>
    deleteMany?: Enumerable<FbfriendScalarWhereInput>
  }

  export type FbfriendUncheckedUpdateManyWithoutRequestFriendNestedInput = {
    create?: XOR<Enumerable<FbfriendCreateWithoutRequestFriendInput>, Enumerable<FbfriendUncheckedCreateWithoutRequestFriendInput>>
    connectOrCreate?: Enumerable<FbfriendCreateOrConnectWithoutRequestFriendInput>
    upsert?: Enumerable<FbfriendUpsertWithWhereUniqueWithoutRequestFriendInput>
    createMany?: FbfriendCreateManyRequestFriendInputEnvelope
    set?: Enumerable<FbfriendWhereUniqueInput>
    disconnect?: Enumerable<FbfriendWhereUniqueInput>
    delete?: Enumerable<FbfriendWhereUniqueInput>
    connect?: Enumerable<FbfriendWhereUniqueInput>
    update?: Enumerable<FbfriendUpdateWithWhereUniqueWithoutRequestFriendInput>
    updateMany?: Enumerable<FbfriendUpdateManyWithWhereWithoutRequestFriendInput>
    deleteMany?: Enumerable<FbfriendScalarWhereInput>
  }

  export type FbLikeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<FbLikeCreateWithoutUserInput>, Enumerable<FbLikeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FbLikeCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<FbLikeUpsertWithWhereUniqueWithoutUserInput>
    createMany?: FbLikeCreateManyUserInputEnvelope
    set?: Enumerable<FbLikeWhereUniqueInput>
    disconnect?: Enumerable<FbLikeWhereUniqueInput>
    delete?: Enumerable<FbLikeWhereUniqueInput>
    connect?: Enumerable<FbLikeWhereUniqueInput>
    update?: Enumerable<FbLikeUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<FbLikeUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<FbLikeScalarWhereInput>
  }

  export type FbMessengerUncheckedUpdateManyWithoutFromNestedInput = {
    create?: XOR<Enumerable<FbMessengerCreateWithoutFromInput>, Enumerable<FbMessengerUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<FbMessengerCreateOrConnectWithoutFromInput>
    upsert?: Enumerable<FbMessengerUpsertWithWhereUniqueWithoutFromInput>
    createMany?: FbMessengerCreateManyFromInputEnvelope
    set?: Enumerable<FbMessengerWhereUniqueInput>
    disconnect?: Enumerable<FbMessengerWhereUniqueInput>
    delete?: Enumerable<FbMessengerWhereUniqueInput>
    connect?: Enumerable<FbMessengerWhereUniqueInput>
    update?: Enumerable<FbMessengerUpdateWithWhereUniqueWithoutFromInput>
    updateMany?: Enumerable<FbMessengerUpdateManyWithWhereWithoutFromInput>
    deleteMany?: Enumerable<FbMessengerScalarWhereInput>
  }

  export type FbMessengerUncheckedUpdateManyWithoutToNestedInput = {
    create?: XOR<Enumerable<FbMessengerCreateWithoutToInput>, Enumerable<FbMessengerUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<FbMessengerCreateOrConnectWithoutToInput>
    upsert?: Enumerable<FbMessengerUpsertWithWhereUniqueWithoutToInput>
    createMany?: FbMessengerCreateManyToInputEnvelope
    set?: Enumerable<FbMessengerWhereUniqueInput>
    disconnect?: Enumerable<FbMessengerWhereUniqueInput>
    delete?: Enumerable<FbMessengerWhereUniqueInput>
    connect?: Enumerable<FbMessengerWhereUniqueInput>
    update?: Enumerable<FbMessengerUpdateWithWhereUniqueWithoutToInput>
    updateMany?: Enumerable<FbMessengerUpdateManyWithWhereWithoutToInput>
    deleteMany?: Enumerable<FbMessengerScalarWhereInput>
  }

  export type FbShareUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<FbShareCreateWithoutUserInput>, Enumerable<FbShareUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FbShareCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<FbShareUpsertWithWhereUniqueWithoutUserInput>
    createMany?: FbShareCreateManyUserInputEnvelope
    set?: Enumerable<FbShareWhereUniqueInput>
    disconnect?: Enumerable<FbShareWhereUniqueInput>
    delete?: Enumerable<FbShareWhereUniqueInput>
    connect?: Enumerable<FbShareWhereUniqueInput>
    update?: Enumerable<FbShareUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<FbShareUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<FbShareScalarWhereInput>
  }

  export type FbCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<FbCommentCreateWithoutUserInput>, Enumerable<FbCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FbCommentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<FbCommentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: FbCommentCreateManyUserInputEnvelope
    set?: Enumerable<FbCommentWhereUniqueInput>
    disconnect?: Enumerable<FbCommentWhereUniqueInput>
    delete?: Enumerable<FbCommentWhereUniqueInput>
    connect?: Enumerable<FbCommentWhereUniqueInput>
    update?: Enumerable<FbCommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<FbCommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<FbCommentScalarWhereInput>
  }

  export type GroupToUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<GroupToUserCreateWithoutUserInput>, Enumerable<GroupToUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<GroupToUserCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<GroupToUserUpsertWithWhereUniqueWithoutUserInput>
    createMany?: GroupToUserCreateManyUserInputEnvelope
    set?: Enumerable<GroupToUserWhereUniqueInput>
    disconnect?: Enumerable<GroupToUserWhereUniqueInput>
    delete?: Enumerable<GroupToUserWhereUniqueInput>
    connect?: Enumerable<GroupToUserWhereUniqueInput>
    update?: Enumerable<GroupToUserUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<GroupToUserUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<GroupToUserScalarWhereInput>
  }

  export type FbUserCreateNestedOneWithoutPostsInput = {
    create?: XOR<FbUserCreateWithoutPostsInput, FbUserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: FbUserCreateOrConnectWithoutPostsInput
    connect?: FbUserWhereUniqueInput
  }

  export type FbPostImageCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<FbPostImageCreateWithoutPostInput>, Enumerable<FbPostImageUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<FbPostImageCreateOrConnectWithoutPostInput>
    createMany?: FbPostImageCreateManyPostInputEnvelope
    connect?: Enumerable<FbPostImageWhereUniqueInput>
  }

  export type FbPostVideoCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<FbPostVideoCreateWithoutPostInput>, Enumerable<FbPostVideoUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<FbPostVideoCreateOrConnectWithoutPostInput>
    createMany?: FbPostVideoCreateManyPostInputEnvelope
    connect?: Enumerable<FbPostVideoWhereUniqueInput>
  }

  export type FbPostOnHashtagCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<FbPostOnHashtagCreateWithoutPostInput>, Enumerable<FbPostOnHashtagUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<FbPostOnHashtagCreateOrConnectWithoutPostInput>
    createMany?: FbPostOnHashtagCreateManyPostInputEnvelope
    connect?: Enumerable<FbPostOnHashtagWhereUniqueInput>
  }

  export type FbShareCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<FbShareCreateWithoutPostInput>, Enumerable<FbShareUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<FbShareCreateOrConnectWithoutPostInput>
    createMany?: FbShareCreateManyPostInputEnvelope
    connect?: Enumerable<FbShareWhereUniqueInput>
  }

  export type FbLikeCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<FbLikeCreateWithoutPostInput>, Enumerable<FbLikeUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<FbLikeCreateOrConnectWithoutPostInput>
    createMany?: FbLikeCreateManyPostInputEnvelope
    connect?: Enumerable<FbLikeWhereUniqueInput>
  }

  export type FbWallCreateNestedOneWithoutPostsInput = {
    create?: XOR<FbWallCreateWithoutPostsInput, FbWallUncheckedCreateWithoutPostsInput>
    connectOrCreate?: FbWallCreateOrConnectWithoutPostsInput
    connect?: FbWallWhereUniqueInput
  }

  export type FbPostImageUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<FbPostImageCreateWithoutPostInput>, Enumerable<FbPostImageUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<FbPostImageCreateOrConnectWithoutPostInput>
    createMany?: FbPostImageCreateManyPostInputEnvelope
    connect?: Enumerable<FbPostImageWhereUniqueInput>
  }

  export type FbPostVideoUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<FbPostVideoCreateWithoutPostInput>, Enumerable<FbPostVideoUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<FbPostVideoCreateOrConnectWithoutPostInput>
    createMany?: FbPostVideoCreateManyPostInputEnvelope
    connect?: Enumerable<FbPostVideoWhereUniqueInput>
  }

  export type FbPostOnHashtagUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<FbPostOnHashtagCreateWithoutPostInput>, Enumerable<FbPostOnHashtagUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<FbPostOnHashtagCreateOrConnectWithoutPostInput>
    createMany?: FbPostOnHashtagCreateManyPostInputEnvelope
    connect?: Enumerable<FbPostOnHashtagWhereUniqueInput>
  }

  export type FbShareUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<FbShareCreateWithoutPostInput>, Enumerable<FbShareUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<FbShareCreateOrConnectWithoutPostInput>
    createMany?: FbShareCreateManyPostInputEnvelope
    connect?: Enumerable<FbShareWhereUniqueInput>
  }

  export type FbLikeUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<FbLikeCreateWithoutPostInput>, Enumerable<FbLikeUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<FbLikeCreateOrConnectWithoutPostInput>
    createMany?: FbLikeCreateManyPostInputEnvelope
    connect?: Enumerable<FbLikeWhereUniqueInput>
  }

  export type FbUserUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<FbUserCreateWithoutPostsInput, FbUserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: FbUserCreateOrConnectWithoutPostsInput
    upsert?: FbUserUpsertWithoutPostsInput
    connect?: FbUserWhereUniqueInput
    update?: XOR<FbUserUpdateWithoutPostsInput, FbUserUncheckedUpdateWithoutPostsInput>
  }

  export type FbPostImageUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<FbPostImageCreateWithoutPostInput>, Enumerable<FbPostImageUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<FbPostImageCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<FbPostImageUpsertWithWhereUniqueWithoutPostInput>
    createMany?: FbPostImageCreateManyPostInputEnvelope
    set?: Enumerable<FbPostImageWhereUniqueInput>
    disconnect?: Enumerable<FbPostImageWhereUniqueInput>
    delete?: Enumerable<FbPostImageWhereUniqueInput>
    connect?: Enumerable<FbPostImageWhereUniqueInput>
    update?: Enumerable<FbPostImageUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<FbPostImageUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<FbPostImageScalarWhereInput>
  }

  export type FbPostVideoUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<FbPostVideoCreateWithoutPostInput>, Enumerable<FbPostVideoUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<FbPostVideoCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<FbPostVideoUpsertWithWhereUniqueWithoutPostInput>
    createMany?: FbPostVideoCreateManyPostInputEnvelope
    set?: Enumerable<FbPostVideoWhereUniqueInput>
    disconnect?: Enumerable<FbPostVideoWhereUniqueInput>
    delete?: Enumerable<FbPostVideoWhereUniqueInput>
    connect?: Enumerable<FbPostVideoWhereUniqueInput>
    update?: Enumerable<FbPostVideoUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<FbPostVideoUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<FbPostVideoScalarWhereInput>
  }

  export type FbPostOnHashtagUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<FbPostOnHashtagCreateWithoutPostInput>, Enumerable<FbPostOnHashtagUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<FbPostOnHashtagCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<FbPostOnHashtagUpsertWithWhereUniqueWithoutPostInput>
    createMany?: FbPostOnHashtagCreateManyPostInputEnvelope
    set?: Enumerable<FbPostOnHashtagWhereUniqueInput>
    disconnect?: Enumerable<FbPostOnHashtagWhereUniqueInput>
    delete?: Enumerable<FbPostOnHashtagWhereUniqueInput>
    connect?: Enumerable<FbPostOnHashtagWhereUniqueInput>
    update?: Enumerable<FbPostOnHashtagUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<FbPostOnHashtagUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<FbPostOnHashtagScalarWhereInput>
  }

  export type FbShareUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<FbShareCreateWithoutPostInput>, Enumerable<FbShareUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<FbShareCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<FbShareUpsertWithWhereUniqueWithoutPostInput>
    createMany?: FbShareCreateManyPostInputEnvelope
    set?: Enumerable<FbShareWhereUniqueInput>
    disconnect?: Enumerable<FbShareWhereUniqueInput>
    delete?: Enumerable<FbShareWhereUniqueInput>
    connect?: Enumerable<FbShareWhereUniqueInput>
    update?: Enumerable<FbShareUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<FbShareUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<FbShareScalarWhereInput>
  }

  export type FbLikeUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<FbLikeCreateWithoutPostInput>, Enumerable<FbLikeUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<FbLikeCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<FbLikeUpsertWithWhereUniqueWithoutPostInput>
    createMany?: FbLikeCreateManyPostInputEnvelope
    set?: Enumerable<FbLikeWhereUniqueInput>
    disconnect?: Enumerable<FbLikeWhereUniqueInput>
    delete?: Enumerable<FbLikeWhereUniqueInput>
    connect?: Enumerable<FbLikeWhereUniqueInput>
    update?: Enumerable<FbLikeUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<FbLikeUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<FbLikeScalarWhereInput>
  }

  export type FbWallUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<FbWallCreateWithoutPostsInput, FbWallUncheckedCreateWithoutPostsInput>
    connectOrCreate?: FbWallCreateOrConnectWithoutPostsInput
    upsert?: FbWallUpsertWithoutPostsInput
    connect?: FbWallWhereUniqueInput
    update?: XOR<FbWallUpdateWithoutPostsInput, FbWallUncheckedUpdateWithoutPostsInput>
  }

  export type FbPostImageUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<FbPostImageCreateWithoutPostInput>, Enumerable<FbPostImageUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<FbPostImageCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<FbPostImageUpsertWithWhereUniqueWithoutPostInput>
    createMany?: FbPostImageCreateManyPostInputEnvelope
    set?: Enumerable<FbPostImageWhereUniqueInput>
    disconnect?: Enumerable<FbPostImageWhereUniqueInput>
    delete?: Enumerable<FbPostImageWhereUniqueInput>
    connect?: Enumerable<FbPostImageWhereUniqueInput>
    update?: Enumerable<FbPostImageUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<FbPostImageUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<FbPostImageScalarWhereInput>
  }

  export type FbPostVideoUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<FbPostVideoCreateWithoutPostInput>, Enumerable<FbPostVideoUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<FbPostVideoCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<FbPostVideoUpsertWithWhereUniqueWithoutPostInput>
    createMany?: FbPostVideoCreateManyPostInputEnvelope
    set?: Enumerable<FbPostVideoWhereUniqueInput>
    disconnect?: Enumerable<FbPostVideoWhereUniqueInput>
    delete?: Enumerable<FbPostVideoWhereUniqueInput>
    connect?: Enumerable<FbPostVideoWhereUniqueInput>
    update?: Enumerable<FbPostVideoUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<FbPostVideoUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<FbPostVideoScalarWhereInput>
  }

  export type FbPostOnHashtagUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<FbPostOnHashtagCreateWithoutPostInput>, Enumerable<FbPostOnHashtagUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<FbPostOnHashtagCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<FbPostOnHashtagUpsertWithWhereUniqueWithoutPostInput>
    createMany?: FbPostOnHashtagCreateManyPostInputEnvelope
    set?: Enumerable<FbPostOnHashtagWhereUniqueInput>
    disconnect?: Enumerable<FbPostOnHashtagWhereUniqueInput>
    delete?: Enumerable<FbPostOnHashtagWhereUniqueInput>
    connect?: Enumerable<FbPostOnHashtagWhereUniqueInput>
    update?: Enumerable<FbPostOnHashtagUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<FbPostOnHashtagUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<FbPostOnHashtagScalarWhereInput>
  }

  export type FbShareUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<FbShareCreateWithoutPostInput>, Enumerable<FbShareUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<FbShareCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<FbShareUpsertWithWhereUniqueWithoutPostInput>
    createMany?: FbShareCreateManyPostInputEnvelope
    set?: Enumerable<FbShareWhereUniqueInput>
    disconnect?: Enumerable<FbShareWhereUniqueInput>
    delete?: Enumerable<FbShareWhereUniqueInput>
    connect?: Enumerable<FbShareWhereUniqueInput>
    update?: Enumerable<FbShareUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<FbShareUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<FbShareScalarWhereInput>
  }

  export type FbLikeUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<FbLikeCreateWithoutPostInput>, Enumerable<FbLikeUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<FbLikeCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<FbLikeUpsertWithWhereUniqueWithoutPostInput>
    createMany?: FbLikeCreateManyPostInputEnvelope
    set?: Enumerable<FbLikeWhereUniqueInput>
    disconnect?: Enumerable<FbLikeWhereUniqueInput>
    delete?: Enumerable<FbLikeWhereUniqueInput>
    connect?: Enumerable<FbLikeWhereUniqueInput>
    update?: Enumerable<FbLikeUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<FbLikeUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<FbLikeScalarWhereInput>
  }

  export type FbPostCreateNestedOneWithoutPostImagesInput = {
    create?: XOR<FbPostCreateWithoutPostImagesInput, FbPostUncheckedCreateWithoutPostImagesInput>
    connectOrCreate?: FbPostCreateOrConnectWithoutPostImagesInput
    connect?: FbPostWhereUniqueInput
  }

  export type FbPostUpdateOneRequiredWithoutPostImagesNestedInput = {
    create?: XOR<FbPostCreateWithoutPostImagesInput, FbPostUncheckedCreateWithoutPostImagesInput>
    connectOrCreate?: FbPostCreateOrConnectWithoutPostImagesInput
    upsert?: FbPostUpsertWithoutPostImagesInput
    connect?: FbPostWhereUniqueInput
    update?: XOR<FbPostUpdateWithoutPostImagesInput, FbPostUncheckedUpdateWithoutPostImagesInput>
  }

  export type FbPostCreateNestedOneWithoutPostVideoesInput = {
    create?: XOR<FbPostCreateWithoutPostVideoesInput, FbPostUncheckedCreateWithoutPostVideoesInput>
    connectOrCreate?: FbPostCreateOrConnectWithoutPostVideoesInput
    connect?: FbPostWhereUniqueInput
  }

  export type FbPostUpdateOneRequiredWithoutPostVideoesNestedInput = {
    create?: XOR<FbPostCreateWithoutPostVideoesInput, FbPostUncheckedCreateWithoutPostVideoesInput>
    connectOrCreate?: FbPostCreateOrConnectWithoutPostVideoesInput
    upsert?: FbPostUpsertWithoutPostVideoesInput
    connect?: FbPostWhereUniqueInput
    update?: XOR<FbPostUpdateWithoutPostVideoesInput, FbPostUncheckedUpdateWithoutPostVideoesInput>
  }

  export type FbPostOnHashtagCreateNestedManyWithoutHashtagInput = {
    create?: XOR<Enumerable<FbPostOnHashtagCreateWithoutHashtagInput>, Enumerable<FbPostOnHashtagUncheckedCreateWithoutHashtagInput>>
    connectOrCreate?: Enumerable<FbPostOnHashtagCreateOrConnectWithoutHashtagInput>
    createMany?: FbPostOnHashtagCreateManyHashtagInputEnvelope
    connect?: Enumerable<FbPostOnHashtagWhereUniqueInput>
  }

  export type FbPostOnHashtagUncheckedCreateNestedManyWithoutHashtagInput = {
    create?: XOR<Enumerable<FbPostOnHashtagCreateWithoutHashtagInput>, Enumerable<FbPostOnHashtagUncheckedCreateWithoutHashtagInput>>
    connectOrCreate?: Enumerable<FbPostOnHashtagCreateOrConnectWithoutHashtagInput>
    createMany?: FbPostOnHashtagCreateManyHashtagInputEnvelope
    connect?: Enumerable<FbPostOnHashtagWhereUniqueInput>
  }

  export type FbPostOnHashtagUpdateManyWithoutHashtagNestedInput = {
    create?: XOR<Enumerable<FbPostOnHashtagCreateWithoutHashtagInput>, Enumerable<FbPostOnHashtagUncheckedCreateWithoutHashtagInput>>
    connectOrCreate?: Enumerable<FbPostOnHashtagCreateOrConnectWithoutHashtagInput>
    upsert?: Enumerable<FbPostOnHashtagUpsertWithWhereUniqueWithoutHashtagInput>
    createMany?: FbPostOnHashtagCreateManyHashtagInputEnvelope
    set?: Enumerable<FbPostOnHashtagWhereUniqueInput>
    disconnect?: Enumerable<FbPostOnHashtagWhereUniqueInput>
    delete?: Enumerable<FbPostOnHashtagWhereUniqueInput>
    connect?: Enumerable<FbPostOnHashtagWhereUniqueInput>
    update?: Enumerable<FbPostOnHashtagUpdateWithWhereUniqueWithoutHashtagInput>
    updateMany?: Enumerable<FbPostOnHashtagUpdateManyWithWhereWithoutHashtagInput>
    deleteMany?: Enumerable<FbPostOnHashtagScalarWhereInput>
  }

  export type FbPostOnHashtagUncheckedUpdateManyWithoutHashtagNestedInput = {
    create?: XOR<Enumerable<FbPostOnHashtagCreateWithoutHashtagInput>, Enumerable<FbPostOnHashtagUncheckedCreateWithoutHashtagInput>>
    connectOrCreate?: Enumerable<FbPostOnHashtagCreateOrConnectWithoutHashtagInput>
    upsert?: Enumerable<FbPostOnHashtagUpsertWithWhereUniqueWithoutHashtagInput>
    createMany?: FbPostOnHashtagCreateManyHashtagInputEnvelope
    set?: Enumerable<FbPostOnHashtagWhereUniqueInput>
    disconnect?: Enumerable<FbPostOnHashtagWhereUniqueInput>
    delete?: Enumerable<FbPostOnHashtagWhereUniqueInput>
    connect?: Enumerable<FbPostOnHashtagWhereUniqueInput>
    update?: Enumerable<FbPostOnHashtagUpdateWithWhereUniqueWithoutHashtagInput>
    updateMany?: Enumerable<FbPostOnHashtagUpdateManyWithWhereWithoutHashtagInput>
    deleteMany?: Enumerable<FbPostOnHashtagScalarWhereInput>
  }

  export type FbPostCreateNestedOneWithoutPostOnHashtagsInput = {
    create?: XOR<FbPostCreateWithoutPostOnHashtagsInput, FbPostUncheckedCreateWithoutPostOnHashtagsInput>
    connectOrCreate?: FbPostCreateOrConnectWithoutPostOnHashtagsInput
    connect?: FbPostWhereUniqueInput
  }

  export type FbHashtagCreateNestedOneWithoutPostOnHashtagsInput = {
    create?: XOR<FbHashtagCreateWithoutPostOnHashtagsInput, FbHashtagUncheckedCreateWithoutPostOnHashtagsInput>
    connectOrCreate?: FbHashtagCreateOrConnectWithoutPostOnHashtagsInput
    connect?: FbHashtagWhereUniqueInput
  }

  export type FbPostUpdateOneRequiredWithoutPostOnHashtagsNestedInput = {
    create?: XOR<FbPostCreateWithoutPostOnHashtagsInput, FbPostUncheckedCreateWithoutPostOnHashtagsInput>
    connectOrCreate?: FbPostCreateOrConnectWithoutPostOnHashtagsInput
    upsert?: FbPostUpsertWithoutPostOnHashtagsInput
    connect?: FbPostWhereUniqueInput
    update?: XOR<FbPostUpdateWithoutPostOnHashtagsInput, FbPostUncheckedUpdateWithoutPostOnHashtagsInput>
  }

  export type FbHashtagUpdateOneRequiredWithoutPostOnHashtagsNestedInput = {
    create?: XOR<FbHashtagCreateWithoutPostOnHashtagsInput, FbHashtagUncheckedCreateWithoutPostOnHashtagsInput>
    connectOrCreate?: FbHashtagCreateOrConnectWithoutPostOnHashtagsInput
    upsert?: FbHashtagUpsertWithoutPostOnHashtagsInput
    connect?: FbHashtagWhereUniqueInput
    update?: XOR<FbHashtagUpdateWithoutPostOnHashtagsInput, FbHashtagUncheckedUpdateWithoutPostOnHashtagsInput>
  }

  export type FbUserCreateNestedOneWithoutLikesInput = {
    create?: XOR<FbUserCreateWithoutLikesInput, FbUserUncheckedCreateWithoutLikesInput>
    connectOrCreate?: FbUserCreateOrConnectWithoutLikesInput
    connect?: FbUserWhereUniqueInput
  }

  export type FbPostCreateNestedOneWithoutLikesInput = {
    create?: XOR<FbPostCreateWithoutLikesInput, FbPostUncheckedCreateWithoutLikesInput>
    connectOrCreate?: FbPostCreateOrConnectWithoutLikesInput
    connect?: FbPostWhereUniqueInput
  }

  export type FbCommentCreateNestedOneWithoutLikesInput = {
    create?: XOR<FbCommentCreateWithoutLikesInput, FbCommentUncheckedCreateWithoutLikesInput>
    connectOrCreate?: FbCommentCreateOrConnectWithoutLikesInput
    connect?: FbCommentWhereUniqueInput
  }

  export type FbShareCreateNestedOneWithoutLikesInput = {
    create?: XOR<FbShareCreateWithoutLikesInput, FbShareUncheckedCreateWithoutLikesInput>
    connectOrCreate?: FbShareCreateOrConnectWithoutLikesInput
    connect?: FbShareWhereUniqueInput
  }

  export type FbUserUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<FbUserCreateWithoutLikesInput, FbUserUncheckedCreateWithoutLikesInput>
    connectOrCreate?: FbUserCreateOrConnectWithoutLikesInput
    upsert?: FbUserUpsertWithoutLikesInput
    connect?: FbUserWhereUniqueInput
    update?: XOR<FbUserUpdateWithoutLikesInput, FbUserUncheckedUpdateWithoutLikesInput>
  }

  export type FbPostUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<FbPostCreateWithoutLikesInput, FbPostUncheckedCreateWithoutLikesInput>
    connectOrCreate?: FbPostCreateOrConnectWithoutLikesInput
    upsert?: FbPostUpsertWithoutLikesInput
    connect?: FbPostWhereUniqueInput
    update?: XOR<FbPostUpdateWithoutLikesInput, FbPostUncheckedUpdateWithoutLikesInput>
  }

  export type FbCommentUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<FbCommentCreateWithoutLikesInput, FbCommentUncheckedCreateWithoutLikesInput>
    connectOrCreate?: FbCommentCreateOrConnectWithoutLikesInput
    upsert?: FbCommentUpsertWithoutLikesInput
    connect?: FbCommentWhereUniqueInput
    update?: XOR<FbCommentUpdateWithoutLikesInput, FbCommentUncheckedUpdateWithoutLikesInput>
  }

  export type FbShareUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<FbShareCreateWithoutLikesInput, FbShareUncheckedCreateWithoutLikesInput>
    connectOrCreate?: FbShareCreateOrConnectWithoutLikesInput
    upsert?: FbShareUpsertWithoutLikesInput
    connect?: FbShareWhereUniqueInput
    update?: XOR<FbShareUpdateWithoutLikesInput, FbShareUncheckedUpdateWithoutLikesInput>
  }

  export type FbUserCreateNestedOneWithoutSharesInput = {
    create?: XOR<FbUserCreateWithoutSharesInput, FbUserUncheckedCreateWithoutSharesInput>
    connectOrCreate?: FbUserCreateOrConnectWithoutSharesInput
    connect?: FbUserWhereUniqueInput
  }

  export type FbPostCreateNestedOneWithoutSharesInput = {
    create?: XOR<FbPostCreateWithoutSharesInput, FbPostUncheckedCreateWithoutSharesInput>
    connectOrCreate?: FbPostCreateOrConnectWithoutSharesInput
    connect?: FbPostWhereUniqueInput
  }

  export type FbLikeCreateNestedManyWithoutShareInput = {
    create?: XOR<Enumerable<FbLikeCreateWithoutShareInput>, Enumerable<FbLikeUncheckedCreateWithoutShareInput>>
    connectOrCreate?: Enumerable<FbLikeCreateOrConnectWithoutShareInput>
    createMany?: FbLikeCreateManyShareInputEnvelope
    connect?: Enumerable<FbLikeWhereUniqueInput>
  }

  export type FbDestinationUserCreateNestedManyWithoutShareInput = {
    create?: XOR<Enumerable<FbDestinationUserCreateWithoutShareInput>, Enumerable<FbDestinationUserUncheckedCreateWithoutShareInput>>
    connectOrCreate?: Enumerable<FbDestinationUserCreateOrConnectWithoutShareInput>
    createMany?: FbDestinationUserCreateManyShareInputEnvelope
    connect?: Enumerable<FbDestinationUserWhereUniqueInput>
  }

  export type FbLikeUncheckedCreateNestedManyWithoutShareInput = {
    create?: XOR<Enumerable<FbLikeCreateWithoutShareInput>, Enumerable<FbLikeUncheckedCreateWithoutShareInput>>
    connectOrCreate?: Enumerable<FbLikeCreateOrConnectWithoutShareInput>
    createMany?: FbLikeCreateManyShareInputEnvelope
    connect?: Enumerable<FbLikeWhereUniqueInput>
  }

  export type FbDestinationUserUncheckedCreateNestedManyWithoutShareInput = {
    create?: XOR<Enumerable<FbDestinationUserCreateWithoutShareInput>, Enumerable<FbDestinationUserUncheckedCreateWithoutShareInput>>
    connectOrCreate?: Enumerable<FbDestinationUserCreateOrConnectWithoutShareInput>
    createMany?: FbDestinationUserCreateManyShareInputEnvelope
    connect?: Enumerable<FbDestinationUserWhereUniqueInput>
  }

  export type FbUserUpdateOneRequiredWithoutSharesNestedInput = {
    create?: XOR<FbUserCreateWithoutSharesInput, FbUserUncheckedCreateWithoutSharesInput>
    connectOrCreate?: FbUserCreateOrConnectWithoutSharesInput
    upsert?: FbUserUpsertWithoutSharesInput
    connect?: FbUserWhereUniqueInput
    update?: XOR<FbUserUpdateWithoutSharesInput, FbUserUncheckedUpdateWithoutSharesInput>
  }

  export type FbPostUpdateOneRequiredWithoutSharesNestedInput = {
    create?: XOR<FbPostCreateWithoutSharesInput, FbPostUncheckedCreateWithoutSharesInput>
    connectOrCreate?: FbPostCreateOrConnectWithoutSharesInput
    upsert?: FbPostUpsertWithoutSharesInput
    connect?: FbPostWhereUniqueInput
    update?: XOR<FbPostUpdateWithoutSharesInput, FbPostUncheckedUpdateWithoutSharesInput>
  }

  export type FbLikeUpdateManyWithoutShareNestedInput = {
    create?: XOR<Enumerable<FbLikeCreateWithoutShareInput>, Enumerable<FbLikeUncheckedCreateWithoutShareInput>>
    connectOrCreate?: Enumerable<FbLikeCreateOrConnectWithoutShareInput>
    upsert?: Enumerable<FbLikeUpsertWithWhereUniqueWithoutShareInput>
    createMany?: FbLikeCreateManyShareInputEnvelope
    set?: Enumerable<FbLikeWhereUniqueInput>
    disconnect?: Enumerable<FbLikeWhereUniqueInput>
    delete?: Enumerable<FbLikeWhereUniqueInput>
    connect?: Enumerable<FbLikeWhereUniqueInput>
    update?: Enumerable<FbLikeUpdateWithWhereUniqueWithoutShareInput>
    updateMany?: Enumerable<FbLikeUpdateManyWithWhereWithoutShareInput>
    deleteMany?: Enumerable<FbLikeScalarWhereInput>
  }

  export type FbDestinationUserUpdateManyWithoutShareNestedInput = {
    create?: XOR<Enumerable<FbDestinationUserCreateWithoutShareInput>, Enumerable<FbDestinationUserUncheckedCreateWithoutShareInput>>
    connectOrCreate?: Enumerable<FbDestinationUserCreateOrConnectWithoutShareInput>
    upsert?: Enumerable<FbDestinationUserUpsertWithWhereUniqueWithoutShareInput>
    createMany?: FbDestinationUserCreateManyShareInputEnvelope
    set?: Enumerable<FbDestinationUserWhereUniqueInput>
    disconnect?: Enumerable<FbDestinationUserWhereUniqueInput>
    delete?: Enumerable<FbDestinationUserWhereUniqueInput>
    connect?: Enumerable<FbDestinationUserWhereUniqueInput>
    update?: Enumerable<FbDestinationUserUpdateWithWhereUniqueWithoutShareInput>
    updateMany?: Enumerable<FbDestinationUserUpdateManyWithWhereWithoutShareInput>
    deleteMany?: Enumerable<FbDestinationUserScalarWhereInput>
  }

  export type FbLikeUncheckedUpdateManyWithoutShareNestedInput = {
    create?: XOR<Enumerable<FbLikeCreateWithoutShareInput>, Enumerable<FbLikeUncheckedCreateWithoutShareInput>>
    connectOrCreate?: Enumerable<FbLikeCreateOrConnectWithoutShareInput>
    upsert?: Enumerable<FbLikeUpsertWithWhereUniqueWithoutShareInput>
    createMany?: FbLikeCreateManyShareInputEnvelope
    set?: Enumerable<FbLikeWhereUniqueInput>
    disconnect?: Enumerable<FbLikeWhereUniqueInput>
    delete?: Enumerable<FbLikeWhereUniqueInput>
    connect?: Enumerable<FbLikeWhereUniqueInput>
    update?: Enumerable<FbLikeUpdateWithWhereUniqueWithoutShareInput>
    updateMany?: Enumerable<FbLikeUpdateManyWithWhereWithoutShareInput>
    deleteMany?: Enumerable<FbLikeScalarWhereInput>
  }

  export type FbDestinationUserUncheckedUpdateManyWithoutShareNestedInput = {
    create?: XOR<Enumerable<FbDestinationUserCreateWithoutShareInput>, Enumerable<FbDestinationUserUncheckedCreateWithoutShareInput>>
    connectOrCreate?: Enumerable<FbDestinationUserCreateOrConnectWithoutShareInput>
    upsert?: Enumerable<FbDestinationUserUpsertWithWhereUniqueWithoutShareInput>
    createMany?: FbDestinationUserCreateManyShareInputEnvelope
    set?: Enumerable<FbDestinationUserWhereUniqueInput>
    disconnect?: Enumerable<FbDestinationUserWhereUniqueInput>
    delete?: Enumerable<FbDestinationUserWhereUniqueInput>
    connect?: Enumerable<FbDestinationUserWhereUniqueInput>
    update?: Enumerable<FbDestinationUserUpdateWithWhereUniqueWithoutShareInput>
    updateMany?: Enumerable<FbDestinationUserUpdateManyWithWhereWithoutShareInput>
    deleteMany?: Enumerable<FbDestinationUserScalarWhereInput>
  }

  export type FbUserCreateNestedOneWithoutAcceptFbFriendsInput = {
    create?: XOR<FbUserCreateWithoutAcceptFbFriendsInput, FbUserUncheckedCreateWithoutAcceptFbFriendsInput>
    connectOrCreate?: FbUserCreateOrConnectWithoutAcceptFbFriendsInput
    connect?: FbUserWhereUniqueInput
  }

  export type FbUserCreateNestedOneWithoutRequestFbFriendsInput = {
    create?: XOR<FbUserCreateWithoutRequestFbFriendsInput, FbUserUncheckedCreateWithoutRequestFbFriendsInput>
    connectOrCreate?: FbUserCreateOrConnectWithoutRequestFbFriendsInput
    connect?: FbUserWhereUniqueInput
  }

  export type FbUserUpdateOneRequiredWithoutAcceptFbFriendsNestedInput = {
    create?: XOR<FbUserCreateWithoutAcceptFbFriendsInput, FbUserUncheckedCreateWithoutAcceptFbFriendsInput>
    connectOrCreate?: FbUserCreateOrConnectWithoutAcceptFbFriendsInput
    upsert?: FbUserUpsertWithoutAcceptFbFriendsInput
    connect?: FbUserWhereUniqueInput
    update?: XOR<FbUserUpdateWithoutAcceptFbFriendsInput, FbUserUncheckedUpdateWithoutAcceptFbFriendsInput>
  }

  export type FbUserUpdateOneRequiredWithoutRequestFbFriendsNestedInput = {
    create?: XOR<FbUserCreateWithoutRequestFbFriendsInput, FbUserUncheckedCreateWithoutRequestFbFriendsInput>
    connectOrCreate?: FbUserCreateOrConnectWithoutRequestFbFriendsInput
    upsert?: FbUserUpsertWithoutRequestFbFriendsInput
    connect?: FbUserWhereUniqueInput
    update?: XOR<FbUserUpdateWithoutRequestFbFriendsInput, FbUserUncheckedUpdateWithoutRequestFbFriendsInput>
  }

  export type FbUserCreateNestedOneWithoutFromMessengersInput = {
    create?: XOR<FbUserCreateWithoutFromMessengersInput, FbUserUncheckedCreateWithoutFromMessengersInput>
    connectOrCreate?: FbUserCreateOrConnectWithoutFromMessengersInput
    connect?: FbUserWhereUniqueInput
  }

  export type FbUserCreateNestedOneWithoutToMessengersInput = {
    create?: XOR<FbUserCreateWithoutToMessengersInput, FbUserUncheckedCreateWithoutToMessengersInput>
    connectOrCreate?: FbUserCreateOrConnectWithoutToMessengersInput
    connect?: FbUserWhereUniqueInput
  }

  export type FbUserUpdateOneRequiredWithoutFromMessengersNestedInput = {
    create?: XOR<FbUserCreateWithoutFromMessengersInput, FbUserUncheckedCreateWithoutFromMessengersInput>
    connectOrCreate?: FbUserCreateOrConnectWithoutFromMessengersInput
    upsert?: FbUserUpsertWithoutFromMessengersInput
    connect?: FbUserWhereUniqueInput
    update?: XOR<FbUserUpdateWithoutFromMessengersInput, FbUserUncheckedUpdateWithoutFromMessengersInput>
  }

  export type FbUserUpdateOneRequiredWithoutToMessengersNestedInput = {
    create?: XOR<FbUserCreateWithoutToMessengersInput, FbUserUncheckedCreateWithoutToMessengersInput>
    connectOrCreate?: FbUserCreateOrConnectWithoutToMessengersInput
    upsert?: FbUserUpsertWithoutToMessengersInput
    connect?: FbUserWhereUniqueInput
    update?: XOR<FbUserUpdateWithoutToMessengersInput, FbUserUncheckedUpdateWithoutToMessengersInput>
  }

  export type FbUserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<FbUserCreateWithoutCommentsInput, FbUserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: FbUserCreateOrConnectWithoutCommentsInput
    connect?: FbUserWhereUniqueInput
  }

  export type FbLikeCreateNestedManyWithoutCommentInput = {
    create?: XOR<Enumerable<FbLikeCreateWithoutCommentInput>, Enumerable<FbLikeUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<FbLikeCreateOrConnectWithoutCommentInput>
    createMany?: FbLikeCreateManyCommentInputEnvelope
    connect?: Enumerable<FbLikeWhereUniqueInput>
  }

  export type FbLikeUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<Enumerable<FbLikeCreateWithoutCommentInput>, Enumerable<FbLikeUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<FbLikeCreateOrConnectWithoutCommentInput>
    createMany?: FbLikeCreateManyCommentInputEnvelope
    connect?: Enumerable<FbLikeWhereUniqueInput>
  }

  export type FbUserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<FbUserCreateWithoutCommentsInput, FbUserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: FbUserCreateOrConnectWithoutCommentsInput
    upsert?: FbUserUpsertWithoutCommentsInput
    connect?: FbUserWhereUniqueInput
    update?: XOR<FbUserUpdateWithoutCommentsInput, FbUserUncheckedUpdateWithoutCommentsInput>
  }

  export type FbLikeUpdateManyWithoutCommentNestedInput = {
    create?: XOR<Enumerable<FbLikeCreateWithoutCommentInput>, Enumerable<FbLikeUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<FbLikeCreateOrConnectWithoutCommentInput>
    upsert?: Enumerable<FbLikeUpsertWithWhereUniqueWithoutCommentInput>
    createMany?: FbLikeCreateManyCommentInputEnvelope
    set?: Enumerable<FbLikeWhereUniqueInput>
    disconnect?: Enumerable<FbLikeWhereUniqueInput>
    delete?: Enumerable<FbLikeWhereUniqueInput>
    connect?: Enumerable<FbLikeWhereUniqueInput>
    update?: Enumerable<FbLikeUpdateWithWhereUniqueWithoutCommentInput>
    updateMany?: Enumerable<FbLikeUpdateManyWithWhereWithoutCommentInput>
    deleteMany?: Enumerable<FbLikeScalarWhereInput>
  }

  export type FbLikeUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<Enumerable<FbLikeCreateWithoutCommentInput>, Enumerable<FbLikeUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<FbLikeCreateOrConnectWithoutCommentInput>
    upsert?: Enumerable<FbLikeUpsertWithWhereUniqueWithoutCommentInput>
    createMany?: FbLikeCreateManyCommentInputEnvelope
    set?: Enumerable<FbLikeWhereUniqueInput>
    disconnect?: Enumerable<FbLikeWhereUniqueInput>
    delete?: Enumerable<FbLikeWhereUniqueInput>
    connect?: Enumerable<FbLikeWhereUniqueInput>
    update?: Enumerable<FbLikeUpdateWithWhereUniqueWithoutCommentInput>
    updateMany?: Enumerable<FbLikeUpdateManyWithWhereWithoutCommentInput>
    deleteMany?: Enumerable<FbLikeScalarWhereInput>
  }

  export type GroupToUserCreateNestedManyWithoutGroupInput = {
    create?: XOR<Enumerable<GroupToUserCreateWithoutGroupInput>, Enumerable<GroupToUserUncheckedCreateWithoutGroupInput>>
    connectOrCreate?: Enumerable<GroupToUserCreateOrConnectWithoutGroupInput>
    createMany?: GroupToUserCreateManyGroupInputEnvelope
    connect?: Enumerable<GroupToUserWhereUniqueInput>
  }

  export type FbDestinationUserCreateNestedManyWithoutGroupInput = {
    create?: XOR<Enumerable<FbDestinationUserCreateWithoutGroupInput>, Enumerable<FbDestinationUserUncheckedCreateWithoutGroupInput>>
    connectOrCreate?: Enumerable<FbDestinationUserCreateOrConnectWithoutGroupInput>
    createMany?: FbDestinationUserCreateManyGroupInputEnvelope
    connect?: Enumerable<FbDestinationUserWhereUniqueInput>
  }

  export type GroupToUserUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<Enumerable<GroupToUserCreateWithoutGroupInput>, Enumerable<GroupToUserUncheckedCreateWithoutGroupInput>>
    connectOrCreate?: Enumerable<GroupToUserCreateOrConnectWithoutGroupInput>
    createMany?: GroupToUserCreateManyGroupInputEnvelope
    connect?: Enumerable<GroupToUserWhereUniqueInput>
  }

  export type FbDestinationUserUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<Enumerable<FbDestinationUserCreateWithoutGroupInput>, Enumerable<FbDestinationUserUncheckedCreateWithoutGroupInput>>
    connectOrCreate?: Enumerable<FbDestinationUserCreateOrConnectWithoutGroupInput>
    createMany?: FbDestinationUserCreateManyGroupInputEnvelope
    connect?: Enumerable<FbDestinationUserWhereUniqueInput>
  }

  export type GroupToUserUpdateManyWithoutGroupNestedInput = {
    create?: XOR<Enumerable<GroupToUserCreateWithoutGroupInput>, Enumerable<GroupToUserUncheckedCreateWithoutGroupInput>>
    connectOrCreate?: Enumerable<GroupToUserCreateOrConnectWithoutGroupInput>
    upsert?: Enumerable<GroupToUserUpsertWithWhereUniqueWithoutGroupInput>
    createMany?: GroupToUserCreateManyGroupInputEnvelope
    set?: Enumerable<GroupToUserWhereUniqueInput>
    disconnect?: Enumerable<GroupToUserWhereUniqueInput>
    delete?: Enumerable<GroupToUserWhereUniqueInput>
    connect?: Enumerable<GroupToUserWhereUniqueInput>
    update?: Enumerable<GroupToUserUpdateWithWhereUniqueWithoutGroupInput>
    updateMany?: Enumerable<GroupToUserUpdateManyWithWhereWithoutGroupInput>
    deleteMany?: Enumerable<GroupToUserScalarWhereInput>
  }

  export type FbDestinationUserUpdateManyWithoutGroupNestedInput = {
    create?: XOR<Enumerable<FbDestinationUserCreateWithoutGroupInput>, Enumerable<FbDestinationUserUncheckedCreateWithoutGroupInput>>
    connectOrCreate?: Enumerable<FbDestinationUserCreateOrConnectWithoutGroupInput>
    upsert?: Enumerable<FbDestinationUserUpsertWithWhereUniqueWithoutGroupInput>
    createMany?: FbDestinationUserCreateManyGroupInputEnvelope
    set?: Enumerable<FbDestinationUserWhereUniqueInput>
    disconnect?: Enumerable<FbDestinationUserWhereUniqueInput>
    delete?: Enumerable<FbDestinationUserWhereUniqueInput>
    connect?: Enumerable<FbDestinationUserWhereUniqueInput>
    update?: Enumerable<FbDestinationUserUpdateWithWhereUniqueWithoutGroupInput>
    updateMany?: Enumerable<FbDestinationUserUpdateManyWithWhereWithoutGroupInput>
    deleteMany?: Enumerable<FbDestinationUserScalarWhereInput>
  }

  export type GroupToUserUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<Enumerable<GroupToUserCreateWithoutGroupInput>, Enumerable<GroupToUserUncheckedCreateWithoutGroupInput>>
    connectOrCreate?: Enumerable<GroupToUserCreateOrConnectWithoutGroupInput>
    upsert?: Enumerable<GroupToUserUpsertWithWhereUniqueWithoutGroupInput>
    createMany?: GroupToUserCreateManyGroupInputEnvelope
    set?: Enumerable<GroupToUserWhereUniqueInput>
    disconnect?: Enumerable<GroupToUserWhereUniqueInput>
    delete?: Enumerable<GroupToUserWhereUniqueInput>
    connect?: Enumerable<GroupToUserWhereUniqueInput>
    update?: Enumerable<GroupToUserUpdateWithWhereUniqueWithoutGroupInput>
    updateMany?: Enumerable<GroupToUserUpdateManyWithWhereWithoutGroupInput>
    deleteMany?: Enumerable<GroupToUserScalarWhereInput>
  }

  export type FbDestinationUserUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<Enumerable<FbDestinationUserCreateWithoutGroupInput>, Enumerable<FbDestinationUserUncheckedCreateWithoutGroupInput>>
    connectOrCreate?: Enumerable<FbDestinationUserCreateOrConnectWithoutGroupInput>
    upsert?: Enumerable<FbDestinationUserUpsertWithWhereUniqueWithoutGroupInput>
    createMany?: FbDestinationUserCreateManyGroupInputEnvelope
    set?: Enumerable<FbDestinationUserWhereUniqueInput>
    disconnect?: Enumerable<FbDestinationUserWhereUniqueInput>
    delete?: Enumerable<FbDestinationUserWhereUniqueInput>
    connect?: Enumerable<FbDestinationUserWhereUniqueInput>
    update?: Enumerable<FbDestinationUserUpdateWithWhereUniqueWithoutGroupInput>
    updateMany?: Enumerable<FbDestinationUserUpdateManyWithWhereWithoutGroupInput>
    deleteMany?: Enumerable<FbDestinationUserScalarWhereInput>
  }

  export type FbUserCreateNestedOneWithoutGroupToUsersInput = {
    create?: XOR<FbUserCreateWithoutGroupToUsersInput, FbUserUncheckedCreateWithoutGroupToUsersInput>
    connectOrCreate?: FbUserCreateOrConnectWithoutGroupToUsersInput
    connect?: FbUserWhereUniqueInput
  }

  export type FbGroupCreateNestedOneWithoutGroupToUsersInput = {
    create?: XOR<FbGroupCreateWithoutGroupToUsersInput, FbGroupUncheckedCreateWithoutGroupToUsersInput>
    connectOrCreate?: FbGroupCreateOrConnectWithoutGroupToUsersInput
    connect?: FbGroupWhereUniqueInput
  }

  export type FbUserUpdateOneRequiredWithoutGroupToUsersNestedInput = {
    create?: XOR<FbUserCreateWithoutGroupToUsersInput, FbUserUncheckedCreateWithoutGroupToUsersInput>
    connectOrCreate?: FbUserCreateOrConnectWithoutGroupToUsersInput
    upsert?: FbUserUpsertWithoutGroupToUsersInput
    connect?: FbUserWhereUniqueInput
    update?: XOR<FbUserUpdateWithoutGroupToUsersInput, FbUserUncheckedUpdateWithoutGroupToUsersInput>
  }

  export type FbGroupUpdateOneRequiredWithoutGroupToUsersNestedInput = {
    create?: XOR<FbGroupCreateWithoutGroupToUsersInput, FbGroupUncheckedCreateWithoutGroupToUsersInput>
    connectOrCreate?: FbGroupCreateOrConnectWithoutGroupToUsersInput
    upsert?: FbGroupUpsertWithoutGroupToUsersInput
    connect?: FbGroupWhereUniqueInput
    update?: XOR<FbGroupUpdateWithoutGroupToUsersInput, FbGroupUncheckedUpdateWithoutGroupToUsersInput>
  }

  export type FbPostCreateNestedManyWithoutWallInput = {
    create?: XOR<Enumerable<FbPostCreateWithoutWallInput>, Enumerable<FbPostUncheckedCreateWithoutWallInput>>
    connectOrCreate?: Enumerable<FbPostCreateOrConnectWithoutWallInput>
    createMany?: FbPostCreateManyWallInputEnvelope
    connect?: Enumerable<FbPostWhereUniqueInput>
  }

  export type FbDestinationUserCreateNestedManyWithoutWallInput = {
    create?: XOR<Enumerable<FbDestinationUserCreateWithoutWallInput>, Enumerable<FbDestinationUserUncheckedCreateWithoutWallInput>>
    connectOrCreate?: Enumerable<FbDestinationUserCreateOrConnectWithoutWallInput>
    createMany?: FbDestinationUserCreateManyWallInputEnvelope
    connect?: Enumerable<FbDestinationUserWhereUniqueInput>
  }

  export type FbPostUncheckedCreateNestedManyWithoutWallInput = {
    create?: XOR<Enumerable<FbPostCreateWithoutWallInput>, Enumerable<FbPostUncheckedCreateWithoutWallInput>>
    connectOrCreate?: Enumerable<FbPostCreateOrConnectWithoutWallInput>
    createMany?: FbPostCreateManyWallInputEnvelope
    connect?: Enumerable<FbPostWhereUniqueInput>
  }

  export type FbDestinationUserUncheckedCreateNestedManyWithoutWallInput = {
    create?: XOR<Enumerable<FbDestinationUserCreateWithoutWallInput>, Enumerable<FbDestinationUserUncheckedCreateWithoutWallInput>>
    connectOrCreate?: Enumerable<FbDestinationUserCreateOrConnectWithoutWallInput>
    createMany?: FbDestinationUserCreateManyWallInputEnvelope
    connect?: Enumerable<FbDestinationUserWhereUniqueInput>
  }

  export type FbPostUpdateManyWithoutWallNestedInput = {
    create?: XOR<Enumerable<FbPostCreateWithoutWallInput>, Enumerable<FbPostUncheckedCreateWithoutWallInput>>
    connectOrCreate?: Enumerable<FbPostCreateOrConnectWithoutWallInput>
    upsert?: Enumerable<FbPostUpsertWithWhereUniqueWithoutWallInput>
    createMany?: FbPostCreateManyWallInputEnvelope
    set?: Enumerable<FbPostWhereUniqueInput>
    disconnect?: Enumerable<FbPostWhereUniqueInput>
    delete?: Enumerable<FbPostWhereUniqueInput>
    connect?: Enumerable<FbPostWhereUniqueInput>
    update?: Enumerable<FbPostUpdateWithWhereUniqueWithoutWallInput>
    updateMany?: Enumerable<FbPostUpdateManyWithWhereWithoutWallInput>
    deleteMany?: Enumerable<FbPostScalarWhereInput>
  }

  export type FbDestinationUserUpdateManyWithoutWallNestedInput = {
    create?: XOR<Enumerable<FbDestinationUserCreateWithoutWallInput>, Enumerable<FbDestinationUserUncheckedCreateWithoutWallInput>>
    connectOrCreate?: Enumerable<FbDestinationUserCreateOrConnectWithoutWallInput>
    upsert?: Enumerable<FbDestinationUserUpsertWithWhereUniqueWithoutWallInput>
    createMany?: FbDestinationUserCreateManyWallInputEnvelope
    set?: Enumerable<FbDestinationUserWhereUniqueInput>
    disconnect?: Enumerable<FbDestinationUserWhereUniqueInput>
    delete?: Enumerable<FbDestinationUserWhereUniqueInput>
    connect?: Enumerable<FbDestinationUserWhereUniqueInput>
    update?: Enumerable<FbDestinationUserUpdateWithWhereUniqueWithoutWallInput>
    updateMany?: Enumerable<FbDestinationUserUpdateManyWithWhereWithoutWallInput>
    deleteMany?: Enumerable<FbDestinationUserScalarWhereInput>
  }

  export type FbPostUncheckedUpdateManyWithoutWallNestedInput = {
    create?: XOR<Enumerable<FbPostCreateWithoutWallInput>, Enumerable<FbPostUncheckedCreateWithoutWallInput>>
    connectOrCreate?: Enumerable<FbPostCreateOrConnectWithoutWallInput>
    upsert?: Enumerable<FbPostUpsertWithWhereUniqueWithoutWallInput>
    createMany?: FbPostCreateManyWallInputEnvelope
    set?: Enumerable<FbPostWhereUniqueInput>
    disconnect?: Enumerable<FbPostWhereUniqueInput>
    delete?: Enumerable<FbPostWhereUniqueInput>
    connect?: Enumerable<FbPostWhereUniqueInput>
    update?: Enumerable<FbPostUpdateWithWhereUniqueWithoutWallInput>
    updateMany?: Enumerable<FbPostUpdateManyWithWhereWithoutWallInput>
    deleteMany?: Enumerable<FbPostScalarWhereInput>
  }

  export type FbDestinationUserUncheckedUpdateManyWithoutWallNestedInput = {
    create?: XOR<Enumerable<FbDestinationUserCreateWithoutWallInput>, Enumerable<FbDestinationUserUncheckedCreateWithoutWallInput>>
    connectOrCreate?: Enumerable<FbDestinationUserCreateOrConnectWithoutWallInput>
    upsert?: Enumerable<FbDestinationUserUpsertWithWhereUniqueWithoutWallInput>
    createMany?: FbDestinationUserCreateManyWallInputEnvelope
    set?: Enumerable<FbDestinationUserWhereUniqueInput>
    disconnect?: Enumerable<FbDestinationUserWhereUniqueInput>
    delete?: Enumerable<FbDestinationUserWhereUniqueInput>
    connect?: Enumerable<FbDestinationUserWhereUniqueInput>
    update?: Enumerable<FbDestinationUserUpdateWithWhereUniqueWithoutWallInput>
    updateMany?: Enumerable<FbDestinationUserUpdateManyWithWhereWithoutWallInput>
    deleteMany?: Enumerable<FbDestinationUserScalarWhereInput>
  }

  export type FbWallCreateNestedOneWithoutDestinationUsersInput = {
    create?: XOR<FbWallCreateWithoutDestinationUsersInput, FbWallUncheckedCreateWithoutDestinationUsersInput>
    connectOrCreate?: FbWallCreateOrConnectWithoutDestinationUsersInput
    connect?: FbWallWhereUniqueInput
  }

  export type FbShareCreateNestedOneWithoutDestinationUsersInput = {
    create?: XOR<FbShareCreateWithoutDestinationUsersInput, FbShareUncheckedCreateWithoutDestinationUsersInput>
    connectOrCreate?: FbShareCreateOrConnectWithoutDestinationUsersInput
    connect?: FbShareWhereUniqueInput
  }

  export type FbGroupCreateNestedOneWithoutDestinationUsersInput = {
    create?: XOR<FbGroupCreateWithoutDestinationUsersInput, FbGroupUncheckedCreateWithoutDestinationUsersInput>
    connectOrCreate?: FbGroupCreateOrConnectWithoutDestinationUsersInput
    connect?: FbGroupWhereUniqueInput
  }

  export type FbWallUpdateOneRequiredWithoutDestinationUsersNestedInput = {
    create?: XOR<FbWallCreateWithoutDestinationUsersInput, FbWallUncheckedCreateWithoutDestinationUsersInput>
    connectOrCreate?: FbWallCreateOrConnectWithoutDestinationUsersInput
    upsert?: FbWallUpsertWithoutDestinationUsersInput
    connect?: FbWallWhereUniqueInput
    update?: XOR<FbWallUpdateWithoutDestinationUsersInput, FbWallUncheckedUpdateWithoutDestinationUsersInput>
  }

  export type FbShareUpdateOneRequiredWithoutDestinationUsersNestedInput = {
    create?: XOR<FbShareCreateWithoutDestinationUsersInput, FbShareUncheckedCreateWithoutDestinationUsersInput>
    connectOrCreate?: FbShareCreateOrConnectWithoutDestinationUsersInput
    upsert?: FbShareUpsertWithoutDestinationUsersInput
    connect?: FbShareWhereUniqueInput
    update?: XOR<FbShareUpdateWithoutDestinationUsersInput, FbShareUncheckedUpdateWithoutDestinationUsersInput>
  }

  export type FbGroupUpdateOneRequiredWithoutDestinationUsersNestedInput = {
    create?: XOR<FbGroupCreateWithoutDestinationUsersInput, FbGroupUncheckedCreateWithoutDestinationUsersInput>
    connectOrCreate?: FbGroupCreateOrConnectWithoutDestinationUsersInput
    upsert?: FbGroupUpsertWithoutDestinationUsersInput
    connect?: FbGroupWhereUniqueInput
    update?: XOR<FbGroupUpdateWithoutDestinationUsersInput, FbGroupUncheckedUpdateWithoutDestinationUsersInput>
  }

  export type KorKitchenMenuCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<KorKitchenMenuCreateWithoutCategoryInput>, Enumerable<KorKitchenMenuUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<KorKitchenMenuCreateOrConnectWithoutCategoryInput>
    createMany?: KorKitchenMenuCreateManyCategoryInputEnvelope
    connect?: Enumerable<KorKitchenMenuWhereUniqueInput>
  }

  export type KorKitchenMenuUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<KorKitchenMenuCreateWithoutCategoryInput>, Enumerable<KorKitchenMenuUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<KorKitchenMenuCreateOrConnectWithoutCategoryInput>
    createMany?: KorKitchenMenuCreateManyCategoryInputEnvelope
    connect?: Enumerable<KorKitchenMenuWhereUniqueInput>
  }

  export type KorKitchenMenuUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<KorKitchenMenuCreateWithoutCategoryInput>, Enumerable<KorKitchenMenuUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<KorKitchenMenuCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<KorKitchenMenuUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: KorKitchenMenuCreateManyCategoryInputEnvelope
    set?: Enumerable<KorKitchenMenuWhereUniqueInput>
    disconnect?: Enumerable<KorKitchenMenuWhereUniqueInput>
    delete?: Enumerable<KorKitchenMenuWhereUniqueInput>
    connect?: Enumerable<KorKitchenMenuWhereUniqueInput>
    update?: Enumerable<KorKitchenMenuUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<KorKitchenMenuUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<KorKitchenMenuScalarWhereInput>
  }

  export type KorKitchenMenuUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<KorKitchenMenuCreateWithoutCategoryInput>, Enumerable<KorKitchenMenuUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<KorKitchenMenuCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<KorKitchenMenuUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: KorKitchenMenuCreateManyCategoryInputEnvelope
    set?: Enumerable<KorKitchenMenuWhereUniqueInput>
    disconnect?: Enumerable<KorKitchenMenuWhereUniqueInput>
    delete?: Enumerable<KorKitchenMenuWhereUniqueInput>
    connect?: Enumerable<KorKitchenMenuWhereUniqueInput>
    update?: Enumerable<KorKitchenMenuUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<KorKitchenMenuUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<KorKitchenMenuScalarWhereInput>
  }

  export type KorKitchenCategoryCreateNestedOneWithoutMenuInput = {
    create?: XOR<KorKitchenCategoryCreateWithoutMenuInput, KorKitchenCategoryUncheckedCreateWithoutMenuInput>
    connectOrCreate?: KorKitchenCategoryCreateOrConnectWithoutMenuInput
    connect?: KorKitchenCategoryWhereUniqueInput
  }

  export type KorKitchenOrderItemCreateNestedManyWithoutMenuInput = {
    create?: XOR<Enumerable<KorKitchenOrderItemCreateWithoutMenuInput>, Enumerable<KorKitchenOrderItemUncheckedCreateWithoutMenuInput>>
    connectOrCreate?: Enumerable<KorKitchenOrderItemCreateOrConnectWithoutMenuInput>
    createMany?: KorKitchenOrderItemCreateManyMenuInputEnvelope
    connect?: Enumerable<KorKitchenOrderItemWhereUniqueInput>
  }

  export type KorKitchenOrderItemUncheckedCreateNestedManyWithoutMenuInput = {
    create?: XOR<Enumerable<KorKitchenOrderItemCreateWithoutMenuInput>, Enumerable<KorKitchenOrderItemUncheckedCreateWithoutMenuInput>>
    connectOrCreate?: Enumerable<KorKitchenOrderItemCreateOrConnectWithoutMenuInput>
    createMany?: KorKitchenOrderItemCreateManyMenuInputEnvelope
    connect?: Enumerable<KorKitchenOrderItemWhereUniqueInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type KorKitchenCategoryUpdateOneWithoutMenuNestedInput = {
    create?: XOR<KorKitchenCategoryCreateWithoutMenuInput, KorKitchenCategoryUncheckedCreateWithoutMenuInput>
    connectOrCreate?: KorKitchenCategoryCreateOrConnectWithoutMenuInput
    upsert?: KorKitchenCategoryUpsertWithoutMenuInput
    disconnect?: boolean
    delete?: boolean
    connect?: KorKitchenCategoryWhereUniqueInput
    update?: XOR<KorKitchenCategoryUpdateWithoutMenuInput, KorKitchenCategoryUncheckedUpdateWithoutMenuInput>
  }

  export type KorKitchenOrderItemUpdateManyWithoutMenuNestedInput = {
    create?: XOR<Enumerable<KorKitchenOrderItemCreateWithoutMenuInput>, Enumerable<KorKitchenOrderItemUncheckedCreateWithoutMenuInput>>
    connectOrCreate?: Enumerable<KorKitchenOrderItemCreateOrConnectWithoutMenuInput>
    upsert?: Enumerable<KorKitchenOrderItemUpsertWithWhereUniqueWithoutMenuInput>
    createMany?: KorKitchenOrderItemCreateManyMenuInputEnvelope
    set?: Enumerable<KorKitchenOrderItemWhereUniqueInput>
    disconnect?: Enumerable<KorKitchenOrderItemWhereUniqueInput>
    delete?: Enumerable<KorKitchenOrderItemWhereUniqueInput>
    connect?: Enumerable<KorKitchenOrderItemWhereUniqueInput>
    update?: Enumerable<KorKitchenOrderItemUpdateWithWhereUniqueWithoutMenuInput>
    updateMany?: Enumerable<KorKitchenOrderItemUpdateManyWithWhereWithoutMenuInput>
    deleteMany?: Enumerable<KorKitchenOrderItemScalarWhereInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type KorKitchenOrderItemUncheckedUpdateManyWithoutMenuNestedInput = {
    create?: XOR<Enumerable<KorKitchenOrderItemCreateWithoutMenuInput>, Enumerable<KorKitchenOrderItemUncheckedCreateWithoutMenuInput>>
    connectOrCreate?: Enumerable<KorKitchenOrderItemCreateOrConnectWithoutMenuInput>
    upsert?: Enumerable<KorKitchenOrderItemUpsertWithWhereUniqueWithoutMenuInput>
    createMany?: KorKitchenOrderItemCreateManyMenuInputEnvelope
    set?: Enumerable<KorKitchenOrderItemWhereUniqueInput>
    disconnect?: Enumerable<KorKitchenOrderItemWhereUniqueInput>
    delete?: Enumerable<KorKitchenOrderItemWhereUniqueInput>
    connect?: Enumerable<KorKitchenOrderItemWhereUniqueInput>
    update?: Enumerable<KorKitchenOrderItemUpdateWithWhereUniqueWithoutMenuInput>
    updateMany?: Enumerable<KorKitchenOrderItemUpdateManyWithWhereWithoutMenuInput>
    deleteMany?: Enumerable<KorKitchenOrderItemScalarWhereInput>
  }

  export type KorKitchenOrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<Enumerable<KorKitchenOrderItemCreateWithoutOrderInput>, Enumerable<KorKitchenOrderItemUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<KorKitchenOrderItemCreateOrConnectWithoutOrderInput>
    createMany?: KorKitchenOrderItemCreateManyOrderInputEnvelope
    connect?: Enumerable<KorKitchenOrderItemWhereUniqueInput>
  }

  export type KorKitchenOrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<Enumerable<KorKitchenOrderItemCreateWithoutOrderInput>, Enumerable<KorKitchenOrderItemUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<KorKitchenOrderItemCreateOrConnectWithoutOrderInput>
    createMany?: KorKitchenOrderItemCreateManyOrderInputEnvelope
    connect?: Enumerable<KorKitchenOrderItemWhereUniqueInput>
  }

  export type KorKitchenOrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<Enumerable<KorKitchenOrderItemCreateWithoutOrderInput>, Enumerable<KorKitchenOrderItemUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<KorKitchenOrderItemCreateOrConnectWithoutOrderInput>
    upsert?: Enumerable<KorKitchenOrderItemUpsertWithWhereUniqueWithoutOrderInput>
    createMany?: KorKitchenOrderItemCreateManyOrderInputEnvelope
    set?: Enumerable<KorKitchenOrderItemWhereUniqueInput>
    disconnect?: Enumerable<KorKitchenOrderItemWhereUniqueInput>
    delete?: Enumerable<KorKitchenOrderItemWhereUniqueInput>
    connect?: Enumerable<KorKitchenOrderItemWhereUniqueInput>
    update?: Enumerable<KorKitchenOrderItemUpdateWithWhereUniqueWithoutOrderInput>
    updateMany?: Enumerable<KorKitchenOrderItemUpdateManyWithWhereWithoutOrderInput>
    deleteMany?: Enumerable<KorKitchenOrderItemScalarWhereInput>
  }

  export type KorKitchenOrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<Enumerable<KorKitchenOrderItemCreateWithoutOrderInput>, Enumerable<KorKitchenOrderItemUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<KorKitchenOrderItemCreateOrConnectWithoutOrderInput>
    upsert?: Enumerable<KorKitchenOrderItemUpsertWithWhereUniqueWithoutOrderInput>
    createMany?: KorKitchenOrderItemCreateManyOrderInputEnvelope
    set?: Enumerable<KorKitchenOrderItemWhereUniqueInput>
    disconnect?: Enumerable<KorKitchenOrderItemWhereUniqueInput>
    delete?: Enumerable<KorKitchenOrderItemWhereUniqueInput>
    connect?: Enumerable<KorKitchenOrderItemWhereUniqueInput>
    update?: Enumerable<KorKitchenOrderItemUpdateWithWhereUniqueWithoutOrderInput>
    updateMany?: Enumerable<KorKitchenOrderItemUpdateManyWithWhereWithoutOrderInput>
    deleteMany?: Enumerable<KorKitchenOrderItemScalarWhereInput>
  }

  export type KorKitchenMenuCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<KorKitchenMenuCreateWithoutOrderItemsInput, KorKitchenMenuUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: KorKitchenMenuCreateOrConnectWithoutOrderItemsInput
    connect?: KorKitchenMenuWhereUniqueInput
  }

  export type KorKitchenOrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<KorKitchenOrderCreateWithoutItemsInput, KorKitchenOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: KorKitchenOrderCreateOrConnectWithoutItemsInput
    connect?: KorKitchenOrderWhereUniqueInput
  }

  export type KorKitchenMenuUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<KorKitchenMenuCreateWithoutOrderItemsInput, KorKitchenMenuUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: KorKitchenMenuCreateOrConnectWithoutOrderItemsInput
    upsert?: KorKitchenMenuUpsertWithoutOrderItemsInput
    connect?: KorKitchenMenuWhereUniqueInput
    update?: XOR<KorKitchenMenuUpdateWithoutOrderItemsInput, KorKitchenMenuUncheckedUpdateWithoutOrderItemsInput>
  }

  export type KorKitchenOrderUpdateOneWithoutItemsNestedInput = {
    create?: XOR<KorKitchenOrderCreateWithoutItemsInput, KorKitchenOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: KorKitchenOrderCreateOrConnectWithoutItemsInput
    upsert?: KorKitchenOrderUpsertWithoutItemsInput
    disconnect?: boolean
    delete?: boolean
    connect?: KorKitchenOrderWhereUniqueInput
    update?: XOR<KorKitchenOrderUpdateWithoutItemsInput, KorKitchenOrderUncheckedUpdateWithoutItemsInput>
  }

  export type TriviaQuestionCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<TriviaQuestionCreateWithoutCategoryInput>, Enumerable<TriviaQuestionUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<TriviaQuestionCreateOrConnectWithoutCategoryInput>
    createMany?: TriviaQuestionCreateManyCategoryInputEnvelope
    connect?: Enumerable<TriviaQuestionWhereUniqueInput>
  }

  export type TriviaRoundCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<TriviaRoundCreateWithoutCategoryInput>, Enumerable<TriviaRoundUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<TriviaRoundCreateOrConnectWithoutCategoryInput>
    createMany?: TriviaRoundCreateManyCategoryInputEnvelope
    connect?: Enumerable<TriviaRoundWhereUniqueInput>
  }

  export type TriviaQuestionUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<TriviaQuestionCreateWithoutCategoryInput>, Enumerable<TriviaQuestionUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<TriviaQuestionCreateOrConnectWithoutCategoryInput>
    createMany?: TriviaQuestionCreateManyCategoryInputEnvelope
    connect?: Enumerable<TriviaQuestionWhereUniqueInput>
  }

  export type TriviaRoundUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<TriviaRoundCreateWithoutCategoryInput>, Enumerable<TriviaRoundUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<TriviaRoundCreateOrConnectWithoutCategoryInput>
    createMany?: TriviaRoundCreateManyCategoryInputEnvelope
    connect?: Enumerable<TriviaRoundWhereUniqueInput>
  }

  export type TriviaQuestionUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<TriviaQuestionCreateWithoutCategoryInput>, Enumerable<TriviaQuestionUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<TriviaQuestionCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<TriviaQuestionUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: TriviaQuestionCreateManyCategoryInputEnvelope
    set?: Enumerable<TriviaQuestionWhereUniqueInput>
    disconnect?: Enumerable<TriviaQuestionWhereUniqueInput>
    delete?: Enumerable<TriviaQuestionWhereUniqueInput>
    connect?: Enumerable<TriviaQuestionWhereUniqueInput>
    update?: Enumerable<TriviaQuestionUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<TriviaQuestionUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<TriviaQuestionScalarWhereInput>
  }

  export type TriviaRoundUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<TriviaRoundCreateWithoutCategoryInput>, Enumerable<TriviaRoundUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<TriviaRoundCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<TriviaRoundUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: TriviaRoundCreateManyCategoryInputEnvelope
    set?: Enumerable<TriviaRoundWhereUniqueInput>
    disconnect?: Enumerable<TriviaRoundWhereUniqueInput>
    delete?: Enumerable<TriviaRoundWhereUniqueInput>
    connect?: Enumerable<TriviaRoundWhereUniqueInput>
    update?: Enumerable<TriviaRoundUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<TriviaRoundUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<TriviaRoundScalarWhereInput>
  }

  export type TriviaQuestionUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<TriviaQuestionCreateWithoutCategoryInput>, Enumerable<TriviaQuestionUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<TriviaQuestionCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<TriviaQuestionUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: TriviaQuestionCreateManyCategoryInputEnvelope
    set?: Enumerable<TriviaQuestionWhereUniqueInput>
    disconnect?: Enumerable<TriviaQuestionWhereUniqueInput>
    delete?: Enumerable<TriviaQuestionWhereUniqueInput>
    connect?: Enumerable<TriviaQuestionWhereUniqueInput>
    update?: Enumerable<TriviaQuestionUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<TriviaQuestionUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<TriviaQuestionScalarWhereInput>
  }

  export type TriviaRoundUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<TriviaRoundCreateWithoutCategoryInput>, Enumerable<TriviaRoundUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<TriviaRoundCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<TriviaRoundUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: TriviaRoundCreateManyCategoryInputEnvelope
    set?: Enumerable<TriviaRoundWhereUniqueInput>
    disconnect?: Enumerable<TriviaRoundWhereUniqueInput>
    delete?: Enumerable<TriviaRoundWhereUniqueInput>
    connect?: Enumerable<TriviaRoundWhereUniqueInput>
    update?: Enumerable<TriviaRoundUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<TriviaRoundUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<TriviaRoundScalarWhereInput>
  }

  export type TriviaCategoryCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<TriviaCategoryCreateWithoutQuestionsInput, TriviaCategoryUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: TriviaCategoryCreateOrConnectWithoutQuestionsInput
    connect?: TriviaCategoryWhereUniqueInput
  }

  export type TriviaChoiceCreateNestedManyWithoutQuestionInput = {
    create?: XOR<Enumerable<TriviaChoiceCreateWithoutQuestionInput>, Enumerable<TriviaChoiceUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<TriviaChoiceCreateOrConnectWithoutQuestionInput>
    createMany?: TriviaChoiceCreateManyQuestionInputEnvelope
    connect?: Enumerable<TriviaChoiceWhereUniqueInput>
  }

  export type TriviaRoundQuestionCreateNestedManyWithoutQuestionInput = {
    create?: XOR<Enumerable<TriviaRoundQuestionCreateWithoutQuestionInput>, Enumerable<TriviaRoundQuestionUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<TriviaRoundQuestionCreateOrConnectWithoutQuestionInput>
    createMany?: TriviaRoundQuestionCreateManyQuestionInputEnvelope
    connect?: Enumerable<TriviaRoundQuestionWhereUniqueInput>
  }

  export type TriviaChoiceUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<Enumerable<TriviaChoiceCreateWithoutQuestionInput>, Enumerable<TriviaChoiceUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<TriviaChoiceCreateOrConnectWithoutQuestionInput>
    createMany?: TriviaChoiceCreateManyQuestionInputEnvelope
    connect?: Enumerable<TriviaChoiceWhereUniqueInput>
  }

  export type TriviaRoundQuestionUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<Enumerable<TriviaRoundQuestionCreateWithoutQuestionInput>, Enumerable<TriviaRoundQuestionUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<TriviaRoundQuestionCreateOrConnectWithoutQuestionInput>
    createMany?: TriviaRoundQuestionCreateManyQuestionInputEnvelope
    connect?: Enumerable<TriviaRoundQuestionWhereUniqueInput>
  }

  export type TriviaCategoryUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<TriviaCategoryCreateWithoutQuestionsInput, TriviaCategoryUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: TriviaCategoryCreateOrConnectWithoutQuestionsInput
    upsert?: TriviaCategoryUpsertWithoutQuestionsInput
    connect?: TriviaCategoryWhereUniqueInput
    update?: XOR<TriviaCategoryUpdateWithoutQuestionsInput, TriviaCategoryUncheckedUpdateWithoutQuestionsInput>
  }

  export type TriviaChoiceUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<Enumerable<TriviaChoiceCreateWithoutQuestionInput>, Enumerable<TriviaChoiceUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<TriviaChoiceCreateOrConnectWithoutQuestionInput>
    upsert?: Enumerable<TriviaChoiceUpsertWithWhereUniqueWithoutQuestionInput>
    createMany?: TriviaChoiceCreateManyQuestionInputEnvelope
    set?: Enumerable<TriviaChoiceWhereUniqueInput>
    disconnect?: Enumerable<TriviaChoiceWhereUniqueInput>
    delete?: Enumerable<TriviaChoiceWhereUniqueInput>
    connect?: Enumerable<TriviaChoiceWhereUniqueInput>
    update?: Enumerable<TriviaChoiceUpdateWithWhereUniqueWithoutQuestionInput>
    updateMany?: Enumerable<TriviaChoiceUpdateManyWithWhereWithoutQuestionInput>
    deleteMany?: Enumerable<TriviaChoiceScalarWhereInput>
  }

  export type TriviaRoundQuestionUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<Enumerable<TriviaRoundQuestionCreateWithoutQuestionInput>, Enumerable<TriviaRoundQuestionUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<TriviaRoundQuestionCreateOrConnectWithoutQuestionInput>
    upsert?: Enumerable<TriviaRoundQuestionUpsertWithWhereUniqueWithoutQuestionInput>
    createMany?: TriviaRoundQuestionCreateManyQuestionInputEnvelope
    set?: Enumerable<TriviaRoundQuestionWhereUniqueInput>
    disconnect?: Enumerable<TriviaRoundQuestionWhereUniqueInput>
    delete?: Enumerable<TriviaRoundQuestionWhereUniqueInput>
    connect?: Enumerable<TriviaRoundQuestionWhereUniqueInput>
    update?: Enumerable<TriviaRoundQuestionUpdateWithWhereUniqueWithoutQuestionInput>
    updateMany?: Enumerable<TriviaRoundQuestionUpdateManyWithWhereWithoutQuestionInput>
    deleteMany?: Enumerable<TriviaRoundQuestionScalarWhereInput>
  }

  export type TriviaChoiceUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<Enumerable<TriviaChoiceCreateWithoutQuestionInput>, Enumerable<TriviaChoiceUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<TriviaChoiceCreateOrConnectWithoutQuestionInput>
    upsert?: Enumerable<TriviaChoiceUpsertWithWhereUniqueWithoutQuestionInput>
    createMany?: TriviaChoiceCreateManyQuestionInputEnvelope
    set?: Enumerable<TriviaChoiceWhereUniqueInput>
    disconnect?: Enumerable<TriviaChoiceWhereUniqueInput>
    delete?: Enumerable<TriviaChoiceWhereUniqueInput>
    connect?: Enumerable<TriviaChoiceWhereUniqueInput>
    update?: Enumerable<TriviaChoiceUpdateWithWhereUniqueWithoutQuestionInput>
    updateMany?: Enumerable<TriviaChoiceUpdateManyWithWhereWithoutQuestionInput>
    deleteMany?: Enumerable<TriviaChoiceScalarWhereInput>
  }

  export type TriviaRoundQuestionUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<Enumerable<TriviaRoundQuestionCreateWithoutQuestionInput>, Enumerable<TriviaRoundQuestionUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<TriviaRoundQuestionCreateOrConnectWithoutQuestionInput>
    upsert?: Enumerable<TriviaRoundQuestionUpsertWithWhereUniqueWithoutQuestionInput>
    createMany?: TriviaRoundQuestionCreateManyQuestionInputEnvelope
    set?: Enumerable<TriviaRoundQuestionWhereUniqueInput>
    disconnect?: Enumerable<TriviaRoundQuestionWhereUniqueInput>
    delete?: Enumerable<TriviaRoundQuestionWhereUniqueInput>
    connect?: Enumerable<TriviaRoundQuestionWhereUniqueInput>
    update?: Enumerable<TriviaRoundQuestionUpdateWithWhereUniqueWithoutQuestionInput>
    updateMany?: Enumerable<TriviaRoundQuestionUpdateManyWithWhereWithoutQuestionInput>
    deleteMany?: Enumerable<TriviaRoundQuestionScalarWhereInput>
  }

  export type TriviaQuestionCreateNestedOneWithoutChoicesInput = {
    create?: XOR<TriviaQuestionCreateWithoutChoicesInput, TriviaQuestionUncheckedCreateWithoutChoicesInput>
    connectOrCreate?: TriviaQuestionCreateOrConnectWithoutChoicesInput
    connect?: TriviaQuestionWhereUniqueInput
  }

  export type TriviaRoundQuestionCreateNestedManyWithoutUserChoiceInput = {
    create?: XOR<Enumerable<TriviaRoundQuestionCreateWithoutUserChoiceInput>, Enumerable<TriviaRoundQuestionUncheckedCreateWithoutUserChoiceInput>>
    connectOrCreate?: Enumerable<TriviaRoundQuestionCreateOrConnectWithoutUserChoiceInput>
    createMany?: TriviaRoundQuestionCreateManyUserChoiceInputEnvelope
    connect?: Enumerable<TriviaRoundQuestionWhereUniqueInput>
  }

  export type TriviaRoundQuestionUncheckedCreateNestedManyWithoutUserChoiceInput = {
    create?: XOR<Enumerable<TriviaRoundQuestionCreateWithoutUserChoiceInput>, Enumerable<TriviaRoundQuestionUncheckedCreateWithoutUserChoiceInput>>
    connectOrCreate?: Enumerable<TriviaRoundQuestionCreateOrConnectWithoutUserChoiceInput>
    createMany?: TriviaRoundQuestionCreateManyUserChoiceInputEnvelope
    connect?: Enumerable<TriviaRoundQuestionWhereUniqueInput>
  }

  export type TriviaQuestionUpdateOneRequiredWithoutChoicesNestedInput = {
    create?: XOR<TriviaQuestionCreateWithoutChoicesInput, TriviaQuestionUncheckedCreateWithoutChoicesInput>
    connectOrCreate?: TriviaQuestionCreateOrConnectWithoutChoicesInput
    upsert?: TriviaQuestionUpsertWithoutChoicesInput
    connect?: TriviaQuestionWhereUniqueInput
    update?: XOR<TriviaQuestionUpdateWithoutChoicesInput, TriviaQuestionUncheckedUpdateWithoutChoicesInput>
  }

  export type TriviaRoundQuestionUpdateManyWithoutUserChoiceNestedInput = {
    create?: XOR<Enumerable<TriviaRoundQuestionCreateWithoutUserChoiceInput>, Enumerable<TriviaRoundQuestionUncheckedCreateWithoutUserChoiceInput>>
    connectOrCreate?: Enumerable<TriviaRoundQuestionCreateOrConnectWithoutUserChoiceInput>
    upsert?: Enumerable<TriviaRoundQuestionUpsertWithWhereUniqueWithoutUserChoiceInput>
    createMany?: TriviaRoundQuestionCreateManyUserChoiceInputEnvelope
    set?: Enumerable<TriviaRoundQuestionWhereUniqueInput>
    disconnect?: Enumerable<TriviaRoundQuestionWhereUniqueInput>
    delete?: Enumerable<TriviaRoundQuestionWhereUniqueInput>
    connect?: Enumerable<TriviaRoundQuestionWhereUniqueInput>
    update?: Enumerable<TriviaRoundQuestionUpdateWithWhereUniqueWithoutUserChoiceInput>
    updateMany?: Enumerable<TriviaRoundQuestionUpdateManyWithWhereWithoutUserChoiceInput>
    deleteMany?: Enumerable<TriviaRoundQuestionScalarWhereInput>
  }

  export type TriviaRoundQuestionUncheckedUpdateManyWithoutUserChoiceNestedInput = {
    create?: XOR<Enumerable<TriviaRoundQuestionCreateWithoutUserChoiceInput>, Enumerable<TriviaRoundQuestionUncheckedCreateWithoutUserChoiceInput>>
    connectOrCreate?: Enumerable<TriviaRoundQuestionCreateOrConnectWithoutUserChoiceInput>
    upsert?: Enumerable<TriviaRoundQuestionUpsertWithWhereUniqueWithoutUserChoiceInput>
    createMany?: TriviaRoundQuestionCreateManyUserChoiceInputEnvelope
    set?: Enumerable<TriviaRoundQuestionWhereUniqueInput>
    disconnect?: Enumerable<TriviaRoundQuestionWhereUniqueInput>
    delete?: Enumerable<TriviaRoundQuestionWhereUniqueInput>
    connect?: Enumerable<TriviaRoundQuestionWhereUniqueInput>
    update?: Enumerable<TriviaRoundQuestionUpdateWithWhereUniqueWithoutUserChoiceInput>
    updateMany?: Enumerable<TriviaRoundQuestionUpdateManyWithWhereWithoutUserChoiceInput>
    deleteMany?: Enumerable<TriviaRoundQuestionScalarWhereInput>
  }

  export type TriviaQuestionCreateNestedOneWithoutRoundQuestionsInput = {
    create?: XOR<TriviaQuestionCreateWithoutRoundQuestionsInput, TriviaQuestionUncheckedCreateWithoutRoundQuestionsInput>
    connectOrCreate?: TriviaQuestionCreateOrConnectWithoutRoundQuestionsInput
    connect?: TriviaQuestionWhereUniqueInput
  }

  export type TriviaChoiceCreateNestedOneWithoutRoundQuestionsInput = {
    create?: XOR<TriviaChoiceCreateWithoutRoundQuestionsInput, TriviaChoiceUncheckedCreateWithoutRoundQuestionsInput>
    connectOrCreate?: TriviaChoiceCreateOrConnectWithoutRoundQuestionsInput
    connect?: TriviaChoiceWhereUniqueInput
  }

  export type TriviaRoundCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<TriviaRoundCreateWithoutQuestionsInput, TriviaRoundUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: TriviaRoundCreateOrConnectWithoutQuestionsInput
    connect?: TriviaRoundWhereUniqueInput
  }

  export type TriviaQuestionUpdateOneRequiredWithoutRoundQuestionsNestedInput = {
    create?: XOR<TriviaQuestionCreateWithoutRoundQuestionsInput, TriviaQuestionUncheckedCreateWithoutRoundQuestionsInput>
    connectOrCreate?: TriviaQuestionCreateOrConnectWithoutRoundQuestionsInput
    upsert?: TriviaQuestionUpsertWithoutRoundQuestionsInput
    connect?: TriviaQuestionWhereUniqueInput
    update?: XOR<TriviaQuestionUpdateWithoutRoundQuestionsInput, TriviaQuestionUncheckedUpdateWithoutRoundQuestionsInput>
  }

  export type TriviaChoiceUpdateOneRequiredWithoutRoundQuestionsNestedInput = {
    create?: XOR<TriviaChoiceCreateWithoutRoundQuestionsInput, TriviaChoiceUncheckedCreateWithoutRoundQuestionsInput>
    connectOrCreate?: TriviaChoiceCreateOrConnectWithoutRoundQuestionsInput
    upsert?: TriviaChoiceUpsertWithoutRoundQuestionsInput
    connect?: TriviaChoiceWhereUniqueInput
    update?: XOR<TriviaChoiceUpdateWithoutRoundQuestionsInput, TriviaChoiceUncheckedUpdateWithoutRoundQuestionsInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type TriviaRoundUpdateOneWithoutQuestionsNestedInput = {
    create?: XOR<TriviaRoundCreateWithoutQuestionsInput, TriviaRoundUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: TriviaRoundCreateOrConnectWithoutQuestionsInput
    upsert?: TriviaRoundUpsertWithoutQuestionsInput
    disconnect?: boolean
    delete?: boolean
    connect?: TriviaRoundWhereUniqueInput
    update?: XOR<TriviaRoundUpdateWithoutQuestionsInput, TriviaRoundUncheckedUpdateWithoutQuestionsInput>
  }

  export type TriviaRoundQuestionCreateNestedManyWithoutRoundInput = {
    create?: XOR<Enumerable<TriviaRoundQuestionCreateWithoutRoundInput>, Enumerable<TriviaRoundQuestionUncheckedCreateWithoutRoundInput>>
    connectOrCreate?: Enumerable<TriviaRoundQuestionCreateOrConnectWithoutRoundInput>
    createMany?: TriviaRoundQuestionCreateManyRoundInputEnvelope
    connect?: Enumerable<TriviaRoundQuestionWhereUniqueInput>
  }

  export type TriviaCategoryCreateNestedOneWithoutRoundsInput = {
    create?: XOR<TriviaCategoryCreateWithoutRoundsInput, TriviaCategoryUncheckedCreateWithoutRoundsInput>
    connectOrCreate?: TriviaCategoryCreateOrConnectWithoutRoundsInput
    connect?: TriviaCategoryWhereUniqueInput
  }

  export type TriviaRoundQuestionUncheckedCreateNestedManyWithoutRoundInput = {
    create?: XOR<Enumerable<TriviaRoundQuestionCreateWithoutRoundInput>, Enumerable<TriviaRoundQuestionUncheckedCreateWithoutRoundInput>>
    connectOrCreate?: Enumerable<TriviaRoundQuestionCreateOrConnectWithoutRoundInput>
    createMany?: TriviaRoundQuestionCreateManyRoundInputEnvelope
    connect?: Enumerable<TriviaRoundQuestionWhereUniqueInput>
  }

  export type TriviaRoundQuestionUpdateManyWithoutRoundNestedInput = {
    create?: XOR<Enumerable<TriviaRoundQuestionCreateWithoutRoundInput>, Enumerable<TriviaRoundQuestionUncheckedCreateWithoutRoundInput>>
    connectOrCreate?: Enumerable<TriviaRoundQuestionCreateOrConnectWithoutRoundInput>
    upsert?: Enumerable<TriviaRoundQuestionUpsertWithWhereUniqueWithoutRoundInput>
    createMany?: TriviaRoundQuestionCreateManyRoundInputEnvelope
    set?: Enumerable<TriviaRoundQuestionWhereUniqueInput>
    disconnect?: Enumerable<TriviaRoundQuestionWhereUniqueInput>
    delete?: Enumerable<TriviaRoundQuestionWhereUniqueInput>
    connect?: Enumerable<TriviaRoundQuestionWhereUniqueInput>
    update?: Enumerable<TriviaRoundQuestionUpdateWithWhereUniqueWithoutRoundInput>
    updateMany?: Enumerable<TriviaRoundQuestionUpdateManyWithWhereWithoutRoundInput>
    deleteMany?: Enumerable<TriviaRoundQuestionScalarWhereInput>
  }

  export type TriviaCategoryUpdateOneRequiredWithoutRoundsNestedInput = {
    create?: XOR<TriviaCategoryCreateWithoutRoundsInput, TriviaCategoryUncheckedCreateWithoutRoundsInput>
    connectOrCreate?: TriviaCategoryCreateOrConnectWithoutRoundsInput
    upsert?: TriviaCategoryUpsertWithoutRoundsInput
    connect?: TriviaCategoryWhereUniqueInput
    update?: XOR<TriviaCategoryUpdateWithoutRoundsInput, TriviaCategoryUncheckedUpdateWithoutRoundsInput>
  }

  export type TriviaRoundQuestionUncheckedUpdateManyWithoutRoundNestedInput = {
    create?: XOR<Enumerable<TriviaRoundQuestionCreateWithoutRoundInput>, Enumerable<TriviaRoundQuestionUncheckedCreateWithoutRoundInput>>
    connectOrCreate?: Enumerable<TriviaRoundQuestionCreateOrConnectWithoutRoundInput>
    upsert?: Enumerable<TriviaRoundQuestionUpsertWithWhereUniqueWithoutRoundInput>
    createMany?: TriviaRoundQuestionCreateManyRoundInputEnvelope
    set?: Enumerable<TriviaRoundQuestionWhereUniqueInput>
    disconnect?: Enumerable<TriviaRoundQuestionWhereUniqueInput>
    delete?: Enumerable<TriviaRoundQuestionWhereUniqueInput>
    connect?: Enumerable<TriviaRoundQuestionWhereUniqueInput>
    update?: Enumerable<TriviaRoundQuestionUpdateWithWhereUniqueWithoutRoundInput>
    updateMany?: Enumerable<TriviaRoundQuestionUpdateManyWithWhereWithoutRoundInput>
    deleteMany?: Enumerable<TriviaRoundQuestionScalarWhereInput>
  }

  export type TwitterFollowCreateNestedManyWithoutFromInput = {
    create?: XOR<Enumerable<TwitterFollowCreateWithoutFromInput>, Enumerable<TwitterFollowUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<TwitterFollowCreateOrConnectWithoutFromInput>
    createMany?: TwitterFollowCreateManyFromInputEnvelope
    connect?: Enumerable<TwitterFollowWhereUniqueInput>
  }

  export type TwitterFollowCreateNestedManyWithoutToInput = {
    create?: XOR<Enumerable<TwitterFollowCreateWithoutToInput>, Enumerable<TwitterFollowUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<TwitterFollowCreateOrConnectWithoutToInput>
    createMany?: TwitterFollowCreateManyToInputEnvelope
    connect?: Enumerable<TwitterFollowWhereUniqueInput>
  }

  export type TwitterPostCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TwitterPostCreateWithoutUserInput>, Enumerable<TwitterPostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TwitterPostCreateOrConnectWithoutUserInput>
    createMany?: TwitterPostCreateManyUserInputEnvelope
    connect?: Enumerable<TwitterPostWhereUniqueInput>
  }

  export type TwitterDirectMessageCreateNestedManyWithoutFromInput = {
    create?: XOR<Enumerable<TwitterDirectMessageCreateWithoutFromInput>, Enumerable<TwitterDirectMessageUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<TwitterDirectMessageCreateOrConnectWithoutFromInput>
    createMany?: TwitterDirectMessageCreateManyFromInputEnvelope
    connect?: Enumerable<TwitterDirectMessageWhereUniqueInput>
  }

  export type TwitterDirectMessageCreateNestedManyWithoutToInput = {
    create?: XOR<Enumerable<TwitterDirectMessageCreateWithoutToInput>, Enumerable<TwitterDirectMessageUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<TwitterDirectMessageCreateOrConnectWithoutToInput>
    createMany?: TwitterDirectMessageCreateManyToInputEnvelope
    connect?: Enumerable<TwitterDirectMessageWhereUniqueInput>
  }

  export type TwitterCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TwitterCommentCreateWithoutUserInput>, Enumerable<TwitterCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TwitterCommentCreateOrConnectWithoutUserInput>
    createMany?: TwitterCommentCreateManyUserInputEnvelope
    connect?: Enumerable<TwitterCommentWhereUniqueInput>
  }

  export type TwitterFollowUncheckedCreateNestedManyWithoutFromInput = {
    create?: XOR<Enumerable<TwitterFollowCreateWithoutFromInput>, Enumerable<TwitterFollowUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<TwitterFollowCreateOrConnectWithoutFromInput>
    createMany?: TwitterFollowCreateManyFromInputEnvelope
    connect?: Enumerable<TwitterFollowWhereUniqueInput>
  }

  export type TwitterFollowUncheckedCreateNestedManyWithoutToInput = {
    create?: XOR<Enumerable<TwitterFollowCreateWithoutToInput>, Enumerable<TwitterFollowUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<TwitterFollowCreateOrConnectWithoutToInput>
    createMany?: TwitterFollowCreateManyToInputEnvelope
    connect?: Enumerable<TwitterFollowWhereUniqueInput>
  }

  export type TwitterPostUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TwitterPostCreateWithoutUserInput>, Enumerable<TwitterPostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TwitterPostCreateOrConnectWithoutUserInput>
    createMany?: TwitterPostCreateManyUserInputEnvelope
    connect?: Enumerable<TwitterPostWhereUniqueInput>
  }

  export type TwitterDirectMessageUncheckedCreateNestedManyWithoutFromInput = {
    create?: XOR<Enumerable<TwitterDirectMessageCreateWithoutFromInput>, Enumerable<TwitterDirectMessageUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<TwitterDirectMessageCreateOrConnectWithoutFromInput>
    createMany?: TwitterDirectMessageCreateManyFromInputEnvelope
    connect?: Enumerable<TwitterDirectMessageWhereUniqueInput>
  }

  export type TwitterDirectMessageUncheckedCreateNestedManyWithoutToInput = {
    create?: XOR<Enumerable<TwitterDirectMessageCreateWithoutToInput>, Enumerable<TwitterDirectMessageUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<TwitterDirectMessageCreateOrConnectWithoutToInput>
    createMany?: TwitterDirectMessageCreateManyToInputEnvelope
    connect?: Enumerable<TwitterDirectMessageWhereUniqueInput>
  }

  export type TwitterCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TwitterCommentCreateWithoutUserInput>, Enumerable<TwitterCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TwitterCommentCreateOrConnectWithoutUserInput>
    createMany?: TwitterCommentCreateManyUserInputEnvelope
    connect?: Enumerable<TwitterCommentWhereUniqueInput>
  }

  export type TwitterFollowUpdateManyWithoutFromNestedInput = {
    create?: XOR<Enumerable<TwitterFollowCreateWithoutFromInput>, Enumerable<TwitterFollowUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<TwitterFollowCreateOrConnectWithoutFromInput>
    upsert?: Enumerable<TwitterFollowUpsertWithWhereUniqueWithoutFromInput>
    createMany?: TwitterFollowCreateManyFromInputEnvelope
    set?: Enumerable<TwitterFollowWhereUniqueInput>
    disconnect?: Enumerable<TwitterFollowWhereUniqueInput>
    delete?: Enumerable<TwitterFollowWhereUniqueInput>
    connect?: Enumerable<TwitterFollowWhereUniqueInput>
    update?: Enumerable<TwitterFollowUpdateWithWhereUniqueWithoutFromInput>
    updateMany?: Enumerable<TwitterFollowUpdateManyWithWhereWithoutFromInput>
    deleteMany?: Enumerable<TwitterFollowScalarWhereInput>
  }

  export type TwitterFollowUpdateManyWithoutToNestedInput = {
    create?: XOR<Enumerable<TwitterFollowCreateWithoutToInput>, Enumerable<TwitterFollowUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<TwitterFollowCreateOrConnectWithoutToInput>
    upsert?: Enumerable<TwitterFollowUpsertWithWhereUniqueWithoutToInput>
    createMany?: TwitterFollowCreateManyToInputEnvelope
    set?: Enumerable<TwitterFollowWhereUniqueInput>
    disconnect?: Enumerable<TwitterFollowWhereUniqueInput>
    delete?: Enumerable<TwitterFollowWhereUniqueInput>
    connect?: Enumerable<TwitterFollowWhereUniqueInput>
    update?: Enumerable<TwitterFollowUpdateWithWhereUniqueWithoutToInput>
    updateMany?: Enumerable<TwitterFollowUpdateManyWithWhereWithoutToInput>
    deleteMany?: Enumerable<TwitterFollowScalarWhereInput>
  }

  export type TwitterPostUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<TwitterPostCreateWithoutUserInput>, Enumerable<TwitterPostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TwitterPostCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TwitterPostUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TwitterPostCreateManyUserInputEnvelope
    set?: Enumerable<TwitterPostWhereUniqueInput>
    disconnect?: Enumerable<TwitterPostWhereUniqueInput>
    delete?: Enumerable<TwitterPostWhereUniqueInput>
    connect?: Enumerable<TwitterPostWhereUniqueInput>
    update?: Enumerable<TwitterPostUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TwitterPostUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TwitterPostScalarWhereInput>
  }

  export type TwitterDirectMessageUpdateManyWithoutFromNestedInput = {
    create?: XOR<Enumerable<TwitterDirectMessageCreateWithoutFromInput>, Enumerable<TwitterDirectMessageUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<TwitterDirectMessageCreateOrConnectWithoutFromInput>
    upsert?: Enumerable<TwitterDirectMessageUpsertWithWhereUniqueWithoutFromInput>
    createMany?: TwitterDirectMessageCreateManyFromInputEnvelope
    set?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    disconnect?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    delete?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    connect?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    update?: Enumerable<TwitterDirectMessageUpdateWithWhereUniqueWithoutFromInput>
    updateMany?: Enumerable<TwitterDirectMessageUpdateManyWithWhereWithoutFromInput>
    deleteMany?: Enumerable<TwitterDirectMessageScalarWhereInput>
  }

  export type TwitterDirectMessageUpdateManyWithoutToNestedInput = {
    create?: XOR<Enumerable<TwitterDirectMessageCreateWithoutToInput>, Enumerable<TwitterDirectMessageUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<TwitterDirectMessageCreateOrConnectWithoutToInput>
    upsert?: Enumerable<TwitterDirectMessageUpsertWithWhereUniqueWithoutToInput>
    createMany?: TwitterDirectMessageCreateManyToInputEnvelope
    set?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    disconnect?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    delete?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    connect?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    update?: Enumerable<TwitterDirectMessageUpdateWithWhereUniqueWithoutToInput>
    updateMany?: Enumerable<TwitterDirectMessageUpdateManyWithWhereWithoutToInput>
    deleteMany?: Enumerable<TwitterDirectMessageScalarWhereInput>
  }

  export type TwitterCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<TwitterCommentCreateWithoutUserInput>, Enumerable<TwitterCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TwitterCommentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TwitterCommentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TwitterCommentCreateManyUserInputEnvelope
    set?: Enumerable<TwitterCommentWhereUniqueInput>
    disconnect?: Enumerable<TwitterCommentWhereUniqueInput>
    delete?: Enumerable<TwitterCommentWhereUniqueInput>
    connect?: Enumerable<TwitterCommentWhereUniqueInput>
    update?: Enumerable<TwitterCommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TwitterCommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TwitterCommentScalarWhereInput>
  }

  export type TwitterFollowUncheckedUpdateManyWithoutFromNestedInput = {
    create?: XOR<Enumerable<TwitterFollowCreateWithoutFromInput>, Enumerable<TwitterFollowUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<TwitterFollowCreateOrConnectWithoutFromInput>
    upsert?: Enumerable<TwitterFollowUpsertWithWhereUniqueWithoutFromInput>
    createMany?: TwitterFollowCreateManyFromInputEnvelope
    set?: Enumerable<TwitterFollowWhereUniqueInput>
    disconnect?: Enumerable<TwitterFollowWhereUniqueInput>
    delete?: Enumerable<TwitterFollowWhereUniqueInput>
    connect?: Enumerable<TwitterFollowWhereUniqueInput>
    update?: Enumerable<TwitterFollowUpdateWithWhereUniqueWithoutFromInput>
    updateMany?: Enumerable<TwitterFollowUpdateManyWithWhereWithoutFromInput>
    deleteMany?: Enumerable<TwitterFollowScalarWhereInput>
  }

  export type TwitterFollowUncheckedUpdateManyWithoutToNestedInput = {
    create?: XOR<Enumerable<TwitterFollowCreateWithoutToInput>, Enumerable<TwitterFollowUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<TwitterFollowCreateOrConnectWithoutToInput>
    upsert?: Enumerable<TwitterFollowUpsertWithWhereUniqueWithoutToInput>
    createMany?: TwitterFollowCreateManyToInputEnvelope
    set?: Enumerable<TwitterFollowWhereUniqueInput>
    disconnect?: Enumerable<TwitterFollowWhereUniqueInput>
    delete?: Enumerable<TwitterFollowWhereUniqueInput>
    connect?: Enumerable<TwitterFollowWhereUniqueInput>
    update?: Enumerable<TwitterFollowUpdateWithWhereUniqueWithoutToInput>
    updateMany?: Enumerable<TwitterFollowUpdateManyWithWhereWithoutToInput>
    deleteMany?: Enumerable<TwitterFollowScalarWhereInput>
  }

  export type TwitterPostUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<TwitterPostCreateWithoutUserInput>, Enumerable<TwitterPostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TwitterPostCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TwitterPostUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TwitterPostCreateManyUserInputEnvelope
    set?: Enumerable<TwitterPostWhereUniqueInput>
    disconnect?: Enumerable<TwitterPostWhereUniqueInput>
    delete?: Enumerable<TwitterPostWhereUniqueInput>
    connect?: Enumerable<TwitterPostWhereUniqueInput>
    update?: Enumerable<TwitterPostUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TwitterPostUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TwitterPostScalarWhereInput>
  }

  export type TwitterDirectMessageUncheckedUpdateManyWithoutFromNestedInput = {
    create?: XOR<Enumerable<TwitterDirectMessageCreateWithoutFromInput>, Enumerable<TwitterDirectMessageUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<TwitterDirectMessageCreateOrConnectWithoutFromInput>
    upsert?: Enumerable<TwitterDirectMessageUpsertWithWhereUniqueWithoutFromInput>
    createMany?: TwitterDirectMessageCreateManyFromInputEnvelope
    set?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    disconnect?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    delete?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    connect?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    update?: Enumerable<TwitterDirectMessageUpdateWithWhereUniqueWithoutFromInput>
    updateMany?: Enumerable<TwitterDirectMessageUpdateManyWithWhereWithoutFromInput>
    deleteMany?: Enumerable<TwitterDirectMessageScalarWhereInput>
  }

  export type TwitterDirectMessageUncheckedUpdateManyWithoutToNestedInput = {
    create?: XOR<Enumerable<TwitterDirectMessageCreateWithoutToInput>, Enumerable<TwitterDirectMessageUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<TwitterDirectMessageCreateOrConnectWithoutToInput>
    upsert?: Enumerable<TwitterDirectMessageUpsertWithWhereUniqueWithoutToInput>
    createMany?: TwitterDirectMessageCreateManyToInputEnvelope
    set?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    disconnect?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    delete?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    connect?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    update?: Enumerable<TwitterDirectMessageUpdateWithWhereUniqueWithoutToInput>
    updateMany?: Enumerable<TwitterDirectMessageUpdateManyWithWhereWithoutToInput>
    deleteMany?: Enumerable<TwitterDirectMessageScalarWhereInput>
  }

  export type TwitterCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<TwitterCommentCreateWithoutUserInput>, Enumerable<TwitterCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TwitterCommentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TwitterCommentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TwitterCommentCreateManyUserInputEnvelope
    set?: Enumerable<TwitterCommentWhereUniqueInput>
    disconnect?: Enumerable<TwitterCommentWhereUniqueInput>
    delete?: Enumerable<TwitterCommentWhereUniqueInput>
    connect?: Enumerable<TwitterCommentWhereUniqueInput>
    update?: Enumerable<TwitterCommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TwitterCommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TwitterCommentScalarWhereInput>
  }

  export type TwitterUserCreateNestedOneWithoutFromFollowingInput = {
    create?: XOR<TwitterUserCreateWithoutFromFollowingInput, TwitterUserUncheckedCreateWithoutFromFollowingInput>
    connectOrCreate?: TwitterUserCreateOrConnectWithoutFromFollowingInput
    connect?: TwitterUserWhereUniqueInput
  }

  export type TwitterUserCreateNestedOneWithoutToFollowingInput = {
    create?: XOR<TwitterUserCreateWithoutToFollowingInput, TwitterUserUncheckedCreateWithoutToFollowingInput>
    connectOrCreate?: TwitterUserCreateOrConnectWithoutToFollowingInput
    connect?: TwitterUserWhereUniqueInput
  }

  export type TwitterUserUpdateOneRequiredWithoutFromFollowingNestedInput = {
    create?: XOR<TwitterUserCreateWithoutFromFollowingInput, TwitterUserUncheckedCreateWithoutFromFollowingInput>
    connectOrCreate?: TwitterUserCreateOrConnectWithoutFromFollowingInput
    upsert?: TwitterUserUpsertWithoutFromFollowingInput
    connect?: TwitterUserWhereUniqueInput
    update?: XOR<TwitterUserUpdateWithoutFromFollowingInput, TwitterUserUncheckedUpdateWithoutFromFollowingInput>
  }

  export type TwitterUserUpdateOneRequiredWithoutToFollowingNestedInput = {
    create?: XOR<TwitterUserCreateWithoutToFollowingInput, TwitterUserUncheckedCreateWithoutToFollowingInput>
    connectOrCreate?: TwitterUserCreateOrConnectWithoutToFollowingInput
    upsert?: TwitterUserUpsertWithoutToFollowingInput
    connect?: TwitterUserWhereUniqueInput
    update?: XOR<TwitterUserUpdateWithoutToFollowingInput, TwitterUserUncheckedUpdateWithoutToFollowingInput>
  }

  export type TwitterUserCreateNestedOneWithoutPostsInput = {
    create?: XOR<TwitterUserCreateWithoutPostsInput, TwitterUserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: TwitterUserCreateOrConnectWithoutPostsInput
    connect?: TwitterUserWhereUniqueInput
  }

  export type TwitterCommentCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<TwitterCommentCreateWithoutPostInput>, Enumerable<TwitterCommentUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<TwitterCommentCreateOrConnectWithoutPostInput>
    createMany?: TwitterCommentCreateManyPostInputEnvelope
    connect?: Enumerable<TwitterCommentWhereUniqueInput>
  }

  export type TwitterPostOnHashtagCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<TwitterPostOnHashtagCreateWithoutPostInput>, Enumerable<TwitterPostOnHashtagUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<TwitterPostOnHashtagCreateOrConnectWithoutPostInput>
    createMany?: TwitterPostOnHashtagCreateManyPostInputEnvelope
    connect?: Enumerable<TwitterPostOnHashtagWhereUniqueInput>
  }

  export type TwitterCommentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<TwitterCommentCreateWithoutPostInput>, Enumerable<TwitterCommentUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<TwitterCommentCreateOrConnectWithoutPostInput>
    createMany?: TwitterCommentCreateManyPostInputEnvelope
    connect?: Enumerable<TwitterCommentWhereUniqueInput>
  }

  export type TwitterPostOnHashtagUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<TwitterPostOnHashtagCreateWithoutPostInput>, Enumerable<TwitterPostOnHashtagUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<TwitterPostOnHashtagCreateOrConnectWithoutPostInput>
    createMany?: TwitterPostOnHashtagCreateManyPostInputEnvelope
    connect?: Enumerable<TwitterPostOnHashtagWhereUniqueInput>
  }

  export type TwitterUserUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<TwitterUserCreateWithoutPostsInput, TwitterUserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: TwitterUserCreateOrConnectWithoutPostsInput
    upsert?: TwitterUserUpsertWithoutPostsInput
    connect?: TwitterUserWhereUniqueInput
    update?: XOR<TwitterUserUpdateWithoutPostsInput, TwitterUserUncheckedUpdateWithoutPostsInput>
  }

  export type TwitterCommentUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<TwitterCommentCreateWithoutPostInput>, Enumerable<TwitterCommentUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<TwitterCommentCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<TwitterCommentUpsertWithWhereUniqueWithoutPostInput>
    createMany?: TwitterCommentCreateManyPostInputEnvelope
    set?: Enumerable<TwitterCommentWhereUniqueInput>
    disconnect?: Enumerable<TwitterCommentWhereUniqueInput>
    delete?: Enumerable<TwitterCommentWhereUniqueInput>
    connect?: Enumerable<TwitterCommentWhereUniqueInput>
    update?: Enumerable<TwitterCommentUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<TwitterCommentUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<TwitterCommentScalarWhereInput>
  }

  export type TwitterPostOnHashtagUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<TwitterPostOnHashtagCreateWithoutPostInput>, Enumerable<TwitterPostOnHashtagUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<TwitterPostOnHashtagCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<TwitterPostOnHashtagUpsertWithWhereUniqueWithoutPostInput>
    createMany?: TwitterPostOnHashtagCreateManyPostInputEnvelope
    set?: Enumerable<TwitterPostOnHashtagWhereUniqueInput>
    disconnect?: Enumerable<TwitterPostOnHashtagWhereUniqueInput>
    delete?: Enumerable<TwitterPostOnHashtagWhereUniqueInput>
    connect?: Enumerable<TwitterPostOnHashtagWhereUniqueInput>
    update?: Enumerable<TwitterPostOnHashtagUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<TwitterPostOnHashtagUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<TwitterPostOnHashtagScalarWhereInput>
  }

  export type TwitterCommentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<TwitterCommentCreateWithoutPostInput>, Enumerable<TwitterCommentUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<TwitterCommentCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<TwitterCommentUpsertWithWhereUniqueWithoutPostInput>
    createMany?: TwitterCommentCreateManyPostInputEnvelope
    set?: Enumerable<TwitterCommentWhereUniqueInput>
    disconnect?: Enumerable<TwitterCommentWhereUniqueInput>
    delete?: Enumerable<TwitterCommentWhereUniqueInput>
    connect?: Enumerable<TwitterCommentWhereUniqueInput>
    update?: Enumerable<TwitterCommentUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<TwitterCommentUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<TwitterCommentScalarWhereInput>
  }

  export type TwitterPostOnHashtagUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<TwitterPostOnHashtagCreateWithoutPostInput>, Enumerable<TwitterPostOnHashtagUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<TwitterPostOnHashtagCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<TwitterPostOnHashtagUpsertWithWhereUniqueWithoutPostInput>
    createMany?: TwitterPostOnHashtagCreateManyPostInputEnvelope
    set?: Enumerable<TwitterPostOnHashtagWhereUniqueInput>
    disconnect?: Enumerable<TwitterPostOnHashtagWhereUniqueInput>
    delete?: Enumerable<TwitterPostOnHashtagWhereUniqueInput>
    connect?: Enumerable<TwitterPostOnHashtagWhereUniqueInput>
    update?: Enumerable<TwitterPostOnHashtagUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<TwitterPostOnHashtagUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<TwitterPostOnHashtagScalarWhereInput>
  }

  export type TwitterUserCreateNestedOneWithoutFromDirectMessageInput = {
    create?: XOR<TwitterUserCreateWithoutFromDirectMessageInput, TwitterUserUncheckedCreateWithoutFromDirectMessageInput>
    connectOrCreate?: TwitterUserCreateOrConnectWithoutFromDirectMessageInput
    connect?: TwitterUserWhereUniqueInput
  }

  export type TwitterUserCreateNestedOneWithoutToDirectMessageInput = {
    create?: XOR<TwitterUserCreateWithoutToDirectMessageInput, TwitterUserUncheckedCreateWithoutToDirectMessageInput>
    connectOrCreate?: TwitterUserCreateOrConnectWithoutToDirectMessageInput
    connect?: TwitterUserWhereUniqueInput
  }

  export type TwitterUserUpdateOneRequiredWithoutFromDirectMessageNestedInput = {
    create?: XOR<TwitterUserCreateWithoutFromDirectMessageInput, TwitterUserUncheckedCreateWithoutFromDirectMessageInput>
    connectOrCreate?: TwitterUserCreateOrConnectWithoutFromDirectMessageInput
    upsert?: TwitterUserUpsertWithoutFromDirectMessageInput
    connect?: TwitterUserWhereUniqueInput
    update?: XOR<TwitterUserUpdateWithoutFromDirectMessageInput, TwitterUserUncheckedUpdateWithoutFromDirectMessageInput>
  }

  export type TwitterUserUpdateOneRequiredWithoutToDirectMessageNestedInput = {
    create?: XOR<TwitterUserCreateWithoutToDirectMessageInput, TwitterUserUncheckedCreateWithoutToDirectMessageInput>
    connectOrCreate?: TwitterUserCreateOrConnectWithoutToDirectMessageInput
    upsert?: TwitterUserUpsertWithoutToDirectMessageInput
    connect?: TwitterUserWhereUniqueInput
    update?: XOR<TwitterUserUpdateWithoutToDirectMessageInput, TwitterUserUncheckedUpdateWithoutToDirectMessageInput>
  }

  export type TwitterPostOnHashtagCreateNestedManyWithoutHashtagInput = {
    create?: XOR<Enumerable<TwitterPostOnHashtagCreateWithoutHashtagInput>, Enumerable<TwitterPostOnHashtagUncheckedCreateWithoutHashtagInput>>
    connectOrCreate?: Enumerable<TwitterPostOnHashtagCreateOrConnectWithoutHashtagInput>
    createMany?: TwitterPostOnHashtagCreateManyHashtagInputEnvelope
    connect?: Enumerable<TwitterPostOnHashtagWhereUniqueInput>
  }

  export type TwitterPostOnHashtagUncheckedCreateNestedManyWithoutHashtagInput = {
    create?: XOR<Enumerable<TwitterPostOnHashtagCreateWithoutHashtagInput>, Enumerable<TwitterPostOnHashtagUncheckedCreateWithoutHashtagInput>>
    connectOrCreate?: Enumerable<TwitterPostOnHashtagCreateOrConnectWithoutHashtagInput>
    createMany?: TwitterPostOnHashtagCreateManyHashtagInputEnvelope
    connect?: Enumerable<TwitterPostOnHashtagWhereUniqueInput>
  }

  export type TwitterPostOnHashtagUpdateManyWithoutHashtagNestedInput = {
    create?: XOR<Enumerable<TwitterPostOnHashtagCreateWithoutHashtagInput>, Enumerable<TwitterPostOnHashtagUncheckedCreateWithoutHashtagInput>>
    connectOrCreate?: Enumerable<TwitterPostOnHashtagCreateOrConnectWithoutHashtagInput>
    upsert?: Enumerable<TwitterPostOnHashtagUpsertWithWhereUniqueWithoutHashtagInput>
    createMany?: TwitterPostOnHashtagCreateManyHashtagInputEnvelope
    set?: Enumerable<TwitterPostOnHashtagWhereUniqueInput>
    disconnect?: Enumerable<TwitterPostOnHashtagWhereUniqueInput>
    delete?: Enumerable<TwitterPostOnHashtagWhereUniqueInput>
    connect?: Enumerable<TwitterPostOnHashtagWhereUniqueInput>
    update?: Enumerable<TwitterPostOnHashtagUpdateWithWhereUniqueWithoutHashtagInput>
    updateMany?: Enumerable<TwitterPostOnHashtagUpdateManyWithWhereWithoutHashtagInput>
    deleteMany?: Enumerable<TwitterPostOnHashtagScalarWhereInput>
  }

  export type TwitterPostOnHashtagUncheckedUpdateManyWithoutHashtagNestedInput = {
    create?: XOR<Enumerable<TwitterPostOnHashtagCreateWithoutHashtagInput>, Enumerable<TwitterPostOnHashtagUncheckedCreateWithoutHashtagInput>>
    connectOrCreate?: Enumerable<TwitterPostOnHashtagCreateOrConnectWithoutHashtagInput>
    upsert?: Enumerable<TwitterPostOnHashtagUpsertWithWhereUniqueWithoutHashtagInput>
    createMany?: TwitterPostOnHashtagCreateManyHashtagInputEnvelope
    set?: Enumerable<TwitterPostOnHashtagWhereUniqueInput>
    disconnect?: Enumerable<TwitterPostOnHashtagWhereUniqueInput>
    delete?: Enumerable<TwitterPostOnHashtagWhereUniqueInput>
    connect?: Enumerable<TwitterPostOnHashtagWhereUniqueInput>
    update?: Enumerable<TwitterPostOnHashtagUpdateWithWhereUniqueWithoutHashtagInput>
    updateMany?: Enumerable<TwitterPostOnHashtagUpdateManyWithWhereWithoutHashtagInput>
    deleteMany?: Enumerable<TwitterPostOnHashtagScalarWhereInput>
  }

  export type TwitterUserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<TwitterUserCreateWithoutCommentsInput, TwitterUserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TwitterUserCreateOrConnectWithoutCommentsInput
    connect?: TwitterUserWhereUniqueInput
  }

  export type TwitterPostCreateNestedOneWithoutCommentsInput = {
    create?: XOR<TwitterPostCreateWithoutCommentsInput, TwitterPostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TwitterPostCreateOrConnectWithoutCommentsInput
    connect?: TwitterPostWhereUniqueInput
  }

  export type TwitterUserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<TwitterUserCreateWithoutCommentsInput, TwitterUserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TwitterUserCreateOrConnectWithoutCommentsInput
    upsert?: TwitterUserUpsertWithoutCommentsInput
    connect?: TwitterUserWhereUniqueInput
    update?: XOR<TwitterUserUpdateWithoutCommentsInput, TwitterUserUncheckedUpdateWithoutCommentsInput>
  }

  export type TwitterPostUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<TwitterPostCreateWithoutCommentsInput, TwitterPostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TwitterPostCreateOrConnectWithoutCommentsInput
    upsert?: TwitterPostUpsertWithoutCommentsInput
    connect?: TwitterPostWhereUniqueInput
    update?: XOR<TwitterPostUpdateWithoutCommentsInput, TwitterPostUncheckedUpdateWithoutCommentsInput>
  }

  export type TwitterPostCreateNestedOneWithoutPostOnHashtagsInput = {
    create?: XOR<TwitterPostCreateWithoutPostOnHashtagsInput, TwitterPostUncheckedCreateWithoutPostOnHashtagsInput>
    connectOrCreate?: TwitterPostCreateOrConnectWithoutPostOnHashtagsInput
    connect?: TwitterPostWhereUniqueInput
  }

  export type TwitterHashtagCreateNestedOneWithoutPostOnHashtagInput = {
    create?: XOR<TwitterHashtagCreateWithoutPostOnHashtagInput, TwitterHashtagUncheckedCreateWithoutPostOnHashtagInput>
    connectOrCreate?: TwitterHashtagCreateOrConnectWithoutPostOnHashtagInput
    connect?: TwitterHashtagWhereUniqueInput
  }

  export type TwitterPostUpdateOneRequiredWithoutPostOnHashtagsNestedInput = {
    create?: XOR<TwitterPostCreateWithoutPostOnHashtagsInput, TwitterPostUncheckedCreateWithoutPostOnHashtagsInput>
    connectOrCreate?: TwitterPostCreateOrConnectWithoutPostOnHashtagsInput
    upsert?: TwitterPostUpsertWithoutPostOnHashtagsInput
    connect?: TwitterPostWhereUniqueInput
    update?: XOR<TwitterPostUpdateWithoutPostOnHashtagsInput, TwitterPostUncheckedUpdateWithoutPostOnHashtagsInput>
  }

  export type TwitterHashtagUpdateOneRequiredWithoutPostOnHashtagNestedInput = {
    create?: XOR<TwitterHashtagCreateWithoutPostOnHashtagInput, TwitterHashtagUncheckedCreateWithoutPostOnHashtagInput>
    connectOrCreate?: TwitterHashtagCreateOrConnectWithoutPostOnHashtagInput
    upsert?: TwitterHashtagUpsertWithoutPostOnHashtagInput
    connect?: TwitterHashtagWhereUniqueInput
    update?: XOR<TwitterHashtagUpdateWithoutPostOnHashtagInput, TwitterHashtagUncheckedUpdateWithoutPostOnHashtagInput>
  }

  export type WSTopupHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<WSTopupHistoryCreateWithoutUserInput>, Enumerable<WSTopupHistoryUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<WSTopupHistoryCreateOrConnectWithoutUserInput>
    createMany?: WSTopupHistoryCreateManyUserInputEnvelope
    connect?: Enumerable<WSTopupHistoryWhereUniqueInput>
  }

  export type WSUsingHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<WSUsingHistoryCreateWithoutUserInput>, Enumerable<WSUsingHistoryUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<WSUsingHistoryCreateOrConnectWithoutUserInput>
    createMany?: WSUsingHistoryCreateManyUserInputEnvelope
    connect?: Enumerable<WSUsingHistoryWhereUniqueInput>
  }

  export type WSTopupHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<WSTopupHistoryCreateWithoutUserInput>, Enumerable<WSTopupHistoryUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<WSTopupHistoryCreateOrConnectWithoutUserInput>
    createMany?: WSTopupHistoryCreateManyUserInputEnvelope
    connect?: Enumerable<WSTopupHistoryWhereUniqueInput>
  }

  export type WSUsingHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<WSUsingHistoryCreateWithoutUserInput>, Enumerable<WSUsingHistoryUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<WSUsingHistoryCreateOrConnectWithoutUserInput>
    createMany?: WSUsingHistoryCreateManyUserInputEnvelope
    connect?: Enumerable<WSUsingHistoryWhereUniqueInput>
  }

  export type WSTopupHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<WSTopupHistoryCreateWithoutUserInput>, Enumerable<WSTopupHistoryUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<WSTopupHistoryCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<WSTopupHistoryUpsertWithWhereUniqueWithoutUserInput>
    createMany?: WSTopupHistoryCreateManyUserInputEnvelope
    set?: Enumerable<WSTopupHistoryWhereUniqueInput>
    disconnect?: Enumerable<WSTopupHistoryWhereUniqueInput>
    delete?: Enumerable<WSTopupHistoryWhereUniqueInput>
    connect?: Enumerable<WSTopupHistoryWhereUniqueInput>
    update?: Enumerable<WSTopupHistoryUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<WSTopupHistoryUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<WSTopupHistoryScalarWhereInput>
  }

  export type WSUsingHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<WSUsingHistoryCreateWithoutUserInput>, Enumerable<WSUsingHistoryUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<WSUsingHistoryCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<WSUsingHistoryUpsertWithWhereUniqueWithoutUserInput>
    createMany?: WSUsingHistoryCreateManyUserInputEnvelope
    set?: Enumerable<WSUsingHistoryWhereUniqueInput>
    disconnect?: Enumerable<WSUsingHistoryWhereUniqueInput>
    delete?: Enumerable<WSUsingHistoryWhereUniqueInput>
    connect?: Enumerable<WSUsingHistoryWhereUniqueInput>
    update?: Enumerable<WSUsingHistoryUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<WSUsingHistoryUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<WSUsingHistoryScalarWhereInput>
  }

  export type WSTopupHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<WSTopupHistoryCreateWithoutUserInput>, Enumerable<WSTopupHistoryUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<WSTopupHistoryCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<WSTopupHistoryUpsertWithWhereUniqueWithoutUserInput>
    createMany?: WSTopupHistoryCreateManyUserInputEnvelope
    set?: Enumerable<WSTopupHistoryWhereUniqueInput>
    disconnect?: Enumerable<WSTopupHistoryWhereUniqueInput>
    delete?: Enumerable<WSTopupHistoryWhereUniqueInput>
    connect?: Enumerable<WSTopupHistoryWhereUniqueInput>
    update?: Enumerable<WSTopupHistoryUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<WSTopupHistoryUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<WSTopupHistoryScalarWhereInput>
  }

  export type WSUsingHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<WSUsingHistoryCreateWithoutUserInput>, Enumerable<WSUsingHistoryUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<WSUsingHistoryCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<WSUsingHistoryUpsertWithWhereUniqueWithoutUserInput>
    createMany?: WSUsingHistoryCreateManyUserInputEnvelope
    set?: Enumerable<WSUsingHistoryWhereUniqueInput>
    disconnect?: Enumerable<WSUsingHistoryWhereUniqueInput>
    delete?: Enumerable<WSUsingHistoryWhereUniqueInput>
    connect?: Enumerable<WSUsingHistoryWhereUniqueInput>
    update?: Enumerable<WSUsingHistoryUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<WSUsingHistoryUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<WSUsingHistoryScalarWhereInput>
  }

  export type WSUserCreateNestedOneWithoutTopupHistoriesInput = {
    create?: XOR<WSUserCreateWithoutTopupHistoriesInput, WSUserUncheckedCreateWithoutTopupHistoriesInput>
    connectOrCreate?: WSUserCreateOrConnectWithoutTopupHistoriesInput
    connect?: WSUserWhereUniqueInput
  }

  export type WSUserUpdateOneRequiredWithoutTopupHistoriesNestedInput = {
    create?: XOR<WSUserCreateWithoutTopupHistoriesInput, WSUserUncheckedCreateWithoutTopupHistoriesInput>
    connectOrCreate?: WSUserCreateOrConnectWithoutTopupHistoriesInput
    upsert?: WSUserUpsertWithoutTopupHistoriesInput
    connect?: WSUserWhereUniqueInput
    update?: XOR<WSUserUpdateWithoutTopupHistoriesInput, WSUserUncheckedUpdateWithoutTopupHistoriesInput>
  }

  export type WSUserCreateNestedOneWithoutUsingHistoriesInput = {
    create?: XOR<WSUserCreateWithoutUsingHistoriesInput, WSUserUncheckedCreateWithoutUsingHistoriesInput>
    connectOrCreate?: WSUserCreateOrConnectWithoutUsingHistoriesInput
    connect?: WSUserWhereUniqueInput
  }

  export type WSMachineCreateNestedOneWithoutUsingHistoriesInput = {
    create?: XOR<WSMachineCreateWithoutUsingHistoriesInput, WSMachineUncheckedCreateWithoutUsingHistoriesInput>
    connectOrCreate?: WSMachineCreateOrConnectWithoutUsingHistoriesInput
    connect?: WSMachineWhereUniqueInput
  }

  export type WSProgramCreateNestedOneWithoutUsingHistoriesInput = {
    create?: XOR<WSProgramCreateWithoutUsingHistoriesInput, WSProgramUncheckedCreateWithoutUsingHistoriesInput>
    connectOrCreate?: WSProgramCreateOrConnectWithoutUsingHistoriesInput
    connect?: WSProgramWhereUniqueInput
  }

  export type WSUserUpdateOneRequiredWithoutUsingHistoriesNestedInput = {
    create?: XOR<WSUserCreateWithoutUsingHistoriesInput, WSUserUncheckedCreateWithoutUsingHistoriesInput>
    connectOrCreate?: WSUserCreateOrConnectWithoutUsingHistoriesInput
    upsert?: WSUserUpsertWithoutUsingHistoriesInput
    connect?: WSUserWhereUniqueInput
    update?: XOR<WSUserUpdateWithoutUsingHistoriesInput, WSUserUncheckedUpdateWithoutUsingHistoriesInput>
  }

  export type WSMachineUpdateOneRequiredWithoutUsingHistoriesNestedInput = {
    create?: XOR<WSMachineCreateWithoutUsingHistoriesInput, WSMachineUncheckedCreateWithoutUsingHistoriesInput>
    connectOrCreate?: WSMachineCreateOrConnectWithoutUsingHistoriesInput
    upsert?: WSMachineUpsertWithoutUsingHistoriesInput
    connect?: WSMachineWhereUniqueInput
    update?: XOR<WSMachineUpdateWithoutUsingHistoriesInput, WSMachineUncheckedUpdateWithoutUsingHistoriesInput>
  }

  export type WSProgramUpdateOneRequiredWithoutUsingHistoriesNestedInput = {
    create?: XOR<WSProgramCreateWithoutUsingHistoriesInput, WSProgramUncheckedCreateWithoutUsingHistoriesInput>
    connectOrCreate?: WSProgramCreateOrConnectWithoutUsingHistoriesInput
    upsert?: WSProgramUpsertWithoutUsingHistoriesInput
    connect?: WSProgramWhereUniqueInput
    update?: XOR<WSProgramUpdateWithoutUsingHistoriesInput, WSProgramUncheckedUpdateWithoutUsingHistoriesInput>
  }

  export type WSMachineCreateNestedManyWithoutShopInput = {
    create?: XOR<Enumerable<WSMachineCreateWithoutShopInput>, Enumerable<WSMachineUncheckedCreateWithoutShopInput>>
    connectOrCreate?: Enumerable<WSMachineCreateOrConnectWithoutShopInput>
    createMany?: WSMachineCreateManyShopInputEnvelope
    connect?: Enumerable<WSMachineWhereUniqueInput>
  }

  export type WSMachineUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<Enumerable<WSMachineCreateWithoutShopInput>, Enumerable<WSMachineUncheckedCreateWithoutShopInput>>
    connectOrCreate?: Enumerable<WSMachineCreateOrConnectWithoutShopInput>
    createMany?: WSMachineCreateManyShopInputEnvelope
    connect?: Enumerable<WSMachineWhereUniqueInput>
  }

  export type WSMachineUpdateManyWithoutShopNestedInput = {
    create?: XOR<Enumerable<WSMachineCreateWithoutShopInput>, Enumerable<WSMachineUncheckedCreateWithoutShopInput>>
    connectOrCreate?: Enumerable<WSMachineCreateOrConnectWithoutShopInput>
    upsert?: Enumerable<WSMachineUpsertWithWhereUniqueWithoutShopInput>
    createMany?: WSMachineCreateManyShopInputEnvelope
    set?: Enumerable<WSMachineWhereUniqueInput>
    disconnect?: Enumerable<WSMachineWhereUniqueInput>
    delete?: Enumerable<WSMachineWhereUniqueInput>
    connect?: Enumerable<WSMachineWhereUniqueInput>
    update?: Enumerable<WSMachineUpdateWithWhereUniqueWithoutShopInput>
    updateMany?: Enumerable<WSMachineUpdateManyWithWhereWithoutShopInput>
    deleteMany?: Enumerable<WSMachineScalarWhereInput>
  }

  export type WSMachineUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<Enumerable<WSMachineCreateWithoutShopInput>, Enumerable<WSMachineUncheckedCreateWithoutShopInput>>
    connectOrCreate?: Enumerable<WSMachineCreateOrConnectWithoutShopInput>
    upsert?: Enumerable<WSMachineUpsertWithWhereUniqueWithoutShopInput>
    createMany?: WSMachineCreateManyShopInputEnvelope
    set?: Enumerable<WSMachineWhereUniqueInput>
    disconnect?: Enumerable<WSMachineWhereUniqueInput>
    delete?: Enumerable<WSMachineWhereUniqueInput>
    connect?: Enumerable<WSMachineWhereUniqueInput>
    update?: Enumerable<WSMachineUpdateWithWhereUniqueWithoutShopInput>
    updateMany?: Enumerable<WSMachineUpdateManyWithWhereWithoutShopInput>
    deleteMany?: Enumerable<WSMachineScalarWhereInput>
  }

  export type WSShopCreateNestedOneWithoutMachinesInput = {
    create?: XOR<WSShopCreateWithoutMachinesInput, WSShopUncheckedCreateWithoutMachinesInput>
    connectOrCreate?: WSShopCreateOrConnectWithoutMachinesInput
    connect?: WSShopWhereUniqueInput
  }

  export type MachineToProgramCreateNestedManyWithoutMachingInput = {
    create?: XOR<Enumerable<MachineToProgramCreateWithoutMachingInput>, Enumerable<MachineToProgramUncheckedCreateWithoutMachingInput>>
    connectOrCreate?: Enumerable<MachineToProgramCreateOrConnectWithoutMachingInput>
    createMany?: MachineToProgramCreateManyMachingInputEnvelope
    connect?: Enumerable<MachineToProgramWhereUniqueInput>
  }

  export type WSMaintainCreateNestedManyWithoutMachineInput = {
    create?: XOR<Enumerable<WSMaintainCreateWithoutMachineInput>, Enumerable<WSMaintainUncheckedCreateWithoutMachineInput>>
    connectOrCreate?: Enumerable<WSMaintainCreateOrConnectWithoutMachineInput>
    createMany?: WSMaintainCreateManyMachineInputEnvelope
    connect?: Enumerable<WSMaintainWhereUniqueInput>
  }

  export type WSUsingHistoryCreateNestedManyWithoutMachineInput = {
    create?: XOR<Enumerable<WSUsingHistoryCreateWithoutMachineInput>, Enumerable<WSUsingHistoryUncheckedCreateWithoutMachineInput>>
    connectOrCreate?: Enumerable<WSUsingHistoryCreateOrConnectWithoutMachineInput>
    createMany?: WSUsingHistoryCreateManyMachineInputEnvelope
    connect?: Enumerable<WSUsingHistoryWhereUniqueInput>
  }

  export type MachineToProgramUncheckedCreateNestedManyWithoutMachingInput = {
    create?: XOR<Enumerable<MachineToProgramCreateWithoutMachingInput>, Enumerable<MachineToProgramUncheckedCreateWithoutMachingInput>>
    connectOrCreate?: Enumerable<MachineToProgramCreateOrConnectWithoutMachingInput>
    createMany?: MachineToProgramCreateManyMachingInputEnvelope
    connect?: Enumerable<MachineToProgramWhereUniqueInput>
  }

  export type WSMaintainUncheckedCreateNestedManyWithoutMachineInput = {
    create?: XOR<Enumerable<WSMaintainCreateWithoutMachineInput>, Enumerable<WSMaintainUncheckedCreateWithoutMachineInput>>
    connectOrCreate?: Enumerable<WSMaintainCreateOrConnectWithoutMachineInput>
    createMany?: WSMaintainCreateManyMachineInputEnvelope
    connect?: Enumerable<WSMaintainWhereUniqueInput>
  }

  export type WSUsingHistoryUncheckedCreateNestedManyWithoutMachineInput = {
    create?: XOR<Enumerable<WSUsingHistoryCreateWithoutMachineInput>, Enumerable<WSUsingHistoryUncheckedCreateWithoutMachineInput>>
    connectOrCreate?: Enumerable<WSUsingHistoryCreateOrConnectWithoutMachineInput>
    createMany?: WSUsingHistoryCreateManyMachineInputEnvelope
    connect?: Enumerable<WSUsingHistoryWhereUniqueInput>
  }

  export type WSShopUpdateOneRequiredWithoutMachinesNestedInput = {
    create?: XOR<WSShopCreateWithoutMachinesInput, WSShopUncheckedCreateWithoutMachinesInput>
    connectOrCreate?: WSShopCreateOrConnectWithoutMachinesInput
    upsert?: WSShopUpsertWithoutMachinesInput
    connect?: WSShopWhereUniqueInput
    update?: XOR<WSShopUpdateWithoutMachinesInput, WSShopUncheckedUpdateWithoutMachinesInput>
  }

  export type MachineToProgramUpdateManyWithoutMachingNestedInput = {
    create?: XOR<Enumerable<MachineToProgramCreateWithoutMachingInput>, Enumerable<MachineToProgramUncheckedCreateWithoutMachingInput>>
    connectOrCreate?: Enumerable<MachineToProgramCreateOrConnectWithoutMachingInput>
    upsert?: Enumerable<MachineToProgramUpsertWithWhereUniqueWithoutMachingInput>
    createMany?: MachineToProgramCreateManyMachingInputEnvelope
    set?: Enumerable<MachineToProgramWhereUniqueInput>
    disconnect?: Enumerable<MachineToProgramWhereUniqueInput>
    delete?: Enumerable<MachineToProgramWhereUniqueInput>
    connect?: Enumerable<MachineToProgramWhereUniqueInput>
    update?: Enumerable<MachineToProgramUpdateWithWhereUniqueWithoutMachingInput>
    updateMany?: Enumerable<MachineToProgramUpdateManyWithWhereWithoutMachingInput>
    deleteMany?: Enumerable<MachineToProgramScalarWhereInput>
  }

  export type WSMaintainUpdateManyWithoutMachineNestedInput = {
    create?: XOR<Enumerable<WSMaintainCreateWithoutMachineInput>, Enumerable<WSMaintainUncheckedCreateWithoutMachineInput>>
    connectOrCreate?: Enumerable<WSMaintainCreateOrConnectWithoutMachineInput>
    upsert?: Enumerable<WSMaintainUpsertWithWhereUniqueWithoutMachineInput>
    createMany?: WSMaintainCreateManyMachineInputEnvelope
    set?: Enumerable<WSMaintainWhereUniqueInput>
    disconnect?: Enumerable<WSMaintainWhereUniqueInput>
    delete?: Enumerable<WSMaintainWhereUniqueInput>
    connect?: Enumerable<WSMaintainWhereUniqueInput>
    update?: Enumerable<WSMaintainUpdateWithWhereUniqueWithoutMachineInput>
    updateMany?: Enumerable<WSMaintainUpdateManyWithWhereWithoutMachineInput>
    deleteMany?: Enumerable<WSMaintainScalarWhereInput>
  }

  export type WSUsingHistoryUpdateManyWithoutMachineNestedInput = {
    create?: XOR<Enumerable<WSUsingHistoryCreateWithoutMachineInput>, Enumerable<WSUsingHistoryUncheckedCreateWithoutMachineInput>>
    connectOrCreate?: Enumerable<WSUsingHistoryCreateOrConnectWithoutMachineInput>
    upsert?: Enumerable<WSUsingHistoryUpsertWithWhereUniqueWithoutMachineInput>
    createMany?: WSUsingHistoryCreateManyMachineInputEnvelope
    set?: Enumerable<WSUsingHistoryWhereUniqueInput>
    disconnect?: Enumerable<WSUsingHistoryWhereUniqueInput>
    delete?: Enumerable<WSUsingHistoryWhereUniqueInput>
    connect?: Enumerable<WSUsingHistoryWhereUniqueInput>
    update?: Enumerable<WSUsingHistoryUpdateWithWhereUniqueWithoutMachineInput>
    updateMany?: Enumerable<WSUsingHistoryUpdateManyWithWhereWithoutMachineInput>
    deleteMany?: Enumerable<WSUsingHistoryScalarWhereInput>
  }

  export type MachineToProgramUncheckedUpdateManyWithoutMachingNestedInput = {
    create?: XOR<Enumerable<MachineToProgramCreateWithoutMachingInput>, Enumerable<MachineToProgramUncheckedCreateWithoutMachingInput>>
    connectOrCreate?: Enumerable<MachineToProgramCreateOrConnectWithoutMachingInput>
    upsert?: Enumerable<MachineToProgramUpsertWithWhereUniqueWithoutMachingInput>
    createMany?: MachineToProgramCreateManyMachingInputEnvelope
    set?: Enumerable<MachineToProgramWhereUniqueInput>
    disconnect?: Enumerable<MachineToProgramWhereUniqueInput>
    delete?: Enumerable<MachineToProgramWhereUniqueInput>
    connect?: Enumerable<MachineToProgramWhereUniqueInput>
    update?: Enumerable<MachineToProgramUpdateWithWhereUniqueWithoutMachingInput>
    updateMany?: Enumerable<MachineToProgramUpdateManyWithWhereWithoutMachingInput>
    deleteMany?: Enumerable<MachineToProgramScalarWhereInput>
  }

  export type WSMaintainUncheckedUpdateManyWithoutMachineNestedInput = {
    create?: XOR<Enumerable<WSMaintainCreateWithoutMachineInput>, Enumerable<WSMaintainUncheckedCreateWithoutMachineInput>>
    connectOrCreate?: Enumerable<WSMaintainCreateOrConnectWithoutMachineInput>
    upsert?: Enumerable<WSMaintainUpsertWithWhereUniqueWithoutMachineInput>
    createMany?: WSMaintainCreateManyMachineInputEnvelope
    set?: Enumerable<WSMaintainWhereUniqueInput>
    disconnect?: Enumerable<WSMaintainWhereUniqueInput>
    delete?: Enumerable<WSMaintainWhereUniqueInput>
    connect?: Enumerable<WSMaintainWhereUniqueInput>
    update?: Enumerable<WSMaintainUpdateWithWhereUniqueWithoutMachineInput>
    updateMany?: Enumerable<WSMaintainUpdateManyWithWhereWithoutMachineInput>
    deleteMany?: Enumerable<WSMaintainScalarWhereInput>
  }

  export type WSUsingHistoryUncheckedUpdateManyWithoutMachineNestedInput = {
    create?: XOR<Enumerable<WSUsingHistoryCreateWithoutMachineInput>, Enumerable<WSUsingHistoryUncheckedCreateWithoutMachineInput>>
    connectOrCreate?: Enumerable<WSUsingHistoryCreateOrConnectWithoutMachineInput>
    upsert?: Enumerable<WSUsingHistoryUpsertWithWhereUniqueWithoutMachineInput>
    createMany?: WSUsingHistoryCreateManyMachineInputEnvelope
    set?: Enumerable<WSUsingHistoryWhereUniqueInput>
    disconnect?: Enumerable<WSUsingHistoryWhereUniqueInput>
    delete?: Enumerable<WSUsingHistoryWhereUniqueInput>
    connect?: Enumerable<WSUsingHistoryWhereUniqueInput>
    update?: Enumerable<WSUsingHistoryUpdateWithWhereUniqueWithoutMachineInput>
    updateMany?: Enumerable<WSUsingHistoryUpdateManyWithWhereWithoutMachineInput>
    deleteMany?: Enumerable<WSUsingHistoryScalarWhereInput>
  }

  export type MachineToProgramCreateNestedManyWithoutProgramInput = {
    create?: XOR<Enumerable<MachineToProgramCreateWithoutProgramInput>, Enumerable<MachineToProgramUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<MachineToProgramCreateOrConnectWithoutProgramInput>
    createMany?: MachineToProgramCreateManyProgramInputEnvelope
    connect?: Enumerable<MachineToProgramWhereUniqueInput>
  }

  export type WSProgramDetailCreateNestedManyWithoutProgramInput = {
    create?: XOR<Enumerable<WSProgramDetailCreateWithoutProgramInput>, Enumerable<WSProgramDetailUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<WSProgramDetailCreateOrConnectWithoutProgramInput>
    createMany?: WSProgramDetailCreateManyProgramInputEnvelope
    connect?: Enumerable<WSProgramDetailWhereUniqueInput>
  }

  export type WSProgramDetailCreateNestedOneWithoutProgramsInput = {
    create?: XOR<WSProgramDetailCreateWithoutProgramsInput, WSProgramDetailUncheckedCreateWithoutProgramsInput>
    connectOrCreate?: WSProgramDetailCreateOrConnectWithoutProgramsInput
    connect?: WSProgramDetailWhereUniqueInput
  }

  export type WSUsingHistoryCreateNestedManyWithoutProgramInput = {
    create?: XOR<Enumerable<WSUsingHistoryCreateWithoutProgramInput>, Enumerable<WSUsingHistoryUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<WSUsingHistoryCreateOrConnectWithoutProgramInput>
    createMany?: WSUsingHistoryCreateManyProgramInputEnvelope
    connect?: Enumerable<WSUsingHistoryWhereUniqueInput>
  }

  export type MachineToProgramUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<Enumerable<MachineToProgramCreateWithoutProgramInput>, Enumerable<MachineToProgramUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<MachineToProgramCreateOrConnectWithoutProgramInput>
    createMany?: MachineToProgramCreateManyProgramInputEnvelope
    connect?: Enumerable<MachineToProgramWhereUniqueInput>
  }

  export type WSProgramDetailUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<Enumerable<WSProgramDetailCreateWithoutProgramInput>, Enumerable<WSProgramDetailUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<WSProgramDetailCreateOrConnectWithoutProgramInput>
    createMany?: WSProgramDetailCreateManyProgramInputEnvelope
    connect?: Enumerable<WSProgramDetailWhereUniqueInput>
  }

  export type WSUsingHistoryUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<Enumerable<WSUsingHistoryCreateWithoutProgramInput>, Enumerable<WSUsingHistoryUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<WSUsingHistoryCreateOrConnectWithoutProgramInput>
    createMany?: WSUsingHistoryCreateManyProgramInputEnvelope
    connect?: Enumerable<WSUsingHistoryWhereUniqueInput>
  }

  export type MachineToProgramUpdateManyWithoutProgramNestedInput = {
    create?: XOR<Enumerable<MachineToProgramCreateWithoutProgramInput>, Enumerable<MachineToProgramUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<MachineToProgramCreateOrConnectWithoutProgramInput>
    upsert?: Enumerable<MachineToProgramUpsertWithWhereUniqueWithoutProgramInput>
    createMany?: MachineToProgramCreateManyProgramInputEnvelope
    set?: Enumerable<MachineToProgramWhereUniqueInput>
    disconnect?: Enumerable<MachineToProgramWhereUniqueInput>
    delete?: Enumerable<MachineToProgramWhereUniqueInput>
    connect?: Enumerable<MachineToProgramWhereUniqueInput>
    update?: Enumerable<MachineToProgramUpdateWithWhereUniqueWithoutProgramInput>
    updateMany?: Enumerable<MachineToProgramUpdateManyWithWhereWithoutProgramInput>
    deleteMany?: Enumerable<MachineToProgramScalarWhereInput>
  }

  export type WSProgramDetailUpdateManyWithoutProgramNestedInput = {
    create?: XOR<Enumerable<WSProgramDetailCreateWithoutProgramInput>, Enumerable<WSProgramDetailUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<WSProgramDetailCreateOrConnectWithoutProgramInput>
    upsert?: Enumerable<WSProgramDetailUpsertWithWhereUniqueWithoutProgramInput>
    createMany?: WSProgramDetailCreateManyProgramInputEnvelope
    set?: Enumerable<WSProgramDetailWhereUniqueInput>
    disconnect?: Enumerable<WSProgramDetailWhereUniqueInput>
    delete?: Enumerable<WSProgramDetailWhereUniqueInput>
    connect?: Enumerable<WSProgramDetailWhereUniqueInput>
    update?: Enumerable<WSProgramDetailUpdateWithWhereUniqueWithoutProgramInput>
    updateMany?: Enumerable<WSProgramDetailUpdateManyWithWhereWithoutProgramInput>
    deleteMany?: Enumerable<WSProgramDetailScalarWhereInput>
  }

  export type WSProgramDetailUpdateOneRequiredWithoutProgramsNestedInput = {
    create?: XOR<WSProgramDetailCreateWithoutProgramsInput, WSProgramDetailUncheckedCreateWithoutProgramsInput>
    connectOrCreate?: WSProgramDetailCreateOrConnectWithoutProgramsInput
    upsert?: WSProgramDetailUpsertWithoutProgramsInput
    connect?: WSProgramDetailWhereUniqueInput
    update?: XOR<WSProgramDetailUpdateWithoutProgramsInput, WSProgramDetailUncheckedUpdateWithoutProgramsInput>
  }

  export type WSUsingHistoryUpdateManyWithoutProgramNestedInput = {
    create?: XOR<Enumerable<WSUsingHistoryCreateWithoutProgramInput>, Enumerable<WSUsingHistoryUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<WSUsingHistoryCreateOrConnectWithoutProgramInput>
    upsert?: Enumerable<WSUsingHistoryUpsertWithWhereUniqueWithoutProgramInput>
    createMany?: WSUsingHistoryCreateManyProgramInputEnvelope
    set?: Enumerable<WSUsingHistoryWhereUniqueInput>
    disconnect?: Enumerable<WSUsingHistoryWhereUniqueInput>
    delete?: Enumerable<WSUsingHistoryWhereUniqueInput>
    connect?: Enumerable<WSUsingHistoryWhereUniqueInput>
    update?: Enumerable<WSUsingHistoryUpdateWithWhereUniqueWithoutProgramInput>
    updateMany?: Enumerable<WSUsingHistoryUpdateManyWithWhereWithoutProgramInput>
    deleteMany?: Enumerable<WSUsingHistoryScalarWhereInput>
  }

  export type MachineToProgramUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<Enumerable<MachineToProgramCreateWithoutProgramInput>, Enumerable<MachineToProgramUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<MachineToProgramCreateOrConnectWithoutProgramInput>
    upsert?: Enumerable<MachineToProgramUpsertWithWhereUniqueWithoutProgramInput>
    createMany?: MachineToProgramCreateManyProgramInputEnvelope
    set?: Enumerable<MachineToProgramWhereUniqueInput>
    disconnect?: Enumerable<MachineToProgramWhereUniqueInput>
    delete?: Enumerable<MachineToProgramWhereUniqueInput>
    connect?: Enumerable<MachineToProgramWhereUniqueInput>
    update?: Enumerable<MachineToProgramUpdateWithWhereUniqueWithoutProgramInput>
    updateMany?: Enumerable<MachineToProgramUpdateManyWithWhereWithoutProgramInput>
    deleteMany?: Enumerable<MachineToProgramScalarWhereInput>
  }

  export type WSProgramDetailUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<Enumerable<WSProgramDetailCreateWithoutProgramInput>, Enumerable<WSProgramDetailUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<WSProgramDetailCreateOrConnectWithoutProgramInput>
    upsert?: Enumerable<WSProgramDetailUpsertWithWhereUniqueWithoutProgramInput>
    createMany?: WSProgramDetailCreateManyProgramInputEnvelope
    set?: Enumerable<WSProgramDetailWhereUniqueInput>
    disconnect?: Enumerable<WSProgramDetailWhereUniqueInput>
    delete?: Enumerable<WSProgramDetailWhereUniqueInput>
    connect?: Enumerable<WSProgramDetailWhereUniqueInput>
    update?: Enumerable<WSProgramDetailUpdateWithWhereUniqueWithoutProgramInput>
    updateMany?: Enumerable<WSProgramDetailUpdateManyWithWhereWithoutProgramInput>
    deleteMany?: Enumerable<WSProgramDetailScalarWhereInput>
  }

  export type WSUsingHistoryUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<Enumerable<WSUsingHistoryCreateWithoutProgramInput>, Enumerable<WSUsingHistoryUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<WSUsingHistoryCreateOrConnectWithoutProgramInput>
    upsert?: Enumerable<WSUsingHistoryUpsertWithWhereUniqueWithoutProgramInput>
    createMany?: WSUsingHistoryCreateManyProgramInputEnvelope
    set?: Enumerable<WSUsingHistoryWhereUniqueInput>
    disconnect?: Enumerable<WSUsingHistoryWhereUniqueInput>
    delete?: Enumerable<WSUsingHistoryWhereUniqueInput>
    connect?: Enumerable<WSUsingHistoryWhereUniqueInput>
    update?: Enumerable<WSUsingHistoryUpdateWithWhereUniqueWithoutProgramInput>
    updateMany?: Enumerable<WSUsingHistoryUpdateManyWithWhereWithoutProgramInput>
    deleteMany?: Enumerable<WSUsingHistoryScalarWhereInput>
  }

  export type WSMachineCreateNestedOneWithoutMachineToProgramsInput = {
    create?: XOR<WSMachineCreateWithoutMachineToProgramsInput, WSMachineUncheckedCreateWithoutMachineToProgramsInput>
    connectOrCreate?: WSMachineCreateOrConnectWithoutMachineToProgramsInput
    connect?: WSMachineWhereUniqueInput
  }

  export type WSProgramCreateNestedOneWithoutMachineToProgramsInput = {
    create?: XOR<WSProgramCreateWithoutMachineToProgramsInput, WSProgramUncheckedCreateWithoutMachineToProgramsInput>
    connectOrCreate?: WSProgramCreateOrConnectWithoutMachineToProgramsInput
    connect?: WSProgramWhereUniqueInput
  }

  export type WSMachineUpdateOneRequiredWithoutMachineToProgramsNestedInput = {
    create?: XOR<WSMachineCreateWithoutMachineToProgramsInput, WSMachineUncheckedCreateWithoutMachineToProgramsInput>
    connectOrCreate?: WSMachineCreateOrConnectWithoutMachineToProgramsInput
    upsert?: WSMachineUpsertWithoutMachineToProgramsInput
    connect?: WSMachineWhereUniqueInput
    update?: XOR<WSMachineUpdateWithoutMachineToProgramsInput, WSMachineUncheckedUpdateWithoutMachineToProgramsInput>
  }

  export type WSProgramUpdateOneRequiredWithoutMachineToProgramsNestedInput = {
    create?: XOR<WSProgramCreateWithoutMachineToProgramsInput, WSProgramUncheckedCreateWithoutMachineToProgramsInput>
    connectOrCreate?: WSProgramCreateOrConnectWithoutMachineToProgramsInput
    upsert?: WSProgramUpsertWithoutMachineToProgramsInput
    connect?: WSProgramWhereUniqueInput
    update?: XOR<WSProgramUpdateWithoutMachineToProgramsInput, WSProgramUncheckedUpdateWithoutMachineToProgramsInput>
  }

  export type WSProgramCreateNestedOneWithoutProgramListsInput = {
    create?: XOR<WSProgramCreateWithoutProgramListsInput, WSProgramUncheckedCreateWithoutProgramListsInput>
    connectOrCreate?: WSProgramCreateOrConnectWithoutProgramListsInput
    connect?: WSProgramWhereUniqueInput
  }

  export type WSProgramCreateNestedManyWithoutActiveProgramInput = {
    create?: XOR<Enumerable<WSProgramCreateWithoutActiveProgramInput>, Enumerable<WSProgramUncheckedCreateWithoutActiveProgramInput>>
    connectOrCreate?: Enumerable<WSProgramCreateOrConnectWithoutActiveProgramInput>
    createMany?: WSProgramCreateManyActiveProgramInputEnvelope
    connect?: Enumerable<WSProgramWhereUniqueInput>
  }

  export type WSProgramUncheckedCreateNestedManyWithoutActiveProgramInput = {
    create?: XOR<Enumerable<WSProgramCreateWithoutActiveProgramInput>, Enumerable<WSProgramUncheckedCreateWithoutActiveProgramInput>>
    connectOrCreate?: Enumerable<WSProgramCreateOrConnectWithoutActiveProgramInput>
    createMany?: WSProgramCreateManyActiveProgramInputEnvelope
    connect?: Enumerable<WSProgramWhereUniqueInput>
  }

  export type WSProgramUpdateOneRequiredWithoutProgramListsNestedInput = {
    create?: XOR<WSProgramCreateWithoutProgramListsInput, WSProgramUncheckedCreateWithoutProgramListsInput>
    connectOrCreate?: WSProgramCreateOrConnectWithoutProgramListsInput
    upsert?: WSProgramUpsertWithoutProgramListsInput
    connect?: WSProgramWhereUniqueInput
    update?: XOR<WSProgramUpdateWithoutProgramListsInput, WSProgramUncheckedUpdateWithoutProgramListsInput>
  }

  export type WSProgramUpdateManyWithoutActiveProgramNestedInput = {
    create?: XOR<Enumerable<WSProgramCreateWithoutActiveProgramInput>, Enumerable<WSProgramUncheckedCreateWithoutActiveProgramInput>>
    connectOrCreate?: Enumerable<WSProgramCreateOrConnectWithoutActiveProgramInput>
    upsert?: Enumerable<WSProgramUpsertWithWhereUniqueWithoutActiveProgramInput>
    createMany?: WSProgramCreateManyActiveProgramInputEnvelope
    set?: Enumerable<WSProgramWhereUniqueInput>
    disconnect?: Enumerable<WSProgramWhereUniqueInput>
    delete?: Enumerable<WSProgramWhereUniqueInput>
    connect?: Enumerable<WSProgramWhereUniqueInput>
    update?: Enumerable<WSProgramUpdateWithWhereUniqueWithoutActiveProgramInput>
    updateMany?: Enumerable<WSProgramUpdateManyWithWhereWithoutActiveProgramInput>
    deleteMany?: Enumerable<WSProgramScalarWhereInput>
  }

  export type WSProgramUncheckedUpdateManyWithoutActiveProgramNestedInput = {
    create?: XOR<Enumerable<WSProgramCreateWithoutActiveProgramInput>, Enumerable<WSProgramUncheckedCreateWithoutActiveProgramInput>>
    connectOrCreate?: Enumerable<WSProgramCreateOrConnectWithoutActiveProgramInput>
    upsert?: Enumerable<WSProgramUpsertWithWhereUniqueWithoutActiveProgramInput>
    createMany?: WSProgramCreateManyActiveProgramInputEnvelope
    set?: Enumerable<WSProgramWhereUniqueInput>
    disconnect?: Enumerable<WSProgramWhereUniqueInput>
    delete?: Enumerable<WSProgramWhereUniqueInput>
    connect?: Enumerable<WSProgramWhereUniqueInput>
    update?: Enumerable<WSProgramUpdateWithWhereUniqueWithoutActiveProgramInput>
    updateMany?: Enumerable<WSProgramUpdateManyWithWhereWithoutActiveProgramInput>
    deleteMany?: Enumerable<WSProgramScalarWhereInput>
  }

  export type WSMachineCreateNestedOneWithoutMaintainsInput = {
    create?: XOR<WSMachineCreateWithoutMaintainsInput, WSMachineUncheckedCreateWithoutMaintainsInput>
    connectOrCreate?: WSMachineCreateOrConnectWithoutMaintainsInput
    connect?: WSMachineWhereUniqueInput
  }

  export type WSMachineUpdateOneRequiredWithoutMaintainsNestedInput = {
    create?: XOR<WSMachineCreateWithoutMaintainsInput, WSMachineUncheckedCreateWithoutMaintainsInput>
    connectOrCreate?: WSMachineCreateOrConnectWithoutMaintainsInput
    upsert?: WSMachineUpsertWithoutMaintainsInput
    connect?: WSMachineWhereUniqueInput
    update?: XOR<WSMachineUpdateWithoutMaintainsInput, WSMachineUncheckedUpdateWithoutMaintainsInput>
  }

  export type UserToChannelCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserToChannelCreateWithoutUserInput>, Enumerable<UserToChannelUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserToChannelCreateOrConnectWithoutUserInput>
    createMany?: UserToChannelCreateManyUserInputEnvelope
    connect?: Enumerable<UserToChannelWhereUniqueInput>
  }

  export type YTCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<YTCommentCreateWithoutUserInput>, Enumerable<YTCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YTCommentCreateOrConnectWithoutUserInput>
    createMany?: YTCommentCreateManyUserInputEnvelope
    connect?: Enumerable<YTCommentWhereUniqueInput>
  }

  export type YTSubscribeCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<YTSubscribeCreateWithoutUserInput>, Enumerable<YTSubscribeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YTSubscribeCreateOrConnectWithoutUserInput>
    createMany?: YTSubscribeCreateManyUserInputEnvelope
    connect?: Enumerable<YTSubscribeWhereUniqueInput>
  }

  export type YTShareCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<YTShareCreateWithoutUserInput>, Enumerable<YTShareUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YTShareCreateOrConnectWithoutUserInput>
    createMany?: YTShareCreateManyUserInputEnvelope
    connect?: Enumerable<YTShareWhereUniqueInput>
  }

  export type UserToChannelUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserToChannelCreateWithoutUserInput>, Enumerable<UserToChannelUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserToChannelCreateOrConnectWithoutUserInput>
    createMany?: UserToChannelCreateManyUserInputEnvelope
    connect?: Enumerable<UserToChannelWhereUniqueInput>
  }

  export type YTCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<YTCommentCreateWithoutUserInput>, Enumerable<YTCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YTCommentCreateOrConnectWithoutUserInput>
    createMany?: YTCommentCreateManyUserInputEnvelope
    connect?: Enumerable<YTCommentWhereUniqueInput>
  }

  export type YTSubscribeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<YTSubscribeCreateWithoutUserInput>, Enumerable<YTSubscribeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YTSubscribeCreateOrConnectWithoutUserInput>
    createMany?: YTSubscribeCreateManyUserInputEnvelope
    connect?: Enumerable<YTSubscribeWhereUniqueInput>
  }

  export type YTShareUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<YTShareCreateWithoutUserInput>, Enumerable<YTShareUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YTShareCreateOrConnectWithoutUserInput>
    createMany?: YTShareCreateManyUserInputEnvelope
    connect?: Enumerable<YTShareWhereUniqueInput>
  }

  export type UserToChannelUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserToChannelCreateWithoutUserInput>, Enumerable<UserToChannelUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserToChannelCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserToChannelUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserToChannelCreateManyUserInputEnvelope
    set?: Enumerable<UserToChannelWhereUniqueInput>
    disconnect?: Enumerable<UserToChannelWhereUniqueInput>
    delete?: Enumerable<UserToChannelWhereUniqueInput>
    connect?: Enumerable<UserToChannelWhereUniqueInput>
    update?: Enumerable<UserToChannelUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserToChannelUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserToChannelScalarWhereInput>
  }

  export type YTCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<YTCommentCreateWithoutUserInput>, Enumerable<YTCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YTCommentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<YTCommentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: YTCommentCreateManyUserInputEnvelope
    set?: Enumerable<YTCommentWhereUniqueInput>
    disconnect?: Enumerable<YTCommentWhereUniqueInput>
    delete?: Enumerable<YTCommentWhereUniqueInput>
    connect?: Enumerable<YTCommentWhereUniqueInput>
    update?: Enumerable<YTCommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<YTCommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<YTCommentScalarWhereInput>
  }

  export type YTSubscribeUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<YTSubscribeCreateWithoutUserInput>, Enumerable<YTSubscribeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YTSubscribeCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<YTSubscribeUpsertWithWhereUniqueWithoutUserInput>
    createMany?: YTSubscribeCreateManyUserInputEnvelope
    set?: Enumerable<YTSubscribeWhereUniqueInput>
    disconnect?: Enumerable<YTSubscribeWhereUniqueInput>
    delete?: Enumerable<YTSubscribeWhereUniqueInput>
    connect?: Enumerable<YTSubscribeWhereUniqueInput>
    update?: Enumerable<YTSubscribeUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<YTSubscribeUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<YTSubscribeScalarWhereInput>
  }

  export type YTShareUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<YTShareCreateWithoutUserInput>, Enumerable<YTShareUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YTShareCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<YTShareUpsertWithWhereUniqueWithoutUserInput>
    createMany?: YTShareCreateManyUserInputEnvelope
    set?: Enumerable<YTShareWhereUniqueInput>
    disconnect?: Enumerable<YTShareWhereUniqueInput>
    delete?: Enumerable<YTShareWhereUniqueInput>
    connect?: Enumerable<YTShareWhereUniqueInput>
    update?: Enumerable<YTShareUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<YTShareUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<YTShareScalarWhereInput>
  }

  export type UserToChannelUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserToChannelCreateWithoutUserInput>, Enumerable<UserToChannelUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserToChannelCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserToChannelUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserToChannelCreateManyUserInputEnvelope
    set?: Enumerable<UserToChannelWhereUniqueInput>
    disconnect?: Enumerable<UserToChannelWhereUniqueInput>
    delete?: Enumerable<UserToChannelWhereUniqueInput>
    connect?: Enumerable<UserToChannelWhereUniqueInput>
    update?: Enumerable<UserToChannelUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserToChannelUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserToChannelScalarWhereInput>
  }

  export type YTCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<YTCommentCreateWithoutUserInput>, Enumerable<YTCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YTCommentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<YTCommentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: YTCommentCreateManyUserInputEnvelope
    set?: Enumerable<YTCommentWhereUniqueInput>
    disconnect?: Enumerable<YTCommentWhereUniqueInput>
    delete?: Enumerable<YTCommentWhereUniqueInput>
    connect?: Enumerable<YTCommentWhereUniqueInput>
    update?: Enumerable<YTCommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<YTCommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<YTCommentScalarWhereInput>
  }

  export type YTSubscribeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<YTSubscribeCreateWithoutUserInput>, Enumerable<YTSubscribeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YTSubscribeCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<YTSubscribeUpsertWithWhereUniqueWithoutUserInput>
    createMany?: YTSubscribeCreateManyUserInputEnvelope
    set?: Enumerable<YTSubscribeWhereUniqueInput>
    disconnect?: Enumerable<YTSubscribeWhereUniqueInput>
    delete?: Enumerable<YTSubscribeWhereUniqueInput>
    connect?: Enumerable<YTSubscribeWhereUniqueInput>
    update?: Enumerable<YTSubscribeUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<YTSubscribeUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<YTSubscribeScalarWhereInput>
  }

  export type YTShareUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<YTShareCreateWithoutUserInput>, Enumerable<YTShareUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YTShareCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<YTShareUpsertWithWhereUniqueWithoutUserInput>
    createMany?: YTShareCreateManyUserInputEnvelope
    set?: Enumerable<YTShareWhereUniqueInput>
    disconnect?: Enumerable<YTShareWhereUniqueInput>
    delete?: Enumerable<YTShareWhereUniqueInput>
    connect?: Enumerable<YTShareWhereUniqueInput>
    update?: Enumerable<YTShareUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<YTShareUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<YTShareScalarWhereInput>
  }

  export type UserToChannelCreateNestedManyWithoutChannelInput = {
    create?: XOR<Enumerable<UserToChannelCreateWithoutChannelInput>, Enumerable<UserToChannelUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<UserToChannelCreateOrConnectWithoutChannelInput>
    createMany?: UserToChannelCreateManyChannelInputEnvelope
    connect?: Enumerable<UserToChannelWhereUniqueInput>
  }

  export type YTVideoCreateNestedManyWithoutChannelInput = {
    create?: XOR<Enumerable<YTVideoCreateWithoutChannelInput>, Enumerable<YTVideoUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<YTVideoCreateOrConnectWithoutChannelInput>
    createMany?: YTVideoCreateManyChannelInputEnvelope
    connect?: Enumerable<YTVideoWhereUniqueInput>
  }

  export type YTSubscribeCreateNestedManyWithoutChannelInput = {
    create?: XOR<Enumerable<YTSubscribeCreateWithoutChannelInput>, Enumerable<YTSubscribeUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<YTSubscribeCreateOrConnectWithoutChannelInput>
    createMany?: YTSubscribeCreateManyChannelInputEnvelope
    connect?: Enumerable<YTSubscribeWhereUniqueInput>
  }

  export type UserToChannelUncheckedCreateNestedManyWithoutChannelInput = {
    create?: XOR<Enumerable<UserToChannelCreateWithoutChannelInput>, Enumerable<UserToChannelUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<UserToChannelCreateOrConnectWithoutChannelInput>
    createMany?: UserToChannelCreateManyChannelInputEnvelope
    connect?: Enumerable<UserToChannelWhereUniqueInput>
  }

  export type YTVideoUncheckedCreateNestedManyWithoutChannelInput = {
    create?: XOR<Enumerable<YTVideoCreateWithoutChannelInput>, Enumerable<YTVideoUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<YTVideoCreateOrConnectWithoutChannelInput>
    createMany?: YTVideoCreateManyChannelInputEnvelope
    connect?: Enumerable<YTVideoWhereUniqueInput>
  }

  export type YTSubscribeUncheckedCreateNestedManyWithoutChannelInput = {
    create?: XOR<Enumerable<YTSubscribeCreateWithoutChannelInput>, Enumerable<YTSubscribeUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<YTSubscribeCreateOrConnectWithoutChannelInput>
    createMany?: YTSubscribeCreateManyChannelInputEnvelope
    connect?: Enumerable<YTSubscribeWhereUniqueInput>
  }

  export type UserToChannelUpdateManyWithoutChannelNestedInput = {
    create?: XOR<Enumerable<UserToChannelCreateWithoutChannelInput>, Enumerable<UserToChannelUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<UserToChannelCreateOrConnectWithoutChannelInput>
    upsert?: Enumerable<UserToChannelUpsertWithWhereUniqueWithoutChannelInput>
    createMany?: UserToChannelCreateManyChannelInputEnvelope
    set?: Enumerable<UserToChannelWhereUniqueInput>
    disconnect?: Enumerable<UserToChannelWhereUniqueInput>
    delete?: Enumerable<UserToChannelWhereUniqueInput>
    connect?: Enumerable<UserToChannelWhereUniqueInput>
    update?: Enumerable<UserToChannelUpdateWithWhereUniqueWithoutChannelInput>
    updateMany?: Enumerable<UserToChannelUpdateManyWithWhereWithoutChannelInput>
    deleteMany?: Enumerable<UserToChannelScalarWhereInput>
  }

  export type YTVideoUpdateManyWithoutChannelNestedInput = {
    create?: XOR<Enumerable<YTVideoCreateWithoutChannelInput>, Enumerable<YTVideoUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<YTVideoCreateOrConnectWithoutChannelInput>
    upsert?: Enumerable<YTVideoUpsertWithWhereUniqueWithoutChannelInput>
    createMany?: YTVideoCreateManyChannelInputEnvelope
    set?: Enumerable<YTVideoWhereUniqueInput>
    disconnect?: Enumerable<YTVideoWhereUniqueInput>
    delete?: Enumerable<YTVideoWhereUniqueInput>
    connect?: Enumerable<YTVideoWhereUniqueInput>
    update?: Enumerable<YTVideoUpdateWithWhereUniqueWithoutChannelInput>
    updateMany?: Enumerable<YTVideoUpdateManyWithWhereWithoutChannelInput>
    deleteMany?: Enumerable<YTVideoScalarWhereInput>
  }

  export type YTSubscribeUpdateManyWithoutChannelNestedInput = {
    create?: XOR<Enumerable<YTSubscribeCreateWithoutChannelInput>, Enumerable<YTSubscribeUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<YTSubscribeCreateOrConnectWithoutChannelInput>
    upsert?: Enumerable<YTSubscribeUpsertWithWhereUniqueWithoutChannelInput>
    createMany?: YTSubscribeCreateManyChannelInputEnvelope
    set?: Enumerable<YTSubscribeWhereUniqueInput>
    disconnect?: Enumerable<YTSubscribeWhereUniqueInput>
    delete?: Enumerable<YTSubscribeWhereUniqueInput>
    connect?: Enumerable<YTSubscribeWhereUniqueInput>
    update?: Enumerable<YTSubscribeUpdateWithWhereUniqueWithoutChannelInput>
    updateMany?: Enumerable<YTSubscribeUpdateManyWithWhereWithoutChannelInput>
    deleteMany?: Enumerable<YTSubscribeScalarWhereInput>
  }

  export type UserToChannelUncheckedUpdateManyWithoutChannelNestedInput = {
    create?: XOR<Enumerable<UserToChannelCreateWithoutChannelInput>, Enumerable<UserToChannelUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<UserToChannelCreateOrConnectWithoutChannelInput>
    upsert?: Enumerable<UserToChannelUpsertWithWhereUniqueWithoutChannelInput>
    createMany?: UserToChannelCreateManyChannelInputEnvelope
    set?: Enumerable<UserToChannelWhereUniqueInput>
    disconnect?: Enumerable<UserToChannelWhereUniqueInput>
    delete?: Enumerable<UserToChannelWhereUniqueInput>
    connect?: Enumerable<UserToChannelWhereUniqueInput>
    update?: Enumerable<UserToChannelUpdateWithWhereUniqueWithoutChannelInput>
    updateMany?: Enumerable<UserToChannelUpdateManyWithWhereWithoutChannelInput>
    deleteMany?: Enumerable<UserToChannelScalarWhereInput>
  }

  export type YTVideoUncheckedUpdateManyWithoutChannelNestedInput = {
    create?: XOR<Enumerable<YTVideoCreateWithoutChannelInput>, Enumerable<YTVideoUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<YTVideoCreateOrConnectWithoutChannelInput>
    upsert?: Enumerable<YTVideoUpsertWithWhereUniqueWithoutChannelInput>
    createMany?: YTVideoCreateManyChannelInputEnvelope
    set?: Enumerable<YTVideoWhereUniqueInput>
    disconnect?: Enumerable<YTVideoWhereUniqueInput>
    delete?: Enumerable<YTVideoWhereUniqueInput>
    connect?: Enumerable<YTVideoWhereUniqueInput>
    update?: Enumerable<YTVideoUpdateWithWhereUniqueWithoutChannelInput>
    updateMany?: Enumerable<YTVideoUpdateManyWithWhereWithoutChannelInput>
    deleteMany?: Enumerable<YTVideoScalarWhereInput>
  }

  export type YTSubscribeUncheckedUpdateManyWithoutChannelNestedInput = {
    create?: XOR<Enumerable<YTSubscribeCreateWithoutChannelInput>, Enumerable<YTSubscribeUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<YTSubscribeCreateOrConnectWithoutChannelInput>
    upsert?: Enumerable<YTSubscribeUpsertWithWhereUniqueWithoutChannelInput>
    createMany?: YTSubscribeCreateManyChannelInputEnvelope
    set?: Enumerable<YTSubscribeWhereUniqueInput>
    disconnect?: Enumerable<YTSubscribeWhereUniqueInput>
    delete?: Enumerable<YTSubscribeWhereUniqueInput>
    connect?: Enumerable<YTSubscribeWhereUniqueInput>
    update?: Enumerable<YTSubscribeUpdateWithWhereUniqueWithoutChannelInput>
    updateMany?: Enumerable<YTSubscribeUpdateManyWithWhereWithoutChannelInput>
    deleteMany?: Enumerable<YTSubscribeScalarWhereInput>
  }

  export type YTUserCreateNestedOneWithoutUserToChannelsInput = {
    create?: XOR<YTUserCreateWithoutUserToChannelsInput, YTUserUncheckedCreateWithoutUserToChannelsInput>
    connectOrCreate?: YTUserCreateOrConnectWithoutUserToChannelsInput
    connect?: YTUserWhereUniqueInput
  }

  export type YTChannelCreateNestedOneWithoutUserToChannelsInput = {
    create?: XOR<YTChannelCreateWithoutUserToChannelsInput, YTChannelUncheckedCreateWithoutUserToChannelsInput>
    connectOrCreate?: YTChannelCreateOrConnectWithoutUserToChannelsInput
    connect?: YTChannelWhereUniqueInput
  }

  export type YTUserUpdateOneRequiredWithoutUserToChannelsNestedInput = {
    create?: XOR<YTUserCreateWithoutUserToChannelsInput, YTUserUncheckedCreateWithoutUserToChannelsInput>
    connectOrCreate?: YTUserCreateOrConnectWithoutUserToChannelsInput
    upsert?: YTUserUpsertWithoutUserToChannelsInput
    connect?: YTUserWhereUniqueInput
    update?: XOR<YTUserUpdateWithoutUserToChannelsInput, YTUserUncheckedUpdateWithoutUserToChannelsInput>
  }

  export type YTChannelUpdateOneRequiredWithoutUserToChannelsNestedInput = {
    create?: XOR<YTChannelCreateWithoutUserToChannelsInput, YTChannelUncheckedCreateWithoutUserToChannelsInput>
    connectOrCreate?: YTChannelCreateOrConnectWithoutUserToChannelsInput
    upsert?: YTChannelUpsertWithoutUserToChannelsInput
    connect?: YTChannelWhereUniqueInput
    update?: XOR<YTChannelUpdateWithoutUserToChannelsInput, YTChannelUncheckedUpdateWithoutUserToChannelsInput>
  }

  export type EnumYTRoleEnumFieldUpdateOperationsInput = {
    set?: YTRoleEnum
  }

  export type YTChannelCreateNestedOneWithoutVideosInput = {
    create?: XOR<YTChannelCreateWithoutVideosInput, YTChannelUncheckedCreateWithoutVideosInput>
    connectOrCreate?: YTChannelCreateOrConnectWithoutVideosInput
    connect?: YTChannelWhereUniqueInput
  }

  export type YTLikeCreateNestedManyWithoutVideoInput = {
    create?: XOR<Enumerable<YTLikeCreateWithoutVideoInput>, Enumerable<YTLikeUncheckedCreateWithoutVideoInput>>
    connectOrCreate?: Enumerable<YTLikeCreateOrConnectWithoutVideoInput>
    createMany?: YTLikeCreateManyVideoInputEnvelope
    connect?: Enumerable<YTLikeWhereUniqueInput>
  }

  export type YTCommentCreateNestedManyWithoutVideoInput = {
    create?: XOR<Enumerable<YTCommentCreateWithoutVideoInput>, Enumerable<YTCommentUncheckedCreateWithoutVideoInput>>
    connectOrCreate?: Enumerable<YTCommentCreateOrConnectWithoutVideoInput>
    createMany?: YTCommentCreateManyVideoInputEnvelope
    connect?: Enumerable<YTCommentWhereUniqueInput>
  }

  export type YTShareCreateNestedManyWithoutVideoInput = {
    create?: XOR<Enumerable<YTShareCreateWithoutVideoInput>, Enumerable<YTShareUncheckedCreateWithoutVideoInput>>
    connectOrCreate?: Enumerable<YTShareCreateOrConnectWithoutVideoInput>
    createMany?: YTShareCreateManyVideoInputEnvelope
    connect?: Enumerable<YTShareWhereUniqueInput>
  }

  export type YTLikeUncheckedCreateNestedManyWithoutVideoInput = {
    create?: XOR<Enumerable<YTLikeCreateWithoutVideoInput>, Enumerable<YTLikeUncheckedCreateWithoutVideoInput>>
    connectOrCreate?: Enumerable<YTLikeCreateOrConnectWithoutVideoInput>
    createMany?: YTLikeCreateManyVideoInputEnvelope
    connect?: Enumerable<YTLikeWhereUniqueInput>
  }

  export type YTCommentUncheckedCreateNestedManyWithoutVideoInput = {
    create?: XOR<Enumerable<YTCommentCreateWithoutVideoInput>, Enumerable<YTCommentUncheckedCreateWithoutVideoInput>>
    connectOrCreate?: Enumerable<YTCommentCreateOrConnectWithoutVideoInput>
    createMany?: YTCommentCreateManyVideoInputEnvelope
    connect?: Enumerable<YTCommentWhereUniqueInput>
  }

  export type YTShareUncheckedCreateNestedManyWithoutVideoInput = {
    create?: XOR<Enumerable<YTShareCreateWithoutVideoInput>, Enumerable<YTShareUncheckedCreateWithoutVideoInput>>
    connectOrCreate?: Enumerable<YTShareCreateOrConnectWithoutVideoInput>
    createMany?: YTShareCreateManyVideoInputEnvelope
    connect?: Enumerable<YTShareWhereUniqueInput>
  }

  export type YTChannelUpdateOneRequiredWithoutVideosNestedInput = {
    create?: XOR<YTChannelCreateWithoutVideosInput, YTChannelUncheckedCreateWithoutVideosInput>
    connectOrCreate?: YTChannelCreateOrConnectWithoutVideosInput
    upsert?: YTChannelUpsertWithoutVideosInput
    connect?: YTChannelWhereUniqueInput
    update?: XOR<YTChannelUpdateWithoutVideosInput, YTChannelUncheckedUpdateWithoutVideosInput>
  }

  export type YTLikeUpdateManyWithoutVideoNestedInput = {
    create?: XOR<Enumerable<YTLikeCreateWithoutVideoInput>, Enumerable<YTLikeUncheckedCreateWithoutVideoInput>>
    connectOrCreate?: Enumerable<YTLikeCreateOrConnectWithoutVideoInput>
    upsert?: Enumerable<YTLikeUpsertWithWhereUniqueWithoutVideoInput>
    createMany?: YTLikeCreateManyVideoInputEnvelope
    set?: Enumerable<YTLikeWhereUniqueInput>
    disconnect?: Enumerable<YTLikeWhereUniqueInput>
    delete?: Enumerable<YTLikeWhereUniqueInput>
    connect?: Enumerable<YTLikeWhereUniqueInput>
    update?: Enumerable<YTLikeUpdateWithWhereUniqueWithoutVideoInput>
    updateMany?: Enumerable<YTLikeUpdateManyWithWhereWithoutVideoInput>
    deleteMany?: Enumerable<YTLikeScalarWhereInput>
  }

  export type YTCommentUpdateManyWithoutVideoNestedInput = {
    create?: XOR<Enumerable<YTCommentCreateWithoutVideoInput>, Enumerable<YTCommentUncheckedCreateWithoutVideoInput>>
    connectOrCreate?: Enumerable<YTCommentCreateOrConnectWithoutVideoInput>
    upsert?: Enumerable<YTCommentUpsertWithWhereUniqueWithoutVideoInput>
    createMany?: YTCommentCreateManyVideoInputEnvelope
    set?: Enumerable<YTCommentWhereUniqueInput>
    disconnect?: Enumerable<YTCommentWhereUniqueInput>
    delete?: Enumerable<YTCommentWhereUniqueInput>
    connect?: Enumerable<YTCommentWhereUniqueInput>
    update?: Enumerable<YTCommentUpdateWithWhereUniqueWithoutVideoInput>
    updateMany?: Enumerable<YTCommentUpdateManyWithWhereWithoutVideoInput>
    deleteMany?: Enumerable<YTCommentScalarWhereInput>
  }

  export type YTShareUpdateManyWithoutVideoNestedInput = {
    create?: XOR<Enumerable<YTShareCreateWithoutVideoInput>, Enumerable<YTShareUncheckedCreateWithoutVideoInput>>
    connectOrCreate?: Enumerable<YTShareCreateOrConnectWithoutVideoInput>
    upsert?: Enumerable<YTShareUpsertWithWhereUniqueWithoutVideoInput>
    createMany?: YTShareCreateManyVideoInputEnvelope
    set?: Enumerable<YTShareWhereUniqueInput>
    disconnect?: Enumerable<YTShareWhereUniqueInput>
    delete?: Enumerable<YTShareWhereUniqueInput>
    connect?: Enumerable<YTShareWhereUniqueInput>
    update?: Enumerable<YTShareUpdateWithWhereUniqueWithoutVideoInput>
    updateMany?: Enumerable<YTShareUpdateManyWithWhereWithoutVideoInput>
    deleteMany?: Enumerable<YTShareScalarWhereInput>
  }

  export type YTLikeUncheckedUpdateManyWithoutVideoNestedInput = {
    create?: XOR<Enumerable<YTLikeCreateWithoutVideoInput>, Enumerable<YTLikeUncheckedCreateWithoutVideoInput>>
    connectOrCreate?: Enumerable<YTLikeCreateOrConnectWithoutVideoInput>
    upsert?: Enumerable<YTLikeUpsertWithWhereUniqueWithoutVideoInput>
    createMany?: YTLikeCreateManyVideoInputEnvelope
    set?: Enumerable<YTLikeWhereUniqueInput>
    disconnect?: Enumerable<YTLikeWhereUniqueInput>
    delete?: Enumerable<YTLikeWhereUniqueInput>
    connect?: Enumerable<YTLikeWhereUniqueInput>
    update?: Enumerable<YTLikeUpdateWithWhereUniqueWithoutVideoInput>
    updateMany?: Enumerable<YTLikeUpdateManyWithWhereWithoutVideoInput>
    deleteMany?: Enumerable<YTLikeScalarWhereInput>
  }

  export type YTCommentUncheckedUpdateManyWithoutVideoNestedInput = {
    create?: XOR<Enumerable<YTCommentCreateWithoutVideoInput>, Enumerable<YTCommentUncheckedCreateWithoutVideoInput>>
    connectOrCreate?: Enumerable<YTCommentCreateOrConnectWithoutVideoInput>
    upsert?: Enumerable<YTCommentUpsertWithWhereUniqueWithoutVideoInput>
    createMany?: YTCommentCreateManyVideoInputEnvelope
    set?: Enumerable<YTCommentWhereUniqueInput>
    disconnect?: Enumerable<YTCommentWhereUniqueInput>
    delete?: Enumerable<YTCommentWhereUniqueInput>
    connect?: Enumerable<YTCommentWhereUniqueInput>
    update?: Enumerable<YTCommentUpdateWithWhereUniqueWithoutVideoInput>
    updateMany?: Enumerable<YTCommentUpdateManyWithWhereWithoutVideoInput>
    deleteMany?: Enumerable<YTCommentScalarWhereInput>
  }

  export type YTShareUncheckedUpdateManyWithoutVideoNestedInput = {
    create?: XOR<Enumerable<YTShareCreateWithoutVideoInput>, Enumerable<YTShareUncheckedCreateWithoutVideoInput>>
    connectOrCreate?: Enumerable<YTShareCreateOrConnectWithoutVideoInput>
    upsert?: Enumerable<YTShareUpsertWithWhereUniqueWithoutVideoInput>
    createMany?: YTShareCreateManyVideoInputEnvelope
    set?: Enumerable<YTShareWhereUniqueInput>
    disconnect?: Enumerable<YTShareWhereUniqueInput>
    delete?: Enumerable<YTShareWhereUniqueInput>
    connect?: Enumerable<YTShareWhereUniqueInput>
    update?: Enumerable<YTShareUpdateWithWhereUniqueWithoutVideoInput>
    updateMany?: Enumerable<YTShareUpdateManyWithWhereWithoutVideoInput>
    deleteMany?: Enumerable<YTShareScalarWhereInput>
  }

  export type YTVideoCreateNestedOneWithoutLikesInput = {
    create?: XOR<YTVideoCreateWithoutLikesInput, YTVideoUncheckedCreateWithoutLikesInput>
    connectOrCreate?: YTVideoCreateOrConnectWithoutLikesInput
    connect?: YTVideoWhereUniqueInput
  }

  export type YTCommentCreateNestedOneWithoutLikesInput = {
    create?: XOR<YTCommentCreateWithoutLikesInput, YTCommentUncheckedCreateWithoutLikesInput>
    connectOrCreate?: YTCommentCreateOrConnectWithoutLikesInput
    connect?: YTCommentWhereUniqueInput
  }

  export type YTVideoUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<YTVideoCreateWithoutLikesInput, YTVideoUncheckedCreateWithoutLikesInput>
    connectOrCreate?: YTVideoCreateOrConnectWithoutLikesInput
    upsert?: YTVideoUpsertWithoutLikesInput
    connect?: YTVideoWhereUniqueInput
    update?: XOR<YTVideoUpdateWithoutLikesInput, YTVideoUncheckedUpdateWithoutLikesInput>
  }

  export type YTCommentUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<YTCommentCreateWithoutLikesInput, YTCommentUncheckedCreateWithoutLikesInput>
    connectOrCreate?: YTCommentCreateOrConnectWithoutLikesInput
    upsert?: YTCommentUpsertWithoutLikesInput
    connect?: YTCommentWhereUniqueInput
    update?: XOR<YTCommentUpdateWithoutLikesInput, YTCommentUncheckedUpdateWithoutLikesInput>
  }

  export type YTUserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<YTUserCreateWithoutCommentsInput, YTUserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: YTUserCreateOrConnectWithoutCommentsInput
    connect?: YTUserWhereUniqueInput
  }

  export type YTVideoCreateNestedOneWithoutCommentsInput = {
    create?: XOR<YTVideoCreateWithoutCommentsInput, YTVideoUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: YTVideoCreateOrConnectWithoutCommentsInput
    connect?: YTVideoWhereUniqueInput
  }

  export type YTLikeCreateNestedManyWithoutCommentInput = {
    create?: XOR<Enumerable<YTLikeCreateWithoutCommentInput>, Enumerable<YTLikeUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<YTLikeCreateOrConnectWithoutCommentInput>
    createMany?: YTLikeCreateManyCommentInputEnvelope
    connect?: Enumerable<YTLikeWhereUniqueInput>
  }

  export type YTLikeUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<Enumerable<YTLikeCreateWithoutCommentInput>, Enumerable<YTLikeUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<YTLikeCreateOrConnectWithoutCommentInput>
    createMany?: YTLikeCreateManyCommentInputEnvelope
    connect?: Enumerable<YTLikeWhereUniqueInput>
  }

  export type YTUserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<YTUserCreateWithoutCommentsInput, YTUserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: YTUserCreateOrConnectWithoutCommentsInput
    upsert?: YTUserUpsertWithoutCommentsInput
    connect?: YTUserWhereUniqueInput
    update?: XOR<YTUserUpdateWithoutCommentsInput, YTUserUncheckedUpdateWithoutCommentsInput>
  }

  export type YTVideoUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<YTVideoCreateWithoutCommentsInput, YTVideoUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: YTVideoCreateOrConnectWithoutCommentsInput
    upsert?: YTVideoUpsertWithoutCommentsInput
    connect?: YTVideoWhereUniqueInput
    update?: XOR<YTVideoUpdateWithoutCommentsInput, YTVideoUncheckedUpdateWithoutCommentsInput>
  }

  export type YTLikeUpdateManyWithoutCommentNestedInput = {
    create?: XOR<Enumerable<YTLikeCreateWithoutCommentInput>, Enumerable<YTLikeUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<YTLikeCreateOrConnectWithoutCommentInput>
    upsert?: Enumerable<YTLikeUpsertWithWhereUniqueWithoutCommentInput>
    createMany?: YTLikeCreateManyCommentInputEnvelope
    set?: Enumerable<YTLikeWhereUniqueInput>
    disconnect?: Enumerable<YTLikeWhereUniqueInput>
    delete?: Enumerable<YTLikeWhereUniqueInput>
    connect?: Enumerable<YTLikeWhereUniqueInput>
    update?: Enumerable<YTLikeUpdateWithWhereUniqueWithoutCommentInput>
    updateMany?: Enumerable<YTLikeUpdateManyWithWhereWithoutCommentInput>
    deleteMany?: Enumerable<YTLikeScalarWhereInput>
  }

  export type YTLikeUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<Enumerable<YTLikeCreateWithoutCommentInput>, Enumerable<YTLikeUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<YTLikeCreateOrConnectWithoutCommentInput>
    upsert?: Enumerable<YTLikeUpsertWithWhereUniqueWithoutCommentInput>
    createMany?: YTLikeCreateManyCommentInputEnvelope
    set?: Enumerable<YTLikeWhereUniqueInput>
    disconnect?: Enumerable<YTLikeWhereUniqueInput>
    delete?: Enumerable<YTLikeWhereUniqueInput>
    connect?: Enumerable<YTLikeWhereUniqueInput>
    update?: Enumerable<YTLikeUpdateWithWhereUniqueWithoutCommentInput>
    updateMany?: Enumerable<YTLikeUpdateManyWithWhereWithoutCommentInput>
    deleteMany?: Enumerable<YTLikeScalarWhereInput>
  }

  export type YTUserCreateNestedOneWithoutSubscribesInput = {
    create?: XOR<YTUserCreateWithoutSubscribesInput, YTUserUncheckedCreateWithoutSubscribesInput>
    connectOrCreate?: YTUserCreateOrConnectWithoutSubscribesInput
    connect?: YTUserWhereUniqueInput
  }

  export type YTChannelCreateNestedOneWithoutSubscribesInput = {
    create?: XOR<YTChannelCreateWithoutSubscribesInput, YTChannelUncheckedCreateWithoutSubscribesInput>
    connectOrCreate?: YTChannelCreateOrConnectWithoutSubscribesInput
    connect?: YTChannelWhereUniqueInput
  }

  export type YTUserUpdateOneRequiredWithoutSubscribesNestedInput = {
    create?: XOR<YTUserCreateWithoutSubscribesInput, YTUserUncheckedCreateWithoutSubscribesInput>
    connectOrCreate?: YTUserCreateOrConnectWithoutSubscribesInput
    upsert?: YTUserUpsertWithoutSubscribesInput
    connect?: YTUserWhereUniqueInput
    update?: XOR<YTUserUpdateWithoutSubscribesInput, YTUserUncheckedUpdateWithoutSubscribesInput>
  }

  export type YTChannelUpdateOneRequiredWithoutSubscribesNestedInput = {
    create?: XOR<YTChannelCreateWithoutSubscribesInput, YTChannelUncheckedCreateWithoutSubscribesInput>
    connectOrCreate?: YTChannelCreateOrConnectWithoutSubscribesInput
    upsert?: YTChannelUpsertWithoutSubscribesInput
    connect?: YTChannelWhereUniqueInput
    update?: XOR<YTChannelUpdateWithoutSubscribesInput, YTChannelUncheckedUpdateWithoutSubscribesInput>
  }

  export type YTUserCreateNestedOneWithoutSharesInput = {
    create?: XOR<YTUserCreateWithoutSharesInput, YTUserUncheckedCreateWithoutSharesInput>
    connectOrCreate?: YTUserCreateOrConnectWithoutSharesInput
    connect?: YTUserWhereUniqueInput
  }

  export type YTVideoCreateNestedOneWithoutSharesInput = {
    create?: XOR<YTVideoCreateWithoutSharesInput, YTVideoUncheckedCreateWithoutSharesInput>
    connectOrCreate?: YTVideoCreateOrConnectWithoutSharesInput
    connect?: YTVideoWhereUniqueInput
  }

  export type YTUserUpdateOneRequiredWithoutSharesNestedInput = {
    create?: XOR<YTUserCreateWithoutSharesInput, YTUserUncheckedCreateWithoutSharesInput>
    connectOrCreate?: YTUserCreateOrConnectWithoutSharesInput
    upsert?: YTUserUpsertWithoutSharesInput
    connect?: YTUserWhereUniqueInput
    update?: XOR<YTUserUpdateWithoutSharesInput, YTUserUncheckedUpdateWithoutSharesInput>
  }

  export type YTVideoUpdateOneRequiredWithoutSharesNestedInput = {
    create?: XOR<YTVideoCreateWithoutSharesInput, YTVideoUncheckedCreateWithoutSharesInput>
    connectOrCreate?: YTVideoCreateOrConnectWithoutSharesInput
    upsert?: YTVideoUpsertWithoutSharesInput
    connect?: YTVideoWhereUniqueInput
    update?: XOR<YTVideoUpdateWithoutSharesInput, YTVideoUncheckedUpdateWithoutSharesInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedEnumRequestStatusEnumFilter = {
    equals?: RequestStatusEnum
    in?: Enumerable<RequestStatusEnum>
    notIn?: Enumerable<RequestStatusEnum>
    not?: NestedEnumRequestStatusEnumFilter | RequestStatusEnum
  }

  export type NestedEnumRequestStatusEnumWithAggregatesFilter = {
    equals?: RequestStatusEnum
    in?: Enumerable<RequestStatusEnum>
    notIn?: Enumerable<RequestStatusEnum>
    not?: NestedEnumRequestStatusEnumWithAggregatesFilter | RequestStatusEnum
    _count?: NestedIntFilter
    _min?: NestedEnumRequestStatusEnumFilter
    _max?: NestedEnumRequestStatusEnumFilter
  }

  export type NestedEnumCopyStatusEnumFilter = {
    equals?: CopyStatusEnum
    in?: Enumerable<CopyStatusEnum>
    notIn?: Enumerable<CopyStatusEnum>
    not?: NestedEnumCopyStatusEnumFilter | CopyStatusEnum
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedEnumCopyStatusEnumWithAggregatesFilter = {
    equals?: CopyStatusEnum
    in?: Enumerable<CopyStatusEnum>
    notIn?: Enumerable<CopyStatusEnum>
    not?: NestedEnumCopyStatusEnumWithAggregatesFilter | CopyStatusEnum
    _count?: NestedIntFilter
    _min?: NestedEnumCopyStatusEnumFilter
    _max?: NestedEnumCopyStatusEnumFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedEnumYTRoleEnumFilter = {
    equals?: YTRoleEnum
    in?: Enumerable<YTRoleEnum>
    notIn?: Enumerable<YTRoleEnum>
    not?: NestedEnumYTRoleEnumFilter | YTRoleEnum
  }

  export type NestedEnumYTRoleEnumWithAggregatesFilter = {
    equals?: YTRoleEnum
    in?: Enumerable<YTRoleEnum>
    notIn?: Enumerable<YTRoleEnum>
    not?: NestedEnumYTRoleEnumWithAggregatesFilter | YTRoleEnum
    _count?: NestedIntFilter
    _min?: NestedEnumYTRoleEnumFilter
    _max?: NestedEnumYTRoleEnumFilter
  }

  export type BKUniversityCreateWithoutReserveUsersInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    universityToTitles?: UniversityToTitleCreateNestedManyWithoutUniversityInput
    fromRequest?: BKRequestCreateNestedManyWithoutFromInput
    toRequest?: BKRequestCreateNestedManyWithoutToInput
    BKBorrowingHistory?: BKBorrowingHistoryCreateNestedManyWithoutFromInput
  }

  export type BKUniversityUncheckedCreateWithoutReserveUsersInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    universityToTitles?: UniversityToTitleUncheckedCreateNestedManyWithoutUniversityInput
    fromRequest?: BKRequestUncheckedCreateNestedManyWithoutFromInput
    toRequest?: BKRequestUncheckedCreateNestedManyWithoutToInput
    BKBorrowingHistory?: BKBorrowingHistoryUncheckedCreateNestedManyWithoutFromInput
  }

  export type BKUniversityCreateOrConnectWithoutReserveUsersInput = {
    where: BKUniversityWhereUniqueInput
    create: XOR<BKUniversityCreateWithoutReserveUsersInput, BKUniversityUncheckedCreateWithoutReserveUsersInput>
  }

  export type BKRequestCreateWithoutUserInput = {
    copy: BKCopyCreateNestedOneWithoutRequestsInput
    from: BKUniversityCreateNestedOneWithoutFromRequestInput
    to: BKUniversityCreateNestedOneWithoutToRequestInput
    requestDate: Date | string
    status: RequestStatusEnum
    planRecievedDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BKRequestUncheckedCreateWithoutUserInput = {
    id?: number
    copyId: number
    fromUniversityId: number
    toUniversityId: number
    requestDate: Date | string
    status: RequestStatusEnum
    planRecievedDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BKRequestCreateOrConnectWithoutUserInput = {
    where: BKRequestWhereUniqueInput
    create: XOR<BKRequestCreateWithoutUserInput, BKRequestUncheckedCreateWithoutUserInput>
  }

  export type BKRequestCreateManyUserInputEnvelope = {
    data: Enumerable<BKRequestCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type BKBorrowingHistoryCreateWithoutUserInput = {
    copy: BKCopyCreateNestedOneWithoutBKBorrowingHistoryInput
    from: BKUniversityCreateNestedOneWithoutBKBorrowingHistoryInput
    borrowDate: Date | string
    returnDate: Date | string
    actualReturnDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BKBorrowingHistoryUncheckedCreateWithoutUserInput = {
    id?: number
    copyId: number
    fromUniversityId: number
    borrowDate: Date | string
    returnDate: Date | string
    actualReturnDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BKBorrowingHistoryCreateOrConnectWithoutUserInput = {
    where: BKBorrowingHistoryWhereUniqueInput
    create: XOR<BKBorrowingHistoryCreateWithoutUserInput, BKBorrowingHistoryUncheckedCreateWithoutUserInput>
  }

  export type BKBorrowingHistoryCreateManyUserInputEnvelope = {
    data: Enumerable<BKBorrowingHistoryCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type BKCopyCreateWithoutUserInput = {
    status: CopyStatusEnum
    title: BKTitleCreateNestedOneWithoutCopiesInput
    createdAt?: Date | string
    updatedAt?: Date | string
    requests?: BKRequestCreateNestedManyWithoutCopyInput
    BKBorrowingHistory?: BKBorrowingHistoryCreateNestedManyWithoutCopyInput
  }

  export type BKCopyUncheckedCreateWithoutUserInput = {
    id?: number
    status: CopyStatusEnum
    titleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    requests?: BKRequestUncheckedCreateNestedManyWithoutCopyInput
    BKBorrowingHistory?: BKBorrowingHistoryUncheckedCreateNestedManyWithoutCopyInput
  }

  export type BKCopyCreateOrConnectWithoutUserInput = {
    where: BKCopyWhereUniqueInput
    create: XOR<BKCopyCreateWithoutUserInput, BKCopyUncheckedCreateWithoutUserInput>
  }

  export type BKCopyCreateManyUserInputEnvelope = {
    data: Enumerable<BKCopyCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type BKUniversityUpsertWithoutReserveUsersInput = {
    update: XOR<BKUniversityUpdateWithoutReserveUsersInput, BKUniversityUncheckedUpdateWithoutReserveUsersInput>
    create: XOR<BKUniversityCreateWithoutReserveUsersInput, BKUniversityUncheckedCreateWithoutReserveUsersInput>
  }

  export type BKUniversityUpdateWithoutReserveUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    universityToTitles?: UniversityToTitleUpdateManyWithoutUniversityNestedInput
    fromRequest?: BKRequestUpdateManyWithoutFromNestedInput
    toRequest?: BKRequestUpdateManyWithoutToNestedInput
    BKBorrowingHistory?: BKBorrowingHistoryUpdateManyWithoutFromNestedInput
  }

  export type BKUniversityUncheckedUpdateWithoutReserveUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    universityToTitles?: UniversityToTitleUncheckedUpdateManyWithoutUniversityNestedInput
    fromRequest?: BKRequestUncheckedUpdateManyWithoutFromNestedInput
    toRequest?: BKRequestUncheckedUpdateManyWithoutToNestedInput
    BKBorrowingHistory?: BKBorrowingHistoryUncheckedUpdateManyWithoutFromNestedInput
  }

  export type BKRequestUpsertWithWhereUniqueWithoutUserInput = {
    where: BKRequestWhereUniqueInput
    update: XOR<BKRequestUpdateWithoutUserInput, BKRequestUncheckedUpdateWithoutUserInput>
    create: XOR<BKRequestCreateWithoutUserInput, BKRequestUncheckedCreateWithoutUserInput>
  }

  export type BKRequestUpdateWithWhereUniqueWithoutUserInput = {
    where: BKRequestWhereUniqueInput
    data: XOR<BKRequestUpdateWithoutUserInput, BKRequestUncheckedUpdateWithoutUserInput>
  }

  export type BKRequestUpdateManyWithWhereWithoutUserInput = {
    where: BKRequestScalarWhereInput
    data: XOR<BKRequestUpdateManyMutationInput, BKRequestUncheckedUpdateManyWithoutRequestsInput>
  }

  export type BKRequestScalarWhereInput = {
    AND?: Enumerable<BKRequestScalarWhereInput>
    OR?: Enumerable<BKRequestScalarWhereInput>
    NOT?: Enumerable<BKRequestScalarWhereInput>
    id?: IntFilter | number
    reserveUserId?: IntFilter | number
    copyId?: IntFilter | number
    fromUniversityId?: IntFilter | number
    toUniversityId?: IntFilter | number
    requestDate?: DateTimeFilter | Date | string
    status?: EnumRequestStatusEnumFilter | RequestStatusEnum
    planRecievedDate?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type BKBorrowingHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: BKBorrowingHistoryWhereUniqueInput
    update: XOR<BKBorrowingHistoryUpdateWithoutUserInput, BKBorrowingHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<BKBorrowingHistoryCreateWithoutUserInput, BKBorrowingHistoryUncheckedCreateWithoutUserInput>
  }

  export type BKBorrowingHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: BKBorrowingHistoryWhereUniqueInput
    data: XOR<BKBorrowingHistoryUpdateWithoutUserInput, BKBorrowingHistoryUncheckedUpdateWithoutUserInput>
  }

  export type BKBorrowingHistoryUpdateManyWithWhereWithoutUserInput = {
    where: BKBorrowingHistoryScalarWhereInput
    data: XOR<BKBorrowingHistoryUpdateManyMutationInput, BKBorrowingHistoryUncheckedUpdateManyWithoutBKBorrowingHistoryInput>
  }

  export type BKBorrowingHistoryScalarWhereInput = {
    AND?: Enumerable<BKBorrowingHistoryScalarWhereInput>
    OR?: Enumerable<BKBorrowingHistoryScalarWhereInput>
    NOT?: Enumerable<BKBorrowingHistoryScalarWhereInput>
    id?: IntFilter | number
    reserveUserId?: IntFilter | number
    copyId?: IntFilter | number
    fromUniversityId?: IntFilter | number
    borrowDate?: DateTimeFilter | Date | string
    returnDate?: DateTimeFilter | Date | string
    actualReturnDate?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type BKCopyUpsertWithWhereUniqueWithoutUserInput = {
    where: BKCopyWhereUniqueInput
    update: XOR<BKCopyUpdateWithoutUserInput, BKCopyUncheckedUpdateWithoutUserInput>
    create: XOR<BKCopyCreateWithoutUserInput, BKCopyUncheckedCreateWithoutUserInput>
  }

  export type BKCopyUpdateWithWhereUniqueWithoutUserInput = {
    where: BKCopyWhereUniqueInput
    data: XOR<BKCopyUpdateWithoutUserInput, BKCopyUncheckedUpdateWithoutUserInput>
  }

  export type BKCopyUpdateManyWithWhereWithoutUserInput = {
    where: BKCopyScalarWhereInput
    data: XOR<BKCopyUpdateManyMutationInput, BKCopyUncheckedUpdateManyWithoutBKCopyInput>
  }

  export type BKCopyScalarWhereInput = {
    AND?: Enumerable<BKCopyScalarWhereInput>
    OR?: Enumerable<BKCopyScalarWhereInput>
    NOT?: Enumerable<BKCopyScalarWhereInput>
    id?: IntFilter | number
    status?: EnumCopyStatusEnumFilter | CopyStatusEnum
    titleId?: IntFilter | number
    reserveUserId?: IntNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type BKReserveUserCreateWithoutRequestsInput = {
    university: BKUniversityCreateNestedOneWithoutReserveUsersInput
    createdAt?: Date | string
    updatedAt?: Date | string
    BKBorrowingHistory?: BKBorrowingHistoryCreateNestedManyWithoutUserInput
    BKCopy?: BKCopyCreateNestedManyWithoutUserInput
  }

  export type BKReserveUserUncheckedCreateWithoutRequestsInput = {
    id?: number
    universityId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    BKBorrowingHistory?: BKBorrowingHistoryUncheckedCreateNestedManyWithoutUserInput
    BKCopy?: BKCopyUncheckedCreateNestedManyWithoutUserInput
  }

  export type BKReserveUserCreateOrConnectWithoutRequestsInput = {
    where: BKReserveUserWhereUniqueInput
    create: XOR<BKReserveUserCreateWithoutRequestsInput, BKReserveUserUncheckedCreateWithoutRequestsInput>
  }

  export type BKCopyCreateWithoutRequestsInput = {
    status: CopyStatusEnum
    title: BKTitleCreateNestedOneWithoutCopiesInput
    user?: BKReserveUserCreateNestedOneWithoutBKCopyInput
    createdAt?: Date | string
    updatedAt?: Date | string
    BKBorrowingHistory?: BKBorrowingHistoryCreateNestedManyWithoutCopyInput
  }

  export type BKCopyUncheckedCreateWithoutRequestsInput = {
    id?: number
    status: CopyStatusEnum
    titleId: number
    reserveUserId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    BKBorrowingHistory?: BKBorrowingHistoryUncheckedCreateNestedManyWithoutCopyInput
  }

  export type BKCopyCreateOrConnectWithoutRequestsInput = {
    where: BKCopyWhereUniqueInput
    create: XOR<BKCopyCreateWithoutRequestsInput, BKCopyUncheckedCreateWithoutRequestsInput>
  }

  export type BKUniversityCreateWithoutFromRequestInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    universityToTitles?: UniversityToTitleCreateNestedManyWithoutUniversityInput
    reserveUsers?: BKReserveUserCreateNestedManyWithoutUniversityInput
    toRequest?: BKRequestCreateNestedManyWithoutToInput
    BKBorrowingHistory?: BKBorrowingHistoryCreateNestedManyWithoutFromInput
  }

  export type BKUniversityUncheckedCreateWithoutFromRequestInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    universityToTitles?: UniversityToTitleUncheckedCreateNestedManyWithoutUniversityInput
    reserveUsers?: BKReserveUserUncheckedCreateNestedManyWithoutUniversityInput
    toRequest?: BKRequestUncheckedCreateNestedManyWithoutToInput
    BKBorrowingHistory?: BKBorrowingHistoryUncheckedCreateNestedManyWithoutFromInput
  }

  export type BKUniversityCreateOrConnectWithoutFromRequestInput = {
    where: BKUniversityWhereUniqueInput
    create: XOR<BKUniversityCreateWithoutFromRequestInput, BKUniversityUncheckedCreateWithoutFromRequestInput>
  }

  export type BKUniversityCreateWithoutToRequestInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    universityToTitles?: UniversityToTitleCreateNestedManyWithoutUniversityInput
    reserveUsers?: BKReserveUserCreateNestedManyWithoutUniversityInput
    fromRequest?: BKRequestCreateNestedManyWithoutFromInput
    BKBorrowingHistory?: BKBorrowingHistoryCreateNestedManyWithoutFromInput
  }

  export type BKUniversityUncheckedCreateWithoutToRequestInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    universityToTitles?: UniversityToTitleUncheckedCreateNestedManyWithoutUniversityInput
    reserveUsers?: BKReserveUserUncheckedCreateNestedManyWithoutUniversityInput
    fromRequest?: BKRequestUncheckedCreateNestedManyWithoutFromInput
    BKBorrowingHistory?: BKBorrowingHistoryUncheckedCreateNestedManyWithoutFromInput
  }

  export type BKUniversityCreateOrConnectWithoutToRequestInput = {
    where: BKUniversityWhereUniqueInput
    create: XOR<BKUniversityCreateWithoutToRequestInput, BKUniversityUncheckedCreateWithoutToRequestInput>
  }

  export type BKReserveUserUpsertWithoutRequestsInput = {
    update: XOR<BKReserveUserUpdateWithoutRequestsInput, BKReserveUserUncheckedUpdateWithoutRequestsInput>
    create: XOR<BKReserveUserCreateWithoutRequestsInput, BKReserveUserUncheckedCreateWithoutRequestsInput>
  }

  export type BKReserveUserUpdateWithoutRequestsInput = {
    university?: BKUniversityUpdateOneRequiredWithoutReserveUsersNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BKBorrowingHistory?: BKBorrowingHistoryUpdateManyWithoutUserNestedInput
    BKCopy?: BKCopyUpdateManyWithoutUserNestedInput
  }

  export type BKReserveUserUncheckedUpdateWithoutRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    universityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BKBorrowingHistory?: BKBorrowingHistoryUncheckedUpdateManyWithoutUserNestedInput
    BKCopy?: BKCopyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BKCopyUpsertWithoutRequestsInput = {
    update: XOR<BKCopyUpdateWithoutRequestsInput, BKCopyUncheckedUpdateWithoutRequestsInput>
    create: XOR<BKCopyCreateWithoutRequestsInput, BKCopyUncheckedCreateWithoutRequestsInput>
  }

  export type BKCopyUpdateWithoutRequestsInput = {
    status?: EnumCopyStatusEnumFieldUpdateOperationsInput | CopyStatusEnum
    title?: BKTitleUpdateOneRequiredWithoutCopiesNestedInput
    user?: BKReserveUserUpdateOneWithoutBKCopyNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BKBorrowingHistory?: BKBorrowingHistoryUpdateManyWithoutCopyNestedInput
  }

  export type BKCopyUncheckedUpdateWithoutRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumCopyStatusEnumFieldUpdateOperationsInput | CopyStatusEnum
    titleId?: IntFieldUpdateOperationsInput | number
    reserveUserId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BKBorrowingHistory?: BKBorrowingHistoryUncheckedUpdateManyWithoutCopyNestedInput
  }

  export type BKUniversityUpsertWithoutFromRequestInput = {
    update: XOR<BKUniversityUpdateWithoutFromRequestInput, BKUniversityUncheckedUpdateWithoutFromRequestInput>
    create: XOR<BKUniversityCreateWithoutFromRequestInput, BKUniversityUncheckedCreateWithoutFromRequestInput>
  }

  export type BKUniversityUpdateWithoutFromRequestInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    universityToTitles?: UniversityToTitleUpdateManyWithoutUniversityNestedInput
    reserveUsers?: BKReserveUserUpdateManyWithoutUniversityNestedInput
    toRequest?: BKRequestUpdateManyWithoutToNestedInput
    BKBorrowingHistory?: BKBorrowingHistoryUpdateManyWithoutFromNestedInput
  }

  export type BKUniversityUncheckedUpdateWithoutFromRequestInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    universityToTitles?: UniversityToTitleUncheckedUpdateManyWithoutUniversityNestedInput
    reserveUsers?: BKReserveUserUncheckedUpdateManyWithoutUniversityNestedInput
    toRequest?: BKRequestUncheckedUpdateManyWithoutToNestedInput
    BKBorrowingHistory?: BKBorrowingHistoryUncheckedUpdateManyWithoutFromNestedInput
  }

  export type BKUniversityUpsertWithoutToRequestInput = {
    update: XOR<BKUniversityUpdateWithoutToRequestInput, BKUniversityUncheckedUpdateWithoutToRequestInput>
    create: XOR<BKUniversityCreateWithoutToRequestInput, BKUniversityUncheckedCreateWithoutToRequestInput>
  }

  export type BKUniversityUpdateWithoutToRequestInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    universityToTitles?: UniversityToTitleUpdateManyWithoutUniversityNestedInput
    reserveUsers?: BKReserveUserUpdateManyWithoutUniversityNestedInput
    fromRequest?: BKRequestUpdateManyWithoutFromNestedInput
    BKBorrowingHistory?: BKBorrowingHistoryUpdateManyWithoutFromNestedInput
  }

  export type BKUniversityUncheckedUpdateWithoutToRequestInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    universityToTitles?: UniversityToTitleUncheckedUpdateManyWithoutUniversityNestedInput
    reserveUsers?: BKReserveUserUncheckedUpdateManyWithoutUniversityNestedInput
    fromRequest?: BKRequestUncheckedUpdateManyWithoutFromNestedInput
    BKBorrowingHistory?: BKBorrowingHistoryUncheckedUpdateManyWithoutFromNestedInput
  }

  export type BKReserveUserCreateWithoutBKBorrowingHistoryInput = {
    university: BKUniversityCreateNestedOneWithoutReserveUsersInput
    createdAt?: Date | string
    updatedAt?: Date | string
    requests?: BKRequestCreateNestedManyWithoutUserInput
    BKCopy?: BKCopyCreateNestedManyWithoutUserInput
  }

  export type BKReserveUserUncheckedCreateWithoutBKBorrowingHistoryInput = {
    id?: number
    universityId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    requests?: BKRequestUncheckedCreateNestedManyWithoutUserInput
    BKCopy?: BKCopyUncheckedCreateNestedManyWithoutUserInput
  }

  export type BKReserveUserCreateOrConnectWithoutBKBorrowingHistoryInput = {
    where: BKReserveUserWhereUniqueInput
    create: XOR<BKReserveUserCreateWithoutBKBorrowingHistoryInput, BKReserveUserUncheckedCreateWithoutBKBorrowingHistoryInput>
  }

  export type BKCopyCreateWithoutBKBorrowingHistoryInput = {
    status: CopyStatusEnum
    title: BKTitleCreateNestedOneWithoutCopiesInput
    user?: BKReserveUserCreateNestedOneWithoutBKCopyInput
    createdAt?: Date | string
    updatedAt?: Date | string
    requests?: BKRequestCreateNestedManyWithoutCopyInput
  }

  export type BKCopyUncheckedCreateWithoutBKBorrowingHistoryInput = {
    id?: number
    status: CopyStatusEnum
    titleId: number
    reserveUserId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    requests?: BKRequestUncheckedCreateNestedManyWithoutCopyInput
  }

  export type BKCopyCreateOrConnectWithoutBKBorrowingHistoryInput = {
    where: BKCopyWhereUniqueInput
    create: XOR<BKCopyCreateWithoutBKBorrowingHistoryInput, BKCopyUncheckedCreateWithoutBKBorrowingHistoryInput>
  }

  export type BKUniversityCreateWithoutBKBorrowingHistoryInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    universityToTitles?: UniversityToTitleCreateNestedManyWithoutUniversityInput
    reserveUsers?: BKReserveUserCreateNestedManyWithoutUniversityInput
    fromRequest?: BKRequestCreateNestedManyWithoutFromInput
    toRequest?: BKRequestCreateNestedManyWithoutToInput
  }

  export type BKUniversityUncheckedCreateWithoutBKBorrowingHistoryInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    universityToTitles?: UniversityToTitleUncheckedCreateNestedManyWithoutUniversityInput
    reserveUsers?: BKReserveUserUncheckedCreateNestedManyWithoutUniversityInput
    fromRequest?: BKRequestUncheckedCreateNestedManyWithoutFromInput
    toRequest?: BKRequestUncheckedCreateNestedManyWithoutToInput
  }

  export type BKUniversityCreateOrConnectWithoutBKBorrowingHistoryInput = {
    where: BKUniversityWhereUniqueInput
    create: XOR<BKUniversityCreateWithoutBKBorrowingHistoryInput, BKUniversityUncheckedCreateWithoutBKBorrowingHistoryInput>
  }

  export type BKReserveUserUpsertWithoutBKBorrowingHistoryInput = {
    update: XOR<BKReserveUserUpdateWithoutBKBorrowingHistoryInput, BKReserveUserUncheckedUpdateWithoutBKBorrowingHistoryInput>
    create: XOR<BKReserveUserCreateWithoutBKBorrowingHistoryInput, BKReserveUserUncheckedCreateWithoutBKBorrowingHistoryInput>
  }

  export type BKReserveUserUpdateWithoutBKBorrowingHistoryInput = {
    university?: BKUniversityUpdateOneRequiredWithoutReserveUsersNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requests?: BKRequestUpdateManyWithoutUserNestedInput
    BKCopy?: BKCopyUpdateManyWithoutUserNestedInput
  }

  export type BKReserveUserUncheckedUpdateWithoutBKBorrowingHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    universityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requests?: BKRequestUncheckedUpdateManyWithoutUserNestedInput
    BKCopy?: BKCopyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BKCopyUpsertWithoutBKBorrowingHistoryInput = {
    update: XOR<BKCopyUpdateWithoutBKBorrowingHistoryInput, BKCopyUncheckedUpdateWithoutBKBorrowingHistoryInput>
    create: XOR<BKCopyCreateWithoutBKBorrowingHistoryInput, BKCopyUncheckedCreateWithoutBKBorrowingHistoryInput>
  }

  export type BKCopyUpdateWithoutBKBorrowingHistoryInput = {
    status?: EnumCopyStatusEnumFieldUpdateOperationsInput | CopyStatusEnum
    title?: BKTitleUpdateOneRequiredWithoutCopiesNestedInput
    user?: BKReserveUserUpdateOneWithoutBKCopyNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requests?: BKRequestUpdateManyWithoutCopyNestedInput
  }

  export type BKCopyUncheckedUpdateWithoutBKBorrowingHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumCopyStatusEnumFieldUpdateOperationsInput | CopyStatusEnum
    titleId?: IntFieldUpdateOperationsInput | number
    reserveUserId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requests?: BKRequestUncheckedUpdateManyWithoutCopyNestedInput
  }

  export type BKUniversityUpsertWithoutBKBorrowingHistoryInput = {
    update: XOR<BKUniversityUpdateWithoutBKBorrowingHistoryInput, BKUniversityUncheckedUpdateWithoutBKBorrowingHistoryInput>
    create: XOR<BKUniversityCreateWithoutBKBorrowingHistoryInput, BKUniversityUncheckedCreateWithoutBKBorrowingHistoryInput>
  }

  export type BKUniversityUpdateWithoutBKBorrowingHistoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    universityToTitles?: UniversityToTitleUpdateManyWithoutUniversityNestedInput
    reserveUsers?: BKReserveUserUpdateManyWithoutUniversityNestedInput
    fromRequest?: BKRequestUpdateManyWithoutFromNestedInput
    toRequest?: BKRequestUpdateManyWithoutToNestedInput
  }

  export type BKUniversityUncheckedUpdateWithoutBKBorrowingHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    universityToTitles?: UniversityToTitleUncheckedUpdateManyWithoutUniversityNestedInput
    reserveUsers?: BKReserveUserUncheckedUpdateManyWithoutUniversityNestedInput
    fromRequest?: BKRequestUncheckedUpdateManyWithoutFromNestedInput
    toRequest?: BKRequestUncheckedUpdateManyWithoutToNestedInput
  }

  export type BKTitleCreateWithoutCopiesInput = {
    name: string
    ISBN: number
    copyQty: number
    createdAt?: Date | string
    updatedAt?: Date | string
    titleToCategories?: TitleToCategoryCreateNestedManyWithoutTitleInput
    titleToAuthors?: TitleToAuthorCreateNestedManyWithoutTitleInput
    universityToTitles?: UniversityToTitleCreateNestedManyWithoutTitleInput
  }

  export type BKTitleUncheckedCreateWithoutCopiesInput = {
    id?: number
    name: string
    ISBN: number
    copyQty: number
    createdAt?: Date | string
    updatedAt?: Date | string
    titleToCategories?: TitleToCategoryUncheckedCreateNestedManyWithoutTitleInput
    titleToAuthors?: TitleToAuthorUncheckedCreateNestedManyWithoutTitleInput
    universityToTitles?: UniversityToTitleUncheckedCreateNestedManyWithoutTitleInput
  }

  export type BKTitleCreateOrConnectWithoutCopiesInput = {
    where: BKTitleWhereUniqueInput
    create: XOR<BKTitleCreateWithoutCopiesInput, BKTitleUncheckedCreateWithoutCopiesInput>
  }

  export type BKReserveUserCreateWithoutBKCopyInput = {
    university: BKUniversityCreateNestedOneWithoutReserveUsersInput
    createdAt?: Date | string
    updatedAt?: Date | string
    requests?: BKRequestCreateNestedManyWithoutUserInput
    BKBorrowingHistory?: BKBorrowingHistoryCreateNestedManyWithoutUserInput
  }

  export type BKReserveUserUncheckedCreateWithoutBKCopyInput = {
    id?: number
    universityId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    requests?: BKRequestUncheckedCreateNestedManyWithoutUserInput
    BKBorrowingHistory?: BKBorrowingHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type BKReserveUserCreateOrConnectWithoutBKCopyInput = {
    where: BKReserveUserWhereUniqueInput
    create: XOR<BKReserveUserCreateWithoutBKCopyInput, BKReserveUserUncheckedCreateWithoutBKCopyInput>
  }

  export type BKRequestCreateWithoutCopyInput = {
    user: BKReserveUserCreateNestedOneWithoutRequestsInput
    from: BKUniversityCreateNestedOneWithoutFromRequestInput
    to: BKUniversityCreateNestedOneWithoutToRequestInput
    requestDate: Date | string
    status: RequestStatusEnum
    planRecievedDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BKRequestUncheckedCreateWithoutCopyInput = {
    id?: number
    reserveUserId: number
    fromUniversityId: number
    toUniversityId: number
    requestDate: Date | string
    status: RequestStatusEnum
    planRecievedDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BKRequestCreateOrConnectWithoutCopyInput = {
    where: BKRequestWhereUniqueInput
    create: XOR<BKRequestCreateWithoutCopyInput, BKRequestUncheckedCreateWithoutCopyInput>
  }

  export type BKRequestCreateManyCopyInputEnvelope = {
    data: Enumerable<BKRequestCreateManyCopyInput>
    skipDuplicates?: boolean
  }

  export type BKBorrowingHistoryCreateWithoutCopyInput = {
    user: BKReserveUserCreateNestedOneWithoutBKBorrowingHistoryInput
    from: BKUniversityCreateNestedOneWithoutBKBorrowingHistoryInput
    borrowDate: Date | string
    returnDate: Date | string
    actualReturnDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BKBorrowingHistoryUncheckedCreateWithoutCopyInput = {
    id?: number
    reserveUserId: number
    fromUniversityId: number
    borrowDate: Date | string
    returnDate: Date | string
    actualReturnDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BKBorrowingHistoryCreateOrConnectWithoutCopyInput = {
    where: BKBorrowingHistoryWhereUniqueInput
    create: XOR<BKBorrowingHistoryCreateWithoutCopyInput, BKBorrowingHistoryUncheckedCreateWithoutCopyInput>
  }

  export type BKBorrowingHistoryCreateManyCopyInputEnvelope = {
    data: Enumerable<BKBorrowingHistoryCreateManyCopyInput>
    skipDuplicates?: boolean
  }

  export type BKTitleUpsertWithoutCopiesInput = {
    update: XOR<BKTitleUpdateWithoutCopiesInput, BKTitleUncheckedUpdateWithoutCopiesInput>
    create: XOR<BKTitleCreateWithoutCopiesInput, BKTitleUncheckedCreateWithoutCopiesInput>
  }

  export type BKTitleUpdateWithoutCopiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    ISBN?: IntFieldUpdateOperationsInput | number
    copyQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    titleToCategories?: TitleToCategoryUpdateManyWithoutTitleNestedInput
    titleToAuthors?: TitleToAuthorUpdateManyWithoutTitleNestedInput
    universityToTitles?: UniversityToTitleUpdateManyWithoutTitleNestedInput
  }

  export type BKTitleUncheckedUpdateWithoutCopiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    ISBN?: IntFieldUpdateOperationsInput | number
    copyQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    titleToCategories?: TitleToCategoryUncheckedUpdateManyWithoutTitleNestedInput
    titleToAuthors?: TitleToAuthorUncheckedUpdateManyWithoutTitleNestedInput
    universityToTitles?: UniversityToTitleUncheckedUpdateManyWithoutTitleNestedInput
  }

  export type BKReserveUserUpsertWithoutBKCopyInput = {
    update: XOR<BKReserveUserUpdateWithoutBKCopyInput, BKReserveUserUncheckedUpdateWithoutBKCopyInput>
    create: XOR<BKReserveUserCreateWithoutBKCopyInput, BKReserveUserUncheckedCreateWithoutBKCopyInput>
  }

  export type BKReserveUserUpdateWithoutBKCopyInput = {
    university?: BKUniversityUpdateOneRequiredWithoutReserveUsersNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requests?: BKRequestUpdateManyWithoutUserNestedInput
    BKBorrowingHistory?: BKBorrowingHistoryUpdateManyWithoutUserNestedInput
  }

  export type BKReserveUserUncheckedUpdateWithoutBKCopyInput = {
    id?: IntFieldUpdateOperationsInput | number
    universityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requests?: BKRequestUncheckedUpdateManyWithoutUserNestedInput
    BKBorrowingHistory?: BKBorrowingHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BKRequestUpsertWithWhereUniqueWithoutCopyInput = {
    where: BKRequestWhereUniqueInput
    update: XOR<BKRequestUpdateWithoutCopyInput, BKRequestUncheckedUpdateWithoutCopyInput>
    create: XOR<BKRequestCreateWithoutCopyInput, BKRequestUncheckedCreateWithoutCopyInput>
  }

  export type BKRequestUpdateWithWhereUniqueWithoutCopyInput = {
    where: BKRequestWhereUniqueInput
    data: XOR<BKRequestUpdateWithoutCopyInput, BKRequestUncheckedUpdateWithoutCopyInput>
  }

  export type BKRequestUpdateManyWithWhereWithoutCopyInput = {
    where: BKRequestScalarWhereInput
    data: XOR<BKRequestUpdateManyMutationInput, BKRequestUncheckedUpdateManyWithoutRequestsInput>
  }

  export type BKBorrowingHistoryUpsertWithWhereUniqueWithoutCopyInput = {
    where: BKBorrowingHistoryWhereUniqueInput
    update: XOR<BKBorrowingHistoryUpdateWithoutCopyInput, BKBorrowingHistoryUncheckedUpdateWithoutCopyInput>
    create: XOR<BKBorrowingHistoryCreateWithoutCopyInput, BKBorrowingHistoryUncheckedCreateWithoutCopyInput>
  }

  export type BKBorrowingHistoryUpdateWithWhereUniqueWithoutCopyInput = {
    where: BKBorrowingHistoryWhereUniqueInput
    data: XOR<BKBorrowingHistoryUpdateWithoutCopyInput, BKBorrowingHistoryUncheckedUpdateWithoutCopyInput>
  }

  export type BKBorrowingHistoryUpdateManyWithWhereWithoutCopyInput = {
    where: BKBorrowingHistoryScalarWhereInput
    data: XOR<BKBorrowingHistoryUpdateManyMutationInput, BKBorrowingHistoryUncheckedUpdateManyWithoutBKBorrowingHistoryInput>
  }

  export type UniversityToTitleCreateWithoutUniversityInput = {
    title: BKTitleCreateNestedOneWithoutUniversityToTitlesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UniversityToTitleUncheckedCreateWithoutUniversityInput = {
    id?: number
    titleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UniversityToTitleCreateOrConnectWithoutUniversityInput = {
    where: UniversityToTitleWhereUniqueInput
    create: XOR<UniversityToTitleCreateWithoutUniversityInput, UniversityToTitleUncheckedCreateWithoutUniversityInput>
  }

  export type UniversityToTitleCreateManyUniversityInputEnvelope = {
    data: Enumerable<UniversityToTitleCreateManyUniversityInput>
    skipDuplicates?: boolean
  }

  export type BKReserveUserCreateWithoutUniversityInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    requests?: BKRequestCreateNestedManyWithoutUserInput
    BKBorrowingHistory?: BKBorrowingHistoryCreateNestedManyWithoutUserInput
    BKCopy?: BKCopyCreateNestedManyWithoutUserInput
  }

  export type BKReserveUserUncheckedCreateWithoutUniversityInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    requests?: BKRequestUncheckedCreateNestedManyWithoutUserInput
    BKBorrowingHistory?: BKBorrowingHistoryUncheckedCreateNestedManyWithoutUserInput
    BKCopy?: BKCopyUncheckedCreateNestedManyWithoutUserInput
  }

  export type BKReserveUserCreateOrConnectWithoutUniversityInput = {
    where: BKReserveUserWhereUniqueInput
    create: XOR<BKReserveUserCreateWithoutUniversityInput, BKReserveUserUncheckedCreateWithoutUniversityInput>
  }

  export type BKReserveUserCreateManyUniversityInputEnvelope = {
    data: Enumerable<BKReserveUserCreateManyUniversityInput>
    skipDuplicates?: boolean
  }

  export type BKRequestCreateWithoutFromInput = {
    user: BKReserveUserCreateNestedOneWithoutRequestsInput
    copy: BKCopyCreateNestedOneWithoutRequestsInput
    to: BKUniversityCreateNestedOneWithoutToRequestInput
    requestDate: Date | string
    status: RequestStatusEnum
    planRecievedDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BKRequestUncheckedCreateWithoutFromInput = {
    id?: number
    reserveUserId: number
    copyId: number
    toUniversityId: number
    requestDate: Date | string
    status: RequestStatusEnum
    planRecievedDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BKRequestCreateOrConnectWithoutFromInput = {
    where: BKRequestWhereUniqueInput
    create: XOR<BKRequestCreateWithoutFromInput, BKRequestUncheckedCreateWithoutFromInput>
  }

  export type BKRequestCreateManyFromInputEnvelope = {
    data: Enumerable<BKRequestCreateManyFromInput>
    skipDuplicates?: boolean
  }

  export type BKRequestCreateWithoutToInput = {
    user: BKReserveUserCreateNestedOneWithoutRequestsInput
    copy: BKCopyCreateNestedOneWithoutRequestsInput
    from: BKUniversityCreateNestedOneWithoutFromRequestInput
    requestDate: Date | string
    status: RequestStatusEnum
    planRecievedDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BKRequestUncheckedCreateWithoutToInput = {
    id?: number
    reserveUserId: number
    copyId: number
    fromUniversityId: number
    requestDate: Date | string
    status: RequestStatusEnum
    planRecievedDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BKRequestCreateOrConnectWithoutToInput = {
    where: BKRequestWhereUniqueInput
    create: XOR<BKRequestCreateWithoutToInput, BKRequestUncheckedCreateWithoutToInput>
  }

  export type BKRequestCreateManyToInputEnvelope = {
    data: Enumerable<BKRequestCreateManyToInput>
    skipDuplicates?: boolean
  }

  export type BKBorrowingHistoryCreateWithoutFromInput = {
    user: BKReserveUserCreateNestedOneWithoutBKBorrowingHistoryInput
    copy: BKCopyCreateNestedOneWithoutBKBorrowingHistoryInput
    borrowDate: Date | string
    returnDate: Date | string
    actualReturnDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BKBorrowingHistoryUncheckedCreateWithoutFromInput = {
    id?: number
    reserveUserId: number
    copyId: number
    borrowDate: Date | string
    returnDate: Date | string
    actualReturnDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BKBorrowingHistoryCreateOrConnectWithoutFromInput = {
    where: BKBorrowingHistoryWhereUniqueInput
    create: XOR<BKBorrowingHistoryCreateWithoutFromInput, BKBorrowingHistoryUncheckedCreateWithoutFromInput>
  }

  export type BKBorrowingHistoryCreateManyFromInputEnvelope = {
    data: Enumerable<BKBorrowingHistoryCreateManyFromInput>
    skipDuplicates?: boolean
  }

  export type UniversityToTitleUpsertWithWhereUniqueWithoutUniversityInput = {
    where: UniversityToTitleWhereUniqueInput
    update: XOR<UniversityToTitleUpdateWithoutUniversityInput, UniversityToTitleUncheckedUpdateWithoutUniversityInput>
    create: XOR<UniversityToTitleCreateWithoutUniversityInput, UniversityToTitleUncheckedCreateWithoutUniversityInput>
  }

  export type UniversityToTitleUpdateWithWhereUniqueWithoutUniversityInput = {
    where: UniversityToTitleWhereUniqueInput
    data: XOR<UniversityToTitleUpdateWithoutUniversityInput, UniversityToTitleUncheckedUpdateWithoutUniversityInput>
  }

  export type UniversityToTitleUpdateManyWithWhereWithoutUniversityInput = {
    where: UniversityToTitleScalarWhereInput
    data: XOR<UniversityToTitleUpdateManyMutationInput, UniversityToTitleUncheckedUpdateManyWithoutUniversityToTitlesInput>
  }

  export type UniversityToTitleScalarWhereInput = {
    AND?: Enumerable<UniversityToTitleScalarWhereInput>
    OR?: Enumerable<UniversityToTitleScalarWhereInput>
    NOT?: Enumerable<UniversityToTitleScalarWhereInput>
    id?: IntFilter | number
    universityId?: IntFilter | number
    titleId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type BKReserveUserUpsertWithWhereUniqueWithoutUniversityInput = {
    where: BKReserveUserWhereUniqueInput
    update: XOR<BKReserveUserUpdateWithoutUniversityInput, BKReserveUserUncheckedUpdateWithoutUniversityInput>
    create: XOR<BKReserveUserCreateWithoutUniversityInput, BKReserveUserUncheckedCreateWithoutUniversityInput>
  }

  export type BKReserveUserUpdateWithWhereUniqueWithoutUniversityInput = {
    where: BKReserveUserWhereUniqueInput
    data: XOR<BKReserveUserUpdateWithoutUniversityInput, BKReserveUserUncheckedUpdateWithoutUniversityInput>
  }

  export type BKReserveUserUpdateManyWithWhereWithoutUniversityInput = {
    where: BKReserveUserScalarWhereInput
    data: XOR<BKReserveUserUpdateManyMutationInput, BKReserveUserUncheckedUpdateManyWithoutReserveUsersInput>
  }

  export type BKReserveUserScalarWhereInput = {
    AND?: Enumerable<BKReserveUserScalarWhereInput>
    OR?: Enumerable<BKReserveUserScalarWhereInput>
    NOT?: Enumerable<BKReserveUserScalarWhereInput>
    id?: IntFilter | number
    universityId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type BKRequestUpsertWithWhereUniqueWithoutFromInput = {
    where: BKRequestWhereUniqueInput
    update: XOR<BKRequestUpdateWithoutFromInput, BKRequestUncheckedUpdateWithoutFromInput>
    create: XOR<BKRequestCreateWithoutFromInput, BKRequestUncheckedCreateWithoutFromInput>
  }

  export type BKRequestUpdateWithWhereUniqueWithoutFromInput = {
    where: BKRequestWhereUniqueInput
    data: XOR<BKRequestUpdateWithoutFromInput, BKRequestUncheckedUpdateWithoutFromInput>
  }

  export type BKRequestUpdateManyWithWhereWithoutFromInput = {
    where: BKRequestScalarWhereInput
    data: XOR<BKRequestUpdateManyMutationInput, BKRequestUncheckedUpdateManyWithoutFromRequestInput>
  }

  export type BKRequestUpsertWithWhereUniqueWithoutToInput = {
    where: BKRequestWhereUniqueInput
    update: XOR<BKRequestUpdateWithoutToInput, BKRequestUncheckedUpdateWithoutToInput>
    create: XOR<BKRequestCreateWithoutToInput, BKRequestUncheckedCreateWithoutToInput>
  }

  export type BKRequestUpdateWithWhereUniqueWithoutToInput = {
    where: BKRequestWhereUniqueInput
    data: XOR<BKRequestUpdateWithoutToInput, BKRequestUncheckedUpdateWithoutToInput>
  }

  export type BKRequestUpdateManyWithWhereWithoutToInput = {
    where: BKRequestScalarWhereInput
    data: XOR<BKRequestUpdateManyMutationInput, BKRequestUncheckedUpdateManyWithoutToRequestInput>
  }

  export type BKBorrowingHistoryUpsertWithWhereUniqueWithoutFromInput = {
    where: BKBorrowingHistoryWhereUniqueInput
    update: XOR<BKBorrowingHistoryUpdateWithoutFromInput, BKBorrowingHistoryUncheckedUpdateWithoutFromInput>
    create: XOR<BKBorrowingHistoryCreateWithoutFromInput, BKBorrowingHistoryUncheckedCreateWithoutFromInput>
  }

  export type BKBorrowingHistoryUpdateWithWhereUniqueWithoutFromInput = {
    where: BKBorrowingHistoryWhereUniqueInput
    data: XOR<BKBorrowingHistoryUpdateWithoutFromInput, BKBorrowingHistoryUncheckedUpdateWithoutFromInput>
  }

  export type BKBorrowingHistoryUpdateManyWithWhereWithoutFromInput = {
    where: BKBorrowingHistoryScalarWhereInput
    data: XOR<BKBorrowingHistoryUpdateManyMutationInput, BKBorrowingHistoryUncheckedUpdateManyWithoutBKBorrowingHistoryInput>
  }

  export type TitleToCategoryCreateWithoutTitleInput = {
    category: BKCategoryCreateNestedOneWithoutTitleToCategoriesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TitleToCategoryUncheckedCreateWithoutTitleInput = {
    id?: number
    categoryId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TitleToCategoryCreateOrConnectWithoutTitleInput = {
    where: TitleToCategoryWhereUniqueInput
    create: XOR<TitleToCategoryCreateWithoutTitleInput, TitleToCategoryUncheckedCreateWithoutTitleInput>
  }

  export type TitleToCategoryCreateManyTitleInputEnvelope = {
    data: Enumerable<TitleToCategoryCreateManyTitleInput>
    skipDuplicates?: boolean
  }

  export type TitleToAuthorCreateWithoutTitleInput = {
    author: BKAuthorCreateNestedOneWithoutTitleToAuthorsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TitleToAuthorUncheckedCreateWithoutTitleInput = {
    id?: number
    authorId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TitleToAuthorCreateOrConnectWithoutTitleInput = {
    where: TitleToAuthorWhereUniqueInput
    create: XOR<TitleToAuthorCreateWithoutTitleInput, TitleToAuthorUncheckedCreateWithoutTitleInput>
  }

  export type TitleToAuthorCreateManyTitleInputEnvelope = {
    data: Enumerable<TitleToAuthorCreateManyTitleInput>
    skipDuplicates?: boolean
  }

  export type UniversityToTitleCreateWithoutTitleInput = {
    university: BKUniversityCreateNestedOneWithoutUniversityToTitlesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UniversityToTitleUncheckedCreateWithoutTitleInput = {
    id?: number
    universityId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UniversityToTitleCreateOrConnectWithoutTitleInput = {
    where: UniversityToTitleWhereUniqueInput
    create: XOR<UniversityToTitleCreateWithoutTitleInput, UniversityToTitleUncheckedCreateWithoutTitleInput>
  }

  export type UniversityToTitleCreateManyTitleInputEnvelope = {
    data: Enumerable<UniversityToTitleCreateManyTitleInput>
    skipDuplicates?: boolean
  }

  export type BKCopyCreateWithoutTitleInput = {
    status: CopyStatusEnum
    user?: BKReserveUserCreateNestedOneWithoutBKCopyInput
    createdAt?: Date | string
    updatedAt?: Date | string
    requests?: BKRequestCreateNestedManyWithoutCopyInput
    BKBorrowingHistory?: BKBorrowingHistoryCreateNestedManyWithoutCopyInput
  }

  export type BKCopyUncheckedCreateWithoutTitleInput = {
    id?: number
    status: CopyStatusEnum
    reserveUserId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    requests?: BKRequestUncheckedCreateNestedManyWithoutCopyInput
    BKBorrowingHistory?: BKBorrowingHistoryUncheckedCreateNestedManyWithoutCopyInput
  }

  export type BKCopyCreateOrConnectWithoutTitleInput = {
    where: BKCopyWhereUniqueInput
    create: XOR<BKCopyCreateWithoutTitleInput, BKCopyUncheckedCreateWithoutTitleInput>
  }

  export type BKCopyCreateManyTitleInputEnvelope = {
    data: Enumerable<BKCopyCreateManyTitleInput>
    skipDuplicates?: boolean
  }

  export type TitleToCategoryUpsertWithWhereUniqueWithoutTitleInput = {
    where: TitleToCategoryWhereUniqueInput
    update: XOR<TitleToCategoryUpdateWithoutTitleInput, TitleToCategoryUncheckedUpdateWithoutTitleInput>
    create: XOR<TitleToCategoryCreateWithoutTitleInput, TitleToCategoryUncheckedCreateWithoutTitleInput>
  }

  export type TitleToCategoryUpdateWithWhereUniqueWithoutTitleInput = {
    where: TitleToCategoryWhereUniqueInput
    data: XOR<TitleToCategoryUpdateWithoutTitleInput, TitleToCategoryUncheckedUpdateWithoutTitleInput>
  }

  export type TitleToCategoryUpdateManyWithWhereWithoutTitleInput = {
    where: TitleToCategoryScalarWhereInput
    data: XOR<TitleToCategoryUpdateManyMutationInput, TitleToCategoryUncheckedUpdateManyWithoutTitleToCategoriesInput>
  }

  export type TitleToCategoryScalarWhereInput = {
    AND?: Enumerable<TitleToCategoryScalarWhereInput>
    OR?: Enumerable<TitleToCategoryScalarWhereInput>
    NOT?: Enumerable<TitleToCategoryScalarWhereInput>
    id?: IntFilter | number
    titleId?: IntFilter | number
    categoryId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TitleToAuthorUpsertWithWhereUniqueWithoutTitleInput = {
    where: TitleToAuthorWhereUniqueInput
    update: XOR<TitleToAuthorUpdateWithoutTitleInput, TitleToAuthorUncheckedUpdateWithoutTitleInput>
    create: XOR<TitleToAuthorCreateWithoutTitleInput, TitleToAuthorUncheckedCreateWithoutTitleInput>
  }

  export type TitleToAuthorUpdateWithWhereUniqueWithoutTitleInput = {
    where: TitleToAuthorWhereUniqueInput
    data: XOR<TitleToAuthorUpdateWithoutTitleInput, TitleToAuthorUncheckedUpdateWithoutTitleInput>
  }

  export type TitleToAuthorUpdateManyWithWhereWithoutTitleInput = {
    where: TitleToAuthorScalarWhereInput
    data: XOR<TitleToAuthorUpdateManyMutationInput, TitleToAuthorUncheckedUpdateManyWithoutTitleToAuthorsInput>
  }

  export type TitleToAuthorScalarWhereInput = {
    AND?: Enumerable<TitleToAuthorScalarWhereInput>
    OR?: Enumerable<TitleToAuthorScalarWhereInput>
    NOT?: Enumerable<TitleToAuthorScalarWhereInput>
    id?: IntFilter | number
    titleId?: IntFilter | number
    authorId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type UniversityToTitleUpsertWithWhereUniqueWithoutTitleInput = {
    where: UniversityToTitleWhereUniqueInput
    update: XOR<UniversityToTitleUpdateWithoutTitleInput, UniversityToTitleUncheckedUpdateWithoutTitleInput>
    create: XOR<UniversityToTitleCreateWithoutTitleInput, UniversityToTitleUncheckedCreateWithoutTitleInput>
  }

  export type UniversityToTitleUpdateWithWhereUniqueWithoutTitleInput = {
    where: UniversityToTitleWhereUniqueInput
    data: XOR<UniversityToTitleUpdateWithoutTitleInput, UniversityToTitleUncheckedUpdateWithoutTitleInput>
  }

  export type UniversityToTitleUpdateManyWithWhereWithoutTitleInput = {
    where: UniversityToTitleScalarWhereInput
    data: XOR<UniversityToTitleUpdateManyMutationInput, UniversityToTitleUncheckedUpdateManyWithoutUniversityToTitlesInput>
  }

  export type BKCopyUpsertWithWhereUniqueWithoutTitleInput = {
    where: BKCopyWhereUniqueInput
    update: XOR<BKCopyUpdateWithoutTitleInput, BKCopyUncheckedUpdateWithoutTitleInput>
    create: XOR<BKCopyCreateWithoutTitleInput, BKCopyUncheckedCreateWithoutTitleInput>
  }

  export type BKCopyUpdateWithWhereUniqueWithoutTitleInput = {
    where: BKCopyWhereUniqueInput
    data: XOR<BKCopyUpdateWithoutTitleInput, BKCopyUncheckedUpdateWithoutTitleInput>
  }

  export type BKCopyUpdateManyWithWhereWithoutTitleInput = {
    where: BKCopyScalarWhereInput
    data: XOR<BKCopyUpdateManyMutationInput, BKCopyUncheckedUpdateManyWithoutCopiesInput>
  }

  export type BKUniversityCreateWithoutUniversityToTitlesInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    reserveUsers?: BKReserveUserCreateNestedManyWithoutUniversityInput
    fromRequest?: BKRequestCreateNestedManyWithoutFromInput
    toRequest?: BKRequestCreateNestedManyWithoutToInput
    BKBorrowingHistory?: BKBorrowingHistoryCreateNestedManyWithoutFromInput
  }

  export type BKUniversityUncheckedCreateWithoutUniversityToTitlesInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    reserveUsers?: BKReserveUserUncheckedCreateNestedManyWithoutUniversityInput
    fromRequest?: BKRequestUncheckedCreateNestedManyWithoutFromInput
    toRequest?: BKRequestUncheckedCreateNestedManyWithoutToInput
    BKBorrowingHistory?: BKBorrowingHistoryUncheckedCreateNestedManyWithoutFromInput
  }

  export type BKUniversityCreateOrConnectWithoutUniversityToTitlesInput = {
    where: BKUniversityWhereUniqueInput
    create: XOR<BKUniversityCreateWithoutUniversityToTitlesInput, BKUniversityUncheckedCreateWithoutUniversityToTitlesInput>
  }

  export type BKTitleCreateWithoutUniversityToTitlesInput = {
    name: string
    ISBN: number
    copyQty: number
    createdAt?: Date | string
    updatedAt?: Date | string
    titleToCategories?: TitleToCategoryCreateNestedManyWithoutTitleInput
    titleToAuthors?: TitleToAuthorCreateNestedManyWithoutTitleInput
    copies?: BKCopyCreateNestedManyWithoutTitleInput
  }

  export type BKTitleUncheckedCreateWithoutUniversityToTitlesInput = {
    id?: number
    name: string
    ISBN: number
    copyQty: number
    createdAt?: Date | string
    updatedAt?: Date | string
    titleToCategories?: TitleToCategoryUncheckedCreateNestedManyWithoutTitleInput
    titleToAuthors?: TitleToAuthorUncheckedCreateNestedManyWithoutTitleInput
    copies?: BKCopyUncheckedCreateNestedManyWithoutTitleInput
  }

  export type BKTitleCreateOrConnectWithoutUniversityToTitlesInput = {
    where: BKTitleWhereUniqueInput
    create: XOR<BKTitleCreateWithoutUniversityToTitlesInput, BKTitleUncheckedCreateWithoutUniversityToTitlesInput>
  }

  export type BKUniversityUpsertWithoutUniversityToTitlesInput = {
    update: XOR<BKUniversityUpdateWithoutUniversityToTitlesInput, BKUniversityUncheckedUpdateWithoutUniversityToTitlesInput>
    create: XOR<BKUniversityCreateWithoutUniversityToTitlesInput, BKUniversityUncheckedCreateWithoutUniversityToTitlesInput>
  }

  export type BKUniversityUpdateWithoutUniversityToTitlesInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reserveUsers?: BKReserveUserUpdateManyWithoutUniversityNestedInput
    fromRequest?: BKRequestUpdateManyWithoutFromNestedInput
    toRequest?: BKRequestUpdateManyWithoutToNestedInput
    BKBorrowingHistory?: BKBorrowingHistoryUpdateManyWithoutFromNestedInput
  }

  export type BKUniversityUncheckedUpdateWithoutUniversityToTitlesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reserveUsers?: BKReserveUserUncheckedUpdateManyWithoutUniversityNestedInput
    fromRequest?: BKRequestUncheckedUpdateManyWithoutFromNestedInput
    toRequest?: BKRequestUncheckedUpdateManyWithoutToNestedInput
    BKBorrowingHistory?: BKBorrowingHistoryUncheckedUpdateManyWithoutFromNestedInput
  }

  export type BKTitleUpsertWithoutUniversityToTitlesInput = {
    update: XOR<BKTitleUpdateWithoutUniversityToTitlesInput, BKTitleUncheckedUpdateWithoutUniversityToTitlesInput>
    create: XOR<BKTitleCreateWithoutUniversityToTitlesInput, BKTitleUncheckedCreateWithoutUniversityToTitlesInput>
  }

  export type BKTitleUpdateWithoutUniversityToTitlesInput = {
    name?: StringFieldUpdateOperationsInput | string
    ISBN?: IntFieldUpdateOperationsInput | number
    copyQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    titleToCategories?: TitleToCategoryUpdateManyWithoutTitleNestedInput
    titleToAuthors?: TitleToAuthorUpdateManyWithoutTitleNestedInput
    copies?: BKCopyUpdateManyWithoutTitleNestedInput
  }

  export type BKTitleUncheckedUpdateWithoutUniversityToTitlesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    ISBN?: IntFieldUpdateOperationsInput | number
    copyQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    titleToCategories?: TitleToCategoryUncheckedUpdateManyWithoutTitleNestedInput
    titleToAuthors?: TitleToAuthorUncheckedUpdateManyWithoutTitleNestedInput
    copies?: BKCopyUncheckedUpdateManyWithoutTitleNestedInput
  }

  export type TitleToCategoryCreateWithoutCategoryInput = {
    title: BKTitleCreateNestedOneWithoutTitleToCategoriesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TitleToCategoryUncheckedCreateWithoutCategoryInput = {
    id?: number
    titleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TitleToCategoryCreateOrConnectWithoutCategoryInput = {
    where: TitleToCategoryWhereUniqueInput
    create: XOR<TitleToCategoryCreateWithoutCategoryInput, TitleToCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type TitleToCategoryCreateManyCategoryInputEnvelope = {
    data: Enumerable<TitleToCategoryCreateManyCategoryInput>
    skipDuplicates?: boolean
  }

  export type TitleToCategoryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: TitleToCategoryWhereUniqueInput
    update: XOR<TitleToCategoryUpdateWithoutCategoryInput, TitleToCategoryUncheckedUpdateWithoutCategoryInput>
    create: XOR<TitleToCategoryCreateWithoutCategoryInput, TitleToCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type TitleToCategoryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: TitleToCategoryWhereUniqueInput
    data: XOR<TitleToCategoryUpdateWithoutCategoryInput, TitleToCategoryUncheckedUpdateWithoutCategoryInput>
  }

  export type TitleToCategoryUpdateManyWithWhereWithoutCategoryInput = {
    where: TitleToCategoryScalarWhereInput
    data: XOR<TitleToCategoryUpdateManyMutationInput, TitleToCategoryUncheckedUpdateManyWithoutTitleToCategoriesInput>
  }

  export type BKTitleCreateWithoutTitleToCategoriesInput = {
    name: string
    ISBN: number
    copyQty: number
    createdAt?: Date | string
    updatedAt?: Date | string
    titleToAuthors?: TitleToAuthorCreateNestedManyWithoutTitleInput
    universityToTitles?: UniversityToTitleCreateNestedManyWithoutTitleInput
    copies?: BKCopyCreateNestedManyWithoutTitleInput
  }

  export type BKTitleUncheckedCreateWithoutTitleToCategoriesInput = {
    id?: number
    name: string
    ISBN: number
    copyQty: number
    createdAt?: Date | string
    updatedAt?: Date | string
    titleToAuthors?: TitleToAuthorUncheckedCreateNestedManyWithoutTitleInput
    universityToTitles?: UniversityToTitleUncheckedCreateNestedManyWithoutTitleInput
    copies?: BKCopyUncheckedCreateNestedManyWithoutTitleInput
  }

  export type BKTitleCreateOrConnectWithoutTitleToCategoriesInput = {
    where: BKTitleWhereUniqueInput
    create: XOR<BKTitleCreateWithoutTitleToCategoriesInput, BKTitleUncheckedCreateWithoutTitleToCategoriesInput>
  }

  export type BKCategoryCreateWithoutTitleToCategoriesInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BKCategoryUncheckedCreateWithoutTitleToCategoriesInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BKCategoryCreateOrConnectWithoutTitleToCategoriesInput = {
    where: BKCategoryWhereUniqueInput
    create: XOR<BKCategoryCreateWithoutTitleToCategoriesInput, BKCategoryUncheckedCreateWithoutTitleToCategoriesInput>
  }

  export type BKTitleUpsertWithoutTitleToCategoriesInput = {
    update: XOR<BKTitleUpdateWithoutTitleToCategoriesInput, BKTitleUncheckedUpdateWithoutTitleToCategoriesInput>
    create: XOR<BKTitleCreateWithoutTitleToCategoriesInput, BKTitleUncheckedCreateWithoutTitleToCategoriesInput>
  }

  export type BKTitleUpdateWithoutTitleToCategoriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    ISBN?: IntFieldUpdateOperationsInput | number
    copyQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    titleToAuthors?: TitleToAuthorUpdateManyWithoutTitleNestedInput
    universityToTitles?: UniversityToTitleUpdateManyWithoutTitleNestedInput
    copies?: BKCopyUpdateManyWithoutTitleNestedInput
  }

  export type BKTitleUncheckedUpdateWithoutTitleToCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    ISBN?: IntFieldUpdateOperationsInput | number
    copyQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    titleToAuthors?: TitleToAuthorUncheckedUpdateManyWithoutTitleNestedInput
    universityToTitles?: UniversityToTitleUncheckedUpdateManyWithoutTitleNestedInput
    copies?: BKCopyUncheckedUpdateManyWithoutTitleNestedInput
  }

  export type BKCategoryUpsertWithoutTitleToCategoriesInput = {
    update: XOR<BKCategoryUpdateWithoutTitleToCategoriesInput, BKCategoryUncheckedUpdateWithoutTitleToCategoriesInput>
    create: XOR<BKCategoryCreateWithoutTitleToCategoriesInput, BKCategoryUncheckedCreateWithoutTitleToCategoriesInput>
  }

  export type BKCategoryUpdateWithoutTitleToCategoriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BKCategoryUncheckedUpdateWithoutTitleToCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TitleToAuthorCreateWithoutAuthorInput = {
    title: BKTitleCreateNestedOneWithoutTitleToAuthorsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TitleToAuthorUncheckedCreateWithoutAuthorInput = {
    id?: number
    titleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TitleToAuthorCreateOrConnectWithoutAuthorInput = {
    where: TitleToAuthorWhereUniqueInput
    create: XOR<TitleToAuthorCreateWithoutAuthorInput, TitleToAuthorUncheckedCreateWithoutAuthorInput>
  }

  export type TitleToAuthorCreateManyAuthorInputEnvelope = {
    data: Enumerable<TitleToAuthorCreateManyAuthorInput>
    skipDuplicates?: boolean
  }

  export type TitleToAuthorUpsertWithWhereUniqueWithoutAuthorInput = {
    where: TitleToAuthorWhereUniqueInput
    update: XOR<TitleToAuthorUpdateWithoutAuthorInput, TitleToAuthorUncheckedUpdateWithoutAuthorInput>
    create: XOR<TitleToAuthorCreateWithoutAuthorInput, TitleToAuthorUncheckedCreateWithoutAuthorInput>
  }

  export type TitleToAuthorUpdateWithWhereUniqueWithoutAuthorInput = {
    where: TitleToAuthorWhereUniqueInput
    data: XOR<TitleToAuthorUpdateWithoutAuthorInput, TitleToAuthorUncheckedUpdateWithoutAuthorInput>
  }

  export type TitleToAuthorUpdateManyWithWhereWithoutAuthorInput = {
    where: TitleToAuthorScalarWhereInput
    data: XOR<TitleToAuthorUpdateManyMutationInput, TitleToAuthorUncheckedUpdateManyWithoutTitleToAuthorsInput>
  }

  export type BKTitleCreateWithoutTitleToAuthorsInput = {
    name: string
    ISBN: number
    copyQty: number
    createdAt?: Date | string
    updatedAt?: Date | string
    titleToCategories?: TitleToCategoryCreateNestedManyWithoutTitleInput
    universityToTitles?: UniversityToTitleCreateNestedManyWithoutTitleInput
    copies?: BKCopyCreateNestedManyWithoutTitleInput
  }

  export type BKTitleUncheckedCreateWithoutTitleToAuthorsInput = {
    id?: number
    name: string
    ISBN: number
    copyQty: number
    createdAt?: Date | string
    updatedAt?: Date | string
    titleToCategories?: TitleToCategoryUncheckedCreateNestedManyWithoutTitleInput
    universityToTitles?: UniversityToTitleUncheckedCreateNestedManyWithoutTitleInput
    copies?: BKCopyUncheckedCreateNestedManyWithoutTitleInput
  }

  export type BKTitleCreateOrConnectWithoutTitleToAuthorsInput = {
    where: BKTitleWhereUniqueInput
    create: XOR<BKTitleCreateWithoutTitleToAuthorsInput, BKTitleUncheckedCreateWithoutTitleToAuthorsInput>
  }

  export type BKAuthorCreateWithoutTitleToAuthorsInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BKAuthorUncheckedCreateWithoutTitleToAuthorsInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BKAuthorCreateOrConnectWithoutTitleToAuthorsInput = {
    where: BKAuthorWhereUniqueInput
    create: XOR<BKAuthorCreateWithoutTitleToAuthorsInput, BKAuthorUncheckedCreateWithoutTitleToAuthorsInput>
  }

  export type BKTitleUpsertWithoutTitleToAuthorsInput = {
    update: XOR<BKTitleUpdateWithoutTitleToAuthorsInput, BKTitleUncheckedUpdateWithoutTitleToAuthorsInput>
    create: XOR<BKTitleCreateWithoutTitleToAuthorsInput, BKTitleUncheckedCreateWithoutTitleToAuthorsInput>
  }

  export type BKTitleUpdateWithoutTitleToAuthorsInput = {
    name?: StringFieldUpdateOperationsInput | string
    ISBN?: IntFieldUpdateOperationsInput | number
    copyQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    titleToCategories?: TitleToCategoryUpdateManyWithoutTitleNestedInput
    universityToTitles?: UniversityToTitleUpdateManyWithoutTitleNestedInput
    copies?: BKCopyUpdateManyWithoutTitleNestedInput
  }

  export type BKTitleUncheckedUpdateWithoutTitleToAuthorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    ISBN?: IntFieldUpdateOperationsInput | number
    copyQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    titleToCategories?: TitleToCategoryUncheckedUpdateManyWithoutTitleNestedInput
    universityToTitles?: UniversityToTitleUncheckedUpdateManyWithoutTitleNestedInput
    copies?: BKCopyUncheckedUpdateManyWithoutTitleNestedInput
  }

  export type BKAuthorUpsertWithoutTitleToAuthorsInput = {
    update: XOR<BKAuthorUpdateWithoutTitleToAuthorsInput, BKAuthorUncheckedUpdateWithoutTitleToAuthorsInput>
    create: XOR<BKAuthorCreateWithoutTitleToAuthorsInput, BKAuthorUncheckedCreateWithoutTitleToAuthorsInput>
  }

  export type BKAuthorUpdateWithoutTitleToAuthorsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BKAuthorUncheckedUpdateWithoutTitleToAuthorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbPostCreateWithoutUserInput = {
    caption: string
    createdAt?: Date | string
    updatedAt?: Date | string
    postImages?: FbPostImageCreateNestedManyWithoutPostInput
    postVideoes?: FbPostVideoCreateNestedManyWithoutPostInput
    postOnHashtags?: FbPostOnHashtagCreateNestedManyWithoutPostInput
    shares?: FbShareCreateNestedManyWithoutPostInput
    likes?: FbLikeCreateNestedManyWithoutPostInput
    wall: FbWallCreateNestedOneWithoutPostsInput
  }

  export type FbPostUncheckedCreateWithoutUserInput = {
    id?: number
    caption: string
    createdAt?: Date | string
    updatedAt?: Date | string
    postImages?: FbPostImageUncheckedCreateNestedManyWithoutPostInput
    postVideoes?: FbPostVideoUncheckedCreateNestedManyWithoutPostInput
    postOnHashtags?: FbPostOnHashtagUncheckedCreateNestedManyWithoutPostInput
    shares?: FbShareUncheckedCreateNestedManyWithoutPostInput
    likes?: FbLikeUncheckedCreateNestedManyWithoutPostInput
    wallId: number
  }

  export type FbPostCreateOrConnectWithoutUserInput = {
    where: FbPostWhereUniqueInput
    create: XOR<FbPostCreateWithoutUserInput, FbPostUncheckedCreateWithoutUserInput>
  }

  export type FbPostCreateManyUserInputEnvelope = {
    data: Enumerable<FbPostCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type FbfriendCreateWithoutAcceptFriendInput = {
    requestFriend: FbUserCreateNestedOneWithoutRequestFbFriendsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbfriendUncheckedCreateWithoutAcceptFriendInput = {
    id?: number
    requestId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbfriendCreateOrConnectWithoutAcceptFriendInput = {
    where: FbfriendWhereUniqueInput
    create: XOR<FbfriendCreateWithoutAcceptFriendInput, FbfriendUncheckedCreateWithoutAcceptFriendInput>
  }

  export type FbfriendCreateManyAcceptFriendInputEnvelope = {
    data: Enumerable<FbfriendCreateManyAcceptFriendInput>
    skipDuplicates?: boolean
  }

  export type FbfriendCreateWithoutRequestFriendInput = {
    acceptFriend: FbUserCreateNestedOneWithoutAcceptFbFriendsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbfriendUncheckedCreateWithoutRequestFriendInput = {
    id?: number
    acceptId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbfriendCreateOrConnectWithoutRequestFriendInput = {
    where: FbfriendWhereUniqueInput
    create: XOR<FbfriendCreateWithoutRequestFriendInput, FbfriendUncheckedCreateWithoutRequestFriendInput>
  }

  export type FbfriendCreateManyRequestFriendInputEnvelope = {
    data: Enumerable<FbfriendCreateManyRequestFriendInput>
    skipDuplicates?: boolean
  }

  export type FbLikeCreateWithoutUserInput = {
    post: FbPostCreateNestedOneWithoutLikesInput
    comment: FbCommentCreateNestedOneWithoutLikesInput
    share: FbShareCreateNestedOneWithoutLikesInput
    likeType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbLikeUncheckedCreateWithoutUserInput = {
    id?: number
    postId: number
    commentId: number
    shareId: number
    likeType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbLikeCreateOrConnectWithoutUserInput = {
    where: FbLikeWhereUniqueInput
    create: XOR<FbLikeCreateWithoutUserInput, FbLikeUncheckedCreateWithoutUserInput>
  }

  export type FbLikeCreateManyUserInputEnvelope = {
    data: Enumerable<FbLikeCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type FbMessengerCreateWithoutFromInput = {
    to: FbUserCreateNestedOneWithoutToMessengersInput
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbMessengerUncheckedCreateWithoutFromInput = {
    id?: number
    toUserId: number
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbMessengerCreateOrConnectWithoutFromInput = {
    where: FbMessengerWhereUniqueInput
    create: XOR<FbMessengerCreateWithoutFromInput, FbMessengerUncheckedCreateWithoutFromInput>
  }

  export type FbMessengerCreateManyFromInputEnvelope = {
    data: Enumerable<FbMessengerCreateManyFromInput>
    skipDuplicates?: boolean
  }

  export type FbMessengerCreateWithoutToInput = {
    from: FbUserCreateNestedOneWithoutFromMessengersInput
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbMessengerUncheckedCreateWithoutToInput = {
    id?: number
    fromuserId: number
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbMessengerCreateOrConnectWithoutToInput = {
    where: FbMessengerWhereUniqueInput
    create: XOR<FbMessengerCreateWithoutToInput, FbMessengerUncheckedCreateWithoutToInput>
  }

  export type FbMessengerCreateManyToInputEnvelope = {
    data: Enumerable<FbMessengerCreateManyToInput>
    skipDuplicates?: boolean
  }

  export type FbShareCreateWithoutUserInput = {
    post: FbPostCreateNestedOneWithoutSharesInput
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: FbLikeCreateNestedManyWithoutShareInput
    destinationUsers?: FbDestinationUserCreateNestedManyWithoutShareInput
  }

  export type FbShareUncheckedCreateWithoutUserInput = {
    id?: number
    postId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: FbLikeUncheckedCreateNestedManyWithoutShareInput
    destinationUsers?: FbDestinationUserUncheckedCreateNestedManyWithoutShareInput
  }

  export type FbShareCreateOrConnectWithoutUserInput = {
    where: FbShareWhereUniqueInput
    create: XOR<FbShareCreateWithoutUserInput, FbShareUncheckedCreateWithoutUserInput>
  }

  export type FbShareCreateManyUserInputEnvelope = {
    data: Enumerable<FbShareCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type FbCommentCreateWithoutUserInput = {
    text: string
    likes?: FbLikeCreateNestedManyWithoutCommentInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbCommentUncheckedCreateWithoutUserInput = {
    id?: number
    text: string
    likes?: FbLikeUncheckedCreateNestedManyWithoutCommentInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbCommentCreateOrConnectWithoutUserInput = {
    where: FbCommentWhereUniqueInput
    create: XOR<FbCommentCreateWithoutUserInput, FbCommentUncheckedCreateWithoutUserInput>
  }

  export type FbCommentCreateManyUserInputEnvelope = {
    data: Enumerable<FbCommentCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type GroupToUserCreateWithoutUserInput = {
    group: FbGroupCreateNestedOneWithoutGroupToUsersInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupToUserUncheckedCreateWithoutUserInput = {
    id?: number
    groupId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupToUserCreateOrConnectWithoutUserInput = {
    where: GroupToUserWhereUniqueInput
    create: XOR<GroupToUserCreateWithoutUserInput, GroupToUserUncheckedCreateWithoutUserInput>
  }

  export type GroupToUserCreateManyUserInputEnvelope = {
    data: Enumerable<GroupToUserCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type FbPostUpsertWithWhereUniqueWithoutUserInput = {
    where: FbPostWhereUniqueInput
    update: XOR<FbPostUpdateWithoutUserInput, FbPostUncheckedUpdateWithoutUserInput>
    create: XOR<FbPostCreateWithoutUserInput, FbPostUncheckedCreateWithoutUserInput>
  }

  export type FbPostUpdateWithWhereUniqueWithoutUserInput = {
    where: FbPostWhereUniqueInput
    data: XOR<FbPostUpdateWithoutUserInput, FbPostUncheckedUpdateWithoutUserInput>
  }

  export type FbPostUpdateManyWithWhereWithoutUserInput = {
    where: FbPostScalarWhereInput
    data: XOR<FbPostUpdateManyMutationInput, FbPostUncheckedUpdateManyWithoutPostsInput>
  }

  export type FbPostScalarWhereInput = {
    AND?: Enumerable<FbPostScalarWhereInput>
    OR?: Enumerable<FbPostScalarWhereInput>
    NOT?: Enumerable<FbPostScalarWhereInput>
    id?: IntFilter | number
    caption?: StringFilter | string
    userId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    wallId?: IntFilter | number
  }

  export type FbfriendUpsertWithWhereUniqueWithoutAcceptFriendInput = {
    where: FbfriendWhereUniqueInput
    update: XOR<FbfriendUpdateWithoutAcceptFriendInput, FbfriendUncheckedUpdateWithoutAcceptFriendInput>
    create: XOR<FbfriendCreateWithoutAcceptFriendInput, FbfriendUncheckedCreateWithoutAcceptFriendInput>
  }

  export type FbfriendUpdateWithWhereUniqueWithoutAcceptFriendInput = {
    where: FbfriendWhereUniqueInput
    data: XOR<FbfriendUpdateWithoutAcceptFriendInput, FbfriendUncheckedUpdateWithoutAcceptFriendInput>
  }

  export type FbfriendUpdateManyWithWhereWithoutAcceptFriendInput = {
    where: FbfriendScalarWhereInput
    data: XOR<FbfriendUpdateManyMutationInput, FbfriendUncheckedUpdateManyWithoutAcceptFbFriendsInput>
  }

  export type FbfriendScalarWhereInput = {
    AND?: Enumerable<FbfriendScalarWhereInput>
    OR?: Enumerable<FbfriendScalarWhereInput>
    NOT?: Enumerable<FbfriendScalarWhereInput>
    id?: IntFilter | number
    acceptId?: IntFilter | number
    requestId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type FbfriendUpsertWithWhereUniqueWithoutRequestFriendInput = {
    where: FbfriendWhereUniqueInput
    update: XOR<FbfriendUpdateWithoutRequestFriendInput, FbfriendUncheckedUpdateWithoutRequestFriendInput>
    create: XOR<FbfriendCreateWithoutRequestFriendInput, FbfriendUncheckedCreateWithoutRequestFriendInput>
  }

  export type FbfriendUpdateWithWhereUniqueWithoutRequestFriendInput = {
    where: FbfriendWhereUniqueInput
    data: XOR<FbfriendUpdateWithoutRequestFriendInput, FbfriendUncheckedUpdateWithoutRequestFriendInput>
  }

  export type FbfriendUpdateManyWithWhereWithoutRequestFriendInput = {
    where: FbfriendScalarWhereInput
    data: XOR<FbfriendUpdateManyMutationInput, FbfriendUncheckedUpdateManyWithoutRequestFbFriendsInput>
  }

  export type FbLikeUpsertWithWhereUniqueWithoutUserInput = {
    where: FbLikeWhereUniqueInput
    update: XOR<FbLikeUpdateWithoutUserInput, FbLikeUncheckedUpdateWithoutUserInput>
    create: XOR<FbLikeCreateWithoutUserInput, FbLikeUncheckedCreateWithoutUserInput>
  }

  export type FbLikeUpdateWithWhereUniqueWithoutUserInput = {
    where: FbLikeWhereUniqueInput
    data: XOR<FbLikeUpdateWithoutUserInput, FbLikeUncheckedUpdateWithoutUserInput>
  }

  export type FbLikeUpdateManyWithWhereWithoutUserInput = {
    where: FbLikeScalarWhereInput
    data: XOR<FbLikeUpdateManyMutationInput, FbLikeUncheckedUpdateManyWithoutLikesInput>
  }

  export type FbLikeScalarWhereInput = {
    AND?: Enumerable<FbLikeScalarWhereInput>
    OR?: Enumerable<FbLikeScalarWhereInput>
    NOT?: Enumerable<FbLikeScalarWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    postId?: IntFilter | number
    commentId?: IntFilter | number
    shareId?: IntFilter | number
    likeType?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type FbMessengerUpsertWithWhereUniqueWithoutFromInput = {
    where: FbMessengerWhereUniqueInput
    update: XOR<FbMessengerUpdateWithoutFromInput, FbMessengerUncheckedUpdateWithoutFromInput>
    create: XOR<FbMessengerCreateWithoutFromInput, FbMessengerUncheckedCreateWithoutFromInput>
  }

  export type FbMessengerUpdateWithWhereUniqueWithoutFromInput = {
    where: FbMessengerWhereUniqueInput
    data: XOR<FbMessengerUpdateWithoutFromInput, FbMessengerUncheckedUpdateWithoutFromInput>
  }

  export type FbMessengerUpdateManyWithWhereWithoutFromInput = {
    where: FbMessengerScalarWhereInput
    data: XOR<FbMessengerUpdateManyMutationInput, FbMessengerUncheckedUpdateManyWithoutFromMessengersInput>
  }

  export type FbMessengerScalarWhereInput = {
    AND?: Enumerable<FbMessengerScalarWhereInput>
    OR?: Enumerable<FbMessengerScalarWhereInput>
    NOT?: Enumerable<FbMessengerScalarWhereInput>
    id?: IntFilter | number
    fromuserId?: IntFilter | number
    toUserId?: IntFilter | number
    text?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type FbMessengerUpsertWithWhereUniqueWithoutToInput = {
    where: FbMessengerWhereUniqueInput
    update: XOR<FbMessengerUpdateWithoutToInput, FbMessengerUncheckedUpdateWithoutToInput>
    create: XOR<FbMessengerCreateWithoutToInput, FbMessengerUncheckedCreateWithoutToInput>
  }

  export type FbMessengerUpdateWithWhereUniqueWithoutToInput = {
    where: FbMessengerWhereUniqueInput
    data: XOR<FbMessengerUpdateWithoutToInput, FbMessengerUncheckedUpdateWithoutToInput>
  }

  export type FbMessengerUpdateManyWithWhereWithoutToInput = {
    where: FbMessengerScalarWhereInput
    data: XOR<FbMessengerUpdateManyMutationInput, FbMessengerUncheckedUpdateManyWithoutToMessengersInput>
  }

  export type FbShareUpsertWithWhereUniqueWithoutUserInput = {
    where: FbShareWhereUniqueInput
    update: XOR<FbShareUpdateWithoutUserInput, FbShareUncheckedUpdateWithoutUserInput>
    create: XOR<FbShareCreateWithoutUserInput, FbShareUncheckedCreateWithoutUserInput>
  }

  export type FbShareUpdateWithWhereUniqueWithoutUserInput = {
    where: FbShareWhereUniqueInput
    data: XOR<FbShareUpdateWithoutUserInput, FbShareUncheckedUpdateWithoutUserInput>
  }

  export type FbShareUpdateManyWithWhereWithoutUserInput = {
    where: FbShareScalarWhereInput
    data: XOR<FbShareUpdateManyMutationInput, FbShareUncheckedUpdateManyWithoutSharesInput>
  }

  export type FbShareScalarWhereInput = {
    AND?: Enumerable<FbShareScalarWhereInput>
    OR?: Enumerable<FbShareScalarWhereInput>
    NOT?: Enumerable<FbShareScalarWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    postId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type FbCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: FbCommentWhereUniqueInput
    update: XOR<FbCommentUpdateWithoutUserInput, FbCommentUncheckedUpdateWithoutUserInput>
    create: XOR<FbCommentCreateWithoutUserInput, FbCommentUncheckedCreateWithoutUserInput>
  }

  export type FbCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: FbCommentWhereUniqueInput
    data: XOR<FbCommentUpdateWithoutUserInput, FbCommentUncheckedUpdateWithoutUserInput>
  }

  export type FbCommentUpdateManyWithWhereWithoutUserInput = {
    where: FbCommentScalarWhereInput
    data: XOR<FbCommentUpdateManyMutationInput, FbCommentUncheckedUpdateManyWithoutCommentsInput>
  }

  export type FbCommentScalarWhereInput = {
    AND?: Enumerable<FbCommentScalarWhereInput>
    OR?: Enumerable<FbCommentScalarWhereInput>
    NOT?: Enumerable<FbCommentScalarWhereInput>
    id?: IntFilter | number
    text?: StringFilter | string
    userId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type GroupToUserUpsertWithWhereUniqueWithoutUserInput = {
    where: GroupToUserWhereUniqueInput
    update: XOR<GroupToUserUpdateWithoutUserInput, GroupToUserUncheckedUpdateWithoutUserInput>
    create: XOR<GroupToUserCreateWithoutUserInput, GroupToUserUncheckedCreateWithoutUserInput>
  }

  export type GroupToUserUpdateWithWhereUniqueWithoutUserInput = {
    where: GroupToUserWhereUniqueInput
    data: XOR<GroupToUserUpdateWithoutUserInput, GroupToUserUncheckedUpdateWithoutUserInput>
  }

  export type GroupToUserUpdateManyWithWhereWithoutUserInput = {
    where: GroupToUserScalarWhereInput
    data: XOR<GroupToUserUpdateManyMutationInput, GroupToUserUncheckedUpdateManyWithoutGroupToUsersInput>
  }

  export type GroupToUserScalarWhereInput = {
    AND?: Enumerable<GroupToUserScalarWhereInput>
    OR?: Enumerable<GroupToUserScalarWhereInput>
    NOT?: Enumerable<GroupToUserScalarWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    groupId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type FbUserCreateWithoutPostsInput = {
    name: string
    image: string
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    acceptFbFriends?: FbfriendCreateNestedManyWithoutAcceptFriendInput
    requestFbFriends?: FbfriendCreateNestedManyWithoutRequestFriendInput
    likes?: FbLikeCreateNestedManyWithoutUserInput
    fromMessengers?: FbMessengerCreateNestedManyWithoutFromInput
    toMessengers?: FbMessengerCreateNestedManyWithoutToInput
    shares?: FbShareCreateNestedManyWithoutUserInput
    comments?: FbCommentCreateNestedManyWithoutUserInput
    groupToUsers?: GroupToUserCreateNestedManyWithoutUserInput
  }

  export type FbUserUncheckedCreateWithoutPostsInput = {
    id?: number
    name: string
    image: string
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    acceptFbFriends?: FbfriendUncheckedCreateNestedManyWithoutAcceptFriendInput
    requestFbFriends?: FbfriendUncheckedCreateNestedManyWithoutRequestFriendInput
    likes?: FbLikeUncheckedCreateNestedManyWithoutUserInput
    fromMessengers?: FbMessengerUncheckedCreateNestedManyWithoutFromInput
    toMessengers?: FbMessengerUncheckedCreateNestedManyWithoutToInput
    shares?: FbShareUncheckedCreateNestedManyWithoutUserInput
    comments?: FbCommentUncheckedCreateNestedManyWithoutUserInput
    groupToUsers?: GroupToUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type FbUserCreateOrConnectWithoutPostsInput = {
    where: FbUserWhereUniqueInput
    create: XOR<FbUserCreateWithoutPostsInput, FbUserUncheckedCreateWithoutPostsInput>
  }

  export type FbPostImageCreateWithoutPostInput = {
    image: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbPostImageUncheckedCreateWithoutPostInput = {
    id?: number
    image: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbPostImageCreateOrConnectWithoutPostInput = {
    where: FbPostImageWhereUniqueInput
    create: XOR<FbPostImageCreateWithoutPostInput, FbPostImageUncheckedCreateWithoutPostInput>
  }

  export type FbPostImageCreateManyPostInputEnvelope = {
    data: Enumerable<FbPostImageCreateManyPostInput>
    skipDuplicates?: boolean
  }

  export type FbPostVideoCreateWithoutPostInput = {
    video: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbPostVideoUncheckedCreateWithoutPostInput = {
    id?: number
    video: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbPostVideoCreateOrConnectWithoutPostInput = {
    where: FbPostVideoWhereUniqueInput
    create: XOR<FbPostVideoCreateWithoutPostInput, FbPostVideoUncheckedCreateWithoutPostInput>
  }

  export type FbPostVideoCreateManyPostInputEnvelope = {
    data: Enumerable<FbPostVideoCreateManyPostInput>
    skipDuplicates?: boolean
  }

  export type FbPostOnHashtagCreateWithoutPostInput = {
    hashtag: FbHashtagCreateNestedOneWithoutPostOnHashtagsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbPostOnHashtagUncheckedCreateWithoutPostInput = {
    id?: number
    hashtagId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbPostOnHashtagCreateOrConnectWithoutPostInput = {
    where: FbPostOnHashtagWhereUniqueInput
    create: XOR<FbPostOnHashtagCreateWithoutPostInput, FbPostOnHashtagUncheckedCreateWithoutPostInput>
  }

  export type FbPostOnHashtagCreateManyPostInputEnvelope = {
    data: Enumerable<FbPostOnHashtagCreateManyPostInput>
    skipDuplicates?: boolean
  }

  export type FbShareCreateWithoutPostInput = {
    user: FbUserCreateNestedOneWithoutSharesInput
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: FbLikeCreateNestedManyWithoutShareInput
    destinationUsers?: FbDestinationUserCreateNestedManyWithoutShareInput
  }

  export type FbShareUncheckedCreateWithoutPostInput = {
    id?: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: FbLikeUncheckedCreateNestedManyWithoutShareInput
    destinationUsers?: FbDestinationUserUncheckedCreateNestedManyWithoutShareInput
  }

  export type FbShareCreateOrConnectWithoutPostInput = {
    where: FbShareWhereUniqueInput
    create: XOR<FbShareCreateWithoutPostInput, FbShareUncheckedCreateWithoutPostInput>
  }

  export type FbShareCreateManyPostInputEnvelope = {
    data: Enumerable<FbShareCreateManyPostInput>
    skipDuplicates?: boolean
  }

  export type FbLikeCreateWithoutPostInput = {
    user: FbUserCreateNestedOneWithoutLikesInput
    comment: FbCommentCreateNestedOneWithoutLikesInput
    share: FbShareCreateNestedOneWithoutLikesInput
    likeType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbLikeUncheckedCreateWithoutPostInput = {
    id?: number
    userId: number
    commentId: number
    shareId: number
    likeType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbLikeCreateOrConnectWithoutPostInput = {
    where: FbLikeWhereUniqueInput
    create: XOR<FbLikeCreateWithoutPostInput, FbLikeUncheckedCreateWithoutPostInput>
  }

  export type FbLikeCreateManyPostInputEnvelope = {
    data: Enumerable<FbLikeCreateManyPostInput>
    skipDuplicates?: boolean
  }

  export type FbWallCreateWithoutPostsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    destinationUsers?: FbDestinationUserCreateNestedManyWithoutWallInput
  }

  export type FbWallUncheckedCreateWithoutPostsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    destinationUsers?: FbDestinationUserUncheckedCreateNestedManyWithoutWallInput
  }

  export type FbWallCreateOrConnectWithoutPostsInput = {
    where: FbWallWhereUniqueInput
    create: XOR<FbWallCreateWithoutPostsInput, FbWallUncheckedCreateWithoutPostsInput>
  }

  export type FbUserUpsertWithoutPostsInput = {
    update: XOR<FbUserUpdateWithoutPostsInput, FbUserUncheckedUpdateWithoutPostsInput>
    create: XOR<FbUserCreateWithoutPostsInput, FbUserUncheckedCreateWithoutPostsInput>
  }

  export type FbUserUpdateWithoutPostsInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptFbFriends?: FbfriendUpdateManyWithoutAcceptFriendNestedInput
    requestFbFriends?: FbfriendUpdateManyWithoutRequestFriendNestedInput
    likes?: FbLikeUpdateManyWithoutUserNestedInput
    fromMessengers?: FbMessengerUpdateManyWithoutFromNestedInput
    toMessengers?: FbMessengerUpdateManyWithoutToNestedInput
    shares?: FbShareUpdateManyWithoutUserNestedInput
    comments?: FbCommentUpdateManyWithoutUserNestedInput
    groupToUsers?: GroupToUserUpdateManyWithoutUserNestedInput
  }

  export type FbUserUncheckedUpdateWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptFbFriends?: FbfriendUncheckedUpdateManyWithoutAcceptFriendNestedInput
    requestFbFriends?: FbfriendUncheckedUpdateManyWithoutRequestFriendNestedInput
    likes?: FbLikeUncheckedUpdateManyWithoutUserNestedInput
    fromMessengers?: FbMessengerUncheckedUpdateManyWithoutFromNestedInput
    toMessengers?: FbMessengerUncheckedUpdateManyWithoutToNestedInput
    shares?: FbShareUncheckedUpdateManyWithoutUserNestedInput
    comments?: FbCommentUncheckedUpdateManyWithoutUserNestedInput
    groupToUsers?: GroupToUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FbPostImageUpsertWithWhereUniqueWithoutPostInput = {
    where: FbPostImageWhereUniqueInput
    update: XOR<FbPostImageUpdateWithoutPostInput, FbPostImageUncheckedUpdateWithoutPostInput>
    create: XOR<FbPostImageCreateWithoutPostInput, FbPostImageUncheckedCreateWithoutPostInput>
  }

  export type FbPostImageUpdateWithWhereUniqueWithoutPostInput = {
    where: FbPostImageWhereUniqueInput
    data: XOR<FbPostImageUpdateWithoutPostInput, FbPostImageUncheckedUpdateWithoutPostInput>
  }

  export type FbPostImageUpdateManyWithWhereWithoutPostInput = {
    where: FbPostImageScalarWhereInput
    data: XOR<FbPostImageUpdateManyMutationInput, FbPostImageUncheckedUpdateManyWithoutPostImagesInput>
  }

  export type FbPostImageScalarWhereInput = {
    AND?: Enumerable<FbPostImageScalarWhereInput>
    OR?: Enumerable<FbPostImageScalarWhereInput>
    NOT?: Enumerable<FbPostImageScalarWhereInput>
    id?: IntFilter | number
    image?: StringFilter | string
    postId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type FbPostVideoUpsertWithWhereUniqueWithoutPostInput = {
    where: FbPostVideoWhereUniqueInput
    update: XOR<FbPostVideoUpdateWithoutPostInput, FbPostVideoUncheckedUpdateWithoutPostInput>
    create: XOR<FbPostVideoCreateWithoutPostInput, FbPostVideoUncheckedCreateWithoutPostInput>
  }

  export type FbPostVideoUpdateWithWhereUniqueWithoutPostInput = {
    where: FbPostVideoWhereUniqueInput
    data: XOR<FbPostVideoUpdateWithoutPostInput, FbPostVideoUncheckedUpdateWithoutPostInput>
  }

  export type FbPostVideoUpdateManyWithWhereWithoutPostInput = {
    where: FbPostVideoScalarWhereInput
    data: XOR<FbPostVideoUpdateManyMutationInput, FbPostVideoUncheckedUpdateManyWithoutPostVideoesInput>
  }

  export type FbPostVideoScalarWhereInput = {
    AND?: Enumerable<FbPostVideoScalarWhereInput>
    OR?: Enumerable<FbPostVideoScalarWhereInput>
    NOT?: Enumerable<FbPostVideoScalarWhereInput>
    id?: IntFilter | number
    video?: StringFilter | string
    postId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type FbPostOnHashtagUpsertWithWhereUniqueWithoutPostInput = {
    where: FbPostOnHashtagWhereUniqueInput
    update: XOR<FbPostOnHashtagUpdateWithoutPostInput, FbPostOnHashtagUncheckedUpdateWithoutPostInput>
    create: XOR<FbPostOnHashtagCreateWithoutPostInput, FbPostOnHashtagUncheckedCreateWithoutPostInput>
  }

  export type FbPostOnHashtagUpdateWithWhereUniqueWithoutPostInput = {
    where: FbPostOnHashtagWhereUniqueInput
    data: XOR<FbPostOnHashtagUpdateWithoutPostInput, FbPostOnHashtagUncheckedUpdateWithoutPostInput>
  }

  export type FbPostOnHashtagUpdateManyWithWhereWithoutPostInput = {
    where: FbPostOnHashtagScalarWhereInput
    data: XOR<FbPostOnHashtagUpdateManyMutationInput, FbPostOnHashtagUncheckedUpdateManyWithoutPostOnHashtagsInput>
  }

  export type FbPostOnHashtagScalarWhereInput = {
    AND?: Enumerable<FbPostOnHashtagScalarWhereInput>
    OR?: Enumerable<FbPostOnHashtagScalarWhereInput>
    NOT?: Enumerable<FbPostOnHashtagScalarWhereInput>
    id?: IntFilter | number
    postId?: IntFilter | number
    hashtagId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type FbShareUpsertWithWhereUniqueWithoutPostInput = {
    where: FbShareWhereUniqueInput
    update: XOR<FbShareUpdateWithoutPostInput, FbShareUncheckedUpdateWithoutPostInput>
    create: XOR<FbShareCreateWithoutPostInput, FbShareUncheckedCreateWithoutPostInput>
  }

  export type FbShareUpdateWithWhereUniqueWithoutPostInput = {
    where: FbShareWhereUniqueInput
    data: XOR<FbShareUpdateWithoutPostInput, FbShareUncheckedUpdateWithoutPostInput>
  }

  export type FbShareUpdateManyWithWhereWithoutPostInput = {
    where: FbShareScalarWhereInput
    data: XOR<FbShareUpdateManyMutationInput, FbShareUncheckedUpdateManyWithoutSharesInput>
  }

  export type FbLikeUpsertWithWhereUniqueWithoutPostInput = {
    where: FbLikeWhereUniqueInput
    update: XOR<FbLikeUpdateWithoutPostInput, FbLikeUncheckedUpdateWithoutPostInput>
    create: XOR<FbLikeCreateWithoutPostInput, FbLikeUncheckedCreateWithoutPostInput>
  }

  export type FbLikeUpdateWithWhereUniqueWithoutPostInput = {
    where: FbLikeWhereUniqueInput
    data: XOR<FbLikeUpdateWithoutPostInput, FbLikeUncheckedUpdateWithoutPostInput>
  }

  export type FbLikeUpdateManyWithWhereWithoutPostInput = {
    where: FbLikeScalarWhereInput
    data: XOR<FbLikeUpdateManyMutationInput, FbLikeUncheckedUpdateManyWithoutLikesInput>
  }

  export type FbWallUpsertWithoutPostsInput = {
    update: XOR<FbWallUpdateWithoutPostsInput, FbWallUncheckedUpdateWithoutPostsInput>
    create: XOR<FbWallCreateWithoutPostsInput, FbWallUncheckedCreateWithoutPostsInput>
  }

  export type FbWallUpdateWithoutPostsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    destinationUsers?: FbDestinationUserUpdateManyWithoutWallNestedInput
  }

  export type FbWallUncheckedUpdateWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    destinationUsers?: FbDestinationUserUncheckedUpdateManyWithoutWallNestedInput
  }

  export type FbPostCreateWithoutPostImagesInput = {
    caption: string
    user: FbUserCreateNestedOneWithoutPostsInput
    createdAt?: Date | string
    updatedAt?: Date | string
    postVideoes?: FbPostVideoCreateNestedManyWithoutPostInput
    postOnHashtags?: FbPostOnHashtagCreateNestedManyWithoutPostInput
    shares?: FbShareCreateNestedManyWithoutPostInput
    likes?: FbLikeCreateNestedManyWithoutPostInput
    wall: FbWallCreateNestedOneWithoutPostsInput
  }

  export type FbPostUncheckedCreateWithoutPostImagesInput = {
    id?: number
    caption: string
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    postVideoes?: FbPostVideoUncheckedCreateNestedManyWithoutPostInput
    postOnHashtags?: FbPostOnHashtagUncheckedCreateNestedManyWithoutPostInput
    shares?: FbShareUncheckedCreateNestedManyWithoutPostInput
    likes?: FbLikeUncheckedCreateNestedManyWithoutPostInput
    wallId: number
  }

  export type FbPostCreateOrConnectWithoutPostImagesInput = {
    where: FbPostWhereUniqueInput
    create: XOR<FbPostCreateWithoutPostImagesInput, FbPostUncheckedCreateWithoutPostImagesInput>
  }

  export type FbPostUpsertWithoutPostImagesInput = {
    update: XOR<FbPostUpdateWithoutPostImagesInput, FbPostUncheckedUpdateWithoutPostImagesInput>
    create: XOR<FbPostCreateWithoutPostImagesInput, FbPostUncheckedCreateWithoutPostImagesInput>
  }

  export type FbPostUpdateWithoutPostImagesInput = {
    caption?: StringFieldUpdateOperationsInput | string
    user?: FbUserUpdateOneRequiredWithoutPostsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postVideoes?: FbPostVideoUpdateManyWithoutPostNestedInput
    postOnHashtags?: FbPostOnHashtagUpdateManyWithoutPostNestedInput
    shares?: FbShareUpdateManyWithoutPostNestedInput
    likes?: FbLikeUpdateManyWithoutPostNestedInput
    wall?: FbWallUpdateOneRequiredWithoutPostsNestedInput
  }

  export type FbPostUncheckedUpdateWithoutPostImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    caption?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postVideoes?: FbPostVideoUncheckedUpdateManyWithoutPostNestedInput
    postOnHashtags?: FbPostOnHashtagUncheckedUpdateManyWithoutPostNestedInput
    shares?: FbShareUncheckedUpdateManyWithoutPostNestedInput
    likes?: FbLikeUncheckedUpdateManyWithoutPostNestedInput
    wallId?: IntFieldUpdateOperationsInput | number
  }

  export type FbPostCreateWithoutPostVideoesInput = {
    caption: string
    user: FbUserCreateNestedOneWithoutPostsInput
    createdAt?: Date | string
    updatedAt?: Date | string
    postImages?: FbPostImageCreateNestedManyWithoutPostInput
    postOnHashtags?: FbPostOnHashtagCreateNestedManyWithoutPostInput
    shares?: FbShareCreateNestedManyWithoutPostInput
    likes?: FbLikeCreateNestedManyWithoutPostInput
    wall: FbWallCreateNestedOneWithoutPostsInput
  }

  export type FbPostUncheckedCreateWithoutPostVideoesInput = {
    id?: number
    caption: string
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    postImages?: FbPostImageUncheckedCreateNestedManyWithoutPostInput
    postOnHashtags?: FbPostOnHashtagUncheckedCreateNestedManyWithoutPostInput
    shares?: FbShareUncheckedCreateNestedManyWithoutPostInput
    likes?: FbLikeUncheckedCreateNestedManyWithoutPostInput
    wallId: number
  }

  export type FbPostCreateOrConnectWithoutPostVideoesInput = {
    where: FbPostWhereUniqueInput
    create: XOR<FbPostCreateWithoutPostVideoesInput, FbPostUncheckedCreateWithoutPostVideoesInput>
  }

  export type FbPostUpsertWithoutPostVideoesInput = {
    update: XOR<FbPostUpdateWithoutPostVideoesInput, FbPostUncheckedUpdateWithoutPostVideoesInput>
    create: XOR<FbPostCreateWithoutPostVideoesInput, FbPostUncheckedCreateWithoutPostVideoesInput>
  }

  export type FbPostUpdateWithoutPostVideoesInput = {
    caption?: StringFieldUpdateOperationsInput | string
    user?: FbUserUpdateOneRequiredWithoutPostsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postImages?: FbPostImageUpdateManyWithoutPostNestedInput
    postOnHashtags?: FbPostOnHashtagUpdateManyWithoutPostNestedInput
    shares?: FbShareUpdateManyWithoutPostNestedInput
    likes?: FbLikeUpdateManyWithoutPostNestedInput
    wall?: FbWallUpdateOneRequiredWithoutPostsNestedInput
  }

  export type FbPostUncheckedUpdateWithoutPostVideoesInput = {
    id?: IntFieldUpdateOperationsInput | number
    caption?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postImages?: FbPostImageUncheckedUpdateManyWithoutPostNestedInput
    postOnHashtags?: FbPostOnHashtagUncheckedUpdateManyWithoutPostNestedInput
    shares?: FbShareUncheckedUpdateManyWithoutPostNestedInput
    likes?: FbLikeUncheckedUpdateManyWithoutPostNestedInput
    wallId?: IntFieldUpdateOperationsInput | number
  }

  export type FbPostOnHashtagCreateWithoutHashtagInput = {
    post: FbPostCreateNestedOneWithoutPostOnHashtagsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbPostOnHashtagUncheckedCreateWithoutHashtagInput = {
    id?: number
    postId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbPostOnHashtagCreateOrConnectWithoutHashtagInput = {
    where: FbPostOnHashtagWhereUniqueInput
    create: XOR<FbPostOnHashtagCreateWithoutHashtagInput, FbPostOnHashtagUncheckedCreateWithoutHashtagInput>
  }

  export type FbPostOnHashtagCreateManyHashtagInputEnvelope = {
    data: Enumerable<FbPostOnHashtagCreateManyHashtagInput>
    skipDuplicates?: boolean
  }

  export type FbPostOnHashtagUpsertWithWhereUniqueWithoutHashtagInput = {
    where: FbPostOnHashtagWhereUniqueInput
    update: XOR<FbPostOnHashtagUpdateWithoutHashtagInput, FbPostOnHashtagUncheckedUpdateWithoutHashtagInput>
    create: XOR<FbPostOnHashtagCreateWithoutHashtagInput, FbPostOnHashtagUncheckedCreateWithoutHashtagInput>
  }

  export type FbPostOnHashtagUpdateWithWhereUniqueWithoutHashtagInput = {
    where: FbPostOnHashtagWhereUniqueInput
    data: XOR<FbPostOnHashtagUpdateWithoutHashtagInput, FbPostOnHashtagUncheckedUpdateWithoutHashtagInput>
  }

  export type FbPostOnHashtagUpdateManyWithWhereWithoutHashtagInput = {
    where: FbPostOnHashtagScalarWhereInput
    data: XOR<FbPostOnHashtagUpdateManyMutationInput, FbPostOnHashtagUncheckedUpdateManyWithoutPostOnHashtagsInput>
  }

  export type FbPostCreateWithoutPostOnHashtagsInput = {
    caption: string
    user: FbUserCreateNestedOneWithoutPostsInput
    createdAt?: Date | string
    updatedAt?: Date | string
    postImages?: FbPostImageCreateNestedManyWithoutPostInput
    postVideoes?: FbPostVideoCreateNestedManyWithoutPostInput
    shares?: FbShareCreateNestedManyWithoutPostInput
    likes?: FbLikeCreateNestedManyWithoutPostInput
    wall: FbWallCreateNestedOneWithoutPostsInput
  }

  export type FbPostUncheckedCreateWithoutPostOnHashtagsInput = {
    id?: number
    caption: string
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    postImages?: FbPostImageUncheckedCreateNestedManyWithoutPostInput
    postVideoes?: FbPostVideoUncheckedCreateNestedManyWithoutPostInput
    shares?: FbShareUncheckedCreateNestedManyWithoutPostInput
    likes?: FbLikeUncheckedCreateNestedManyWithoutPostInput
    wallId: number
  }

  export type FbPostCreateOrConnectWithoutPostOnHashtagsInput = {
    where: FbPostWhereUniqueInput
    create: XOR<FbPostCreateWithoutPostOnHashtagsInput, FbPostUncheckedCreateWithoutPostOnHashtagsInput>
  }

  export type FbHashtagCreateWithoutPostOnHashtagsInput = {
    hashtag: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbHashtagUncheckedCreateWithoutPostOnHashtagsInput = {
    id?: number
    hashtag: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbHashtagCreateOrConnectWithoutPostOnHashtagsInput = {
    where: FbHashtagWhereUniqueInput
    create: XOR<FbHashtagCreateWithoutPostOnHashtagsInput, FbHashtagUncheckedCreateWithoutPostOnHashtagsInput>
  }

  export type FbPostUpsertWithoutPostOnHashtagsInput = {
    update: XOR<FbPostUpdateWithoutPostOnHashtagsInput, FbPostUncheckedUpdateWithoutPostOnHashtagsInput>
    create: XOR<FbPostCreateWithoutPostOnHashtagsInput, FbPostUncheckedCreateWithoutPostOnHashtagsInput>
  }

  export type FbPostUpdateWithoutPostOnHashtagsInput = {
    caption?: StringFieldUpdateOperationsInput | string
    user?: FbUserUpdateOneRequiredWithoutPostsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postImages?: FbPostImageUpdateManyWithoutPostNestedInput
    postVideoes?: FbPostVideoUpdateManyWithoutPostNestedInput
    shares?: FbShareUpdateManyWithoutPostNestedInput
    likes?: FbLikeUpdateManyWithoutPostNestedInput
    wall?: FbWallUpdateOneRequiredWithoutPostsNestedInput
  }

  export type FbPostUncheckedUpdateWithoutPostOnHashtagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    caption?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postImages?: FbPostImageUncheckedUpdateManyWithoutPostNestedInput
    postVideoes?: FbPostVideoUncheckedUpdateManyWithoutPostNestedInput
    shares?: FbShareUncheckedUpdateManyWithoutPostNestedInput
    likes?: FbLikeUncheckedUpdateManyWithoutPostNestedInput
    wallId?: IntFieldUpdateOperationsInput | number
  }

  export type FbHashtagUpsertWithoutPostOnHashtagsInput = {
    update: XOR<FbHashtagUpdateWithoutPostOnHashtagsInput, FbHashtagUncheckedUpdateWithoutPostOnHashtagsInput>
    create: XOR<FbHashtagCreateWithoutPostOnHashtagsInput, FbHashtagUncheckedCreateWithoutPostOnHashtagsInput>
  }

  export type FbHashtagUpdateWithoutPostOnHashtagsInput = {
    hashtag?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbHashtagUncheckedUpdateWithoutPostOnHashtagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    hashtag?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbUserCreateWithoutLikesInput = {
    name: string
    image: string
    location: string
    posts?: FbPostCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
    acceptFbFriends?: FbfriendCreateNestedManyWithoutAcceptFriendInput
    requestFbFriends?: FbfriendCreateNestedManyWithoutRequestFriendInput
    fromMessengers?: FbMessengerCreateNestedManyWithoutFromInput
    toMessengers?: FbMessengerCreateNestedManyWithoutToInput
    shares?: FbShareCreateNestedManyWithoutUserInput
    comments?: FbCommentCreateNestedManyWithoutUserInput
    groupToUsers?: GroupToUserCreateNestedManyWithoutUserInput
  }

  export type FbUserUncheckedCreateWithoutLikesInput = {
    id?: number
    name: string
    image: string
    location: string
    posts?: FbPostUncheckedCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
    acceptFbFriends?: FbfriendUncheckedCreateNestedManyWithoutAcceptFriendInput
    requestFbFriends?: FbfriendUncheckedCreateNestedManyWithoutRequestFriendInput
    fromMessengers?: FbMessengerUncheckedCreateNestedManyWithoutFromInput
    toMessengers?: FbMessengerUncheckedCreateNestedManyWithoutToInput
    shares?: FbShareUncheckedCreateNestedManyWithoutUserInput
    comments?: FbCommentUncheckedCreateNestedManyWithoutUserInput
    groupToUsers?: GroupToUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type FbUserCreateOrConnectWithoutLikesInput = {
    where: FbUserWhereUniqueInput
    create: XOR<FbUserCreateWithoutLikesInput, FbUserUncheckedCreateWithoutLikesInput>
  }

  export type FbPostCreateWithoutLikesInput = {
    caption: string
    user: FbUserCreateNestedOneWithoutPostsInput
    createdAt?: Date | string
    updatedAt?: Date | string
    postImages?: FbPostImageCreateNestedManyWithoutPostInput
    postVideoes?: FbPostVideoCreateNestedManyWithoutPostInput
    postOnHashtags?: FbPostOnHashtagCreateNestedManyWithoutPostInput
    shares?: FbShareCreateNestedManyWithoutPostInput
    wall: FbWallCreateNestedOneWithoutPostsInput
  }

  export type FbPostUncheckedCreateWithoutLikesInput = {
    id?: number
    caption: string
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    postImages?: FbPostImageUncheckedCreateNestedManyWithoutPostInput
    postVideoes?: FbPostVideoUncheckedCreateNestedManyWithoutPostInput
    postOnHashtags?: FbPostOnHashtagUncheckedCreateNestedManyWithoutPostInput
    shares?: FbShareUncheckedCreateNestedManyWithoutPostInput
    wallId: number
  }

  export type FbPostCreateOrConnectWithoutLikesInput = {
    where: FbPostWhereUniqueInput
    create: XOR<FbPostCreateWithoutLikesInput, FbPostUncheckedCreateWithoutLikesInput>
  }

  export type FbCommentCreateWithoutLikesInput = {
    text: string
    user: FbUserCreateNestedOneWithoutCommentsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbCommentUncheckedCreateWithoutLikesInput = {
    id?: number
    text: string
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbCommentCreateOrConnectWithoutLikesInput = {
    where: FbCommentWhereUniqueInput
    create: XOR<FbCommentCreateWithoutLikesInput, FbCommentUncheckedCreateWithoutLikesInput>
  }

  export type FbShareCreateWithoutLikesInput = {
    user: FbUserCreateNestedOneWithoutSharesInput
    post: FbPostCreateNestedOneWithoutSharesInput
    createdAt?: Date | string
    updatedAt?: Date | string
    destinationUsers?: FbDestinationUserCreateNestedManyWithoutShareInput
  }

  export type FbShareUncheckedCreateWithoutLikesInput = {
    id?: number
    userId: number
    postId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    destinationUsers?: FbDestinationUserUncheckedCreateNestedManyWithoutShareInput
  }

  export type FbShareCreateOrConnectWithoutLikesInput = {
    where: FbShareWhereUniqueInput
    create: XOR<FbShareCreateWithoutLikesInput, FbShareUncheckedCreateWithoutLikesInput>
  }

  export type FbUserUpsertWithoutLikesInput = {
    update: XOR<FbUserUpdateWithoutLikesInput, FbUserUncheckedUpdateWithoutLikesInput>
    create: XOR<FbUserCreateWithoutLikesInput, FbUserUncheckedCreateWithoutLikesInput>
  }

  export type FbUserUpdateWithoutLikesInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    posts?: FbPostUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptFbFriends?: FbfriendUpdateManyWithoutAcceptFriendNestedInput
    requestFbFriends?: FbfriendUpdateManyWithoutRequestFriendNestedInput
    fromMessengers?: FbMessengerUpdateManyWithoutFromNestedInput
    toMessengers?: FbMessengerUpdateManyWithoutToNestedInput
    shares?: FbShareUpdateManyWithoutUserNestedInput
    comments?: FbCommentUpdateManyWithoutUserNestedInput
    groupToUsers?: GroupToUserUpdateManyWithoutUserNestedInput
  }

  export type FbUserUncheckedUpdateWithoutLikesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    posts?: FbPostUncheckedUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptFbFriends?: FbfriendUncheckedUpdateManyWithoutAcceptFriendNestedInput
    requestFbFriends?: FbfriendUncheckedUpdateManyWithoutRequestFriendNestedInput
    fromMessengers?: FbMessengerUncheckedUpdateManyWithoutFromNestedInput
    toMessengers?: FbMessengerUncheckedUpdateManyWithoutToNestedInput
    shares?: FbShareUncheckedUpdateManyWithoutUserNestedInput
    comments?: FbCommentUncheckedUpdateManyWithoutUserNestedInput
    groupToUsers?: GroupToUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FbPostUpsertWithoutLikesInput = {
    update: XOR<FbPostUpdateWithoutLikesInput, FbPostUncheckedUpdateWithoutLikesInput>
    create: XOR<FbPostCreateWithoutLikesInput, FbPostUncheckedCreateWithoutLikesInput>
  }

  export type FbPostUpdateWithoutLikesInput = {
    caption?: StringFieldUpdateOperationsInput | string
    user?: FbUserUpdateOneRequiredWithoutPostsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postImages?: FbPostImageUpdateManyWithoutPostNestedInput
    postVideoes?: FbPostVideoUpdateManyWithoutPostNestedInput
    postOnHashtags?: FbPostOnHashtagUpdateManyWithoutPostNestedInput
    shares?: FbShareUpdateManyWithoutPostNestedInput
    wall?: FbWallUpdateOneRequiredWithoutPostsNestedInput
  }

  export type FbPostUncheckedUpdateWithoutLikesInput = {
    id?: IntFieldUpdateOperationsInput | number
    caption?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postImages?: FbPostImageUncheckedUpdateManyWithoutPostNestedInput
    postVideoes?: FbPostVideoUncheckedUpdateManyWithoutPostNestedInput
    postOnHashtags?: FbPostOnHashtagUncheckedUpdateManyWithoutPostNestedInput
    shares?: FbShareUncheckedUpdateManyWithoutPostNestedInput
    wallId?: IntFieldUpdateOperationsInput | number
  }

  export type FbCommentUpsertWithoutLikesInput = {
    update: XOR<FbCommentUpdateWithoutLikesInput, FbCommentUncheckedUpdateWithoutLikesInput>
    create: XOR<FbCommentCreateWithoutLikesInput, FbCommentUncheckedCreateWithoutLikesInput>
  }

  export type FbCommentUpdateWithoutLikesInput = {
    text?: StringFieldUpdateOperationsInput | string
    user?: FbUserUpdateOneRequiredWithoutCommentsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbCommentUncheckedUpdateWithoutLikesInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbShareUpsertWithoutLikesInput = {
    update: XOR<FbShareUpdateWithoutLikesInput, FbShareUncheckedUpdateWithoutLikesInput>
    create: XOR<FbShareCreateWithoutLikesInput, FbShareUncheckedCreateWithoutLikesInput>
  }

  export type FbShareUpdateWithoutLikesInput = {
    user?: FbUserUpdateOneRequiredWithoutSharesNestedInput
    post?: FbPostUpdateOneRequiredWithoutSharesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    destinationUsers?: FbDestinationUserUpdateManyWithoutShareNestedInput
  }

  export type FbShareUncheckedUpdateWithoutLikesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    destinationUsers?: FbDestinationUserUncheckedUpdateManyWithoutShareNestedInput
  }

  export type FbUserCreateWithoutSharesInput = {
    name: string
    image: string
    location: string
    posts?: FbPostCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
    acceptFbFriends?: FbfriendCreateNestedManyWithoutAcceptFriendInput
    requestFbFriends?: FbfriendCreateNestedManyWithoutRequestFriendInput
    likes?: FbLikeCreateNestedManyWithoutUserInput
    fromMessengers?: FbMessengerCreateNestedManyWithoutFromInput
    toMessengers?: FbMessengerCreateNestedManyWithoutToInput
    comments?: FbCommentCreateNestedManyWithoutUserInput
    groupToUsers?: GroupToUserCreateNestedManyWithoutUserInput
  }

  export type FbUserUncheckedCreateWithoutSharesInput = {
    id?: number
    name: string
    image: string
    location: string
    posts?: FbPostUncheckedCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
    acceptFbFriends?: FbfriendUncheckedCreateNestedManyWithoutAcceptFriendInput
    requestFbFriends?: FbfriendUncheckedCreateNestedManyWithoutRequestFriendInput
    likes?: FbLikeUncheckedCreateNestedManyWithoutUserInput
    fromMessengers?: FbMessengerUncheckedCreateNestedManyWithoutFromInput
    toMessengers?: FbMessengerUncheckedCreateNestedManyWithoutToInput
    comments?: FbCommentUncheckedCreateNestedManyWithoutUserInput
    groupToUsers?: GroupToUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type FbUserCreateOrConnectWithoutSharesInput = {
    where: FbUserWhereUniqueInput
    create: XOR<FbUserCreateWithoutSharesInput, FbUserUncheckedCreateWithoutSharesInput>
  }

  export type FbPostCreateWithoutSharesInput = {
    caption: string
    user: FbUserCreateNestedOneWithoutPostsInput
    createdAt?: Date | string
    updatedAt?: Date | string
    postImages?: FbPostImageCreateNestedManyWithoutPostInput
    postVideoes?: FbPostVideoCreateNestedManyWithoutPostInput
    postOnHashtags?: FbPostOnHashtagCreateNestedManyWithoutPostInput
    likes?: FbLikeCreateNestedManyWithoutPostInput
    wall: FbWallCreateNestedOneWithoutPostsInput
  }

  export type FbPostUncheckedCreateWithoutSharesInput = {
    id?: number
    caption: string
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    postImages?: FbPostImageUncheckedCreateNestedManyWithoutPostInput
    postVideoes?: FbPostVideoUncheckedCreateNestedManyWithoutPostInput
    postOnHashtags?: FbPostOnHashtagUncheckedCreateNestedManyWithoutPostInput
    likes?: FbLikeUncheckedCreateNestedManyWithoutPostInput
    wallId: number
  }

  export type FbPostCreateOrConnectWithoutSharesInput = {
    where: FbPostWhereUniqueInput
    create: XOR<FbPostCreateWithoutSharesInput, FbPostUncheckedCreateWithoutSharesInput>
  }

  export type FbLikeCreateWithoutShareInput = {
    user: FbUserCreateNestedOneWithoutLikesInput
    post: FbPostCreateNestedOneWithoutLikesInput
    comment: FbCommentCreateNestedOneWithoutLikesInput
    likeType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbLikeUncheckedCreateWithoutShareInput = {
    id?: number
    userId: number
    postId: number
    commentId: number
    likeType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbLikeCreateOrConnectWithoutShareInput = {
    where: FbLikeWhereUniqueInput
    create: XOR<FbLikeCreateWithoutShareInput, FbLikeUncheckedCreateWithoutShareInput>
  }

  export type FbLikeCreateManyShareInputEnvelope = {
    data: Enumerable<FbLikeCreateManyShareInput>
    skipDuplicates?: boolean
  }

  export type FbDestinationUserCreateWithoutShareInput = {
    wall: FbWallCreateNestedOneWithoutDestinationUsersInput
    group: FbGroupCreateNestedOneWithoutDestinationUsersInput
  }

  export type FbDestinationUserUncheckedCreateWithoutShareInput = {
    id?: number
    fbWallId: number
    groupId: number
  }

  export type FbDestinationUserCreateOrConnectWithoutShareInput = {
    where: FbDestinationUserWhereUniqueInput
    create: XOR<FbDestinationUserCreateWithoutShareInput, FbDestinationUserUncheckedCreateWithoutShareInput>
  }

  export type FbDestinationUserCreateManyShareInputEnvelope = {
    data: Enumerable<FbDestinationUserCreateManyShareInput>
    skipDuplicates?: boolean
  }

  export type FbUserUpsertWithoutSharesInput = {
    update: XOR<FbUserUpdateWithoutSharesInput, FbUserUncheckedUpdateWithoutSharesInput>
    create: XOR<FbUserCreateWithoutSharesInput, FbUserUncheckedCreateWithoutSharesInput>
  }

  export type FbUserUpdateWithoutSharesInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    posts?: FbPostUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptFbFriends?: FbfriendUpdateManyWithoutAcceptFriendNestedInput
    requestFbFriends?: FbfriendUpdateManyWithoutRequestFriendNestedInput
    likes?: FbLikeUpdateManyWithoutUserNestedInput
    fromMessengers?: FbMessengerUpdateManyWithoutFromNestedInput
    toMessengers?: FbMessengerUpdateManyWithoutToNestedInput
    comments?: FbCommentUpdateManyWithoutUserNestedInput
    groupToUsers?: GroupToUserUpdateManyWithoutUserNestedInput
  }

  export type FbUserUncheckedUpdateWithoutSharesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    posts?: FbPostUncheckedUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptFbFriends?: FbfriendUncheckedUpdateManyWithoutAcceptFriendNestedInput
    requestFbFriends?: FbfriendUncheckedUpdateManyWithoutRequestFriendNestedInput
    likes?: FbLikeUncheckedUpdateManyWithoutUserNestedInput
    fromMessengers?: FbMessengerUncheckedUpdateManyWithoutFromNestedInput
    toMessengers?: FbMessengerUncheckedUpdateManyWithoutToNestedInput
    comments?: FbCommentUncheckedUpdateManyWithoutUserNestedInput
    groupToUsers?: GroupToUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FbPostUpsertWithoutSharesInput = {
    update: XOR<FbPostUpdateWithoutSharesInput, FbPostUncheckedUpdateWithoutSharesInput>
    create: XOR<FbPostCreateWithoutSharesInput, FbPostUncheckedCreateWithoutSharesInput>
  }

  export type FbPostUpdateWithoutSharesInput = {
    caption?: StringFieldUpdateOperationsInput | string
    user?: FbUserUpdateOneRequiredWithoutPostsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postImages?: FbPostImageUpdateManyWithoutPostNestedInput
    postVideoes?: FbPostVideoUpdateManyWithoutPostNestedInput
    postOnHashtags?: FbPostOnHashtagUpdateManyWithoutPostNestedInput
    likes?: FbLikeUpdateManyWithoutPostNestedInput
    wall?: FbWallUpdateOneRequiredWithoutPostsNestedInput
  }

  export type FbPostUncheckedUpdateWithoutSharesInput = {
    id?: IntFieldUpdateOperationsInput | number
    caption?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postImages?: FbPostImageUncheckedUpdateManyWithoutPostNestedInput
    postVideoes?: FbPostVideoUncheckedUpdateManyWithoutPostNestedInput
    postOnHashtags?: FbPostOnHashtagUncheckedUpdateManyWithoutPostNestedInput
    likes?: FbLikeUncheckedUpdateManyWithoutPostNestedInput
    wallId?: IntFieldUpdateOperationsInput | number
  }

  export type FbLikeUpsertWithWhereUniqueWithoutShareInput = {
    where: FbLikeWhereUniqueInput
    update: XOR<FbLikeUpdateWithoutShareInput, FbLikeUncheckedUpdateWithoutShareInput>
    create: XOR<FbLikeCreateWithoutShareInput, FbLikeUncheckedCreateWithoutShareInput>
  }

  export type FbLikeUpdateWithWhereUniqueWithoutShareInput = {
    where: FbLikeWhereUniqueInput
    data: XOR<FbLikeUpdateWithoutShareInput, FbLikeUncheckedUpdateWithoutShareInput>
  }

  export type FbLikeUpdateManyWithWhereWithoutShareInput = {
    where: FbLikeScalarWhereInput
    data: XOR<FbLikeUpdateManyMutationInput, FbLikeUncheckedUpdateManyWithoutLikesInput>
  }

  export type FbDestinationUserUpsertWithWhereUniqueWithoutShareInput = {
    where: FbDestinationUserWhereUniqueInput
    update: XOR<FbDestinationUserUpdateWithoutShareInput, FbDestinationUserUncheckedUpdateWithoutShareInput>
    create: XOR<FbDestinationUserCreateWithoutShareInput, FbDestinationUserUncheckedCreateWithoutShareInput>
  }

  export type FbDestinationUserUpdateWithWhereUniqueWithoutShareInput = {
    where: FbDestinationUserWhereUniqueInput
    data: XOR<FbDestinationUserUpdateWithoutShareInput, FbDestinationUserUncheckedUpdateWithoutShareInput>
  }

  export type FbDestinationUserUpdateManyWithWhereWithoutShareInput = {
    where: FbDestinationUserScalarWhereInput
    data: XOR<FbDestinationUserUpdateManyMutationInput, FbDestinationUserUncheckedUpdateManyWithoutDestinationUsersInput>
  }

  export type FbDestinationUserScalarWhereInput = {
    AND?: Enumerable<FbDestinationUserScalarWhereInput>
    OR?: Enumerable<FbDestinationUserScalarWhereInput>
    NOT?: Enumerable<FbDestinationUserScalarWhereInput>
    id?: IntFilter | number
    fbWallId?: IntFilter | number
    shareId?: IntFilter | number
    groupId?: IntFilter | number
  }

  export type FbUserCreateWithoutAcceptFbFriendsInput = {
    name: string
    image: string
    location: string
    posts?: FbPostCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
    requestFbFriends?: FbfriendCreateNestedManyWithoutRequestFriendInput
    likes?: FbLikeCreateNestedManyWithoutUserInput
    fromMessengers?: FbMessengerCreateNestedManyWithoutFromInput
    toMessengers?: FbMessengerCreateNestedManyWithoutToInput
    shares?: FbShareCreateNestedManyWithoutUserInput
    comments?: FbCommentCreateNestedManyWithoutUserInput
    groupToUsers?: GroupToUserCreateNestedManyWithoutUserInput
  }

  export type FbUserUncheckedCreateWithoutAcceptFbFriendsInput = {
    id?: number
    name: string
    image: string
    location: string
    posts?: FbPostUncheckedCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
    requestFbFriends?: FbfriendUncheckedCreateNestedManyWithoutRequestFriendInput
    likes?: FbLikeUncheckedCreateNestedManyWithoutUserInput
    fromMessengers?: FbMessengerUncheckedCreateNestedManyWithoutFromInput
    toMessengers?: FbMessengerUncheckedCreateNestedManyWithoutToInput
    shares?: FbShareUncheckedCreateNestedManyWithoutUserInput
    comments?: FbCommentUncheckedCreateNestedManyWithoutUserInput
    groupToUsers?: GroupToUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type FbUserCreateOrConnectWithoutAcceptFbFriendsInput = {
    where: FbUserWhereUniqueInput
    create: XOR<FbUserCreateWithoutAcceptFbFriendsInput, FbUserUncheckedCreateWithoutAcceptFbFriendsInput>
  }

  export type FbUserCreateWithoutRequestFbFriendsInput = {
    name: string
    image: string
    location: string
    posts?: FbPostCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
    acceptFbFriends?: FbfriendCreateNestedManyWithoutAcceptFriendInput
    likes?: FbLikeCreateNestedManyWithoutUserInput
    fromMessengers?: FbMessengerCreateNestedManyWithoutFromInput
    toMessengers?: FbMessengerCreateNestedManyWithoutToInput
    shares?: FbShareCreateNestedManyWithoutUserInput
    comments?: FbCommentCreateNestedManyWithoutUserInput
    groupToUsers?: GroupToUserCreateNestedManyWithoutUserInput
  }

  export type FbUserUncheckedCreateWithoutRequestFbFriendsInput = {
    id?: number
    name: string
    image: string
    location: string
    posts?: FbPostUncheckedCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
    acceptFbFriends?: FbfriendUncheckedCreateNestedManyWithoutAcceptFriendInput
    likes?: FbLikeUncheckedCreateNestedManyWithoutUserInput
    fromMessengers?: FbMessengerUncheckedCreateNestedManyWithoutFromInput
    toMessengers?: FbMessengerUncheckedCreateNestedManyWithoutToInput
    shares?: FbShareUncheckedCreateNestedManyWithoutUserInput
    comments?: FbCommentUncheckedCreateNestedManyWithoutUserInput
    groupToUsers?: GroupToUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type FbUserCreateOrConnectWithoutRequestFbFriendsInput = {
    where: FbUserWhereUniqueInput
    create: XOR<FbUserCreateWithoutRequestFbFriendsInput, FbUserUncheckedCreateWithoutRequestFbFriendsInput>
  }

  export type FbUserUpsertWithoutAcceptFbFriendsInput = {
    update: XOR<FbUserUpdateWithoutAcceptFbFriendsInput, FbUserUncheckedUpdateWithoutAcceptFbFriendsInput>
    create: XOR<FbUserCreateWithoutAcceptFbFriendsInput, FbUserUncheckedCreateWithoutAcceptFbFriendsInput>
  }

  export type FbUserUpdateWithoutAcceptFbFriendsInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    posts?: FbPostUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestFbFriends?: FbfriendUpdateManyWithoutRequestFriendNestedInput
    likes?: FbLikeUpdateManyWithoutUserNestedInput
    fromMessengers?: FbMessengerUpdateManyWithoutFromNestedInput
    toMessengers?: FbMessengerUpdateManyWithoutToNestedInput
    shares?: FbShareUpdateManyWithoutUserNestedInput
    comments?: FbCommentUpdateManyWithoutUserNestedInput
    groupToUsers?: GroupToUserUpdateManyWithoutUserNestedInput
  }

  export type FbUserUncheckedUpdateWithoutAcceptFbFriendsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    posts?: FbPostUncheckedUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestFbFriends?: FbfriendUncheckedUpdateManyWithoutRequestFriendNestedInput
    likes?: FbLikeUncheckedUpdateManyWithoutUserNestedInput
    fromMessengers?: FbMessengerUncheckedUpdateManyWithoutFromNestedInput
    toMessengers?: FbMessengerUncheckedUpdateManyWithoutToNestedInput
    shares?: FbShareUncheckedUpdateManyWithoutUserNestedInput
    comments?: FbCommentUncheckedUpdateManyWithoutUserNestedInput
    groupToUsers?: GroupToUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FbUserUpsertWithoutRequestFbFriendsInput = {
    update: XOR<FbUserUpdateWithoutRequestFbFriendsInput, FbUserUncheckedUpdateWithoutRequestFbFriendsInput>
    create: XOR<FbUserCreateWithoutRequestFbFriendsInput, FbUserUncheckedCreateWithoutRequestFbFriendsInput>
  }

  export type FbUserUpdateWithoutRequestFbFriendsInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    posts?: FbPostUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptFbFriends?: FbfriendUpdateManyWithoutAcceptFriendNestedInput
    likes?: FbLikeUpdateManyWithoutUserNestedInput
    fromMessengers?: FbMessengerUpdateManyWithoutFromNestedInput
    toMessengers?: FbMessengerUpdateManyWithoutToNestedInput
    shares?: FbShareUpdateManyWithoutUserNestedInput
    comments?: FbCommentUpdateManyWithoutUserNestedInput
    groupToUsers?: GroupToUserUpdateManyWithoutUserNestedInput
  }

  export type FbUserUncheckedUpdateWithoutRequestFbFriendsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    posts?: FbPostUncheckedUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptFbFriends?: FbfriendUncheckedUpdateManyWithoutAcceptFriendNestedInput
    likes?: FbLikeUncheckedUpdateManyWithoutUserNestedInput
    fromMessengers?: FbMessengerUncheckedUpdateManyWithoutFromNestedInput
    toMessengers?: FbMessengerUncheckedUpdateManyWithoutToNestedInput
    shares?: FbShareUncheckedUpdateManyWithoutUserNestedInput
    comments?: FbCommentUncheckedUpdateManyWithoutUserNestedInput
    groupToUsers?: GroupToUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FbUserCreateWithoutFromMessengersInput = {
    name: string
    image: string
    location: string
    posts?: FbPostCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
    acceptFbFriends?: FbfriendCreateNestedManyWithoutAcceptFriendInput
    requestFbFriends?: FbfriendCreateNestedManyWithoutRequestFriendInput
    likes?: FbLikeCreateNestedManyWithoutUserInput
    toMessengers?: FbMessengerCreateNestedManyWithoutToInput
    shares?: FbShareCreateNestedManyWithoutUserInput
    comments?: FbCommentCreateNestedManyWithoutUserInput
    groupToUsers?: GroupToUserCreateNestedManyWithoutUserInput
  }

  export type FbUserUncheckedCreateWithoutFromMessengersInput = {
    id?: number
    name: string
    image: string
    location: string
    posts?: FbPostUncheckedCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
    acceptFbFriends?: FbfriendUncheckedCreateNestedManyWithoutAcceptFriendInput
    requestFbFriends?: FbfriendUncheckedCreateNestedManyWithoutRequestFriendInput
    likes?: FbLikeUncheckedCreateNestedManyWithoutUserInput
    toMessengers?: FbMessengerUncheckedCreateNestedManyWithoutToInput
    shares?: FbShareUncheckedCreateNestedManyWithoutUserInput
    comments?: FbCommentUncheckedCreateNestedManyWithoutUserInput
    groupToUsers?: GroupToUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type FbUserCreateOrConnectWithoutFromMessengersInput = {
    where: FbUserWhereUniqueInput
    create: XOR<FbUserCreateWithoutFromMessengersInput, FbUserUncheckedCreateWithoutFromMessengersInput>
  }

  export type FbUserCreateWithoutToMessengersInput = {
    name: string
    image: string
    location: string
    posts?: FbPostCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
    acceptFbFriends?: FbfriendCreateNestedManyWithoutAcceptFriendInput
    requestFbFriends?: FbfriendCreateNestedManyWithoutRequestFriendInput
    likes?: FbLikeCreateNestedManyWithoutUserInput
    fromMessengers?: FbMessengerCreateNestedManyWithoutFromInput
    shares?: FbShareCreateNestedManyWithoutUserInput
    comments?: FbCommentCreateNestedManyWithoutUserInput
    groupToUsers?: GroupToUserCreateNestedManyWithoutUserInput
  }

  export type FbUserUncheckedCreateWithoutToMessengersInput = {
    id?: number
    name: string
    image: string
    location: string
    posts?: FbPostUncheckedCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
    acceptFbFriends?: FbfriendUncheckedCreateNestedManyWithoutAcceptFriendInput
    requestFbFriends?: FbfriendUncheckedCreateNestedManyWithoutRequestFriendInput
    likes?: FbLikeUncheckedCreateNestedManyWithoutUserInput
    fromMessengers?: FbMessengerUncheckedCreateNestedManyWithoutFromInput
    shares?: FbShareUncheckedCreateNestedManyWithoutUserInput
    comments?: FbCommentUncheckedCreateNestedManyWithoutUserInput
    groupToUsers?: GroupToUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type FbUserCreateOrConnectWithoutToMessengersInput = {
    where: FbUserWhereUniqueInput
    create: XOR<FbUserCreateWithoutToMessengersInput, FbUserUncheckedCreateWithoutToMessengersInput>
  }

  export type FbUserUpsertWithoutFromMessengersInput = {
    update: XOR<FbUserUpdateWithoutFromMessengersInput, FbUserUncheckedUpdateWithoutFromMessengersInput>
    create: XOR<FbUserCreateWithoutFromMessengersInput, FbUserUncheckedCreateWithoutFromMessengersInput>
  }

  export type FbUserUpdateWithoutFromMessengersInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    posts?: FbPostUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptFbFriends?: FbfriendUpdateManyWithoutAcceptFriendNestedInput
    requestFbFriends?: FbfriendUpdateManyWithoutRequestFriendNestedInput
    likes?: FbLikeUpdateManyWithoutUserNestedInput
    toMessengers?: FbMessengerUpdateManyWithoutToNestedInput
    shares?: FbShareUpdateManyWithoutUserNestedInput
    comments?: FbCommentUpdateManyWithoutUserNestedInput
    groupToUsers?: GroupToUserUpdateManyWithoutUserNestedInput
  }

  export type FbUserUncheckedUpdateWithoutFromMessengersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    posts?: FbPostUncheckedUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptFbFriends?: FbfriendUncheckedUpdateManyWithoutAcceptFriendNestedInput
    requestFbFriends?: FbfriendUncheckedUpdateManyWithoutRequestFriendNestedInput
    likes?: FbLikeUncheckedUpdateManyWithoutUserNestedInput
    toMessengers?: FbMessengerUncheckedUpdateManyWithoutToNestedInput
    shares?: FbShareUncheckedUpdateManyWithoutUserNestedInput
    comments?: FbCommentUncheckedUpdateManyWithoutUserNestedInput
    groupToUsers?: GroupToUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FbUserUpsertWithoutToMessengersInput = {
    update: XOR<FbUserUpdateWithoutToMessengersInput, FbUserUncheckedUpdateWithoutToMessengersInput>
    create: XOR<FbUserCreateWithoutToMessengersInput, FbUserUncheckedCreateWithoutToMessengersInput>
  }

  export type FbUserUpdateWithoutToMessengersInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    posts?: FbPostUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptFbFriends?: FbfriendUpdateManyWithoutAcceptFriendNestedInput
    requestFbFriends?: FbfriendUpdateManyWithoutRequestFriendNestedInput
    likes?: FbLikeUpdateManyWithoutUserNestedInput
    fromMessengers?: FbMessengerUpdateManyWithoutFromNestedInput
    shares?: FbShareUpdateManyWithoutUserNestedInput
    comments?: FbCommentUpdateManyWithoutUserNestedInput
    groupToUsers?: GroupToUserUpdateManyWithoutUserNestedInput
  }

  export type FbUserUncheckedUpdateWithoutToMessengersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    posts?: FbPostUncheckedUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptFbFriends?: FbfriendUncheckedUpdateManyWithoutAcceptFriendNestedInput
    requestFbFriends?: FbfriendUncheckedUpdateManyWithoutRequestFriendNestedInput
    likes?: FbLikeUncheckedUpdateManyWithoutUserNestedInput
    fromMessengers?: FbMessengerUncheckedUpdateManyWithoutFromNestedInput
    shares?: FbShareUncheckedUpdateManyWithoutUserNestedInput
    comments?: FbCommentUncheckedUpdateManyWithoutUserNestedInput
    groupToUsers?: GroupToUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FbUserCreateWithoutCommentsInput = {
    name: string
    image: string
    location: string
    posts?: FbPostCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
    acceptFbFriends?: FbfriendCreateNestedManyWithoutAcceptFriendInput
    requestFbFriends?: FbfriendCreateNestedManyWithoutRequestFriendInput
    likes?: FbLikeCreateNestedManyWithoutUserInput
    fromMessengers?: FbMessengerCreateNestedManyWithoutFromInput
    toMessengers?: FbMessengerCreateNestedManyWithoutToInput
    shares?: FbShareCreateNestedManyWithoutUserInput
    groupToUsers?: GroupToUserCreateNestedManyWithoutUserInput
  }

  export type FbUserUncheckedCreateWithoutCommentsInput = {
    id?: number
    name: string
    image: string
    location: string
    posts?: FbPostUncheckedCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
    acceptFbFriends?: FbfriendUncheckedCreateNestedManyWithoutAcceptFriendInput
    requestFbFriends?: FbfriendUncheckedCreateNestedManyWithoutRequestFriendInput
    likes?: FbLikeUncheckedCreateNestedManyWithoutUserInput
    fromMessengers?: FbMessengerUncheckedCreateNestedManyWithoutFromInput
    toMessengers?: FbMessengerUncheckedCreateNestedManyWithoutToInput
    shares?: FbShareUncheckedCreateNestedManyWithoutUserInput
    groupToUsers?: GroupToUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type FbUserCreateOrConnectWithoutCommentsInput = {
    where: FbUserWhereUniqueInput
    create: XOR<FbUserCreateWithoutCommentsInput, FbUserUncheckedCreateWithoutCommentsInput>
  }

  export type FbLikeCreateWithoutCommentInput = {
    user: FbUserCreateNestedOneWithoutLikesInput
    post: FbPostCreateNestedOneWithoutLikesInput
    share: FbShareCreateNestedOneWithoutLikesInput
    likeType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbLikeUncheckedCreateWithoutCommentInput = {
    id?: number
    userId: number
    postId: number
    shareId: number
    likeType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbLikeCreateOrConnectWithoutCommentInput = {
    where: FbLikeWhereUniqueInput
    create: XOR<FbLikeCreateWithoutCommentInput, FbLikeUncheckedCreateWithoutCommentInput>
  }

  export type FbLikeCreateManyCommentInputEnvelope = {
    data: Enumerable<FbLikeCreateManyCommentInput>
    skipDuplicates?: boolean
  }

  export type FbUserUpsertWithoutCommentsInput = {
    update: XOR<FbUserUpdateWithoutCommentsInput, FbUserUncheckedUpdateWithoutCommentsInput>
    create: XOR<FbUserCreateWithoutCommentsInput, FbUserUncheckedCreateWithoutCommentsInput>
  }

  export type FbUserUpdateWithoutCommentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    posts?: FbPostUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptFbFriends?: FbfriendUpdateManyWithoutAcceptFriendNestedInput
    requestFbFriends?: FbfriendUpdateManyWithoutRequestFriendNestedInput
    likes?: FbLikeUpdateManyWithoutUserNestedInput
    fromMessengers?: FbMessengerUpdateManyWithoutFromNestedInput
    toMessengers?: FbMessengerUpdateManyWithoutToNestedInput
    shares?: FbShareUpdateManyWithoutUserNestedInput
    groupToUsers?: GroupToUserUpdateManyWithoutUserNestedInput
  }

  export type FbUserUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    posts?: FbPostUncheckedUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptFbFriends?: FbfriendUncheckedUpdateManyWithoutAcceptFriendNestedInput
    requestFbFriends?: FbfriendUncheckedUpdateManyWithoutRequestFriendNestedInput
    likes?: FbLikeUncheckedUpdateManyWithoutUserNestedInput
    fromMessengers?: FbMessengerUncheckedUpdateManyWithoutFromNestedInput
    toMessengers?: FbMessengerUncheckedUpdateManyWithoutToNestedInput
    shares?: FbShareUncheckedUpdateManyWithoutUserNestedInput
    groupToUsers?: GroupToUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FbLikeUpsertWithWhereUniqueWithoutCommentInput = {
    where: FbLikeWhereUniqueInput
    update: XOR<FbLikeUpdateWithoutCommentInput, FbLikeUncheckedUpdateWithoutCommentInput>
    create: XOR<FbLikeCreateWithoutCommentInput, FbLikeUncheckedCreateWithoutCommentInput>
  }

  export type FbLikeUpdateWithWhereUniqueWithoutCommentInput = {
    where: FbLikeWhereUniqueInput
    data: XOR<FbLikeUpdateWithoutCommentInput, FbLikeUncheckedUpdateWithoutCommentInput>
  }

  export type FbLikeUpdateManyWithWhereWithoutCommentInput = {
    where: FbLikeScalarWhereInput
    data: XOR<FbLikeUpdateManyMutationInput, FbLikeUncheckedUpdateManyWithoutLikesInput>
  }

  export type GroupToUserCreateWithoutGroupInput = {
    user: FbUserCreateNestedOneWithoutGroupToUsersInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupToUserUncheckedCreateWithoutGroupInput = {
    id?: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupToUserCreateOrConnectWithoutGroupInput = {
    where: GroupToUserWhereUniqueInput
    create: XOR<GroupToUserCreateWithoutGroupInput, GroupToUserUncheckedCreateWithoutGroupInput>
  }

  export type GroupToUserCreateManyGroupInputEnvelope = {
    data: Enumerable<GroupToUserCreateManyGroupInput>
    skipDuplicates?: boolean
  }

  export type FbDestinationUserCreateWithoutGroupInput = {
    wall: FbWallCreateNestedOneWithoutDestinationUsersInput
    share: FbShareCreateNestedOneWithoutDestinationUsersInput
  }

  export type FbDestinationUserUncheckedCreateWithoutGroupInput = {
    id?: number
    fbWallId: number
    shareId: number
  }

  export type FbDestinationUserCreateOrConnectWithoutGroupInput = {
    where: FbDestinationUserWhereUniqueInput
    create: XOR<FbDestinationUserCreateWithoutGroupInput, FbDestinationUserUncheckedCreateWithoutGroupInput>
  }

  export type FbDestinationUserCreateManyGroupInputEnvelope = {
    data: Enumerable<FbDestinationUserCreateManyGroupInput>
    skipDuplicates?: boolean
  }

  export type GroupToUserUpsertWithWhereUniqueWithoutGroupInput = {
    where: GroupToUserWhereUniqueInput
    update: XOR<GroupToUserUpdateWithoutGroupInput, GroupToUserUncheckedUpdateWithoutGroupInput>
    create: XOR<GroupToUserCreateWithoutGroupInput, GroupToUserUncheckedCreateWithoutGroupInput>
  }

  export type GroupToUserUpdateWithWhereUniqueWithoutGroupInput = {
    where: GroupToUserWhereUniqueInput
    data: XOR<GroupToUserUpdateWithoutGroupInput, GroupToUserUncheckedUpdateWithoutGroupInput>
  }

  export type GroupToUserUpdateManyWithWhereWithoutGroupInput = {
    where: GroupToUserScalarWhereInput
    data: XOR<GroupToUserUpdateManyMutationInput, GroupToUserUncheckedUpdateManyWithoutGroupToUsersInput>
  }

  export type FbDestinationUserUpsertWithWhereUniqueWithoutGroupInput = {
    where: FbDestinationUserWhereUniqueInput
    update: XOR<FbDestinationUserUpdateWithoutGroupInput, FbDestinationUserUncheckedUpdateWithoutGroupInput>
    create: XOR<FbDestinationUserCreateWithoutGroupInput, FbDestinationUserUncheckedCreateWithoutGroupInput>
  }

  export type FbDestinationUserUpdateWithWhereUniqueWithoutGroupInput = {
    where: FbDestinationUserWhereUniqueInput
    data: XOR<FbDestinationUserUpdateWithoutGroupInput, FbDestinationUserUncheckedUpdateWithoutGroupInput>
  }

  export type FbDestinationUserUpdateManyWithWhereWithoutGroupInput = {
    where: FbDestinationUserScalarWhereInput
    data: XOR<FbDestinationUserUpdateManyMutationInput, FbDestinationUserUncheckedUpdateManyWithoutDestinationUsersInput>
  }

  export type FbUserCreateWithoutGroupToUsersInput = {
    name: string
    image: string
    location: string
    posts?: FbPostCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
    acceptFbFriends?: FbfriendCreateNestedManyWithoutAcceptFriendInput
    requestFbFriends?: FbfriendCreateNestedManyWithoutRequestFriendInput
    likes?: FbLikeCreateNestedManyWithoutUserInput
    fromMessengers?: FbMessengerCreateNestedManyWithoutFromInput
    toMessengers?: FbMessengerCreateNestedManyWithoutToInput
    shares?: FbShareCreateNestedManyWithoutUserInput
    comments?: FbCommentCreateNestedManyWithoutUserInput
  }

  export type FbUserUncheckedCreateWithoutGroupToUsersInput = {
    id?: number
    name: string
    image: string
    location: string
    posts?: FbPostUncheckedCreateNestedManyWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
    acceptFbFriends?: FbfriendUncheckedCreateNestedManyWithoutAcceptFriendInput
    requestFbFriends?: FbfriendUncheckedCreateNestedManyWithoutRequestFriendInput
    likes?: FbLikeUncheckedCreateNestedManyWithoutUserInput
    fromMessengers?: FbMessengerUncheckedCreateNestedManyWithoutFromInput
    toMessengers?: FbMessengerUncheckedCreateNestedManyWithoutToInput
    shares?: FbShareUncheckedCreateNestedManyWithoutUserInput
    comments?: FbCommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type FbUserCreateOrConnectWithoutGroupToUsersInput = {
    where: FbUserWhereUniqueInput
    create: XOR<FbUserCreateWithoutGroupToUsersInput, FbUserUncheckedCreateWithoutGroupToUsersInput>
  }

  export type FbGroupCreateWithoutGroupToUsersInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    destinationUsers?: FbDestinationUserCreateNestedManyWithoutGroupInput
  }

  export type FbGroupUncheckedCreateWithoutGroupToUsersInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    destinationUsers?: FbDestinationUserUncheckedCreateNestedManyWithoutGroupInput
  }

  export type FbGroupCreateOrConnectWithoutGroupToUsersInput = {
    where: FbGroupWhereUniqueInput
    create: XOR<FbGroupCreateWithoutGroupToUsersInput, FbGroupUncheckedCreateWithoutGroupToUsersInput>
  }

  export type FbUserUpsertWithoutGroupToUsersInput = {
    update: XOR<FbUserUpdateWithoutGroupToUsersInput, FbUserUncheckedUpdateWithoutGroupToUsersInput>
    create: XOR<FbUserCreateWithoutGroupToUsersInput, FbUserUncheckedCreateWithoutGroupToUsersInput>
  }

  export type FbUserUpdateWithoutGroupToUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    posts?: FbPostUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptFbFriends?: FbfriendUpdateManyWithoutAcceptFriendNestedInput
    requestFbFriends?: FbfriendUpdateManyWithoutRequestFriendNestedInput
    likes?: FbLikeUpdateManyWithoutUserNestedInput
    fromMessengers?: FbMessengerUpdateManyWithoutFromNestedInput
    toMessengers?: FbMessengerUpdateManyWithoutToNestedInput
    shares?: FbShareUpdateManyWithoutUserNestedInput
    comments?: FbCommentUpdateManyWithoutUserNestedInput
  }

  export type FbUserUncheckedUpdateWithoutGroupToUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    posts?: FbPostUncheckedUpdateManyWithoutUserNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptFbFriends?: FbfriendUncheckedUpdateManyWithoutAcceptFriendNestedInput
    requestFbFriends?: FbfriendUncheckedUpdateManyWithoutRequestFriendNestedInput
    likes?: FbLikeUncheckedUpdateManyWithoutUserNestedInput
    fromMessengers?: FbMessengerUncheckedUpdateManyWithoutFromNestedInput
    toMessengers?: FbMessengerUncheckedUpdateManyWithoutToNestedInput
    shares?: FbShareUncheckedUpdateManyWithoutUserNestedInput
    comments?: FbCommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FbGroupUpsertWithoutGroupToUsersInput = {
    update: XOR<FbGroupUpdateWithoutGroupToUsersInput, FbGroupUncheckedUpdateWithoutGroupToUsersInput>
    create: XOR<FbGroupCreateWithoutGroupToUsersInput, FbGroupUncheckedCreateWithoutGroupToUsersInput>
  }

  export type FbGroupUpdateWithoutGroupToUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    destinationUsers?: FbDestinationUserUpdateManyWithoutGroupNestedInput
  }

  export type FbGroupUncheckedUpdateWithoutGroupToUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    destinationUsers?: FbDestinationUserUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type FbPostCreateWithoutWallInput = {
    caption: string
    user: FbUserCreateNestedOneWithoutPostsInput
    createdAt?: Date | string
    updatedAt?: Date | string
    postImages?: FbPostImageCreateNestedManyWithoutPostInput
    postVideoes?: FbPostVideoCreateNestedManyWithoutPostInput
    postOnHashtags?: FbPostOnHashtagCreateNestedManyWithoutPostInput
    shares?: FbShareCreateNestedManyWithoutPostInput
    likes?: FbLikeCreateNestedManyWithoutPostInput
  }

  export type FbPostUncheckedCreateWithoutWallInput = {
    id?: number
    caption: string
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    postImages?: FbPostImageUncheckedCreateNestedManyWithoutPostInput
    postVideoes?: FbPostVideoUncheckedCreateNestedManyWithoutPostInput
    postOnHashtags?: FbPostOnHashtagUncheckedCreateNestedManyWithoutPostInput
    shares?: FbShareUncheckedCreateNestedManyWithoutPostInput
    likes?: FbLikeUncheckedCreateNestedManyWithoutPostInput
  }

  export type FbPostCreateOrConnectWithoutWallInput = {
    where: FbPostWhereUniqueInput
    create: XOR<FbPostCreateWithoutWallInput, FbPostUncheckedCreateWithoutWallInput>
  }

  export type FbPostCreateManyWallInputEnvelope = {
    data: Enumerable<FbPostCreateManyWallInput>
    skipDuplicates?: boolean
  }

  export type FbDestinationUserCreateWithoutWallInput = {
    share: FbShareCreateNestedOneWithoutDestinationUsersInput
    group: FbGroupCreateNestedOneWithoutDestinationUsersInput
  }

  export type FbDestinationUserUncheckedCreateWithoutWallInput = {
    id?: number
    shareId: number
    groupId: number
  }

  export type FbDestinationUserCreateOrConnectWithoutWallInput = {
    where: FbDestinationUserWhereUniqueInput
    create: XOR<FbDestinationUserCreateWithoutWallInput, FbDestinationUserUncheckedCreateWithoutWallInput>
  }

  export type FbDestinationUserCreateManyWallInputEnvelope = {
    data: Enumerable<FbDestinationUserCreateManyWallInput>
    skipDuplicates?: boolean
  }

  export type FbPostUpsertWithWhereUniqueWithoutWallInput = {
    where: FbPostWhereUniqueInput
    update: XOR<FbPostUpdateWithoutWallInput, FbPostUncheckedUpdateWithoutWallInput>
    create: XOR<FbPostCreateWithoutWallInput, FbPostUncheckedCreateWithoutWallInput>
  }

  export type FbPostUpdateWithWhereUniqueWithoutWallInput = {
    where: FbPostWhereUniqueInput
    data: XOR<FbPostUpdateWithoutWallInput, FbPostUncheckedUpdateWithoutWallInput>
  }

  export type FbPostUpdateManyWithWhereWithoutWallInput = {
    where: FbPostScalarWhereInput
    data: XOR<FbPostUpdateManyMutationInput, FbPostUncheckedUpdateManyWithoutPostsInput>
  }

  export type FbDestinationUserUpsertWithWhereUniqueWithoutWallInput = {
    where: FbDestinationUserWhereUniqueInput
    update: XOR<FbDestinationUserUpdateWithoutWallInput, FbDestinationUserUncheckedUpdateWithoutWallInput>
    create: XOR<FbDestinationUserCreateWithoutWallInput, FbDestinationUserUncheckedCreateWithoutWallInput>
  }

  export type FbDestinationUserUpdateWithWhereUniqueWithoutWallInput = {
    where: FbDestinationUserWhereUniqueInput
    data: XOR<FbDestinationUserUpdateWithoutWallInput, FbDestinationUserUncheckedUpdateWithoutWallInput>
  }

  export type FbDestinationUserUpdateManyWithWhereWithoutWallInput = {
    where: FbDestinationUserScalarWhereInput
    data: XOR<FbDestinationUserUpdateManyMutationInput, FbDestinationUserUncheckedUpdateManyWithoutDestinationUsersInput>
  }

  export type FbWallCreateWithoutDestinationUsersInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: FbPostCreateNestedManyWithoutWallInput
  }

  export type FbWallUncheckedCreateWithoutDestinationUsersInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: FbPostUncheckedCreateNestedManyWithoutWallInput
  }

  export type FbWallCreateOrConnectWithoutDestinationUsersInput = {
    where: FbWallWhereUniqueInput
    create: XOR<FbWallCreateWithoutDestinationUsersInput, FbWallUncheckedCreateWithoutDestinationUsersInput>
  }

  export type FbShareCreateWithoutDestinationUsersInput = {
    user: FbUserCreateNestedOneWithoutSharesInput
    post: FbPostCreateNestedOneWithoutSharesInput
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: FbLikeCreateNestedManyWithoutShareInput
  }

  export type FbShareUncheckedCreateWithoutDestinationUsersInput = {
    id?: number
    userId: number
    postId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: FbLikeUncheckedCreateNestedManyWithoutShareInput
  }

  export type FbShareCreateOrConnectWithoutDestinationUsersInput = {
    where: FbShareWhereUniqueInput
    create: XOR<FbShareCreateWithoutDestinationUsersInput, FbShareUncheckedCreateWithoutDestinationUsersInput>
  }

  export type FbGroupCreateWithoutDestinationUsersInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    groupToUsers?: GroupToUserCreateNestedManyWithoutGroupInput
  }

  export type FbGroupUncheckedCreateWithoutDestinationUsersInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    groupToUsers?: GroupToUserUncheckedCreateNestedManyWithoutGroupInput
  }

  export type FbGroupCreateOrConnectWithoutDestinationUsersInput = {
    where: FbGroupWhereUniqueInput
    create: XOR<FbGroupCreateWithoutDestinationUsersInput, FbGroupUncheckedCreateWithoutDestinationUsersInput>
  }

  export type FbWallUpsertWithoutDestinationUsersInput = {
    update: XOR<FbWallUpdateWithoutDestinationUsersInput, FbWallUncheckedUpdateWithoutDestinationUsersInput>
    create: XOR<FbWallCreateWithoutDestinationUsersInput, FbWallUncheckedCreateWithoutDestinationUsersInput>
  }

  export type FbWallUpdateWithoutDestinationUsersInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: FbPostUpdateManyWithoutWallNestedInput
  }

  export type FbWallUncheckedUpdateWithoutDestinationUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: FbPostUncheckedUpdateManyWithoutWallNestedInput
  }

  export type FbShareUpsertWithoutDestinationUsersInput = {
    update: XOR<FbShareUpdateWithoutDestinationUsersInput, FbShareUncheckedUpdateWithoutDestinationUsersInput>
    create: XOR<FbShareCreateWithoutDestinationUsersInput, FbShareUncheckedCreateWithoutDestinationUsersInput>
  }

  export type FbShareUpdateWithoutDestinationUsersInput = {
    user?: FbUserUpdateOneRequiredWithoutSharesNestedInput
    post?: FbPostUpdateOneRequiredWithoutSharesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: FbLikeUpdateManyWithoutShareNestedInput
  }

  export type FbShareUncheckedUpdateWithoutDestinationUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: FbLikeUncheckedUpdateManyWithoutShareNestedInput
  }

  export type FbGroupUpsertWithoutDestinationUsersInput = {
    update: XOR<FbGroupUpdateWithoutDestinationUsersInput, FbGroupUncheckedUpdateWithoutDestinationUsersInput>
    create: XOR<FbGroupCreateWithoutDestinationUsersInput, FbGroupUncheckedCreateWithoutDestinationUsersInput>
  }

  export type FbGroupUpdateWithoutDestinationUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupToUsers?: GroupToUserUpdateManyWithoutGroupNestedInput
  }

  export type FbGroupUncheckedUpdateWithoutDestinationUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupToUsers?: GroupToUserUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type KorKitchenMenuCreateWithoutCategoryInput = {
    name: string
    image: string
    price: number
    orderItems?: KorKitchenOrderItemCreateNestedManyWithoutMenuInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type KorKitchenMenuUncheckedCreateWithoutCategoryInput = {
    id?: number
    name: string
    image: string
    price: number
    orderItems?: KorKitchenOrderItemUncheckedCreateNestedManyWithoutMenuInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type KorKitchenMenuCreateOrConnectWithoutCategoryInput = {
    where: KorKitchenMenuWhereUniqueInput
    create: XOR<KorKitchenMenuCreateWithoutCategoryInput, KorKitchenMenuUncheckedCreateWithoutCategoryInput>
  }

  export type KorKitchenMenuCreateManyCategoryInputEnvelope = {
    data: Enumerable<KorKitchenMenuCreateManyCategoryInput>
    skipDuplicates?: boolean
  }

  export type KorKitchenMenuUpsertWithWhereUniqueWithoutCategoryInput = {
    where: KorKitchenMenuWhereUniqueInput
    update: XOR<KorKitchenMenuUpdateWithoutCategoryInput, KorKitchenMenuUncheckedUpdateWithoutCategoryInput>
    create: XOR<KorKitchenMenuCreateWithoutCategoryInput, KorKitchenMenuUncheckedCreateWithoutCategoryInput>
  }

  export type KorKitchenMenuUpdateWithWhereUniqueWithoutCategoryInput = {
    where: KorKitchenMenuWhereUniqueInput
    data: XOR<KorKitchenMenuUpdateWithoutCategoryInput, KorKitchenMenuUncheckedUpdateWithoutCategoryInput>
  }

  export type KorKitchenMenuUpdateManyWithWhereWithoutCategoryInput = {
    where: KorKitchenMenuScalarWhereInput
    data: XOR<KorKitchenMenuUpdateManyMutationInput, KorKitchenMenuUncheckedUpdateManyWithoutMenuInput>
  }

  export type KorKitchenMenuScalarWhereInput = {
    AND?: Enumerable<KorKitchenMenuScalarWhereInput>
    OR?: Enumerable<KorKitchenMenuScalarWhereInput>
    NOT?: Enumerable<KorKitchenMenuScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    image?: StringFilter | string
    price?: FloatFilter | number
    categoryName?: StringNullableFilter | string | null
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type KorKitchenCategoryCreateWithoutMenuInput = {
    name: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type KorKitchenCategoryUncheckedCreateWithoutMenuInput = {
    id?: number
    name: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type KorKitchenCategoryCreateOrConnectWithoutMenuInput = {
    where: KorKitchenCategoryWhereUniqueInput
    create: XOR<KorKitchenCategoryCreateWithoutMenuInput, KorKitchenCategoryUncheckedCreateWithoutMenuInput>
  }

  export type KorKitchenOrderItemCreateWithoutMenuInput = {
    order?: KorKitchenOrderCreateNestedOneWithoutItemsInput
    quantity: number
    totalPrice: number
    creatAt?: Date | string
    updatedAt?: Date | string
  }

  export type KorKitchenOrderItemUncheckedCreateWithoutMenuInput = {
    id?: number
    orderId?: number | null
    quantity: number
    totalPrice: number
    creatAt?: Date | string
    updatedAt?: Date | string
  }

  export type KorKitchenOrderItemCreateOrConnectWithoutMenuInput = {
    where: KorKitchenOrderItemWhereUniqueInput
    create: XOR<KorKitchenOrderItemCreateWithoutMenuInput, KorKitchenOrderItemUncheckedCreateWithoutMenuInput>
  }

  export type KorKitchenOrderItemCreateManyMenuInputEnvelope = {
    data: Enumerable<KorKitchenOrderItemCreateManyMenuInput>
    skipDuplicates?: boolean
  }

  export type KorKitchenCategoryUpsertWithoutMenuInput = {
    update: XOR<KorKitchenCategoryUpdateWithoutMenuInput, KorKitchenCategoryUncheckedUpdateWithoutMenuInput>
    create: XOR<KorKitchenCategoryCreateWithoutMenuInput, KorKitchenCategoryUncheckedCreateWithoutMenuInput>
  }

  export type KorKitchenCategoryUpdateWithoutMenuInput = {
    name?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KorKitchenCategoryUncheckedUpdateWithoutMenuInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KorKitchenOrderItemUpsertWithWhereUniqueWithoutMenuInput = {
    where: KorKitchenOrderItemWhereUniqueInput
    update: XOR<KorKitchenOrderItemUpdateWithoutMenuInput, KorKitchenOrderItemUncheckedUpdateWithoutMenuInput>
    create: XOR<KorKitchenOrderItemCreateWithoutMenuInput, KorKitchenOrderItemUncheckedCreateWithoutMenuInput>
  }

  export type KorKitchenOrderItemUpdateWithWhereUniqueWithoutMenuInput = {
    where: KorKitchenOrderItemWhereUniqueInput
    data: XOR<KorKitchenOrderItemUpdateWithoutMenuInput, KorKitchenOrderItemUncheckedUpdateWithoutMenuInput>
  }

  export type KorKitchenOrderItemUpdateManyWithWhereWithoutMenuInput = {
    where: KorKitchenOrderItemScalarWhereInput
    data: XOR<KorKitchenOrderItemUpdateManyMutationInput, KorKitchenOrderItemUncheckedUpdateManyWithoutOrderItemsInput>
  }

  export type KorKitchenOrderItemScalarWhereInput = {
    AND?: Enumerable<KorKitchenOrderItemScalarWhereInput>
    OR?: Enumerable<KorKitchenOrderItemScalarWhereInput>
    NOT?: Enumerable<KorKitchenOrderItemScalarWhereInput>
    id?: IntFilter | number
    menuId?: IntFilter | number
    orderId?: IntNullableFilter | number | null
    quantity?: IntFilter | number
    totalPrice?: FloatFilter | number
    creatAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type KorKitchenOrderItemCreateWithoutOrderInput = {
    menu: KorKitchenMenuCreateNestedOneWithoutOrderItemsInput
    quantity: number
    totalPrice: number
    creatAt?: Date | string
    updatedAt?: Date | string
  }

  export type KorKitchenOrderItemUncheckedCreateWithoutOrderInput = {
    id?: number
    menuId: number
    quantity: number
    totalPrice: number
    creatAt?: Date | string
    updatedAt?: Date | string
  }

  export type KorKitchenOrderItemCreateOrConnectWithoutOrderInput = {
    where: KorKitchenOrderItemWhereUniqueInput
    create: XOR<KorKitchenOrderItemCreateWithoutOrderInput, KorKitchenOrderItemUncheckedCreateWithoutOrderInput>
  }

  export type KorKitchenOrderItemCreateManyOrderInputEnvelope = {
    data: Enumerable<KorKitchenOrderItemCreateManyOrderInput>
    skipDuplicates?: boolean
  }

  export type KorKitchenOrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: KorKitchenOrderItemWhereUniqueInput
    update: XOR<KorKitchenOrderItemUpdateWithoutOrderInput, KorKitchenOrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<KorKitchenOrderItemCreateWithoutOrderInput, KorKitchenOrderItemUncheckedCreateWithoutOrderInput>
  }

  export type KorKitchenOrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: KorKitchenOrderItemWhereUniqueInput
    data: XOR<KorKitchenOrderItemUpdateWithoutOrderInput, KorKitchenOrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type KorKitchenOrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: KorKitchenOrderItemScalarWhereInput
    data: XOR<KorKitchenOrderItemUpdateManyMutationInput, KorKitchenOrderItemUncheckedUpdateManyWithoutItemsInput>
  }

  export type KorKitchenMenuCreateWithoutOrderItemsInput = {
    name: string
    image: string
    price: number
    category?: KorKitchenCategoryCreateNestedOneWithoutMenuInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type KorKitchenMenuUncheckedCreateWithoutOrderItemsInput = {
    id?: number
    name: string
    image: string
    price: number
    categoryName?: string | null
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type KorKitchenMenuCreateOrConnectWithoutOrderItemsInput = {
    where: KorKitchenMenuWhereUniqueInput
    create: XOR<KorKitchenMenuCreateWithoutOrderItemsInput, KorKitchenMenuUncheckedCreateWithoutOrderItemsInput>
  }

  export type KorKitchenOrderCreateWithoutItemsInput = {
    status?: string
    tableId: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type KorKitchenOrderUncheckedCreateWithoutItemsInput = {
    id?: number
    status?: string
    tableId: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type KorKitchenOrderCreateOrConnectWithoutItemsInput = {
    where: KorKitchenOrderWhereUniqueInput
    create: XOR<KorKitchenOrderCreateWithoutItemsInput, KorKitchenOrderUncheckedCreateWithoutItemsInput>
  }

  export type KorKitchenMenuUpsertWithoutOrderItemsInput = {
    update: XOR<KorKitchenMenuUpdateWithoutOrderItemsInput, KorKitchenMenuUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<KorKitchenMenuCreateWithoutOrderItemsInput, KorKitchenMenuUncheckedCreateWithoutOrderItemsInput>
  }

  export type KorKitchenMenuUpdateWithoutOrderItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    category?: KorKitchenCategoryUpdateOneWithoutMenuNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KorKitchenMenuUncheckedUpdateWithoutOrderItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    categoryName?: NullableStringFieldUpdateOperationsInput | string | null
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KorKitchenOrderUpsertWithoutItemsInput = {
    update: XOR<KorKitchenOrderUpdateWithoutItemsInput, KorKitchenOrderUncheckedUpdateWithoutItemsInput>
    create: XOR<KorKitchenOrderCreateWithoutItemsInput, KorKitchenOrderUncheckedCreateWithoutItemsInput>
  }

  export type KorKitchenOrderUpdateWithoutItemsInput = {
    status?: StringFieldUpdateOperationsInput | string
    tableId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KorKitchenOrderUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    tableId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TriviaQuestionCreateWithoutCategoryInput = {
    name: string
    answerID: number
    choices?: TriviaChoiceCreateNestedManyWithoutQuestionInput
    roundQuestions?: TriviaRoundQuestionCreateNestedManyWithoutQuestionInput
  }

  export type TriviaQuestionUncheckedCreateWithoutCategoryInput = {
    id?: number
    name: string
    answerID: number
    choices?: TriviaChoiceUncheckedCreateNestedManyWithoutQuestionInput
    roundQuestions?: TriviaRoundQuestionUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type TriviaQuestionCreateOrConnectWithoutCategoryInput = {
    where: TriviaQuestionWhereUniqueInput
    create: XOR<TriviaQuestionCreateWithoutCategoryInput, TriviaQuestionUncheckedCreateWithoutCategoryInput>
  }

  export type TriviaQuestionCreateManyCategoryInputEnvelope = {
    data: Enumerable<TriviaQuestionCreateManyCategoryInput>
    skipDuplicates?: boolean
  }

  export type TriviaRoundCreateWithoutCategoryInput = {
    user: string
    questions?: TriviaRoundQuestionCreateNestedManyWithoutRoundInput
    totalResult: number
    createAt?: Date | string
  }

  export type TriviaRoundUncheckedCreateWithoutCategoryInput = {
    id?: number
    user: string
    questions?: TriviaRoundQuestionUncheckedCreateNestedManyWithoutRoundInput
    totalResult: number
    createAt?: Date | string
  }

  export type TriviaRoundCreateOrConnectWithoutCategoryInput = {
    where: TriviaRoundWhereUniqueInput
    create: XOR<TriviaRoundCreateWithoutCategoryInput, TriviaRoundUncheckedCreateWithoutCategoryInput>
  }

  export type TriviaRoundCreateManyCategoryInputEnvelope = {
    data: Enumerable<TriviaRoundCreateManyCategoryInput>
    skipDuplicates?: boolean
  }

  export type TriviaQuestionUpsertWithWhereUniqueWithoutCategoryInput = {
    where: TriviaQuestionWhereUniqueInput
    update: XOR<TriviaQuestionUpdateWithoutCategoryInput, TriviaQuestionUncheckedUpdateWithoutCategoryInput>
    create: XOR<TriviaQuestionCreateWithoutCategoryInput, TriviaQuestionUncheckedCreateWithoutCategoryInput>
  }

  export type TriviaQuestionUpdateWithWhereUniqueWithoutCategoryInput = {
    where: TriviaQuestionWhereUniqueInput
    data: XOR<TriviaQuestionUpdateWithoutCategoryInput, TriviaQuestionUncheckedUpdateWithoutCategoryInput>
  }

  export type TriviaQuestionUpdateManyWithWhereWithoutCategoryInput = {
    where: TriviaQuestionScalarWhereInput
    data: XOR<TriviaQuestionUpdateManyMutationInput, TriviaQuestionUncheckedUpdateManyWithoutQuestionsInput>
  }

  export type TriviaQuestionScalarWhereInput = {
    AND?: Enumerable<TriviaQuestionScalarWhereInput>
    OR?: Enumerable<TriviaQuestionScalarWhereInput>
    NOT?: Enumerable<TriviaQuestionScalarWhereInput>
    id?: IntFilter | number
    categoryId?: IntFilter | number
    name?: StringFilter | string
    answerID?: IntFilter | number
  }

  export type TriviaRoundUpsertWithWhereUniqueWithoutCategoryInput = {
    where: TriviaRoundWhereUniqueInput
    update: XOR<TriviaRoundUpdateWithoutCategoryInput, TriviaRoundUncheckedUpdateWithoutCategoryInput>
    create: XOR<TriviaRoundCreateWithoutCategoryInput, TriviaRoundUncheckedCreateWithoutCategoryInput>
  }

  export type TriviaRoundUpdateWithWhereUniqueWithoutCategoryInput = {
    where: TriviaRoundWhereUniqueInput
    data: XOR<TriviaRoundUpdateWithoutCategoryInput, TriviaRoundUncheckedUpdateWithoutCategoryInput>
  }

  export type TriviaRoundUpdateManyWithWhereWithoutCategoryInput = {
    where: TriviaRoundScalarWhereInput
    data: XOR<TriviaRoundUpdateManyMutationInput, TriviaRoundUncheckedUpdateManyWithoutRoundsInput>
  }

  export type TriviaRoundScalarWhereInput = {
    AND?: Enumerable<TriviaRoundScalarWhereInput>
    OR?: Enumerable<TriviaRoundScalarWhereInput>
    NOT?: Enumerable<TriviaRoundScalarWhereInput>
    id?: IntFilter | number
    user?: StringFilter | string
    categoryId?: IntFilter | number
    totalResult?: IntFilter | number
    createAt?: DateTimeFilter | Date | string
  }

  export type TriviaCategoryCreateWithoutQuestionsInput = {
    name: string
    rounds?: TriviaRoundCreateNestedManyWithoutCategoryInput
  }

  export type TriviaCategoryUncheckedCreateWithoutQuestionsInput = {
    id?: number
    name: string
    rounds?: TriviaRoundUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type TriviaCategoryCreateOrConnectWithoutQuestionsInput = {
    where: TriviaCategoryWhereUniqueInput
    create: XOR<TriviaCategoryCreateWithoutQuestionsInput, TriviaCategoryUncheckedCreateWithoutQuestionsInput>
  }

  export type TriviaChoiceCreateWithoutQuestionInput = {
    name: string
    roundQuestions?: TriviaRoundQuestionCreateNestedManyWithoutUserChoiceInput
  }

  export type TriviaChoiceUncheckedCreateWithoutQuestionInput = {
    id?: number
    name: string
    roundQuestions?: TriviaRoundQuestionUncheckedCreateNestedManyWithoutUserChoiceInput
  }

  export type TriviaChoiceCreateOrConnectWithoutQuestionInput = {
    where: TriviaChoiceWhereUniqueInput
    create: XOR<TriviaChoiceCreateWithoutQuestionInput, TriviaChoiceUncheckedCreateWithoutQuestionInput>
  }

  export type TriviaChoiceCreateManyQuestionInputEnvelope = {
    data: Enumerable<TriviaChoiceCreateManyQuestionInput>
    skipDuplicates?: boolean
  }

  export type TriviaRoundQuestionCreateWithoutQuestionInput = {
    userChoice: TriviaChoiceCreateNestedOneWithoutRoundQuestionsInput
    quizResult: boolean
    round?: TriviaRoundCreateNestedOneWithoutQuestionsInput
  }

  export type TriviaRoundQuestionUncheckedCreateWithoutQuestionInput = {
    id?: number
    choiceId: number
    quizResult: boolean
    roundId?: number | null
  }

  export type TriviaRoundQuestionCreateOrConnectWithoutQuestionInput = {
    where: TriviaRoundQuestionWhereUniqueInput
    create: XOR<TriviaRoundQuestionCreateWithoutQuestionInput, TriviaRoundQuestionUncheckedCreateWithoutQuestionInput>
  }

  export type TriviaRoundQuestionCreateManyQuestionInputEnvelope = {
    data: Enumerable<TriviaRoundQuestionCreateManyQuestionInput>
    skipDuplicates?: boolean
  }

  export type TriviaCategoryUpsertWithoutQuestionsInput = {
    update: XOR<TriviaCategoryUpdateWithoutQuestionsInput, TriviaCategoryUncheckedUpdateWithoutQuestionsInput>
    create: XOR<TriviaCategoryCreateWithoutQuestionsInput, TriviaCategoryUncheckedCreateWithoutQuestionsInput>
  }

  export type TriviaCategoryUpdateWithoutQuestionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    rounds?: TriviaRoundUpdateManyWithoutCategoryNestedInput
  }

  export type TriviaCategoryUncheckedUpdateWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    rounds?: TriviaRoundUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type TriviaChoiceUpsertWithWhereUniqueWithoutQuestionInput = {
    where: TriviaChoiceWhereUniqueInput
    update: XOR<TriviaChoiceUpdateWithoutQuestionInput, TriviaChoiceUncheckedUpdateWithoutQuestionInput>
    create: XOR<TriviaChoiceCreateWithoutQuestionInput, TriviaChoiceUncheckedCreateWithoutQuestionInput>
  }

  export type TriviaChoiceUpdateWithWhereUniqueWithoutQuestionInput = {
    where: TriviaChoiceWhereUniqueInput
    data: XOR<TriviaChoiceUpdateWithoutQuestionInput, TriviaChoiceUncheckedUpdateWithoutQuestionInput>
  }

  export type TriviaChoiceUpdateManyWithWhereWithoutQuestionInput = {
    where: TriviaChoiceScalarWhereInput
    data: XOR<TriviaChoiceUpdateManyMutationInput, TriviaChoiceUncheckedUpdateManyWithoutChoicesInput>
  }

  export type TriviaChoiceScalarWhereInput = {
    AND?: Enumerable<TriviaChoiceScalarWhereInput>
    OR?: Enumerable<TriviaChoiceScalarWhereInput>
    NOT?: Enumerable<TriviaChoiceScalarWhereInput>
    id?: IntFilter | number
    quizId?: IntFilter | number
    name?: StringFilter | string
  }

  export type TriviaRoundQuestionUpsertWithWhereUniqueWithoutQuestionInput = {
    where: TriviaRoundQuestionWhereUniqueInput
    update: XOR<TriviaRoundQuestionUpdateWithoutQuestionInput, TriviaRoundQuestionUncheckedUpdateWithoutQuestionInput>
    create: XOR<TriviaRoundQuestionCreateWithoutQuestionInput, TriviaRoundQuestionUncheckedCreateWithoutQuestionInput>
  }

  export type TriviaRoundQuestionUpdateWithWhereUniqueWithoutQuestionInput = {
    where: TriviaRoundQuestionWhereUniqueInput
    data: XOR<TriviaRoundQuestionUpdateWithoutQuestionInput, TriviaRoundQuestionUncheckedUpdateWithoutQuestionInput>
  }

  export type TriviaRoundQuestionUpdateManyWithWhereWithoutQuestionInput = {
    where: TriviaRoundQuestionScalarWhereInput
    data: XOR<TriviaRoundQuestionUpdateManyMutationInput, TriviaRoundQuestionUncheckedUpdateManyWithoutRoundQuestionsInput>
  }

  export type TriviaRoundQuestionScalarWhereInput = {
    AND?: Enumerable<TriviaRoundQuestionScalarWhereInput>
    OR?: Enumerable<TriviaRoundQuestionScalarWhereInput>
    NOT?: Enumerable<TriviaRoundQuestionScalarWhereInput>
    id?: IntFilter | number
    quizId?: IntFilter | number
    choiceId?: IntFilter | number
    quizResult?: BoolFilter | boolean
    roundId?: IntNullableFilter | number | null
  }

  export type TriviaQuestionCreateWithoutChoicesInput = {
    category: TriviaCategoryCreateNestedOneWithoutQuestionsInput
    name: string
    answerID: number
    roundQuestions?: TriviaRoundQuestionCreateNestedManyWithoutQuestionInput
  }

  export type TriviaQuestionUncheckedCreateWithoutChoicesInput = {
    id?: number
    categoryId: number
    name: string
    answerID: number
    roundQuestions?: TriviaRoundQuestionUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type TriviaQuestionCreateOrConnectWithoutChoicesInput = {
    where: TriviaQuestionWhereUniqueInput
    create: XOR<TriviaQuestionCreateWithoutChoicesInput, TriviaQuestionUncheckedCreateWithoutChoicesInput>
  }

  export type TriviaRoundQuestionCreateWithoutUserChoiceInput = {
    question: TriviaQuestionCreateNestedOneWithoutRoundQuestionsInput
    quizResult: boolean
    round?: TriviaRoundCreateNestedOneWithoutQuestionsInput
  }

  export type TriviaRoundQuestionUncheckedCreateWithoutUserChoiceInput = {
    id?: number
    quizId: number
    quizResult: boolean
    roundId?: number | null
  }

  export type TriviaRoundQuestionCreateOrConnectWithoutUserChoiceInput = {
    where: TriviaRoundQuestionWhereUniqueInput
    create: XOR<TriviaRoundQuestionCreateWithoutUserChoiceInput, TriviaRoundQuestionUncheckedCreateWithoutUserChoiceInput>
  }

  export type TriviaRoundQuestionCreateManyUserChoiceInputEnvelope = {
    data: Enumerable<TriviaRoundQuestionCreateManyUserChoiceInput>
    skipDuplicates?: boolean
  }

  export type TriviaQuestionUpsertWithoutChoicesInput = {
    update: XOR<TriviaQuestionUpdateWithoutChoicesInput, TriviaQuestionUncheckedUpdateWithoutChoicesInput>
    create: XOR<TriviaQuestionCreateWithoutChoicesInput, TriviaQuestionUncheckedCreateWithoutChoicesInput>
  }

  export type TriviaQuestionUpdateWithoutChoicesInput = {
    category?: TriviaCategoryUpdateOneRequiredWithoutQuestionsNestedInput
    name?: StringFieldUpdateOperationsInput | string
    answerID?: IntFieldUpdateOperationsInput | number
    roundQuestions?: TriviaRoundQuestionUpdateManyWithoutQuestionNestedInput
  }

  export type TriviaQuestionUncheckedUpdateWithoutChoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    answerID?: IntFieldUpdateOperationsInput | number
    roundQuestions?: TriviaRoundQuestionUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type TriviaRoundQuestionUpsertWithWhereUniqueWithoutUserChoiceInput = {
    where: TriviaRoundQuestionWhereUniqueInput
    update: XOR<TriviaRoundQuestionUpdateWithoutUserChoiceInput, TriviaRoundQuestionUncheckedUpdateWithoutUserChoiceInput>
    create: XOR<TriviaRoundQuestionCreateWithoutUserChoiceInput, TriviaRoundQuestionUncheckedCreateWithoutUserChoiceInput>
  }

  export type TriviaRoundQuestionUpdateWithWhereUniqueWithoutUserChoiceInput = {
    where: TriviaRoundQuestionWhereUniqueInput
    data: XOR<TriviaRoundQuestionUpdateWithoutUserChoiceInput, TriviaRoundQuestionUncheckedUpdateWithoutUserChoiceInput>
  }

  export type TriviaRoundQuestionUpdateManyWithWhereWithoutUserChoiceInput = {
    where: TriviaRoundQuestionScalarWhereInput
    data: XOR<TriviaRoundQuestionUpdateManyMutationInput, TriviaRoundQuestionUncheckedUpdateManyWithoutRoundQuestionsInput>
  }

  export type TriviaQuestionCreateWithoutRoundQuestionsInput = {
    category: TriviaCategoryCreateNestedOneWithoutQuestionsInput
    name: string
    answerID: number
    choices?: TriviaChoiceCreateNestedManyWithoutQuestionInput
  }

  export type TriviaQuestionUncheckedCreateWithoutRoundQuestionsInput = {
    id?: number
    categoryId: number
    name: string
    answerID: number
    choices?: TriviaChoiceUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type TriviaQuestionCreateOrConnectWithoutRoundQuestionsInput = {
    where: TriviaQuestionWhereUniqueInput
    create: XOR<TriviaQuestionCreateWithoutRoundQuestionsInput, TriviaQuestionUncheckedCreateWithoutRoundQuestionsInput>
  }

  export type TriviaChoiceCreateWithoutRoundQuestionsInput = {
    question: TriviaQuestionCreateNestedOneWithoutChoicesInput
    name: string
  }

  export type TriviaChoiceUncheckedCreateWithoutRoundQuestionsInput = {
    id?: number
    quizId: number
    name: string
  }

  export type TriviaChoiceCreateOrConnectWithoutRoundQuestionsInput = {
    where: TriviaChoiceWhereUniqueInput
    create: XOR<TriviaChoiceCreateWithoutRoundQuestionsInput, TriviaChoiceUncheckedCreateWithoutRoundQuestionsInput>
  }

  export type TriviaRoundCreateWithoutQuestionsInput = {
    user: string
    category: TriviaCategoryCreateNestedOneWithoutRoundsInput
    totalResult: number
    createAt?: Date | string
  }

  export type TriviaRoundUncheckedCreateWithoutQuestionsInput = {
    id?: number
    user: string
    categoryId: number
    totalResult: number
    createAt?: Date | string
  }

  export type TriviaRoundCreateOrConnectWithoutQuestionsInput = {
    where: TriviaRoundWhereUniqueInput
    create: XOR<TriviaRoundCreateWithoutQuestionsInput, TriviaRoundUncheckedCreateWithoutQuestionsInput>
  }

  export type TriviaQuestionUpsertWithoutRoundQuestionsInput = {
    update: XOR<TriviaQuestionUpdateWithoutRoundQuestionsInput, TriviaQuestionUncheckedUpdateWithoutRoundQuestionsInput>
    create: XOR<TriviaQuestionCreateWithoutRoundQuestionsInput, TriviaQuestionUncheckedCreateWithoutRoundQuestionsInput>
  }

  export type TriviaQuestionUpdateWithoutRoundQuestionsInput = {
    category?: TriviaCategoryUpdateOneRequiredWithoutQuestionsNestedInput
    name?: StringFieldUpdateOperationsInput | string
    answerID?: IntFieldUpdateOperationsInput | number
    choices?: TriviaChoiceUpdateManyWithoutQuestionNestedInput
  }

  export type TriviaQuestionUncheckedUpdateWithoutRoundQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    answerID?: IntFieldUpdateOperationsInput | number
    choices?: TriviaChoiceUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type TriviaChoiceUpsertWithoutRoundQuestionsInput = {
    update: XOR<TriviaChoiceUpdateWithoutRoundQuestionsInput, TriviaChoiceUncheckedUpdateWithoutRoundQuestionsInput>
    create: XOR<TriviaChoiceCreateWithoutRoundQuestionsInput, TriviaChoiceUncheckedCreateWithoutRoundQuestionsInput>
  }

  export type TriviaChoiceUpdateWithoutRoundQuestionsInput = {
    question?: TriviaQuestionUpdateOneRequiredWithoutChoicesNestedInput
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TriviaChoiceUncheckedUpdateWithoutRoundQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TriviaRoundUpsertWithoutQuestionsInput = {
    update: XOR<TriviaRoundUpdateWithoutQuestionsInput, TriviaRoundUncheckedUpdateWithoutQuestionsInput>
    create: XOR<TriviaRoundCreateWithoutQuestionsInput, TriviaRoundUncheckedCreateWithoutQuestionsInput>
  }

  export type TriviaRoundUpdateWithoutQuestionsInput = {
    user?: StringFieldUpdateOperationsInput | string
    category?: TriviaCategoryUpdateOneRequiredWithoutRoundsNestedInput
    totalResult?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TriviaRoundUncheckedUpdateWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    totalResult?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TriviaRoundQuestionCreateWithoutRoundInput = {
    question: TriviaQuestionCreateNestedOneWithoutRoundQuestionsInput
    userChoice: TriviaChoiceCreateNestedOneWithoutRoundQuestionsInput
    quizResult: boolean
  }

  export type TriviaRoundQuestionUncheckedCreateWithoutRoundInput = {
    id?: number
    quizId: number
    choiceId: number
    quizResult: boolean
  }

  export type TriviaRoundQuestionCreateOrConnectWithoutRoundInput = {
    where: TriviaRoundQuestionWhereUniqueInput
    create: XOR<TriviaRoundQuestionCreateWithoutRoundInput, TriviaRoundQuestionUncheckedCreateWithoutRoundInput>
  }

  export type TriviaRoundQuestionCreateManyRoundInputEnvelope = {
    data: Enumerable<TriviaRoundQuestionCreateManyRoundInput>
    skipDuplicates?: boolean
  }

  export type TriviaCategoryCreateWithoutRoundsInput = {
    name: string
    questions?: TriviaQuestionCreateNestedManyWithoutCategoryInput
  }

  export type TriviaCategoryUncheckedCreateWithoutRoundsInput = {
    id?: number
    name: string
    questions?: TriviaQuestionUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type TriviaCategoryCreateOrConnectWithoutRoundsInput = {
    where: TriviaCategoryWhereUniqueInput
    create: XOR<TriviaCategoryCreateWithoutRoundsInput, TriviaCategoryUncheckedCreateWithoutRoundsInput>
  }

  export type TriviaRoundQuestionUpsertWithWhereUniqueWithoutRoundInput = {
    where: TriviaRoundQuestionWhereUniqueInput
    update: XOR<TriviaRoundQuestionUpdateWithoutRoundInput, TriviaRoundQuestionUncheckedUpdateWithoutRoundInput>
    create: XOR<TriviaRoundQuestionCreateWithoutRoundInput, TriviaRoundQuestionUncheckedCreateWithoutRoundInput>
  }

  export type TriviaRoundQuestionUpdateWithWhereUniqueWithoutRoundInput = {
    where: TriviaRoundQuestionWhereUniqueInput
    data: XOR<TriviaRoundQuestionUpdateWithoutRoundInput, TriviaRoundQuestionUncheckedUpdateWithoutRoundInput>
  }

  export type TriviaRoundQuestionUpdateManyWithWhereWithoutRoundInput = {
    where: TriviaRoundQuestionScalarWhereInput
    data: XOR<TriviaRoundQuestionUpdateManyMutationInput, TriviaRoundQuestionUncheckedUpdateManyWithoutQuestionsInput>
  }

  export type TriviaCategoryUpsertWithoutRoundsInput = {
    update: XOR<TriviaCategoryUpdateWithoutRoundsInput, TriviaCategoryUncheckedUpdateWithoutRoundsInput>
    create: XOR<TriviaCategoryCreateWithoutRoundsInput, TriviaCategoryUncheckedCreateWithoutRoundsInput>
  }

  export type TriviaCategoryUpdateWithoutRoundsInput = {
    name?: StringFieldUpdateOperationsInput | string
    questions?: TriviaQuestionUpdateManyWithoutCategoryNestedInput
  }

  export type TriviaCategoryUncheckedUpdateWithoutRoundsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    questions?: TriviaQuestionUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type TwitterFollowCreateWithoutFromInput = {
    to: TwitterUserCreateNestedOneWithoutToFollowingInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterFollowUncheckedCreateWithoutFromInput = {
    id?: number
    toUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterFollowCreateOrConnectWithoutFromInput = {
    where: TwitterFollowWhereUniqueInput
    create: XOR<TwitterFollowCreateWithoutFromInput, TwitterFollowUncheckedCreateWithoutFromInput>
  }

  export type TwitterFollowCreateManyFromInputEnvelope = {
    data: Enumerable<TwitterFollowCreateManyFromInput>
    skipDuplicates?: boolean
  }

  export type TwitterFollowCreateWithoutToInput = {
    from: TwitterUserCreateNestedOneWithoutFromFollowingInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterFollowUncheckedCreateWithoutToInput = {
    id?: number
    fromUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterFollowCreateOrConnectWithoutToInput = {
    where: TwitterFollowWhereUniqueInput
    create: XOR<TwitterFollowCreateWithoutToInput, TwitterFollowUncheckedCreateWithoutToInput>
  }

  export type TwitterFollowCreateManyToInputEnvelope = {
    data: Enumerable<TwitterFollowCreateManyToInput>
    skipDuplicates?: boolean
  }

  export type TwitterPostCreateWithoutUserInput = {
    caption: string
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: TwitterCommentCreateNestedManyWithoutPostInput
    postOnHashtags?: TwitterPostOnHashtagCreateNestedManyWithoutPostInput
  }

  export type TwitterPostUncheckedCreateWithoutUserInput = {
    id?: number
    caption: string
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: TwitterCommentUncheckedCreateNestedManyWithoutPostInput
    postOnHashtags?: TwitterPostOnHashtagUncheckedCreateNestedManyWithoutPostInput
  }

  export type TwitterPostCreateOrConnectWithoutUserInput = {
    where: TwitterPostWhereUniqueInput
    create: XOR<TwitterPostCreateWithoutUserInput, TwitterPostUncheckedCreateWithoutUserInput>
  }

  export type TwitterPostCreateManyUserInputEnvelope = {
    data: Enumerable<TwitterPostCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type TwitterDirectMessageCreateWithoutFromInput = {
    to: TwitterUserCreateNestedOneWithoutToDirectMessageInput
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterDirectMessageUncheckedCreateWithoutFromInput = {
    id?: number
    toUserId: number
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterDirectMessageCreateOrConnectWithoutFromInput = {
    where: TwitterDirectMessageWhereUniqueInput
    create: XOR<TwitterDirectMessageCreateWithoutFromInput, TwitterDirectMessageUncheckedCreateWithoutFromInput>
  }

  export type TwitterDirectMessageCreateManyFromInputEnvelope = {
    data: Enumerable<TwitterDirectMessageCreateManyFromInput>
    skipDuplicates?: boolean
  }

  export type TwitterDirectMessageCreateWithoutToInput = {
    from: TwitterUserCreateNestedOneWithoutFromDirectMessageInput
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterDirectMessageUncheckedCreateWithoutToInput = {
    id?: number
    fromUserId: number
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterDirectMessageCreateOrConnectWithoutToInput = {
    where: TwitterDirectMessageWhereUniqueInput
    create: XOR<TwitterDirectMessageCreateWithoutToInput, TwitterDirectMessageUncheckedCreateWithoutToInput>
  }

  export type TwitterDirectMessageCreateManyToInputEnvelope = {
    data: Enumerable<TwitterDirectMessageCreateManyToInput>
    skipDuplicates?: boolean
  }

  export type TwitterCommentCreateWithoutUserInput = {
    text: string
    post: TwitterPostCreateNestedOneWithoutCommentsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterCommentUncheckedCreateWithoutUserInput = {
    id?: number
    text: string
    postId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterCommentCreateOrConnectWithoutUserInput = {
    where: TwitterCommentWhereUniqueInput
    create: XOR<TwitterCommentCreateWithoutUserInput, TwitterCommentUncheckedCreateWithoutUserInput>
  }

  export type TwitterCommentCreateManyUserInputEnvelope = {
    data: Enumerable<TwitterCommentCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type TwitterFollowUpsertWithWhereUniqueWithoutFromInput = {
    where: TwitterFollowWhereUniqueInput
    update: XOR<TwitterFollowUpdateWithoutFromInput, TwitterFollowUncheckedUpdateWithoutFromInput>
    create: XOR<TwitterFollowCreateWithoutFromInput, TwitterFollowUncheckedCreateWithoutFromInput>
  }

  export type TwitterFollowUpdateWithWhereUniqueWithoutFromInput = {
    where: TwitterFollowWhereUniqueInput
    data: XOR<TwitterFollowUpdateWithoutFromInput, TwitterFollowUncheckedUpdateWithoutFromInput>
  }

  export type TwitterFollowUpdateManyWithWhereWithoutFromInput = {
    where: TwitterFollowScalarWhereInput
    data: XOR<TwitterFollowUpdateManyMutationInput, TwitterFollowUncheckedUpdateManyWithoutFromFollowingInput>
  }

  export type TwitterFollowScalarWhereInput = {
    AND?: Enumerable<TwitterFollowScalarWhereInput>
    OR?: Enumerable<TwitterFollowScalarWhereInput>
    NOT?: Enumerable<TwitterFollowScalarWhereInput>
    id?: IntFilter | number
    fromUserId?: IntFilter | number
    toUserId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TwitterFollowUpsertWithWhereUniqueWithoutToInput = {
    where: TwitterFollowWhereUniqueInput
    update: XOR<TwitterFollowUpdateWithoutToInput, TwitterFollowUncheckedUpdateWithoutToInput>
    create: XOR<TwitterFollowCreateWithoutToInput, TwitterFollowUncheckedCreateWithoutToInput>
  }

  export type TwitterFollowUpdateWithWhereUniqueWithoutToInput = {
    where: TwitterFollowWhereUniqueInput
    data: XOR<TwitterFollowUpdateWithoutToInput, TwitterFollowUncheckedUpdateWithoutToInput>
  }

  export type TwitterFollowUpdateManyWithWhereWithoutToInput = {
    where: TwitterFollowScalarWhereInput
    data: XOR<TwitterFollowUpdateManyMutationInput, TwitterFollowUncheckedUpdateManyWithoutToFollowingInput>
  }

  export type TwitterPostUpsertWithWhereUniqueWithoutUserInput = {
    where: TwitterPostWhereUniqueInput
    update: XOR<TwitterPostUpdateWithoutUserInput, TwitterPostUncheckedUpdateWithoutUserInput>
    create: XOR<TwitterPostCreateWithoutUserInput, TwitterPostUncheckedCreateWithoutUserInput>
  }

  export type TwitterPostUpdateWithWhereUniqueWithoutUserInput = {
    where: TwitterPostWhereUniqueInput
    data: XOR<TwitterPostUpdateWithoutUserInput, TwitterPostUncheckedUpdateWithoutUserInput>
  }

  export type TwitterPostUpdateManyWithWhereWithoutUserInput = {
    where: TwitterPostScalarWhereInput
    data: XOR<TwitterPostUpdateManyMutationInput, TwitterPostUncheckedUpdateManyWithoutPostsInput>
  }

  export type TwitterPostScalarWhereInput = {
    AND?: Enumerable<TwitterPostScalarWhereInput>
    OR?: Enumerable<TwitterPostScalarWhereInput>
    NOT?: Enumerable<TwitterPostScalarWhereInput>
    id?: IntFilter | number
    caption?: StringFilter | string
    userId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TwitterDirectMessageUpsertWithWhereUniqueWithoutFromInput = {
    where: TwitterDirectMessageWhereUniqueInput
    update: XOR<TwitterDirectMessageUpdateWithoutFromInput, TwitterDirectMessageUncheckedUpdateWithoutFromInput>
    create: XOR<TwitterDirectMessageCreateWithoutFromInput, TwitterDirectMessageUncheckedCreateWithoutFromInput>
  }

  export type TwitterDirectMessageUpdateWithWhereUniqueWithoutFromInput = {
    where: TwitterDirectMessageWhereUniqueInput
    data: XOR<TwitterDirectMessageUpdateWithoutFromInput, TwitterDirectMessageUncheckedUpdateWithoutFromInput>
  }

  export type TwitterDirectMessageUpdateManyWithWhereWithoutFromInput = {
    where: TwitterDirectMessageScalarWhereInput
    data: XOR<TwitterDirectMessageUpdateManyMutationInput, TwitterDirectMessageUncheckedUpdateManyWithoutFromDirectMessageInput>
  }

  export type TwitterDirectMessageScalarWhereInput = {
    AND?: Enumerable<TwitterDirectMessageScalarWhereInput>
    OR?: Enumerable<TwitterDirectMessageScalarWhereInput>
    NOT?: Enumerable<TwitterDirectMessageScalarWhereInput>
    id?: IntFilter | number
    fromUserId?: IntFilter | number
    toUserId?: IntFilter | number
    text?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TwitterDirectMessageUpsertWithWhereUniqueWithoutToInput = {
    where: TwitterDirectMessageWhereUniqueInput
    update: XOR<TwitterDirectMessageUpdateWithoutToInput, TwitterDirectMessageUncheckedUpdateWithoutToInput>
    create: XOR<TwitterDirectMessageCreateWithoutToInput, TwitterDirectMessageUncheckedCreateWithoutToInput>
  }

  export type TwitterDirectMessageUpdateWithWhereUniqueWithoutToInput = {
    where: TwitterDirectMessageWhereUniqueInput
    data: XOR<TwitterDirectMessageUpdateWithoutToInput, TwitterDirectMessageUncheckedUpdateWithoutToInput>
  }

  export type TwitterDirectMessageUpdateManyWithWhereWithoutToInput = {
    where: TwitterDirectMessageScalarWhereInput
    data: XOR<TwitterDirectMessageUpdateManyMutationInput, TwitterDirectMessageUncheckedUpdateManyWithoutToDirectMessageInput>
  }

  export type TwitterCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: TwitterCommentWhereUniqueInput
    update: XOR<TwitterCommentUpdateWithoutUserInput, TwitterCommentUncheckedUpdateWithoutUserInput>
    create: XOR<TwitterCommentCreateWithoutUserInput, TwitterCommentUncheckedCreateWithoutUserInput>
  }

  export type TwitterCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: TwitterCommentWhereUniqueInput
    data: XOR<TwitterCommentUpdateWithoutUserInput, TwitterCommentUncheckedUpdateWithoutUserInput>
  }

  export type TwitterCommentUpdateManyWithWhereWithoutUserInput = {
    where: TwitterCommentScalarWhereInput
    data: XOR<TwitterCommentUpdateManyMutationInput, TwitterCommentUncheckedUpdateManyWithoutCommentsInput>
  }

  export type TwitterCommentScalarWhereInput = {
    AND?: Enumerable<TwitterCommentScalarWhereInput>
    OR?: Enumerable<TwitterCommentScalarWhereInput>
    NOT?: Enumerable<TwitterCommentScalarWhereInput>
    id?: IntFilter | number
    text?: StringFilter | string
    userId?: IntFilter | number
    postId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TwitterUserCreateWithoutFromFollowingInput = {
    name: string
    Image: string
    createdAt?: Date | string
    updatedAt?: Date | string
    toFollowing?: TwitterFollowCreateNestedManyWithoutToInput
    posts?: TwitterPostCreateNestedManyWithoutUserInput
    fromDirectMessage?: TwitterDirectMessageCreateNestedManyWithoutFromInput
    toDirectMessage?: TwitterDirectMessageCreateNestedManyWithoutToInput
    comments?: TwitterCommentCreateNestedManyWithoutUserInput
  }

  export type TwitterUserUncheckedCreateWithoutFromFollowingInput = {
    id?: number
    name: string
    Image: string
    createdAt?: Date | string
    updatedAt?: Date | string
    toFollowing?: TwitterFollowUncheckedCreateNestedManyWithoutToInput
    posts?: TwitterPostUncheckedCreateNestedManyWithoutUserInput
    fromDirectMessage?: TwitterDirectMessageUncheckedCreateNestedManyWithoutFromInput
    toDirectMessage?: TwitterDirectMessageUncheckedCreateNestedManyWithoutToInput
    comments?: TwitterCommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type TwitterUserCreateOrConnectWithoutFromFollowingInput = {
    where: TwitterUserWhereUniqueInput
    create: XOR<TwitterUserCreateWithoutFromFollowingInput, TwitterUserUncheckedCreateWithoutFromFollowingInput>
  }

  export type TwitterUserCreateWithoutToFollowingInput = {
    name: string
    Image: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fromFollowing?: TwitterFollowCreateNestedManyWithoutFromInput
    posts?: TwitterPostCreateNestedManyWithoutUserInput
    fromDirectMessage?: TwitterDirectMessageCreateNestedManyWithoutFromInput
    toDirectMessage?: TwitterDirectMessageCreateNestedManyWithoutToInput
    comments?: TwitterCommentCreateNestedManyWithoutUserInput
  }

  export type TwitterUserUncheckedCreateWithoutToFollowingInput = {
    id?: number
    name: string
    Image: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fromFollowing?: TwitterFollowUncheckedCreateNestedManyWithoutFromInput
    posts?: TwitterPostUncheckedCreateNestedManyWithoutUserInput
    fromDirectMessage?: TwitterDirectMessageUncheckedCreateNestedManyWithoutFromInput
    toDirectMessage?: TwitterDirectMessageUncheckedCreateNestedManyWithoutToInput
    comments?: TwitterCommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type TwitterUserCreateOrConnectWithoutToFollowingInput = {
    where: TwitterUserWhereUniqueInput
    create: XOR<TwitterUserCreateWithoutToFollowingInput, TwitterUserUncheckedCreateWithoutToFollowingInput>
  }

  export type TwitterUserUpsertWithoutFromFollowingInput = {
    update: XOR<TwitterUserUpdateWithoutFromFollowingInput, TwitterUserUncheckedUpdateWithoutFromFollowingInput>
    create: XOR<TwitterUserCreateWithoutFromFollowingInput, TwitterUserUncheckedCreateWithoutFromFollowingInput>
  }

  export type TwitterUserUpdateWithoutFromFollowingInput = {
    name?: StringFieldUpdateOperationsInput | string
    Image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    toFollowing?: TwitterFollowUpdateManyWithoutToNestedInput
    posts?: TwitterPostUpdateManyWithoutUserNestedInput
    fromDirectMessage?: TwitterDirectMessageUpdateManyWithoutFromNestedInput
    toDirectMessage?: TwitterDirectMessageUpdateManyWithoutToNestedInput
    comments?: TwitterCommentUpdateManyWithoutUserNestedInput
  }

  export type TwitterUserUncheckedUpdateWithoutFromFollowingInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    Image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    toFollowing?: TwitterFollowUncheckedUpdateManyWithoutToNestedInput
    posts?: TwitterPostUncheckedUpdateManyWithoutUserNestedInput
    fromDirectMessage?: TwitterDirectMessageUncheckedUpdateManyWithoutFromNestedInput
    toDirectMessage?: TwitterDirectMessageUncheckedUpdateManyWithoutToNestedInput
    comments?: TwitterCommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TwitterUserUpsertWithoutToFollowingInput = {
    update: XOR<TwitterUserUpdateWithoutToFollowingInput, TwitterUserUncheckedUpdateWithoutToFollowingInput>
    create: XOR<TwitterUserCreateWithoutToFollowingInput, TwitterUserUncheckedCreateWithoutToFollowingInput>
  }

  export type TwitterUserUpdateWithoutToFollowingInput = {
    name?: StringFieldUpdateOperationsInput | string
    Image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromFollowing?: TwitterFollowUpdateManyWithoutFromNestedInput
    posts?: TwitterPostUpdateManyWithoutUserNestedInput
    fromDirectMessage?: TwitterDirectMessageUpdateManyWithoutFromNestedInput
    toDirectMessage?: TwitterDirectMessageUpdateManyWithoutToNestedInput
    comments?: TwitterCommentUpdateManyWithoutUserNestedInput
  }

  export type TwitterUserUncheckedUpdateWithoutToFollowingInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    Image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromFollowing?: TwitterFollowUncheckedUpdateManyWithoutFromNestedInput
    posts?: TwitterPostUncheckedUpdateManyWithoutUserNestedInput
    fromDirectMessage?: TwitterDirectMessageUncheckedUpdateManyWithoutFromNestedInput
    toDirectMessage?: TwitterDirectMessageUncheckedUpdateManyWithoutToNestedInput
    comments?: TwitterCommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TwitterUserCreateWithoutPostsInput = {
    name: string
    Image: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fromFollowing?: TwitterFollowCreateNestedManyWithoutFromInput
    toFollowing?: TwitterFollowCreateNestedManyWithoutToInput
    fromDirectMessage?: TwitterDirectMessageCreateNestedManyWithoutFromInput
    toDirectMessage?: TwitterDirectMessageCreateNestedManyWithoutToInput
    comments?: TwitterCommentCreateNestedManyWithoutUserInput
  }

  export type TwitterUserUncheckedCreateWithoutPostsInput = {
    id?: number
    name: string
    Image: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fromFollowing?: TwitterFollowUncheckedCreateNestedManyWithoutFromInput
    toFollowing?: TwitterFollowUncheckedCreateNestedManyWithoutToInput
    fromDirectMessage?: TwitterDirectMessageUncheckedCreateNestedManyWithoutFromInput
    toDirectMessage?: TwitterDirectMessageUncheckedCreateNestedManyWithoutToInput
    comments?: TwitterCommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type TwitterUserCreateOrConnectWithoutPostsInput = {
    where: TwitterUserWhereUniqueInput
    create: XOR<TwitterUserCreateWithoutPostsInput, TwitterUserUncheckedCreateWithoutPostsInput>
  }

  export type TwitterCommentCreateWithoutPostInput = {
    text: string
    user: TwitterUserCreateNestedOneWithoutCommentsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterCommentUncheckedCreateWithoutPostInput = {
    id?: number
    text: string
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterCommentCreateOrConnectWithoutPostInput = {
    where: TwitterCommentWhereUniqueInput
    create: XOR<TwitterCommentCreateWithoutPostInput, TwitterCommentUncheckedCreateWithoutPostInput>
  }

  export type TwitterCommentCreateManyPostInputEnvelope = {
    data: Enumerable<TwitterCommentCreateManyPostInput>
    skipDuplicates?: boolean
  }

  export type TwitterPostOnHashtagCreateWithoutPostInput = {
    hashtag: TwitterHashtagCreateNestedOneWithoutPostOnHashtagInput
  }

  export type TwitterPostOnHashtagUncheckedCreateWithoutPostInput = {
    id?: number
    hashtagId: number
  }

  export type TwitterPostOnHashtagCreateOrConnectWithoutPostInput = {
    where: TwitterPostOnHashtagWhereUniqueInput
    create: XOR<TwitterPostOnHashtagCreateWithoutPostInput, TwitterPostOnHashtagUncheckedCreateWithoutPostInput>
  }

  export type TwitterPostOnHashtagCreateManyPostInputEnvelope = {
    data: Enumerable<TwitterPostOnHashtagCreateManyPostInput>
    skipDuplicates?: boolean
  }

  export type TwitterUserUpsertWithoutPostsInput = {
    update: XOR<TwitterUserUpdateWithoutPostsInput, TwitterUserUncheckedUpdateWithoutPostsInput>
    create: XOR<TwitterUserCreateWithoutPostsInput, TwitterUserUncheckedCreateWithoutPostsInput>
  }

  export type TwitterUserUpdateWithoutPostsInput = {
    name?: StringFieldUpdateOperationsInput | string
    Image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromFollowing?: TwitterFollowUpdateManyWithoutFromNestedInput
    toFollowing?: TwitterFollowUpdateManyWithoutToNestedInput
    fromDirectMessage?: TwitterDirectMessageUpdateManyWithoutFromNestedInput
    toDirectMessage?: TwitterDirectMessageUpdateManyWithoutToNestedInput
    comments?: TwitterCommentUpdateManyWithoutUserNestedInput
  }

  export type TwitterUserUncheckedUpdateWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    Image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromFollowing?: TwitterFollowUncheckedUpdateManyWithoutFromNestedInput
    toFollowing?: TwitterFollowUncheckedUpdateManyWithoutToNestedInput
    fromDirectMessage?: TwitterDirectMessageUncheckedUpdateManyWithoutFromNestedInput
    toDirectMessage?: TwitterDirectMessageUncheckedUpdateManyWithoutToNestedInput
    comments?: TwitterCommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TwitterCommentUpsertWithWhereUniqueWithoutPostInput = {
    where: TwitterCommentWhereUniqueInput
    update: XOR<TwitterCommentUpdateWithoutPostInput, TwitterCommentUncheckedUpdateWithoutPostInput>
    create: XOR<TwitterCommentCreateWithoutPostInput, TwitterCommentUncheckedCreateWithoutPostInput>
  }

  export type TwitterCommentUpdateWithWhereUniqueWithoutPostInput = {
    where: TwitterCommentWhereUniqueInput
    data: XOR<TwitterCommentUpdateWithoutPostInput, TwitterCommentUncheckedUpdateWithoutPostInput>
  }

  export type TwitterCommentUpdateManyWithWhereWithoutPostInput = {
    where: TwitterCommentScalarWhereInput
    data: XOR<TwitterCommentUpdateManyMutationInput, TwitterCommentUncheckedUpdateManyWithoutCommentsInput>
  }

  export type TwitterPostOnHashtagUpsertWithWhereUniqueWithoutPostInput = {
    where: TwitterPostOnHashtagWhereUniqueInput
    update: XOR<TwitterPostOnHashtagUpdateWithoutPostInput, TwitterPostOnHashtagUncheckedUpdateWithoutPostInput>
    create: XOR<TwitterPostOnHashtagCreateWithoutPostInput, TwitterPostOnHashtagUncheckedCreateWithoutPostInput>
  }

  export type TwitterPostOnHashtagUpdateWithWhereUniqueWithoutPostInput = {
    where: TwitterPostOnHashtagWhereUniqueInput
    data: XOR<TwitterPostOnHashtagUpdateWithoutPostInput, TwitterPostOnHashtagUncheckedUpdateWithoutPostInput>
  }

  export type TwitterPostOnHashtagUpdateManyWithWhereWithoutPostInput = {
    where: TwitterPostOnHashtagScalarWhereInput
    data: XOR<TwitterPostOnHashtagUpdateManyMutationInput, TwitterPostOnHashtagUncheckedUpdateManyWithoutPostOnHashtagsInput>
  }

  export type TwitterPostOnHashtagScalarWhereInput = {
    AND?: Enumerable<TwitterPostOnHashtagScalarWhereInput>
    OR?: Enumerable<TwitterPostOnHashtagScalarWhereInput>
    NOT?: Enumerable<TwitterPostOnHashtagScalarWhereInput>
    id?: IntFilter | number
    postId?: IntFilter | number
    hashtagId?: IntFilter | number
  }

  export type TwitterUserCreateWithoutFromDirectMessageInput = {
    name: string
    Image: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fromFollowing?: TwitterFollowCreateNestedManyWithoutFromInput
    toFollowing?: TwitterFollowCreateNestedManyWithoutToInput
    posts?: TwitterPostCreateNestedManyWithoutUserInput
    toDirectMessage?: TwitterDirectMessageCreateNestedManyWithoutToInput
    comments?: TwitterCommentCreateNestedManyWithoutUserInput
  }

  export type TwitterUserUncheckedCreateWithoutFromDirectMessageInput = {
    id?: number
    name: string
    Image: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fromFollowing?: TwitterFollowUncheckedCreateNestedManyWithoutFromInput
    toFollowing?: TwitterFollowUncheckedCreateNestedManyWithoutToInput
    posts?: TwitterPostUncheckedCreateNestedManyWithoutUserInput
    toDirectMessage?: TwitterDirectMessageUncheckedCreateNestedManyWithoutToInput
    comments?: TwitterCommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type TwitterUserCreateOrConnectWithoutFromDirectMessageInput = {
    where: TwitterUserWhereUniqueInput
    create: XOR<TwitterUserCreateWithoutFromDirectMessageInput, TwitterUserUncheckedCreateWithoutFromDirectMessageInput>
  }

  export type TwitterUserCreateWithoutToDirectMessageInput = {
    name: string
    Image: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fromFollowing?: TwitterFollowCreateNestedManyWithoutFromInput
    toFollowing?: TwitterFollowCreateNestedManyWithoutToInput
    posts?: TwitterPostCreateNestedManyWithoutUserInput
    fromDirectMessage?: TwitterDirectMessageCreateNestedManyWithoutFromInput
    comments?: TwitterCommentCreateNestedManyWithoutUserInput
  }

  export type TwitterUserUncheckedCreateWithoutToDirectMessageInput = {
    id?: number
    name: string
    Image: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fromFollowing?: TwitterFollowUncheckedCreateNestedManyWithoutFromInput
    toFollowing?: TwitterFollowUncheckedCreateNestedManyWithoutToInput
    posts?: TwitterPostUncheckedCreateNestedManyWithoutUserInput
    fromDirectMessage?: TwitterDirectMessageUncheckedCreateNestedManyWithoutFromInput
    comments?: TwitterCommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type TwitterUserCreateOrConnectWithoutToDirectMessageInput = {
    where: TwitterUserWhereUniqueInput
    create: XOR<TwitterUserCreateWithoutToDirectMessageInput, TwitterUserUncheckedCreateWithoutToDirectMessageInput>
  }

  export type TwitterUserUpsertWithoutFromDirectMessageInput = {
    update: XOR<TwitterUserUpdateWithoutFromDirectMessageInput, TwitterUserUncheckedUpdateWithoutFromDirectMessageInput>
    create: XOR<TwitterUserCreateWithoutFromDirectMessageInput, TwitterUserUncheckedCreateWithoutFromDirectMessageInput>
  }

  export type TwitterUserUpdateWithoutFromDirectMessageInput = {
    name?: StringFieldUpdateOperationsInput | string
    Image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromFollowing?: TwitterFollowUpdateManyWithoutFromNestedInput
    toFollowing?: TwitterFollowUpdateManyWithoutToNestedInput
    posts?: TwitterPostUpdateManyWithoutUserNestedInput
    toDirectMessage?: TwitterDirectMessageUpdateManyWithoutToNestedInput
    comments?: TwitterCommentUpdateManyWithoutUserNestedInput
  }

  export type TwitterUserUncheckedUpdateWithoutFromDirectMessageInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    Image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromFollowing?: TwitterFollowUncheckedUpdateManyWithoutFromNestedInput
    toFollowing?: TwitterFollowUncheckedUpdateManyWithoutToNestedInput
    posts?: TwitterPostUncheckedUpdateManyWithoutUserNestedInput
    toDirectMessage?: TwitterDirectMessageUncheckedUpdateManyWithoutToNestedInput
    comments?: TwitterCommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TwitterUserUpsertWithoutToDirectMessageInput = {
    update: XOR<TwitterUserUpdateWithoutToDirectMessageInput, TwitterUserUncheckedUpdateWithoutToDirectMessageInput>
    create: XOR<TwitterUserCreateWithoutToDirectMessageInput, TwitterUserUncheckedCreateWithoutToDirectMessageInput>
  }

  export type TwitterUserUpdateWithoutToDirectMessageInput = {
    name?: StringFieldUpdateOperationsInput | string
    Image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromFollowing?: TwitterFollowUpdateManyWithoutFromNestedInput
    toFollowing?: TwitterFollowUpdateManyWithoutToNestedInput
    posts?: TwitterPostUpdateManyWithoutUserNestedInput
    fromDirectMessage?: TwitterDirectMessageUpdateManyWithoutFromNestedInput
    comments?: TwitterCommentUpdateManyWithoutUserNestedInput
  }

  export type TwitterUserUncheckedUpdateWithoutToDirectMessageInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    Image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromFollowing?: TwitterFollowUncheckedUpdateManyWithoutFromNestedInput
    toFollowing?: TwitterFollowUncheckedUpdateManyWithoutToNestedInput
    posts?: TwitterPostUncheckedUpdateManyWithoutUserNestedInput
    fromDirectMessage?: TwitterDirectMessageUncheckedUpdateManyWithoutFromNestedInput
    comments?: TwitterCommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TwitterPostOnHashtagCreateWithoutHashtagInput = {
    post: TwitterPostCreateNestedOneWithoutPostOnHashtagsInput
  }

  export type TwitterPostOnHashtagUncheckedCreateWithoutHashtagInput = {
    id?: number
    postId: number
  }

  export type TwitterPostOnHashtagCreateOrConnectWithoutHashtagInput = {
    where: TwitterPostOnHashtagWhereUniqueInput
    create: XOR<TwitterPostOnHashtagCreateWithoutHashtagInput, TwitterPostOnHashtagUncheckedCreateWithoutHashtagInput>
  }

  export type TwitterPostOnHashtagCreateManyHashtagInputEnvelope = {
    data: Enumerable<TwitterPostOnHashtagCreateManyHashtagInput>
    skipDuplicates?: boolean
  }

  export type TwitterPostOnHashtagUpsertWithWhereUniqueWithoutHashtagInput = {
    where: TwitterPostOnHashtagWhereUniqueInput
    update: XOR<TwitterPostOnHashtagUpdateWithoutHashtagInput, TwitterPostOnHashtagUncheckedUpdateWithoutHashtagInput>
    create: XOR<TwitterPostOnHashtagCreateWithoutHashtagInput, TwitterPostOnHashtagUncheckedCreateWithoutHashtagInput>
  }

  export type TwitterPostOnHashtagUpdateWithWhereUniqueWithoutHashtagInput = {
    where: TwitterPostOnHashtagWhereUniqueInput
    data: XOR<TwitterPostOnHashtagUpdateWithoutHashtagInput, TwitterPostOnHashtagUncheckedUpdateWithoutHashtagInput>
  }

  export type TwitterPostOnHashtagUpdateManyWithWhereWithoutHashtagInput = {
    where: TwitterPostOnHashtagScalarWhereInput
    data: XOR<TwitterPostOnHashtagUpdateManyMutationInput, TwitterPostOnHashtagUncheckedUpdateManyWithoutPostOnHashtagInput>
  }

  export type TwitterUserCreateWithoutCommentsInput = {
    name: string
    Image: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fromFollowing?: TwitterFollowCreateNestedManyWithoutFromInput
    toFollowing?: TwitterFollowCreateNestedManyWithoutToInput
    posts?: TwitterPostCreateNestedManyWithoutUserInput
    fromDirectMessage?: TwitterDirectMessageCreateNestedManyWithoutFromInput
    toDirectMessage?: TwitterDirectMessageCreateNestedManyWithoutToInput
  }

  export type TwitterUserUncheckedCreateWithoutCommentsInput = {
    id?: number
    name: string
    Image: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fromFollowing?: TwitterFollowUncheckedCreateNestedManyWithoutFromInput
    toFollowing?: TwitterFollowUncheckedCreateNestedManyWithoutToInput
    posts?: TwitterPostUncheckedCreateNestedManyWithoutUserInput
    fromDirectMessage?: TwitterDirectMessageUncheckedCreateNestedManyWithoutFromInput
    toDirectMessage?: TwitterDirectMessageUncheckedCreateNestedManyWithoutToInput
  }

  export type TwitterUserCreateOrConnectWithoutCommentsInput = {
    where: TwitterUserWhereUniqueInput
    create: XOR<TwitterUserCreateWithoutCommentsInput, TwitterUserUncheckedCreateWithoutCommentsInput>
  }

  export type TwitterPostCreateWithoutCommentsInput = {
    caption: string
    user: TwitterUserCreateNestedOneWithoutPostsInput
    createdAt?: Date | string
    updatedAt?: Date | string
    postOnHashtags?: TwitterPostOnHashtagCreateNestedManyWithoutPostInput
  }

  export type TwitterPostUncheckedCreateWithoutCommentsInput = {
    id?: number
    caption: string
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    postOnHashtags?: TwitterPostOnHashtagUncheckedCreateNestedManyWithoutPostInput
  }

  export type TwitterPostCreateOrConnectWithoutCommentsInput = {
    where: TwitterPostWhereUniqueInput
    create: XOR<TwitterPostCreateWithoutCommentsInput, TwitterPostUncheckedCreateWithoutCommentsInput>
  }

  export type TwitterUserUpsertWithoutCommentsInput = {
    update: XOR<TwitterUserUpdateWithoutCommentsInput, TwitterUserUncheckedUpdateWithoutCommentsInput>
    create: XOR<TwitterUserCreateWithoutCommentsInput, TwitterUserUncheckedCreateWithoutCommentsInput>
  }

  export type TwitterUserUpdateWithoutCommentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    Image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromFollowing?: TwitterFollowUpdateManyWithoutFromNestedInput
    toFollowing?: TwitterFollowUpdateManyWithoutToNestedInput
    posts?: TwitterPostUpdateManyWithoutUserNestedInput
    fromDirectMessage?: TwitterDirectMessageUpdateManyWithoutFromNestedInput
    toDirectMessage?: TwitterDirectMessageUpdateManyWithoutToNestedInput
  }

  export type TwitterUserUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    Image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromFollowing?: TwitterFollowUncheckedUpdateManyWithoutFromNestedInput
    toFollowing?: TwitterFollowUncheckedUpdateManyWithoutToNestedInput
    posts?: TwitterPostUncheckedUpdateManyWithoutUserNestedInput
    fromDirectMessage?: TwitterDirectMessageUncheckedUpdateManyWithoutFromNestedInput
    toDirectMessage?: TwitterDirectMessageUncheckedUpdateManyWithoutToNestedInput
  }

  export type TwitterPostUpsertWithoutCommentsInput = {
    update: XOR<TwitterPostUpdateWithoutCommentsInput, TwitterPostUncheckedUpdateWithoutCommentsInput>
    create: XOR<TwitterPostCreateWithoutCommentsInput, TwitterPostUncheckedCreateWithoutCommentsInput>
  }

  export type TwitterPostUpdateWithoutCommentsInput = {
    caption?: StringFieldUpdateOperationsInput | string
    user?: TwitterUserUpdateOneRequiredWithoutPostsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postOnHashtags?: TwitterPostOnHashtagUpdateManyWithoutPostNestedInput
  }

  export type TwitterPostUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    caption?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postOnHashtags?: TwitterPostOnHashtagUncheckedUpdateManyWithoutPostNestedInput
  }

  export type TwitterPostCreateWithoutPostOnHashtagsInput = {
    caption: string
    user: TwitterUserCreateNestedOneWithoutPostsInput
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: TwitterCommentCreateNestedManyWithoutPostInput
  }

  export type TwitterPostUncheckedCreateWithoutPostOnHashtagsInput = {
    id?: number
    caption: string
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: TwitterCommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type TwitterPostCreateOrConnectWithoutPostOnHashtagsInput = {
    where: TwitterPostWhereUniqueInput
    create: XOR<TwitterPostCreateWithoutPostOnHashtagsInput, TwitterPostUncheckedCreateWithoutPostOnHashtagsInput>
  }

  export type TwitterHashtagCreateWithoutPostOnHashtagInput = {
    hashtag: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterHashtagUncheckedCreateWithoutPostOnHashtagInput = {
    id?: number
    hashtag: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterHashtagCreateOrConnectWithoutPostOnHashtagInput = {
    where: TwitterHashtagWhereUniqueInput
    create: XOR<TwitterHashtagCreateWithoutPostOnHashtagInput, TwitterHashtagUncheckedCreateWithoutPostOnHashtagInput>
  }

  export type TwitterPostUpsertWithoutPostOnHashtagsInput = {
    update: XOR<TwitterPostUpdateWithoutPostOnHashtagsInput, TwitterPostUncheckedUpdateWithoutPostOnHashtagsInput>
    create: XOR<TwitterPostCreateWithoutPostOnHashtagsInput, TwitterPostUncheckedCreateWithoutPostOnHashtagsInput>
  }

  export type TwitterPostUpdateWithoutPostOnHashtagsInput = {
    caption?: StringFieldUpdateOperationsInput | string
    user?: TwitterUserUpdateOneRequiredWithoutPostsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: TwitterCommentUpdateManyWithoutPostNestedInput
  }

  export type TwitterPostUncheckedUpdateWithoutPostOnHashtagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    caption?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: TwitterCommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type TwitterHashtagUpsertWithoutPostOnHashtagInput = {
    update: XOR<TwitterHashtagUpdateWithoutPostOnHashtagInput, TwitterHashtagUncheckedUpdateWithoutPostOnHashtagInput>
    create: XOR<TwitterHashtagCreateWithoutPostOnHashtagInput, TwitterHashtagUncheckedCreateWithoutPostOnHashtagInput>
  }

  export type TwitterHashtagUpdateWithoutPostOnHashtagInput = {
    hashtag?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterHashtagUncheckedUpdateWithoutPostOnHashtagInput = {
    id?: IntFieldUpdateOperationsInput | number
    hashtag?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WSTopupHistoryCreateWithoutUserInput = {
    topup: number
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type WSTopupHistoryUncheckedCreateWithoutUserInput = {
    id?: number
    topup: number
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type WSTopupHistoryCreateOrConnectWithoutUserInput = {
    where: WSTopupHistoryWhereUniqueInput
    create: XOR<WSTopupHistoryCreateWithoutUserInput, WSTopupHistoryUncheckedCreateWithoutUserInput>
  }

  export type WSTopupHistoryCreateManyUserInputEnvelope = {
    data: Enumerable<WSTopupHistoryCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type WSUsingHistoryCreateWithoutUserInput = {
    price: number
    createdAt?: Date | string
    updateAt?: Date | string
    machine: WSMachineCreateNestedOneWithoutUsingHistoriesInput
    program: WSProgramCreateNestedOneWithoutUsingHistoriesInput
    usingStartAt: Date | string
    finishingAt: Date | string
  }

  export type WSUsingHistoryUncheckedCreateWithoutUserInput = {
    id?: number
    price: number
    createdAt?: Date | string
    updateAt?: Date | string
    usingStartAt: Date | string
    finishingAt: Date | string
    wSMachineId: number
    wSProgramId: number
  }

  export type WSUsingHistoryCreateOrConnectWithoutUserInput = {
    where: WSUsingHistoryWhereUniqueInput
    create: XOR<WSUsingHistoryCreateWithoutUserInput, WSUsingHistoryUncheckedCreateWithoutUserInput>
  }

  export type WSUsingHistoryCreateManyUserInputEnvelope = {
    data: Enumerable<WSUsingHistoryCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type WSTopupHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: WSTopupHistoryWhereUniqueInput
    update: XOR<WSTopupHistoryUpdateWithoutUserInput, WSTopupHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<WSTopupHistoryCreateWithoutUserInput, WSTopupHistoryUncheckedCreateWithoutUserInput>
  }

  export type WSTopupHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: WSTopupHistoryWhereUniqueInput
    data: XOR<WSTopupHistoryUpdateWithoutUserInput, WSTopupHistoryUncheckedUpdateWithoutUserInput>
  }

  export type WSTopupHistoryUpdateManyWithWhereWithoutUserInput = {
    where: WSTopupHistoryScalarWhereInput
    data: XOR<WSTopupHistoryUpdateManyMutationInput, WSTopupHistoryUncheckedUpdateManyWithoutTopupHistoriesInput>
  }

  export type WSTopupHistoryScalarWhereInput = {
    AND?: Enumerable<WSTopupHistoryScalarWhereInput>
    OR?: Enumerable<WSTopupHistoryScalarWhereInput>
    NOT?: Enumerable<WSTopupHistoryScalarWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    topup?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type WSUsingHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: WSUsingHistoryWhereUniqueInput
    update: XOR<WSUsingHistoryUpdateWithoutUserInput, WSUsingHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<WSUsingHistoryCreateWithoutUserInput, WSUsingHistoryUncheckedCreateWithoutUserInput>
  }

  export type WSUsingHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: WSUsingHistoryWhereUniqueInput
    data: XOR<WSUsingHistoryUpdateWithoutUserInput, WSUsingHistoryUncheckedUpdateWithoutUserInput>
  }

  export type WSUsingHistoryUpdateManyWithWhereWithoutUserInput = {
    where: WSUsingHistoryScalarWhereInput
    data: XOR<WSUsingHistoryUpdateManyMutationInput, WSUsingHistoryUncheckedUpdateManyWithoutUsingHistoriesInput>
  }

  export type WSUsingHistoryScalarWhereInput = {
    AND?: Enumerable<WSUsingHistoryScalarWhereInput>
    OR?: Enumerable<WSUsingHistoryScalarWhereInput>
    NOT?: Enumerable<WSUsingHistoryScalarWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    price?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
    usingStartAt?: DateTimeFilter | Date | string
    finishingAt?: DateTimeFilter | Date | string
    wSMachineId?: IntFilter | number
    wSProgramId?: IntFilter | number
  }

  export type WSUserCreateWithoutTopupHistoriesInput = {
    name: string
    tel: number
    myWallet: number
    createdAt?: Date | string
    updateAt?: Date | string
    usingHistories?: WSUsingHistoryCreateNestedManyWithoutUserInput
  }

  export type WSUserUncheckedCreateWithoutTopupHistoriesInput = {
    id?: number
    name: string
    tel: number
    myWallet: number
    createdAt?: Date | string
    updateAt?: Date | string
    usingHistories?: WSUsingHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type WSUserCreateOrConnectWithoutTopupHistoriesInput = {
    where: WSUserWhereUniqueInput
    create: XOR<WSUserCreateWithoutTopupHistoriesInput, WSUserUncheckedCreateWithoutTopupHistoriesInput>
  }

  export type WSUserUpsertWithoutTopupHistoriesInput = {
    update: XOR<WSUserUpdateWithoutTopupHistoriesInput, WSUserUncheckedUpdateWithoutTopupHistoriesInput>
    create: XOR<WSUserCreateWithoutTopupHistoriesInput, WSUserUncheckedCreateWithoutTopupHistoriesInput>
  }

  export type WSUserUpdateWithoutTopupHistoriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    tel?: IntFieldUpdateOperationsInput | number
    myWallet?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usingHistories?: WSUsingHistoryUpdateManyWithoutUserNestedInput
  }

  export type WSUserUncheckedUpdateWithoutTopupHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tel?: IntFieldUpdateOperationsInput | number
    myWallet?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usingHistories?: WSUsingHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WSUserCreateWithoutUsingHistoriesInput = {
    name: string
    tel: number
    myWallet: number
    createdAt?: Date | string
    updateAt?: Date | string
    topupHistories?: WSTopupHistoryCreateNestedManyWithoutUserInput
  }

  export type WSUserUncheckedCreateWithoutUsingHistoriesInput = {
    id?: number
    name: string
    tel: number
    myWallet: number
    createdAt?: Date | string
    updateAt?: Date | string
    topupHistories?: WSTopupHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type WSUserCreateOrConnectWithoutUsingHistoriesInput = {
    where: WSUserWhereUniqueInput
    create: XOR<WSUserCreateWithoutUsingHistoriesInput, WSUserUncheckedCreateWithoutUsingHistoriesInput>
  }

  export type WSMachineCreateWithoutUsingHistoriesInput = {
    shop: WSShopCreateNestedOneWithoutMachinesInput
    brandname: string
    size: string
    type: string
    model: string
    producedDate: string
    insuranceExpiredDate: string
    createdAt?: Date | string
    updateAt?: Date | string
    machineToPrograms?: MachineToProgramCreateNestedManyWithoutMachingInput
    maintains?: WSMaintainCreateNestedManyWithoutMachineInput
  }

  export type WSMachineUncheckedCreateWithoutUsingHistoriesInput = {
    id?: number
    shopId: number
    brandname: string
    size: string
    type: string
    model: string
    producedDate: string
    insuranceExpiredDate: string
    createdAt?: Date | string
    updateAt?: Date | string
    machineToPrograms?: MachineToProgramUncheckedCreateNestedManyWithoutMachingInput
    maintains?: WSMaintainUncheckedCreateNestedManyWithoutMachineInput
  }

  export type WSMachineCreateOrConnectWithoutUsingHistoriesInput = {
    where: WSMachineWhereUniqueInput
    create: XOR<WSMachineCreateWithoutUsingHistoriesInput, WSMachineUncheckedCreateWithoutUsingHistoriesInput>
  }

  export type WSProgramCreateWithoutUsingHistoriesInput = {
    name: string
    createdAt?: Date | string
    updateAt?: Date | string
    machineToPrograms?: MachineToProgramCreateNestedManyWithoutProgramInput
    programLists?: WSProgramDetailCreateNestedManyWithoutProgramInput
    activeProgram: WSProgramDetailCreateNestedOneWithoutProgramsInput
  }

  export type WSProgramUncheckedCreateWithoutUsingHistoriesInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updateAt?: Date | string
    machineToPrograms?: MachineToProgramUncheckedCreateNestedManyWithoutProgramInput
    programLists?: WSProgramDetailUncheckedCreateNestedManyWithoutProgramInput
    activeProgramId: number
  }

  export type WSProgramCreateOrConnectWithoutUsingHistoriesInput = {
    where: WSProgramWhereUniqueInput
    create: XOR<WSProgramCreateWithoutUsingHistoriesInput, WSProgramUncheckedCreateWithoutUsingHistoriesInput>
  }

  export type WSUserUpsertWithoutUsingHistoriesInput = {
    update: XOR<WSUserUpdateWithoutUsingHistoriesInput, WSUserUncheckedUpdateWithoutUsingHistoriesInput>
    create: XOR<WSUserCreateWithoutUsingHistoriesInput, WSUserUncheckedCreateWithoutUsingHistoriesInput>
  }

  export type WSUserUpdateWithoutUsingHistoriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    tel?: IntFieldUpdateOperationsInput | number
    myWallet?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topupHistories?: WSTopupHistoryUpdateManyWithoutUserNestedInput
  }

  export type WSUserUncheckedUpdateWithoutUsingHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tel?: IntFieldUpdateOperationsInput | number
    myWallet?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topupHistories?: WSTopupHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WSMachineUpsertWithoutUsingHistoriesInput = {
    update: XOR<WSMachineUpdateWithoutUsingHistoriesInput, WSMachineUncheckedUpdateWithoutUsingHistoriesInput>
    create: XOR<WSMachineCreateWithoutUsingHistoriesInput, WSMachineUncheckedCreateWithoutUsingHistoriesInput>
  }

  export type WSMachineUpdateWithoutUsingHistoriesInput = {
    shop?: WSShopUpdateOneRequiredWithoutMachinesNestedInput
    brandname?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    producedDate?: StringFieldUpdateOperationsInput | string
    insuranceExpiredDate?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    machineToPrograms?: MachineToProgramUpdateManyWithoutMachingNestedInput
    maintains?: WSMaintainUpdateManyWithoutMachineNestedInput
  }

  export type WSMachineUncheckedUpdateWithoutUsingHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    brandname?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    producedDate?: StringFieldUpdateOperationsInput | string
    insuranceExpiredDate?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    machineToPrograms?: MachineToProgramUncheckedUpdateManyWithoutMachingNestedInput
    maintains?: WSMaintainUncheckedUpdateManyWithoutMachineNestedInput
  }

  export type WSProgramUpsertWithoutUsingHistoriesInput = {
    update: XOR<WSProgramUpdateWithoutUsingHistoriesInput, WSProgramUncheckedUpdateWithoutUsingHistoriesInput>
    create: XOR<WSProgramCreateWithoutUsingHistoriesInput, WSProgramUncheckedCreateWithoutUsingHistoriesInput>
  }

  export type WSProgramUpdateWithoutUsingHistoriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    machineToPrograms?: MachineToProgramUpdateManyWithoutProgramNestedInput
    programLists?: WSProgramDetailUpdateManyWithoutProgramNestedInput
    activeProgram?: WSProgramDetailUpdateOneRequiredWithoutProgramsNestedInput
  }

  export type WSProgramUncheckedUpdateWithoutUsingHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    machineToPrograms?: MachineToProgramUncheckedUpdateManyWithoutProgramNestedInput
    programLists?: WSProgramDetailUncheckedUpdateManyWithoutProgramNestedInput
    activeProgramId?: IntFieldUpdateOperationsInput | number
  }

  export type WSMachineCreateWithoutShopInput = {
    brandname: string
    size: string
    type: string
    model: string
    producedDate: string
    insuranceExpiredDate: string
    createdAt?: Date | string
    updateAt?: Date | string
    machineToPrograms?: MachineToProgramCreateNestedManyWithoutMachingInput
    maintains?: WSMaintainCreateNestedManyWithoutMachineInput
    usingHistories?: WSUsingHistoryCreateNestedManyWithoutMachineInput
  }

  export type WSMachineUncheckedCreateWithoutShopInput = {
    id?: number
    brandname: string
    size: string
    type: string
    model: string
    producedDate: string
    insuranceExpiredDate: string
    createdAt?: Date | string
    updateAt?: Date | string
    machineToPrograms?: MachineToProgramUncheckedCreateNestedManyWithoutMachingInput
    maintains?: WSMaintainUncheckedCreateNestedManyWithoutMachineInput
    usingHistories?: WSUsingHistoryUncheckedCreateNestedManyWithoutMachineInput
  }

  export type WSMachineCreateOrConnectWithoutShopInput = {
    where: WSMachineWhereUniqueInput
    create: XOR<WSMachineCreateWithoutShopInput, WSMachineUncheckedCreateWithoutShopInput>
  }

  export type WSMachineCreateManyShopInputEnvelope = {
    data: Enumerable<WSMachineCreateManyShopInput>
    skipDuplicates?: boolean
  }

  export type WSMachineUpsertWithWhereUniqueWithoutShopInput = {
    where: WSMachineWhereUniqueInput
    update: XOR<WSMachineUpdateWithoutShopInput, WSMachineUncheckedUpdateWithoutShopInput>
    create: XOR<WSMachineCreateWithoutShopInput, WSMachineUncheckedCreateWithoutShopInput>
  }

  export type WSMachineUpdateWithWhereUniqueWithoutShopInput = {
    where: WSMachineWhereUniqueInput
    data: XOR<WSMachineUpdateWithoutShopInput, WSMachineUncheckedUpdateWithoutShopInput>
  }

  export type WSMachineUpdateManyWithWhereWithoutShopInput = {
    where: WSMachineScalarWhereInput
    data: XOR<WSMachineUpdateManyMutationInput, WSMachineUncheckedUpdateManyWithoutMachinesInput>
  }

  export type WSMachineScalarWhereInput = {
    AND?: Enumerable<WSMachineScalarWhereInput>
    OR?: Enumerable<WSMachineScalarWhereInput>
    NOT?: Enumerable<WSMachineScalarWhereInput>
    id?: IntFilter | number
    shopId?: IntFilter | number
    brandname?: StringFilter | string
    size?: StringFilter | string
    type?: StringFilter | string
    model?: StringFilter | string
    producedDate?: StringFilter | string
    insuranceExpiredDate?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type WSShopCreateWithoutMachinesInput = {
    branch: string
    owner: string
    tel: number
    location: string
    area: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type WSShopUncheckedCreateWithoutMachinesInput = {
    id?: number
    branch: string
    owner: string
    tel: number
    location: string
    area: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type WSShopCreateOrConnectWithoutMachinesInput = {
    where: WSShopWhereUniqueInput
    create: XOR<WSShopCreateWithoutMachinesInput, WSShopUncheckedCreateWithoutMachinesInput>
  }

  export type MachineToProgramCreateWithoutMachingInput = {
    program: WSProgramCreateNestedOneWithoutMachineToProgramsInput
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type MachineToProgramUncheckedCreateWithoutMachingInput = {
    id?: number
    programId: number
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type MachineToProgramCreateOrConnectWithoutMachingInput = {
    where: MachineToProgramWhereUniqueInput
    create: XOR<MachineToProgramCreateWithoutMachingInput, MachineToProgramUncheckedCreateWithoutMachingInput>
  }

  export type MachineToProgramCreateManyMachingInputEnvelope = {
    data: Enumerable<MachineToProgramCreateManyMachingInput>
    skipDuplicates?: boolean
  }

  export type WSMaintainCreateWithoutMachineInput = {
    checker: string
    item: string
    status: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type WSMaintainUncheckedCreateWithoutMachineInput = {
    id?: number
    checker: string
    item: string
    status: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type WSMaintainCreateOrConnectWithoutMachineInput = {
    where: WSMaintainWhereUniqueInput
    create: XOR<WSMaintainCreateWithoutMachineInput, WSMaintainUncheckedCreateWithoutMachineInput>
  }

  export type WSMaintainCreateManyMachineInputEnvelope = {
    data: Enumerable<WSMaintainCreateManyMachineInput>
    skipDuplicates?: boolean
  }

  export type WSUsingHistoryCreateWithoutMachineInput = {
    user: WSUserCreateNestedOneWithoutUsingHistoriesInput
    price: number
    createdAt?: Date | string
    updateAt?: Date | string
    program: WSProgramCreateNestedOneWithoutUsingHistoriesInput
    usingStartAt: Date | string
    finishingAt: Date | string
  }

  export type WSUsingHistoryUncheckedCreateWithoutMachineInput = {
    id?: number
    userId: number
    price: number
    createdAt?: Date | string
    updateAt?: Date | string
    usingStartAt: Date | string
    finishingAt: Date | string
    wSProgramId: number
  }

  export type WSUsingHistoryCreateOrConnectWithoutMachineInput = {
    where: WSUsingHistoryWhereUniqueInput
    create: XOR<WSUsingHistoryCreateWithoutMachineInput, WSUsingHistoryUncheckedCreateWithoutMachineInput>
  }

  export type WSUsingHistoryCreateManyMachineInputEnvelope = {
    data: Enumerable<WSUsingHistoryCreateManyMachineInput>
    skipDuplicates?: boolean
  }

  export type WSShopUpsertWithoutMachinesInput = {
    update: XOR<WSShopUpdateWithoutMachinesInput, WSShopUncheckedUpdateWithoutMachinesInput>
    create: XOR<WSShopCreateWithoutMachinesInput, WSShopUncheckedCreateWithoutMachinesInput>
  }

  export type WSShopUpdateWithoutMachinesInput = {
    branch?: StringFieldUpdateOperationsInput | string
    owner?: StringFieldUpdateOperationsInput | string
    tel?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WSShopUncheckedUpdateWithoutMachinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    branch?: StringFieldUpdateOperationsInput | string
    owner?: StringFieldUpdateOperationsInput | string
    tel?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineToProgramUpsertWithWhereUniqueWithoutMachingInput = {
    where: MachineToProgramWhereUniqueInput
    update: XOR<MachineToProgramUpdateWithoutMachingInput, MachineToProgramUncheckedUpdateWithoutMachingInput>
    create: XOR<MachineToProgramCreateWithoutMachingInput, MachineToProgramUncheckedCreateWithoutMachingInput>
  }

  export type MachineToProgramUpdateWithWhereUniqueWithoutMachingInput = {
    where: MachineToProgramWhereUniqueInput
    data: XOR<MachineToProgramUpdateWithoutMachingInput, MachineToProgramUncheckedUpdateWithoutMachingInput>
  }

  export type MachineToProgramUpdateManyWithWhereWithoutMachingInput = {
    where: MachineToProgramScalarWhereInput
    data: XOR<MachineToProgramUpdateManyMutationInput, MachineToProgramUncheckedUpdateManyWithoutMachineToProgramsInput>
  }

  export type MachineToProgramScalarWhereInput = {
    AND?: Enumerable<MachineToProgramScalarWhereInput>
    OR?: Enumerable<MachineToProgramScalarWhereInput>
    NOT?: Enumerable<MachineToProgramScalarWhereInput>
    id?: IntFilter | number
    machineId?: IntFilter | number
    programId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type WSMaintainUpsertWithWhereUniqueWithoutMachineInput = {
    where: WSMaintainWhereUniqueInput
    update: XOR<WSMaintainUpdateWithoutMachineInput, WSMaintainUncheckedUpdateWithoutMachineInput>
    create: XOR<WSMaintainCreateWithoutMachineInput, WSMaintainUncheckedCreateWithoutMachineInput>
  }

  export type WSMaintainUpdateWithWhereUniqueWithoutMachineInput = {
    where: WSMaintainWhereUniqueInput
    data: XOR<WSMaintainUpdateWithoutMachineInput, WSMaintainUncheckedUpdateWithoutMachineInput>
  }

  export type WSMaintainUpdateManyWithWhereWithoutMachineInput = {
    where: WSMaintainScalarWhereInput
    data: XOR<WSMaintainUpdateManyMutationInput, WSMaintainUncheckedUpdateManyWithoutMaintainsInput>
  }

  export type WSMaintainScalarWhereInput = {
    AND?: Enumerable<WSMaintainScalarWhereInput>
    OR?: Enumerable<WSMaintainScalarWhereInput>
    NOT?: Enumerable<WSMaintainScalarWhereInput>
    id?: IntFilter | number
    checker?: StringFilter | string
    item?: StringFilter | string
    status?: StringFilter | string
    machineId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type WSUsingHistoryUpsertWithWhereUniqueWithoutMachineInput = {
    where: WSUsingHistoryWhereUniqueInput
    update: XOR<WSUsingHistoryUpdateWithoutMachineInput, WSUsingHistoryUncheckedUpdateWithoutMachineInput>
    create: XOR<WSUsingHistoryCreateWithoutMachineInput, WSUsingHistoryUncheckedCreateWithoutMachineInput>
  }

  export type WSUsingHistoryUpdateWithWhereUniqueWithoutMachineInput = {
    where: WSUsingHistoryWhereUniqueInput
    data: XOR<WSUsingHistoryUpdateWithoutMachineInput, WSUsingHistoryUncheckedUpdateWithoutMachineInput>
  }

  export type WSUsingHistoryUpdateManyWithWhereWithoutMachineInput = {
    where: WSUsingHistoryScalarWhereInput
    data: XOR<WSUsingHistoryUpdateManyMutationInput, WSUsingHistoryUncheckedUpdateManyWithoutUsingHistoriesInput>
  }

  export type MachineToProgramCreateWithoutProgramInput = {
    maching: WSMachineCreateNestedOneWithoutMachineToProgramsInput
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type MachineToProgramUncheckedCreateWithoutProgramInput = {
    id?: number
    machineId: number
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type MachineToProgramCreateOrConnectWithoutProgramInput = {
    where: MachineToProgramWhereUniqueInput
    create: XOR<MachineToProgramCreateWithoutProgramInput, MachineToProgramUncheckedCreateWithoutProgramInput>
  }

  export type MachineToProgramCreateManyProgramInputEnvelope = {
    data: Enumerable<MachineToProgramCreateManyProgramInput>
    skipDuplicates?: boolean
  }

  export type WSProgramDetailCreateWithoutProgramInput = {
    price: number
    duration: number
    weight: number
    createdAt?: Date | string
    updateAt?: Date | string
    programs?: WSProgramCreateNestedManyWithoutActiveProgramInput
  }

  export type WSProgramDetailUncheckedCreateWithoutProgramInput = {
    id?: number
    price: number
    duration: number
    weight: number
    createdAt?: Date | string
    updateAt?: Date | string
    programs?: WSProgramUncheckedCreateNestedManyWithoutActiveProgramInput
  }

  export type WSProgramDetailCreateOrConnectWithoutProgramInput = {
    where: WSProgramDetailWhereUniqueInput
    create: XOR<WSProgramDetailCreateWithoutProgramInput, WSProgramDetailUncheckedCreateWithoutProgramInput>
  }

  export type WSProgramDetailCreateManyProgramInputEnvelope = {
    data: Enumerable<WSProgramDetailCreateManyProgramInput>
    skipDuplicates?: boolean
  }

  export type WSProgramDetailCreateWithoutProgramsInput = {
    program: WSProgramCreateNestedOneWithoutProgramListsInput
    price: number
    duration: number
    weight: number
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type WSProgramDetailUncheckedCreateWithoutProgramsInput = {
    id?: number
    programId: number
    price: number
    duration: number
    weight: number
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type WSProgramDetailCreateOrConnectWithoutProgramsInput = {
    where: WSProgramDetailWhereUniqueInput
    create: XOR<WSProgramDetailCreateWithoutProgramsInput, WSProgramDetailUncheckedCreateWithoutProgramsInput>
  }

  export type WSUsingHistoryCreateWithoutProgramInput = {
    user: WSUserCreateNestedOneWithoutUsingHistoriesInput
    price: number
    createdAt?: Date | string
    updateAt?: Date | string
    machine: WSMachineCreateNestedOneWithoutUsingHistoriesInput
    usingStartAt: Date | string
    finishingAt: Date | string
  }

  export type WSUsingHistoryUncheckedCreateWithoutProgramInput = {
    id?: number
    userId: number
    price: number
    createdAt?: Date | string
    updateAt?: Date | string
    usingStartAt: Date | string
    finishingAt: Date | string
    wSMachineId: number
  }

  export type WSUsingHistoryCreateOrConnectWithoutProgramInput = {
    where: WSUsingHistoryWhereUniqueInput
    create: XOR<WSUsingHistoryCreateWithoutProgramInput, WSUsingHistoryUncheckedCreateWithoutProgramInput>
  }

  export type WSUsingHistoryCreateManyProgramInputEnvelope = {
    data: Enumerable<WSUsingHistoryCreateManyProgramInput>
    skipDuplicates?: boolean
  }

  export type MachineToProgramUpsertWithWhereUniqueWithoutProgramInput = {
    where: MachineToProgramWhereUniqueInput
    update: XOR<MachineToProgramUpdateWithoutProgramInput, MachineToProgramUncheckedUpdateWithoutProgramInput>
    create: XOR<MachineToProgramCreateWithoutProgramInput, MachineToProgramUncheckedCreateWithoutProgramInput>
  }

  export type MachineToProgramUpdateWithWhereUniqueWithoutProgramInput = {
    where: MachineToProgramWhereUniqueInput
    data: XOR<MachineToProgramUpdateWithoutProgramInput, MachineToProgramUncheckedUpdateWithoutProgramInput>
  }

  export type MachineToProgramUpdateManyWithWhereWithoutProgramInput = {
    where: MachineToProgramScalarWhereInput
    data: XOR<MachineToProgramUpdateManyMutationInput, MachineToProgramUncheckedUpdateManyWithoutMachineToProgramsInput>
  }

  export type WSProgramDetailUpsertWithWhereUniqueWithoutProgramInput = {
    where: WSProgramDetailWhereUniqueInput
    update: XOR<WSProgramDetailUpdateWithoutProgramInput, WSProgramDetailUncheckedUpdateWithoutProgramInput>
    create: XOR<WSProgramDetailCreateWithoutProgramInput, WSProgramDetailUncheckedCreateWithoutProgramInput>
  }

  export type WSProgramDetailUpdateWithWhereUniqueWithoutProgramInput = {
    where: WSProgramDetailWhereUniqueInput
    data: XOR<WSProgramDetailUpdateWithoutProgramInput, WSProgramDetailUncheckedUpdateWithoutProgramInput>
  }

  export type WSProgramDetailUpdateManyWithWhereWithoutProgramInput = {
    where: WSProgramDetailScalarWhereInput
    data: XOR<WSProgramDetailUpdateManyMutationInput, WSProgramDetailUncheckedUpdateManyWithoutProgramListsInput>
  }

  export type WSProgramDetailScalarWhereInput = {
    AND?: Enumerable<WSProgramDetailScalarWhereInput>
    OR?: Enumerable<WSProgramDetailScalarWhereInput>
    NOT?: Enumerable<WSProgramDetailScalarWhereInput>
    id?: IntFilter | number
    programId?: IntFilter | number
    price?: IntFilter | number
    duration?: IntFilter | number
    weight?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type WSProgramDetailUpsertWithoutProgramsInput = {
    update: XOR<WSProgramDetailUpdateWithoutProgramsInput, WSProgramDetailUncheckedUpdateWithoutProgramsInput>
    create: XOR<WSProgramDetailCreateWithoutProgramsInput, WSProgramDetailUncheckedCreateWithoutProgramsInput>
  }

  export type WSProgramDetailUpdateWithoutProgramsInput = {
    program?: WSProgramUpdateOneRequiredWithoutProgramListsNestedInput
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    weight?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WSProgramDetailUncheckedUpdateWithoutProgramsInput = {
    id?: IntFieldUpdateOperationsInput | number
    programId?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    weight?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WSUsingHistoryUpsertWithWhereUniqueWithoutProgramInput = {
    where: WSUsingHistoryWhereUniqueInput
    update: XOR<WSUsingHistoryUpdateWithoutProgramInput, WSUsingHistoryUncheckedUpdateWithoutProgramInput>
    create: XOR<WSUsingHistoryCreateWithoutProgramInput, WSUsingHistoryUncheckedCreateWithoutProgramInput>
  }

  export type WSUsingHistoryUpdateWithWhereUniqueWithoutProgramInput = {
    where: WSUsingHistoryWhereUniqueInput
    data: XOR<WSUsingHistoryUpdateWithoutProgramInput, WSUsingHistoryUncheckedUpdateWithoutProgramInput>
  }

  export type WSUsingHistoryUpdateManyWithWhereWithoutProgramInput = {
    where: WSUsingHistoryScalarWhereInput
    data: XOR<WSUsingHistoryUpdateManyMutationInput, WSUsingHistoryUncheckedUpdateManyWithoutUsingHistoriesInput>
  }

  export type WSMachineCreateWithoutMachineToProgramsInput = {
    shop: WSShopCreateNestedOneWithoutMachinesInput
    brandname: string
    size: string
    type: string
    model: string
    producedDate: string
    insuranceExpiredDate: string
    createdAt?: Date | string
    updateAt?: Date | string
    maintains?: WSMaintainCreateNestedManyWithoutMachineInput
    usingHistories?: WSUsingHistoryCreateNestedManyWithoutMachineInput
  }

  export type WSMachineUncheckedCreateWithoutMachineToProgramsInput = {
    id?: number
    shopId: number
    brandname: string
    size: string
    type: string
    model: string
    producedDate: string
    insuranceExpiredDate: string
    createdAt?: Date | string
    updateAt?: Date | string
    maintains?: WSMaintainUncheckedCreateNestedManyWithoutMachineInput
    usingHistories?: WSUsingHistoryUncheckedCreateNestedManyWithoutMachineInput
  }

  export type WSMachineCreateOrConnectWithoutMachineToProgramsInput = {
    where: WSMachineWhereUniqueInput
    create: XOR<WSMachineCreateWithoutMachineToProgramsInput, WSMachineUncheckedCreateWithoutMachineToProgramsInput>
  }

  export type WSProgramCreateWithoutMachineToProgramsInput = {
    name: string
    createdAt?: Date | string
    updateAt?: Date | string
    programLists?: WSProgramDetailCreateNestedManyWithoutProgramInput
    activeProgram: WSProgramDetailCreateNestedOneWithoutProgramsInput
    usingHistories?: WSUsingHistoryCreateNestedManyWithoutProgramInput
  }

  export type WSProgramUncheckedCreateWithoutMachineToProgramsInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updateAt?: Date | string
    programLists?: WSProgramDetailUncheckedCreateNestedManyWithoutProgramInput
    usingHistories?: WSUsingHistoryUncheckedCreateNestedManyWithoutProgramInput
    activeProgramId: number
  }

  export type WSProgramCreateOrConnectWithoutMachineToProgramsInput = {
    where: WSProgramWhereUniqueInput
    create: XOR<WSProgramCreateWithoutMachineToProgramsInput, WSProgramUncheckedCreateWithoutMachineToProgramsInput>
  }

  export type WSMachineUpsertWithoutMachineToProgramsInput = {
    update: XOR<WSMachineUpdateWithoutMachineToProgramsInput, WSMachineUncheckedUpdateWithoutMachineToProgramsInput>
    create: XOR<WSMachineCreateWithoutMachineToProgramsInput, WSMachineUncheckedCreateWithoutMachineToProgramsInput>
  }

  export type WSMachineUpdateWithoutMachineToProgramsInput = {
    shop?: WSShopUpdateOneRequiredWithoutMachinesNestedInput
    brandname?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    producedDate?: StringFieldUpdateOperationsInput | string
    insuranceExpiredDate?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maintains?: WSMaintainUpdateManyWithoutMachineNestedInput
    usingHistories?: WSUsingHistoryUpdateManyWithoutMachineNestedInput
  }

  export type WSMachineUncheckedUpdateWithoutMachineToProgramsInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    brandname?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    producedDate?: StringFieldUpdateOperationsInput | string
    insuranceExpiredDate?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maintains?: WSMaintainUncheckedUpdateManyWithoutMachineNestedInput
    usingHistories?: WSUsingHistoryUncheckedUpdateManyWithoutMachineNestedInput
  }

  export type WSProgramUpsertWithoutMachineToProgramsInput = {
    update: XOR<WSProgramUpdateWithoutMachineToProgramsInput, WSProgramUncheckedUpdateWithoutMachineToProgramsInput>
    create: XOR<WSProgramCreateWithoutMachineToProgramsInput, WSProgramUncheckedCreateWithoutMachineToProgramsInput>
  }

  export type WSProgramUpdateWithoutMachineToProgramsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programLists?: WSProgramDetailUpdateManyWithoutProgramNestedInput
    activeProgram?: WSProgramDetailUpdateOneRequiredWithoutProgramsNestedInput
    usingHistories?: WSUsingHistoryUpdateManyWithoutProgramNestedInput
  }

  export type WSProgramUncheckedUpdateWithoutMachineToProgramsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programLists?: WSProgramDetailUncheckedUpdateManyWithoutProgramNestedInput
    usingHistories?: WSUsingHistoryUncheckedUpdateManyWithoutProgramNestedInput
    activeProgramId?: IntFieldUpdateOperationsInput | number
  }

  export type WSProgramCreateWithoutProgramListsInput = {
    name: string
    createdAt?: Date | string
    updateAt?: Date | string
    machineToPrograms?: MachineToProgramCreateNestedManyWithoutProgramInput
    activeProgram: WSProgramDetailCreateNestedOneWithoutProgramsInput
    usingHistories?: WSUsingHistoryCreateNestedManyWithoutProgramInput
  }

  export type WSProgramUncheckedCreateWithoutProgramListsInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updateAt?: Date | string
    machineToPrograms?: MachineToProgramUncheckedCreateNestedManyWithoutProgramInput
    usingHistories?: WSUsingHistoryUncheckedCreateNestedManyWithoutProgramInput
    activeProgramId: number
  }

  export type WSProgramCreateOrConnectWithoutProgramListsInput = {
    where: WSProgramWhereUniqueInput
    create: XOR<WSProgramCreateWithoutProgramListsInput, WSProgramUncheckedCreateWithoutProgramListsInput>
  }

  export type WSProgramCreateWithoutActiveProgramInput = {
    name: string
    createdAt?: Date | string
    updateAt?: Date | string
    machineToPrograms?: MachineToProgramCreateNestedManyWithoutProgramInput
    programLists?: WSProgramDetailCreateNestedManyWithoutProgramInput
    usingHistories?: WSUsingHistoryCreateNestedManyWithoutProgramInput
  }

  export type WSProgramUncheckedCreateWithoutActiveProgramInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updateAt?: Date | string
    machineToPrograms?: MachineToProgramUncheckedCreateNestedManyWithoutProgramInput
    programLists?: WSProgramDetailUncheckedCreateNestedManyWithoutProgramInput
    usingHistories?: WSUsingHistoryUncheckedCreateNestedManyWithoutProgramInput
  }

  export type WSProgramCreateOrConnectWithoutActiveProgramInput = {
    where: WSProgramWhereUniqueInput
    create: XOR<WSProgramCreateWithoutActiveProgramInput, WSProgramUncheckedCreateWithoutActiveProgramInput>
  }

  export type WSProgramCreateManyActiveProgramInputEnvelope = {
    data: Enumerable<WSProgramCreateManyActiveProgramInput>
    skipDuplicates?: boolean
  }

  export type WSProgramUpsertWithoutProgramListsInput = {
    update: XOR<WSProgramUpdateWithoutProgramListsInput, WSProgramUncheckedUpdateWithoutProgramListsInput>
    create: XOR<WSProgramCreateWithoutProgramListsInput, WSProgramUncheckedCreateWithoutProgramListsInput>
  }

  export type WSProgramUpdateWithoutProgramListsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    machineToPrograms?: MachineToProgramUpdateManyWithoutProgramNestedInput
    activeProgram?: WSProgramDetailUpdateOneRequiredWithoutProgramsNestedInput
    usingHistories?: WSUsingHistoryUpdateManyWithoutProgramNestedInput
  }

  export type WSProgramUncheckedUpdateWithoutProgramListsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    machineToPrograms?: MachineToProgramUncheckedUpdateManyWithoutProgramNestedInput
    usingHistories?: WSUsingHistoryUncheckedUpdateManyWithoutProgramNestedInput
    activeProgramId?: IntFieldUpdateOperationsInput | number
  }

  export type WSProgramUpsertWithWhereUniqueWithoutActiveProgramInput = {
    where: WSProgramWhereUniqueInput
    update: XOR<WSProgramUpdateWithoutActiveProgramInput, WSProgramUncheckedUpdateWithoutActiveProgramInput>
    create: XOR<WSProgramCreateWithoutActiveProgramInput, WSProgramUncheckedCreateWithoutActiveProgramInput>
  }

  export type WSProgramUpdateWithWhereUniqueWithoutActiveProgramInput = {
    where: WSProgramWhereUniqueInput
    data: XOR<WSProgramUpdateWithoutActiveProgramInput, WSProgramUncheckedUpdateWithoutActiveProgramInput>
  }

  export type WSProgramUpdateManyWithWhereWithoutActiveProgramInput = {
    where: WSProgramScalarWhereInput
    data: XOR<WSProgramUpdateManyMutationInput, WSProgramUncheckedUpdateManyWithoutProgramsInput>
  }

  export type WSProgramScalarWhereInput = {
    AND?: Enumerable<WSProgramScalarWhereInput>
    OR?: Enumerable<WSProgramScalarWhereInput>
    NOT?: Enumerable<WSProgramScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
    activeProgramId?: IntFilter | number
  }

  export type WSMachineCreateWithoutMaintainsInput = {
    shop: WSShopCreateNestedOneWithoutMachinesInput
    brandname: string
    size: string
    type: string
    model: string
    producedDate: string
    insuranceExpiredDate: string
    createdAt?: Date | string
    updateAt?: Date | string
    machineToPrograms?: MachineToProgramCreateNestedManyWithoutMachingInput
    usingHistories?: WSUsingHistoryCreateNestedManyWithoutMachineInput
  }

  export type WSMachineUncheckedCreateWithoutMaintainsInput = {
    id?: number
    shopId: number
    brandname: string
    size: string
    type: string
    model: string
    producedDate: string
    insuranceExpiredDate: string
    createdAt?: Date | string
    updateAt?: Date | string
    machineToPrograms?: MachineToProgramUncheckedCreateNestedManyWithoutMachingInput
    usingHistories?: WSUsingHistoryUncheckedCreateNestedManyWithoutMachineInput
  }

  export type WSMachineCreateOrConnectWithoutMaintainsInput = {
    where: WSMachineWhereUniqueInput
    create: XOR<WSMachineCreateWithoutMaintainsInput, WSMachineUncheckedCreateWithoutMaintainsInput>
  }

  export type WSMachineUpsertWithoutMaintainsInput = {
    update: XOR<WSMachineUpdateWithoutMaintainsInput, WSMachineUncheckedUpdateWithoutMaintainsInput>
    create: XOR<WSMachineCreateWithoutMaintainsInput, WSMachineUncheckedCreateWithoutMaintainsInput>
  }

  export type WSMachineUpdateWithoutMaintainsInput = {
    shop?: WSShopUpdateOneRequiredWithoutMachinesNestedInput
    brandname?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    producedDate?: StringFieldUpdateOperationsInput | string
    insuranceExpiredDate?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    machineToPrograms?: MachineToProgramUpdateManyWithoutMachingNestedInput
    usingHistories?: WSUsingHistoryUpdateManyWithoutMachineNestedInput
  }

  export type WSMachineUncheckedUpdateWithoutMaintainsInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopId?: IntFieldUpdateOperationsInput | number
    brandname?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    producedDate?: StringFieldUpdateOperationsInput | string
    insuranceExpiredDate?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    machineToPrograms?: MachineToProgramUncheckedUpdateManyWithoutMachingNestedInput
    usingHistories?: WSUsingHistoryUncheckedUpdateManyWithoutMachineNestedInput
  }

  export type UserToChannelCreateWithoutUserInput = {
    channel: YTChannelCreateNestedOneWithoutUserToChannelsInput
    role: YTRoleEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToChannelUncheckedCreateWithoutUserInput = {
    id?: number
    channelId: number
    role: YTRoleEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToChannelCreateOrConnectWithoutUserInput = {
    where: UserToChannelWhereUniqueInput
    create: XOR<UserToChannelCreateWithoutUserInput, UserToChannelUncheckedCreateWithoutUserInput>
  }

  export type UserToChannelCreateManyUserInputEnvelope = {
    data: Enumerable<UserToChannelCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type YTCommentCreateWithoutUserInput = {
    text: string
    commentTo?: number | null
    video: YTVideoCreateNestedOneWithoutCommentsInput
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: YTLikeCreateNestedManyWithoutCommentInput
  }

  export type YTCommentUncheckedCreateWithoutUserInput = {
    id?: number
    text: string
    commentTo?: number | null
    videoId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: YTLikeUncheckedCreateNestedManyWithoutCommentInput
  }

  export type YTCommentCreateOrConnectWithoutUserInput = {
    where: YTCommentWhereUniqueInput
    create: XOR<YTCommentCreateWithoutUserInput, YTCommentUncheckedCreateWithoutUserInput>
  }

  export type YTCommentCreateManyUserInputEnvelope = {
    data: Enumerable<YTCommentCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type YTSubscribeCreateWithoutUserInput = {
    channel: YTChannelCreateNestedOneWithoutSubscribesInput
    member: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YTSubscribeUncheckedCreateWithoutUserInput = {
    id?: number
    channelId: number
    member: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YTSubscribeCreateOrConnectWithoutUserInput = {
    where: YTSubscribeWhereUniqueInput
    create: XOR<YTSubscribeCreateWithoutUserInput, YTSubscribeUncheckedCreateWithoutUserInput>
  }

  export type YTSubscribeCreateManyUserInputEnvelope = {
    data: Enumerable<YTSubscribeCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type YTShareCreateWithoutUserInput = {
    video: YTVideoCreateNestedOneWithoutSharesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YTShareUncheckedCreateWithoutUserInput = {
    id?: number
    videoId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YTShareCreateOrConnectWithoutUserInput = {
    where: YTShareWhereUniqueInput
    create: XOR<YTShareCreateWithoutUserInput, YTShareUncheckedCreateWithoutUserInput>
  }

  export type YTShareCreateManyUserInputEnvelope = {
    data: Enumerable<YTShareCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type UserToChannelUpsertWithWhereUniqueWithoutUserInput = {
    where: UserToChannelWhereUniqueInput
    update: XOR<UserToChannelUpdateWithoutUserInput, UserToChannelUncheckedUpdateWithoutUserInput>
    create: XOR<UserToChannelCreateWithoutUserInput, UserToChannelUncheckedCreateWithoutUserInput>
  }

  export type UserToChannelUpdateWithWhereUniqueWithoutUserInput = {
    where: UserToChannelWhereUniqueInput
    data: XOR<UserToChannelUpdateWithoutUserInput, UserToChannelUncheckedUpdateWithoutUserInput>
  }

  export type UserToChannelUpdateManyWithWhereWithoutUserInput = {
    where: UserToChannelScalarWhereInput
    data: XOR<UserToChannelUpdateManyMutationInput, UserToChannelUncheckedUpdateManyWithoutUserToChannelsInput>
  }

  export type UserToChannelScalarWhereInput = {
    AND?: Enumerable<UserToChannelScalarWhereInput>
    OR?: Enumerable<UserToChannelScalarWhereInput>
    NOT?: Enumerable<UserToChannelScalarWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    channelId?: IntFilter | number
    role?: EnumYTRoleEnumFilter | YTRoleEnum
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type YTCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: YTCommentWhereUniqueInput
    update: XOR<YTCommentUpdateWithoutUserInput, YTCommentUncheckedUpdateWithoutUserInput>
    create: XOR<YTCommentCreateWithoutUserInput, YTCommentUncheckedCreateWithoutUserInput>
  }

  export type YTCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: YTCommentWhereUniqueInput
    data: XOR<YTCommentUpdateWithoutUserInput, YTCommentUncheckedUpdateWithoutUserInput>
  }

  export type YTCommentUpdateManyWithWhereWithoutUserInput = {
    where: YTCommentScalarWhereInput
    data: XOR<YTCommentUpdateManyMutationInput, YTCommentUncheckedUpdateManyWithoutCommentsInput>
  }

  export type YTCommentScalarWhereInput = {
    AND?: Enumerable<YTCommentScalarWhereInput>
    OR?: Enumerable<YTCommentScalarWhereInput>
    NOT?: Enumerable<YTCommentScalarWhereInput>
    id?: IntFilter | number
    text?: StringFilter | string
    userId?: IntFilter | number
    commentTo?: IntNullableFilter | number | null
    videoId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type YTSubscribeUpsertWithWhereUniqueWithoutUserInput = {
    where: YTSubscribeWhereUniqueInput
    update: XOR<YTSubscribeUpdateWithoutUserInput, YTSubscribeUncheckedUpdateWithoutUserInput>
    create: XOR<YTSubscribeCreateWithoutUserInput, YTSubscribeUncheckedCreateWithoutUserInput>
  }

  export type YTSubscribeUpdateWithWhereUniqueWithoutUserInput = {
    where: YTSubscribeWhereUniqueInput
    data: XOR<YTSubscribeUpdateWithoutUserInput, YTSubscribeUncheckedUpdateWithoutUserInput>
  }

  export type YTSubscribeUpdateManyWithWhereWithoutUserInput = {
    where: YTSubscribeScalarWhereInput
    data: XOR<YTSubscribeUpdateManyMutationInput, YTSubscribeUncheckedUpdateManyWithoutSubscribesInput>
  }

  export type YTSubscribeScalarWhereInput = {
    AND?: Enumerable<YTSubscribeScalarWhereInput>
    OR?: Enumerable<YTSubscribeScalarWhereInput>
    NOT?: Enumerable<YTSubscribeScalarWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    channelId?: IntFilter | number
    member?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type YTShareUpsertWithWhereUniqueWithoutUserInput = {
    where: YTShareWhereUniqueInput
    update: XOR<YTShareUpdateWithoutUserInput, YTShareUncheckedUpdateWithoutUserInput>
    create: XOR<YTShareCreateWithoutUserInput, YTShareUncheckedCreateWithoutUserInput>
  }

  export type YTShareUpdateWithWhereUniqueWithoutUserInput = {
    where: YTShareWhereUniqueInput
    data: XOR<YTShareUpdateWithoutUserInput, YTShareUncheckedUpdateWithoutUserInput>
  }

  export type YTShareUpdateManyWithWhereWithoutUserInput = {
    where: YTShareScalarWhereInput
    data: XOR<YTShareUpdateManyMutationInput, YTShareUncheckedUpdateManyWithoutSharesInput>
  }

  export type YTShareScalarWhereInput = {
    AND?: Enumerable<YTShareScalarWhereInput>
    OR?: Enumerable<YTShareScalarWhereInput>
    NOT?: Enumerable<YTShareScalarWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    videoId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type UserToChannelCreateWithoutChannelInput = {
    user: YTUserCreateNestedOneWithoutUserToChannelsInput
    role: YTRoleEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToChannelUncheckedCreateWithoutChannelInput = {
    id?: number
    userId: number
    role: YTRoleEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToChannelCreateOrConnectWithoutChannelInput = {
    where: UserToChannelWhereUniqueInput
    create: XOR<UserToChannelCreateWithoutChannelInput, UserToChannelUncheckedCreateWithoutChannelInput>
  }

  export type UserToChannelCreateManyChannelInputEnvelope = {
    data: Enumerable<UserToChannelCreateManyChannelInput>
    skipDuplicates?: boolean
  }

  export type YTVideoCreateWithoutChannelInput = {
    name: string
    file: string
    logo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: YTLikeCreateNestedManyWithoutVideoInput
    comments?: YTCommentCreateNestedManyWithoutVideoInput
    shares?: YTShareCreateNestedManyWithoutVideoInput
  }

  export type YTVideoUncheckedCreateWithoutChannelInput = {
    id?: number
    name: string
    file: string
    logo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: YTLikeUncheckedCreateNestedManyWithoutVideoInput
    comments?: YTCommentUncheckedCreateNestedManyWithoutVideoInput
    shares?: YTShareUncheckedCreateNestedManyWithoutVideoInput
  }

  export type YTVideoCreateOrConnectWithoutChannelInput = {
    where: YTVideoWhereUniqueInput
    create: XOR<YTVideoCreateWithoutChannelInput, YTVideoUncheckedCreateWithoutChannelInput>
  }

  export type YTVideoCreateManyChannelInputEnvelope = {
    data: Enumerable<YTVideoCreateManyChannelInput>
    skipDuplicates?: boolean
  }

  export type YTSubscribeCreateWithoutChannelInput = {
    user: YTUserCreateNestedOneWithoutSubscribesInput
    member: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YTSubscribeUncheckedCreateWithoutChannelInput = {
    id?: number
    userId: number
    member: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YTSubscribeCreateOrConnectWithoutChannelInput = {
    where: YTSubscribeWhereUniqueInput
    create: XOR<YTSubscribeCreateWithoutChannelInput, YTSubscribeUncheckedCreateWithoutChannelInput>
  }

  export type YTSubscribeCreateManyChannelInputEnvelope = {
    data: Enumerable<YTSubscribeCreateManyChannelInput>
    skipDuplicates?: boolean
  }

  export type UserToChannelUpsertWithWhereUniqueWithoutChannelInput = {
    where: UserToChannelWhereUniqueInput
    update: XOR<UserToChannelUpdateWithoutChannelInput, UserToChannelUncheckedUpdateWithoutChannelInput>
    create: XOR<UserToChannelCreateWithoutChannelInput, UserToChannelUncheckedCreateWithoutChannelInput>
  }

  export type UserToChannelUpdateWithWhereUniqueWithoutChannelInput = {
    where: UserToChannelWhereUniqueInput
    data: XOR<UserToChannelUpdateWithoutChannelInput, UserToChannelUncheckedUpdateWithoutChannelInput>
  }

  export type UserToChannelUpdateManyWithWhereWithoutChannelInput = {
    where: UserToChannelScalarWhereInput
    data: XOR<UserToChannelUpdateManyMutationInput, UserToChannelUncheckedUpdateManyWithoutUserToChannelsInput>
  }

  export type YTVideoUpsertWithWhereUniqueWithoutChannelInput = {
    where: YTVideoWhereUniqueInput
    update: XOR<YTVideoUpdateWithoutChannelInput, YTVideoUncheckedUpdateWithoutChannelInput>
    create: XOR<YTVideoCreateWithoutChannelInput, YTVideoUncheckedCreateWithoutChannelInput>
  }

  export type YTVideoUpdateWithWhereUniqueWithoutChannelInput = {
    where: YTVideoWhereUniqueInput
    data: XOR<YTVideoUpdateWithoutChannelInput, YTVideoUncheckedUpdateWithoutChannelInput>
  }

  export type YTVideoUpdateManyWithWhereWithoutChannelInput = {
    where: YTVideoScalarWhereInput
    data: XOR<YTVideoUpdateManyMutationInput, YTVideoUncheckedUpdateManyWithoutVideosInput>
  }

  export type YTVideoScalarWhereInput = {
    AND?: Enumerable<YTVideoScalarWhereInput>
    OR?: Enumerable<YTVideoScalarWhereInput>
    NOT?: Enumerable<YTVideoScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    file?: StringFilter | string
    logo?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    channelId?: IntFilter | number
  }

  export type YTSubscribeUpsertWithWhereUniqueWithoutChannelInput = {
    where: YTSubscribeWhereUniqueInput
    update: XOR<YTSubscribeUpdateWithoutChannelInput, YTSubscribeUncheckedUpdateWithoutChannelInput>
    create: XOR<YTSubscribeCreateWithoutChannelInput, YTSubscribeUncheckedCreateWithoutChannelInput>
  }

  export type YTSubscribeUpdateWithWhereUniqueWithoutChannelInput = {
    where: YTSubscribeWhereUniqueInput
    data: XOR<YTSubscribeUpdateWithoutChannelInput, YTSubscribeUncheckedUpdateWithoutChannelInput>
  }

  export type YTSubscribeUpdateManyWithWhereWithoutChannelInput = {
    where: YTSubscribeScalarWhereInput
    data: XOR<YTSubscribeUpdateManyMutationInput, YTSubscribeUncheckedUpdateManyWithoutSubscribesInput>
  }

  export type YTUserCreateWithoutUserToChannelsInput = {
    user: string
    email: string
    avatar: string
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: YTCommentCreateNestedManyWithoutUserInput
    subscribes?: YTSubscribeCreateNestedManyWithoutUserInput
    shares?: YTShareCreateNestedManyWithoutUserInput
  }

  export type YTUserUncheckedCreateWithoutUserToChannelsInput = {
    id?: number
    user: string
    email: string
    avatar: string
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: YTCommentUncheckedCreateNestedManyWithoutUserInput
    subscribes?: YTSubscribeUncheckedCreateNestedManyWithoutUserInput
    shares?: YTShareUncheckedCreateNestedManyWithoutUserInput
  }

  export type YTUserCreateOrConnectWithoutUserToChannelsInput = {
    where: YTUserWhereUniqueInput
    create: XOR<YTUserCreateWithoutUserToChannelsInput, YTUserUncheckedCreateWithoutUserToChannelsInput>
  }

  export type YTChannelCreateWithoutUserToChannelsInput = {
    channelName: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    videos?: YTVideoCreateNestedManyWithoutChannelInput
    subscribes?: YTSubscribeCreateNestedManyWithoutChannelInput
  }

  export type YTChannelUncheckedCreateWithoutUserToChannelsInput = {
    id?: number
    channelName: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    videos?: YTVideoUncheckedCreateNestedManyWithoutChannelInput
    subscribes?: YTSubscribeUncheckedCreateNestedManyWithoutChannelInput
  }

  export type YTChannelCreateOrConnectWithoutUserToChannelsInput = {
    where: YTChannelWhereUniqueInput
    create: XOR<YTChannelCreateWithoutUserToChannelsInput, YTChannelUncheckedCreateWithoutUserToChannelsInput>
  }

  export type YTUserUpsertWithoutUserToChannelsInput = {
    update: XOR<YTUserUpdateWithoutUserToChannelsInput, YTUserUncheckedUpdateWithoutUserToChannelsInput>
    create: XOR<YTUserCreateWithoutUserToChannelsInput, YTUserUncheckedCreateWithoutUserToChannelsInput>
  }

  export type YTUserUpdateWithoutUserToChannelsInput = {
    user?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: YTCommentUpdateManyWithoutUserNestedInput
    subscribes?: YTSubscribeUpdateManyWithoutUserNestedInput
    shares?: YTShareUpdateManyWithoutUserNestedInput
  }

  export type YTUserUncheckedUpdateWithoutUserToChannelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: YTCommentUncheckedUpdateManyWithoutUserNestedInput
    subscribes?: YTSubscribeUncheckedUpdateManyWithoutUserNestedInput
    shares?: YTShareUncheckedUpdateManyWithoutUserNestedInput
  }

  export type YTChannelUpsertWithoutUserToChannelsInput = {
    update: XOR<YTChannelUpdateWithoutUserToChannelsInput, YTChannelUncheckedUpdateWithoutUserToChannelsInput>
    create: XOR<YTChannelCreateWithoutUserToChannelsInput, YTChannelUncheckedCreateWithoutUserToChannelsInput>
  }

  export type YTChannelUpdateWithoutUserToChannelsInput = {
    channelName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    videos?: YTVideoUpdateManyWithoutChannelNestedInput
    subscribes?: YTSubscribeUpdateManyWithoutChannelNestedInput
  }

  export type YTChannelUncheckedUpdateWithoutUserToChannelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    channelName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    videos?: YTVideoUncheckedUpdateManyWithoutChannelNestedInput
    subscribes?: YTSubscribeUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type YTChannelCreateWithoutVideosInput = {
    channelName: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userToChannels?: UserToChannelCreateNestedManyWithoutChannelInput
    subscribes?: YTSubscribeCreateNestedManyWithoutChannelInput
  }

  export type YTChannelUncheckedCreateWithoutVideosInput = {
    id?: number
    channelName: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userToChannels?: UserToChannelUncheckedCreateNestedManyWithoutChannelInput
    subscribes?: YTSubscribeUncheckedCreateNestedManyWithoutChannelInput
  }

  export type YTChannelCreateOrConnectWithoutVideosInput = {
    where: YTChannelWhereUniqueInput
    create: XOR<YTChannelCreateWithoutVideosInput, YTChannelUncheckedCreateWithoutVideosInput>
  }

  export type YTLikeCreateWithoutVideoInput = {
    type: string
    comment: YTCommentCreateNestedOneWithoutLikesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YTLikeUncheckedCreateWithoutVideoInput = {
    id?: number
    type: string
    commentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YTLikeCreateOrConnectWithoutVideoInput = {
    where: YTLikeWhereUniqueInput
    create: XOR<YTLikeCreateWithoutVideoInput, YTLikeUncheckedCreateWithoutVideoInput>
  }

  export type YTLikeCreateManyVideoInputEnvelope = {
    data: Enumerable<YTLikeCreateManyVideoInput>
    skipDuplicates?: boolean
  }

  export type YTCommentCreateWithoutVideoInput = {
    text: string
    user: YTUserCreateNestedOneWithoutCommentsInput
    commentTo?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: YTLikeCreateNestedManyWithoutCommentInput
  }

  export type YTCommentUncheckedCreateWithoutVideoInput = {
    id?: number
    text: string
    userId: number
    commentTo?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: YTLikeUncheckedCreateNestedManyWithoutCommentInput
  }

  export type YTCommentCreateOrConnectWithoutVideoInput = {
    where: YTCommentWhereUniqueInput
    create: XOR<YTCommentCreateWithoutVideoInput, YTCommentUncheckedCreateWithoutVideoInput>
  }

  export type YTCommentCreateManyVideoInputEnvelope = {
    data: Enumerable<YTCommentCreateManyVideoInput>
    skipDuplicates?: boolean
  }

  export type YTShareCreateWithoutVideoInput = {
    user: YTUserCreateNestedOneWithoutSharesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YTShareUncheckedCreateWithoutVideoInput = {
    id?: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YTShareCreateOrConnectWithoutVideoInput = {
    where: YTShareWhereUniqueInput
    create: XOR<YTShareCreateWithoutVideoInput, YTShareUncheckedCreateWithoutVideoInput>
  }

  export type YTShareCreateManyVideoInputEnvelope = {
    data: Enumerable<YTShareCreateManyVideoInput>
    skipDuplicates?: boolean
  }

  export type YTChannelUpsertWithoutVideosInput = {
    update: XOR<YTChannelUpdateWithoutVideosInput, YTChannelUncheckedUpdateWithoutVideosInput>
    create: XOR<YTChannelCreateWithoutVideosInput, YTChannelUncheckedCreateWithoutVideosInput>
  }

  export type YTChannelUpdateWithoutVideosInput = {
    channelName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userToChannels?: UserToChannelUpdateManyWithoutChannelNestedInput
    subscribes?: YTSubscribeUpdateManyWithoutChannelNestedInput
  }

  export type YTChannelUncheckedUpdateWithoutVideosInput = {
    id?: IntFieldUpdateOperationsInput | number
    channelName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userToChannels?: UserToChannelUncheckedUpdateManyWithoutChannelNestedInput
    subscribes?: YTSubscribeUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type YTLikeUpsertWithWhereUniqueWithoutVideoInput = {
    where: YTLikeWhereUniqueInput
    update: XOR<YTLikeUpdateWithoutVideoInput, YTLikeUncheckedUpdateWithoutVideoInput>
    create: XOR<YTLikeCreateWithoutVideoInput, YTLikeUncheckedCreateWithoutVideoInput>
  }

  export type YTLikeUpdateWithWhereUniqueWithoutVideoInput = {
    where: YTLikeWhereUniqueInput
    data: XOR<YTLikeUpdateWithoutVideoInput, YTLikeUncheckedUpdateWithoutVideoInput>
  }

  export type YTLikeUpdateManyWithWhereWithoutVideoInput = {
    where: YTLikeScalarWhereInput
    data: XOR<YTLikeUpdateManyMutationInput, YTLikeUncheckedUpdateManyWithoutLikesInput>
  }

  export type YTLikeScalarWhereInput = {
    AND?: Enumerable<YTLikeScalarWhereInput>
    OR?: Enumerable<YTLikeScalarWhereInput>
    NOT?: Enumerable<YTLikeScalarWhereInput>
    id?: IntFilter | number
    type?: StringFilter | string
    videoId?: IntFilter | number
    commentId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type YTCommentUpsertWithWhereUniqueWithoutVideoInput = {
    where: YTCommentWhereUniqueInput
    update: XOR<YTCommentUpdateWithoutVideoInput, YTCommentUncheckedUpdateWithoutVideoInput>
    create: XOR<YTCommentCreateWithoutVideoInput, YTCommentUncheckedCreateWithoutVideoInput>
  }

  export type YTCommentUpdateWithWhereUniqueWithoutVideoInput = {
    where: YTCommentWhereUniqueInput
    data: XOR<YTCommentUpdateWithoutVideoInput, YTCommentUncheckedUpdateWithoutVideoInput>
  }

  export type YTCommentUpdateManyWithWhereWithoutVideoInput = {
    where: YTCommentScalarWhereInput
    data: XOR<YTCommentUpdateManyMutationInput, YTCommentUncheckedUpdateManyWithoutCommentsInput>
  }

  export type YTShareUpsertWithWhereUniqueWithoutVideoInput = {
    where: YTShareWhereUniqueInput
    update: XOR<YTShareUpdateWithoutVideoInput, YTShareUncheckedUpdateWithoutVideoInput>
    create: XOR<YTShareCreateWithoutVideoInput, YTShareUncheckedCreateWithoutVideoInput>
  }

  export type YTShareUpdateWithWhereUniqueWithoutVideoInput = {
    where: YTShareWhereUniqueInput
    data: XOR<YTShareUpdateWithoutVideoInput, YTShareUncheckedUpdateWithoutVideoInput>
  }

  export type YTShareUpdateManyWithWhereWithoutVideoInput = {
    where: YTShareScalarWhereInput
    data: XOR<YTShareUpdateManyMutationInput, YTShareUncheckedUpdateManyWithoutSharesInput>
  }

  export type YTVideoCreateWithoutLikesInput = {
    name: string
    file: string
    logo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    channel: YTChannelCreateNestedOneWithoutVideosInput
    comments?: YTCommentCreateNestedManyWithoutVideoInput
    shares?: YTShareCreateNestedManyWithoutVideoInput
  }

  export type YTVideoUncheckedCreateWithoutLikesInput = {
    id?: number
    name: string
    file: string
    logo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    channelId: number
    comments?: YTCommentUncheckedCreateNestedManyWithoutVideoInput
    shares?: YTShareUncheckedCreateNestedManyWithoutVideoInput
  }

  export type YTVideoCreateOrConnectWithoutLikesInput = {
    where: YTVideoWhereUniqueInput
    create: XOR<YTVideoCreateWithoutLikesInput, YTVideoUncheckedCreateWithoutLikesInput>
  }

  export type YTCommentCreateWithoutLikesInput = {
    text: string
    user: YTUserCreateNestedOneWithoutCommentsInput
    commentTo?: number | null
    video: YTVideoCreateNestedOneWithoutCommentsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YTCommentUncheckedCreateWithoutLikesInput = {
    id?: number
    text: string
    userId: number
    commentTo?: number | null
    videoId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YTCommentCreateOrConnectWithoutLikesInput = {
    where: YTCommentWhereUniqueInput
    create: XOR<YTCommentCreateWithoutLikesInput, YTCommentUncheckedCreateWithoutLikesInput>
  }

  export type YTVideoUpsertWithoutLikesInput = {
    update: XOR<YTVideoUpdateWithoutLikesInput, YTVideoUncheckedUpdateWithoutLikesInput>
    create: XOR<YTVideoCreateWithoutLikesInput, YTVideoUncheckedCreateWithoutLikesInput>
  }

  export type YTVideoUpdateWithoutLikesInput = {
    name?: StringFieldUpdateOperationsInput | string
    file?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: YTChannelUpdateOneRequiredWithoutVideosNestedInput
    comments?: YTCommentUpdateManyWithoutVideoNestedInput
    shares?: YTShareUpdateManyWithoutVideoNestedInput
  }

  export type YTVideoUncheckedUpdateWithoutLikesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    file?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channelId?: IntFieldUpdateOperationsInput | number
    comments?: YTCommentUncheckedUpdateManyWithoutVideoNestedInput
    shares?: YTShareUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type YTCommentUpsertWithoutLikesInput = {
    update: XOR<YTCommentUpdateWithoutLikesInput, YTCommentUncheckedUpdateWithoutLikesInput>
    create: XOR<YTCommentCreateWithoutLikesInput, YTCommentUncheckedCreateWithoutLikesInput>
  }

  export type YTCommentUpdateWithoutLikesInput = {
    text?: StringFieldUpdateOperationsInput | string
    user?: YTUserUpdateOneRequiredWithoutCommentsNestedInput
    commentTo?: NullableIntFieldUpdateOperationsInput | number | null
    video?: YTVideoUpdateOneRequiredWithoutCommentsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YTCommentUncheckedUpdateWithoutLikesInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    commentTo?: NullableIntFieldUpdateOperationsInput | number | null
    videoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YTUserCreateWithoutCommentsInput = {
    user: string
    email: string
    avatar: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userToChannels?: UserToChannelCreateNestedManyWithoutUserInput
    subscribes?: YTSubscribeCreateNestedManyWithoutUserInput
    shares?: YTShareCreateNestedManyWithoutUserInput
  }

  export type YTUserUncheckedCreateWithoutCommentsInput = {
    id?: number
    user: string
    email: string
    avatar: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userToChannels?: UserToChannelUncheckedCreateNestedManyWithoutUserInput
    subscribes?: YTSubscribeUncheckedCreateNestedManyWithoutUserInput
    shares?: YTShareUncheckedCreateNestedManyWithoutUserInput
  }

  export type YTUserCreateOrConnectWithoutCommentsInput = {
    where: YTUserWhereUniqueInput
    create: XOR<YTUserCreateWithoutCommentsInput, YTUserUncheckedCreateWithoutCommentsInput>
  }

  export type YTVideoCreateWithoutCommentsInput = {
    name: string
    file: string
    logo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    channel: YTChannelCreateNestedOneWithoutVideosInput
    likes?: YTLikeCreateNestedManyWithoutVideoInput
    shares?: YTShareCreateNestedManyWithoutVideoInput
  }

  export type YTVideoUncheckedCreateWithoutCommentsInput = {
    id?: number
    name: string
    file: string
    logo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    channelId: number
    likes?: YTLikeUncheckedCreateNestedManyWithoutVideoInput
    shares?: YTShareUncheckedCreateNestedManyWithoutVideoInput
  }

  export type YTVideoCreateOrConnectWithoutCommentsInput = {
    where: YTVideoWhereUniqueInput
    create: XOR<YTVideoCreateWithoutCommentsInput, YTVideoUncheckedCreateWithoutCommentsInput>
  }

  export type YTLikeCreateWithoutCommentInput = {
    type: string
    video: YTVideoCreateNestedOneWithoutLikesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YTLikeUncheckedCreateWithoutCommentInput = {
    id?: number
    type: string
    videoId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YTLikeCreateOrConnectWithoutCommentInput = {
    where: YTLikeWhereUniqueInput
    create: XOR<YTLikeCreateWithoutCommentInput, YTLikeUncheckedCreateWithoutCommentInput>
  }

  export type YTLikeCreateManyCommentInputEnvelope = {
    data: Enumerable<YTLikeCreateManyCommentInput>
    skipDuplicates?: boolean
  }

  export type YTUserUpsertWithoutCommentsInput = {
    update: XOR<YTUserUpdateWithoutCommentsInput, YTUserUncheckedUpdateWithoutCommentsInput>
    create: XOR<YTUserCreateWithoutCommentsInput, YTUserUncheckedCreateWithoutCommentsInput>
  }

  export type YTUserUpdateWithoutCommentsInput = {
    user?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userToChannels?: UserToChannelUpdateManyWithoutUserNestedInput
    subscribes?: YTSubscribeUpdateManyWithoutUserNestedInput
    shares?: YTShareUpdateManyWithoutUserNestedInput
  }

  export type YTUserUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userToChannels?: UserToChannelUncheckedUpdateManyWithoutUserNestedInput
    subscribes?: YTSubscribeUncheckedUpdateManyWithoutUserNestedInput
    shares?: YTShareUncheckedUpdateManyWithoutUserNestedInput
  }

  export type YTVideoUpsertWithoutCommentsInput = {
    update: XOR<YTVideoUpdateWithoutCommentsInput, YTVideoUncheckedUpdateWithoutCommentsInput>
    create: XOR<YTVideoCreateWithoutCommentsInput, YTVideoUncheckedCreateWithoutCommentsInput>
  }

  export type YTVideoUpdateWithoutCommentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    file?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: YTChannelUpdateOneRequiredWithoutVideosNestedInput
    likes?: YTLikeUpdateManyWithoutVideoNestedInput
    shares?: YTShareUpdateManyWithoutVideoNestedInput
  }

  export type YTVideoUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    file?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channelId?: IntFieldUpdateOperationsInput | number
    likes?: YTLikeUncheckedUpdateManyWithoutVideoNestedInput
    shares?: YTShareUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type YTLikeUpsertWithWhereUniqueWithoutCommentInput = {
    where: YTLikeWhereUniqueInput
    update: XOR<YTLikeUpdateWithoutCommentInput, YTLikeUncheckedUpdateWithoutCommentInput>
    create: XOR<YTLikeCreateWithoutCommentInput, YTLikeUncheckedCreateWithoutCommentInput>
  }

  export type YTLikeUpdateWithWhereUniqueWithoutCommentInput = {
    where: YTLikeWhereUniqueInput
    data: XOR<YTLikeUpdateWithoutCommentInput, YTLikeUncheckedUpdateWithoutCommentInput>
  }

  export type YTLikeUpdateManyWithWhereWithoutCommentInput = {
    where: YTLikeScalarWhereInput
    data: XOR<YTLikeUpdateManyMutationInput, YTLikeUncheckedUpdateManyWithoutLikesInput>
  }

  export type YTUserCreateWithoutSubscribesInput = {
    user: string
    email: string
    avatar: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userToChannels?: UserToChannelCreateNestedManyWithoutUserInput
    comments?: YTCommentCreateNestedManyWithoutUserInput
    shares?: YTShareCreateNestedManyWithoutUserInput
  }

  export type YTUserUncheckedCreateWithoutSubscribesInput = {
    id?: number
    user: string
    email: string
    avatar: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userToChannels?: UserToChannelUncheckedCreateNestedManyWithoutUserInput
    comments?: YTCommentUncheckedCreateNestedManyWithoutUserInput
    shares?: YTShareUncheckedCreateNestedManyWithoutUserInput
  }

  export type YTUserCreateOrConnectWithoutSubscribesInput = {
    where: YTUserWhereUniqueInput
    create: XOR<YTUserCreateWithoutSubscribesInput, YTUserUncheckedCreateWithoutSubscribesInput>
  }

  export type YTChannelCreateWithoutSubscribesInput = {
    channelName: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userToChannels?: UserToChannelCreateNestedManyWithoutChannelInput
    videos?: YTVideoCreateNestedManyWithoutChannelInput
  }

  export type YTChannelUncheckedCreateWithoutSubscribesInput = {
    id?: number
    channelName: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userToChannels?: UserToChannelUncheckedCreateNestedManyWithoutChannelInput
    videos?: YTVideoUncheckedCreateNestedManyWithoutChannelInput
  }

  export type YTChannelCreateOrConnectWithoutSubscribesInput = {
    where: YTChannelWhereUniqueInput
    create: XOR<YTChannelCreateWithoutSubscribesInput, YTChannelUncheckedCreateWithoutSubscribesInput>
  }

  export type YTUserUpsertWithoutSubscribesInput = {
    update: XOR<YTUserUpdateWithoutSubscribesInput, YTUserUncheckedUpdateWithoutSubscribesInput>
    create: XOR<YTUserCreateWithoutSubscribesInput, YTUserUncheckedCreateWithoutSubscribesInput>
  }

  export type YTUserUpdateWithoutSubscribesInput = {
    user?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userToChannels?: UserToChannelUpdateManyWithoutUserNestedInput
    comments?: YTCommentUpdateManyWithoutUserNestedInput
    shares?: YTShareUpdateManyWithoutUserNestedInput
  }

  export type YTUserUncheckedUpdateWithoutSubscribesInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userToChannels?: UserToChannelUncheckedUpdateManyWithoutUserNestedInput
    comments?: YTCommentUncheckedUpdateManyWithoutUserNestedInput
    shares?: YTShareUncheckedUpdateManyWithoutUserNestedInput
  }

  export type YTChannelUpsertWithoutSubscribesInput = {
    update: XOR<YTChannelUpdateWithoutSubscribesInput, YTChannelUncheckedUpdateWithoutSubscribesInput>
    create: XOR<YTChannelCreateWithoutSubscribesInput, YTChannelUncheckedCreateWithoutSubscribesInput>
  }

  export type YTChannelUpdateWithoutSubscribesInput = {
    channelName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userToChannels?: UserToChannelUpdateManyWithoutChannelNestedInput
    videos?: YTVideoUpdateManyWithoutChannelNestedInput
  }

  export type YTChannelUncheckedUpdateWithoutSubscribesInput = {
    id?: IntFieldUpdateOperationsInput | number
    channelName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userToChannels?: UserToChannelUncheckedUpdateManyWithoutChannelNestedInput
    videos?: YTVideoUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type YTUserCreateWithoutSharesInput = {
    user: string
    email: string
    avatar: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userToChannels?: UserToChannelCreateNestedManyWithoutUserInput
    comments?: YTCommentCreateNestedManyWithoutUserInput
    subscribes?: YTSubscribeCreateNestedManyWithoutUserInput
  }

  export type YTUserUncheckedCreateWithoutSharesInput = {
    id?: number
    user: string
    email: string
    avatar: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userToChannels?: UserToChannelUncheckedCreateNestedManyWithoutUserInput
    comments?: YTCommentUncheckedCreateNestedManyWithoutUserInput
    subscribes?: YTSubscribeUncheckedCreateNestedManyWithoutUserInput
  }

  export type YTUserCreateOrConnectWithoutSharesInput = {
    where: YTUserWhereUniqueInput
    create: XOR<YTUserCreateWithoutSharesInput, YTUserUncheckedCreateWithoutSharesInput>
  }

  export type YTVideoCreateWithoutSharesInput = {
    name: string
    file: string
    logo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    channel: YTChannelCreateNestedOneWithoutVideosInput
    likes?: YTLikeCreateNestedManyWithoutVideoInput
    comments?: YTCommentCreateNestedManyWithoutVideoInput
  }

  export type YTVideoUncheckedCreateWithoutSharesInput = {
    id?: number
    name: string
    file: string
    logo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    channelId: number
    likes?: YTLikeUncheckedCreateNestedManyWithoutVideoInput
    comments?: YTCommentUncheckedCreateNestedManyWithoutVideoInput
  }

  export type YTVideoCreateOrConnectWithoutSharesInput = {
    where: YTVideoWhereUniqueInput
    create: XOR<YTVideoCreateWithoutSharesInput, YTVideoUncheckedCreateWithoutSharesInput>
  }

  export type YTUserUpsertWithoutSharesInput = {
    update: XOR<YTUserUpdateWithoutSharesInput, YTUserUncheckedUpdateWithoutSharesInput>
    create: XOR<YTUserCreateWithoutSharesInput, YTUserUncheckedCreateWithoutSharesInput>
  }

  export type YTUserUpdateWithoutSharesInput = {
    user?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userToChannels?: UserToChannelUpdateManyWithoutUserNestedInput
    comments?: YTCommentUpdateManyWithoutUserNestedInput
    subscribes?: YTSubscribeUpdateManyWithoutUserNestedInput
  }

  export type YTUserUncheckedUpdateWithoutSharesInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userToChannels?: UserToChannelUncheckedUpdateManyWithoutUserNestedInput
    comments?: YTCommentUncheckedUpdateManyWithoutUserNestedInput
    subscribes?: YTSubscribeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type YTVideoUpsertWithoutSharesInput = {
    update: XOR<YTVideoUpdateWithoutSharesInput, YTVideoUncheckedUpdateWithoutSharesInput>
    create: XOR<YTVideoCreateWithoutSharesInput, YTVideoUncheckedCreateWithoutSharesInput>
  }

  export type YTVideoUpdateWithoutSharesInput = {
    name?: StringFieldUpdateOperationsInput | string
    file?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: YTChannelUpdateOneRequiredWithoutVideosNestedInput
    likes?: YTLikeUpdateManyWithoutVideoNestedInput
    comments?: YTCommentUpdateManyWithoutVideoNestedInput
  }

  export type YTVideoUncheckedUpdateWithoutSharesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    file?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channelId?: IntFieldUpdateOperationsInput | number
    likes?: YTLikeUncheckedUpdateManyWithoutVideoNestedInput
    comments?: YTCommentUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type BKRequestCreateManyUserInput = {
    id?: number
    copyId: number
    fromUniversityId: number
    toUniversityId: number
    requestDate: Date | string
    status: RequestStatusEnum
    planRecievedDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BKBorrowingHistoryCreateManyUserInput = {
    id?: number
    copyId: number
    fromUniversityId: number
    borrowDate: Date | string
    returnDate: Date | string
    actualReturnDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BKCopyCreateManyUserInput = {
    id?: number
    status: CopyStatusEnum
    titleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BKRequestUpdateWithoutUserInput = {
    copy?: BKCopyUpdateOneRequiredWithoutRequestsNestedInput
    from?: BKUniversityUpdateOneRequiredWithoutFromRequestNestedInput
    to?: BKUniversityUpdateOneRequiredWithoutToRequestNestedInput
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRequestStatusEnumFieldUpdateOperationsInput | RequestStatusEnum
    planRecievedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BKRequestUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    copyId?: IntFieldUpdateOperationsInput | number
    fromUniversityId?: IntFieldUpdateOperationsInput | number
    toUniversityId?: IntFieldUpdateOperationsInput | number
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRequestStatusEnumFieldUpdateOperationsInput | RequestStatusEnum
    planRecievedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BKRequestUncheckedUpdateManyWithoutRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    copyId?: IntFieldUpdateOperationsInput | number
    fromUniversityId?: IntFieldUpdateOperationsInput | number
    toUniversityId?: IntFieldUpdateOperationsInput | number
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRequestStatusEnumFieldUpdateOperationsInput | RequestStatusEnum
    planRecievedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BKBorrowingHistoryUpdateWithoutUserInput = {
    copy?: BKCopyUpdateOneRequiredWithoutBKBorrowingHistoryNestedInput
    from?: BKUniversityUpdateOneRequiredWithoutBKBorrowingHistoryNestedInput
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualReturnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BKBorrowingHistoryUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    copyId?: IntFieldUpdateOperationsInput | number
    fromUniversityId?: IntFieldUpdateOperationsInput | number
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualReturnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BKBorrowingHistoryUncheckedUpdateManyWithoutBKBorrowingHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    copyId?: IntFieldUpdateOperationsInput | number
    fromUniversityId?: IntFieldUpdateOperationsInput | number
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualReturnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BKCopyUpdateWithoutUserInput = {
    status?: EnumCopyStatusEnumFieldUpdateOperationsInput | CopyStatusEnum
    title?: BKTitleUpdateOneRequiredWithoutCopiesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requests?: BKRequestUpdateManyWithoutCopyNestedInput
    BKBorrowingHistory?: BKBorrowingHistoryUpdateManyWithoutCopyNestedInput
  }

  export type BKCopyUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumCopyStatusEnumFieldUpdateOperationsInput | CopyStatusEnum
    titleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requests?: BKRequestUncheckedUpdateManyWithoutCopyNestedInput
    BKBorrowingHistory?: BKBorrowingHistoryUncheckedUpdateManyWithoutCopyNestedInput
  }

  export type BKCopyUncheckedUpdateManyWithoutBKCopyInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumCopyStatusEnumFieldUpdateOperationsInput | CopyStatusEnum
    titleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BKRequestCreateManyCopyInput = {
    id?: number
    reserveUserId: number
    fromUniversityId: number
    toUniversityId: number
    requestDate: Date | string
    status: RequestStatusEnum
    planRecievedDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BKBorrowingHistoryCreateManyCopyInput = {
    id?: number
    reserveUserId: number
    fromUniversityId: number
    borrowDate: Date | string
    returnDate: Date | string
    actualReturnDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BKRequestUpdateWithoutCopyInput = {
    user?: BKReserveUserUpdateOneRequiredWithoutRequestsNestedInput
    from?: BKUniversityUpdateOneRequiredWithoutFromRequestNestedInput
    to?: BKUniversityUpdateOneRequiredWithoutToRequestNestedInput
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRequestStatusEnumFieldUpdateOperationsInput | RequestStatusEnum
    planRecievedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BKRequestUncheckedUpdateWithoutCopyInput = {
    id?: IntFieldUpdateOperationsInput | number
    reserveUserId?: IntFieldUpdateOperationsInput | number
    fromUniversityId?: IntFieldUpdateOperationsInput | number
    toUniversityId?: IntFieldUpdateOperationsInput | number
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRequestStatusEnumFieldUpdateOperationsInput | RequestStatusEnum
    planRecievedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BKBorrowingHistoryUpdateWithoutCopyInput = {
    user?: BKReserveUserUpdateOneRequiredWithoutBKBorrowingHistoryNestedInput
    from?: BKUniversityUpdateOneRequiredWithoutBKBorrowingHistoryNestedInput
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualReturnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BKBorrowingHistoryUncheckedUpdateWithoutCopyInput = {
    id?: IntFieldUpdateOperationsInput | number
    reserveUserId?: IntFieldUpdateOperationsInput | number
    fromUniversityId?: IntFieldUpdateOperationsInput | number
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualReturnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UniversityToTitleCreateManyUniversityInput = {
    id?: number
    titleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BKReserveUserCreateManyUniversityInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BKRequestCreateManyFromInput = {
    id?: number
    reserveUserId: number
    copyId: number
    toUniversityId: number
    requestDate: Date | string
    status: RequestStatusEnum
    planRecievedDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BKRequestCreateManyToInput = {
    id?: number
    reserveUserId: number
    copyId: number
    fromUniversityId: number
    requestDate: Date | string
    status: RequestStatusEnum
    planRecievedDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BKBorrowingHistoryCreateManyFromInput = {
    id?: number
    reserveUserId: number
    copyId: number
    borrowDate: Date | string
    returnDate: Date | string
    actualReturnDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UniversityToTitleUpdateWithoutUniversityInput = {
    title?: BKTitleUpdateOneRequiredWithoutUniversityToTitlesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UniversityToTitleUncheckedUpdateWithoutUniversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    titleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UniversityToTitleUncheckedUpdateManyWithoutUniversityToTitlesInput = {
    id?: IntFieldUpdateOperationsInput | number
    titleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BKReserveUserUpdateWithoutUniversityInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requests?: BKRequestUpdateManyWithoutUserNestedInput
    BKBorrowingHistory?: BKBorrowingHistoryUpdateManyWithoutUserNestedInput
    BKCopy?: BKCopyUpdateManyWithoutUserNestedInput
  }

  export type BKReserveUserUncheckedUpdateWithoutUniversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requests?: BKRequestUncheckedUpdateManyWithoutUserNestedInput
    BKBorrowingHistory?: BKBorrowingHistoryUncheckedUpdateManyWithoutUserNestedInput
    BKCopy?: BKCopyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BKReserveUserUncheckedUpdateManyWithoutReserveUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BKRequestUpdateWithoutFromInput = {
    user?: BKReserveUserUpdateOneRequiredWithoutRequestsNestedInput
    copy?: BKCopyUpdateOneRequiredWithoutRequestsNestedInput
    to?: BKUniversityUpdateOneRequiredWithoutToRequestNestedInput
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRequestStatusEnumFieldUpdateOperationsInput | RequestStatusEnum
    planRecievedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BKRequestUncheckedUpdateWithoutFromInput = {
    id?: IntFieldUpdateOperationsInput | number
    reserveUserId?: IntFieldUpdateOperationsInput | number
    copyId?: IntFieldUpdateOperationsInput | number
    toUniversityId?: IntFieldUpdateOperationsInput | number
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRequestStatusEnumFieldUpdateOperationsInput | RequestStatusEnum
    planRecievedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BKRequestUncheckedUpdateManyWithoutFromRequestInput = {
    id?: IntFieldUpdateOperationsInput | number
    reserveUserId?: IntFieldUpdateOperationsInput | number
    copyId?: IntFieldUpdateOperationsInput | number
    toUniversityId?: IntFieldUpdateOperationsInput | number
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRequestStatusEnumFieldUpdateOperationsInput | RequestStatusEnum
    planRecievedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BKRequestUpdateWithoutToInput = {
    user?: BKReserveUserUpdateOneRequiredWithoutRequestsNestedInput
    copy?: BKCopyUpdateOneRequiredWithoutRequestsNestedInput
    from?: BKUniversityUpdateOneRequiredWithoutFromRequestNestedInput
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRequestStatusEnumFieldUpdateOperationsInput | RequestStatusEnum
    planRecievedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BKRequestUncheckedUpdateWithoutToInput = {
    id?: IntFieldUpdateOperationsInput | number
    reserveUserId?: IntFieldUpdateOperationsInput | number
    copyId?: IntFieldUpdateOperationsInput | number
    fromUniversityId?: IntFieldUpdateOperationsInput | number
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRequestStatusEnumFieldUpdateOperationsInput | RequestStatusEnum
    planRecievedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BKRequestUncheckedUpdateManyWithoutToRequestInput = {
    id?: IntFieldUpdateOperationsInput | number
    reserveUserId?: IntFieldUpdateOperationsInput | number
    copyId?: IntFieldUpdateOperationsInput | number
    fromUniversityId?: IntFieldUpdateOperationsInput | number
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRequestStatusEnumFieldUpdateOperationsInput | RequestStatusEnum
    planRecievedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BKBorrowingHistoryUpdateWithoutFromInput = {
    user?: BKReserveUserUpdateOneRequiredWithoutBKBorrowingHistoryNestedInput
    copy?: BKCopyUpdateOneRequiredWithoutBKBorrowingHistoryNestedInput
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualReturnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BKBorrowingHistoryUncheckedUpdateWithoutFromInput = {
    id?: IntFieldUpdateOperationsInput | number
    reserveUserId?: IntFieldUpdateOperationsInput | number
    copyId?: IntFieldUpdateOperationsInput | number
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualReturnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TitleToCategoryCreateManyTitleInput = {
    id?: number
    categoryId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TitleToAuthorCreateManyTitleInput = {
    id?: number
    authorId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UniversityToTitleCreateManyTitleInput = {
    id?: number
    universityId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BKCopyCreateManyTitleInput = {
    id?: number
    status: CopyStatusEnum
    reserveUserId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TitleToCategoryUpdateWithoutTitleInput = {
    category?: BKCategoryUpdateOneRequiredWithoutTitleToCategoriesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TitleToCategoryUncheckedUpdateWithoutTitleInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TitleToCategoryUncheckedUpdateManyWithoutTitleToCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TitleToAuthorUpdateWithoutTitleInput = {
    author?: BKAuthorUpdateOneRequiredWithoutTitleToAuthorsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TitleToAuthorUncheckedUpdateWithoutTitleInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TitleToAuthorUncheckedUpdateManyWithoutTitleToAuthorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UniversityToTitleUpdateWithoutTitleInput = {
    university?: BKUniversityUpdateOneRequiredWithoutUniversityToTitlesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UniversityToTitleUncheckedUpdateWithoutTitleInput = {
    id?: IntFieldUpdateOperationsInput | number
    universityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BKCopyUpdateWithoutTitleInput = {
    status?: EnumCopyStatusEnumFieldUpdateOperationsInput | CopyStatusEnum
    user?: BKReserveUserUpdateOneWithoutBKCopyNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requests?: BKRequestUpdateManyWithoutCopyNestedInput
    BKBorrowingHistory?: BKBorrowingHistoryUpdateManyWithoutCopyNestedInput
  }

  export type BKCopyUncheckedUpdateWithoutTitleInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumCopyStatusEnumFieldUpdateOperationsInput | CopyStatusEnum
    reserveUserId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requests?: BKRequestUncheckedUpdateManyWithoutCopyNestedInput
    BKBorrowingHistory?: BKBorrowingHistoryUncheckedUpdateManyWithoutCopyNestedInput
  }

  export type BKCopyUncheckedUpdateManyWithoutCopiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumCopyStatusEnumFieldUpdateOperationsInput | CopyStatusEnum
    reserveUserId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TitleToCategoryCreateManyCategoryInput = {
    id?: number
    titleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TitleToCategoryUpdateWithoutCategoryInput = {
    title?: BKTitleUpdateOneRequiredWithoutTitleToCategoriesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TitleToCategoryUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    titleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TitleToAuthorCreateManyAuthorInput = {
    id?: number
    titleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TitleToAuthorUpdateWithoutAuthorInput = {
    title?: BKTitleUpdateOneRequiredWithoutTitleToAuthorsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TitleToAuthorUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    titleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbPostCreateManyUserInput = {
    id?: number
    caption: string
    createdAt?: Date | string
    updatedAt?: Date | string
    wallId: number
  }

  export type FbfriendCreateManyAcceptFriendInput = {
    id?: number
    requestId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbfriendCreateManyRequestFriendInput = {
    id?: number
    acceptId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbLikeCreateManyUserInput = {
    id?: number
    postId: number
    commentId: number
    shareId: number
    likeType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbMessengerCreateManyFromInput = {
    id?: number
    toUserId: number
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbMessengerCreateManyToInput = {
    id?: number
    fromuserId: number
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbShareCreateManyUserInput = {
    id?: number
    postId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbCommentCreateManyUserInput = {
    id?: number
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupToUserCreateManyUserInput = {
    id?: number
    groupId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbPostUpdateWithoutUserInput = {
    caption?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postImages?: FbPostImageUpdateManyWithoutPostNestedInput
    postVideoes?: FbPostVideoUpdateManyWithoutPostNestedInput
    postOnHashtags?: FbPostOnHashtagUpdateManyWithoutPostNestedInput
    shares?: FbShareUpdateManyWithoutPostNestedInput
    likes?: FbLikeUpdateManyWithoutPostNestedInput
    wall?: FbWallUpdateOneRequiredWithoutPostsNestedInput
  }

  export type FbPostUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    caption?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postImages?: FbPostImageUncheckedUpdateManyWithoutPostNestedInput
    postVideoes?: FbPostVideoUncheckedUpdateManyWithoutPostNestedInput
    postOnHashtags?: FbPostOnHashtagUncheckedUpdateManyWithoutPostNestedInput
    shares?: FbShareUncheckedUpdateManyWithoutPostNestedInput
    likes?: FbLikeUncheckedUpdateManyWithoutPostNestedInput
    wallId?: IntFieldUpdateOperationsInput | number
  }

  export type FbPostUncheckedUpdateManyWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    caption?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wallId?: IntFieldUpdateOperationsInput | number
  }

  export type FbfriendUpdateWithoutAcceptFriendInput = {
    requestFriend?: FbUserUpdateOneRequiredWithoutRequestFbFriendsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbfriendUncheckedUpdateWithoutAcceptFriendInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbfriendUncheckedUpdateManyWithoutAcceptFbFriendsInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbfriendUpdateWithoutRequestFriendInput = {
    acceptFriend?: FbUserUpdateOneRequiredWithoutAcceptFbFriendsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbfriendUncheckedUpdateWithoutRequestFriendInput = {
    id?: IntFieldUpdateOperationsInput | number
    acceptId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbfriendUncheckedUpdateManyWithoutRequestFbFriendsInput = {
    id?: IntFieldUpdateOperationsInput | number
    acceptId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbLikeUpdateWithoutUserInput = {
    post?: FbPostUpdateOneRequiredWithoutLikesNestedInput
    comment?: FbCommentUpdateOneRequiredWithoutLikesNestedInput
    share?: FbShareUpdateOneRequiredWithoutLikesNestedInput
    likeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbLikeUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    shareId?: IntFieldUpdateOperationsInput | number
    likeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbLikeUncheckedUpdateManyWithoutLikesInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    shareId?: IntFieldUpdateOperationsInput | number
    likeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbMessengerUpdateWithoutFromInput = {
    to?: FbUserUpdateOneRequiredWithoutToMessengersNestedInput
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbMessengerUncheckedUpdateWithoutFromInput = {
    id?: IntFieldUpdateOperationsInput | number
    toUserId?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbMessengerUncheckedUpdateManyWithoutFromMessengersInput = {
    id?: IntFieldUpdateOperationsInput | number
    toUserId?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbMessengerUpdateWithoutToInput = {
    from?: FbUserUpdateOneRequiredWithoutFromMessengersNestedInput
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbMessengerUncheckedUpdateWithoutToInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromuserId?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbMessengerUncheckedUpdateManyWithoutToMessengersInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromuserId?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbShareUpdateWithoutUserInput = {
    post?: FbPostUpdateOneRequiredWithoutSharesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: FbLikeUpdateManyWithoutShareNestedInput
    destinationUsers?: FbDestinationUserUpdateManyWithoutShareNestedInput
  }

  export type FbShareUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: FbLikeUncheckedUpdateManyWithoutShareNestedInput
    destinationUsers?: FbDestinationUserUncheckedUpdateManyWithoutShareNestedInput
  }

  export type FbShareUncheckedUpdateManyWithoutSharesInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbCommentUpdateWithoutUserInput = {
    text?: StringFieldUpdateOperationsInput | string
    likes?: FbLikeUpdateManyWithoutCommentNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbCommentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    likes?: FbLikeUncheckedUpdateManyWithoutCommentNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbCommentUncheckedUpdateManyWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupToUserUpdateWithoutUserInput = {
    group?: FbGroupUpdateOneRequiredWithoutGroupToUsersNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupToUserUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupToUserUncheckedUpdateManyWithoutGroupToUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbPostImageCreateManyPostInput = {
    id?: number
    image: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbPostVideoCreateManyPostInput = {
    id?: number
    video: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbPostOnHashtagCreateManyPostInput = {
    id?: number
    hashtagId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbShareCreateManyPostInput = {
    id?: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbLikeCreateManyPostInput = {
    id?: number
    userId: number
    commentId: number
    shareId: number
    likeType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbPostImageUpdateWithoutPostInput = {
    image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbPostImageUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbPostImageUncheckedUpdateManyWithoutPostImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbPostVideoUpdateWithoutPostInput = {
    video?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbPostVideoUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    video?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbPostVideoUncheckedUpdateManyWithoutPostVideoesInput = {
    id?: IntFieldUpdateOperationsInput | number
    video?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbPostOnHashtagUpdateWithoutPostInput = {
    hashtag?: FbHashtagUpdateOneRequiredWithoutPostOnHashtagsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbPostOnHashtagUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    hashtagId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbPostOnHashtagUncheckedUpdateManyWithoutPostOnHashtagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    hashtagId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbShareUpdateWithoutPostInput = {
    user?: FbUserUpdateOneRequiredWithoutSharesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: FbLikeUpdateManyWithoutShareNestedInput
    destinationUsers?: FbDestinationUserUpdateManyWithoutShareNestedInput
  }

  export type FbShareUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: FbLikeUncheckedUpdateManyWithoutShareNestedInput
    destinationUsers?: FbDestinationUserUncheckedUpdateManyWithoutShareNestedInput
  }

  export type FbLikeUpdateWithoutPostInput = {
    user?: FbUserUpdateOneRequiredWithoutLikesNestedInput
    comment?: FbCommentUpdateOneRequiredWithoutLikesNestedInput
    share?: FbShareUpdateOneRequiredWithoutLikesNestedInput
    likeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbLikeUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    shareId?: IntFieldUpdateOperationsInput | number
    likeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbPostOnHashtagCreateManyHashtagInput = {
    id?: number
    postId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbPostOnHashtagUpdateWithoutHashtagInput = {
    post?: FbPostUpdateOneRequiredWithoutPostOnHashtagsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbPostOnHashtagUncheckedUpdateWithoutHashtagInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbLikeCreateManyShareInput = {
    id?: number
    userId: number
    postId: number
    commentId: number
    likeType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbDestinationUserCreateManyShareInput = {
    id?: number
    fbWallId: number
    groupId: number
  }

  export type FbLikeUpdateWithoutShareInput = {
    user?: FbUserUpdateOneRequiredWithoutLikesNestedInput
    post?: FbPostUpdateOneRequiredWithoutLikesNestedInput
    comment?: FbCommentUpdateOneRequiredWithoutLikesNestedInput
    likeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbLikeUncheckedUpdateWithoutShareInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    likeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbDestinationUserUpdateWithoutShareInput = {
    wall?: FbWallUpdateOneRequiredWithoutDestinationUsersNestedInput
    group?: FbGroupUpdateOneRequiredWithoutDestinationUsersNestedInput
  }

  export type FbDestinationUserUncheckedUpdateWithoutShareInput = {
    id?: IntFieldUpdateOperationsInput | number
    fbWallId?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
  }

  export type FbDestinationUserUncheckedUpdateManyWithoutDestinationUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    fbWallId?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
  }

  export type FbLikeCreateManyCommentInput = {
    id?: number
    userId: number
    postId: number
    shareId: number
    likeType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbLikeUpdateWithoutCommentInput = {
    user?: FbUserUpdateOneRequiredWithoutLikesNestedInput
    post?: FbPostUpdateOneRequiredWithoutLikesNestedInput
    share?: FbShareUpdateOneRequiredWithoutLikesNestedInput
    likeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbLikeUncheckedUpdateWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    shareId?: IntFieldUpdateOperationsInput | number
    likeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupToUserCreateManyGroupInput = {
    id?: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbDestinationUserCreateManyGroupInput = {
    id?: number
    fbWallId: number
    shareId: number
  }

  export type GroupToUserUpdateWithoutGroupInput = {
    user?: FbUserUpdateOneRequiredWithoutGroupToUsersNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupToUserUncheckedUpdateWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FbDestinationUserUpdateWithoutGroupInput = {
    wall?: FbWallUpdateOneRequiredWithoutDestinationUsersNestedInput
    share?: FbShareUpdateOneRequiredWithoutDestinationUsersNestedInput
  }

  export type FbDestinationUserUncheckedUpdateWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    fbWallId?: IntFieldUpdateOperationsInput | number
    shareId?: IntFieldUpdateOperationsInput | number
  }

  export type FbPostCreateManyWallInput = {
    id?: number
    caption: string
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FbDestinationUserCreateManyWallInput = {
    id?: number
    shareId: number
    groupId: number
  }

  export type FbPostUpdateWithoutWallInput = {
    caption?: StringFieldUpdateOperationsInput | string
    user?: FbUserUpdateOneRequiredWithoutPostsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postImages?: FbPostImageUpdateManyWithoutPostNestedInput
    postVideoes?: FbPostVideoUpdateManyWithoutPostNestedInput
    postOnHashtags?: FbPostOnHashtagUpdateManyWithoutPostNestedInput
    shares?: FbShareUpdateManyWithoutPostNestedInput
    likes?: FbLikeUpdateManyWithoutPostNestedInput
  }

  export type FbPostUncheckedUpdateWithoutWallInput = {
    id?: IntFieldUpdateOperationsInput | number
    caption?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postImages?: FbPostImageUncheckedUpdateManyWithoutPostNestedInput
    postVideoes?: FbPostVideoUncheckedUpdateManyWithoutPostNestedInput
    postOnHashtags?: FbPostOnHashtagUncheckedUpdateManyWithoutPostNestedInput
    shares?: FbShareUncheckedUpdateManyWithoutPostNestedInput
    likes?: FbLikeUncheckedUpdateManyWithoutPostNestedInput
  }

  export type FbDestinationUserUpdateWithoutWallInput = {
    share?: FbShareUpdateOneRequiredWithoutDestinationUsersNestedInput
    group?: FbGroupUpdateOneRequiredWithoutDestinationUsersNestedInput
  }

  export type FbDestinationUserUncheckedUpdateWithoutWallInput = {
    id?: IntFieldUpdateOperationsInput | number
    shareId?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
  }

  export type KorKitchenMenuCreateManyCategoryInput = {
    id?: number
    name: string
    image: string
    price: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type KorKitchenMenuUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    orderItems?: KorKitchenOrderItemUpdateManyWithoutMenuNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KorKitchenMenuUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    orderItems?: KorKitchenOrderItemUncheckedUpdateManyWithoutMenuNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KorKitchenMenuUncheckedUpdateManyWithoutMenuInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KorKitchenOrderItemCreateManyMenuInput = {
    id?: number
    orderId?: number | null
    quantity: number
    totalPrice: number
    creatAt?: Date | string
    updatedAt?: Date | string
  }

  export type KorKitchenOrderItemUpdateWithoutMenuInput = {
    order?: KorKitchenOrderUpdateOneWithoutItemsNestedInput
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    creatAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KorKitchenOrderItemUncheckedUpdateWithoutMenuInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    creatAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KorKitchenOrderItemUncheckedUpdateManyWithoutOrderItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    creatAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KorKitchenOrderItemCreateManyOrderInput = {
    id?: number
    menuId: number
    quantity: number
    totalPrice: number
    creatAt?: Date | string
    updatedAt?: Date | string
  }

  export type KorKitchenOrderItemUpdateWithoutOrderInput = {
    menu?: KorKitchenMenuUpdateOneRequiredWithoutOrderItemsNestedInput
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    creatAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KorKitchenOrderItemUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    creatAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KorKitchenOrderItemUncheckedUpdateManyWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    creatAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TriviaQuestionCreateManyCategoryInput = {
    id?: number
    name: string
    answerID: number
  }

  export type TriviaRoundCreateManyCategoryInput = {
    id?: number
    user: string
    totalResult: number
    createAt?: Date | string
  }

  export type TriviaQuestionUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    answerID?: IntFieldUpdateOperationsInput | number
    choices?: TriviaChoiceUpdateManyWithoutQuestionNestedInput
    roundQuestions?: TriviaRoundQuestionUpdateManyWithoutQuestionNestedInput
  }

  export type TriviaQuestionUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    answerID?: IntFieldUpdateOperationsInput | number
    choices?: TriviaChoiceUncheckedUpdateManyWithoutQuestionNestedInput
    roundQuestions?: TriviaRoundQuestionUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type TriviaQuestionUncheckedUpdateManyWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    answerID?: IntFieldUpdateOperationsInput | number
  }

  export type TriviaRoundUpdateWithoutCategoryInput = {
    user?: StringFieldUpdateOperationsInput | string
    questions?: TriviaRoundQuestionUpdateManyWithoutRoundNestedInput
    totalResult?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TriviaRoundUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    questions?: TriviaRoundQuestionUncheckedUpdateManyWithoutRoundNestedInput
    totalResult?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TriviaRoundUncheckedUpdateManyWithoutRoundsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    totalResult?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TriviaChoiceCreateManyQuestionInput = {
    id?: number
    name: string
  }

  export type TriviaRoundQuestionCreateManyQuestionInput = {
    id?: number
    choiceId: number
    quizResult: boolean
    roundId?: number | null
  }

  export type TriviaChoiceUpdateWithoutQuestionInput = {
    name?: StringFieldUpdateOperationsInput | string
    roundQuestions?: TriviaRoundQuestionUpdateManyWithoutUserChoiceNestedInput
  }

  export type TriviaChoiceUncheckedUpdateWithoutQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    roundQuestions?: TriviaRoundQuestionUncheckedUpdateManyWithoutUserChoiceNestedInput
  }

  export type TriviaChoiceUncheckedUpdateManyWithoutChoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TriviaRoundQuestionUpdateWithoutQuestionInput = {
    userChoice?: TriviaChoiceUpdateOneRequiredWithoutRoundQuestionsNestedInput
    quizResult?: BoolFieldUpdateOperationsInput | boolean
    round?: TriviaRoundUpdateOneWithoutQuestionsNestedInput
  }

  export type TriviaRoundQuestionUncheckedUpdateWithoutQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    choiceId?: IntFieldUpdateOperationsInput | number
    quizResult?: BoolFieldUpdateOperationsInput | boolean
    roundId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TriviaRoundQuestionUncheckedUpdateManyWithoutRoundQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    choiceId?: IntFieldUpdateOperationsInput | number
    quizResult?: BoolFieldUpdateOperationsInput | boolean
    roundId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TriviaRoundQuestionCreateManyUserChoiceInput = {
    id?: number
    quizId: number
    quizResult: boolean
    roundId?: number | null
  }

  export type TriviaRoundQuestionUpdateWithoutUserChoiceInput = {
    question?: TriviaQuestionUpdateOneRequiredWithoutRoundQuestionsNestedInput
    quizResult?: BoolFieldUpdateOperationsInput | boolean
    round?: TriviaRoundUpdateOneWithoutQuestionsNestedInput
  }

  export type TriviaRoundQuestionUncheckedUpdateWithoutUserChoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    quizResult?: BoolFieldUpdateOperationsInput | boolean
    roundId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TriviaRoundQuestionCreateManyRoundInput = {
    id?: number
    quizId: number
    choiceId: number
    quizResult: boolean
  }

  export type TriviaRoundQuestionUpdateWithoutRoundInput = {
    question?: TriviaQuestionUpdateOneRequiredWithoutRoundQuestionsNestedInput
    userChoice?: TriviaChoiceUpdateOneRequiredWithoutRoundQuestionsNestedInput
    quizResult?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TriviaRoundQuestionUncheckedUpdateWithoutRoundInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    choiceId?: IntFieldUpdateOperationsInput | number
    quizResult?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TriviaRoundQuestionUncheckedUpdateManyWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    choiceId?: IntFieldUpdateOperationsInput | number
    quizResult?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TwitterFollowCreateManyFromInput = {
    id?: number
    toUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterFollowCreateManyToInput = {
    id?: number
    fromUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterPostCreateManyUserInput = {
    id?: number
    caption: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterDirectMessageCreateManyFromInput = {
    id?: number
    toUserId: number
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterDirectMessageCreateManyToInput = {
    id?: number
    fromUserId: number
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterCommentCreateManyUserInput = {
    id?: number
    text: string
    postId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterFollowUpdateWithoutFromInput = {
    to?: TwitterUserUpdateOneRequiredWithoutToFollowingNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterFollowUncheckedUpdateWithoutFromInput = {
    id?: IntFieldUpdateOperationsInput | number
    toUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterFollowUncheckedUpdateManyWithoutFromFollowingInput = {
    id?: IntFieldUpdateOperationsInput | number
    toUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterFollowUpdateWithoutToInput = {
    from?: TwitterUserUpdateOneRequiredWithoutFromFollowingNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterFollowUncheckedUpdateWithoutToInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterFollowUncheckedUpdateManyWithoutToFollowingInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterPostUpdateWithoutUserInput = {
    caption?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: TwitterCommentUpdateManyWithoutPostNestedInput
    postOnHashtags?: TwitterPostOnHashtagUpdateManyWithoutPostNestedInput
  }

  export type TwitterPostUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    caption?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: TwitterCommentUncheckedUpdateManyWithoutPostNestedInput
    postOnHashtags?: TwitterPostOnHashtagUncheckedUpdateManyWithoutPostNestedInput
  }

  export type TwitterPostUncheckedUpdateManyWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    caption?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterDirectMessageUpdateWithoutFromInput = {
    to?: TwitterUserUpdateOneRequiredWithoutToDirectMessageNestedInput
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterDirectMessageUncheckedUpdateWithoutFromInput = {
    id?: IntFieldUpdateOperationsInput | number
    toUserId?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterDirectMessageUncheckedUpdateManyWithoutFromDirectMessageInput = {
    id?: IntFieldUpdateOperationsInput | number
    toUserId?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterDirectMessageUpdateWithoutToInput = {
    from?: TwitterUserUpdateOneRequiredWithoutFromDirectMessageNestedInput
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterDirectMessageUncheckedUpdateWithoutToInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromUserId?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterDirectMessageUncheckedUpdateManyWithoutToDirectMessageInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromUserId?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterCommentUpdateWithoutUserInput = {
    text?: StringFieldUpdateOperationsInput | string
    post?: TwitterPostUpdateOneRequiredWithoutCommentsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterCommentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    postId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterCommentUncheckedUpdateManyWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    postId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterCommentCreateManyPostInput = {
    id?: number
    text: string
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterPostOnHashtagCreateManyPostInput = {
    id?: number
    hashtagId: number
  }

  export type TwitterCommentUpdateWithoutPostInput = {
    text?: StringFieldUpdateOperationsInput | string
    user?: TwitterUserUpdateOneRequiredWithoutCommentsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterCommentUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterPostOnHashtagUpdateWithoutPostInput = {
    hashtag?: TwitterHashtagUpdateOneRequiredWithoutPostOnHashtagNestedInput
  }

  export type TwitterPostOnHashtagUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    hashtagId?: IntFieldUpdateOperationsInput | number
  }

  export type TwitterPostOnHashtagUncheckedUpdateManyWithoutPostOnHashtagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    hashtagId?: IntFieldUpdateOperationsInput | number
  }

  export type TwitterPostOnHashtagCreateManyHashtagInput = {
    id?: number
    postId: number
  }

  export type TwitterPostOnHashtagUpdateWithoutHashtagInput = {
    post?: TwitterPostUpdateOneRequiredWithoutPostOnHashtagsNestedInput
  }

  export type TwitterPostOnHashtagUncheckedUpdateWithoutHashtagInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
  }

  export type TwitterPostOnHashtagUncheckedUpdateManyWithoutPostOnHashtagInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
  }

  export type WSTopupHistoryCreateManyUserInput = {
    id?: number
    topup: number
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type WSUsingHistoryCreateManyUserInput = {
    id?: number
    price: number
    createdAt?: Date | string
    updateAt?: Date | string
    usingStartAt: Date | string
    finishingAt: Date | string
    wSMachineId: number
    wSProgramId: number
  }

  export type WSTopupHistoryUpdateWithoutUserInput = {
    topup?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WSTopupHistoryUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    topup?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WSTopupHistoryUncheckedUpdateManyWithoutTopupHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    topup?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WSUsingHistoryUpdateWithoutUserInput = {
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    machine?: WSMachineUpdateOneRequiredWithoutUsingHistoriesNestedInput
    program?: WSProgramUpdateOneRequiredWithoutUsingHistoriesNestedInput
    usingStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishingAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WSUsingHistoryUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usingStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishingAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wSMachineId?: IntFieldUpdateOperationsInput | number
    wSProgramId?: IntFieldUpdateOperationsInput | number
  }

  export type WSUsingHistoryUncheckedUpdateManyWithoutUsingHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usingStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishingAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wSMachineId?: IntFieldUpdateOperationsInput | number
    wSProgramId?: IntFieldUpdateOperationsInput | number
  }

  export type WSMachineCreateManyShopInput = {
    id?: number
    brandname: string
    size: string
    type: string
    model: string
    producedDate: string
    insuranceExpiredDate: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type WSMachineUpdateWithoutShopInput = {
    brandname?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    producedDate?: StringFieldUpdateOperationsInput | string
    insuranceExpiredDate?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    machineToPrograms?: MachineToProgramUpdateManyWithoutMachingNestedInput
    maintains?: WSMaintainUpdateManyWithoutMachineNestedInput
    usingHistories?: WSUsingHistoryUpdateManyWithoutMachineNestedInput
  }

  export type WSMachineUncheckedUpdateWithoutShopInput = {
    id?: IntFieldUpdateOperationsInput | number
    brandname?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    producedDate?: StringFieldUpdateOperationsInput | string
    insuranceExpiredDate?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    machineToPrograms?: MachineToProgramUncheckedUpdateManyWithoutMachingNestedInput
    maintains?: WSMaintainUncheckedUpdateManyWithoutMachineNestedInput
    usingHistories?: WSUsingHistoryUncheckedUpdateManyWithoutMachineNestedInput
  }

  export type WSMachineUncheckedUpdateManyWithoutMachinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    brandname?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    producedDate?: StringFieldUpdateOperationsInput | string
    insuranceExpiredDate?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineToProgramCreateManyMachingInput = {
    id?: number
    programId: number
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type WSMaintainCreateManyMachineInput = {
    id?: number
    checker: string
    item: string
    status: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type WSUsingHistoryCreateManyMachineInput = {
    id?: number
    userId: number
    price: number
    createdAt?: Date | string
    updateAt?: Date | string
    usingStartAt: Date | string
    finishingAt: Date | string
    wSProgramId: number
  }

  export type MachineToProgramUpdateWithoutMachingInput = {
    program?: WSProgramUpdateOneRequiredWithoutMachineToProgramsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineToProgramUncheckedUpdateWithoutMachingInput = {
    id?: IntFieldUpdateOperationsInput | number
    programId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineToProgramUncheckedUpdateManyWithoutMachineToProgramsInput = {
    id?: IntFieldUpdateOperationsInput | number
    programId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WSMaintainUpdateWithoutMachineInput = {
    checker?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WSMaintainUncheckedUpdateWithoutMachineInput = {
    id?: IntFieldUpdateOperationsInput | number
    checker?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WSMaintainUncheckedUpdateManyWithoutMaintainsInput = {
    id?: IntFieldUpdateOperationsInput | number
    checker?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WSUsingHistoryUpdateWithoutMachineInput = {
    user?: WSUserUpdateOneRequiredWithoutUsingHistoriesNestedInput
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    program?: WSProgramUpdateOneRequiredWithoutUsingHistoriesNestedInput
    usingStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishingAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WSUsingHistoryUncheckedUpdateWithoutMachineInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usingStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishingAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wSProgramId?: IntFieldUpdateOperationsInput | number
  }

  export type MachineToProgramCreateManyProgramInput = {
    id?: number
    machineId: number
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type WSProgramDetailCreateManyProgramInput = {
    id?: number
    price: number
    duration: number
    weight: number
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type WSUsingHistoryCreateManyProgramInput = {
    id?: number
    userId: number
    price: number
    createdAt?: Date | string
    updateAt?: Date | string
    usingStartAt: Date | string
    finishingAt: Date | string
    wSMachineId: number
  }

  export type MachineToProgramUpdateWithoutProgramInput = {
    maching?: WSMachineUpdateOneRequiredWithoutMachineToProgramsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineToProgramUncheckedUpdateWithoutProgramInput = {
    id?: IntFieldUpdateOperationsInput | number
    machineId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WSProgramDetailUpdateWithoutProgramInput = {
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    weight?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programs?: WSProgramUpdateManyWithoutActiveProgramNestedInput
  }

  export type WSProgramDetailUncheckedUpdateWithoutProgramInput = {
    id?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    weight?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programs?: WSProgramUncheckedUpdateManyWithoutActiveProgramNestedInput
  }

  export type WSProgramDetailUncheckedUpdateManyWithoutProgramListsInput = {
    id?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    weight?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WSUsingHistoryUpdateWithoutProgramInput = {
    user?: WSUserUpdateOneRequiredWithoutUsingHistoriesNestedInput
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    machine?: WSMachineUpdateOneRequiredWithoutUsingHistoriesNestedInput
    usingStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishingAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WSUsingHistoryUncheckedUpdateWithoutProgramInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usingStartAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishingAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wSMachineId?: IntFieldUpdateOperationsInput | number
  }

  export type WSProgramCreateManyActiveProgramInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type WSProgramUpdateWithoutActiveProgramInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    machineToPrograms?: MachineToProgramUpdateManyWithoutProgramNestedInput
    programLists?: WSProgramDetailUpdateManyWithoutProgramNestedInput
    usingHistories?: WSUsingHistoryUpdateManyWithoutProgramNestedInput
  }

  export type WSProgramUncheckedUpdateWithoutActiveProgramInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    machineToPrograms?: MachineToProgramUncheckedUpdateManyWithoutProgramNestedInput
    programLists?: WSProgramDetailUncheckedUpdateManyWithoutProgramNestedInput
    usingHistories?: WSUsingHistoryUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type WSProgramUncheckedUpdateManyWithoutProgramsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToChannelCreateManyUserInput = {
    id?: number
    channelId: number
    role: YTRoleEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YTCommentCreateManyUserInput = {
    id?: number
    text: string
    commentTo?: number | null
    videoId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YTSubscribeCreateManyUserInput = {
    id?: number
    channelId: number
    member: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YTShareCreateManyUserInput = {
    id?: number
    videoId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToChannelUpdateWithoutUserInput = {
    channel?: YTChannelUpdateOneRequiredWithoutUserToChannelsNestedInput
    role?: EnumYTRoleEnumFieldUpdateOperationsInput | YTRoleEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToChannelUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    channelId?: IntFieldUpdateOperationsInput | number
    role?: EnumYTRoleEnumFieldUpdateOperationsInput | YTRoleEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToChannelUncheckedUpdateManyWithoutUserToChannelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    channelId?: IntFieldUpdateOperationsInput | number
    role?: EnumYTRoleEnumFieldUpdateOperationsInput | YTRoleEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YTCommentUpdateWithoutUserInput = {
    text?: StringFieldUpdateOperationsInput | string
    commentTo?: NullableIntFieldUpdateOperationsInput | number | null
    video?: YTVideoUpdateOneRequiredWithoutCommentsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: YTLikeUpdateManyWithoutCommentNestedInput
  }

  export type YTCommentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    commentTo?: NullableIntFieldUpdateOperationsInput | number | null
    videoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: YTLikeUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type YTCommentUncheckedUpdateManyWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    commentTo?: NullableIntFieldUpdateOperationsInput | number | null
    videoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YTSubscribeUpdateWithoutUserInput = {
    channel?: YTChannelUpdateOneRequiredWithoutSubscribesNestedInput
    member?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YTSubscribeUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    channelId?: IntFieldUpdateOperationsInput | number
    member?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YTSubscribeUncheckedUpdateManyWithoutSubscribesInput = {
    id?: IntFieldUpdateOperationsInput | number
    channelId?: IntFieldUpdateOperationsInput | number
    member?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YTShareUpdateWithoutUserInput = {
    video?: YTVideoUpdateOneRequiredWithoutSharesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YTShareUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    videoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YTShareUncheckedUpdateManyWithoutSharesInput = {
    id?: IntFieldUpdateOperationsInput | number
    videoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToChannelCreateManyChannelInput = {
    id?: number
    userId: number
    role: YTRoleEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YTVideoCreateManyChannelInput = {
    id?: number
    name: string
    file: string
    logo: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YTSubscribeCreateManyChannelInput = {
    id?: number
    userId: number
    member: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToChannelUpdateWithoutChannelInput = {
    user?: YTUserUpdateOneRequiredWithoutUserToChannelsNestedInput
    role?: EnumYTRoleEnumFieldUpdateOperationsInput | YTRoleEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToChannelUncheckedUpdateWithoutChannelInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: EnumYTRoleEnumFieldUpdateOperationsInput | YTRoleEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YTVideoUpdateWithoutChannelInput = {
    name?: StringFieldUpdateOperationsInput | string
    file?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: YTLikeUpdateManyWithoutVideoNestedInput
    comments?: YTCommentUpdateManyWithoutVideoNestedInput
    shares?: YTShareUpdateManyWithoutVideoNestedInput
  }

  export type YTVideoUncheckedUpdateWithoutChannelInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    file?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: YTLikeUncheckedUpdateManyWithoutVideoNestedInput
    comments?: YTCommentUncheckedUpdateManyWithoutVideoNestedInput
    shares?: YTShareUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type YTVideoUncheckedUpdateManyWithoutVideosInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    file?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YTSubscribeUpdateWithoutChannelInput = {
    user?: YTUserUpdateOneRequiredWithoutSubscribesNestedInput
    member?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YTSubscribeUncheckedUpdateWithoutChannelInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    member?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YTLikeCreateManyVideoInput = {
    id?: number
    type: string
    commentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YTCommentCreateManyVideoInput = {
    id?: number
    text: string
    userId: number
    commentTo?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YTShareCreateManyVideoInput = {
    id?: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YTLikeUpdateWithoutVideoInput = {
    type?: StringFieldUpdateOperationsInput | string
    comment?: YTCommentUpdateOneRequiredWithoutLikesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YTLikeUncheckedUpdateWithoutVideoInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    commentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YTLikeUncheckedUpdateManyWithoutLikesInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    commentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YTCommentUpdateWithoutVideoInput = {
    text?: StringFieldUpdateOperationsInput | string
    user?: YTUserUpdateOneRequiredWithoutCommentsNestedInput
    commentTo?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: YTLikeUpdateManyWithoutCommentNestedInput
  }

  export type YTCommentUncheckedUpdateWithoutVideoInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    commentTo?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: YTLikeUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type YTShareUpdateWithoutVideoInput = {
    user?: YTUserUpdateOneRequiredWithoutSharesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YTShareUncheckedUpdateWithoutVideoInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YTLikeCreateManyCommentInput = {
    id?: number
    type: string
    videoId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YTLikeUpdateWithoutCommentInput = {
    type?: StringFieldUpdateOperationsInput | string
    video?: YTVideoUpdateOneRequiredWithoutLikesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YTLikeUncheckedUpdateWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    videoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}